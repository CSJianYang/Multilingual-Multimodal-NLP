[
    {
        "title": "Minimum Area Rectangle II",
        "question_content": "You are given an array of points in the X-Y plane points where points[i] = [xi, yi].\nReturn the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the X and Y axes. If there is not any such rectangle, return 0.\nAnswers within 10-5 of the actual answer will be accepted.\n&nbsp;\nExample 1:\n\nInput: points = [[1,2],[2,1],[1,0],[0,1]]\nOutput: 2.00000\nExplanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.\n\nExample 2:\n\nInput: points = [[0,1],[2,1],[1,1],[1,0],[2,0]]\nOutput: 1.00000\nExplanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.\n\nExample 3:\n\nInput: points = [[0,3],[1,2],[3,1],[1,3],[2,1]]\nOutput: 0\nExplanation: There is no possible rectangle to form from these points.\n\n&nbsp;\nConstraints:\n\n\t1 <= points.length <= 50\n\tpoints[i].length == 2\n\t0 <= xi, yi <= 4 * 104\n\tAll the given points are unique.",
        "solutions": [
            {
                "id": 208361,
                "title": "java-o-n-2-using-map",
                "content": "1. Two diagonals of a rectangle bisect each other, and are of equal length.\\n2. The map\\'s key is String including diagonal length and coordinate of the diagonal center; map\\'s value is the index of two points forming the diagonal.\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int len = points.length;\\n        double res = Double.MAX_VALUE;\\n        if (len < 4) return 0.0;\\n        Map<String, List<int[]>> map = new HashMap<>(); // int[] is the index of two points forming the diagonal\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                long dis = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                double centerX = (double)(points[j][0] + points[i][0])/2; // centerX and centerY is the coordinate of the diagonal center\\n                double centerY = (double)(points[j][1] + points[i][1])/2;\\n                String key = \"\" + dis + \"+\" + centerX + \"+\" + centerY; // key includes the length of the diagonal and the coordinate of the diagonal center\\n                if (map.get(key) == null) map.put(key, new ArrayList<int[]>());\\n                map.get(key).add(new int[]{i,j});\\n            }\\n        }\\n        for (String key : map.keySet()) {\\n            if (map.get(key).size() > 1) {  \\n                List<int[]> list = map.get(key);\\n                for (int i = 0; i < list.size(); i++) { // there could be multiple rectangles inside\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        int p1 = list.get(i)[0]; // p1, p2 and p3 are the three vertices of a rectangle\\n                        int p2 = list.get(j)[0];\\n                        int p3 = list.get(j)[1];\\n                        // len1 and len2 are the length of the sides of a rectangle\\n                        double len1 = Math.sqrt((points[p1][0] - points[p2][0]) * (points[p1][0] - points[p2][0]) +  (points[p1][1] - points[p2][1]) * (points[p1][1] - points[p2][1])); \\n                        double len2 = Math.sqrt((points[p1][0] - points[p3][0]) * (points[p1][0] - points[p3][0]) +  (points[p1][1] - points[p3][1]) * (points[p1][1] - points[p3][1]));\\n                        double area = len1 * len2; \\n                        res = Math.min(res, area);\\n                    }\\n                }\\n            }\\n        }\\n        return res == Double.MAX_VALUE ?  0.0 : res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int len = points.length;\\n        double res = Double.MAX_VALUE;\\n        if (len < 4) return 0.0;\\n        Map<String, List<int[]>> map = new HashMap<>(); // int[] is the index of two points forming the diagonal\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                long dis = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                double centerX = (double)(points[j][0] + points[i][0])/2; // centerX and centerY is the coordinate of the diagonal center\\n                double centerY = (double)(points[j][1] + points[i][1])/2;\\n                String key = \"\" + dis + \"+\" + centerX + \"+\" + centerY; // key includes the length of the diagonal and the coordinate of the diagonal center\\n                if (map.get(key) == null) map.put(key, new ArrayList<int[]>());\\n                map.get(key).add(new int[]{i,j});\\n            }\\n        }\\n        for (String key : map.keySet()) {\\n            if (map.get(key).size() > 1) {  \\n                List<int[]> list = map.get(key);\\n                for (int i = 0; i < list.size(); i++) { // there could be multiple rectangles inside\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        int p1 = list.get(i)[0]; // p1, p2 and p3 are the three vertices of a rectangle\\n                        int p2 = list.get(j)[0];\\n                        int p3 = list.get(j)[1];\\n                        // len1 and len2 are the length of the sides of a rectangle\\n                        double len1 = Math.sqrt((points[p1][0] - points[p2][0]) * (points[p1][0] - points[p2][0]) +  (points[p1][1] - points[p2][1]) * (points[p1][1] - points[p2][1])); \\n                        double len2 = Math.sqrt((points[p1][0] - points[p3][0]) * (points[p1][0] - points[p3][0]) +  (points[p1][1] - points[p3][1]) * (points[p1][1] - points[p3][1]));\\n                        double area = len1 * len2; \\n                        res = Math.min(res, area);\\n                    }\\n                }\\n            }\\n        }\\n        return res == Double.MAX_VALUE ?  0.0 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210786,
                "title": "c-with-picture-find-diagonals-o-n-n",
                "content": "Diagonals of a rectangle are intersecting in the middle point. For any pair of points (our first potential diagonal) ```{xi, yi} - {xj, yj}```, we find and track the middle point ```{x0, y0}```. Any other pair of points with the same middle point is the second potential diagonal.\\n\\nI am using the hash map for O(1) lookups, and I compressing ```{x0, y0}``` coordinates into a single integer for the simplicity.\\n![image](https://assets.leetcode.com/users/votrubac/image_1546066215.png)\\nAfter we processed all pair of points this way, we analyze potential diagonals for each middle point. We form two sides of the potential rectangle as ```{x11, y11} - {x21, y21}``` and ```{x11, y11} - {x22, y22}```, and check if they are orthogonal (perpendicular). If so, we calculate the area and track the smallest one.\\n```\\nsize_t d2(int x1, int y1, int x2, int y2) { \\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, vector<vector<int>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      m[center].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it = begin(m); it != end(m); ++it)\\n    for (auto i = 0; i < it->second.size(); ++i)\\n      for (auto j = i + 1; j < it->second.size(); ++j) {\\n        auto &p1 = it->second[i], &p2 = it->second[j];\\n        if ((p1[0] - p2[0]) * (p1[0] - p2[2]) + (p1[1] - p2[1]) * (p1[1] - p2[3]) == 0) {\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n      }\\n  return sqrt(res);\\n}\\n```\\nAs an alternative, we can track both the center and length of the diagonals in the hash map (only diagonals with the same length can form a rectangle). That way we can potentially reduce the number of diagonals to compare. We also do not need to do the orthogonality check anymore.\\n\\nThanks [@kaiwensun](https://leetcode.com/kaiwensun/) for this interesting idea.\\n```\\nsize_t d2(int x1, int y1, int x2, int y2) {\\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, unordered_map<size_t, vector<vector<int>>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      auto len = d2(ps[i][0], ps[i][1], ps[j][0], ps[j][1]);\\n      m[center][len].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it_c = begin(m); it_c != end(m); ++it_c)\\n    for (auto it_l = begin(it_c->second); it_l != end(it_c->second); ++it_l)\\n      for (auto i = 0; i < it_l->second.size(); ++i)\\n        for (auto j = i + 1; j < it_l->second.size(); ++j) {\\n          auto &p1 = it_l->second[i], &p2 = it_l->second[j];\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n  return sqrt(res);\\n}\\n```",
                "solutionTags": [],
                "code": "```{xi, yi} - {xj, yj}```\n```{x0, y0}```\n```{x0, y0}```\n```{x11, y11} - {x21, y21}```\n```{x11, y11} - {x22, y22}```\n```\\nsize_t d2(int x1, int y1, int x2, int y2) { \\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, vector<vector<int>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      m[center].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it = begin(m); it != end(m); ++it)\\n    for (auto i = 0; i < it->second.size(); ++i)\\n      for (auto j = i + 1; j < it->second.size(); ++j) {\\n        auto &p1 = it->second[i], &p2 = it->second[j];\\n        if ((p1[0] - p2[0]) * (p1[0] - p2[2]) + (p1[1] - p2[1]) * (p1[1] - p2[3]) == 0) {\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n      }\\n  return sqrt(res);\\n}\\n```\n```\\nsize_t d2(int x1, int y1, int x2, int y2) {\\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, unordered_map<size_t, vector<vector<int>>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      auto len = d2(ps[i][0], ps[i][1], ps[j][0], ps[j][1]);\\n      m[center][len].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it_c = begin(m); it_c != end(m); ++it_c)\\n    for (auto it_l = begin(it_c->second); it_l != end(it_c->second); ++it_l)\\n      for (auto i = 0; i < it_l->second.size(); ++i)\\n        for (auto j = i + 1; j < it_l->second.size(); ++j) {\\n          auto &p1 = it_l->second[i], &p2 = it_l->second[j];\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n  return sqrt(res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208470,
                "title": "java-o-n-3-bruteforce",
                "content": "1. Iterate 3 points.\\n2. Find the last point.\\n3. Calculate the area.\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Set<String> set = new HashSet<>();\\n        for (int[] p : points) {\\n            set.add(p[0] + \" \" + p[1]);\\n        }\\n        double result = Double.MAX_VALUE;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points) {\\n                if (p1[0] == p2[0] && p1[1] == p2[1]) {\\n                    continue;\\n                }\\n                for (int[] p3 : points) {\\n                    if (dist(p1, p3) + dist(p2, p3) != dist(p1, p2)) {\\n                        continue;\\n                    }\\n                    int x = p1[0] + p2[0] - p3[0];\\n                    int y = p1[1] + p2[1] - p3[1];\\n                    if (!set.contains(x + \" \" + y)) {\\n                        continue;\\n                    }\\n                    double area = Math.sqrt(dist(p1, p3)) * Math.sqrt(dist(p2, p3));\\n                    if (Double.compare(area, 0) == 0) {\\n                        continue;\\n                    }\\n                    result = Math.min(result, area);\\n                }\\n            }\\n        }\\n        return Double.compare(Double.MAX_VALUE, result) == 0 ? 0 : result;\\n    }\\n    private int dist(int[] p1, int[] p2) {\\n        return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Set<String> set = new HashSet<>();\\n        for (int[] p : points) {\\n            set.add(p[0] + \" \" + p[1]);\\n        }\\n        double result = Double.MAX_VALUE;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points) {\\n                if (p1[0] == p2[0] && p1[1] == p2[1]) {\\n                    continue;\\n                }\\n                for (int[] p3 : points) {\\n                    if (dist(p1, p3) + dist(p2, p3) != dist(p1, p2)) {\\n                        continue;\\n                    }\\n                    int x = p1[0] + p2[0] - p3[0];\\n                    int y = p1[1] + p2[1] - p3[1];\\n                    if (!set.contains(x + \" \" + y)) {\\n                        continue;\\n                    }\\n                    double area = Math.sqrt(dist(p1, p3)) * Math.sqrt(dist(p2, p3));\\n                    if (Double.compare(area, 0) == 0) {\\n                        continue;\\n                    }\\n                    result = Math.min(result, area);\\n                }\\n            }\\n        }\\n        return Double.compare(Double.MAX_VALUE, result) == 0 ? 0 : result;\\n    }\\n    private int dist(int[] p1, int[] p2) {\\n        return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208377,
                "title": "python-easy-to-understand-dot-product-o-n-3-ac",
                "content": "* Dot product of two sides in a rectangle should be zero  because a . b = |a| |b| cos(90)\\n* If we can extend p3 by the same margin delta(p2 - p1), we can have the fourth point p4.\\n\\t* x4 = x3 + (x2 - x1)\\n\\t* y4 = y3 + (y2 - y1)\\n* If p4 in points, calculate area.\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        mn, st, n = float(\\'inf\\'), {(x, y) for x, y in points}, len(points) \\n        for i in range(n):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, n):\\n                x2, y2 = points[j]\\n                for k in range(j + 1, n):\\n                    x3, y3 = points[k]\\n                    if not (x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1) and (x3 + (x2 - x1), y3 + (y2 - y1)) in st:\\n                        mn = min(mn, ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 * ((x3 - x1) ** 2 + (y3 - y1) ** 2) ** 0.5)\\n        return mn if mn < float(\"inf\") else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        mn, st, n = float(\\'inf\\'), {(x, y) for x, y in points}, len(points) \\n        for i in range(n):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, n):\\n                x2, y2 = points[j]\\n                for k in range(j + 1, n):\\n                    x3, y3 = points[k]\\n                    if not (x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1) and (x3 + (x2 - x1), y3 + (y2 - y1)) in st:\\n                        mn = min(mn, ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 * ((x3 - x1) ** 2 + (y3 - y1) ** 2) ** 0.5)\\n        return mn if mn < float(\"inf\") else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980956,
                "title": "python3-center-point-o-n-2",
                "content": "**Algo**\\nUse a 2-layer nested loops to scan through pair of points `(x0, y0)` and `(x1, y1)`. The key features extracted from this pair are center and length `(cx, cy, d2)`. Those points with the same center and length form rectangles. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        ans = inf\\n        seen = {}\\n        for i, (x0, y0) in enumerate(points):\\n            for x1, y1 in points[i+1:]:\\n                cx = (x0 + x1)/2\\n                cy = (y0 + y1)/2\\n                d2 = (x0 - x1)**2 + (y0 - y1)**2\\n                for xx, yy in seen.get((cx, cy, d2), []): \\n                    area = sqrt(((x0-xx)**2 + (y0-yy)**2) * ((x1-xx)**2 + (y1-yy)**2))\\n                    ans = min(ans, area)\\n                seen.setdefault((cx, cy, d2), []).append((x0, y0))\\n        return ans if ans < inf else 0\\n```\\n\\n**Analysis**\\nTime complexity `O(N^2)`\\nSpace complexity `O(N^2)`\\n\\nThe worse case of this approach is `O(N^3)`. Imagine that all points are distributed on a circle. In this case, one could find `N/2` pairs whose center is at the center of the circle. In extreme cases like this, one would have `O(N^3)` performance. But on average, `O(N^2)` can be expected.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        ans = inf\\n        seen = {}\\n        for i, (x0, y0) in enumerate(points):\\n            for x1, y1 in points[i+1:]:\\n                cx = (x0 + x1)/2\\n                cy = (y0 + y1)/2\\n                d2 = (x0 - x1)**2 + (y0 - y1)**2\\n                for xx, yy in seen.get((cx, cy, d2), []): \\n                    area = sqrt(((x0-xx)**2 + (y0-yy)**2) * ((x1-xx)**2 + (y1-yy)**2))\\n                    ans = min(ans, area)\\n                seen.setdefault((cx, cy, d2), []).append((x0, y0))\\n        return ans if ans < inf else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477751,
                "title": "clean-python-solution-with-explanation",
                "content": "The key insight is that four points `point1, point2, point3, point4` can form a rectangle if and only if\\n* the distance between `point1` and `point2` equals the distance between `point3` and `point4`\\n* the midpoint of `point1` and `point2` equals the midpoint of `point3` and `point4`.\\n\\nIn the following implementation, I use a dictionary to store all pairs of points that have the same `distance` and `midpoint`. \\n\\n```python\\n\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        diagonal_and_midpoints = defaultdict(list)\\n        for point1, point2 in self._generate_distinct_pairs(points):\\n            diagonal = self._get_distance(point1, point2)\\n            midpoint = self._get_midpoint(point1, point2)\\n            diagonal_and_midpoints[(diagonal, midpoint)].append((point1, point2))\\n        return min(\\n            (self._get_area(pair1, pair2)\\n             for pairs in diagonal_and_midpoints.values()\\n             for pair1, pair2 in self._generate_distinct_pairs(pairs)),\\n            default=0)\\n\\n    def _generate_distinct_pairs(self, items):\\n        for i in range(len(items)):\\n            for j in range(i+1, len(items)):\\n                yield items[i], items[j]\\n    \\n    def _get_midpoint(self, point1, point2):\\n        (x1, y1), (x2, y2) = point1, point2\\n        return (x1 + x2) / 2, (y1 + y2) / 2\\n\\n    def _get_area(self, pair1, pair2) -> float:\\n        (point1, _), (point3, point4) = pair1, pair2\\n        return self._get_distance(point1, point3) * self._get_distance(point1, point4)\\n    \\n    def _get_distance(self, point1, point2) -> float:\\n        x1, y1 = point1\\n        x2, y2 = point2\\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\n\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        diagonal_and_midpoints = defaultdict(list)\\n        for point1, point2 in self._generate_distinct_pairs(points):\\n            diagonal = self._get_distance(point1, point2)\\n            midpoint = self._get_midpoint(point1, point2)\\n            diagonal_and_midpoints[(diagonal, midpoint)].append((point1, point2))\\n        return min(\\n            (self._get_area(pair1, pair2)\\n             for pairs in diagonal_and_midpoints.values()\\n             for pair1, pair2 in self._generate_distinct_pairs(pairs)),\\n            default=0)\\n\\n    def _generate_distinct_pairs(self, items):\\n        for i in range(len(items)):\\n            for j in range(i+1, len(items)):\\n                yield items[i], items[j]\\n    \\n    def _get_midpoint(self, point1, point2):\\n        (x1, y1), (x2, y2) = point1, point2\\n        return (x1 + x2) / 2, (y1 + y2) / 2\\n\\n    def _get_area(self, pair1, pair2) -> float:\\n        (point1, _), (point3, point4) = pair1, pair2\\n        return self._get_distance(point1, point3) * self._get_distance(point1, point4)\\n    \\n    def _get_distance(self, point1, point2) -> float:\\n        x1, y1 = point1\\n        x2, y2 = point2\\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209117,
                "title": "short-java-solution",
                "content": "```\\n    public double minAreaFreeRect(int[][] p) {\\n        Map<String, List<int[]>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < p.length; i++) {\\n            for(int j = i + 1; j < p.length; j++) {\\n                double x = (p[i][0] + p[j][0]) / 2.0;\\n                double y = (p[i][1] + p[j][1]) / 2.0;\\n                String key = x + \",\"+ y + \",\" + getDist(p, i, j);\\n                map.putIfAbsent(key, new ArrayList<>());\\n                map.get(key).add(new int[]{i, j});\\n            }\\n        }\\n        \\n        \\n        double res = Double.MAX_VALUE;\\n        for(List<int[]> l : map.values()) {\\n            for(int i = 0; i < l.size(); i++) {\\n                for(int j = i + 1; j < l.size(); j++) {\\n                    res = Math.min(res, getArea(p, l.get(i), l.get(j)));\\n                }\\n            }\\n        }\\n        \\n        return res == Double.MAX_VALUE ? 0 : res;\\n    }\\n    \\n    int getDist(int[][] p, int i, int j) {\\n        return (p[i][0]-p[j][0])*(p[i][0]-p[j][0]) + (p[i][1]-p[j][1])*(p[i][1]-p[j][1]);\\n    }\\n    \\n    double getArea(int[][] p, int[] a, int[] b) {\\n        int dis1 = getDist(p, a[0], b[0]);\\n        int dis2 = getDist(p, a[0], b[1]);\\n        return Math.sqrt(dis1) * Math.sqrt(dis2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double minAreaFreeRect(int[][] p) {\\n        Map<String, List<int[]>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < p.length; i++) {\\n            for(int j = i + 1; j < p.length; j++) {\\n                double x = (p[i][0] + p[j][0]) / 2.0;\\n                double y = (p[i][1] + p[j][1]) / 2.0;\\n                String key = x + \",\"+ y + \",\" + getDist(p, i, j);\\n                map.putIfAbsent(key, new ArrayList<>());\\n                map.get(key).add(new int[]{i, j});\\n            }\\n        }\\n        \\n        \\n        double res = Double.MAX_VALUE;\\n        for(List<int[]> l : map.values()) {\\n            for(int i = 0; i < l.size(); i++) {\\n                for(int j = i + 1; j < l.size(); j++) {\\n                    res = Math.min(res, getArea(p, l.get(i), l.get(j)));\\n                }\\n            }\\n        }\\n        \\n        return res == Double.MAX_VALUE ? 0 : res;\\n    }\\n    \\n    int getDist(int[][] p, int i, int j) {\\n        return (p[i][0]-p[j][0])*(p[i][0]-p[j][0]) + (p[i][1]-p[j][1])*(p[i][1]-p[j][1]);\\n    }\\n    \\n    double getArea(int[][] p, int[] a, int[] b) {\\n        int dis1 = getDist(p, a[0], b[0]);\\n        int dis2 = getDist(p, a[0], b[1]);\\n        return Math.sqrt(dis1) * Math.sqrt(dis2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208351,
                "title": "python-complex",
                "content": "It will be O(N^3) in worst cases.  O(N^2) in average.\\n\\n**Python:**\\n```\\n    def minAreaFreeRect(self, points):\\n        points = [complex(*z) for z in sorted(points)]\\n        seen = collections.defaultdict(list)\\n        for P, Q in itertools.combinations(points, 2):\\n            seen[Q - P].append((P + Q) / 2)\\n\\n        ans = float(\"inf\")\\n        for A, candidates in seen.iteritems():\\n            for P, Q in itertools.combinations(candidates, 2):\\n                if A.real * (P - Q).real == -A.imag * (P - Q).imag:\\n                    ans = min(ans, abs(A) * abs(P - Q))\\n        return ans if ans < float(\"inf\") else 0\\n```",
                "solutionTags": [],
                "code": "```\\n    def minAreaFreeRect(self, points):\\n        points = [complex(*z) for z in sorted(points)]\\n        seen = collections.defaultdict(list)\\n        for P, Q in itertools.combinations(points, 2):\\n            seen[Q - P].append((P + Q) / 2)\\n\\n        ans = float(\"inf\")\\n        for A, candidates in seen.iteritems():\\n            for P, Q in itertools.combinations(candidates, 2):\\n                if A.real * (P - Q).real == -A.imag * (P - Q).imag:\\n                    ans = min(ans, abs(A) * abs(P - Q))\\n        return ans if ans < float(\"inf\") else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 208384,
                "title": "c-o-n-3-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string getKey(int a, int b) {\\n        return to_string(a) + \"_\" + to_string(b);\\n    }\\n    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_set<string> us;\\n        for (auto &p: points) {\\n            us.insert(getKey(p[0], p[1]));\\n        }\\n        double ans = 0;\\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = 0; j < points.size(); ++j) {\\n                for (int k = j + 1; k < points.size(); ++k) {\\n                    if (i == j || i == k) continue;\\n                    int x1 = points[i][0], y1 = points[i][1];\\n                    int x2 = points[j][0], y2 = points[j][1];\\n                    int x3 = points[k][0], y3 = points[k][1];\\n                    if ((x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1) != 0) continue;\\n                    int x4 = x2 + x3 - x1, y4 = y2 + y3 - y1;\\n                    if (us.count(getKey(x4, y4))) {\\n                        double w = pow(pow(x2 - x1, 2) + pow(y2 - y1, 2), 0.5);\\n                        double l = pow(pow(x3 - x1, 2) + pow(y3 - y1, 2), 0.5);\\n                        double area = w * l;\\n                        if (ans == 0 || area != 0 && area < ans) {\\n                            ans = area;   \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getKey(int a, int b) {\\n        return to_string(a) + \"_\" + to_string(b);\\n    }\\n    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_set<string> us;\\n        for (auto &p: points) {\\n            us.insert(getKey(p[0], p[1]));\\n        }\\n        double ans = 0;\\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = 0; j < points.size(); ++j) {\\n                for (int k = j + 1; k < points.size(); ++k) {\\n                    if (i == j || i == k) continue;\\n                    int x1 = points[i][0], y1 = points[i][1];\\n                    int x2 = points[j][0], y2 = points[j][1];\\n                    int x3 = points[k][0], y3 = points[k][1];\\n                    if ((x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1) != 0) continue;\\n                    int x4 = x2 + x3 - x1, y4 = y2 + y3 - y1;\\n                    if (us.count(getKey(x4, y4))) {\\n                        double w = pow(pow(x2 - x1, 2) + pow(y2 - y1, 2), 0.5);\\n                        double l = pow(pow(x3 - x1, 2) + pow(y3 - y1, 2), 0.5);\\n                        double area = w * l;\\n                        if (ans == 0 || area != 0 && area < ans) {\\n                            ans = area;   \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869640,
                "title": "python3-easy-to-understand-solution-with-basic-coordinate-geometry",
                "content": "For any rectangle, the length of its diagonals and the mid point of its diagonals must be equal.\\n\\n1.Form a line between any two points and assume that it forms a diagonal of some rectangle.\\n2.Group similar pairs of points into a dictionary with the key as (diagonal_len, midpoint)\\n3.Iterate through each group\\n4.Any pair of points within a group would form a rectangle so calculate its area and check if it is the minimum\\n```\\nfrom collections import defaultdict\\nfrom math import sqrt\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def mid_point(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            mid_x = (x1 + x2) / 2.0\\n            mid_y = (y1 + y2) / 2.0\\n            return (mid_x, mid_y)\\n\\n        def get_distance(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\\n\\n        def get_area(p1, p2, p4):\\n            width = get_distance(p1, p2)\\n            height = get_distance(p1, p4)\\n            return width * height\\n\\n        diag_centres_and_len = defaultdict(list)\\n        # Assume that two points form the diagonal of a rectangle\\n        # Group the points based on diagonal length and diagonal midpoint\\n        for i in range(len(points)):\\n            p1 = points[i]\\n            for k in range(i+1, len(points)):\\n                p2 = points[k]\\n                diagonal_len = get_distance(p1, p2)\\n                diagonal_mid = mid_point(p1, p2)\\n                diag_centres_and_len[(diagonal_len, diagonal_mid)].append((p1, p2))\\n\\n        min_area = float(\"inf\")\\n        # Each pair of items in a group form 4 points of the rectangle\\n        # Interate through each pair to get the area\\n        for group in diag_centres_and_len.values():\\n            for i in range(len(group)):\\n                p1, p3 = group[i]\\n                for k in range(i+1, len(group)):\\n                    p2, p4 = group[k]\\n                    area = get_area(p1, p2, p4)\\n                    min_area = min(min_area, area)\\n\\n        return min_area if min_area != float(\"inf\") else 0\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nfrom math import sqrt\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def mid_point(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            mid_x = (x1 + x2) / 2.0\\n            mid_y = (y1 + y2) / 2.0\\n            return (mid_x, mid_y)\\n\\n        def get_distance(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\\n\\n        def get_area(p1, p2, p4):\\n            width = get_distance(p1, p2)\\n            height = get_distance(p1, p4)\\n            return width * height\\n\\n        diag_centres_and_len = defaultdict(list)\\n        # Assume that two points form the diagonal of a rectangle\\n        # Group the points based on diagonal length and diagonal midpoint\\n        for i in range(len(points)):\\n            p1 = points[i]\\n            for k in range(i+1, len(points)):\\n                p2 = points[k]\\n                diagonal_len = get_distance(p1, p2)\\n                diagonal_mid = mid_point(p1, p2)\\n                diag_centres_and_len[(diagonal_len, diagonal_mid)].append((p1, p2))\\n\\n        min_area = float(\"inf\")\\n        # Each pair of items in a group form 4 points of the rectangle\\n        # Interate through each pair to get the area\\n        for group in diag_centres_and_len.values():\\n            for i in range(len(group)):\\n                p1, p3 = group[i]\\n                for k in range(i+1, len(group)):\\n                    p2, p4 = group[k]\\n                    area = get_area(p1, p2, p4)\\n                    min_area = min(min_area, area)\\n\\n        return min_area if min_area != float(\"inf\") else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611645,
                "title": "java-check-diagonal",
                "content": "for points forms rectangular iff:\\n1, diags cross at centers;\\n2, diag lengths are the same;\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] ps) {\\n        Map<String, List<int[][]>> map = new HashMap<>();\\n        int m = ps.length;\\n        String DEL = \",\";\\n        for (int i = 0; i < m; i++) {\\n            for (int j = i + 1; j < m; j++) {\\n                double len = getDist(new int[][]{ps[i], ps[j]});\\n                double xm = (ps[i][0] + ps[j][0]) / 2.0;\\n                double ym = (ps[i][1] + ps[j][1]) / 2.0;\\n                map.computeIfAbsent(xm + DEL + ym + DEL + len, k -> new ArrayList<>());\\n                map.get(xm + DEL + ym + DEL + len).add(new int[][]{ps[i], ps[j]});\\n            }\\n        }\\n        double res = Double.MAX_VALUE;\\n        for (String key : map.keySet()) {\\n            List<int[][]> l = map.get(key);\\n            if (l.size() < 2) continue;\\n            for (int i = 0; i < l.size(); i++) {\\n                for (int j = i + 1; j < l.size(); j++) {\\n                    int[] i1 = l.get(i)[0];\\n                    int[] j1 = l.get(j)[0];\\n                    int[] j2 = l.get(j)[1];\\n                    double area = getDist(new int[][]{i1, j1}) * getDist(new int[][]{i1, j2});\\n                    res = Math.min(res, area);\\n                }\\n            }\\n        }\\n        return res < Double.MAX_VALUE ? res : 0;  // corner case;\\n    }\\n    \\n    private double getDist(int[][] ps) {\\n        int i = 0, j = 1;\\n        return Math.sqrt((ps[i][0] - ps[j][0]) * (ps[i][0] - ps[j][0]) + \\n                         (ps[i][1] - ps[j][1]) * (ps[i][1] - ps[j][1]));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] ps) {\\n        Map<String, List<int[][]>> map = new HashMap<>();\\n        int m = ps.length;\\n        String DEL = \",\";\\n        for (int i = 0; i < m; i++) {\\n            for (int j = i + 1; j < m; j++) {\\n                double len = getDist(new int[][]{ps[i], ps[j]});\\n                double xm = (ps[i][0] + ps[j][0]) / 2.0;\\n                double ym = (ps[i][1] + ps[j][1]) / 2.0;\\n                map.computeIfAbsent(xm + DEL + ym + DEL + len, k -> new ArrayList<>());\\n                map.get(xm + DEL + ym + DEL + len).add(new int[][]{ps[i], ps[j]});\\n            }\\n        }\\n        double res = Double.MAX_VALUE;\\n        for (String key : map.keySet()) {\\n            List<int[][]> l = map.get(key);\\n            if (l.size() < 2) continue;\\n            for (int i = 0; i < l.size(); i++) {\\n                for (int j = i + 1; j < l.size(); j++) {\\n                    int[] i1 = l.get(i)[0];\\n                    int[] j1 = l.get(j)[0];\\n                    int[] j2 = l.get(j)[1];\\n                    double area = getDist(new int[][]{i1, j1}) * getDist(new int[][]{i1, j2});\\n                    res = Math.min(res, area);\\n                }\\n            }\\n        }\\n        return res < Double.MAX_VALUE ? res : 0;  // corner case;\\n    }\\n    \\n    private double getDist(int[][] ps) {\\n        int i = 0, j = 1;\\n        return Math.sqrt((ps[i][0] - ps[j][0]) * (ps[i][0] - ps[j][0]) + \\n                         (ps[i][1] - ps[j][1]) * (ps[i][1] - ps[j][1]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480125,
                "title": "clean-code-with-full-detail-explanation",
                "content": "```\\nThis complete problem requires the 5 basic concept of geometry.\\n\\nConcept -1 : Slope of line formed by points ( x1,y1 ) and (x2,y2) is (y2-y1) / (x2-x1)\\n\\nConcept-2 Three points form a right angle if the product of their slope is -1. Let assume 2 points are (x1,y1) , (x2,y2) and (x3,y3) \\n\\t      (y2-y1)/(x2-x1)   * (y3-y1)*(x3-x1) = -1\\n\\n\\t      Simplifying this equation\\n\\t\\t(y2-y1)* (y3-y1) \\u2013 (x2-x1) (x3-x1) = 0\\n\\n\\nConcept-3 Distance between 2 point is sqrt[ (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)]\\n\\nConcept -4 Middle of two point is (x2+x1)/2\\n\\nConcept -5 : Expressing the 4 the co-ordinate of the rectangle through other 3 co-ordinates\\nLet say we have 4 co-ordinates anticlockwise ->  a(x1,y1), b(x2,y2), c(x3,y3), d(x4,y4) \\nWe know diagonals of rectangle are equal and bisect each other. Thus\\n(x1+x3)/ 2 = (x2+x4)/2\\nSimplify the equation\\nX4 = x1-x2 +x3\\nX4 = y1-y2 +y3\\n\\nNow we have all the ingredients of our algorithm, Here is the step of our algorithm \\n\\n1.\\tFor all triplets of points check if they form a Right -Angle by using the concept -2\\n2.\\tIf they form a right angle calculate the 4th point through concept-5.\\n3.\\tCheck if the 4th point exists in our list , if yes then calculate the area of rectangle (Area = length * breadth). Length and breadth of rectangle is calculated by using the concept 3. \\n4.\\tTrack if the area calculated is minimum of the area calculated so far.\\n\\nComplexity := O(N ^ 3) where n is number of points\\n\\nIn conclusion I won\\u2019t say it is a good question of algo. It is more of testing your geometry skill.\\n\\nHere is the code \\n\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        \\n        for(int[] point : points){\\n            int x=point[0];\\n            int y=point[1];\\n            if(!map.containsKey(x)){\\n                map.put(x, new HashSet<>());\\n            }\\n            map.get(x).add(y);\\n        }\\n        \\n        double min=Double.MAX_VALUE;\\n        int n=points.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int dx1=points[j][0] - points[i][0];\\n                int dy1=points[j][1] - points[i][1];\\n                \\n                for(int k=j+1;k<n;k++){\\n                    int dx2=points[k][0]-points[i][0];\\n                    int dy2=points[k][1]-points[i][1];\\n                    \\n                    if(dx1 * dx2 + dy1 * dy2 != 0){\\n                        continue;\\n                    }\\n                    \\n                    int x=dx1 + points[k][0];\\n                    int y=dy1+points[k][1];\\n                    \\n                    if(map.get(x) != null && map.get(x).contains(y)){\\n                        double area=Math.sqrt(dx1 * dx1 + dy1 * dy1) * Math.sqrt(dx2 * dx2 + dy2 * dy2);\\n                    if(area < min){\\n                        min=area;\\n                    }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\nDisclaimer \\u2013 Code is not mine, thanks to https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/1116315/Java-Solution-100-Faster for writing clean code on the above concept. I just added the explanation part.\\n```",
                "solutionTags": [],
                "code": "```\\nThis complete problem requires the 5 basic concept of geometry.\\n\\nConcept -1 : Slope of line formed by points ( x1,y1 ) and (x2,y2) is (y2-y1) / (x2-x1)\\n\\nConcept-2 Three points form a right angle if the product of their slope is -1. Let assume 2 points are (x1,y1) , (x2,y2) and (x3,y3) \\n\\t      (y2-y1)/(x2-x1)   * (y3-y1)*(x3-x1) = -1\\n\\n\\t      Simplifying this equation\\n\\t\\t(y2-y1)* (y3-y1) \\u2013 (x2-x1) (x3-x1) = 0\\n\\n\\nConcept-3 Distance between 2 point is sqrt[ (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)]\\n\\nConcept -4 Middle of two point is (x2+x1)/2\\n\\nConcept -5 : Expressing the 4 the co-ordinate of the rectangle through other 3 co-ordinates\\nLet say we have 4 co-ordinates anticlockwise ->  a(x1,y1), b(x2,y2), c(x3,y3), d(x4,y4) \\nWe know diagonals of rectangle are equal and bisect each other. Thus\\n(x1+x3)/ 2 = (x2+x4)/2\\nSimplify the equation\\nX4 = x1-x2 +x3\\nX4 = y1-y2 +y3\\n\\nNow we have all the ingredients of our algorithm, Here is the step of our algorithm \\n\\n1.\\tFor all triplets of points check if they form a Right -Angle by using the concept -2\\n2.\\tIf they form a right angle calculate the 4th point through concept-5.\\n3.\\tCheck if the 4th point exists in our list , if yes then calculate the area of rectangle (Area = length * breadth). Length and breadth of rectangle is calculated by using the concept 3. \\n4.\\tTrack if the area calculated is minimum of the area calculated so far.\\n\\nComplexity := O(N ^ 3) where n is number of points\\n\\nIn conclusion I won\\u2019t say it is a good question of algo. It is more of testing your geometry skill.\\n\\nHere is the code \\n\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        \\n        for(int[] point : points){\\n            int x=point[0];\\n            int y=point[1];\\n            if(!map.containsKey(x)){\\n                map.put(x, new HashSet<>());\\n            }\\n            map.get(x).add(y);\\n        }\\n        \\n        double min=Double.MAX_VALUE;\\n        int n=points.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int dx1=points[j][0] - points[i][0];\\n                int dy1=points[j][1] - points[i][1];\\n                \\n                for(int k=j+1;k<n;k++){\\n                    int dx2=points[k][0]-points[i][0];\\n                    int dy2=points[k][1]-points[i][1];\\n                    \\n                    if(dx1 * dx2 + dy1 * dy2 != 0){\\n                        continue;\\n                    }\\n                    \\n                    int x=dx1 + points[k][0];\\n                    int y=dy1+points[k][1];\\n                    \\n                    if(map.get(x) != null && map.get(x).contains(y)){\\n                        double area=Math.sqrt(dx1 * dx1 + dy1 * dy1) * Math.sqrt(dx2 * dx2 + dy2 * dy2);\\n                    if(area < min){\\n                        min=area;\\n                    }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\nDisclaimer \\u2013 Code is not mine, thanks to https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/1116315/Java-Solution-100-Faster for writing clean code on the above concept. I just added the explanation part.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402566,
                "title": "c-solution-using-hashmap-with-distance-of-2-points-as-key-and-2-points-as-value",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    double minAreaFreeRect(vector<vector<int>>& points) \\n    {\\n        double result=2147483647;\\n        map<int,vector<vector<int>>> total;\\n        for(int i=0;i<(int)points.size()-1;i++)\\n        {\\n            for(int j=i+1;j<(int)points.size();j++)\\n            {\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                int d=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);//key is the distance between 2 points (square)\\n                vector<int> temp;//value is 2 points (x1,y1,x2,y2)\\n                if(x1>x2)\\n                {\\n                    temp.push_back(x1);\\n                    temp.push_back(y1);\\n                    temp.push_back(x2);\\n                    temp.push_back(y2);\\n                }\\n                else\\n                {\\n                    temp.push_back(x2);\\n                    temp.push_back(y2);\\n                    temp.push_back(x1);\\n                    temp.push_back(y1);\\n                }\\n                total[d].push_back(temp);\\n            }\\n        }\\n        for(map<int,vector<vector<int>>>::iterator it=total.begin();it!=total.end();it++)\\n        {\\n            for(int i=0;i<(int)it->second.size()-1;i++)//p1~p2, and p3~p4 have same length\\n            {\\n                for(int j=i+1;j<(int)it->second.size();j++)\\n                {\\n                    int x1=it->second[i][0];\\n                    int x2=it->second[i][2];\\n                    int x3=it->second[j][0];\\n                    int x4=it->second[j][2];\\n\\n                    int y1=it->second[i][1];\\n                    int y2=it->second[i][3];\\n                    int y3=it->second[j][1];\\n                    int y4=it->second[j][3];\\n                    \\n                    if((x3-x1)*(x3-x1)+(y3-y1)*(y3-y1)==(x4-x2)*(x4-x2)+(y4-y2)*(y4-y2))//check if p1~p3 and p2~p4 have same length\\n                    {\\n                        int f1=x2-x1;\\n                        int f2=y2-y1;\\n                        int f3=x3-x1;\\n                        int f4=y3-y1;\\n                        if(((f1==0&&f3==0)||(f2==0&&f4==0)||((double)(x2-x1)/(double)(y2-y1))==((double(x4-x3)/(double)(y4-y3))))&&(f1*f3+f2*f4==0))// check if p1~p2 and p3~p4 have same slope. check if p1~p2 and p1~p3 are orthogonal\\n                        {\\n                            result=min(result,sqrt(f1*f1+f2*f2)*sqrt(f3*f3+f4*f4));//the area of the rectangle\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(result==2147483647)\\n        {\\n            return 0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    double minAreaFreeRect(vector<vector<int>>& points) \\n    {\\n        double result=2147483647;\\n        map<int,vector<vector<int>>> total;\\n        for(int i=0;i<(int)points.size()-1;i++)\\n        {\\n            for(int j=i+1;j<(int)points.size();j++)\\n            {\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                int d=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);//key is the distance between 2 points (square)\\n                vector<int> temp;//value is 2 points (x1,y1,x2,y2)\\n                if(x1>x2)\\n                {\\n                    temp.push_back(x1);\\n                    temp.push_back(y1);\\n                    temp.push_back(x2);\\n                    temp.push_back(y2);\\n                }\\n                else\\n                {\\n                    temp.push_back(x2);\\n                    temp.push_back(y2);\\n                    temp.push_back(x1);\\n                    temp.push_back(y1);\\n                }\\n                total[d].push_back(temp);\\n            }\\n        }\\n        for(map<int,vector<vector<int>>>::iterator it=total.begin();it!=total.end();it++)\\n        {\\n            for(int i=0;i<(int)it->second.size()-1;i++)//p1~p2, and p3~p4 have same length\\n            {\\n                for(int j=i+1;j<(int)it->second.size();j++)\\n                {\\n                    int x1=it->second[i][0];\\n                    int x2=it->second[i][2];\\n                    int x3=it->second[j][0];\\n                    int x4=it->second[j][2];\\n\\n                    int y1=it->second[i][1];\\n                    int y2=it->second[i][3];\\n                    int y3=it->second[j][1];\\n                    int y4=it->second[j][3];\\n                    \\n                    if((x3-x1)*(x3-x1)+(y3-y1)*(y3-y1)==(x4-x2)*(x4-x2)+(y4-y2)*(y4-y2))//check if p1~p3 and p2~p4 have same length\\n                    {\\n                        int f1=x2-x1;\\n                        int f2=y2-y1;\\n                        int f3=x3-x1;\\n                        int f4=y3-y1;\\n                        if(((f1==0&&f3==0)||(f2==0&&f4==0)||((double)(x2-x1)/(double)(y2-y1))==((double(x4-x3)/(double)(y4-y3))))&&(f1*f3+f2*f4==0))// check if p1~p2 and p3~p4 have same slope. check if p1~p2 and p1~p3 are orthogonal\\n                        {\\n                            result=min(result,sqrt(f1*f1+f2*f2)*sqrt(f3*f3+f4*f4));//the area of the rectangle\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(result==2147483647)\\n        {\\n            return 0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100981,
                "title": "javascript-o-n-2-map-with-comments",
                "content": "**Key Observations:**\\n1. Calculate distance between all given points assuming they could be diagonals of the rectangle\\n2. If two set of diagonals have same key then they are a rectangle. Save diagonal distance and midpoint of each combo as key in a map\\n3. Use the map and calculate area for key\\'s which has more than 1 set of co-ordinates.\\n\\n\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    let len = points.length;\\n    \\n    if (len < 4) return 0;\\n    \\n    // Helper function to calculate distance\\n    // between two points, optionally return \\n    // without sqrt if want to use as key\\n    const getDistance = (a, b, isKey = false) => {\\n        let [xa, ya] = a;\\n        let [xb, yb] = b;\\n        \\n        const distance = (xa - xb) * (xa - xb) + (ya - yb) * (ya - yb);\\n        return isKey ? distance : Math.sqrt(distance);\\n    }\\n    \\n    let map = new Map();\\n    \\n    // let\\'s loop over all points and find all possible\\n    // diagonals and calc - dis with midpoints and \\n    // save as key with co-ordinates as values\\n    for (let i = 0; i < len; i += 1) {\\n        for (let j = i + 1; j < len; j += 1) {\\n            let disKey = getDistance(points[i], points[j], true);\\n            let [xa, ya] = points[i];\\n            let [xb, yb] = points[j];\\n            \\n            let x = (xa + xb) / 2;\\n            let y = (ya + yb) / 2;\\n            \\n            let key = `${disKey}-${x}-${y}`;\\n            \\n            let list = [];\\n            \\n            if (!map.has(key)) {\\n                map.set(key, list)\\n            } else list = map.get(key);\\n            \\n            list.push([i, j]);\\n            \\n            map.set(key, list);\\n        }\\n    }\\n    \\n    // console.log(map);\\n    let res = Number.MAX_VALUE;\\n    \\n    // loop over map of keys above and\\n    // only iterate through the list where at least \\n    // 2 set of co-ordinates have been found above\\n    map.forEach((list, key) => {\\n        if (list.length > 1) {\\n            for (let i = 0; i < list.length; i += 1) {\\n                for (let j = i + 1; j < list.length; j += 1) {\\n                    let p1 = list[i][0];\\n                    let p2 = list[j][0];\\n                    let p3 = list[j][1];\\n                    \\n                    let l = getDistance(points[p1], points[p2]);\\n                    let b = getDistance(points[p1], points[p3]);\\n                    res = Math.min(res, l * b);\\n                }\\n            }\\n        }\\n    })\\n    \\n    return res === Number.MAX_VALUE ? 0 : res;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    let len = points.length;\\n    \\n    if (len < 4) return 0;\\n    \\n    // Helper function to calculate distance\\n    // between two points, optionally return \\n    // without sqrt if want to use as key\\n    const getDistance = (a, b, isKey = false) => {\\n        let [xa, ya] = a;\\n        let [xb, yb] = b;\\n        \\n        const distance = (xa - xb) * (xa - xb) + (ya - yb) * (ya - yb);\\n        return isKey ? distance : Math.sqrt(distance);\\n    }\\n    \\n    let map = new Map();\\n    \\n    // let\\'s loop over all points and find all possible\\n    // diagonals and calc - dis with midpoints and \\n    // save as key with co-ordinates as values\\n    for (let i = 0; i < len; i += 1) {\\n        for (let j = i + 1; j < len; j += 1) {\\n            let disKey = getDistance(points[i], points[j], true);\\n            let [xa, ya] = points[i];\\n            let [xb, yb] = points[j];\\n            \\n            let x = (xa + xb) / 2;\\n            let y = (ya + yb) / 2;\\n            \\n            let key = `${disKey}-${x}-${y}`;\\n            \\n            let list = [];\\n            \\n            if (!map.has(key)) {\\n                map.set(key, list)\\n            } else list = map.get(key);\\n            \\n            list.push([i, j]);\\n            \\n            map.set(key, list);\\n        }\\n    }\\n    \\n    // console.log(map);\\n    let res = Number.MAX_VALUE;\\n    \\n    // loop over map of keys above and\\n    // only iterate through the list where at least \\n    // 2 set of co-ordinates have been found above\\n    map.forEach((list, key) => {\\n        if (list.length > 1) {\\n            for (let i = 0; i < list.length; i += 1) {\\n                for (let j = i + 1; j < list.length; j += 1) {\\n                    let p1 = list[i][0];\\n                    let p2 = list[j][0];\\n                    let p3 = list[j][1];\\n                    \\n                    let l = getDistance(points[p1], points[p2]);\\n                    let b = getDistance(points[p1], points[p3]);\\n                    res = Math.min(res, l * b);\\n                }\\n            }\\n        }\\n    })\\n    \\n    return res === Number.MAX_VALUE ? 0 : res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765389,
                "title": "python-76-quick-search-for-diamond-determine-rectangle-by-diagonal-distances",
                "content": "```python\\ndef dist_pow2(x1, y1, x2, y2): return (x2 - x1)**2 + (y2 - y1)**2\\ndef dist(x1, y1, x2, y2): return dist_pow2(x1, y1, x2, y2)**0.5\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        L, m = len(points), float(\\'inf\\')\\n\\n        quick_search = {(x, y) for x, y in points}\\n\\n        for i in range(L):\\n            for j in range(i + 1, L):\\n                for k in range(j + 1, L):\\n                    x1, y1 = points[i] # calculate point4 to form a diamond by previous three\\n                    x2, y2 = points[j] # we only check case when x4 is latter occured than x3\\n                    x3, y3 = points[k] # becourse the case when x4 is earlier occured than x3 will be covered already\\n                    x4, y4 = (x3 + (x2 - x1), y3 + (y2 - y1))\\n\\n                    if (x4, y4) in quick_search:  # look for existence of dimond shape\\n                        # if two diagonals\\' length are equal, we got a rectangel\\n                        if dist_pow2(x1, y1, x4, y4) == dist_pow2(x2, y2, x3, y3):\\n                            # calculate area by multipling any two adjacent edge\\'s length\\n                            area = dist(x1, y1, x2, y2) * dist(x1, y1, x3, y3)\\n                            m = min(m, area)  # keep track of min_area\\n\\n        return m if m != float(\\'inf\\') else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Geometry"
                ],
                "code": "```python\\ndef dist_pow2(x1, y1, x2, y2): return (x2 - x1)**2 + (y2 - y1)**2\\ndef dist(x1, y1, x2, y2): return dist_pow2(x1, y1, x2, y2)**0.5\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        L, m = len(points), float(\\'inf\\')\\n\\n        quick_search = {(x, y) for x, y in points}\\n\\n        for i in range(L):\\n            for j in range(i + 1, L):\\n                for k in range(j + 1, L):\\n                    x1, y1 = points[i] # calculate point4 to form a diamond by previous three\\n                    x2, y2 = points[j] # we only check case when x4 is latter occured than x3\\n                    x3, y3 = points[k] # becourse the case when x4 is earlier occured than x3 will be covered already\\n                    x4, y4 = (x3 + (x2 - x1), y3 + (y2 - y1))\\n\\n                    if (x4, y4) in quick_search:  # look for existence of dimond shape\\n                        # if two diagonals\\' length are equal, we got a rectangel\\n                        if dist_pow2(x1, y1, x4, y4) == dist_pow2(x2, y2, x3, y3):\\n                            # calculate area by multipling any two adjacent edge\\'s length\\n                            area = dist(x1, y1, x2, y2) * dist(x1, y1, x3, y3)\\n                            m = min(m, area)  # keep track of min_area\\n\\n        return m if m != float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192431,
                "title": "python-beats-100-diagonals-in-hashmap",
                "content": "Can we identify a rectangle by looking at its diagonals? If 2 diagonals form a rectangle, they must be bisecting each other and be of equal length. We can use this property to store midpoint and length in a dictionary and then whenever we observe another line (diagonal), it would form a rectangle with all such other diagonals. The code will make things more clear.  \\n\\n```\\nclass Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        \\n        def area(p1,p2,p3):\\n            l1 = (p1[0]-p3[0])**2 + (p1[1]-p3[1])**2\\n            l2 = (p2[0]-p3[0])**2 + (p2[1]-p3[1])**2\\n            return (l1**0.5) * (l2**0.5)\\n        \\n        n = len(points)\\n        D = {}\\n        min_area = float(\"inf\")\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                x1,y1 = points[i]\\n                x2,y2 = points[j]\\n                middle = ((x1+x2)/2.0, (y1+y2)/2.0)\\n                l = (x2-x1)**2 + (y2-y1)**2\\n                if (middle, l) in D:\\n                    for p in D[(middle,l)]:\\n                        min_area = min(area(points[i], points[j], p), min_area)\\n                    D[(middle, l)].append(points[i])\\n                else:\\n                    D[(middle, l)] = [points[i]]\\n        if min_area == float(\"inf\"):\\n            return 0\\n        return min_area\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        \\n        def area(p1,p2,p3):\\n            l1 = (p1[0]-p3[0])**2 + (p1[1]-p3[1])**2\\n            l2 = (p2[0]-p3[0])**2 + (p2[1]-p3[1])**2\\n            return (l1**0.5) * (l2**0.5)\\n        \\n        n = len(points)\\n        D = {}\\n        min_area = float(\"inf\")\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                x1,y1 = points[i]\\n                x2,y2 = points[j]\\n                middle = ((x1+x2)/2.0, (y1+y2)/2.0)\\n                l = (x2-x1)**2 + (y2-y1)**2\\n                if (middle, l) in D:\\n                    for p in D[(middle,l)]:\\n                        min_area = min(area(points[i], points[j], p), min_area)\\n                    D[(middle, l)].append(points[i])\\n                else:\\n                    D[(middle, l)] = [points[i]]\\n        if min_area == float(\"inf\"):\\n            return 0\\n        return min_area\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 208753,
                "title": "c-8ms-using-map-with-explanation",
                "content": "The basic idea is to use a map, where the key is ```(dx,dy)``` formed by each two points ```(x1,y1)``` and ```(x2,y2)``` where ```dx=x2-x1```, ```dy=y2-y1```, and the value of the key is a list of point ```(x1,y1)``` where a line segment ```(dx,dy)``` can be formed from these points in the entire point set. \\n\\nFor example, if ```Map[{1,0}] = {{0,0}, {0,1}, {1,1}}```, this means that a vector ```(1,0)``` can be formed starting from point ```(0,0)```, ```(0,1)```, and ```(1,1)```. To reduce duplication, the map only takes ```(dx,dy)``` such that ```dx>=0``` and ```dy>=0```. This is because for any rectangular, there must be at least one edge satisfying this condition.\\n\\nThen simply iterate every key of the map, and find if any two starting points under this key can form a rectangular. Specifically, if both ```(x1,y1)``` and ```(x2,y2)``` belong to key ```(dx,dy)```, then the necessary and sufficient condition that they can form a triangle is ```(x2-x1,y2-y1)``` is perpendicular to ```(dx,dy)```, i.e., ```dx*(x2-x1) + dy*(y2-y1)=0```. The area of the rectangular is the outer product of ```(dx,dy)``` and ```(x2-x1, y2-y1)```, or ```|dx*(y2-y1)-dy*(x2-x1)|```.\\n\\nThe time complexity is ```O(n^2) + O(km^2)```, where ```n``` is total number of points, ```k``` is number of possible keys, and ```m``` is average number of points under each key. The first ```O(n^2)``` is due to the process establishing the map. The second ```O(km^2)``` is due to iteration over all the keys.\\n\\nI am having some difficulties computing the second time complixity contribution ```O(km^2)```. Instead, I am considering two cases. In one extreme case that all points are completely randome and no rectangule can be formed, ```n(n-1)/2``` line segments can be formed by the ```n``` points, with half of them having negative slope, hence ```k=n(n-1)/4```; but in this case ```m=1```; hence the second term is ```O(km^2)=O(n^2)```. In another extreme case, all points form a ladder shape, such as ```(0,0),(1,0),(1,0),(1,1),(2,0),(2,1),(3,0),(3,1),...```. In this case, ```k=2n``` for ```(dx,dy)=(1,0),(1,1),(1,2),(1,3),...,(1,n/2), (0,1), (0,2),(0,3),...,(0,n/2)```; the number of points under key ```(1,0)``` is ```n/2```, and ```n/2-1``` under key ```(1,1)```, ```1``` under key ```(1,n/2)```, and ```2``` for ```(0,1)```, ```(0,2)```,```(0,3)```, ... The total operation is ```(n/2)^2+(n/2-1)^2+...+1^2 + (n/2)*2^2 ~ n^3```. Hence the total time complexity in this case is ```O(n^3)```. I guess I can also compute another extreme case: all points forms a 2D grid. But my feeling is that ```O(km^2)``` is between ```O(n^2)``` and ```O(n^3)```.\\n\\nHere is the code\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double find_min_Rec(vector<pair<int,int>> & xy0, int dx, int dy){\\n        int n = xy0.size();\\n        if(n<2) return -1;\\n        double tmp_area, min_area = -1;\\n        for(int i=0;i<n-1;i++)\\n            for(int j=i+1;j<n;j++){\\n                int dx1 = xy0[i].first  - xy0[j].first;\\n                int dy1 = xy0[i].second - xy0[j].second;\\n                if(dx1==0 && dy1==0) continue;\\n                if(dx*dx1+dy*dy1==0){\\n                    tmp_area = abs((double)dx*(double)dy1 - (double)dy*(double)dx1);\\n                    if(min_area<0) min_area = tmp_area;\\n                    else min_area = min(min_area, tmp_area);\\n                }\\n            }\\n        return min_area;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        map<pair<int,int>, vector<pair<int,int>>> lines; //(dx,dy)->(x0,y0)\\n        int n = points.size();\\n        for(int i=0;i<n-1;i++)\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0]>points[j][0]){\\n                    int dx = points[i][0]-points[j][0];\\n                    int dy = points[i][1]-points[j][1];\\n                    int x0 = points[j][0], y0 = points[j][1];\\n                    if(dy>=0) lines[{dx,dy}].push_back({x0,y0});\\n                } else {\\n                    int dx = points[j][0]-points[i][0];\\n                    int dy = points[j][1]-points[i][1];\\n                    int x0 = points[i][0], y0 = points[i][1];\\n                    if(dy>=0) lines[{dx,dy}].push_back({x0,y0}); \\n                }\\n            }\\n        double minArea = -1;\\n        \\n        for(auto it = lines.begin();it!=lines.end();it++){\\n            double tmp_min_area = find_min_Rec(it->second, it->first.first, it->first.second);\\n            if(tmp_min_area<0) continue;\\n            if(minArea<0) minArea = tmp_min_area;\\n            else minArea = min(tmp_min_area,minArea);\\n        }\\n        \\n        return minArea<0?0:minArea;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```(dx,dy)```\n```(x1,y1)```\n```(x2,y2)```\n```dx=x2-x1```\n```dy=y2-y1```\n```(x1,y1)```\n```(dx,dy)```\n```Map[{1,0}] = {{0,0}, {0,1}, {1,1}}```\n```(1,0)```\n```(0,0)```\n```(0,1)```\n```(1,1)```\n```(dx,dy)```\n```dx>=0```\n```dy>=0```\n```(x1,y1)```\n```(x2,y2)```\n```(dx,dy)```\n```(x2-x1,y2-y1)```\n```(dx,dy)```\n```dx*(x2-x1) + dy*(y2-y1)=0```\n```(dx,dy)```\n```(x2-x1, y2-y1)```\n```|dx*(y2-y1)-dy*(x2-x1)|```\n```O(n^2) + O(km^2)```\n```n```\n```k```\n```m```\n```O(n^2)```\n```O(km^2)```\n```O(km^2)```\n```n(n-1)/2```\n```n```\n```k=n(n-1)/4```\n```m=1```\n```O(km^2)=O(n^2)```\n```(0,0),(1,0),(1,0),(1,1),(2,0),(2,1),(3,0),(3,1),...```\n```k=2n```\n```(dx,dy)=(1,0),(1,1),(1,2),(1,3),...,(1,n/2), (0,1), (0,2),(0,3),...,(0,n/2)```\n```(1,0)```\n```n/2```\n```n/2-1```\n```(1,1)```\n```1```\n```(1,n/2)```\n```2```\n```(0,1)```\n```(0,2)```\n```(0,3)```\n```(n/2)^2+(n/2-1)^2+...+1^2 + (n/2)*2^2 ~ n^3```\n```O(n^3)```\n```O(km^2)```\n```O(n^2)```\n```O(n^3)```\n```\\nclass Solution {\\npublic:\\n    double find_min_Rec(vector<pair<int,int>> & xy0, int dx, int dy){\\n        int n = xy0.size();\\n        if(n<2) return -1;\\n        double tmp_area, min_area = -1;\\n        for(int i=0;i<n-1;i++)\\n            for(int j=i+1;j<n;j++){\\n                int dx1 = xy0[i].first  - xy0[j].first;\\n                int dy1 = xy0[i].second - xy0[j].second;\\n                if(dx1==0 && dy1==0) continue;\\n                if(dx*dx1+dy*dy1==0){\\n                    tmp_area = abs((double)dx*(double)dy1 - (double)dy*(double)dx1);\\n                    if(min_area<0) min_area = tmp_area;\\n                    else min_area = min(min_area, tmp_area);\\n                }\\n            }\\n        return min_area;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        map<pair<int,int>, vector<pair<int,int>>> lines; //(dx,dy)->(x0,y0)\\n        int n = points.size();\\n        for(int i=0;i<n-1;i++)\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0]>points[j][0]){\\n                    int dx = points[i][0]-points[j][0];\\n                    int dy = points[i][1]-points[j][1];\\n                    int x0 = points[j][0], y0 = points[j][1];\\n                    if(dy>=0) lines[{dx,dy}].push_back({x0,y0});\\n                } else {\\n                    int dx = points[j][0]-points[i][0];\\n                    int dy = points[j][1]-points[i][1];\\n                    int x0 = points[i][0], y0 = points[i][1];\\n                    if(dy>=0) lines[{dx,dy}].push_back({x0,y0}); \\n                }\\n            }\\n        double minArea = -1;\\n        \\n        for(auto it = lines.begin();it!=lines.end();it++){\\n            double tmp_min_area = find_min_Rec(it->second, it->first.first, it->first.second);\\n            if(tmp_min_area<0) continue;\\n            if(minArea<0) minArea = tmp_min_area;\\n            else minArea = min(tmp_min_area,minArea);\\n        }\\n        \\n        return minArea<0?0:minArea;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292911,
                "title": "c-a-little-complicated-but-easy-to-understand-solution",
                "content": "This is a O(N^2LogN) solution.\\n\\nEnumerate the diagonal of the rectangle, find all diagonal with the same mid-point and length, those are two diagonal that can make a rectangle. Then calculate the size from there.  \\n\\nUse a map to group by mid point of diagonal, and another multimap to group by the length.\\n\\n```\\nclass Solution {\\npublic:    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        long ans = LONG_MAX;\\n        // map<mid_point, map<length, vector>>\\n        map<vector<long>, multimap<long, vector<int>>> db;\\n        for (auto i = points.begin(); i != points.end(); i++) {\\n            for (auto j = i+1; j != points.end(); j++) {\\n                if (i == j) continue;\\n                \\n                long x1 = j->at(0) - i->at(0);\\n                long y1 = j->at(1) - i->at(1);\\n                \\n                long length = x1 * x1 + y1 * y1;\\n\\n                vector<long> mid = {i->at(0) + j->at(0), i->at(1) + j->at(1)};\\n                \\n                if (db.find(mid) == db.end()) {\\n                    db.insert(std::make_pair(mid, multimap<long, vector<int>>()));\\n                }\\n                \\n                auto &m = (db.find(mid))->second;\\n                if (m.find(length) != m.end()) {\\n                    auto p = m.equal_range(length);\\n                    for (auto k = p.first; k != p.second; k++) {\\n                        ans = std::min(ans, std::abs(x1 * k->second.at(1) - y1 * k->second.at(0)));\\n                    }\\n                }\\n                m.insert(std::make_pair(length, vector<int>{int(x1), int(y1)}));\\n            }\\n        }\\n        return ans == LONG_MAX ? 0 : ans / 2;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        long ans = LONG_MAX;\\n        // map<mid_point, map<length, vector>>\\n        map<vector<long>, multimap<long, vector<int>>> db;\\n        for (auto i = points.begin(); i != points.end(); i++) {\\n            for (auto j = i+1; j != points.end(); j++) {\\n                if (i == j) continue;\\n                \\n                long x1 = j->at(0) - i->at(0);\\n                long y1 = j->at(1) - i->at(1);\\n                \\n                long length = x1 * x1 + y1 * y1;\\n\\n                vector<long> mid = {i->at(0) + j->at(0), i->at(1) + j->at(1)};\\n                \\n                if (db.find(mid) == db.end()) {\\n                    db.insert(std::make_pair(mid, multimap<long, vector<int>>()));\\n                }\\n                \\n                auto &m = (db.find(mid))->second;\\n                if (m.find(length) != m.end()) {\\n                    auto p = m.equal_range(length);\\n                    for (auto k = p.first; k != p.second; k++) {\\n                        ans = std::min(ans, std::abs(x1 * k->second.at(1) - y1 * k->second.at(0)));\\n                    }\\n                }\\n                m.insert(std::make_pair(length, vector<int>{int(x1), int(y1)}));\\n            }\\n        }\\n        return ans == LONG_MAX ? 0 : ans / 2;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079184,
                "title": "super-easy-to-understand-c-o-n-3logn-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dot_product(vector<int> &a, vector<int> &b, vector<int> &c){\\n        return (b[0] - a[0]) * (c[0] - b[0]) + (b[1] - a[1]) * (c[1] - b[1]);\\n    }\\n    vector<int> get_fourth_point(vector<int> &a, vector<int> &b, vector<int> &c){\\n        int x = a[0] + (c[0] - b[0]);\\n        int y = a[1] + (c[1] - b[1]);\\n        return {x, y};\\n    }\\n    double get_area(vector<int> &a, vector<int> &b, vector<int> &c, vector<int> &d){\\n        double x1 = b[0] - a[0];\\n        double y1 = b[1] - a[1];\\n        double x2 = c[0] - b[0];\\n        double y2 = c[1] - b[1];\\n        \\n        return sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2);\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        map<vector<int>, bool> point_exists;\\n        double res = INT_MAX;\\n        bool rectangle_exists = false;\\n        int n = points.size();\\n        sort(points.begin(), points.end());\\n        for(auto i : points) point_exists[i] = 1;\\n        for(int i = 0;i < n;i++){\\n            for(int j = i + 1;j < n;j++){\\n                for(int k = j + 1;k < n;k++){\\n                    vector<int> a = points[i];\\n                    vector<int> b = points[j];\\n                    vector<int> c = points[k];\\n                    if(dot_product(a, b, c)) continue; // check if vectors AB and BC are perpendicular\\n                    vector<int> d = get_fourth_point(a, b, c); // check if there exists point D such that ABCD is rectangle\\n                    if(point_exists[d]){\\n                        res = min(res, get_area(a, b, c, d));\\n                        rectangle_exists = true;\\n                    }\\n                }\\n            }\\n        }\\n        return rectangle_exists * res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool dot_product(vector<int> &a, vector<int> &b, vector<int> &c){\\n        return (b[0] - a[0]) * (c[0] - b[0]) + (b[1] - a[1]) * (c[1] - b[1]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1004532,
                "title": "python-concise-explained-solution-dhruv-vavliya",
                "content": "```\\n# written by : Dhruv Vavliya\\n\\n\\'\\'\\'\\nthe distance between point1 and point2 equals the distance between point3 and point4\\nthe midpoint of point1 and point2 equals the midpoint of point3 and point4.\\n\\'\\'\\'\\n\\npoints =[[2,4],[4,2],[1,0],[3,4],[4,4],[2,2],[1,1],[3,0],[1,4],[0,3],[0,1],[2,1],[4,0]]\\n\\n\\ndef rect_area(points):\\n    from collections import defaultdict\\n    import math\\n    dp = defaultdict(list)\\n\\n    for i in range(len(points) - 1):\\n        for j in range(i + 1, len(points)):\\n            l = (points[j][1] - points[i][1]) ** 2 + (points[j][0] - points[i][0]) ** 2  # distance\\n            x = (points[i][0] + points[j][0]) / 2                                        # midpoint (x,y)\\n            y = (points[i][1] + points[j][1]) / 2\\n            dp[(l, x, y)].append((i, j))\\n\\n    print(dp)\\n\\n    ans = float(\\'inf\\')\\n    for line in dp.values():\\n        for i in range(len(line) - 1):\\n            p0, p2 = points[line[i][0]] ,points[line[i][1]]     \\n            for j in range(i + 1, len(line)):\\n                p1, p3 = points[line[j][0]], points[line[j][1]]\\n                d1 = math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)    # two adjacent sides\\n                d2 = math.sqrt((p0[0] - p3[0]) ** 2 + (p0[1] - p3[1]) ** 2)\\n                ans = min(ans, d1 * d2)\\n\\n    if ans != float(\\'inf\\'):\\n        return ans\\n    else:\\n        return 0\\n\\n\\nprint(rect_area(points))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# written by : Dhruv Vavliya\\n\\n\\'\\'\\'\\nthe distance between point1 and point2 equals the distance between point3 and point4\\nthe midpoint of point1 and point2 equals the midpoint of point3 and point4.\\n\\'\\'\\'\\n\\npoints =[[2,4],[4,2],[1,0],[3,4],[4,4],[2,2],[1,1],[3,0],[1,4],[0,3],[0,1],[2,1],[4,0]]\\n\\n\\ndef rect_area(points):\\n    from collections import defaultdict\\n    import math\\n    dp = defaultdict(list)\\n\\n    for i in range(len(points) - 1):\\n        for j in range(i + 1, len(points)):\\n            l = (points[j][1] - points[i][1]) ** 2 + (points[j][0] - points[i][0]) ** 2  # distance\\n            x = (points[i][0] + points[j][0]) / 2                                        # midpoint (x,y)\\n            y = (points[i][1] + points[j][1]) / 2\\n            dp[(l, x, y)].append((i, j))\\n\\n    print(dp)\\n\\n    ans = float(\\'inf\\')\\n    for line in dp.values():\\n        for i in range(len(line) - 1):\\n            p0, p2 = points[line[i][0]] ,points[line[i][1]]     \\n            for j in range(i + 1, len(line)):\\n                p1, p3 = points[line[j][0]], points[line[j][1]]\\n                d1 = math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)    # two adjacent sides\\n                d2 = math.sqrt((p0[0] - p3[0]) ** 2 + (p0[1] - p3[1]) ** 2)\\n                ans = min(ans, d1 * d2)\\n\\n    if ans != float(\\'inf\\'):\\n        return ans\\n    else:\\n        return 0\\n\\n\\nprint(rect_area(points))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 880414,
                "title": "java-100-cpu-100-memory-o-n-3-area-function",
                "content": "**Steps to solve this**\\n1.   Fix the *first* point in the given list and see if it can be used to form a rectangle // loop (1)\\n2.   Fix the *second* point on the right of \"First\" point and check if it can be used for form a rectangle loop (2)\\n3.   Fix the *third* point to the right of \"Second\" and see if they form a Rectangle\\n\\t3.b Exception to this rule are if points form a straight line will make rectangle with Zero area\\n4.  Calculate the area that these points form\\n             |\\n\\t\\t\\t |\\n\\t\\t\\t |____________________\\n\\t\\t\\t \\n\\t\\t\\t In the above (x1,y1) (x2,y2) (x3,y3) = We can find the length and width that makes area\\n5. Calculate the area formed by three points \\n  5.a Using the Length and Width\\n  5.b Using the points - Core maths function implemented in code calculateArea(int[][] points, int i, int j, int k)\\n\\n\\tNote: What we have?\\n\\t  a. Three points\\n\\t  b. Area three points forming\\n\\t  c. Minimum area rectangle seen till now\\n  \\n6. Last check to perform?\\n  Does the \"Fourth\" point exists in the List of points?\\n  \\n7. Yes? Update the Tracked Minimum\\n6. \\n\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        double area;\\n        \\n        for(int[] point: points){\\n            if(!map.containsKey(point[0])){\\n                map.put(point[0], new HashSet<>());\\n            }            \\n            map.get(point[0]).add(point[1]);\\n        }//end of for\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        int n = points.length;\\n        \\n        for(int i=0; i<n -2; i++){\\n            for(int j=i+1; j<n - 1; j++){\\n                int dx1 = points[j][0] - points[i][0];\\n                int dy1 = points[j][1] - points[i][1];\\n                //get the 3rd point\\n                for(int k = j+1; k<n; k++){\\n                    int dx2 = points[k][0] - points[i][0];\\n                    int dy2 = points[k][1] - points[i][1];\\n                    \\n                    if(dx1*dx2 + dy1*dy2 != 0){\\n                        continue;\\n                    }\\n                    //find the 4th point\\n                    int x = dx1 + points[k][0];\\n                    int y = dy1 + points[k][1];\\n                    \\n                    area = calculateArea(points, i, j, k);\\n                    if(area >= minArea){\\n                        continue;\\n                    }\\n                    //4th point exists\\n                    if(map.get(x) != null && map.get(x).contains(y)){\\n                        minArea = area;\\n                    }\\n                }\\n            }\\n        }\\n        return minArea == Double.MAX_VALUE ? 0.0 : minArea;\\n    }\\n    \\n    private double calculateArea(int[][] points, int i, int j, int k) {\\n        int[] first = points[i];\\n        int[] second = points[j];\\n        int[] third = points[k];\\n        return Math.abs((first[0] * (second[1] - third[1])) +\\n                (second[0] * (third[1] - first[1])) + \\n            (third[0] * (first[1] - second[1])));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Geometry"
                ],
                "code": "class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        double area;\\n        \\n        for(int[] point: points){\\n            if(!map.containsKey(point[0])){\\n                map.put(point[0], new HashSet<>());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 536801,
                "title": "python",
                "content": "Same idea as the solution, without using `complex`\\n\\n**Python**\\n```py\\nclass Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = set(map(tuple, points))\\n        \\n        def vector_len(a):\\n            return math.sqrt(a[0]**2 + a[1]**2)\\n        \\n        ans = float(\"inf\")\\n        for p1, p2, p3 in itertools.permutations(points, 3):\\n            p4 = p2[0] + p3[0] - p1[0], p2[1] + p3[1] - p1[1]\\n            if p4 in points:\\n                v21 = (p2[0] - p1[0], p2[1] - p1[1])\\n                v31 = (p3[0] - p1[0], p3[1] - p1[1])\\n                if abs(v21[0] * v31[0] + v21[1] * v31[1]) == 0:\\n                    area = vector_len(v21) * vector_len(v31)\\n                    if area < ans:\\n                        ans = area\\n        \\n        return ans if ans < float(\"inf\") else 0\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = set(map(tuple, points))\\n        \\n        def vector_len(a):\\n            return math.sqrt(a[0]**2 + a[1]**2)\\n        \\n        ans = float(\"inf\")\\n        for p1, p2, p3 in itertools.permutations(points, 3):\\n            p4 = p2[0] + p3[0] - p1[0], p2[1] + p3[1] - p1[1]\\n            if p4 in points:\\n                v21 = (p2[0] - p1[0], p2[1] - p1[1])\\n                v31 = (p3[0] - p1[0], p3[1] - p1[1])\\n                if abs(v21[0] * v31[0] + v21[1] * v31[1]) == 0:\\n                    area = vector_len(v21) * vector_len(v31)\\n                    if area < ans:\\n                        ans = area\\n        \\n        return ans if ans < float(\"inf\") else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282378,
                "title": "python-o-n-2-logn-avoid-divide-operation",
                "content": "We can avoid division operation and use pure vector operation to solve this problem\\n\\nSome pre-knowledge\\n\\n1. Cross Product --->  c_prod(v1, v2) = x1*y2 - x2*y1\\n2. Area formula in Coordinates ---->area(v1, v2) = abs(c_prod)  (v1, v2 is the vector of 2 vertical edge of the rectangle)\\n3. Middle point formula ----> mid(p1, p2) = ((x1+x2)/2, (y1+y2)/2)\\n4. Distance formula ----> dist(p1, p2) = SQRT ( (x1-x2)\\\\**2 + (y1-y2)\\\\**2 )\\n\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        from collections import defaultdict\\n        \\n        dic = defaultdict(list)\\n        \\n        for i in range(len(points)-1):\\n            for j in range(i+1, len(points)):\\n                pi = points[i]\\n                pj = points[j]\\n                \\n                mx, my = (pi[0] + pj[0], pi[1] + pj[1])\\n                \\n                dia_sq = (pi[0] - pj[0]) ** 2 + (pi[1] - pj[1]) ** 2\\n                \\n                dic[mx, my, dia_sq].append(pi)\\n        \\n        ans = float(\\'inf\\')\\n                        \\n        for (mx, my, _), lst in dic.items():\\n            for i in range(len(lst)-1):\\n                for j in range(i+1, len(lst)):\\n                    pi = lst[i]\\n                    pj = lst[j]\\n                    \\n                    neg_pj = [mx - pj[0], my - pj[1]]\\n                    \\n                    x1, y1 = pj[0] - pi[0], pj[1] - pi[1]\\n                    x2, y2 = neg_pj[0] - pi[0], neg_pj[1] - pi[1]\\n                                        \\n                    area = abs(x1 * y2 - x2 * y1)\\n                    \\n                    ans = min(area, ans)\\n                    \\n        return float(ans) if ans != float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        from collections import defaultdict\\n        \\n        dic = defaultdict(list)\\n        \\n        for i in range(len(points)-1):\\n            for j in range(i+1, len(points)):\\n                pi = points[i]\\n                pj = points[j]\\n                \\n                mx, my = (pi[0] + pj[0], pi[1] + pj[1])\\n                \\n                dia_sq = (pi[0] - pj[0]) ** 2 + (pi[1] - pj[1]) ** 2\\n                \\n                dic[mx, my, dia_sq].append(pi)\\n        \\n        ans = float(\\'inf\\')\\n                        \\n        for (mx, my, _), lst in dic.items():\\n            for i in range(len(lst)-1):\\n                for j in range(i+1, len(lst)):\\n                    pi = lst[i]\\n                    pj = lst[j]\\n                    \\n                    neg_pj = [mx - pj[0], my - pj[1]]\\n                    \\n                    x1, y1 = pj[0] - pi[0], pj[1] - pi[1]\\n                    x2, y2 = neg_pj[0] - pi[0], neg_pj[1] - pi[1]\\n                                        \\n                    area = abs(x1 * y2 - x2 * y1)\\n                    \\n                    ans = min(area, ans)\\n                    \\n        return float(ans) if ans != float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227068,
                "title": "js-beats-100-with-172-ms-while-existing-fastest-solution-takes-1016ms",
                "content": "The idea is to check if first 3 points constructs a right triangle, if yes, we will then try to find the fouth point easily with the info which point is the right angle point.\\n```\\nfunction distance2([x1, y1], [x2, y2]) {\\n    return (x2 - x1) ** 2 + (y2 - y1) ** 2;\\n}\\n\\nfunction rightTriangle(p1, p2, p3) {\\n    const s12 = distance2(p1, p2);\\n    const s23 = distance2(p2, p3);\\n    const s13 = distance2(p1, p3);\\n    if (s12 + s23 === s13) return [p2, p1, p3];\\n    if (s23 + s13 === s12) return [p3, p1, p2];\\n    if (s13 + s12 === s23) return [p1, p2, p3];\\n    return null;\\n}\\n\\nfunction fourthPoint([[xr, yr], [x1, y1], [x2, y2]]) {\\n    return [x1 + x2 - xr, y1 + y2 - yr];\\n}\\n\\nfunction area([pr, p1, p2]) {\\n    return distance2(pr, p1) * distance2(pr, p2);\\n}\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    const set = new Set(points.map(p => p.join(\\',\\')));\\n    let min = Infinity;\\n    const N = points.length;\\n    for (let i = 0; i < N; i++) {\\n        const pi = points[i];\\n        for (let j = i + 1; j < N; j++) {\\n            const pj = points[j];\\n            for (let k = j + 1; k < N; k++) {\\n                const pk = points[k];\\n                const rt = rightTriangle(pi, pj, pk);\\n                if (rt) {\\n                    const fourth = fourthPoint(rt);\\n                    if (set.has(fourth.join(\\',\\'))) {\\n                        min = Math.min(min, area(rt));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return min === Infinity ? 0 : Math.sqrt(min);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction distance2([x1, y1], [x2, y2]) {\\n    return (x2 - x1) ** 2 + (y2 - y1) ** 2;\\n}\\n\\nfunction rightTriangle(p1, p2, p3) {\\n    const s12 = distance2(p1, p2);\\n    const s23 = distance2(p2, p3);\\n    const s13 = distance2(p1, p3);\\n    if (s12 + s23 === s13) return [p2, p1, p3];\\n    if (s23 + s13 === s12) return [p3, p1, p2];\\n    if (s13 + s12 === s23) return [p1, p2, p3];\\n    return null;\\n}\\n\\nfunction fourthPoint([[xr, yr], [x1, y1], [x2, y2]]) {\\n    return [x1 + x2 - xr, y1 + y2 - yr];\\n}\\n\\nfunction area([pr, p1, p2]) {\\n    return distance2(pr, p1) * distance2(pr, p2);\\n}\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    const set = new Set(points.map(p => p.join(\\',\\')));\\n    let min = Infinity;\\n    const N = points.length;\\n    for (let i = 0; i < N; i++) {\\n        const pi = points[i];\\n        for (let j = i + 1; j < N; j++) {\\n            const pj = points[j];\\n            for (let k = j + 1; k < N; k++) {\\n                const pk = points[k];\\n                const rt = rightTriangle(pi, pj, pk);\\n                if (rt) {\\n                    const fourth = fourthPoint(rt);\\n                    if (set.has(fourth.join(\\',\\'))) {\\n                        min = Math.min(min, area(rt));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return min === Infinity ? 0 : Math.sqrt(min);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208329,
                "title": "java-o-n-3-solution",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer,Set<Integer>> map = new HashMap<>();\\n        for (int[] p : points){\\n            map.putIfAbsent(p[0], new HashSet<>());\\n            map.get(p[0]).add(p[1]);\\n        }\\n        double min = Double.MAX_VALUE;\\n        int n = points.length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = i + 1; j < n; j++){\\n                for (int k = j + 1; k < n; k++){\\n                    int[] p1 = points[i], p2 = points[j], p3 = points[k];\\n                    if (ver(p1, p2, p3)){\\n                        int[] temp = p4(p1, p2, p3);\\n                        if (map.containsKey(temp[0]) && map.get(temp[0]).contains(temp[1])){\\n                            min = Math.min(min, area(p1, p2, p3));\\n                        }\\n                    }\\n                    if (ver(p2, p1, p3)){\\n                        int[] temp1 = p4(p2, p1, p3);\\n                        if (map.containsKey(temp1[0]) && map.get(temp1[0]).contains(temp1[1])){\\n                            min = Math.min(min, area(p2, p1, p3));\\n                        }\\n                    }\\n                    if (ver(p3, p2, p1)){\\n                        int[] temp2 = p4(p3, p2, p1);\\n                        if (map.containsKey(temp2[0]) && map.get(temp2[0]).contains(temp2[1])){\\n                            min = Math.min(min, area(p3, p2, p1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n    public int[] p4(int[] p1, int[] p2, int[] p3){ // find point p4 \\n        return new int[]{p3[0] - p1[0] + p2[0], p3[1] - p1[1] + p2[1]};\\n    }\\n    public boolean ver(int[] p1, int[] p2, int[] p3){//detemine vector p1p2 and vector p1p3 are vertical or not\\n        int x1 = p2[0] - p1[0], y1 = p2[1] - p1[1];\\n        int x2 = p3[0] - p1[0], y2 = p3[1] - p1[1];\\n        return x1 * x2 + y1 * y2 == 0;\\n    }\\n    public double area(int[] p1, int[] p2, int[] p3){\\n        int x1 = p2[0] - p1[0], y1 = p2[1] - p1[1];\\n        int x2 = p3[0] - p1[0], y2 = p3[1] - p1[1];\\n        return Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer,Set<Integer>> map = new HashMap<>();\\n        for (int[] p : points){\\n            map.putIfAbsent(p[0], new HashSet<>());\\n            map.get(p[0]).add(p[1]);\\n        }\\n        double min = Double.MAX_VALUE;\\n        int n = points.length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = i + 1; j < n; j++){\\n                for (int k = j + 1; k < n; k++){\\n                    int[] p1 = points[i], p2 = points[j], p3 = points[k];\\n                    if (ver(p1, p2, p3)){\\n                        int[] temp = p4(p1, p2, p3);\\n                        if (map.containsKey(temp[0]) && map.get(temp[0]).contains(temp[1])){\\n                            min = Math.min(min, area(p1, p2, p3));\\n                        }\\n                    }\\n                    if (ver(p2, p1, p3)){\\n                        int[] temp1 = p4(p2, p1, p3);\\n                        if (map.containsKey(temp1[0]) && map.get(temp1[0]).contains(temp1[1])){\\n                            min = Math.min(min, area(p2, p1, p3));\\n                        }\\n                    }\\n                    if (ver(p3, p2, p1)){\\n                        int[] temp2 = p4(p3, p2, p1);\\n                        if (map.containsKey(temp2[0]) && map.get(temp2[0]).contains(temp2[1])){\\n                            min = Math.min(min, area(p3, p2, p1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n    public int[] p4(int[] p1, int[] p2, int[] p3){ // find point p4 \\n        return new int[]{p3[0] - p1[0] + p2[0], p3[1] - p1[1] + p2[1]};\\n    }\\n    public boolean ver(int[] p1, int[] p2, int[] p3){//detemine vector p1p2 and vector p1p3 are vertical or not\\n        int x1 = p2[0] - p1[0], y1 = p2[1] - p1[1];\\n        int x2 = p3[0] - p1[0], y2 = p3[1] - p1[1];\\n        return x1 * x2 + y1 * y2 == 0;\\n    }\\n    public double area(int[] p1, int[] p2, int[] p3){\\n        int x1 = p2[0] - p1[0], y1 = p2[1] - p1[1];\\n        int x2 = p3[0] - p1[0], y2 = p3[1] - p1[1];\\n        return Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530807,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double _Area, minArea = 0.0;\\n        if (points.size() < 4){\\n            return 0;\\n        }\\n        int x0, y0;\\n        int x1, y1;\\n        int x2, y2;\\n        int x3, y3;\\n        int Lx1, Ly1;\\n        int Lx2, Ly2;\\n        for(int i = 0; i < points.size() - 3; i ++){\\n\\n            x0 = points[i][0];\\n            y0 = points[i][1];\\n\\n            for (int j = i + 1; j < points.size(); j ++){\\n                x1 = points[j][0];\\n                y1 = points[j][1];\\n                for (int k = j + 1; k < points.size(); k ++){\\n                    x2 = points[k][0];\\n                    y2 = points[k][1];\\n\\n                    Lx1 = x1 - x0;\\n                    Ly1 = y1 - y0;\\n                    \\n                    Lx2 = x2 - x0;\\n                    Ly2 = y2 - y0;\\n\\n                    int dotProd = Lx1 * Lx2 + Ly1 * Ly2;\\n                    if (dotProd != 0){\\n                        continue;\\n                    }\\n                    bool skip = true;\\n                    for (int n = 0; n < points.size(); n ++){\\n                        x3 = points[n][0];\\n                        y3 = points[n][1];\\n                        if ((x3 == x0 + Lx1 + Lx2) && (y3 == y0 + Ly1 + Ly2)){\\n                            skip = false;\\n                            break;\\n                        }\\n                    }\\n                    if(skip == true){\\n                        continue;\\n                    }\\n                    _Area = (double)abs(Lx1 * Ly2 - Ly1 * Lx2);\\n\\n                    if (minArea == 0.0){\\n                        minArea = _Area; \\n                    }else{\\n                        minArea = minArea < _Area ? minArea : _Area;\\n                    }\\n                }\\n            }\\n        }\\n        return minArea;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        x, y = 0, 1\\n        vec = lambda p, q: [q[x]-p[x], q[y]-p[y]]\\n        area = lambda p,q: p[x]*q[y] - p[y]*q[x]\\n        dist = lambda p,q: (p[x]-q[x])**2 + (p[y]-q[y])**2\\n        mid_to_diagonals = defaultdict(list)\\n        for p,q in combinations(points, 2):\\n            key = p[x] + q[x], p[y] + q[y]\\n            mid_to_diagonals[key].append((p,q))\\n        res = float(\\'inf\\')\\n        for group in mid_to_diagonals.values():\\n            for (a,b), (c,d) in combinations(group, 2):\\n                if dist(a,b) == dist(c,d):\\n                    res = min(res, abs(area(vec(a,b), vec(a,d))))\\n        return res if res != float(\\'inf\\') else 0\\n```\\n\\n```Java []\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        HashSet<Point> pointsSet = new HashSet<>();\\n        for (int i = 0; i < points.length; i++) {\\n            pointsSet.add(new Point(points[i][0], points[i][1]));\\n        }\\n        double minSq = 2.0 * (double)Long.MAX_VALUE;\\n        boolean hasRects = false;\\n        for (int i2 = 0; i2 < points.length; i2++) {\\n            for (int i1 = i2 + 1; i1 < points.length; i1++) {\\n                long d12 = d2(points[i1], points[i2]);\\n                for (int i3 = i1 + 1; i3 < points.length; i3++) {\\n                    long d23 = d2(points[i2], points[i3]);\\n                    if (d12 + d23 != d2(points[i1], points[i3])) {\\n                        continue;\\n                    }\\n                    if (pointsSet.contains(new Point(points[i1][0] + points[i3][0] - points[i2][0], points[i1][1] + points[i3][1] - points[i2][1]))) {\\n                        hasRects = true;\\n                        minSq = Math.min(minSq, d12 * d23);\\n                    }\\n                }\\n            }\\n        }\\n        return hasRects ? Math.sqrt(minSq) : 0.0;\\n    }\\n    private long d2(int[] p1, int[] p2) {\\n        return ((long)p2[0] - (long)p1[0]) * ((long)p2[0] - (long)p1[0]) + ((long)p2[1] - (long)p1[1]) * ((long)p2[1] - (long)p1[1]);\\n    }\\n    private static class Point{\\n        int x;\\n        int y;\\n\\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            return x + y * 13;\\n        }\\n        @Override\\n        public boolean equals(Object other) {\\n            Point otherPoint = (Point)other;\\n\\n            return otherPoint.x == x && otherPoint.y == y;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double _Area, minArea = 0.0;\\n        if (points.size() < 4){\\n            return 0;\\n        }\\n        int x0, y0;\\n        int x1, y1;\\n        int x2, y2;\\n        int x3, y3;\\n        int Lx1, Ly1;\\n        int Lx2, Ly2;\\n        for(int i = 0; i < points.size() - 3; i ++){\\n\\n            x0 = points[i][0];\\n            y0 = points[i][1];\\n\\n            for (int j = i + 1; j < points.size(); j ++){\\n                x1 = points[j][0];\\n                y1 = points[j][1];\\n                for (int k = j + 1; k < points.size(); k ++){\\n                    x2 = points[k][0];\\n                    y2 = points[k][1];\\n\\n                    Lx1 = x1 - x0;\\n                    Ly1 = y1 - y0;\\n                    \\n                    Lx2 = x2 - x0;\\n                    Ly2 = y2 - y0;\\n\\n                    int dotProd = Lx1 * Lx2 + Ly1 * Ly2;\\n                    if (dotProd != 0){\\n                        continue;\\n                    }\\n                    bool skip = true;\\n                    for (int n = 0; n < points.size(); n ++){\\n                        x3 = points[n][0];\\n                        y3 = points[n][1];\\n                        if ((x3 == x0 + Lx1 + Lx2) && (y3 == y0 + Ly1 + Ly2)){\\n                            skip = false;\\n                            break;\\n                        }\\n                    }\\n                    if(skip == true){\\n                        continue;\\n                    }\\n                    _Area = (double)abs(Lx1 * Ly2 - Ly1 * Lx2);\\n\\n                    if (minArea == 0.0){\\n                        minArea = _Area; \\n                    }else{\\n                        minArea = minArea < _Area ? minArea : _Area;\\n                    }\\n                }\\n            }\\n        }\\n        return minArea;\\n    }\\n};\\n```\n```Python3 []\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        x, y = 0, 1\\n        vec = lambda p, q: [q[x]-p[x], q[y]-p[y]]\\n        area = lambda p,q: p[x]*q[y] - p[y]*q[x]\\n        dist = lambda p,q: (p[x]-q[x])**2 + (p[y]-q[y])**2\\n        mid_to_diagonals = defaultdict(list)\\n        for p,q in combinations(points, 2):\\n            key = p[x] + q[x], p[y] + q[y]\\n            mid_to_diagonals[key].append((p,q))\\n        res = float(\\'inf\\')\\n        for group in mid_to_diagonals.values():\\n            for (a,b), (c,d) in combinations(group, 2):\\n                if dist(a,b) == dist(c,d):\\n                    res = min(res, abs(area(vec(a,b), vec(a,d))))\\n        return res if res != float(\\'inf\\') else 0\\n```\n```Java []\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        HashSet<Point> pointsSet = new HashSet<>();\\n        for (int i = 0; i < points.length; i++) {\\n            pointsSet.add(new Point(points[i][0], points[i][1]));\\n        }\\n        double minSq = 2.0 * (double)Long.MAX_VALUE;\\n        boolean hasRects = false;\\n        for (int i2 = 0; i2 < points.length; i2++) {\\n            for (int i1 = i2 + 1; i1 < points.length; i1++) {\\n                long d12 = d2(points[i1], points[i2]);\\n                for (int i3 = i1 + 1; i3 < points.length; i3++) {\\n                    long d23 = d2(points[i2], points[i3]);\\n                    if (d12 + d23 != d2(points[i1], points[i3])) {\\n                        continue;\\n                    }\\n                    if (pointsSet.contains(new Point(points[i1][0] + points[i3][0] - points[i2][0], points[i1][1] + points[i3][1] - points[i2][1]))) {\\n                        hasRects = true;\\n                        minSq = Math.min(minSq, d12 * d23);\\n                    }\\n                }\\n            }\\n        }\\n        return hasRects ? Math.sqrt(minSq) : 0.0;\\n    }\\n    private long d2(int[] p1, int[] p2) {\\n        return ((long)p2[0] - (long)p1[0]) * ((long)p2[0] - (long)p1[0]) + ((long)p2[1] - (long)p1[1]) * ((long)p2[1] - (long)p1[1]);\\n    }\\n    private static class Point{\\n        int x;\\n        int y;\\n\\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            return x + y * 13;\\n        }\\n        @Override\\n        public boolean equals(Object other) {\\n            Point otherPoint = (Point)other;\\n\\n            return otherPoint.x == x && otherPoint.y == y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714123,
                "title": "python-center-points",
                "content": "```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        x, y = 0, 1\\n        vec = lambda p, q: [q[x]-p[x], q[y]-p[y]]\\n        area = lambda p,q: p[x]*q[y] - p[y]*q[x]\\n        dist = lambda p,q: (p[x]-q[x])**2 + (p[y]-q[y])**2\\n        mid_to_diagonals = defaultdict(list)\\n        for p,q in combinations(points, 2):\\n            key = p[x] + q[x], p[y] + q[y]\\n            mid_to_diagonals[key].append((p,q))\\n        res = float(\\'inf\\')\\n        for group in mid_to_diagonals.values():\\n            for (a,b), (c,d) in combinations(group, 2):\\n                if dist(a,b) == dist(c,d):\\n                    res = min(res, abs(area(vec(a,b), vec(a,d))))\\n        return res if res != float(\\'inf\\') else 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        x, y = 0, 1\\n        vec = lambda p, q: [q[x]-p[x], q[y]-p[y]]\\n        area = lambda p,q: p[x]*q[y] - p[y]*q[x]\\n        dist = lambda p,q: (p[x]-q[x])**2 + (p[y]-q[y])**2\\n        mid_to_diagonals = defaultdict(list)\\n        for p,q in combinations(points, 2):\\n            key = p[x] + q[x], p[y] + q[y]\\n            mid_to_diagonals[key].append((p,q))\\n        res = float(\\'inf\\')\\n        for group in mid_to_diagonals.values():\\n            for (a,b), (c,d) in combinations(group, 2):\\n                if dist(a,b) == dist(c,d):\\n                    res = min(res, abs(area(vec(a,b), vec(a,d))))\\n        return res if res != float(\\'inf\\') else 0",
                "codeTag": "Java"
            },
            {
                "id": 2340767,
                "title": "runtime-96-ms-faster-than-97-40-of-python3-python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/4714725b-1c75-4f18-b154-de9846fe0776_1658920855.742452.png)\\nRuntime: 96 ms, faster than 97.40% of Python3 online submissions for Minimum Area Rectangle II.\\nMemory Usage: 14.2 MB, less than 55.19% of Python3 online submissions for Minimum Area Rectangle II.\\n\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        N = len(points)\\n        \\n        seen = set()\\n        for point in points:\\n            seen.add(tuple(point))\\n\\n        # length^2\\n        def length2(a, b):\\n            return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\\n        \\n        best = 1e30\\n        for i in range(N):\\n            for j in range(N):\\n                if i == j:\\n                    continue\\n                \\n                lij = length2(points[i], points[j])\\n                for k in range(N):\\n                    if i == k or j == k:\\n                        continue\\n                    \\n                    # given i->j line, add to k to find l\\n                    dx, dy = points[j][0] - points[i][0], points[j][1] - points[i][1]\\n                    \\n                    pl = (points[k][0] + dx, points[k][1] + dy)\\n                    if pl not in seen:\\n                        continue\\n                    \\n                    lik = length2(points[i], points[k])\\n                    ljk = length2(points[j], points[k])\\n\\n                    lil = length2(points[i], pl)\\n                    ljl = length2(points[j], pl)\\n                    lkl = length2(points[k], pl)\\n                    \\n                    if lij == lkl and lik == ljl and lil == ljk:\\n                        best = min(best, sqrt(lij * lik * lil) / sqrt(max(lij, lik, lil)))\\n                    \\n        if best >= 1e29:\\n            return 0\\n        return best\\n```\\n\\nif you found any doubt .. do mention me in comment section :)\\n\\nhappy to help",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        N = len(points)\\n        \\n        seen = set()\\n        for point in points:\\n            seen.add(tuple(point))\\n\\n        # length^2\\n        def length2(a, b):\\n            return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\\n        \\n        best = 1e30\\n        for i in range(N):\\n            for j in range(N):\\n                if i == j:\\n                    continue\\n                \\n                lij = length2(points[i], points[j])\\n                for k in range(N):\\n                    if i == k or j == k:\\n                        continue\\n                    \\n                    # given i->j line, add to k to find l\\n                    dx, dy = points[j][0] - points[i][0], points[j][1] - points[i][1]\\n                    \\n                    pl = (points[k][0] + dx, points[k][1] + dy)\\n                    if pl not in seen:\\n                        continue\\n                    \\n                    lik = length2(points[i], points[k])\\n                    ljk = length2(points[j], points[k])\\n\\n                    lil = length2(points[i], pl)\\n                    ljl = length2(points[j], pl)\\n                    lkl = length2(points[k], pl)\\n                    \\n                    if lij == lkl and lik == ljl and lil == ljk:\\n                        best = min(best, sqrt(lij * lik * lil) / sqrt(max(lij, lik, lil)))\\n                    \\n        if best >= 1e29:\\n            return 0\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426272,
                "title": "c-solution",
                "content": "```\\nclass Point{\\npublic:\\n    double x, y;\\n    \\n    Point(double x, double y){\\n        this->x = x;\\n        this->y = y;\\n    }\\n    \\n    double dist(Point *point){\\n        double value_one = point->x - this->x;\\n        double value_two = point->y - this->y;\\n        \\n        return sqrt(pow(value_one, 2) + pow(value_two, 2));\\n    }\\n    \\n    Point *center(Point *point){\\n        double x_center = (point->x + this->x) / 2;\\n        double y_center = (point->y + this->y) / 2;\\n        \\n        Point *centerPoint = new Point(x_center, y_center);\\n        return centerPoint;\\n    }\\n};\\n\\n\\ntypedef unordered_map<string, vector<pair<Point*, Point*>>> diagDT;\\nclass Solution {\\nprivate:\\n    string key(string distance, string centerXY){\\n        return distance + \" -> \" + centerXY;\\n    }\\n    \\n    void fillDiagonalValues(vector<vector<int>> &points, diagDT &diagonals){\\n        for(int i = 0; i < points.size(); i++){\\n            Point *point_one = new Point(points.at(i).at(0), points.at(i).at(1));\\n            \\n            for(int j = i + 1; j < points.size(); j++){\\n                Point *point_two = new Point(points.at(j).at(0), points.at(j).at(1));\\n                           \\n                Point *center   = point_one->center(point_two);\\n                string distance = to_string(point_one->dist(point_two));\\n                string centerXY = to_string(center->x) + \", \" + to_string(center->y);\\n                \\n                diagonals[key(distance, centerXY)].push_back({point_one, point_two});\\n            }\\n        }\\n    }\\n    \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        diagDT diagonals;\\n        fillDiagonalValues(points, diagonals);\\n        \\n        double minArea = INT_MAX;\\n        for(auto iter = diagonals.begin(); iter != diagonals.end(); iter++){\\n           \\n            vector<pair<Point*, Point*>> diagonalPoints = iter->second;\\n            for(int i = 0; i < diagonalPoints.size(); i++){\\n                Point *point_one = diagonalPoints.at(i).first;\\n                Point *point_two = diagonalPoints.at(i).second;\\n                \\n                for(int j = i + 1; j < diagonalPoints.size(); j++){\\n                    Point *point_three = diagonalPoints.at(j).first;\\n                    \\n                    double length = point_one->dist(point_three);\\n                    double width  = point_two->dist(point_three);\\n                    minArea = min(minArea, (length * width));\\n                }\\n            }\\n        }\\n        \\n        return minArea != double(INT_MAX) ? minArea : 0;\\n    }\\n};\\n```\\n\\n**Solution Inspired By :** https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/1214523/Abstracted-and-Elegant-C%2B%2B-Diagonal-Solution and https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/208361/JAVA-O(n2)-using-Map",
                "solutionTags": [],
                "code": "```\\nclass Point{\\npublic:\\n    double x, y;\\n    \\n    Point(double x, double y){\\n        this->x = x;\\n        this->y = y;\\n    }\\n    \\n    double dist(Point *point){\\n        double value_one = point->x - this->x;\\n        double value_two = point->y - this->y;\\n        \\n        return sqrt(pow(value_one, 2) + pow(value_two, 2));\\n    }\\n    \\n    Point *center(Point *point){\\n        double x_center = (point->x + this->x) / 2;\\n        double y_center = (point->y + this->y) / 2;\\n        \\n        Point *centerPoint = new Point(x_center, y_center);\\n        return centerPoint;\\n    }\\n};\\n\\n\\ntypedef unordered_map<string, vector<pair<Point*, Point*>>> diagDT;\\nclass Solution {\\nprivate:\\n    string key(string distance, string centerXY){\\n        return distance + \" -> \" + centerXY;\\n    }\\n    \\n    void fillDiagonalValues(vector<vector<int>> &points, diagDT &diagonals){\\n        for(int i = 0; i < points.size(); i++){\\n            Point *point_one = new Point(points.at(i).at(0), points.at(i).at(1));\\n            \\n            for(int j = i + 1; j < points.size(); j++){\\n                Point *point_two = new Point(points.at(j).at(0), points.at(j).at(1));\\n                           \\n                Point *center   = point_one->center(point_two);\\n                string distance = to_string(point_one->dist(point_two));\\n                string centerXY = to_string(center->x) + \", \" + to_string(center->y);\\n                \\n                diagonals[key(distance, centerXY)].push_back({point_one, point_two});\\n            }\\n        }\\n    }\\n    \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        diagDT diagonals;\\n        fillDiagonalValues(points, diagonals);\\n        \\n        double minArea = INT_MAX;\\n        for(auto iter = diagonals.begin(); iter != diagonals.end(); iter++){\\n           \\n            vector<pair<Point*, Point*>> diagonalPoints = iter->second;\\n            for(int i = 0; i < diagonalPoints.size(); i++){\\n                Point *point_one = diagonalPoints.at(i).first;\\n                Point *point_two = diagonalPoints.at(i).second;\\n                \\n                for(int j = i + 1; j < diagonalPoints.size(); j++){\\n                    Point *point_three = diagonalPoints.at(j).first;\\n                    \\n                    double length = point_one->dist(point_three);\\n                    double width  = point_two->dist(point_three);\\n                    minArea = min(minArea, (length * width));\\n                }\\n            }\\n        }\\n        \\n        return minArea != double(INT_MAX) ? minArea : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424599,
                "title": "easy-understanding-java-o-n-3-solution-with-comment",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Pair<Double, Double>, Map<Double, List<int[][]>>> map = new HashMap<>();\\n        \\n        double res = Double.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            int[] p1 = points[i];\\n            for (int j = i+1; j < points.length; j++) {\\n                int[] p2 = points[j];\\n                // get mid point\\n                Pair<Double, Double> pm = new Pair((p1[0]+p2[0])/2d, (p1[1]+p2[1])/2d);\\n                if (!map.containsKey(pm))\\n                    map.put(pm, new HashMap<>());\\n                // get diagonal length\\n                double dist2 = dist2(p1, p2);\\n                if (!map.get(pm).containsKey(dist2))\\n                    map.get(pm).put(dist2, new ArrayList<>());\\n                \\n                // calculate area for each pair of p3/p4 and check min\\n\\t\\t\\t\\t// Worst case is each pair has same mid point with same length\\n\\t\\t\\t\\t// At worst case, below operation costs O(N)\\n                for (int[][] ps : map.get(pm).get(dist2)) {\\n                    double d1 = dist2(p1, ps[0]);\\n                    double d2 = dist2(p1, ps[1]);\\n                    res = Math.min(res, Math.sqrt(d1 * d2));\\n                }\\n                map.get(pm).get(dist2).add(new int[][]{p1, p2});\\n            }\\n        }\\n        \\n        return res == Double.MAX_VALUE ? 0 : res;\\n    }\\n    \\n    private double dist2(int[] p1, int[] p2) {\\n        return (p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Pair<Double, Double>, Map<Double, List<int[][]>>> map = new HashMap<>();\\n        \\n        double res = Double.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            int[] p1 = points[i];\\n            for (int j = i+1; j < points.length; j++) {\\n                int[] p2 = points[j];\\n                // get mid point\\n                Pair<Double, Double> pm = new Pair((p1[0]+p2[0])/2d, (p1[1]+p2[1])/2d);\\n                if (!map.containsKey(pm))\\n                    map.put(pm, new HashMap<>());\\n                // get diagonal length\\n                double dist2 = dist2(p1, p2);\\n                if (!map.get(pm).containsKey(dist2))\\n                    map.get(pm).put(dist2, new ArrayList<>());\\n                \\n                // calculate area for each pair of p3/p4 and check min\\n\\t\\t\\t\\t// Worst case is each pair has same mid point with same length\\n\\t\\t\\t\\t// At worst case, below operation costs O(N)\\n                for (int[][] ps : map.get(pm).get(dist2)) {\\n                    double d1 = dist2(p1, ps[0]);\\n                    double d2 = dist2(p1, ps[1]);\\n                    res = Math.min(res, Math.sqrt(d1 * d2));\\n                }\\n                map.get(pm).get(dist2).add(new int[][]{p1, p2});\\n            }\\n        }\\n        \\n        return res == Double.MAX_VALUE ? 0 : res;\\n    }\\n    \\n    private double dist2(int[] p1, int[] p2) {\\n        return (p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985812,
                "title": "clean-python-iterative-centers",
                "content": "**Clean Python | Iterative Centers**\\n\\n```\\nclass Solution:\\n    Inf = float(\\'inf\\')\\n    def minAreaFreeRect(self, A):\\n        #\\n        L    = len(A)\\n        res  = self.Inf\\n        sqrt = math.sqrt\\n        #\\n        dist = lambda x1,y1,x2,y2: sqrt( (x2-x1)**2 + (y2-y1)**2 )\\n        D    = defaultdict(list)\\n        #\\n        for i1 in range(L):\\n            for i2 in range(i1+1,L):\\n                x1,y1 = A[i1]\\n                x2,y2 = A[i2]\\n                C     = (x2+x1)/2. , (y2+y1)/2.\\n                r2    = (x2-x1)**2 + (y2-y1)**2\\n                #\\n                if (C,r2) in D:\\n                    for x3,y3 in D[C,r2]:\\n                        res = min(res, dist(x1,y1,x3,y3)*dist(x2,y2,x3,y3) )\\n                #\\n                D[C,r2].append( (x1,y1) )\\n        #\\n        return 0 if res==self.Inf else res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    Inf = float(\\'inf\\')\\n    def minAreaFreeRect(self, A):\\n        #\\n        L    = len(A)\\n        res  = self.Inf\\n        sqrt = math.sqrt\\n        #\\n        dist = lambda x1,y1,x2,y2: sqrt( (x2-x1)**2 + (y2-y1)**2 )\\n        D    = defaultdict(list)\\n        #\\n        for i1 in range(L):\\n            for i2 in range(i1+1,L):\\n                x1,y1 = A[i1]\\n                x2,y2 = A[i2]\\n                C     = (x2+x1)/2. , (y2+y1)/2.\\n                r2    = (x2-x1)**2 + (y2-y1)**2\\n                #\\n                if (C,r2) in D:\\n                    for x3,y3 in D[C,r2]:\\n                        res = min(res, dist(x1,y1,x3,y3)*dist(x2,y2,x3,y3) )\\n                #\\n                D[C,r2].append( (x1,y1) )\\n        #\\n        return 0 if res==self.Inf else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926092,
                "title": "java-o-n-2-easy-to-understand",
                "content": "1. Calculate distance between all possible pairs of points and group together pairs which has same distance.\\n2. Compare all lines (pair of points) with same distance and check if it forms a rectangle. To check if it\\'s a rectangle- distance of other sides of rect and diagonals should be same (trapezium will have unequal diagonals). Consider distances x(smaller side)<y(larger side)<z(diagonal) -area would be x*y.\\n3. Return min area.\\n\\n\\n\\n\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if(points.length==0) return 0;\\n        int N = points.length;        \\n        double[][] dist = new double[N][N];\\n        HashMap<Double, ArrayList<Pair>> map = new HashMap<>();        \\n        \\n        for(int i=0; i<N; i++){\\n            for(int j=i+1; j<N; j++){\\n                int x = Math.abs(points[i][0]-points[j][0]);\\n                int y = Math.abs(points[i][1]-points[j][1]);\\n                dist[i][j] = Math.sqrt(x*x+y*y );\\n                ArrayList<Pair> list = map.getOrDefault(dist[i][j], new ArrayList<>());\\n                map.putIfAbsent(dist[i][j],list);\\n                list.add(new Pair(i,j));                \\n            }\\n        }\\n        \\n        double minarea = Double.MAX_VALUE;\\n        for( Map.Entry<Double,ArrayList<Pair>> entry:map.entrySet()){\\n            List<Pair> list = entry.getValue();\\n            for( int i=0; i<list.size(); i++){\\n                for( int j=i+1; j<list.size(); j++){\\n                    Pair p1 = list.get(i);\\n                    Pair p2 = list.get(j);\\n                    if(dist[p1.pt1][p2.pt1] == dist[p1.pt2][p2.pt2] && dist[p1.pt1][p2.pt2] == dist[p1.pt2][p2.pt1]){\\n                        ArrayList<Double> temp = new ArrayList<>();\\n                        temp.add(entry.getKey());\\n                        temp.add(dist[p1.pt1][p2.pt1]);\\n                        temp.add(dist[p1.pt1][p2.pt2]);\\n                        Collections.sort(temp);\\n                        double curr = temp.get(0)*temp.get(1);\\n                        if(curr<minarea){\\n                            minarea = curr;\\n                        }\\n                    }\\n\\n                }        \\n            }\\n        }\\n        \\n        if(minarea==Double.MAX_VALUE)\\n            minarea = 0;\\n        \\n        return minarea;\\n        \\n    }\\n    \\n    class Pair{\\n        int pt1;\\n        int pt2;\\n        \\n        Pair(int p1, int p2){\\n            this.pt1 = p1;\\n            this.pt2 = p2;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if(points.length==0) return 0;\\n        int N = points.length;        \\n        double[][] dist = new double[N][N];\\n        HashMap<Double, ArrayList<Pair>> map = new HashMap<>();        \\n        \\n        for(int i=0; i<N; i++){\\n            for(int j=i+1; j<N; j++){\\n                int x = Math.abs(points[i][0]-points[j][0]);\\n                int y = Math.abs(points[i][1]-points[j][1]);\\n                dist[i][j] = Math.sqrt(x*x+y*y );\\n                ArrayList<Pair> list = map.getOrDefault(dist[i][j], new ArrayList<>());\\n                map.putIfAbsent(dist[i][j],list);\\n                list.add(new Pair(i,j));                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 907240,
                "title": "diagonals-n-2-find-detailed-math",
                "content": "I used properties of diagonals -- if they have equal length and intersect in the middle we can form rectangular.\\nI expressed computaions using standard math operations like inner product, difference between two vectors, and cross product.\\n\\n```C++\\n    array<int, 2> dif(vector<int> const& a, vector<int> const& b) {\\n         return {b[0] - a[0], b[1] - a[1]};   \\n    }\\n    \\n    array<int, 2> dif(array<int, 2> const& a, array<int, 2> const& b) {\\n         return {b[0] - a[0], b[1] - a[1]};   \\n    }\\n    \\n    int crossNorm(array<int, 2> const& a, array<int, 2> const& b) {\\n         return abs(a[0]*b[1] - b[0]*a[1]);   \\n    }\\n    \\n    int inner(array<int, 2> const& a, array<int, 2> const& b)\\n    {\\n        return a[0]*b[0] + a[1]*b[1];\\n    }\\n    \\n    // consider diagonals\\n    // for that iterate over all pairs\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        const int n = points.size();\\n        int minArea = 1e9;\\n        \\n        unordered_map<int, vector< pair<int, int> > > seen;\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                const auto& a = points[i];\\n                const auto& b = points[j];\\n                array<int, 2> ab = dif(a, b);\\n                int dist2_ab = inner(ab, ab);\\n                auto it = seen.find(dist2_ab);\\n                if (it != seen.end())\\n                    for (auto&[k,w] : it->second) {\\n                        const auto& c = points[k];\\n                        const auto& d = points[w];\\n                        array<int, 2> cd = dif(c,d);\\n                        // need to check that they intersect in center of diagonals\\n                        // 0.5ab + a == 0.5cd + c \\n                        // iff ab + 2*a == cd + 2c\\n                        if (ab[0] + 2*a[0] == cd[0] + 2*c[0] &&\\n                            ab[1] + 2*a[1] == cd[1] + 2*c[1]) {\\n                            array<int, 2> ac = dif(a,c);\\n                            array<int, 2> bc = dif(b,c);\\n                        \\n                            minArea = min(minArea, crossNorm(ac, bc));\\n                        }\\n                            \\n                    }\\n                seen[dist2_ab].emplace_back(i, j);\\n            }\\n        }\\n        return minArea == 1e9 ? 0 : minArea;\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Geometry"
                ],
                "code": "```C++\\n    array<int, 2> dif(vector<int> const& a, vector<int> const& b) {\\n         return {b[0] - a[0], b[1] - a[1]};   \\n    }\\n    \\n    array<int, 2> dif(array<int, 2> const& a, array<int, 2> const& b) {\\n         return {b[0] - a[0], b[1] - a[1]};   \\n    }\\n    \\n    int crossNorm(array<int, 2> const& a, array<int, 2> const& b) {\\n         return abs(a[0]*b[1] - b[0]*a[1]);   \\n    }\\n    \\n    int inner(array<int, 2> const& a, array<int, 2> const& b)\\n    {\\n        return a[0]*b[0] + a[1]*b[1];\\n    }\\n    \\n    // consider diagonals\\n    // for that iterate over all pairs\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        const int n = points.size();\\n        int minArea = 1e9;\\n        \\n        unordered_map<int, vector< pair<int, int> > > seen;\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                const auto& a = points[i];\\n                const auto& b = points[j];\\n                array<int, 2> ab = dif(a, b);\\n                int dist2_ab = inner(ab, ab);\\n                auto it = seen.find(dist2_ab);\\n                if (it != seen.end())\\n                    for (auto&[k,w] : it->second) {\\n                        const auto& c = points[k];\\n                        const auto& d = points[w];\\n                        array<int, 2> cd = dif(c,d);\\n                        // need to check that they intersect in center of diagonals\\n                        // 0.5ab + a == 0.5cd + c \\n                        // iff ab + 2*a == cd + 2c\\n                        if (ab[0] + 2*a[0] == cd[0] + 2*c[0] &&\\n                            ab[1] + 2*a[1] == cd[1] + 2*c[1]) {\\n                            array<int, 2> ac = dif(a,c);\\n                            array<int, 2> bc = dif(b,c);\\n                        \\n                            minArea = min(minArea, crossNorm(ac, bc));\\n                        }\\n                            \\n                    }\\n                seen[dist2_ab].emplace_back(i, j);\\n            }\\n        }\\n        return minArea == 1e9 ? 0 : minArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 711984,
                "title": "swift-clean-code-80ms-beats-100",
                "content": "```swift\\nclass Solution {\\n  private typealias Point = (x: Int, y: Int)\\n  private typealias Segment = (p1: Point, p2: Point)\\n  \\n  func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n    let points = points.map { Point($0[0], $0[1]) }\\n    \\n    var map = [String: [Segment]]()\\n    for i in 0..<points.count - 1 {\\n      for j in i + 1..<points.count {\\n        let p1 = points[i]\\n        let p2 = points[j]\\n        let center = self.center(p1, p2)\\n        let distance = self.distance(p1, p2)\\n        let key = \"\\\\(distance)-\\\\(self.key(center))\"\\n        map[key, default: []].append(Segment(p1, p2))\\n      }\\n    }\\n    \\n    var result = Int.max\\n    for segments in map.values where segments.count > 1 {\\n      for i in 0..<segments.count - 1 {\\n        for j in i + 1..<segments.count {\\n          let segment1 = segments[i]\\n          let segment2 = segments[j]\\n          let size = distance(segment1.p1, segment2.p1) * distance(segment1.p2, segment2.p1)\\n          result = min(result, size)\\n        }\\n      }\\n    }\\n    return result == Int.max ? 0 : sqrt(Double(result))\\n  }\\n\\n  private func distance(_ p1: Point, _ p2: Point) -> Int {\\n    let dx = (p1.x - p2.x)\\n    let dy = (p1.y - p2.y)\\n    return dx * dx + dy * dy\\n  }\\n  \\n  private func center(_ p1: Point, _ p2: Point) -> Point {\\n    return (p1.x + p2.x, p1.y + p2.y)\\n  }\\n  \\n  private func key(_ point: Point) -> Int {\\n    return point.x * 40001 + point.y\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n  private typealias Point = (x: Int, y: Int)\\n  private typealias Segment = (p1: Point, p2: Point)\\n  \\n  func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n    let points = points.map { Point($0[0], $0[1]) }\\n    \\n    var map = [String: [Segment]]()\\n    for i in 0..<points.count - 1 {\\n      for j in i + 1..<points.count {\\n        let p1 = points[i]\\n        let p2 = points[j]\\n        let center = self.center(p1, p2)\\n        let distance = self.distance(p1, p2)\\n        let key = \"\\\\(distance)-\\\\(self.key(center))\"\\n        map[key, default: []].append(Segment(p1, p2))\\n      }\\n    }\\n    \\n    var result = Int.max\\n    for segments in map.values where segments.count > 1 {\\n      for i in 0..<segments.count - 1 {\\n        for j in i + 1..<segments.count {\\n          let segment1 = segments[i]\\n          let segment2 = segments[j]\\n          let size = distance(segment1.p1, segment2.p1) * distance(segment1.p2, segment2.p1)\\n          result = min(result, size)\\n        }\\n      }\\n    }\\n    return result == Int.max ? 0 : sqrt(Double(result))\\n  }\\n\\n  private func distance(_ p1: Point, _ p2: Point) -> Int {\\n    let dx = (p1.x - p2.x)\\n    let dy = (p1.y - p2.y)\\n    return dx * dx + dy * dy\\n  }\\n  \\n  private func center(_ p1: Point, _ p2: Point) -> Point {\\n    return (p1.x + p2.x, p1.y + p2.y)\\n  }\\n  \\n  private func key(_ point: Point) -> Int {\\n    return point.x * 40001 + point.y\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212270,
                "title": "12-ms-o-n-3logn-solution-better-than-98",
                "content": "1. Take every three points P, Q and R.\\n2. Now create two vectors PQ and PR\\n3. Check if dot product or PQ and PR is 0 and cross product of PQ and PR is not zero (because if < between PQ and PR is pi/2 then dot product will be zero and corss product is checking if three points are all distinct.)\\n4. If the 3 satisfies then create vector X = PQ+PR\\n5. change origin of X from (0,0) to (Px, Py)\\n6. Now check if X exists in given point set\\n7. if exists area_of_rec = absolute value of cross_product(PQ, PR)\\n8. return the lowest area as answer\\n\\n```\\n#define LL long long\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& v) {\\n        LL res = 0;\\n        bool found = false;\\n        set<pair<LL,LL>> st;\\n        for(int i=0; i<v.size(); i++){\\n            st.insert(make_pair((LL)v[i][0], (LL)v[i][1]));\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=i+1; j<v.size(); j++){\\n                for(int k=j+1; k<v.size(); k++){\\n                    LL tmp = 0;\\n                    if(dot_product(v[i], v[j], v[k])==0&&(tmp=cross_product(v[i], v[j], v[k]))!=0){\\n                        auto cur = add_vect(v[i], v[j], v[k]);\\n                        if(st.find(cur)!=st.end()){\\n                            tmp = abs(tmp);\\n                            if(found==false){\\n                                found = true;\\n                                res = tmp;\\n                            }else{\\n                                res = min(res, tmp);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(found==false)return 0;\\n        else return res;\\n    }\\n    \\n    pair<LL,LL> add_vect(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return make_pair(p1[0]-(x1+x2), p1[1]-(y1+y2));\\n    }\\n    \\n    LL dot_product(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return x1*x2+y1*y2;\\n    }\\n    \\n    LL cross_product(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return x1*y2-x2*y1;\\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#define LL long long\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& v) {\\n        LL res = 0;\\n        bool found = false;\\n        set<pair<LL,LL>> st;\\n        for(int i=0; i<v.size(); i++){\\n            st.insert(make_pair((LL)v[i][0], (LL)v[i][1]));\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=i+1; j<v.size(); j++){\\n                for(int k=j+1; k<v.size(); k++){\\n                    LL tmp = 0;\\n                    if(dot_product(v[i], v[j], v[k])==0&&(tmp=cross_product(v[i], v[j], v[k]))!=0){\\n                        auto cur = add_vect(v[i], v[j], v[k]);\\n                        if(st.find(cur)!=st.end()){\\n                            tmp = abs(tmp);\\n                            if(found==false){\\n                                found = true;\\n                                res = tmp;\\n                            }else{\\n                                res = min(res, tmp);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(found==false)return 0;\\n        else return res;\\n    }\\n    \\n    pair<LL,LL> add_vect(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return make_pair(p1[0]-(x1+x2), p1[1]-(y1+y2));\\n    }\\n    \\n    LL dot_product(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return x1*x2+y1*y2;\\n    }\\n    \\n    LL cross_product(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return x1*y2-x2*y1;\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208443,
                "title": "math-vector-24ms-c",
                "content": "```\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string,vector<vector<int>>> dic;\\n        long size = LONG_MAX;\\n        for(int i = 0; i < points.size() - 1; ++i)\\n        {\\n            long x1 = points[i][0], y1 = points[i][1];\\n            for (int j = i + 1; j < points.size(); ++j)\\n            {\\n                long x2 = points[j][0], y2 = points[j][1];\\n                long x = x1 - x2;\\n                long y = y1 - y2;\\n                if (x < 0) x = -x, y = -y;\\n                string p = to_string(x) + \\',\\' + to_string(y);\\n                if (dic.count(p) == 1)\\n                {\\n                    for (auto v : dic[p])\\n                    {\\n                        if (((v[0] - x1) * x + (v[1] - y1) * y == 0) && ((v[2] - x2) * x + (v[3] - y2) * y == 0)) \\n                            size = min(size, (x*x + y*y) * ((v[0] - x1) * (v[0] - x1) +  (v[1] - y1) *  (v[1] - y1)));\\n                        else if (((v[0] - x2) * x + (v[1] - y2) * y == 0) && ((v[2] - x1) * x + (v[3] - y1) * y == 0))\\n                            size = min(size, (x*x + y*y) * ((v[0] - x2) * (v[0] - x2) + (v[1] - y2) *  (v[1] - y2)));\\n                    }\\n                }\\n                dic[p].push_back({x1, y1, x2, y2});\\n            }\\n        }\\n        if (size == LONG_MAX) return 0;\\n        return sqrt(size);\\n        \\n    }\\n```\\nkey idea: go through any two points(x1, y1), (x2, y2), if we get vector ***A*** = (x1 - x2, y1 - y2), when we meet two equal vectors, say ***B***=(x\\'1 - x\\'2, y\\'1 - y\\'2) which ***A*** = ***B*** , we check whether ***C***=(x1 - x\\'1, y1- y\\'1) and ***D***=(x2 - x\\'2, y2 - y\\'2)  \\u22A5 ***A*** which means ***C*** * ***A***  = 0 && ***D*** * ***A***  = 0\\n\\n***X*** = (a, b) ***Y*** = (c, d) ***X*** * ***Y*** = a * c + b * d\\ntime O(n^2) worst O(n^3)\\nspace O(n)",
                "solutionTags": [],
                "code": "```\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string,vector<vector<int>>> dic;\\n        long size = LONG_MAX;\\n        for(int i = 0; i < points.size() - 1; ++i)\\n        {\\n            long x1 = points[i][0], y1 = points[i][1];\\n            for (int j = i + 1; j < points.size(); ++j)\\n            {\\n                long x2 = points[j][0], y2 = points[j][1];\\n                long x = x1 - x2;\\n                long y = y1 - y2;\\n                if (x < 0) x = -x, y = -y;\\n                string p = to_string(x) + \\',\\' + to_string(y);\\n                if (dic.count(p) == 1)\\n                {\\n                    for (auto v : dic[p])\\n                    {\\n                        if (((v[0] - x1) * x + (v[1] - y1) * y == 0) && ((v[2] - x2) * x + (v[3] - y2) * y == 0)) \\n                            size = min(size, (x*x + y*y) * ((v[0] - x1) * (v[0] - x1) +  (v[1] - y1) *  (v[1] - y1)));\\n                        else if (((v[0] - x2) * x + (v[1] - y2) * y == 0) && ((v[2] - x1) * x + (v[3] - y1) * y == 0))\\n                            size = min(size, (x*x + y*y) * ((v[0] - x2) * (v[0] - x2) + (v[1] - y2) *  (v[1] - y2)));\\n                    }\\n                }\\n                dic[p].push_back({x1, y1, x2, y2});\\n            }\\n        }\\n        if (size == LONG_MAX) return 0;\\n        return sqrt(size);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991622,
                "title": "easy-brute-c",
                "content": "# Intuition\\nSince number of points are just 50, so even O(n^4) will work.\\nSo we will first precompute the distance between all the pair of points. \\n\\nNow after calculating the distance we just need take all possible combination of 4 points. \\nSo let points be p1,p2,p3,p4\\n\\nNow we need to check if these points can form a rectangle or not. Below conditions will help us in knowing this. \\n\\n1. Distance between any of the points should not be zero\\n2. There will be 3 possibilities in which they can form a rectangle. \\n    a. p1 -> p3 are opposite (diagonal)\\n    b. p1 -> p2 are opposite (diagonal)\\n    c. p1 -> p4 are opposite (diagonal)\\n    And for these conditions we will try to check if rectangle\\'s properties are applied or not. \\n- Opposite side length should be same\\n- ab^2(side1) + ac^2(side2) = ad^2 (diagonal) \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^4)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDist(vector <int> &p1,vector <int> &p2){\\n        return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]);\\n    }\\n\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans = DBL_MAX;\\n        int n = points.size();\\n        vector <vector <long long>> dis(n,vector <long long> (n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dis[i][j] = getDist(points[i],points[j]);\\n            }\\n        }\\n        for(long i=0;i<n-3;i++){\\n            for(long j=i+1;j<n-2;j++){\\n                for(long k=j+1;k<n-1;k++){\\n                    for(long l=k+1;l<n;l++){\\n                        long long ij = dis[i][j];\\n                        long long ik = dis[i][k];\\n                        long long il = dis[i][l];\\n                        long long jk = dis[j][k];\\n                        long long jl = dis[j][l];\\n                        long long kl = dis[k][l];\\n                        if(ij && ik && il && jk && jl && kl){\\n                            if(ij+ik == il && jl==ik && kl==ij && kl+jl==jk){\\n                                double area = (double)sqrt(ij)*(double)sqrt(ik);\\n                                ans = min(ans,area);\\n                            }else if(ik+il == ij && il==jk && ik==jl && jl+jk==kl){\\n                                double area = (double)sqrt(ik)*(double)sqrt(il);\\n                                ans = min(ans,area);\\n                            }else if(ij+il == ik && il==jk && kl==ij && jk+kl==jl){\\n                                double area = (double)sqrt(ij)*(double)sqrt(il);\\n                                ans = min(ans,area);\\n                            }\\n                        }                  \\n                    }\\n                }\\n            }\\n        }\\n        return ans==DBL_MAX?0:ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDist(vector <int> &p1,vector <int> &p2){\\n        return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]);\\n    }\\n\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans = DBL_MAX;\\n        int n = points.size();\\n        vector <vector <long long>> dis(n,vector <long long> (n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dis[i][j] = getDist(points[i],points[j]);\\n            }\\n        }\\n        for(long i=0;i<n-3;i++){\\n            for(long j=i+1;j<n-2;j++){\\n                for(long k=j+1;k<n-1;k++){\\n                    for(long l=k+1;l<n;l++){\\n                        long long ij = dis[i][j];\\n                        long long ik = dis[i][k];\\n                        long long il = dis[i][l];\\n                        long long jk = dis[j][k];\\n                        long long jl = dis[j][l];\\n                        long long kl = dis[k][l];\\n                        if(ij && ik && il && jk && jl && kl){\\n                            if(ij+ik == il && jl==ik && kl==ij && kl+jl==jk){\\n                                double area = (double)sqrt(ij)*(double)sqrt(ik);\\n                                ans = min(ans,area);\\n                            }else if(ik+il == ij && il==jk && ik==jl && jl+jk==kl){\\n                                double area = (double)sqrt(ik)*(double)sqrt(il);\\n                                ans = min(ans,area);\\n                            }else if(ij+il == ik && il==jk && kl==ij && jk+kl==jl){\\n                                double area = (double)sqrt(ij)*(double)sqrt(il);\\n                                ans = min(ans,area);\\n                            }\\n                        }                  \\n                    }\\n                }\\n            }\\n        }\\n        return ans==DBL_MAX?0:ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930175,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  double minAreaFreeRect(vector<vector<int>>& points) {\\n    long long ans = LLONG_MAX;\\n    // For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}\\n    unordered_map<int, vector<tuple<int, int, int, int>>> centerToPoints;\\n\\n    for (const vector<int>& A : points)\\n      for (const vector<int>& B : points) {\\n        const int center = hash(A, B);\\n        centerToPoints[center].emplace_back(A[0], A[1], B[0], B[1]);\\n      }\\n\\n    // For all pair points \"that share the same center\"\\n    for (const auto& [_, points] : centerToPoints)\\n      for (const auto& [ax, ay, bx, by] : points)\\n        for (const auto& [cx, cy, dx, dy] : points)\\n          // AC is perpendicular to AD\\n          // AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0\\n          if ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0) {\\n            const long long squaredArea =\\n                dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy);\\n            if (squaredArea > 0)\\n              ans = min(ans, squaredArea);\\n          }\\n\\n    return ans == LLONG_MAX ? 0 : sqrt(ans);\\n  }\\n\\n private:\\n  int hash(const vector<int>& p, const vector<int>& q) {\\n    return ((long long)(p[0] + q[0]) << 16) + (p[1] + q[1]);\\n  }\\n\\n  long long dist(int px, int py, int qx, int qy) {\\n    return (px - qx) * (px - qx) + (py - qy) * (py - qy);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  double minAreaFreeRect(vector<vector<int>>& points) {\\n    long long ans = LLONG_MAX;\\n    // For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}\\n    unordered_map<int, vector<tuple<int, int, int, int>>> centerToPoints;\\n\\n    for (const vector<int>& A : points)\\n      for (const vector<int>& B : points) {\\n        const int center = hash(A, B);\\n        centerToPoints[center].emplace_back(A[0], A[1], B[0], B[1]);\\n      }\\n\\n    // For all pair points \"that share the same center\"\\n    for (const auto& [_, points] : centerToPoints)\\n      for (const auto& [ax, ay, bx, by] : points)\\n        for (const auto& [cx, cy, dx, dy] : points)\\n          // AC is perpendicular to AD\\n          // AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0\\n          if ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0) {\\n            const long long squaredArea =\\n                dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy);\\n            if (squaredArea > 0)\\n              ans = min(ans, squaredArea);\\n          }\\n\\n    return ans == LLONG_MAX ? 0 : sqrt(ans);\\n  }\\n\\n private:\\n  int hash(const vector<int>& p, const vector<int>& q) {\\n    return ((long long)(p[0] + q[0]) << 16) + (p[1] + q[1]);\\n  }\\n\\n  long long dist(int px, int py, int qx, int qy) {\\n    return (px - qx) * (px - qx) + (py - qy) * (py - qy);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814580,
                "title": "linear-algebra-review-problem-commented-and-explained-graduate-level",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a linear algebra problem. As such, I decided to finally implement some parts of my much needed personal linear algebra library of lambda functions, which I showcase here. These come up in a variety of problems as linear algebra is a powerful field for both AI and graphics. As such, feel free to use / improve for your own uses. I know my determinant 3D function that utilizes my determinant 2D is not the most efficient way of doing things, but it is a great learning method and a key to how I teach how to override the useful * operator for things like enum assignment for graphical nomenclatures. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrom the intuition, let\\'s break down the key lambda functions in detail. \\nFirst, the make vector function takes two points and their size in agreement. This can only be used with two points of equal size, don\\'t try it otherwise. \\n\\nWhat occurs is a generated list of p2[i] - p1[i] for i in range size. \\nSaid more generally is that\\n- For each axis (basis) of point 2, get the axis based value\\n- Subtract from this the axis (basis) of point 1 for the same axis based value \\n- This generates a euclidean delta (described later) for this given axis and records the change. This is akin to saying from point 1 go to point 2 \\n\\nGet determinant 2d is rather involved with needing 2 vectors, an ith power, an index 0 and index 1 as well as a coefficient \\nThis is because, when calculating the 2D determinant of an n dimensional matrix, you will utilize a specific cross bar locaton of the matrix to split it into 2D determinants. Take the example below \\n\\n> a b c    \\n> d e f     ->  given matrix to left, consider the top bar and leftmost column \\n> g h i\\n\\n> a  b  c\\n> d [e f] -> this isolates e f h i as shown in brackets  \\n> g [h i] \\n\\n> a is at row index 0 and col index 0 -> this means our ith power of -1 is 0\\n> this makes the value of -1 to the power of 0 to be 1 \\n> a is also our coefficient \\n> in that case, our value of the 2D determinant here is ((-1)^0) * a * (e * i - f * h)\\n> we then would move across the top row, moving the left column with it \\n\\n> this would give us for the next term ((-1)^1) * b * (d * i - f * g)\\n> try to get the third one. At the end of this explanation section I\\'ll write the answer so you can check \\n\\nTo help with the above, I did add a helper function that will get the n dimensional determinants ith power. It\\'s rather simple, so I\\'ll leave it unexplained. \\n\\nTo get the euclidean delta, simply take the difference between a final and initial value \\n\\nTo get a euclidean distance, this is simply the sum of square euclidean deltas for any two points of a given size (means, for each basis, get the euclidean delta, multiply this by the same euclidean delta, and add them all up)\\n\\nNotice, we are using the sum of squared differences here, not the square root of the sum of squared differences, which is the true euclidean distance, but may involve complex positive and negative numbers! \\n\\nA diagonal key is a key set to be unique for any such pairing (hopefully, no gaurantees, but it works here). It is simply a hashing function at the end of the day, and can be improved as needed. \\n\\nFinally, we make a map of our diagonals as a collection of lists for a given diagonal key (thus avoiding the possibility of matching diagonal keys!) \\n\\nSo then, first we need to make the combinations of points in points into a diagonal key and then append to the list a given point structure. Combinations is necessarily a filtered permutation of sorted order, check the itertools documentation for more (math is fun also has a great breakdown) \\n\\nOnce we have done that, we need to then consider each list of values we have mapped. \\n\\n- For each such list \\n    - generate combinations of points (a, b) and (c, d) from this list \\n        - these are points needed for vectors of a to b and c to d \\n        - These vectors then are useful if the euclidean distance of a to b is equal to the euclidean distance from c to d (we could have used the square root distance, but we would have had to account for negative values coming out of it, which we avoid by sticking with sum of square differences instead of the more rigorous and slightly problem fraught square root of sum of squared distances) \\n            - if the vectors are useful, update result to the minimum of itself and the absolute area of the 2D determinant, using vectors from a to b of size 2 and a to d of size 2, with 2 as the size of the vectors, 2 as an even power to raise -1 to the power of, 0 as the first index, 1 as the second index, and 1 as the coefficient\\n\\nAt the end, return result if result is not our default valuation of float of infinity, otherwise return 0 \\n\\nThe promised answer to the determinant part above is found below \\n(-1 ^ (2)) * c * (d * h - g * e)\\n\\n# Complexity\\n- Time complexity : O( D^2 * C(P, D) * C(V, D) )\\n    - generating the needed combinations for the map is necessarily of time complexity O(r * n choose r) as we need to yield at least r times. \\n    - Generally this would be D * P choose D where D is the dimensionality of the points and P the number of points \\n    - We thus have at worst C(P, D) value key lists \\n    - For which we have to do D * C(V, D) combinations \\n        - each of which needs 2 * D euclidean distance operations \\n            - and which then might cost a final 6 multiplications and one addition \\n    - So D * C(P, D) + C(P, D) * D * C(V, D) * 2D * (6 multi, one add)\\n    - D^2 * C(V, D) * C(P, D) * (6 multi, one add) + D * C(P, D) \\n    - Square D term dominates out \\n    - D^2 * C(P, D) * C(V, D), not accounting additional multiplications or pre-set up\\n    - CURSE OF DIMENSIONALITY!!!   \\n\\n- Space complexity : O( C(P, D))\\n    - We store at most P Choose D lists \\n    - All others are generated / yielded as needed, so will be discounted  \\n\\n# Code\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float :\\n        # linear algebra functions \\n        make_vector = lambda p1, p2, size : list(p2[i] - p1[i] for i in range(size))\\n        get_determinant_2D = lambda v1, v2, ith_power, index_0, index_1, coefficient : (-1)**(ith_power) * coefficient * (v1[index_0]*v2[index_1] - v2[index_0]*v1[index_1])\\n        euclidean_delta = lambda val_f, val_i : val_f - val_i \\n        euclidean_distance = lambda p1, p2, size : sum(list(euclidean_delta(p2[i], p1[i]) * euclidean_delta(p2[i], p1[i]) for i in range(size)))\\n        # hash key function, could be improved but is geometrically necessary \\n        diagonal_key = lambda p1, p2, size : tuple(p1[i] + p2[i] for i in range(size))\\n        # map of hashes \\n        map_of_diagonals = collections.defaultdict(list)\\n        # generate combinations. 2 is here for the size of the vectorial dimension space, in this case 2D \\n        for p1, p2 in itertools.combinations(points, 2) : \\n            key = diagonal_key(p1, p2, 2)\\n            map_of_diagonals[key].append((p1, p2))\\n        # get float valuation \\n        result = float(\\'inf\\')\\n        # loop over C(P, D) value lists \\n        for value_list in map_of_diagonals.values() : \\n            # of size V, taking D * C(V, D) items \\n            for (a, b), (c, d) in itertools.combinations(value_list, 2) : \\n                # doing D operations 2 times to get euclidean distance \\n                if euclidean_distance(a, b, 2) == euclidean_distance(c, d, 2) : \\n                    # doing at most 6 multiplications and one addition to get determinant 2D in abs form \\n                    result = min(result, abs(get_determinant_2D(make_vector(a, b, 2), make_vector(a, d, 2), 2, 0, 1, 1)))\\n        return result if result != float(\\'inf\\') else 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float :\\n        # linear algebra functions \\n        make_vector = lambda p1, p2, size : list(p2[i] - p1[i] for i in range(size))\\n        get_determinant_2D = lambda v1, v2, ith_power, index_0, index_1, coefficient : (-1)**(ith_power) * coefficient * (v1[index_0]*v2[index_1] - v2[index_0]*v1[index_1])\\n        euclidean_delta = lambda val_f, val_i : val_f - val_i \\n        euclidean_distance = lambda p1, p2, size : sum(list(euclidean_delta(p2[i], p1[i]) * euclidean_delta(p2[i], p1[i]) for i in range(size)))\\n        # hash key function, could be improved but is geometrically necessary \\n        diagonal_key = lambda p1, p2, size : tuple(p1[i] + p2[i] for i in range(size))\\n        # map of hashes \\n        map_of_diagonals = collections.defaultdict(list)\\n        # generate combinations. 2 is here for the size of the vectorial dimension space, in this case 2D \\n        for p1, p2 in itertools.combinations(points, 2) : \\n            key = diagonal_key(p1, p2, 2)\\n            map_of_diagonals[key].append((p1, p2))\\n        # get float valuation \\n        result = float(\\'inf\\')\\n        # loop over C(P, D) value lists \\n        for value_list in map_of_diagonals.values() : \\n            # of size V, taking D * C(V, D) items \\n            for (a, b), (c, d) in itertools.combinations(value_list, 2) : \\n                # doing D operations 2 times to get euclidean distance \\n                if euclidean_distance(a, b, 2) == euclidean_distance(c, d, 2) : \\n                    # doing at most 6 multiplications and one addition to get determinant 2D in abs form \\n                    result = min(result, abs(get_determinant_2D(make_vector(a, b, 2), make_vector(a, d, 2), 2, 0, 1, 1)))\\n        return result if result != float(\\'inf\\') else 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747105,
                "title": "o-n-3-worst-case-python-solution-by-finding-parallel-vectors-and-right-angle-corners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef normalize(points) -> []:\\n    vector = (points[1][0] - points[0][0], points[1][1] - points[0][1])\\n    l = length(points)\\n    return (float(vector[0]) / l, float(vector[1]) / l)\\n\\n\\ndef length(points) -> float:\\n    vector = (points[1][0] - points[0][0], points[1][1] - points[0][1])\\n    return sqrt(float(vector[0] * vector[0] + vector[1] * vector[1]))\\n\\nclass Solution:\\n\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        n = len(points)\\n        vectors = {}\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                a = points[i]\\n                b = points[j]\\n                if a[0] > b[0]:\\n                    a, b = b, a\\n                vec = (b[0] - a[0], b[1] - a[1])\\n                if not vec in vectors:\\n                    vectors[vec] = []\\n                vectors[vec].append((a, b))\\n        min_area = float(\"inf\")\\n        for vector in vectors.keys():\\n            sides = vectors[vector]\\n            for i in range(len(sides)):\\n                side1 = sides[i]\\n                for j in range(i + 1, len(sides)):\\n                    perp = (side1[0], sides[j][0])\\n                    if length(side1) > 0 and length(perp) > 0:\\n                        # we have two parallel vectors of same lengths\\n                        # check if we have a right angle corner\\n                        side1_norm = normalize(side1)\\n                        perp_norm = normalize(perp)\\n                        dot = side1_norm[0] * perp_norm[0] + side1_norm[1] * perp_norm[1]\\n                        if abs(dot) < 0.001:\\n                            area = length(side1) * length(perp)\\n                            min_area = min(min_area, area)\\n        if min_area == float(\"inf\"):\\n            return 0\\n        return min_area\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef normalize(points) -> []:\\n    vector = (points[1][0] - points[0][0], points[1][1] - points[0][1])\\n    l = length(points)\\n    return (float(vector[0]) / l, float(vector[1]) / l)\\n\\n\\ndef length(points) -> float:\\n    vector = (points[1][0] - points[0][0], points[1][1] - points[0][1])\\n    return sqrt(float(vector[0] * vector[0] + vector[1] * vector[1]))\\n\\nclass Solution:\\n\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        n = len(points)\\n        vectors = {}\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                a = points[i]\\n                b = points[j]\\n                if a[0] > b[0]:\\n                    a, b = b, a\\n                vec = (b[0] - a[0], b[1] - a[1])\\n                if not vec in vectors:\\n                    vectors[vec] = []\\n                vectors[vec].append((a, b))\\n        min_area = float(\"inf\")\\n        for vector in vectors.keys():\\n            sides = vectors[vector]\\n            for i in range(len(sides)):\\n                side1 = sides[i]\\n                for j in range(i + 1, len(sides)):\\n                    perp = (side1[0], sides[j][0])\\n                    if length(side1) > 0 and length(perp) > 0:\\n                        # we have two parallel vectors of same lengths\\n                        # check if we have a right angle corner\\n                        side1_norm = normalize(side1)\\n                        perp_norm = normalize(perp)\\n                        dot = side1_norm[0] * perp_norm[0] + side1_norm[1] * perp_norm[1]\\n                        if abs(dot) < 0.001:\\n                            area = length(side1) * length(perp)\\n                            min_area = min(min_area, area)\\n        if min_area == float(\"inf\"):\\n            return 0\\n        return min_area\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484544,
                "title": "time-o-n-2-log-n-space-o-n-30-40-ms",
                "content": "# Intuition\\nThe two diagonals of a rectangle must have the same middle point and the same length. Amongst all such diagonals, the minimum area is achieved by the rectangle with the smallest absolute angle.\\n\\n# Approach\\nBucket the two-point segments by middle point and length. Within each bucket, sort them by the absolute value of the angle to an arbitrary fixed line (e.g. the first diagonal in the bucket). Then find the minimum angle difference between consecutive diagonals within the bucket.\\n\\nThe rectangle area is half the absolute value of the cross product of the diagonals.\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2 log n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nint vector_product(std::pair<int, int> p, std::pair<int, int> q)\\n{\\n    return p.first * q.second - p.second * q.first;\\n}\\n\\nstruct key_hash : public std::unary_function<std::tuple<int, int, int>, std::size_t>\\n{\\n    std::size_t operator()(const std::tuple<int, int, int> k) const\\n    {\\n        // Bits: 17, 17, 32\\n        return (std::get<0>(k) << (32 - 17)) ^ std::get<1>(k) ^ std::get<2>(k);\\n    }\\n};\\n\\nstruct key_equal : public std::binary_function<std::tuple<int, int, int>, std::tuple<int, int, int>, bool>\\n{\\n    bool operator()(const std::tuple<int, int, int> v0, const std::tuple<int, int, int> v1) const\\n    {\\n        return v0 == v1;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    double minAreaFreeRect(const std::vector<std::vector<int>> &points)\\n    {\\n        const int n = points.size();\\n        std::unordered_map<std::tuple<int, int, int>, std::vector<std::pair<int, int>>,\\n                           key_hash, key_equal>\\n            endpoint_indices_by_double_midpoint_and_length;\\n        endpoint_indices_by_double_midpoint_and_length.reserve(\\n            (n - 1) * n / 2);\\n        for (auto p_it = points.begin(); p_it != points.end(); ++p_it)\\n        {\\n            const auto &p = *p_it;\\n            for (auto q_it = std::next(p_it); q_it != points.end(); ++q_it)\\n            {\\n                const auto &q = *q_it;\\n                int delta_x = p[0] - q[0];\\n                int delta_y = p[1] - q[1];\\n                endpoint_indices_by_double_midpoint_and_length[{p[0] + q[0], p[1] + q[1], delta_x * delta_x + delta_y * delta_y}].push_back(\\n                    {delta_x, delta_y});\\n            }\\n        }\\n        int min_twice_area = 0;\\n        for (auto &[_, v] : endpoint_indices_by_double_midpoint_and_length)\\n        {\\n            auto p_it = v.begin();\\n            std::sort(std::next(p_it), v.end(), [p_it](const auto &lhs, const auto &rhs)\\n                      { return abs(vector_product(*p_it, lhs)) < abs(vector_product(*p_it, rhs)); });\\n            for (auto q_it = std::next(p_it); q_it != v.end(); ++q_it)\\n            {\\n                int twice_area = abs(vector_product(*p_it, *q_it));\\n                if (min_twice_area == 0 || min_twice_area > twice_area)\\n                {\\n                    min_twice_area = twice_area;\\n                }\\n                p_it = q_it;\\n            }\\n        }\\n        return min_twice_area / 2.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint vector_product(std::pair<int, int> p, std::pair<int, int> q)\\n{\\n    return p.first * q.second - p.second * q.first;\\n}\\n\\nstruct key_hash : public std::unary_function<std::tuple<int, int, int>, std::size_t>\\n{\\n    std::size_t operator()(const std::tuple<int, int, int> k) const\\n    {\\n        // Bits: 17, 17, 32\\n        return (std::get<0>(k) << (32 - 17)) ^ std::get<1>(k) ^ std::get<2>(k);\\n    }\\n};\\n\\nstruct key_equal : public std::binary_function<std::tuple<int, int, int>, std::tuple<int, int, int>, bool>\\n{\\n    bool operator()(const std::tuple<int, int, int> v0, const std::tuple<int, int, int> v1) const\\n    {\\n        return v0 == v1;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    double minAreaFreeRect(const std::vector<std::vector<int>> &points)\\n    {\\n        const int n = points.size();\\n        std::unordered_map<std::tuple<int, int, int>, std::vector<std::pair<int, int>>,\\n                           key_hash, key_equal>\\n            endpoint_indices_by_double_midpoint_and_length;\\n        endpoint_indices_by_double_midpoint_and_length.reserve(\\n            (n - 1) * n / 2);\\n        for (auto p_it = points.begin(); p_it != points.end(); ++p_it)\\n        {\\n            const auto &p = *p_it;\\n            for (auto q_it = std::next(p_it); q_it != points.end(); ++q_it)\\n            {\\n                const auto &q = *q_it;\\n                int delta_x = p[0] - q[0];\\n                int delta_y = p[1] - q[1];\\n                endpoint_indices_by_double_midpoint_and_length[{p[0] + q[0], p[1] + q[1], delta_x * delta_x + delta_y * delta_y}].push_back(\\n                    {delta_x, delta_y});\\n            }\\n        }\\n        int min_twice_area = 0;\\n        for (auto &[_, v] : endpoint_indices_by_double_midpoint_and_length)\\n        {\\n            auto p_it = v.begin();\\n            std::sort(std::next(p_it), v.end(), [p_it](const auto &lhs, const auto &rhs)\\n                      { return abs(vector_product(*p_it, lhs)) < abs(vector_product(*p_it, rhs)); });\\n            for (auto q_it = std::next(p_it); q_it != v.end(); ++q_it)\\n            {\\n                int twice_area = abs(vector_product(*p_it, *q_it));\\n                if (min_twice_area == 0 || min_twice_area > twice_area)\\n                {\\n                    min_twice_area = twice_area;\\n                }\\n                p_it = q_it;\\n            }\\n        }\\n        return min_twice_area / 2.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360769,
                "title": "c",
                "content": "```\\nclass Solution {\\n    long long getDist(vector<int> a, vector<int> b){\\n        long long x = a[0] - b[0] ;\\n        long long y = a[1] - b[1] ;\\n        return x*x + y*y ;\\n    }\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string, vector<pair<int, int>>>Map ; //len+center,  pair of points \\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            for(int j = i+1; j < points.size(); j++)\\n            {\\n                long long dist =  getDist(points[i], points[j]) ;\\n                double centerX = ( points[i][0] + points[j][0] ) / 2.0 ;\\n                double centerY = ( points[i][1] + points[j][1] ) / 2.0 ;\\n                Map[to_string(dist) + \"_\" + to_string(centerX) + \"_\" + to_string(centerY)].push_back({i, j}) ;\\n            }            \\n        }\\n        double ret = INT_MAX ;\\n        for(auto&m : Map){\\n            auto& vec = m.second ;\\n            if(vec.size() < 2)\\n                continue ;\\n            for(int i = 0; i < vec.size(); i++){\\n                for(int j = i+1; j < vec.size(); j++){\\n                    int p1 = vec[i].first ;\\n                    int p2 = vec[i].second ;\\n                    int p3 = vec[j].first ;\\n                    double len1 = sqrt(getDist(points[p1], points[p3])) ;\\n                    double len2 = sqrt(getDist(points[p2], points[p3])) ;\\n                    ret = min(ret, len1 * len2) ;\\n                }\\n            }\\n        }\\n        \\n        return (ret == INT_MAX) ? 0 :  ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long getDist(vector<int> a, vector<int> b){\\n        long long x = a[0] - b[0] ;\\n        long long y = a[1] - b[1] ;\\n        return x*x + y*y ;\\n    }\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string, vector<pair<int, int>>>Map ; //len+center,  pair of points \\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            for(int j = i+1; j < points.size(); j++)\\n            {\\n                long long dist =  getDist(points[i], points[j]) ;\\n                double centerX = ( points[i][0] + points[j][0] ) / 2.0 ;\\n                double centerY = ( points[i][1] + points[j][1] ) / 2.0 ;\\n                Map[to_string(dist) + \"_\" + to_string(centerX) + \"_\" + to_string(centerY)].push_back({i, j}) ;\\n            }            \\n        }\\n        double ret = INT_MAX ;\\n        for(auto&m : Map){\\n            auto& vec = m.second ;\\n            if(vec.size() < 2)\\n                continue ;\\n            for(int i = 0; i < vec.size(); i++){\\n                for(int j = i+1; j < vec.size(); j++){\\n                    int p1 = vec[i].first ;\\n                    int p2 = vec[i].second ;\\n                    int p3 = vec[j].first ;\\n                    double len1 = sqrt(getDist(points[p1], points[p3])) ;\\n                    double len2 = sqrt(getDist(points[p2], points[p3])) ;\\n                    ret = min(ret, len1 * len2) ;\\n                }\\n            }\\n        }\\n        \\n        return (ret == INT_MAX) ? 0 :  ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300670,
                "title": "easy-to-understand-c-solution",
                "content": "\\n\\n# Approach\\nThe approach used in the code is to iterate through all possible combinations of three points, check if they form a right triangle, and then check if there exists a fourth point that can form a rectangle with the three original points. If such a rectangle exists, then its area is calculated and compared to the current minimum area. At the end of the iteration, the minimum area is returned.\\n\\nHere is a breakdown of the main steps in the code:\\n\\n1. First, an unordered_map is created to store all the points. The keys of the map are the x-coordinates and the values are sets of y-coordinates. This is done to easily access points with a particular x-coordinate while checking for rectangles.\\n2. Next, three nested loops are used to generate all possible combinations of three points from the given set of points.\\n3. For each triplet of points (i, j, k), the code checks if they form a right-angled triangle using the formula:\\n- (xj-xi)(xk-xi) + (yj-yi)(yk-yi) = 0\\n\\n- This condition is simplified to dx1dx2 + dy1dy2 == 0\\n- If this condition is satisfied, it means that the three points form a right-angled triangle.\\n\\n4. After finding a right-angled triangle, the code calculates the fourth point (m) which lies on the diagonal opposite to the right angle.\\n5. The coordinates of the fourth point are calculated using the formula:\\nfor \"xm\" --> (xj+xk)/2 = (xm+xi)/2  and for \"ym\" --> (yj+yk)/2 = (ym+yi)/2. After simplify the equation \\n\\n- xm = xj+xk - xi\\n- ym = yj+yk - yi\\n6. Finally, the code calculates the area of the rectangle formed by the four points and checks if it is the minimum area seen so far. If it is, the minimum area is updated.\\nIf no rectangle is found, the function returns 0.0.\\n\\n\\n# Complexity\\n- Time complexity:\\nOverall, the code uses a brute-force approach to check all possible combinations of points, but takes advantage of efficient data structures such as unordered maps and sets to reduce the number of operations required.\\nTC = O(n^3)\\n- Space complexity:\\nSC = O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<int, unordered_set<int>> mp;\\n        for(auto p: points){\\n            mp[p[0]].insert(p[1]); // x-->{y1,y2,..}\\n        }\\n\\n        double area=DBL_MAX; \\n        // Every time we will take three coordinate points(i, j, k) and we will check that can these three point form a right traingle. if slop1*slpo2=-1 then three points form right angle traingle\\n        // slope1 = (yj-yi)/(xj-xi) \\n        // slope2 = (yk-yi)/(xk-xi)\\n\\n        // slope1*slop2=-1, \\n        // simpyfy this==> (xj-xi)*(xk-xi) + (yj-yi)*(yk-yi) =0\\n        // ===>dx1*dx2 + dy1*dy2 ==0[if right angle traingle]\\n\\n        // then we will find fourth point, we know both digonal have same mid points then then \\n        // fourth point(m) can be found as\\n        // (xj+xk)/2 = (xm+xi)/2 ===> xm = xj+xk - xi\\n        // (yj+yk)/2 = (ym+yi)/2 ===> ym = yj+yk - yi\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=i+1; j<points.size(); j++){\\n                for(int k=j+1; k<points.size(); k++){\\n                    // finds dx1, dx2, dy1, dy2\\n                    int dx1 = points[j][0]-points[i][0];\\n                    int dx2 = points[k][0]-points[i][0];\\n                    int dy1 = points[j][1]-points[i][1];\\n                    int dy2 = points[k][1]-points[i][1];\\n                    // check these three points can form a right traingle\\n                    if(dx1*dx2 + dy1*dy2 ==0){ // right traingle\\n                        // find the fourht point \\n                        // intersection point of two digonal will have same points\\n                        // xm = xj+xk - xi, ym = yj+yk - yi\\n                        int xm = dx1 + points[k][0];\\n                        int ym = dy1 + points[k][1];\\n                        // check this point exist into the map\\n                        if(mp[xm].find(ym)!=mp[xm].end()){\\n                            double area1 = sqrt(dx1*dx1 + dy1*dy1)*sqrt(dx2*dx2 + dy2*dy2);\\n                            if(area>area1){\\n                                area = area1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(area == DBL_MAX) return 0.0;\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<int, unordered_set<int>> mp;\\n        for(auto p: points){\\n            mp[p[0]].insert(p[1]); // x-->{y1,y2,..}\\n        }\\n\\n        double area=DBL_MAX; \\n        // Every time we will take three coordinate points(i, j, k) and we will check that can these three point form a right traingle. if slop1*slpo2=-1 then three points form right angle traingle\\n        // slope1 = (yj-yi)/(xj-xi) \\n        // slope2 = (yk-yi)/(xk-xi)\\n\\n        // slope1*slop2=-1, \\n        // simpyfy this==> (xj-xi)*(xk-xi) + (yj-yi)*(yk-yi) =0\\n        // ===>dx1*dx2 + dy1*dy2 ==0[if right angle traingle]\\n\\n        // then we will find fourth point, we know both digonal have same mid points then then \\n        // fourth point(m) can be found as\\n        // (xj+xk)/2 = (xm+xi)/2 ===> xm = xj+xk - xi\\n        // (yj+yk)/2 = (ym+yi)/2 ===> ym = yj+yk - yi\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=i+1; j<points.size(); j++){\\n                for(int k=j+1; k<points.size(); k++){\\n                    // finds dx1, dx2, dy1, dy2\\n                    int dx1 = points[j][0]-points[i][0];\\n                    int dx2 = points[k][0]-points[i][0];\\n                    int dy1 = points[j][1]-points[i][1];\\n                    int dy2 = points[k][1]-points[i][1];\\n                    // check these three points can form a right traingle\\n                    if(dx1*dx2 + dy1*dy2 ==0){ // right traingle\\n                        // find the fourht point \\n                        // intersection point of two digonal will have same points\\n                        // xm = xj+xk - xi, ym = yj+yk - yi\\n                        int xm = dx1 + points[k][0];\\n                        int ym = dy1 + points[k][1];\\n                        // check this point exist into the map\\n                        if(mp[xm].find(ym)!=mp[xm].end()){\\n                            double area1 = sqrt(dx1*dx1 + dy1*dy1)*sqrt(dx2*dx2 + dy2*dy2);\\n                            if(area>area1){\\n                                area = area1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(area == DBL_MAX) return 0.0;\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279091,
                "title": "geometry-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        Set<String> pointSet = new HashSet<>();\\n        for (int[] point : points) {\\n            pointSet.add(point[0] + \",\" + point[1]);\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int[] p1 = points[i];\\n            for (int j = i + 1; j < n; j++) {\\n                int[] p2 = points[j];\\n                for (int k = j + 1; k < n; k++) {\\n                    int[] p3 = points[k];\\n                    int dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1];\\n                    int dx2 = p3[0] - p1[0], dy2 = p3[1] - p1[1];\\n                    if (dx1 * dx2 + dy1 * dy2 == 0) {\\n                        int[] p4 = new int[]{p2[0] + dx2, p2[1] + dy2};\\n                        String p4Str = p4[0] + \",\" + p4[1];\\n                        if (pointSet.contains(p4Str)) {\\n                            double area = Math.sqrt(dx1 * dx1 + dy1 * dy1) * Math.sqrt(dx2 * dx2 + dy2 * dy2);\\n                            minArea = Math.min(minArea, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Geometry",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        Set<String> pointSet = new HashSet<>();\\n        for (int[] point : points) {\\n            pointSet.add(point[0] + \",\" + point[1]);\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int[] p1 = points[i];\\n            for (int j = i + 1; j < n; j++) {\\n                int[] p2 = points[j];\\n                for (int k = j + 1; k < n; k++) {\\n                    int[] p3 = points[k];\\n                    int dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1];\\n                    int dx2 = p3[0] - p1[0], dy2 = p3[1] - p1[1];\\n                    if (dx1 * dx2 + dy1 * dy2 == 0) {\\n                        int[] p4 = new int[]{p2[0] + dx2, p2[1] + dy2};\\n                        String p4Str = p4[0] + \",\" + p4[1];\\n                        if (pointSet.contains(p4Str)) {\\n                            double area = Math.sqrt(dx1 * dx1 + dy1 * dy1) * Math.sqrt(dx2 * dx2 + dy2 * dy2);\\n                            minArea = Math.min(minArea, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202625,
                "title": "solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int len = points.length;\\n        double res = Double.MAX_VALUE;\\n        if (len < 4) return 0.0;\\n        Map<String, List<int[]>> map = new HashMap<>(); // int[] is the index of two points forming the diagonal\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                long dis = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                double centerX = (double)(points[j][0] + points[i][0])/2; // centerX and centerY is the coordinate of the diagonal center\\n                double centerY = (double)(points[j][1] + points[i][1])/2;\\n                String key = \"\" + dis + \"+\" + centerX + \"+\" + centerY; // key includes the length of the diagonal and the coordinate of the diagonal center\\n                if (map.get(key) == null) map.put(key, new ArrayList<int[]>());\\n                map.get(key).add(new int[]{i,j});\\n            }\\n        }\\n        for (String key : map.keySet()) {\\n            if (map.get(key).size() > 1) {  \\n                List<int[]> list = map.get(key);\\n                for (int i = 0; i < list.size(); i++) { // there could be multiple rectangles inside\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        int p1 = list.get(i)[0]; // p1, p2 and p3 are the three vertices of a rectangle\\n                        int p2 = list.get(j)[0];\\n                        int p3 = list.get(j)[1];\\n                        // len1 and len2 are the length of the sides of a rectangle\\n                        double len1 = Math.sqrt((points[p1][0] - points[p2][0]) * (points[p1][0] - points[p2][0]) +  (points[p1][1] - points[p2][1]) * (points[p1][1] - points[p2][1])); \\n                        double len2 = Math.sqrt((points[p1][0] - points[p3][0]) * (points[p1][0] - points[p3][0]) +  (points[p1][1] - points[p3][1]) * (points[p1][1] - points[p3][1]));\\n                        double area = len1 * len2; \\n                        res = Math.min(res, area);\\n                    }\\n                }\\n            }\\n        }\\n        return res == Double.MAX_VALUE ?  0.0 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Geometry",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int len = points.length;\\n        double res = Double.MAX_VALUE;\\n        if (len < 4) return 0.0;\\n        Map<String, List<int[]>> map = new HashMap<>(); // int[] is the index of two points forming the diagonal\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                long dis = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                double centerX = (double)(points[j][0] + points[i][0])/2; // centerX and centerY is the coordinate of the diagonal center\\n                double centerY = (double)(points[j][1] + points[i][1])/2;\\n                String key = \"\" + dis + \"+\" + centerX + \"+\" + centerY; // key includes the length of the diagonal and the coordinate of the diagonal center\\n                if (map.get(key) == null) map.put(key, new ArrayList<int[]>());\\n                map.get(key).add(new int[]{i,j});\\n            }\\n        }\\n        for (String key : map.keySet()) {\\n            if (map.get(key).size() > 1) {  \\n                List<int[]> list = map.get(key);\\n                for (int i = 0; i < list.size(); i++) { // there could be multiple rectangles inside\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        int p1 = list.get(i)[0]; // p1, p2 and p3 are the three vertices of a rectangle\\n                        int p2 = list.get(j)[0];\\n                        int p3 = list.get(j)[1];\\n                        // len1 and len2 are the length of the sides of a rectangle\\n                        double len1 = Math.sqrt((points[p1][0] - points[p2][0]) * (points[p1][0] - points[p2][0]) +  (points[p1][1] - points[p2][1]) * (points[p1][1] - points[p2][1])); \\n                        double len2 = Math.sqrt((points[p1][0] - points[p3][0]) * (points[p1][0] - points[p3][0]) +  (points[p1][1] - points[p3][1]) * (points[p1][1] - points[p3][1]));\\n                        double area = len1 * len2; \\n                        res = Math.min(res, area);\\n                    }\\n                }\\n            }\\n        }\\n        return res == Double.MAX_VALUE ?  0.0 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127517,
                "title": "simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    size_t d2(int x1, int y1, int x2, int y2) {\\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, unordered_map<size_t, vector<vector<int>>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      auto len = d2(ps[i][0], ps[i][1], ps[j][0], ps[j][1]);\\n      m[center][len].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it_c = begin(m); it_c != end(m); ++it_c)\\n    for (auto it_l = begin(it_c->second); it_l != end(it_c->second); ++it_l)\\n      for (auto i = 0; i < it_l->second.size(); ++i)\\n        for (auto j = i + 1; j < it_l->second.size(); ++j) {\\n          auto &p1 = it_l->second[i], &p2 = it_l->second[j];\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n  return sqrt(res);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    size_t d2(int x1, int y1, int x2, int y2) {\\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, unordered_map<size_t, vector<vector<int>>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      auto len = d2(ps[i][0], ps[i][1], ps[j][0], ps[j][1]);\\n      m[center][len].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it_c = begin(m); it_c != end(m); ++it_c)\\n    for (auto it_l = begin(it_c->second); it_l != end(it_c->second); ++it_l)\\n      for (auto i = 0; i < it_l->second.size(); ++i)\\n        for (auto j = i + 1; j < it_l->second.size(); ++j) {\\n          auto &p1 = it_l->second[i], &p2 = it_l->second[j];\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n  return sqrt(res);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012497,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar minAreaFreeRect = function(points) {\\n    const diagonalMap = new Map();\\n    let result = Infinity;\\n\\n    for (let a = 0; a < points.length - 1; a++) {\\n        const [x1, y1] = points[a];\\n        for (let b = a + 1; b < points.length; b++) {\\n            const [x2, y2] = points[b];\\n            const diagonal = calculateeDiagonal(x1, y1, x2, y2);\\n            const centerX = (x1 + x2) / 2;\\n            const centerY = (y1 + y2) / 2;\\n            const key = `${diagonal}_${centerX}_${centerY}`;\\n            const vectors = diagonalMap.get(key) ?? [];\\n\\n            vectors.push({ x1, x2, y1, y2 });\\n            diagonalMap.set(key, vectors);\\n        }\\n    }\\n\\n    for (const [key, vector] of diagonalMap) {\\n        if (vector.length < 2) continue;\\n        for (let a = 0; a < vector.length - 1; a++) {\\n            const vectorA = vector[a];\\n            for (let b = a + 1; b < vector.length; b++) {\\n                const vectorB = vector[b];\\n                const w = Math.sqrt(calculateeDiagonal(vectorA.x1, vectorA.y1, vectorB.x1, vectorB.y1));\\n                const h = Math.sqrt(calculateeDiagonal(vectorA.x1, vectorA.y1, vectorB.x2, vectorB.y2));\\n\\n                result = Math.min(result, w * h);\\n            }\\n        }\\n    }\\n    return result === Infinity ? 0 : result;\\n\\n    function calculateeDiagonal(x1, y1, x2, y2) {\\n        return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minAreaFreeRect = function(points) {\\n    const diagonalMap = new Map();\\n    let result = Infinity;\\n\\n    for (let a = 0; a < points.length - 1; a++) {\\n        const [x1, y1] = points[a];\\n        for (let b = a + 1; b < points.length; b++) {\\n            const [x2, y2] = points[b];\\n            const diagonal = calculateeDiagonal(x1, y1, x2, y2);\\n            const centerX = (x1 + x2) / 2;\\n            const centerY = (y1 + y2) / 2;\\n            const key = `${diagonal}_${centerX}_${centerY}`;\\n            const vectors = diagonalMap.get(key) ?? [];\\n\\n            vectors.push({ x1, x2, y1, y2 });\\n            diagonalMap.set(key, vectors);\\n        }\\n    }\\n\\n    for (const [key, vector] of diagonalMap) {\\n        if (vector.length < 2) continue;\\n        for (let a = 0; a < vector.length - 1; a++) {\\n            const vectorA = vector[a];\\n            for (let b = a + 1; b < vector.length; b++) {\\n                const vectorB = vector[b];\\n                const w = Math.sqrt(calculateeDiagonal(vectorA.x1, vectorA.y1, vectorB.x1, vectorB.y1));\\n                const h = Math.sqrt(calculateeDiagonal(vectorA.x1, vectorA.y1, vectorB.x2, vectorB.y2));\\n\\n                result = Math.min(result, w * h);\\n            }\\n        }\\n    }\\n    return result === Infinity ? 0 : result;\\n\\n    function calculateeDiagonal(x1, y1, x2, y2) {\\n        return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3001608,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_area_free_rect(points: Vec<Vec<i32>>) -> f64 {\\n        fn d2(x1: i64, y1: i64, x2: i64, y2: i64) -> i64 {\\n            (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\\n        }\\n        let points = points\\n            .iter()\\n            .map(|v| v.iter().map(|&x| x as i64).collect::<Vec<_>>())\\n            .collect::<Vec<_>>();\\n        let mut res = 0;\\n        let mut m = std::collections::HashMap::new();\\n        for i in 0..points.len() {\\n            for j in i + 1..points.len() {\\n                let pt_i_0 = points[i][0];\\n                let pt_i_1 = points[i][1];\\n                let pt_j_0 = points[j][0];\\n                let pt_j_1 = points[j][1];\\n                let center = (((pt_i_0 + pt_j_0) as u64) << 16) + (pt_i_1 + pt_j_1) as u64;\\n                let v = vec![pt_i_0, pt_i_1, pt_j_0, pt_j_1];\\n                m.entry(center).or_insert_with(Vec::new).push(v);\\n            }\\n        }\\n        for (_center, points) in m {\\n            for i in 0..points.len() {\\n                for j in i + 1..points.len() {\\n                    let p1 = &points[i];\\n                    let p2 = &points[j];\\n                    if (p1[0] - p2[0]) * (p1[0] - p2[2]) + (p1[1] - p2[1]) * (p1[1] - p2[3]) == 0 {\\n                        let area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n                        if res == 0 || res > area {\\n                            res = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        (res as f64).sqrt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_area_free_rect(points: Vec<Vec<i32>>) -> f64 {\\n        fn d2(x1: i64, y1: i64, x2: i64, y2: i64) -> i64 {\\n            (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\\n        }\\n        let points = points\\n            .iter()\\n            .map(|v| v.iter().map(|&x| x as i64).collect::<Vec<_>>())\\n            .collect::<Vec<_>>();\\n        let mut res = 0;\\n        let mut m = std::collections::HashMap::new();\\n        for i in 0..points.len() {\\n            for j in i + 1..points.len() {\\n                let pt_i_0 = points[i][0];\\n                let pt_i_1 = points[i][1];\\n                let pt_j_0 = points[j][0];\\n                let pt_j_1 = points[j][1];\\n                let center = (((pt_i_0 + pt_j_0) as u64) << 16) + (pt_i_1 + pt_j_1) as u64;\\n                let v = vec![pt_i_0, pt_i_1, pt_j_0, pt_j_1];\\n                m.entry(center).or_insert_with(Vec::new).push(v);\\n            }\\n        }\\n        for (_center, points) in m {\\n            for i in 0..points.len() {\\n                for j in i + 1..points.len() {\\n                    let p1 = &points[i];\\n                    let p2 = &points[j];\\n                    if (p1[0] - p2[0]) * (p1[0] - p2[2]) + (p1[1] - p2[1]) * (p1[1] - p2[3]) == 0 {\\n                        let area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n                        if res == 0 || res > area {\\n                            res = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        (res as f64).sqrt()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2924041,
                "title": "group-all-pairs-by-slopes-anf-lengths",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def dist(self, a, b):\\n        return (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])\\n\\n    def area(self, a, b, c, d):\\n        if self.dist(a, c) != self.dist(b, d):\\n            return float(\\'inf\\')\\n        if a[0] + c[0] != b[0] + d[0] or a[1] + c[1] != b[1] + d[1]:\\n            return float(\\'inf\\')\\n        return self.dist(a, b) * self.dist(a, d)\\n    \\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        n = len(points)\\n        pairs = defaultdict(lambda: defaultdict(list))\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                a, b = points[i]\\n                c, d = points[j]\\n                x, y = c - a, d - b\\n                if y < 0:\\n                    x, y = -x, -y\\n                mul = self.gcd(abs(x), abs(y))\\n                x //= mul\\n                y //= mul\\n                if x >= 0 and y >= 0:\\n                    pairs[(x, y)][self.dist((a, b), (c, d))].append((i, j))\\n        res = float(\\'inf\\')\\n        for slope in pairs:\\n            for d in pairs[slope]:\\n                m = len(pairs[slope][d])\\n                for i in range(m):\\n                    for j in range(i + 1, m):\\n                        p, q = pairs[slope][d][i]\\n                        r, s = pairs[slope][d][j]\\n                        p, q, s, r = sorted([p, q, r, s], key = lambda x: points[x])\\n                        res = min(res, self.area(points[p], points[q], points[r], points[s]))\\n        if res == float(\\'inf\\'):\\n            return 0\\n        return res ** 0.5\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def dist(self, a, b):\\n        return (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])\\n\\n    def area(self, a, b, c, d):\\n        if self.dist(a, c) != self.dist(b, d):\\n            return float(\\'inf\\')\\n        if a[0] + c[0] != b[0] + d[0] or a[1] + c[1] != b[1] + d[1]:\\n            return float(\\'inf\\')\\n        return self.dist(a, b) * self.dist(a, d)\\n    \\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        n = len(points)\\n        pairs = defaultdict(lambda: defaultdict(list))\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                a, b = points[i]\\n                c, d = points[j]\\n                x, y = c - a, d - b\\n                if y < 0:\\n                    x, y = -x, -y\\n                mul = self.gcd(abs(x), abs(y))\\n                x //= mul\\n                y //= mul\\n                if x >= 0 and y >= 0:\\n                    pairs[(x, y)][self.dist((a, b), (c, d))].append((i, j))\\n        res = float(\\'inf\\')\\n        for slope in pairs:\\n            for d in pairs[slope]:\\n                m = len(pairs[slope][d])\\n                for i in range(m):\\n                    for j in range(i + 1, m):\\n                        p, q = pairs[slope][d][i]\\n                        r, s = pairs[slope][d][j]\\n                        p, q, s, r = sorted([p, q, r, s], key = lambda x: points[x])\\n                        res = min(res, self.area(points[p], points[q], points[r], points[s]))\\n        if res == float(\\'inf\\'):\\n            return 0\\n        return res ** 0.5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757454,
                "title": "python-two-solutions-with-explanation",
                "content": "**The Logic**:\\n*I Solution*\\nI created a dictionary `d` to keep all pairs of dots as values and a tuple of two elements described below as keys.\\nTwo elements of keys are segment distance (between two points) and alpha (angle with X-axis). To simplify calculations, I used squared distance instead of distance (to save on sqrt computations) and the difference between x coordinates between two points and a sign of the difference in y coordinates. Why? knowing the distance and the difference - it is enough information to calculate the angle (cos).\\nThus, in each key, I keep pairs of dots with the same length and which are parallel to each other.\\nI loop through the items of `d` and check all pairs between pairs of points (4 points). I check if I can build a rectangle from them and if yes - I calculate the area of rectangular. \\n**Time complexity is difficult to measure but it runs faster than the next solution**\\n```\\nfrom math import sqrt\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def isPerp(p1, p2, p3):\\n            v1 = (p1[0] - p2[0], p1[1] - p2[1])\\n            v2 = (p2[0] - p3[0], p2[1] - p3[1])\\n            return (v1[0] * v2[0] + v1[1] * v2[1]) == 0\\n        def sq3(p1, p2, p3):\\n            return sqrt((p3[0] - p2[0])**2 + (p3[1] - p2[1])**2) * sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)\\n        def squareR(p1, p2, p3, p4):\\n            if (isPerp(p1, p3, p4) and isPerp(p2, p4, p3)):\\n                return sq3(p1, p3, p4)\\n            if (isPerp(p2, p3, p4) and isPerp(p1, p4, p3)):\\n                return sq3(p2, p3, p4)\\n            return 0\\n            \\n        d = dict()\\n        for i in range(len(points) - 1):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, len(points)):\\n                x2, y2 = points[j]\\n                l = (x1-x2)**2 + (y1-y2)**2\\n                a = (x2 - x1) if y2 >= y1 else x1 - x2\\n                t = (l, a)\\n                if t not in d:\\n                    d[t] = []\\n                d[t].append((points[i], points[j]))\\n        ans = float(\\'inf\\')\\n        for (l, xDiff), v in d.items():\\n            xDiff = abs(xDiff)\\n            for i in range(len(v) - 1):\\n                p1, p2 = v[i]\\n                for j in range(i + 1, len(v)):\\n                    p3, p4 = v[j]\\n                    s = squareR(p1, p2, p3, p4)\\n                    if s:\\n                        ans = min(ans, s)\\n        return ans if ans < float(\\'inf\\') else 0\\n```\\n\\n*II Solution*\\nIn the second solution, we iterate through the points checking different combinations of three points (that is why we have three nested loops). If those three points are orthogonal (p1-p2  and p1-p3) we can understand the next point\\'s coordinates and check them in the set of points. If p4 is in the set, we calculate the area.\\n**Time complexity O(N^3)**\\n\\n```\\nfrom math import sqrt\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def findArea(i, j, k):\\n            x1, y1 = points[i]\\n            x2, y2 = points[j]\\n            x3, y3 = points[k]\\n            if x1 == x2 == x3:\\n                return False, 0\\n            xv, yv = x2 - x1, y2 - y1\\n            xu, yu = x3 - x1, y3 - y1\\n            if not (xv * xu + yv * yu) == 0:\\n                return False, 0\\n            p4 = (xv + x3, yv + y3)\\n            if not p4 in pSet:\\n                return False, 0\\n            a = (xv**2 + yv**2) * (xu**2 + yu**2)\\n            return a != 0, a\\n\\n        points.sort()\\n        pSet = set(map(tuple, points))\\n        ans = float(\\'inf\\')\\n        for i in range(len(points) - 3):\\n            for j in range(i + 1, len(points) - 2):\\n                for k in range(j + 1, len(points) - 1):\\n                    isFind, ar = findArea(i, j, k)\\n                    if isFind:\\n                        ans = min(ans, ar)\\n        return sqrt(ans) if ans < float(\\'inf\\') else 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom math import sqrt\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def isPerp(p1, p2, p3):\\n            v1 = (p1[0] - p2[0], p1[1] - p2[1])\\n            v2 = (p2[0] - p3[0], p2[1] - p3[1])\\n            return (v1[0] * v2[0] + v1[1] * v2[1]) == 0\\n        def sq3(p1, p2, p3):\\n            return sqrt((p3[0] - p2[0])**2 + (p3[1] - p2[1])**2) * sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)\\n        def squareR(p1, p2, p3, p4):\\n            if (isPerp(p1, p3, p4) and isPerp(p2, p4, p3)):\\n                return sq3(p1, p3, p4)\\n            if (isPerp(p2, p3, p4) and isPerp(p1, p4, p3)):\\n                return sq3(p2, p3, p4)\\n            return 0\\n            \\n        d = dict()\\n        for i in range(len(points) - 1):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, len(points)):\\n                x2, y2 = points[j]\\n                l = (x1-x2)**2 + (y1-y2)**2\\n                a = (x2 - x1) if y2 >= y1 else x1 - x2\\n                t = (l, a)\\n                if t not in d:\\n                    d[t] = []\\n                d[t].append((points[i], points[j]))\\n        ans = float(\\'inf\\')\\n        for (l, xDiff), v in d.items():\\n            xDiff = abs(xDiff)\\n            for i in range(len(v) - 1):\\n                p1, p2 = v[i]\\n                for j in range(i + 1, len(v)):\\n                    p3, p4 = v[j]\\n                    s = squareR(p1, p2, p3, p4)\\n                    if s:\\n                        ans = min(ans, s)\\n        return ans if ans < float(\\'inf\\') else 0\\n```\n```\\nfrom math import sqrt\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def findArea(i, j, k):\\n            x1, y1 = points[i]\\n            x2, y2 = points[j]\\n            x3, y3 = points[k]\\n            if x1 == x2 == x3:\\n                return False, 0\\n            xv, yv = x2 - x1, y2 - y1\\n            xu, yu = x3 - x1, y3 - y1\\n            if not (xv * xu + yv * yu) == 0:\\n                return False, 0\\n            p4 = (xv + x3, yv + y3)\\n            if not p4 in pSet:\\n                return False, 0\\n            a = (xv**2 + yv**2) * (xu**2 + yu**2)\\n            return a != 0, a\\n\\n        points.sort()\\n        pSet = set(map(tuple, points))\\n        ans = float(\\'inf\\')\\n        for i in range(len(points) - 3):\\n            for j in range(i + 1, len(points) - 2):\\n                for k in range(j + 1, len(points) - 1):\\n                    isFind, ar = findArea(i, j, k)\\n                    if isFind:\\n                        ans = min(ans, ar)\\n        return sqrt(ans) if ans < float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735636,
                "title": "easy-swift-solution",
                "content": "For every combination of all three points:\\nDetermine if the inner product of those three points is zero to make a right angle.\\nCalculate the area of the rectangle created by those 3 points by outer product and determine that it is the smallest.\\nConfirm that there exists a fourth point that constitutes a rectangle.\\n```\\nstruct Po:Hashable {\\n    var x: Int\\n    var y: Int\\n    init(_ p: [Int]){\\n        x = p[0]\\n        y = p[1]\\n    }\\n}\\n\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        var ps: Set<Po> = Set(points.map { Po($0) } )\\n        let n = points.count\\n        var ret = Int.max\\n        for i in 0..<n {\\n            for j in 0..<n {\\n                if i != j {\\n                    for k in 0..<n {\\n                        if k != i && k != j  {\\n                            let ux = points[i][0] - points[k][0]\\n                            let uy = points[i][1] - points[k][1]\\n                            let vx = points[j][0] - points[k][0]\\n                            let vy = points[j][1] - points[k][1]\\n                            if ux*vx + uy*vy == 0 { //Three points make a right angle\\n                                let r = abs(ux*vy - vx*uy)\\n                                if r < ret { //Smallest area\\n                                    let np = [points[i][0]+vx, points[i][1]+vy]\\n                                    if ps.contains(Po(np)) { //The forth point exists\\n                                        ret = r\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if ret == Int.max { return 0}\\n        return Double(ret)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nstruct Po:Hashable {\\n    var x: Int\\n    var y: Int\\n    init(_ p: [Int]){\\n        x = p[0]\\n        y = p[1]\\n    }\\n}\\n\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        var ps: Set<Po> = Set(points.map { Po($0) } )\\n        let n = points.count\\n        var ret = Int.max\\n        for i in 0..<n {\\n            for j in 0..<n {\\n                if i != j {\\n                    for k in 0..<n {\\n                        if k != i && k != j  {\\n                            let ux = points[i][0] - points[k][0]\\n                            let uy = points[i][1] - points[k][1]\\n                            let vx = points[j][0] - points[k][0]\\n                            let vy = points[j][1] - points[k][1]\\n                            if ux*vx + uy*vy == 0 { //Three points make a right angle\\n                                let r = abs(ux*vy - vx*uy)\\n                                if r < ret { //Smallest area\\n                                    let np = [points[i][0]+vx, points[i][1]+vy]\\n                                    if ps.contains(Po(np)) { //The forth point exists\\n                                        ret = r\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if ret == Int.max { return 0}\\n        return Double(ret)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718568,
                "title": "c-solution-no-mistakes-faster-than-57-submissions",
                "content": "Basic geometry. \\n\\n* No need to calculate right angles explicitly using acos. The cross products between lines which forms right angles are 0 already.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> R;\\n    bool isR(vector<int>& a, vector<int>& o, vector<int>& b) {\\n        int ca = (a[0] - o[0]) * (b[0] - o[0]);\\n        int cb = (a[1] - o[1]) * (b[1] - o[1]);\\n        return ca + cb == 0 ? true : false;\\n    }\\n    double line(vector<int>& a, vector<int>& b) {\\n        int x = a[0] - b[0];\\n        int y = a[1] - b[1];\\n        return std::sqrt(x * x + y * y);\\n    }\\n    double area(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        return line(a, b) * line(b, c);\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int len = points.size();\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                for (int k = j + 1; k < len; k++) {\\n                    if (isR(points[i], points[j], points[k])) {\\n                        R.push_back({i,j,k});\\n                    }\\n                    if (isR(points[j], points[k], points[i])) {\\n                        R.push_back({i,k,j});\\n                    }\\n                    if (isR(points[k], points[i], points[j])) {\\n                        R.push_back({j,i,k});\\n                    }\\n                }\\n            }\\n        }\\n        int rlen = R.size();\\n        vector<int> a, b, c, d;\\n        double res = -1.0;\\n        for (int i = 0; i < rlen; i++) {\\n            for (int j = i + 1; j < rlen; j++) {\\n                if (R[i][0] == R[j][0] && R[i][2] == R[j][2]) {\\n                    a = points[R[i][1]];\\n                    b = points[R[i][0]];\\n                    c = points[R[i][2]];\\n                    d = points[R[j][1]];\\n                    if (isR(a, b, d) && isR(a, c, d)) {\\n                        if (res == -1.0) {\\n                            res = area(b, a, c);\\n                        }\\n                        else {\\n                            double tmp = area(b, a, c);\\n                            if (tmp < res)\\n                                res = tmp;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res == -1.0 ? 0.0 : res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> R;\\n    bool isR(vector<int>& a, vector<int>& o, vector<int>& b) {\\n        int ca = (a[0] - o[0]) * (b[0] - o[0]);\\n        int cb = (a[1] - o[1]) * (b[1] - o[1]);\\n        return ca + cb == 0 ? true : false;\\n    }\\n    double line(vector<int>& a, vector<int>& b) {\\n        int x = a[0] - b[0];\\n        int y = a[1] - b[1];\\n        return std::sqrt(x * x + y * y);\\n    }\\n    double area(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        return line(a, b) * line(b, c);\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int len = points.size();\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                for (int k = j + 1; k < len; k++) {\\n                    if (isR(points[i], points[j], points[k])) {\\n                        R.push_back({i,j,k});\\n                    }\\n                    if (isR(points[j], points[k], points[i])) {\\n                        R.push_back({i,k,j});\\n                    }\\n                    if (isR(points[k], points[i], points[j])) {\\n                        R.push_back({j,i,k});\\n                    }\\n                }\\n            }\\n        }\\n        int rlen = R.size();\\n        vector<int> a, b, c, d;\\n        double res = -1.0;\\n        for (int i = 0; i < rlen; i++) {\\n            for (int j = i + 1; j < rlen; j++) {\\n                if (R[i][0] == R[j][0] && R[i][2] == R[j][2]) {\\n                    a = points[R[i][1]];\\n                    b = points[R[i][0]];\\n                    c = points[R[i][2]];\\n                    d = points[R[j][1]];\\n                    if (isR(a, b, d) && isR(a, c, d)) {\\n                        if (res == -1.0) {\\n                            res = area(b, a, c);\\n                        }\\n                        else {\\n                            double tmp = area(b, a, c);\\n                            if (tmp < res)\\n                                res = tmp;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res == -1.0 ? 0.0 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686177,
                "title": "ruby-t-o-n2-s-o-n2-100-100-vector",
                "content": "Base of vector theory\\n\\n- 2 lines are possibly in the same rectangle if they are parallel and have the same length => their vectors are either the same or the reverse.\\n- 2 lines are perpendicular only if their dot product equals to 0\\n\\nWith that, we can come up with a 3-step solution:\\n- First, group all lines that forming the same vector\\n- Second, for each group, find the groups of 2 that their vectors form a dot product of 0, those 4 will form a rectangle\\n- The area of the rectangle will be product of their vector lengths, loop and update the min\\n\\n```\\n# @param {Integer[][]} points\\n# @return {Float}\\ndef min_area_free_rect(points)\\n  vectors = {}\\n\\n  points.combination(2).each do |(x1, y1), (x2, y2)|\\n    if x1 < x2 || y1 < y2\\n      x1, y1, x2, y2 = x2, y2, x1, y1\\n    end\\n    vector = [x1 - x2, y1 - y2]\\n\\n    vectors[vector] ||= []\\n    vectors[vector] << [x1, y1]\\n  end\\n\\n  min = nil\\n  \\n  vectors.each do |vector, grp|\\n    next if grp.size < 2\\n    v0x, v0y = vector\\n    l1 = Math.sqrt(v0x * v0x + v0y * v0y)\\n\\n    grp.combination(2).each do |(x01, y01), (x11, y11)|\\n      v1x = x11 - x01\\n      v1y = y11 - y01\\n\\n      if v0x * v1x + v0y * v1y == 0\\n        l2 = Math.sqrt(v1x * v1x + v1y * v1y)\\n        min = [min, l1 * l2].compact.min\\n      end\\n    end\\n  end\\n\\n  min || 0\\nend\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "Base of vector theory\\n\\n- 2 lines are possibly in the same rectangle if they are parallel and have the same length => their vectors are either the same or the reverse.\\n- 2 lines are perpendicular only if their dot product equals to 0\\n\\nWith that, we can come up with a 3-step solution:\\n- First, group all lines that forming the same vector\\n- Second, for each group, find the groups of 2 that their vectors form a dot product of 0, those 4 will form a rectangle\\n- The area of the rectangle will be product of their vector lengths, loop and update the min\\n\\n```\\n# @param {Integer[][]} points\\n# @return {Float}\\ndef min_area_free_rect(points)\\n  vectors = {}\\n\\n  points.combination(2).each do |(x1, y1), (x2, y2)|\\n    if x1 < x2 || y1 < y2\\n      x1, y1, x2, y2 = x2, y2, x1, y1\\n    end\\n    vector = [x1 - x2, y1 - y2]\\n\\n    vectors[vector] ||= []\\n    vectors[vector] << [x1, y1]\\n  end\\n\\n  min = nil\\n  \\n  vectors.each do |vector, grp|\\n    next if grp.size < 2\\n    v0x, v0y = vector\\n    l1 = Math.sqrt(v0x * v0x + v0y * v0y)\\n\\n    grp.combination(2).each do |(x01, y01), (x11, y11)|\\n      v1x = x11 - x01\\n      v1y = y11 - y01\\n\\n      if v0x * v1x + v0y * v1y == 0\\n        l2 = Math.sqrt(v1x * v1x + v1y * v1y)\\n        min = [min, l1 * l2].compact.min\\n      end\\n    end\\n  end\\n\\n  min || 0\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2587864,
                "title": "java-36-ms-80-faster",
                "content": "\\tdouble[][] distance;\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        distance = new double[n][n];\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                double d = getDistanceBtw(points[i], points[j]);\\n                distance[i][j] = d;\\n                distance[j][i] = d;\\n            }\\n        }\\n        \\n        double minArea = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                for(int k=j+1; k<n; k++) {\\n                    double dij = distance[i][j];\\n                    double dik = distance[i][k];\\n                    double djk = distance[j][k];\\n                    double area = Integer.MAX_VALUE;\\n                    if(isRightAngleTri(i,j,k)) {\\n                        area = findFourthPoint(i, j, k);\\n                    } else if(isRightAngleTri(i,k,j)) {\\n                        area = findFourthPoint(i, j, k);\\n                    } else if(isRightAngleTri(j,k,i)) {\\n                        area = findFourthPoint(i, j, k);\\n                    }\\n                    \\n                    minArea = Math.min(area, minArea);\\n                }\\n            }\\n        }\\n        return minArea == Integer.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    public double findFourthPoint(int x, int y, int z) {\\n        for(int i=0; i<distance.length; i++) {\\n            if(i != x && i != y && i != z){\\n                if(distance[z][i] == distance[x][y] && isRightAngleTri(x,y,i)) {\\n                    double area = Math.sqrt(distance[x][z]) * Math.sqrt(distance[y][z]);\\n                    return area;\\n                }\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n    \\n    \\n    \\n    public boolean isRightAngleTri(int x, int y, int z) {\\n        double hyp = distance[x][y];\\n        double side1 = distance[x][z];\\n        double side2 = distance[y][z];\\n        if(hyp == side1 + side2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public double getDistanceBtw(int[] p1, int[] p2) {\\n        double x = p1[0] - p2[0];\\n        double y = p1[1] - p2[1];\\n        double d = x*x + y*y;\\n        return d;\\n    }",
                "solutionTags": [],
                "code": "\\tdouble[][] distance;\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        distance = new double[n][n];\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                double d = getDistanceBtw(points[i], points[j]);\\n                distance[i][j] = d;\\n                distance[j][i] = d;\\n            }\\n        }\\n        \\n        double minArea = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                for(int k=j+1; k<n; k++) {\\n                    double dij = distance[i][j];\\n                    double dik = distance[i][k];\\n                    double djk = distance[j][k];\\n                    double area = Integer.MAX_VALUE;\\n                    if(isRightAngleTri(i,j,k)) {\\n                        area = findFourthPoint(i, j, k);\\n                    } else if(isRightAngleTri(i,k,j)) {\\n                        area = findFourthPoint(i, j, k);\\n                    } else if(isRightAngleTri(j,k,i)) {\\n                        area = findFourthPoint(i, j, k);\\n                    }\\n                    \\n                    minArea = Math.min(area, minArea);\\n                }\\n            }\\n        }\\n        return minArea == Integer.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    public double findFourthPoint(int x, int y, int z) {\\n        for(int i=0; i<distance.length; i++) {\\n            if(i != x && i != y && i != z){\\n                if(distance[z][i] == distance[x][y] && isRightAngleTri(x,y,i)) {\\n                    double area = Math.sqrt(distance[x][z]) * Math.sqrt(distance[y][z]);\\n                    return area;\\n                }\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n    \\n    \\n    \\n    public boolean isRightAngleTri(int x, int y, int z) {\\n        double hyp = distance[x][y];\\n        double side1 = distance[x][z];\\n        double side2 = distance[y][z];\\n        if(hyp == side1 + side2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public double getDistanceBtw(int[] p1, int[] p2) {\\n        double x = p1[0] - p2[0];\\n        double y = p1[1] - p2[1];\\n        double d = x*x + y*y;\\n        return d;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2507171,
                "title": "python-pythagorean-theorem-o-n-3-easy-solution-with-comments",
                "content": "class Solution(object):\\n    def minAreaFreeRect(self, points):\\n\\n        #Basic idea:\\n        #Iterate all possible 3 points combination\\n        #If they can form a rectangle (By Pythagorean theorem), find the 4th point:\\n        #   then check whether the 4th point in points or not\\n        #        if 4th point in points:\\n        #           calculate their area\\n        #Return the min area\\n        \\n        pLen = len(points)\\n       \\n        \\n        setPts = set((points[i][0],points[i][1]) for i in range(pLen))\\n\\n        distIJMat = [[0 for j in range(pLen)] for i in range(pLen)]\\n        \\n        #Find the distance square between any two points i,j\\n        for i in range(pLen - 1):\\n            for j in range(i, pLen):\\n                distTmp = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\\n                distIJMat[j][i] = distTmp\\n                distIJMat[i][j] = distTmp\\n\\n        areas = []\\n\\n        for i in range(pLen - 2):\\n            for j in range(i + 1, pLen - 1):\\n                for k in range(j + 1, pLen):\\n                    \\n                    if(distIJMat[i][j] == distIJMat[i][k] + distIJMat[j][k]):\\n                        pt1, pt2, pt3 = k, i, j\\n                    elif(distIJMat[j][k] == distIJMat[i][k] + distIJMat[j][i]):\\n                        pt1, pt2, pt3 = i, j, k\\n                    elif(distIJMat[k][i] == distIJMat[i][j] + distIJMat[j][k]):\\n                        pt1, pt2, pt3 = j, i, k\\n                    else:\\n                        continue\\n                        \\n                    pt4 = points[pt2][0] + points[pt3][0] - points[pt1][0], points[pt2][1] + points[pt3][1] - points[pt1][1]\\n                    \\n                    if(pt4 not in setPts):\\n                        continue\\n                        \\n                    areas.append(distIJMat[pt1][pt2] *  distIJMat[pt1][pt3])\\n\\n        if(areas == []):\\n            return 0\\n        else:\\n            return sqrt(min(areas))\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def minAreaFreeRect(self, points):\\n\\n        #Basic idea:\\n        #Iterate all possible 3 points combination\\n        #If they can form a rectangle (By Pythagorean theorem), find the 4th point:\\n        #   then check whether the 4th point in points or not\\n        #        if 4th point in points:\\n        #           calculate their area\\n        #Return the min area\\n        \\n        pLen = len(points)\\n       \\n        \\n        setPts = set((points[i][0],points[i][1]) for i in range(pLen))\\n\\n        distIJMat = [[0 for j in range(pLen)] for i in range(pLen)]\\n        \\n        #Find the distance square between any two points i,j\\n        for i in range(pLen - 1):\\n            for j in range(i, pLen):\\n                distTmp = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\\n                distIJMat[j][i] = distTmp\\n                distIJMat[i][j] = distTmp\\n\\n        areas = []\\n\\n        for i in range(pLen - 2):\\n            for j in range(i + 1, pLen - 1):\\n                for k in range(j + 1, pLen):\\n                    \\n                    if(distIJMat[i][j] == distIJMat[i][k] + distIJMat[j][k]):\\n                        pt1, pt2, pt3 = k, i, j\\n                    elif(distIJMat[j][k] == distIJMat[i][k] + distIJMat[j][i]):\\n                        pt1, pt2, pt3 = i, j, k\\n                    elif(distIJMat[k][i] == distIJMat[i][j] + distIJMat[j][k]):\\n                        pt1, pt2, pt3 = j, i, k\\n                    else:\\n                        continue\\n                        \\n                    pt4 = points[pt2][0] + points[pt3][0] - points[pt1][0], points[pt2][1] + points[pt3][1] - points[pt1][1]\\n                    \\n                    if(pt4 not in setPts):\\n                        continue\\n                        \\n                    areas.append(distIJMat[pt1][pt2] *  distIJMat[pt1][pt3])\\n\\n        if(areas == []):\\n            return 0\\n        else:\\n            return sqrt(min(areas))\\n",
                "codeTag": "Java"
            },
            {
                "id": 2442480,
                "title": "c-using-dictionary-to-store-center-distance",
                "content": "In first loop calculate power 2 distance of each pair of points and middle point of them and insert in a dictionary.\\nThe second will happen only if there is two or more frequency of a key. it will choose a triangle in those four point to calculate the area of rectangle and update minimum value.\\n```\\npublic class Solution {\\n    public double MinAreaFreeRect(int[][] points) {\\n        var len=points.Length;\\n        if(len<4) return 0.0;\\n        var res=Double.MaxValue;\\n        Dictionary<string,List<int[]>> dict = new Dictionary<string,List<int[]>>();\\n        for(int i=0;i<len-1;i++){\\n            for(int j=i+1;j<len;j++){\\n                long dis = Distance2(points[i],points[j]);\\n                double[] mid = Middle(points[i],points[j]);\\n                String key = $\"{dis}-{mid[0]},{mid[1]}\";\\n                if(!dict.ContainsKey(key)) dict.Add(key, new List<int[]>());\\n                dict[key].Add(new int[] {i,j});\\n            }\\n        }\\n        foreach (var key in dict.Keys) {\\n            List<int[]> list = dict[key];\\n            for(int i=0;i<list.Count-1;i++){\\n                for(int j=i+1;j<list.Count;j++){\\n                    int p1=list[i][0];\\n                    int p2=list[j][0];\\n                    int p3=list[j][1];\\n                    double len1=Math.Sqrt(Distance2(points[p1],points[p2]));\\n                    double len2=Math.Sqrt(Distance2(points[p1],points[p3]));\\n                    double area = len1 * len2; \\n                    res = Math.Min(res, area);\\n                }\\n            }\\n        }\\n        return res == Double.MaxValue ?  0.0 : res;\\n    }\\n    private long Distance2(int[] point1,int[] point2){\\n        return (point1[0] - point2[0]) * (point1[0] - point2[0]) + \\n            (point1[1] - point2[1]) * (point1[1] - point2[1]);\\n    }\\n    private double[] Middle(int[] point1,int[] point2){\\n        return new double[] {(point1[0]+point2[0])/2.0,\\n                             (point1[1]+point2[1])/2.0};\\n    }\\n}\\n```\\nO(N^2)\\nconverted from java code",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public double MinAreaFreeRect(int[][] points) {\\n        var len=points.Length;\\n        if(len<4) return 0.0;\\n        var res=Double.MaxValue;\\n        Dictionary<string,List<int[]>> dict = new Dictionary<string,List<int[]>>();\\n        for(int i=0;i<len-1;i++){\\n            for(int j=i+1;j<len;j++){\\n                long dis = Distance2(points[i],points[j]);\\n                double[] mid = Middle(points[i],points[j]);\\n                String key = $\"{dis}-{mid[0]},{mid[1]}\";\\n                if(!dict.ContainsKey(key)) dict.Add(key, new List<int[]>());\\n                dict[key].Add(new int[] {i,j});\\n            }\\n        }\\n        foreach (var key in dict.Keys) {\\n            List<int[]> list = dict[key];\\n            for(int i=0;i<list.Count-1;i++){\\n                for(int j=i+1;j<list.Count;j++){\\n                    int p1=list[i][0];\\n                    int p2=list[j][0];\\n                    int p3=list[j][1];\\n                    double len1=Math.Sqrt(Distance2(points[p1],points[p2]));\\n                    double len2=Math.Sqrt(Distance2(points[p1],points[p3]));\\n                    double area = len1 * len2; \\n                    res = Math.Min(res, area);\\n                }\\n            }\\n        }\\n        return res == Double.MaxValue ?  0.0 : res;\\n    }\\n    private long Distance2(int[] point1,int[] point2){\\n        return (point1[0] - point2[0]) * (point1[0] - point2[0]) + \\n            (point1[1] - point2[1]) * (point1[1] - point2[1]);\\n    }\\n    private double[] Middle(int[] point1,int[] point2){\\n        return new double[] {(point1[0]+point2[0])/2.0,\\n                             (point1[1]+point2[1])/2.0};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409203,
                "title": "check-mid-point-and-length-with-annotation",
                "content": "class Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        from collections import defaultdict\\n        import math\\n        dp = {}\\n        points=map(lambda n: (float(n[0]),float(n[1])),points)\\n        for i in range(len(points) - 1):\\n            for j in range(i + 1, len(points)):\\n                l = (points[j][1] - points[i][1]) ** 2 + (points[j][0] - points[i][0]) ** 2  # distance squared\\n                x = (points[i][0] + points[j][0]) / 2                                      # midpoint (x,y)\\n                y = (points[i][1] + points[j][1]) / 2\\n                dp[(i, j)] = (l, (x,y), points[i], points[j]) \\n        #print(dp)\\n        lines=dp.keys()\\n        minnum=float(\\'inf\\')\\n        flag=False\\n        for i in range(len(lines)-1):\\n            for j in range(i + 1, len(lines)):\\n                if dp[lines[i]][1]==dp[lines[j]][1] and dp[lines[i]][0]==dp[lines[j]][0]:\\n                    #midpoints align and length same\\n                    a=math.sqrt((dp[lines[i]][2][0]-dp[lines[j]][2][0])**2+(dp[lines[i]][2][1]-dp[lines[j]][2][1])**2)\\n                    b=math.sqrt((dp[lines[i]][2][0]-dp[lines[j]][3][0])**2+(dp[lines[i]][2][1]-dp[lines[j]][3][1])**2)\\n                    print(a,b,dp[lines[i]][1],dp[lines[i]][0],lines[i],lines[j])\\n                    minnum=min(minnum,float(a*b))\\n                    flag=True\\n        if flag:\\n            return minnum\\n        else:\\n            return 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        from collections import defaultdict\\n        import math\\n        dp = {}",
                "codeTag": "Java"
            },
            {
                "id": 2391880,
                "title": "python-solution-tedious-question-should-belong-to-hard",
                "content": "To solve this problem, you need to know some basic geometry of the rectangle:\\n1. A rectangle\\'s diagonals bisect each other (therefore same length)\\n2. The length of a diagonal do not correlate with the area of the rectangle, i.e. longer diagonal does not mean larger area (d^2 = a^2 + b^2, area = a * b)\\n\\nTherefore, even after using hash table to store the coordinates of mid points and diagonal length, we still have to loop through all pairs of pairs within the same diagonal length to arrive at the correct answer.\\n```\\nclass Solution:\\n    # 1 <= points.length <= 50 -> O(n^2) algorithm should be ok\\n    # For a rectangle, diagonal\\'s mid-point should coincide between the opposite corners\\n    # In addition their length should be the same\\n    # Therefore, we can first scan points and compute the centroid coordinates and diagonal length between all pairs\\n    # Format = hash_table[(2*xmid, 2*ymid, diag_length^2)] = [{(x0, y1), (x1, y1)}, {(x2, y2), (x3, y3)}, ....]\\n    # Then scan through the keys to find look for the smallest area\\n    # We should note that the area of rectangle is a*b, diagonal length is sqrt(a^2 + b^2), the shorter diagonal do not necessarily means smaller area\\n    \\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        hash_table = {}\\n        n = len(points)\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                x0, y0 = points[i]\\n                x1, y1 = points[j]\\n                key = (x0+x1, y0+y1, (x0-x1)*(x0-x1)+(y0-y1)*(y0-y1))\\n                if key not in hash_table:\\n                    hash_table[key] = []\\n                hash_table[key].append([tuple(points[i]), tuple(points[j])])\\n        \\n        curr_min = float(\\'Inf\\')\\n        for key in hash_table.keys():\\n            if len(hash_table[key]) > 1:\\n                lp = len(hash_table[key])\\n                for i in range(lp-1):\\n                    for j in range(i+1, lp):\\n                        x0, y0 = hash_table[key][i][0]\\n                        x2, y2 = hash_table[key][i][1]\\n                        x1, y1 = hash_table[key][j][0]\\n                        curr_min = min(curr_min, math.sqrt(((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1))*((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))))\\n        if curr_min == float(\\'Inf\\'):\\n            return 0\\n        else:\\n            return curr_min\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # 1 <= points.length <= 50 -> O(n^2) algorithm should be ok\\n    # For a rectangle, diagonal\\'s mid-point should coincide between the opposite corners\\n    # In addition their length should be the same\\n    # Therefore, we can first scan points and compute the centroid coordinates and diagonal length between all pairs\\n    # Format = hash_table[(2*xmid, 2*ymid, diag_length^2)] = [{(x0, y1), (x1, y1)}, {(x2, y2), (x3, y3)}, ....]\\n    # Then scan through the keys to find look for the smallest area\\n    # We should note that the area of rectangle is a*b, diagonal length is sqrt(a^2 + b^2), the shorter diagonal do not necessarily means smaller area\\n    \\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        hash_table = {}\\n        n = len(points)\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                x0, y0 = points[i]\\n                x1, y1 = points[j]\\n                key = (x0+x1, y0+y1, (x0-x1)*(x0-x1)+(y0-y1)*(y0-y1))\\n                if key not in hash_table:\\n                    hash_table[key] = []\\n                hash_table[key].append([tuple(points[i]), tuple(points[j])])\\n        \\n        curr_min = float(\\'Inf\\')\\n        for key in hash_table.keys():\\n            if len(hash_table[key]) > 1:\\n                lp = len(hash_table[key])\\n                for i in range(lp-1):\\n                    for j in range(i+1, lp):\\n                        x0, y0 = hash_table[key][i][0]\\n                        x2, y2 = hash_table[key][i][1]\\n                        x1, y1 = hash_table[key][j][0]\\n                        curr_min = min(curr_min, math.sqrt(((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1))*((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))))\\n        if curr_min == float(\\'Inf\\'):\\n            return 0\\n        else:\\n            return curr_min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209517,
                "title": "c-brute-force-and-hash-set-time-o-n-3",
                "content": "```\\n#if 0\\n \\n(x1, y1) x----------------x (x4, y4)\\n         |                |\\n         |                |\\n(x3, y3) x----------------x (x2, y2)\\n\\n#endif\\n\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        if (points.size() < 4) {\\n            return 0.0;\\n        }\\n\\n        unordered_set<unsigned long> pointSet;\\n        for (int i = 0; i < points.size(); ++i) {\\n            pointSet.insert(encode(points[i][0], points[i][1]));\\n        }\\n\\n        double answer = DBL_MAX;\\n        bool foundRec = false;\\n        for (vector<int>& p1 : points) {\\n            int x1 = p1[0], y1 = p1[1];\\n\\n            for (vector<int>& p2 : points) {\\n                int x2 = p2[0], y2 = p2[1];\\n                if (x1 == x2 && y1 == y2) {\\n                    // p1 and p2 are the same.\\n                    continue;\\n                }\\n\\n                for (vector<int>& p3 : points) {\\n                    int x3 = p3[0], y3 = p3[1];\\n                    unsigned long x4 = x1 + x2 - x3, y4 = y1 + y2 - y3;\\n                    if (pointSet.count(encode(x4, y4)) == 0) {\\n                        // The fourth point doesn\\u2019t exist.\\n                        continue;\\n                    }\\n\\n                    unsigned long side1 = distance(x1, y1, x3, y3);\\n                    unsigned long side2 = distance(x2, y2, x3, y3);\\n                    if (side1 == 0 || side2 == 0) {\\n                        continue;\\n                    }\\n                    unsigned long diagonal = distance(x1, y1, x2, y2);\\n                    if (side1 + side2 != diagonal) {\\n                        // side1 and side2 are not perpendicular.\\n                        continue;\\n                    }\\n                    foundRec = true;\\n                    answer = min(answer, sqrt(side1) * sqrt(side2));\\n                } // end of for-loop\\n            } // end of for-loop\\n        } // end of for-loop\\n\\n        if (!foundRec) {\\n            return 0.0;\\n        }\\n        return answer;\\n    }\\n\\nprivate:\\n    unsigned long encode(unsigned long x, unsigned long y) {\\n        return 50000 * x + y;\\n    }\\n\\n    unsigned long distance(unsigned long x1, unsigned long y1, unsigned long x2, unsigned long y2) {\\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#if 0\\n \\n(x1, y1) x----------------x (x4, y4)\\n         |                |\\n         |                |\\n(x3, y3) x----------------x (x2, y2)\\n\\n#endif\\n\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        if (points.size() < 4) {\\n            return 0.0;\\n        }\\n\\n        unordered_set<unsigned long> pointSet;\\n        for (int i = 0; i < points.size(); ++i) {\\n            pointSet.insert(encode(points[i][0], points[i][1]));\\n        }\\n\\n        double answer = DBL_MAX;\\n        bool foundRec = false;\\n        for (vector<int>& p1 : points) {\\n            int x1 = p1[0], y1 = p1[1];\\n\\n            for (vector<int>& p2 : points) {\\n                int x2 = p2[0], y2 = p2[1];\\n                if (x1 == x2 && y1 == y2) {\\n                    // p1 and p2 are the same.\\n                    continue;\\n                }\\n\\n                for (vector<int>& p3 : points) {\\n                    int x3 = p3[0], y3 = p3[1];\\n                    unsigned long x4 = x1 + x2 - x3, y4 = y1 + y2 - y3;\\n                    if (pointSet.count(encode(x4, y4)) == 0) {\\n                        // The fourth point doesn\\u2019t exist.\\n                        continue;\\n                    }\\n\\n                    unsigned long side1 = distance(x1, y1, x3, y3);\\n                    unsigned long side2 = distance(x2, y2, x3, y3);\\n                    if (side1 == 0 || side2 == 0) {\\n                        continue;\\n                    }\\n                    unsigned long diagonal = distance(x1, y1, x2, y2);\\n                    if (side1 + side2 != diagonal) {\\n                        // side1 and side2 are not perpendicular.\\n                        continue;\\n                    }\\n                    foundRec = true;\\n                    answer = min(answer, sqrt(side1) * sqrt(side2));\\n                } // end of for-loop\\n            } // end of for-loop\\n        } // end of for-loop\\n\\n        if (!foundRec) {\\n            return 0.0;\\n        }\\n        return answer;\\n    }\\n\\nprivate:\\n    unsigned long encode(unsigned long x, unsigned long y) {\\n        return 50000 * x + y;\\n    }\\n\\n    unsigned long distance(unsigned long x1, unsigned long y1, unsigned long x2, unsigned long y2) {\\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134680,
                "title": "c-slope-of-opposite-sides-are-equal",
                "content": "```\\nint sortcol(vector<int>& v1,vector<int>& v2){\\n    if(v1[0]==v2[0]) return v1[1]<v2[1];\\n    else return v1[0]<v2[0];\\n}\\nclass Solution {\\npublic:\\n    double dis(vector<vector<int>>& nums, int i,int j){\\n        return (nums[i][0]-nums[j][0])*(nums[i][0]-nums[j][0]) + (nums[i][1]-nums[j][1])*(nums[i][1]-nums[j][1]);\\n    }\\n    double find(vector<vector<int>>& nums){\\n        sort(nums.begin(),nums.end(),sortcol);\\n        if(dis(nums,0,1)==dis(nums,2,3) && dis(nums,0,2)==dis(nums,1,3) && dis(nums,2,1)==dis(nums,0,3)){\\n            return sqrt(dis(nums,0,1))*sqrt(dis(nums,0,2));\\n        }\\n        else return INT_MAX;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& nums) {\\n        map<string,vector<vector<int>>> mp; // {slope, vector of all points pair}\\n        for(int i = 0; i<nums.size()-1;++i){\\n            for(int j = i+1; j<nums.size();++j){  \\n                int x = nums[i][0]-nums[j][0], y = nums[i][1]-nums[j][1];\\n                int g = __gcd(y,x);\\n                string s = to_string(y/g)+\"*\"+to_string(x/g);  // slope\\n                mp[s].push_back({i,j});\\n            }\\n        }\\n        double re = INT_MAX;\\n        for(auto&[s,arr]:mp){\\n            for(int a = 0; a<arr.size()-1;++a){  \\n                for(int b = 0; b<arr.size();++b){\\n\\t\\t\\t\\t// for a given slope, try all possible combinations of points\\n                    int i = arr[a][0], j=arr[a][1], k = arr[b][0], l = arr[b][1];\\n                    if(i==k||i==l||j==k||j==l) continue;\\n                    vector<vector<int>> temp = {nums[i],nums[j],nums[k],nums[l]};\\n                    re = min(re,find(temp));\\n                }\\n            }\\n        }\\n        if(re==INT_MAX) re = 0;\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint sortcol(vector<int>& v1,vector<int>& v2){\\n    if(v1[0]==v2[0]) return v1[1]<v2[1];\\n    else return v1[0]<v2[0];\\n}\\nclass Solution {\\npublic:\\n    double dis(vector<vector<int>>& nums, int i,int j){\\n        return (nums[i][0]-nums[j][0])*(nums[i][0]-nums[j][0]) + (nums[i][1]-nums[j][1])*(nums[i][1]-nums[j][1]);\\n    }\\n    double find(vector<vector<int>>& nums){\\n        sort(nums.begin(),nums.end(),sortcol);\\n        if(dis(nums,0,1)==dis(nums,2,3) && dis(nums,0,2)==dis(nums,1,3) && dis(nums,2,1)==dis(nums,0,3)){\\n            return sqrt(dis(nums,0,1))*sqrt(dis(nums,0,2));\\n        }\\n        else return INT_MAX;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& nums) {\\n        map<string,vector<vector<int>>> mp; // {slope, vector of all points pair}\\n        for(int i = 0; i<nums.size()-1;++i){\\n            for(int j = i+1; j<nums.size();++j){  \\n                int x = nums[i][0]-nums[j][0], y = nums[i][1]-nums[j][1];\\n                int g = __gcd(y,x);\\n                string s = to_string(y/g)+\"*\"+to_string(x/g);  // slope\\n                mp[s].push_back({i,j});\\n            }\\n        }\\n        double re = INT_MAX;\\n        for(auto&[s,arr]:mp){\\n            for(int a = 0; a<arr.size()-1;++a){  \\n                for(int b = 0; b<arr.size();++b){\\n\\t\\t\\t\\t// for a given slope, try all possible combinations of points\\n                    int i = arr[a][0], j=arr[a][1], k = arr[b][0], l = arr[b][1];\\n                    if(i==k||i==l||j==k||j==l) continue;\\n                    vector<vector<int>> temp = {nums[i],nums[j],nums[k],nums[l]};\\n                    re = min(re,find(temp));\\n                }\\n            }\\n        }\\n        if(re==INT_MAX) re = 0;\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108231,
                "title": "bruteforce-three-point-program-has-bug-that-test-case-cannot-detected",
                "content": "The following bruteForce three point shouldn\\'t test on all three point combination on right angle\\nwhen looping check i j k is right angle is not passed\\nbut j i k can pass submition\\nactually both of them cannot test all case\\n\\nexample code pass\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if(points.length < 4)\\n        {\\n            return 0;\\n        }\\n        HashSet<Pair<Integer,Integer>> exiPoint = new HashSet<>();\\n        \\n        for(int[] point : points)\\n        {\\n            exiPoint.add(new Pair(point[0],point[1]));\\n        }\\n        Double minArea = Double.MAX_VALUE;\\n        for(int i = 0 ; i < points.length - 2 ; i++)\\n        {\\n            for(int j = i+1 ; j < points.length - 1 ; j++)\\n            {\\n                for(int k =j+1; k < points.length; k++)\\n                {\\n                    if(distance(points[i],points[j]) + distance(points[i], points[k]) == distance(points[j], points[k]))\\n                    {\\n                        //angle j i k is right-angle\\n                        int p4x = points[j][0] + points[k][0] - points[i][0];\\n                        int p4y = points[j][1] + points[k][1] - points[i][1];\\n                        if(exiPoint.contains(new Pair(p4x,p4y)))\\n                        {\\n                            Double area = Math.sqrt(distance(points[i],points[j])) * Math.sqrt(distance(points[i], points[k]));\\n                            \\n                            System.out.println(\"area : \" + area + \" i j k\" + i + \" \" + j + \" \" + k);\\n                            minArea = Math.min(area, minArea);  \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    public double distance(int[] p1, int[] p2)\\n    {\\n        return (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1]);\\n    }\\n}\\n\\nexample code not pass\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if(points.length < 4)\\n        {\\n            return 0;\\n        }\\n        HashSet<Pair<Integer,Integer>> exiPoint = new HashSet<>();\\n        \\n        for(int[] point : points)\\n        {\\n            exiPoint.add(new Pair(point[0],point[1]));\\n        }\\n        Double minArea = Double.MAX_VALUE;\\n        for(int i = 0 ; i < points.length - 2 ; i++)\\n        {\\n            for(int j = i+1 ; j < points.length - 1 ; j++)\\n            {\\n                for(int k =j+1; k < points.length; k++)\\n                {\\n                    if(distance(points[i],points[j]) + distance(points[j], points[k]) == distance(points[i], points[k]))\\n                    {\\n                        //angle i j k is right-angle\\n                        int p4x = points[i][0] + points[k][0] - points[j][0];\\n                        int p4y = points[i][1] + points[k][1] - points[j][1];\\n                        if(exiPoint.contains(new Pair(p4x,p4y)))\\n                        {\\n                            Double area = Math.sqrt(distance(points[i],points[j])) * Math.sqrt(distance(points[i], points[k]));\\n                            \\n                            System.out.println(\"area : \" + area + \" i j k\" + i + \" \" + j + \" \" + k);\\n                            minArea = Math.min(area, minArea);  \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    public double distance(int[] p1, int[] p2)\\n    {\\n        return (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1]);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if(points.length < 4)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2083507,
                "title": "c-solution-based-on-geometry-and-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<int, unordered_set<int>> x_to_ys;\\n        for (int i = 0; i < points.size(); i++){\\n            int x = points[i][0], y = points[i][1];\\n            if (x_to_ys.count(x) == 0){x_to_ys.insert({x, {y}});}\\n            else{x_to_ys[x].insert(y);}\\n        }\\n        long min_area = INT_MAX;\\n        bool at_least_one = false;\\n        int n = points.size();\\n        for (int i = 0; i < n; i++){\\n            for (int j = i + 1; j < n; j++){\\n                long dx_ij = (points[i][0] - points[j][0]), dy_ij = (points[i][1] - points[j][1]);\\n                long sq_ij = dx_ij * dx_ij + dy_ij * dy_ij;\\n                for (int k = 0; k < n; k++){\\n                    if (k != i && k != j){\\n                        // whether i, j, k can form a RT?\\n                        long dx_ik = (points[i][0] - points[k][0]), dy_ik = (points[i][1] - points[k][1]);\\n                        long sq_ik = dx_ik * dx_ik + dy_ik * dy_ik;\\n                        long dx_jk = (points[j][0] - points[k][0]), dy_jk = (points[j][1] - points[k][1]);\\n                        long sq_jk = dx_jk * dx_jk + dy_jk * dy_jk;\\n                        if (sq_ik + sq_jk == sq_ij){\\n                            // if the sym point of k for {i, j} is exist?\\n                            int kx = points[k][0], ky = points[k][1];\\n                            int cx_ij = (points[i][0] + points[j][0]);\\n                            int cy_ij = (points[i][1] + points[j][1]);\\n                            int ax = cx_ij - kx, ay = cy_ij - ky;\\n                            if (x_to_ys.count(ax) == 1 && x_to_ys[ax].count(ay) == 1){\\n                                at_least_one = true;\\n                                min_area = min(min_area, (long)sqrt(sq_ik * sq_jk));\\n                            }\\n                        }   \\n                    }                    \\n                }\\n            }\\n        }\\n        if (!at_least_one){return 0;}\\n        return (double)min_area;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<int, unordered_set<int>> x_to_ys;\\n        for (int i = 0; i < points.size(); i++){\\n            int x = points[i][0], y = points[i][1];\\n            if (x_to_ys.count(x) == 0){x_to_ys.insert({x, {y}});}\\n            else{x_to_ys[x].insert(y);}\\n        }\\n        long min_area = INT_MAX;\\n        bool at_least_one = false;\\n        int n = points.size();\\n        for (int i = 0; i < n; i++){\\n            for (int j = i + 1; j < n; j++){\\n                long dx_ij = (points[i][0] - points[j][0]), dy_ij = (points[i][1] - points[j][1]);\\n                long sq_ij = dx_ij * dx_ij + dy_ij * dy_ij;\\n                for (int k = 0; k < n; k++){\\n                    if (k != i && k != j){\\n                        // whether i, j, k can form a RT?\\n                        long dx_ik = (points[i][0] - points[k][0]), dy_ik = (points[i][1] - points[k][1]);\\n                        long sq_ik = dx_ik * dx_ik + dy_ik * dy_ik;\\n                        long dx_jk = (points[j][0] - points[k][0]), dy_jk = (points[j][1] - points[k][1]);\\n                        long sq_jk = dx_jk * dx_jk + dy_jk * dy_jk;\\n                        if (sq_ik + sq_jk == sq_ij){\\n                            // if the sym point of k for {i, j} is exist?\\n                            int kx = points[k][0], ky = points[k][1];\\n                            int cx_ij = (points[i][0] + points[j][0]);\\n                            int cy_ij = (points[i][1] + points[j][1]);\\n                            int ax = cx_ij - kx, ay = cy_ij - ky;\\n                            if (x_to_ys.count(ax) == 1 && x_to_ys[ax].count(ay) == 1){\\n                                at_least_one = true;\\n                                min_area = min(min_area, (long)sqrt(sq_ik * sq_jk));\\n                            }\\n                        }   \\n                    }                    \\n                }\\n            }\\n        }\\n        if (!at_least_one){return 0;}\\n        return (double)min_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861290,
                "title": "java-hashset-and-pythagoras-theorem-based-solution",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        \\n        int numPoints = points.length;\\n        \\n        if (numPoints < 4)\\n            return 0;\\n        \\n        Set<Pair<Double, Double>> uniquePoints = new HashSet<Pair<Double, Double>>();\\n        \\n        for (int i = 0; i < numPoints; i++)\\n            uniquePoints.add(new Pair((double)points[i][0], (double)points[i][1]));\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        for (int i = 0; i < numPoints-2; i++) {\\n            \\n            int[] vertex1 = points[i];\\n            \\n            for (int j = i+1; j < numPoints-1; j++) {\\n                \\n                int[] vertex2 = points[j];\\n                \\n                for (int k = j+1; k < numPoints; k++) {\\n                    \\n                    int[] vertex3 = points[k];\\n                    \\n                    double dx12 = vertex1[0] - vertex2[0];\\n                    double dy12 = vertex1[1] - vertex2[1];\\n                    \\n                    double dx13 = vertex1[0] - vertex3[0];\\n                    double dy13 = vertex1[1] - vertex3[1];\\n                    \\n                    double dx23 = vertex2[0] - vertex3[0];\\n                    double dy23 = vertex2[1] - vertex3[1];\\n                    \\n                    if ((dx12 * dx12 + dy12 * dy12) + (dx13 * dx13 + dy13 * dy13) == (dx23 * dx23 + dy23 * dy23)) {\\n                        \\n                        double corX = (vertex2[0] + vertex3[0]) - vertex1[0];\\n                        double corY = (vertex2[1] + vertex3[1]) - vertex1[1];\\n                        \\n                        double[] pointToCheck = new double[2];\\n                        pointToCheck[0] = corX;\\n                        pointToCheck[1] = corY;\\n                        if (uniquePoints.contains(new Pair(corX, corY)))\\n                            minArea = Math.min(minArea, Math.sqrt(dx12 * dx12 + dy12 * dy12) * Math.sqrt(dx13 * dx13 + dy13 * dy13));\\n                        \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE? 0 : minArea;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        \\n        int numPoints = points.length;\\n        \\n        if (numPoints < 4)\\n            return 0;\\n        \\n        Set<Pair<Double, Double>> uniquePoints = new HashSet<Pair<Double, Double>>();\\n        \\n        for (int i = 0; i < numPoints; i++)\\n            uniquePoints.add(new Pair((double)points[i][0], (double)points[i][1]));\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        for (int i = 0; i < numPoints-2; i++) {\\n            \\n            int[] vertex1 = points[i];\\n            \\n            for (int j = i+1; j < numPoints-1; j++) {\\n                \\n                int[] vertex2 = points[j];\\n                \\n                for (int k = j+1; k < numPoints; k++) {\\n                    \\n                    int[] vertex3 = points[k];\\n                    \\n                    double dx12 = vertex1[0] - vertex2[0];\\n                    double dy12 = vertex1[1] - vertex2[1];\\n                    \\n                    double dx13 = vertex1[0] - vertex3[0];\\n                    double dy13 = vertex1[1] - vertex3[1];\\n                    \\n                    double dx23 = vertex2[0] - vertex3[0];\\n                    double dy23 = vertex2[1] - vertex3[1];\\n                    \\n                    if ((dx12 * dx12 + dy12 * dy12) + (dx13 * dx13 + dy13 * dy13) == (dx23 * dx23 + dy23 * dy23)) {\\n                        \\n                        double corX = (vertex2[0] + vertex3[0]) - vertex1[0];\\n                        double corY = (vertex2[1] + vertex3[1]) - vertex1[1];\\n                        \\n                        double[] pointToCheck = new double[2];\\n                        pointToCheck[0] = corX;\\n                        pointToCheck[1] = corY;\\n                        if (uniquePoints.contains(new Pair(corX, corY)))\\n                            minArea = Math.min(minArea, Math.sqrt(dx12 * dx12 + dy12 * dy12) * Math.sqrt(dx13 * dx13 + dy13 * dy13));\\n                        \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE? 0 : minArea;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744455,
                "title": "c-32ms-88-sorting-hash",
                "content": "Runtime: 32 ms, faster than 88.30% of C++ online submissions for Minimum Area Rectangle II.\\nMemory Usage: 9.2 MB, less than 89.89% of C++ online submissions for Minimum Area Rectangle II.\\n```\\n#define x1 points[i][0]\\n#define y1 points[i][1]\\n#define x2 points[j][0]\\n#define y2 points[j][1]\\n#define x3 points[k][0]\\n#define y3 points[k][1]\\n\\nclass Solution {\\npublic:\\n  double minAreaFreeRect(vector<vector<int>>& points) {\\n    int ans = INT_MAX;\\n    sort(points.begin(),points.end());\\n    set<pair<int,int>>st;\\n    for(auto &p: points) st.insert({p[0], p[1]});\\n    \\n    for(int i = 0; i != points.size() && ans != 1; i++)\\n      for(int j = i+1; j != points.size() && ans != 1; j++)\\n        for(int k = j+1; k != points.size() && ans != 1; k++)\\n          if( (x1-x2)*(x2-x3)+(y1-y2)*(y2-y3) == 0 && st.count({x1+x3-x2, y1+y3-y2}))\\n          ans = min(ans, abs( (y1-y2)*(x3-x2) - (x1-x2)*(y3-y2)));\\n         \\n    return ans == INT_MAX ? 0.0 : double(ans);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define x1 points[i][0]\\n#define y1 points[i][1]\\n#define x2 points[j][0]\\n#define y2 points[j][1]\\n#define x3 points[k][0]\\n#define y3 points[k][1]\\n\\nclass Solution {\\npublic:\\n  double minAreaFreeRect(vector<vector<int>>& points) {\\n    int ans = INT_MAX;\\n    sort(points.begin(),points.end());\\n    set<pair<int,int>>st;\\n    for(auto &p: points) st.insert({p[0], p[1]});\\n    \\n    for(int i = 0; i != points.size() && ans != 1; i++)\\n      for(int j = i+1; j != points.size() && ans != 1; j++)\\n        for(int k = j+1; k != points.size() && ans != 1; k++)\\n          if( (x1-x2)*(x2-x3)+(y1-y2)*(y2-y3) == 0 && st.count({x1+x3-x2, y1+y3-y2}))\\n          ans = min(ans, abs( (y1-y2)*(x3-x2) - (x1-x2)*(y3-y2)));\\n         \\n    return ans == INT_MAX ? 0.0 : double(ans);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717703,
                "title": "c-solution",
                "content": "The solution was inspired by discussions in https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/210786/C%2B%2B-with-picture-find-diagonals-O(n-*-n)\\n```\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        // the basic idea is to find all middle point of any pair of points\\n        // and we will also need to get the distance of every pair of points\\n        // for any pair of line segments, if they can intersect and the intersect point is the middle point for both line segments, and the length of these two line segments are the same, then this pair of line segments are the diagonals of a rectangle\\n        // if two points are (x1, y1) and (x2, y2), for storing the accurate middle point position\\n        // we just do (x1 + x2, y1 + y2) without dividing them by two\\n        // similarly, for computing distance, we won\\'t do sqrt operation\\n        // since we want to use middle point as the key for a map, if we store the middle point as pair, we can\\'t use unordered_map, so we can convert the middle point pair as a unsigned long value.\\n        int size = points.size();\\n        // middlePoints\\'s key is an encoded middle point pair value, value is an unordered_map, with the square of distance as the key and a vector of two end points as value.\\n        unordered_map<unsigned long, unordered_map<int, vector<vector<int>>>> middlePoints;\\n        for (int i = 0; i < size; i++) {\\n            for (int j = i + 1; j < size; j++) {\\n                int middleX_2 = points[i][0] + points[j][0];\\n                int middleY_2 = points[i][1] + points[j][1];\\n                unsigned long encodedKey = (unsigned long)middleX_2 << 32;\\n                encodedKey += middleY_2;\\n                int dSquare = distanceSquare(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                middlePoints[encodedKey][dSquare].push_back({points[i][0], points[i][1], points[j][0], points[j][1]});\\n            }\\n        }\\n        double result = DBL_MAX;\\n        for (auto& middleData : middlePoints) {\\n            for (auto& disData : middleData.second) {\\n                // compute the area of every square, but we can compute the square feet in the end\\n                // so we store the square of the area in the result first\\n                for (int i = 0; i < disData.second.size(); i++) {\\n                    for (int j = i + 1; j < disData.second.size(); j++) {\\n                        double w = distanceSquare(disData.second[i][0], disData.second[i][1], disData.second[j][0], disData.second[j][1]);\\n                        double h = distanceSquare(disData.second[i][0], disData.second[i][1], disData.second[j][2], disData.second[j][3]);\\n                        double area = w * h;\\n                        result = min(result, area);\\n                    }\\n                }\\n            }\\n        }\\n        return result == DBL_MAX ? 0 : sqrt(result);\\n    }\\n    \\n    int distanceSquare(int& x0, int& y0, int& x1, int& y1) {\\n        int dx = x1 - x0;\\n        int dy = y1 - y0;\\n        return dx * dx + dy * dy;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        // the basic idea is to find all middle point of any pair of points\\n        // and we will also need to get the distance of every pair of points\\n        // for any pair of line segments, if they can intersect and the intersect point is the middle point for both line segments, and the length of these two line segments are the same, then this pair of line segments are the diagonals of a rectangle\\n        // if two points are (x1, y1) and (x2, y2), for storing the accurate middle point position\\n        // we just do (x1 + x2, y1 + y2) without dividing them by two\\n        // similarly, for computing distance, we won\\'t do sqrt operation\\n        // since we want to use middle point as the key for a map, if we store the middle point as pair, we can\\'t use unordered_map, so we can convert the middle point pair as a unsigned long value.\\n        int size = points.size();\\n        // middlePoints\\'s key is an encoded middle point pair value, value is an unordered_map, with the square of distance as the key and a vector of two end points as value.\\n        unordered_map<unsigned long, unordered_map<int, vector<vector<int>>>> middlePoints;\\n        for (int i = 0; i < size; i++) {\\n            for (int j = i + 1; j < size; j++) {\\n                int middleX_2 = points[i][0] + points[j][0];\\n                int middleY_2 = points[i][1] + points[j][1];\\n                unsigned long encodedKey = (unsigned long)middleX_2 << 32;\\n                encodedKey += middleY_2;\\n                int dSquare = distanceSquare(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                middlePoints[encodedKey][dSquare].push_back({points[i][0], points[i][1], points[j][0], points[j][1]});\\n            }\\n        }\\n        double result = DBL_MAX;\\n        for (auto& middleData : middlePoints) {\\n            for (auto& disData : middleData.second) {\\n                // compute the area of every square, but we can compute the square feet in the end\\n                // so we store the square of the area in the result first\\n                for (int i = 0; i < disData.second.size(); i++) {\\n                    for (int j = i + 1; j < disData.second.size(); j++) {\\n                        double w = distanceSquare(disData.second[i][0], disData.second[i][1], disData.second[j][0], disData.second[j][1]);\\n                        double h = distanceSquare(disData.second[i][0], disData.second[i][1], disData.second[j][2], disData.second[j][3]);\\n                        double area = w * h;\\n                        result = min(result, area);\\n                    }\\n                }\\n            }\\n        }\\n        return result == DBL_MAX ? 0 : sqrt(result);\\n    }\\n    \\n    int distanceSquare(int& x0, int& y0, int& x1, int& y1) {\\n        int dx = x1 - x0;\\n        int dy = y1 - y0;\\n        return dx * dx + dy * dy;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668962,
                "title": "java-n-2-40ms",
                "content": "```\\n    public double minAreaFreeRect(int[][] points) {\\n        \\n        Map<Double, List<Line>> distanceToLines = new HashMap<>();\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i + 1; j < points.length; j++) {\\n                Line line = new Line(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                \\n                List<Line> lines = distanceToLines.getOrDefault(line.distance, new ArrayList<Line>());\\n                lines.add(line);\\n                distanceToLines.put(line.distance, lines);\\n            }\\n        }\\n        \\n        double result = -1.0;\\n        for(Double distance : distanceToLines.keySet()){\\n            List<Line> lines = distanceToLines.get(distance);\\n            if(lines.size() < 2) {\\n                continue;\\n            }\\n            \\n            for(int i = 0; i < lines.size(); i++) {\\n                for(int j = i + 1; j < lines.size(); j++) {\\n                    double area = getArea(lines.get(i), lines.get(j));\\n                    if(area > 0) {\\n                        result = result < 0.0 ? area : Math.min(result, area);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        result = result < 0.0 ? 0.0 : result;\\n        DecimalFormat format = new DecimalFormat(\"#.#####\");\\n        return Double.valueOf(format.format(result));\\n    }\\n    \\n    private double getArea(Line line1, Line line2){\\n        if(line1.hasSamePoint(line2)) {\\n            return -1.0;\\n        }\\n        \\n        List<Line> lines = new ArrayList<>();\\n        lines.add(line1);\\n        lines.add(line2);\\n        lines.add(new Line(line1.x1, line1.y1, line2.x1, line2.y1));\\n        lines.add(new Line(line1.x2, line1.y2, line2.x2, line2.y2));\\n        lines.add(new Line(line1.x1, line1.y1, line2.x2, line2.y2));\\n        lines.add(new Line(line1.x2, line1.y2, line2.x1, line2.y1));\\n        Collections.sort(lines, (l1, l2) -> l1.distance.compareTo(l2.distance));\\n        \\n        if(!lines.get(0).distance.equals(lines.get(1).distance) \\n           || !lines.get(2).distance.equals(lines.get(3).distance) \\n           || !lines.get(4).distance.equals(lines.get(5).distance)) {\\n            return -1.0;\\n        }\\n        \\n        if(!lines.get(4).sameMidPoint(lines.get(5))) {\\n            return -1.0;\\n        }\\n        \\n        return lines.get(0).distance * lines.get(2).distance;\\n    }\\n    \\n    private static class Line {\\n        int x1;\\n        int y1;\\n        int x2;\\n        int y2;\\n        Double distance;\\n        \\n        public Line(int x1, int y1, int x2, int y2){\\n            this.x1 = x1;\\n            this.y1 = y1;\\n            this.x2 = x2;\\n            this.y2 = y2;\\n            this.distance = Math.pow((Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2)), 0.5);\\n        }\\n        \\n        public boolean hasSamePoint(Line line){\\n            return (x1 == line.x1 && y1 == line.y1)\\n                || (x1 == line.x2 && y1 == line.y2)\\n                || (x2 == line.x1 && y2 == line.y1)\\n                || (x2 == line.x2 && y2 == line.y2);\\n        }\\n        \\n        public boolean sameMidPoint(Line line) {\\n            double[] midPoint1 = getMidPoint();\\n            double[] midPoint2 = line.getMidPoint();\\n            return midPoint1[0] == midPoint2[0] && midPoint1[1] == midPoint2[1];\\n        }\\n        \\n        private double[] getMidPoint() {\\n            return new double[] {(x1 + x2) / 2.0, (y1 + y2) / 2.0};\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public double minAreaFreeRect(int[][] points) {\\n        \\n        Map<Double, List<Line>> distanceToLines = new HashMap<>();\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i + 1; j < points.length; j++) {\\n                Line line = new Line(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                \\n                List<Line> lines = distanceToLines.getOrDefault(line.distance, new ArrayList<Line>());\\n                lines.add(line);\\n                distanceToLines.put(line.distance, lines);\\n            }\\n        }\\n        \\n        double result = -1.0;\\n        for(Double distance : distanceToLines.keySet()){\\n            List<Line> lines = distanceToLines.get(distance);\\n            if(lines.size() < 2) {\\n                continue;\\n            }\\n            \\n            for(int i = 0; i < lines.size(); i++) {\\n                for(int j = i + 1; j < lines.size(); j++) {\\n                    double area = getArea(lines.get(i), lines.get(j));\\n                    if(area > 0) {\\n                        result = result < 0.0 ? area : Math.min(result, area);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        result = result < 0.0 ? 0.0 : result;\\n        DecimalFormat format = new DecimalFormat(\"#.#####\");\\n        return Double.valueOf(format.format(result));\\n    }\\n    \\n    private double getArea(Line line1, Line line2){\\n        if(line1.hasSamePoint(line2)) {\\n            return -1.0;\\n        }\\n        \\n        List<Line> lines = new ArrayList<>();\\n        lines.add(line1);\\n        lines.add(line2);\\n        lines.add(new Line(line1.x1, line1.y1, line2.x1, line2.y1));\\n        lines.add(new Line(line1.x2, line1.y2, line2.x2, line2.y2));\\n        lines.add(new Line(line1.x1, line1.y1, line2.x2, line2.y2));\\n        lines.add(new Line(line1.x2, line1.y2, line2.x1, line2.y1));\\n        Collections.sort(lines, (l1, l2) -> l1.distance.compareTo(l2.distance));\\n        \\n        if(!lines.get(0).distance.equals(lines.get(1).distance) \\n           || !lines.get(2).distance.equals(lines.get(3).distance) \\n           || !lines.get(4).distance.equals(lines.get(5).distance)) {\\n            return -1.0;\\n        }\\n        \\n        if(!lines.get(4).sameMidPoint(lines.get(5))) {\\n            return -1.0;\\n        }\\n        \\n        return lines.get(0).distance * lines.get(2).distance;\\n    }\\n    \\n    private static class Line {\\n        int x1;\\n        int y1;\\n        int x2;\\n        int y2;\\n        Double distance;\\n        \\n        public Line(int x1, int y1, int x2, int y2){\\n            this.x1 = x1;\\n            this.y1 = y1;\\n            this.x2 = x2;\\n            this.y2 = y2;\\n            this.distance = Math.pow((Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2)), 0.5);\\n        }\\n        \\n        public boolean hasSamePoint(Line line){\\n            return (x1 == line.x1 && y1 == line.y1)\\n                || (x1 == line.x2 && y1 == line.y2)\\n                || (x2 == line.x1 && y2 == line.y1)\\n                || (x2 == line.x2 && y2 == line.y2);\\n        }\\n        \\n        public boolean sameMidPoint(Line line) {\\n            double[] midPoint1 = getMidPoint();\\n            double[] midPoint2 = line.getMidPoint();\\n            return midPoint1[0] == midPoint2[0] && midPoint1[1] == midPoint2[1];\\n        }\\n        \\n        private double[] getMidPoint() {\\n            return new double[] {(x1 + x2) / 2.0, (y1 + y2) / 2.0};\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635583,
                "title": "o-n-3-hashmap-ac",
                "content": "```\\nclass Solution {\\npublic:\\n    int distance(long long int x1,long long int y1,long long int x2,long long int y2)\\n    {\\n        return ((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) \\n    {\\n        map<pair<long long int,long long int>,bool>mp;\\n        double mini =0.0;\\n        \\n        // taking all points into map \\n        for(long long int i=0;i<points.size();i++)\\n        {\\n            long long int x = points[i][0];\\n            long long int y = points[i][1];\\n            mp[make_pair(x,y)]=true;\\n        }\\n        \\n        // now i will fix 3 points p1,p2,p3 and try to find the p4\\n\\n        int v = points.size();\\n        // int e = points[0].size();\\n        for(int i=0;i<v;i++)\\n        {\\n            for(int j=0;j<v;j++)\\n            {\\n                for(int k=0;k<v;k++)\\n                {\\n                    long long int x1 = points[i][0];\\n                    long long int y1 = points[i][1];\\n                    \\n                    long long int x2 = points[j][0];\\n                    long long int y2 = points[j][1];\\n                    \\n                    long long int x3 = points[k][0];\\n                    long long int y3 = points[k][1];\\n                    \\n                    pair<long long int,long long int>p1=make_pair(x1,y1); // p1\\n                    pair<long long int,long long int>p2=make_pair(x2,y2); // p2\\n                    pair<long long int,long long int>p3=make_pair(x3,y3); // p3\\n                    \\n                    // slope of p1&p2 p2&p3\\n                    \\n                    // if product is -1 then p2 perpendicular to p1 and p2\\n                    if((y3-y2)*(y2-y1)+(x3-x2)*(x2-x1) == 0)\\n                    {\\n                        // mid point of p1 and p3   \\n                        // long long int mx1 = (x1+x3)/2;\\n                        // long long int my1 = (y1+y3)/2;\\n                        // using mid point of p2 and p4 we know \\n                        // both midpoints lie at same point so we equated them to get point 4\\n                        // we found p4 \\n                        // now we check whether p1 and p2 and p3 form a rectangle part\\n                        // using slope of (p1 , p2 ) & (p2,p3) and product is -1\\n                        long long int x4,y4;\\n                        x4 = x1+x3-x2;\\n                        y4 = y1+y3-y2;\\n                        pair<int,int>p4=make_pair(x4,y4);\\n                        if(mp.find(p4)!=mp.end())\\n                        {\\n                            double d1 = sqrtl(distance(x1,y1,x2,y2));\\n                            double d2 = sqrtl(distance(x2,y2,x3,y3));\\n                            \\n                            double area = (d1*d2);\\n                            \\n                            if(mini == 0 || area<mini)\\n                            {\\n                                if(area!=0)\\n                                {\\n                                    mini = area;\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n       \\n        return (mini);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distance(long long int x1,long long int y1,long long int x2,long long int y2)\\n    {\\n        return ((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) \\n    {\\n        map<pair<long long int,long long int>,bool>mp;\\n        double mini =0.0;\\n        \\n        // taking all points into map \\n        for(long long int i=0;i<points.size();i++)\\n        {\\n            long long int x = points[i][0];\\n            long long int y = points[i][1];\\n            mp[make_pair(x,y)]=true;\\n        }\\n        \\n        // now i will fix 3 points p1,p2,p3 and try to find the p4\\n\\n        int v = points.size();\\n        // int e = points[0].size();\\n        for(int i=0;i<v;i++)\\n        {\\n            for(int j=0;j<v;j++)\\n            {\\n                for(int k=0;k<v;k++)\\n                {\\n                    long long int x1 = points[i][0];\\n                    long long int y1 = points[i][1];\\n                    \\n                    long long int x2 = points[j][0];\\n                    long long int y2 = points[j][1];\\n                    \\n                    long long int x3 = points[k][0];\\n                    long long int y3 = points[k][1];\\n                    \\n                    pair<long long int,long long int>p1=make_pair(x1,y1); // p1\\n                    pair<long long int,long long int>p2=make_pair(x2,y2); // p2\\n                    pair<long long int,long long int>p3=make_pair(x3,y3); // p3\\n                    \\n                    // slope of p1&p2 p2&p3\\n                    \\n                    // if product is -1 then p2 perpendicular to p1 and p2\\n                    if((y3-y2)*(y2-y1)+(x3-x2)*(x2-x1) == 0)\\n                    {\\n                        // mid point of p1 and p3   \\n                        // long long int mx1 = (x1+x3)/2;\\n                        // long long int my1 = (y1+y3)/2;\\n                        // using mid point of p2 and p4 we know \\n                        // both midpoints lie at same point so we equated them to get point 4\\n                        // we found p4 \\n                        // now we check whether p1 and p2 and p3 form a rectangle part\\n                        // using slope of (p1 , p2 ) & (p2,p3) and product is -1\\n                        long long int x4,y4;\\n                        x4 = x1+x3-x2;\\n                        y4 = y1+y3-y2;\\n                        pair<int,int>p4=make_pair(x4,y4);\\n                        if(mp.find(p4)!=mp.end())\\n                        {\\n                            double d1 = sqrtl(distance(x1,y1,x2,y2));\\n                            double d2 = sqrtl(distance(x2,y2,x3,y3));\\n                            \\n                            double area = (d1*d2);\\n                            \\n                            if(mini == 0 || area<mini)\\n                            {\\n                                if(area!=0)\\n                                {\\n                                    mini = area;\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n       \\n        return (mini);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570836,
                "title": "java-get-rectangles-based-on-center-point-diagonal-length-75-faster-22ms",
                "content": "```\\n\\nclass Solution {\\n    private int[][] points;\\n    \\n    public double minAreaFreeRect(int[][] points) {\\n        this.points = points;\\n        \\n        Map<Pair<Double, Double>, Map<Long, List<Pair<Integer, Integer>>>> centerDiagLenLines = new HashMap();\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i + 1; j < points.length; j++) {\\n                int[] point1 = points[i];\\n                int[] point2 = points[j];\\n                \\n                Pair<Double, Double> center = getCenter(point1, point2);\\n                long len = getLen(point1, point2);\\n                \\n                centerDiagLenLines.computeIfAbsent(center, k -> new HashMap<Long, List<Pair<Integer, Integer>>>()).computeIfAbsent(len, k -> new ArrayList<Pair<Integer, Integer>>()).add(new Pair(i,j));\\n            }\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        for(Pair<Double, Double> c: centerDiagLenLines.keySet()) {\\n             Map<Long, List<Pair<Integer, Integer>>> mp = centerDiagLenLines.get(c);\\n            Set<Long> keySet = mp.keySet();\\n            for(Long l: keySet) {\\n                List<Pair<Integer, Integer>> lines = mp.get(l);\\n                if(lines.size() < 2) continue;\\n                \\n                for(int i = 0; i < lines.size(); i++) {\\n                    for(int j = i + 1; j < lines.size(); j++) {\\n                        minArea = Math.min(minArea, getArea(lines.get(i), lines.get(j)));\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE? 0: minArea;\\n    }\\n    \\n    private Pair<Double, Double> getCenter(int[] point1, int[] point2) {\\n        return new Pair((point1[0] + point2[0])/2.0, (point1[1] + point2[1])/2.0);\\n    }\\n    \\n    private long getLen(int[] point1, int[] point2) {\\n        int xDiff = point1[0] - point2[0];\\n        int yDiff = point1[1] - point2[1];\\n        return xDiff*xDiff + yDiff*yDiff;\\n    }\\n    \\n    private double getArea(Pair<Integer, Integer> line1, Pair<Integer, Integer> line2) {\\n        int[] line1Pt1 = points[line1.getKey()];\\n        int[] line1Pt2 = points[line1.getValue()];\\n\\n        int[] line2Pt1 = points[line2.getKey()];\\n        int[] line2Pt2 = points[line2.getValue()];\\n        \\n        double widthPow = Math.pow(line2Pt1[0] - line1Pt1[0], 2) + Math.pow(line2Pt1[1] - line1Pt1[1], 2);\\n        double lenPow = Math.pow(line2Pt1[0] - line1Pt2[0], 2) + Math.pow(line2Pt1[1] - line1Pt2[1], 2);\\n        \\n        return Math.sqrt(widthPow)*Math.sqrt(lenPow);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    private int[][] points;\\n    \\n    public double minAreaFreeRect(int[][] points) {\\n        this.points = points;\\n        \\n        Map<Pair<Double, Double>, Map<Long, List<Pair<Integer, Integer>>>> centerDiagLenLines = new HashMap();\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i + 1; j < points.length; j++) {\\n                int[] point1 = points[i];\\n                int[] point2 = points[j];\\n                \\n                Pair<Double, Double> center = getCenter(point1, point2);\\n                long len = getLen(point1, point2);\\n                \\n                centerDiagLenLines.computeIfAbsent(center, k -> new HashMap<Long, List<Pair<Integer, Integer>>>()).computeIfAbsent(len, k -> new ArrayList<Pair<Integer, Integer>>()).add(new Pair(i,j));\\n            }\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        for(Pair<Double, Double> c: centerDiagLenLines.keySet()) {\\n             Map<Long, List<Pair<Integer, Integer>>> mp = centerDiagLenLines.get(c);\\n            Set<Long> keySet = mp.keySet();\\n            for(Long l: keySet) {\\n                List<Pair<Integer, Integer>> lines = mp.get(l);\\n                if(lines.size() < 2) continue;\\n                \\n                for(int i = 0; i < lines.size(); i++) {\\n                    for(int j = i + 1; j < lines.size(); j++) {\\n                        minArea = Math.min(minArea, getArea(lines.get(i), lines.get(j)));\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE? 0: minArea;\\n    }\\n    \\n    private Pair<Double, Double> getCenter(int[] point1, int[] point2) {\\n        return new Pair((point1[0] + point2[0])/2.0, (point1[1] + point2[1])/2.0);\\n    }\\n    \\n    private long getLen(int[] point1, int[] point2) {\\n        int xDiff = point1[0] - point2[0];\\n        int yDiff = point1[1] - point2[1];\\n        return xDiff*xDiff + yDiff*yDiff;\\n    }\\n    \\n    private double getArea(Pair<Integer, Integer> line1, Pair<Integer, Integer> line2) {\\n        int[] line1Pt1 = points[line1.getKey()];\\n        int[] line1Pt2 = points[line1.getValue()];\\n\\n        int[] line2Pt1 = points[line2.getKey()];\\n        int[] line2Pt2 = points[line2.getValue()];\\n        \\n        double widthPow = Math.pow(line2Pt1[0] - line1Pt1[0], 2) + Math.pow(line2Pt1[1] - line1Pt1[1], 2);\\n        double lenPow = Math.pow(line2Pt1[0] - line1Pt2[0], 2) + Math.pow(line2Pt1[1] - line1Pt2[1], 2);\\n        \\n        return Math.sqrt(widthPow)*Math.sqrt(lenPow);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532210,
                "title": "python-group-all-lines-that-can-make-rectangles-with-each-other-into-a-sorted-list",
                "content": "```python\\nfrom math import sqrt\\nfrom collections import defaultdict as dd\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        \\n        # get length between points p1, p2\\n        length = lambda p1, p2: sqrt((p1[1]-p2[1])**2 + (p1[0]-p2[0])**2)\\n        \\n        # arrange tuple(p1, p2) so that p1 is always closest of two points to origin\\n        arrange = lambda p1, p2: (p1,p2) if length((0,0), p1) < length((0,0), p2) else (p2,p1)\\n        \\n        # get area encompassed by two parallel vectors v1 = tuple(p1, p2), v2 = tuple(p3, p4)\\n        area = lambda v1, v2: length(v1[0], v1[1]) * length(v1[0], v2[0])\\n        \\n        # get slope of points p1, p2\\n        slope = lambda p1, p2: float(\\'inf\\') if p1[0] == p2[0] else (p2[1]-p1[1])/(p2[0]-p1[0])\\n\\n        # get two orthogonal y-intercepts of points p1, p2\\n        orthogonals = lambda p1, p2: (p1[0], p2[0]) if p1[1] == p2[1] else ((p1[1] + p1[0]/slope(p1, p2)), (p2[1] + p2[0] / slope(p1, p2))) \\n        \\n        line_groups = dd(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                p1, p2 = arrange(points[i], points[j])\\n                \\n                # only potential vectors that can make a rectangle with p1->p2 \\n                # all have the same slope and same two orthogonal points\\n                line_groups[(orthogonals(p1,p2), slope(p1, p2))].append((p1,p2))\\n        \\n        min_area = float(\\'inf\\')\\n        for key in line_groups:\\n            \\n            # all vectors in vectors potentially make rectangle with each other\\n            vectors = sorted(line_groups[key])\\n            for i in range(len(vectors)-1):\\n                \\n                # smallest rectangle from vector[i] is always with vector[i+1] or vector[i-1]\\n                v1, v2 = vectors[i], vectors[i+1]\\n                \\n                # update min_area\\n                min_area = min(min_area, area(v1, v2))\\n                \\n        # if min_area was never updated, you never found a rectangle\\n        if min_area == float(\\'inf\\'): return 0\\n        return min_area\\n```\\n\\t\\t\\nFor some reason it works even if you don\\'t sort `vectors`, not sure if it\\'s because they\\'re missing test cases",
                "solutionTags": [],
                "code": "```python\\nfrom math import sqrt\\nfrom collections import defaultdict as dd\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        \\n        # get length between points p1, p2\\n        length = lambda p1, p2: sqrt((p1[1]-p2[1])**2 + (p1[0]-p2[0])**2)\\n        \\n        # arrange tuple(p1, p2) so that p1 is always closest of two points to origin\\n        arrange = lambda p1, p2: (p1,p2) if length((0,0), p1) < length((0,0), p2) else (p2,p1)\\n        \\n        # get area encompassed by two parallel vectors v1 = tuple(p1, p2), v2 = tuple(p3, p4)\\n        area = lambda v1, v2: length(v1[0], v1[1]) * length(v1[0], v2[0])\\n        \\n        # get slope of points p1, p2\\n        slope = lambda p1, p2: float(\\'inf\\') if p1[0] == p2[0] else (p2[1]-p1[1])/(p2[0]-p1[0])\\n\\n        # get two orthogonal y-intercepts of points p1, p2\\n        orthogonals = lambda p1, p2: (p1[0], p2[0]) if p1[1] == p2[1] else ((p1[1] + p1[0]/slope(p1, p2)), (p2[1] + p2[0] / slope(p1, p2))) \\n        \\n        line_groups = dd(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                p1, p2 = arrange(points[i], points[j])\\n                \\n                # only potential vectors that can make a rectangle with p1->p2 \\n                # all have the same slope and same two orthogonal points\\n                line_groups[(orthogonals(p1,p2), slope(p1, p2))].append((p1,p2))\\n        \\n        min_area = float(\\'inf\\')\\n        for key in line_groups:\\n            \\n            # all vectors in vectors potentially make rectangle with each other\\n            vectors = sorted(line_groups[key])\\n            for i in range(len(vectors)-1):\\n                \\n                # smallest rectangle from vector[i] is always with vector[i+1] or vector[i-1]\\n                v1, v2 = vectors[i], vectors[i+1]\\n                \\n                # update min_area\\n                min_area = min(min_area, area(v1, v2))\\n                \\n        # if min_area was never updated, you never found a rectangle\\n        if min_area == float(\\'inf\\'): return 0\\n        return min_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509700,
                "title": "typescript-solution-using-map",
                "content": "```\\ntype Line = {\\n    p1:number[],\\n    p2:number[],\\n    center:number[],\\n    len2:number,\\n    k:number,\\n};\\n\\nfunction minAreaFreeRect(points: number[][]): number {\\n    const lines:Line[] = [];\\n    const map:{[key:string]:Line[]} = {};\\n    \\n    for(let i:number = 0;i<points.length-1;i++){\\n        for(let j:number = i+1; j<points.length;j++){\\n            const [x1,y1] = points[i];\\n            const [x2,y2] = points[j];\\n            const k:number = (y2-y1)/(x2-x1);\\n            const center:number[] = [(x2+x1)/2,(y2+y1)/2];\\n            const len2:number = (y2-y1)**2 + (x2 - x1)**2;\\n            lines.push({\\n                p1:points[i],\\n                p2:points[j],\\n                center,\\n                len2,\\n                k,\\n            });\\n        }\\n    };\\n    \\n    let minArea:number = Infinity;\\n\\n    for(let i:number = 0;i<lines.length;i++){\\n        const line1:Line = lines[i];\\n        const key:string = \"\" + line1.center + line1.len2;\\n        if(map.hasOwnProperty(key)){\\n           for(const line2 of map[key]){\\n                const {p1,p2} = line1;\\n                const {p1:p1Two} = line2;\\n                const dist1:number = Math.sqrt((p1[0]-p1Two[0])**2 + (p1[1] - p1Two[1])**2);\\n                const dist2:number = Math.sqrt((p2[0]-p1Two[0])**2 + (p2[1] - p1Two[1])**2);\\n\\n                const area:number = dist1 * dist2;\\n                minArea = Math.min(minArea,area);\\n           };\\n           map[key].push(line1);\\n        }else{\\n           map[key] = [line1]; \\n        }\\n    };\\n    \\n    return minArea === Infinity ? 0 : minArea\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Line = {\\n    p1:number[],\\n    p2:number[],\\n    center:number[],\\n    len2:number,\\n    k:number,\\n};\\n\\nfunction minAreaFreeRect(points: number[][]): number {\\n    const lines:Line[] = [];\\n    const map:{[key:string]:Line[]} = {};\\n    \\n    for(let i:number = 0;i<points.length-1;i++){\\n        for(let j:number = i+1; j<points.length;j++){\\n            const [x1,y1] = points[i];\\n            const [x2,y2] = points[j];\\n            const k:number = (y2-y1)/(x2-x1);\\n            const center:number[] = [(x2+x1)/2,(y2+y1)/2];\\n            const len2:number = (y2-y1)**2 + (x2 - x1)**2;\\n            lines.push({\\n                p1:points[i],\\n                p2:points[j],\\n                center,\\n                len2,\\n                k,\\n            });\\n        }\\n    };\\n    \\n    let minArea:number = Infinity;\\n\\n    for(let i:number = 0;i<lines.length;i++){\\n        const line1:Line = lines[i];\\n        const key:string = \"\" + line1.center + line1.len2;\\n        if(map.hasOwnProperty(key)){\\n           for(const line2 of map[key]){\\n                const {p1,p2} = line1;\\n                const {p1:p1Two} = line2;\\n                const dist1:number = Math.sqrt((p1[0]-p1Two[0])**2 + (p1[1] - p1Two[1])**2);\\n                const dist2:number = Math.sqrt((p2[0]-p1Two[0])**2 + (p2[1] - p1Two[1])**2);\\n\\n                const area:number = dist1 * dist2;\\n                minArea = Math.min(minArea,area);\\n           };\\n           map[key].push(line1);\\n        }else{\\n           map[key] = [line1]; \\n        }\\n    };\\n    \\n    return minArea === Infinity ? 0 : minArea\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1462117,
                "title": "java-solution-with-simple-math",
                "content": "class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n \\n        /**\\n        Approach:\\n            \\n           \\n            \\n            \\n            Get a mapping for points by diagonal width and by center\\n            Idea : In a rectangle diagonals length is same and both the diagonals have same center\\n            \\n            \\n            Iterate through all  pair of points ( all combination of points N^2)\\n                => Get the length of line \\n                => Get the center of line\\n            \\n            we need to maintain two Map such that \\n            => center to Line Map \\n\\t\\t\\t=> Diagonal Width to Line Map\\n            \\n            Now iterate through each diagonal and cross check the same agains the center\\n            \\n\\t\\t\\tTime : O(N^3)\\n\\t\\t\\tSpaceL O(N^2)\\n            \\n        **/\\n        List<Point> allPoints = new ArrayList<>();\\n        \\n        for(int []aPoint : points) {\\n            allPoints.add(new Point(aPoint[0], aPoint[1]));\\n        }\\n        \\n        \\n        Map<String, List<Line>> clMap = new HashMap<>();\\n        \\n        // diagonal witdth to point \\n        Map<Long, List<Line>> dlMap = new HashMap<>();\\n        \\n        \\n        \\n        \\n        for(int i =0; i < points.length; i++) {\\n            Point aPoint = allPoints.get(i);\\n            for(int j =i + 1; j < points.length; j++ ) {\\n                Point bPoint = allPoints.get(j);\\n                \\n                String center = getCenterPointKey(aPoint, bPoint);\\n                \\n                if(!clMap.containsKey(center)) {\\n                    clMap.put(center, new ArrayList<>());\\n                }\\n                \\n                Line aLine = new Line(aPoint, bPoint);\\n                clMap.get(center).add(aLine);\\n                long diagLen = aLine.len;\\n                \\n                if(!dlMap.containsKey(diagLen)) {\\n                    dlMap.put(diagLen, new ArrayList<>());\\n                }\\n                \\n                dlMap.get(diagLen).add(aLine);\\n            }// end of inner forloop\\n        }// end of outer for loop\\n        \\n        // System.out.println(\"clMap:\" + clMap);\\n        // System.out.println(\"dlMap:\" + dlMap);\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        // now we have mapping of diagonals and centers\\n        //size of map will be N^2\\n        \\n        for(long diagLen : dlMap.keySet()) {\\n            \\n            List<Line> list = dlMap.get(diagLen);\\n            if(list.size() <= 1) {\\n                continue;\\n            }\\n            for(int i =0; i < list.size(); i++) {\\n            \\n                Line aLine = list.get(i);\\n                String center = getCenterPointKey(aLine.a, aLine.b);\\n                List<Line> cLines = clMap.get(center);\\n                if(cLines.size() > 1) {\\n                    // we have more than one lines with same center\\n                    for(Line cLine : cLines) {\\n                        if(cLine.len == diagLen && cLine != aLine) {\\n                            double area = getAreaOfRect(cLine, aLine);\\n                            if(area < minArea) {\\n                                minArea = area;\\n                            }\\n                        }\\n                    }  \\n                }\\n            }\\n            \\n        }// end of outer for loop\\n        return minArea ==Double.MAX_VALUE ? 0 : minArea;\\n    }\\n            \\n    double getAreaOfRect(Line aLine, Line bLine) {\\n        // first check if it is a rectangle\\n        // say aLine is [A,B] and bLine is [C,D]\\n        \\n        Line ad = new Line(aLine.a, bLine.b);\\n        \\n        Line bc = new Line(aLine.b, bLine.a);\\n        if(ad.len != bc.len) {\\n            // opposite sides are not same \\n            // it can not be a rectangle\\n            return Double.MAX_VALUE;\\n        }\\n        \\n        // it is a rectangle because \\n        // 1. diagonals are same\\n        // 2. center is same ( point of intersection of diagonal aLine and bLine)\\n        // 3. and two sides are equal ( ad and bc)\\n        \\n        \\n        Line bd = new Line(aLine.b, bLine.b);\\n        \\n        return  Math.sqrt( bd.len * ad.len);\\n        \\n    }\\n    \\n    String getCenterPointKey(Point aPoint, Point bPoint) {\\n        double cX = (aPoint.x + bPoint.x)/2.0;\\n        double cY = (aPoint.y + bPoint.y)/2.0;\\n                \\n        String center = cX + \"_\" + cY;\\n                return center;\\n    }\\n    \\n    // create a pojo class for easy calculation\\n    \\n    class Line {\\n        Point a;\\n        Point b;\\n        long len;\\n        Line(Point a, Point b) {\\n            this.a = a;\\n            this.b = b;\\n            len = Math.abs(a.x -b.x) * Math.abs(a.x -b.x) + Math.abs(a.y - b.y) * Math.abs(a.y - b.y);\\n            \\n        }\\n\\n        public String toString() {\\n            return \"{\" + a + \",\"+ b +\"}\";\\n        }\\n\\n        \\n    }\\n    \\n    class Point {\\n        long x;\\n        long y;\\n        String key;\\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n            key = x + \".\" + y;\\n        }\\n        \\n        String getKey() {\\n            return key;\\n        }\\n        \\n        public String toString() {\\n            return \"(\" + x + \",\"+ y +\")\";\\n        }\\n        \\n    }\\n    \\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n \\n        /**\\n        Approach:\\n            \\n           \\n            \\n            \\n            Get a mapping for points by diagonal width and by center\\n            Idea : In a rectangle diagonals length is same and both the diagonals have same center\\n            \\n            \\n            Iterate through all  pair of points ( all combination of points N^2)\\n                => Get the length of line \\n                => Get the center of line\\n            \\n            we need to maintain two Map such that \\n            => center to Line Map \\n\\t\\t\\t=> Diagonal Width to Line Map\\n            \\n            Now iterate through each diagonal and cross check the same agains the center\\n            \\n\\t\\t\\tTime : O(N^3)\\n\\t\\t\\tSpaceL O(N^2)\\n            \\n        **/\\n        List<Point> allPoints = new ArrayList<>();\\n        \\n        for(int []aPoint : points) {\\n            allPoints.add(new Point(aPoint[0], aPoint[1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1458812,
                "title": "very-easy-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int dot_prod(vector<int>v1,vector<int> v2)\\n    {\\n        return (v1[0]*v2[0]+v1[1]*v2[1])==0;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans=INT_MAX;\\n        int n=points.size();\\n        set< pair<int,int> >s;\\n        for(int i=0;i<n;i++)\\n            s.insert({points[i][0],points[i][1]});\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                { \\n                    vector<int>v1(2),v2(2);\\n                    \\n                    v1[0]=points[i][0]-points[j][0];\\n                    v1[1]=points[i][1]-points[j][1];\\n                    v2[0]=points[i][0]-points[k][0];\\n                    v2[1]=points[i][1]-points[k][1];\\n                    \\n                   if(dot_prod(v1,v2))//checks two adjacent sides are prependicular or not\\n                    {    \\n                       // mid point co-ordinates from points[j] and points[k] as diagonal \\n                        double midx=(double)(points[k][0]+points[j][0])/2;\\n                        double midy=(double)(points[k][1]+points[j][1])/2;\\n                        \\n                        //fourth co-ordinates\\n                        double fx=2*midx-points[i][0];\\n                        double fy=2*midy-points[i][1];\\n                       \\n                        if(s.find({fx,fy})!=s.end())\\n                        {\\n                            double len=v1[0]*v1[0]+v1[1]*v1[1];\\n                            double wid=v2[0]*v2[0]+v2[1]*v2[1];\\n                            \\n                            double area=sqrt(len)*sqrt(wid);\\n                            ans=min(area,ans);\\n                        }\\n                     }\\n                }\\n            }\\n        }\\n       return ans==INT_MAX ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dot_prod(vector<int>v1,vector<int> v2)\\n    {\\n        return (v1[0]*v2[0]+v1[1]*v2[1])==0;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans=INT_MAX;\\n        int n=points.size();\\n        set< pair<int,int> >s;\\n        for(int i=0;i<n;i++)\\n            s.insert({points[i][0],points[i][1]});\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                { \\n                    vector<int>v1(2),v2(2);\\n                    \\n                    v1[0]=points[i][0]-points[j][0];\\n                    v1[1]=points[i][1]-points[j][1];\\n                    v2[0]=points[i][0]-points[k][0];\\n                    v2[1]=points[i][1]-points[k][1];\\n                    \\n                   if(dot_prod(v1,v2))//checks two adjacent sides are prependicular or not\\n                    {    \\n                       // mid point co-ordinates from points[j] and points[k] as diagonal \\n                        double midx=(double)(points[k][0]+points[j][0])/2;\\n                        double midy=(double)(points[k][1]+points[j][1])/2;\\n                        \\n                        //fourth co-ordinates\\n                        double fx=2*midx-points[i][0];\\n                        double fy=2*midy-points[i][1];\\n                       \\n                        if(s.find({fx,fy})!=s.end())\\n                        {\\n                            double len=v1[0]*v1[0]+v1[1]*v1[1];\\n                            double wid=v2[0]*v2[0]+v2[1]*v2[1];\\n                            \\n                            double area=sqrt(len)*sqrt(wid);\\n                            ans=min(area,ans);\\n                        }\\n                     }\\n                }\\n            }\\n        }\\n       return ans==INT_MAX ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392052,
                "title": "16-ms-c",
                "content": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int n=points.size(), i, j, k;\\n        double ret=0, e=1e-5;\\n        unordered_map<int, unordered_map<int, bool>> s;\\n        for(auto &p:points) s[p[0]][p[1]]=true;\\n        for(i=0; i<n; i++) {\\n            for(j=i+1; j<n; j++) {\\n                auto &p1=points[i], &p2=points[j];\\n                double x=(p1[0]+p2[0])/2.0, y=(p1[1]+p2[1])/2.0;\\n                double d=pow((p1[0]-x), 2)+pow((p1[1]-y), 2);\\n                for(k=j+1; k<n; k++) {\\n                    auto &p3=points[k];\\n                    double t=pow((p3[0]-x), 2)+pow((p3[1]-y), 2);\\n                    if (fabs(t-d)>e) continue;\\n                    double x1=2*x-p3[0], y1=2*y-p3[1];\\n                    int xi1=int(x1), yi1=int(y1);\\n                    if (fabs(xi1-x1)>e || fabs(yi1-y1)>e || s[xi1][yi1]==false) continue;\\n                    double a=sqrt(pow((p1[0]-p3[0]), 2)+pow((p1[1]-p3[1]), 2))*sqrt(pow((p2[0]-p3[0]), 2)+pow((p2[1]-p3[1]), 2));\\n                    if (ret==0 || a<ret) ret=a;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int n=points.size(), i, j, k;\\n        double ret=0, e=1e-5;\\n        unordered_map<int, unordered_map<int, bool>> s;\\n        for(auto &p:points) s[p[0]][p[1]]=true;\\n        for(i=0; i<n; i++) {\\n            for(j=i+1; j<n; j++) {\\n                auto &p1=points[i], &p2=points[j];\\n                double x=(p1[0]+p2[0])/2.0, y=(p1[1]+p2[1])/2.0;\\n                double d=pow((p1[0]-x), 2)+pow((p1[1]-y), 2);\\n                for(k=j+1; k<n; k++) {\\n                    auto &p3=points[k];\\n                    double t=pow((p3[0]-x), 2)+pow((p3[1]-y), 2);\\n                    if (fabs(t-d)>e) continue;\\n                    double x1=2*x-p3[0], y1=2*y-p3[1];\\n                    int xi1=int(x1), yi1=int(y1);\\n                    if (fabs(xi1-x1)>e || fabs(yi1-y1)>e || s[xi1][yi1]==false) continue;\\n                    double a=sqrt(pow((p1[0]-p3[0]), 2)+pow((p1[1]-p3[1]), 2))*sqrt(pow((p2[0]-p3[0]), 2)+pow((p2[1]-p3[1]), 2));\\n                    if (ret==0 || a<ret) ret=a;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347551,
                "title": "java-o-n-3-time-beats-90",
                "content": "1: First record all the positions of points in map, index_x as key and set of index_y as value;\\n2: then set line p1p2 ( p1:[x_1, y_1], p2:[x_2, y_2] ) as diagonal of rectangle;\\n3: then try to find another point( p3:[x_3, y_3] ), so that (x_3 - x_1) * (x_3 - x_2) + (y_3 - y_1) * (y_3 - y_2) = 0, meaning that line p1p3 is vertical to line p2p3;\\n4: if such point p3 was found, then we check if a point p4( [x_4, y_4] ) exist in map, so that x_4 = x_1 + (x_2 - x_3) && y_4 = y_1 + (y_2 - y_3), meaning that line p1p4 is parallel to line p2p3 AND these two lines have equal length;\\n5: if such point p4 was found, calculate the area and update the min area\\n6: return the min area\\n\\nTime: O(N^3)\\n// 3 for loops with one time search from map\\nSpace: O(N)\\n// map to store the coodinates\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        double min = Double.MAX_VALUE;\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int[] point : points) {\\n            if (!map.containsKey(point[0])) {\\n                map.put(point[0], new HashSet<>());\\n            }\\n            map.get(point[0]).add(point[1]);\\n        }\\n        for (int i = 0; i < points.length - 1; i ++) {\\n            for (int j = i + 1; j < points.length; j ++) {\\n                int[] diagno_1 = points[i];\\n                int[] diagno_2 = points[j];\\n                for (int k = 0; k < points.length; k ++) {\\n                    if (k != i && k != j) {\\n                        int[] candid = points[k];\\n                        if (((candid[0] - diagno_1[0]) * (candid[0] - diagno_2[0])) + ((candid[1] - diagno_1[1]) * (candid[1] - diagno_2[1])) == 0) {\\n                            int desired_x = diagno_1[0] + (diagno_2[0] - candid[0]);\\n                            int desired_y = diagno_1[1] + (diagno_2[1] - candid[1]);\\n                            if (map.containsKey(desired_x) && map.get(desired_x).contains(desired_y)) {\\n                                double side_1 = Math.sqrt((int)Math.pow(candid[0] - diagno_1[0], 2) + (int)Math.pow(candid[1] - diagno_1[1], 2));\\n                                double side_2 = Math.sqrt((int)Math.pow(candid[0] - diagno_2[0], 2) + (int)Math.pow(candid[1] - diagno_2[1], 2));\\n                                double area = side_1 * side_2;\\n                                min = Math.min(area, min);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        double min = Double.MAX_VALUE;\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int[] point : points) {\\n            if (!map.containsKey(point[0])) {\\n                map.put(point[0], new HashSet<>());\\n            }\\n            map.get(point[0]).add(point[1]);\\n        }\\n        for (int i = 0; i < points.length - 1; i ++) {\\n            for (int j = i + 1; j < points.length; j ++) {\\n                int[] diagno_1 = points[i];\\n                int[] diagno_2 = points[j];\\n                for (int k = 0; k < points.length; k ++) {\\n                    if (k != i && k != j) {\\n                        int[] candid = points[k];\\n                        if (((candid[0] - diagno_1[0]) * (candid[0] - diagno_2[0])) + ((candid[1] - diagno_1[1]) * (candid[1] - diagno_2[1])) == 0) {\\n                            int desired_x = diagno_1[0] + (diagno_2[0] - candid[0]);\\n                            int desired_y = diagno_1[1] + (diagno_2[1] - candid[1]);\\n                            if (map.containsKey(desired_x) && map.get(desired_x).contains(desired_y)) {\\n                                double side_1 = Math.sqrt((int)Math.pow(candid[0] - diagno_1[0], 2) + (int)Math.pow(candid[1] - diagno_1[1], 2));\\n                                double side_2 = Math.sqrt((int)Math.pow(candid[0] - diagno_2[0], 2) + (int)Math.pow(candid[1] - diagno_2[1], 2));\\n                                double area = side_1 * side_2;\\n                                min = Math.min(area, min);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323394,
                "title": "c-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tdouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\t\\t\\tset<vector<int>>num;\\n\\t\\t\\tfor(const auto &s:points)num.insert(s);\\n\\n\\t\\t\\tdouble res=DBL_MAX;\\n\\n\\t\\t\\tfor(int i=0;i<=points.size()-3;++i){\\n\\t\\t\\t\\tfor(int j=i+1;j<=points.size()-2;++j){\\n\\t\\t\\t\\t\\tfor(int k=j+1;k<points.size();++k){\\n\\t\\t\\t\\t\\t\\tdouble slop_y1=points[j][1]-points[i][1];\\n\\t\\t\\t\\t\\t\\tdouble slop_x1=points[j][0]-points[i][0];\\n\\t\\t\\t\\t\\t\\tdouble slop_y2=points[k][1]-points[i][1];\\n\\t\\t\\t\\t\\t\\tdouble slop_x2=points[k][0]-points[i][0];\\n\\t\\t\\t\\t\\t\\tif(slop_y1*slop_y2+slop_x1*slop_x2!=0)continue;\\n\\n\\t\\t\\t\\t\\t\\tint lasty=slop_y1+points[k][1];\\n\\t\\t\\t\\t\\t\\tint lastx=slop_x1+points[k][0];\\n\\n\\t\\t\\t\\t\\t\\tif(num.count({lastx,lasty})){                        \\n\\t\\t\\t\\t\\t\\t\\tres=min(res,sqrt(pow(slop_y1,2)+pow(slop_x1,2))*sqrt(pow(slop_y2,2)+pow(slop_x2,2)));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res==DBL_MAX?0:res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tdouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\t\\t\\tset<vector<int>>num;\\n\\t\\t\\tfor(const auto &s:points)num.insert(s);\\n\\n\\t\\t\\tdouble res=DBL_MAX;\\n\\n\\t\\t\\tfor(int i=0;i<=points.size()-3;++i){\\n\\t\\t\\t\\tfor(int j=i+1;j<=points.size()-2;++j){\\n\\t\\t\\t\\t\\tfor(int k=j+1;k<points.size();++k){\\n\\t\\t\\t\\t\\t\\tdouble slop_y1=points[j][1]-points[i][1];\\n\\t\\t\\t\\t\\t\\tdouble slop_x1=points[j][0]-points[i][0];\\n\\t\\t\\t\\t\\t\\tdouble slop_y2=points[k][1]-points[i][1];\\n\\t\\t\\t\\t\\t\\tdouble slop_x2=points[k][0]-points[i][0];\\n\\t\\t\\t\\t\\t\\tif(slop_y1*slop_y2+slop_x1*slop_x2!=0)continue;\\n\\n\\t\\t\\t\\t\\t\\tint lasty=slop_y1+points[k][1];\\n\\t\\t\\t\\t\\t\\tint lastx=slop_x1+points[k][0];\\n\\n\\t\\t\\t\\t\\t\\tif(num.count({lastx,lasty}",
                "codeTag": "Java"
            },
            {
                "id": 1214523,
                "title": "abstracted-and-elegant-c-diagonal-solution",
                "content": "Refactored code from @bianhit\\n\\n```\\nclass Point{\\n    public:\\n    double x;\\n    double y;\\n    Point(double x,double y):x(x),y(y){}\\n    double dist(Point* p1){\\n        return sqrt((p1->x-this->x)*(p1->x-this->x)+(p1->y-this->y)*(p1->y-this->y));\\n    }\\n    Point* center(Point* p1){\\n        double xc = (p1->x+this->x)/2.0;\\n        double yc = (p1->y+this->y)/2.0;\\n        return new Point(xc,yc);\\n    }\\n};\\nvoid fillDiagInfo(vector<vector<int>>& points,unordered_map<string,vector<pair<Point*,Point*>>> &diag){\\n    for(int i=0;i<points.size();i++){\\n        for(int j=i+1;j<points.size();j++){\\n            Point* p1 = new Point(points[i][0],points[i][1]);\\n            Point* p2 = new Point(points[j][0],points[j][1]);\\n            string dis = to_string(p1->dist(p2));\\n            Point *cent = p1->center(p2);\\n            string cen = to_string(cent->x)+\",\"+to_string(cent->y);\\n            diag[dis+\"#\"+cen].push_back(make_pair(p1,p2));\\n        }\\n    }\\n}\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string,vector<pair<Point*,Point*>>> diag;\\n        fillDiagInfo(points,diag);\\n        double minArea = INT_MAX;\\n        for(auto it=diag.begin();it!=diag.end();it++){\\n            if(it->second.size()<2) continue;\\n            auto p = it->second;\\n            for(int i=0;i<p.size();i++){\\n                for(int j=i+1;j<p.size();j++){\\n                    Point *p1 = p[i].first;\\n                    Point *p2 = p[j].first;\\n                    Point *p3 = p[i].second;\\n                    minArea = min(minArea,(p1->dist(p2))*(p2->dist(p3)));\\n                }\\n            }\\n        }\\n        return minArea==double(INT_MAX)?0:minArea;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Point{\\n    public:\\n    double x;\\n    double y;\\n    Point(double x,double y):x(x),y(y){}\\n    double dist(Point* p1){\\n        return sqrt((p1->x-this->x)*(p1->x-this->x)+(p1->y-this->y)*(p1->y-this->y));\\n    }\\n    Point* center(Point* p1){\\n        double xc = (p1->x+this->x)/2.0;\\n        double yc = (p1->y+this->y)/2.0;\\n        return new Point(xc,yc);\\n    }\\n};\\nvoid fillDiagInfo(vector<vector<int>>& points,unordered_map<string,vector<pair<Point*,Point*>>> &diag){\\n    for(int i=0;i<points.size();i++){\\n        for(int j=i+1;j<points.size();j++){\\n            Point* p1 = new Point(points[i][0],points[i][1]);\\n            Point* p2 = new Point(points[j][0],points[j][1]);\\n            string dis = to_string(p1->dist(p2));\\n            Point *cent = p1->center(p2);\\n            string cen = to_string(cent->x)+\",\"+to_string(cent->y);\\n            diag[dis+\"#\"+cen].push_back(make_pair(p1,p2));\\n        }\\n    }\\n}\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string,vector<pair<Point*,Point*>>> diag;\\n        fillDiagInfo(points,diag);\\n        double minArea = INT_MAX;\\n        for(auto it=diag.begin();it!=diag.end();it++){\\n            if(it->second.size()<2) continue;\\n            auto p = it->second;\\n            for(int i=0;i<p.size();i++){\\n                for(int j=i+1;j<p.size();j++){\\n                    Point *p1 = p[i].first;\\n                    Point *p2 = p[j].first;\\n                    Point *p3 = p[i].second;\\n                    minArea = min(minArea,(p1->dist(p2))*(p2->dist(p3)));\\n                }\\n            }\\n        }\\n        return minArea==double(INT_MAX)?0:minArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154769,
                "title": "js-o-n-3",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    function isRect(pivot, a, b) {\\n        const [pivotX, pivotY] = pivot\\n        const [aX, aY] = a\\n        const [bX, bY] = b\\n        \\n        const deltaXA = aX - pivotX\\n        const deltaYA = aY - pivotY\\n        const deltaXB = bX - pivotX\\n        const deltaYB = bY - pivotY\\n        \\n        return deltaXA * deltaXB + deltaYA * deltaYB === 0\\n    }\\n    \\n    function toKey(point) {\\n        return point.join(\\'|\\')\\n    }\\n    \\n    \\n    const pointKeySet = points.reduce((set, point) => {\\n        const key = toKey(point)\\n        set.add(key)\\n        return set\\n    }, new Set())\\n    \\n    \\n    let result = Infinity\\n    for (let i = 0, len = points.length;\\n    i < len; i++) {\\n        const pivot = points[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const pointA = points[j]\\n            for (let k = 1 + j; k < len; k++) {\\n                const pointB = points[k]\\n                if (!isRect(pivot, pointA, pointB))\\n                    continue\\n                    \\n                const doubleX = pointA[0] + pointB[0]\\n                const doubleY = pointA[1] + pointB[1]\\n                const seekMeX = doubleX - pivot[0]\\n                const seekMeY = doubleY - pivot[1]\\n                const seekMe = [seekMeX, seekMeY]\\n                const seekMeKey = toKey(seekMe)\\n                \\n                if (pointKeySet.has(seekMeKey)) {\\n                    const [pivotX, pivotY] = pivot\\n                    const [aX, aY] = pointA\\n                    const [bX, bY] = pointB\\n                    \\n                    const deltaXA = aX - pivotX\\n                    const deltaYA = aY - pivotY\\n                    const deltaXB = bX - pivotX\\n                    const deltaYB = bY - pivotY\\n                    const width = Math.hypot(deltaXA, deltaYA)\\n                    const height = Math.hypot(deltaXB, deltaYB)\\n                    \\n                    let outcome = width * height\\n                    result = Math.min(result, outcome)\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    if (result === Infinity)\\n        result = 0\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    function isRect(pivot, a, b) {\\n        const [pivotX, pivotY] = pivot\\n        const [aX, aY] = a\\n        const [bX, bY] = b\\n        \\n        const deltaXA = aX - pivotX\\n        const deltaYA = aY - pivotY\\n        const deltaXB = bX - pivotX\\n        const deltaYB = bY - pivotY\\n        \\n        return deltaXA * deltaXB + deltaYA * deltaYB === 0\\n    }\\n    \\n    function toKey(point) {\\n        return point.join(\\'|\\')\\n    }\\n    \\n    \\n    const pointKeySet = points.reduce((set, point) => {\\n        const key = toKey(point)\\n        set.add(key)\\n        return set\\n    }, new Set())\\n    \\n    \\n    let result = Infinity\\n    for (let i = 0, len = points.length;\\n    i < len; i++) {\\n        const pivot = points[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const pointA = points[j]\\n            for (let k = 1 + j; k < len; k++) {\\n                const pointB = points[k]\\n                if (!isRect(pivot, pointA, pointB))\\n                    continue\\n                    \\n                const doubleX = pointA[0] + pointB[0]\\n                const doubleY = pointA[1] + pointB[1]\\n                const seekMeX = doubleX - pivot[0]\\n                const seekMeY = doubleY - pivot[1]\\n                const seekMe = [seekMeX, seekMeY]\\n                const seekMeKey = toKey(seekMe)\\n                \\n                if (pointKeySet.has(seekMeKey)) {\\n                    const [pivotX, pivotY] = pivot\\n                    const [aX, aY] = pointA\\n                    const [bX, bY] = pointB\\n                    \\n                    const deltaXA = aX - pivotX\\n                    const deltaYA = aY - pivotY\\n                    const deltaXB = bX - pivotX\\n                    const deltaYB = bY - pivotY\\n                    const width = Math.hypot(deltaXA, deltaYA)\\n                    const height = Math.hypot(deltaXB, deltaYB)\\n                    \\n                    let outcome = width * height\\n                    result = Math.min(result, outcome)\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    if (result === Infinity)\\n        result = 0\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1108747,
                "title": "java-solution-83-faster",
                "content": "```\\npublic static class Segment {\\n        int[] a;\\n        int[] b;\\n        int dx;\\n        int dy;\\n        double inclination;\\n        Double length;\\n\\n        public Segment(int[] a, int[] b) {\\n            // sort by x-value\\n            if (a[0] <= b[0]) {\\n                this.a = a;\\n                this.b = b;\\n            } else {\\n                this.a = b;\\n                this.b = a;\\n            }\\n            dx = a[0] - b[0];\\n            dy = a[1] - b[1];\\n            inclination = calculateInclination();\\n        }\\n\\n        public double getLength() {\\n            if (this.length == null)\\n                this.length = Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\\n            return this.length;\\n        }\\n\\n        public double getSizeOfRectangle(Segment another) {\\n            Segment s1 = new Segment(this.a, another.a);\\n            Segment s2 = new Segment(this.b, another.b);\\n\\n            if (isInSameLine(another)) return 0;\\n            if (isOrthogonalWith(s1) && isOrthogonalWith(s2)) {\\n                return this.getLength() * s1.getLength();\\n            }\\n            return 0;\\n\\n        }\\n\\n        // check if two segments are in same line\\n        private boolean isInSameLine(Segment another) {\\n            int dx2 = another.a[0] - a[0];\\n            int dy2 = another.a[1] - a[1];\\n\\n            return dy * dx2 == dy2 * dx;\\n        }\\n\\n        // check if two segments are orthogonal\\n        private boolean isOrthogonalWith(Segment another) {\\n            if ((dx == 0 && another.dy == 0 || dy == 0 && another.dy == 0)) return true;\\n\\n            return dx * another.dx == -dy * another.dy;\\n        }\\n\\n        private double calculateInclination() {\\n            // use Double.MAX_VALUE as infinite value\\n            if (a[0] - b[0] == 0) return Double.MAX_VALUE;\\n\\n            double inclination = ((double) a[1] - b[1]) / ((double) a[0] - b[0]);\\n            // convert -0.0 to +0.0\\n            if (inclination == -0) return 0;\\n\\n            return inclination;\\n        }\\n    }\\n\\n    public static double minAreaFreeRect(int[][] points) {\\n        double min = Double.MAX_VALUE;\\n        int n = points.length;\\n\\n        // K: inclination , V: segment\\n        Map<Double, List<Segment>> map = new HashMap<>();\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                Segment segment = new Segment(points[i], points[j]);\\n                double inclination = segment.inclination;\\n                List<Segment> list = map.get(inclination);\\n                if (list == null) {\\n                    list = new ArrayList<>();\\n\\n                }\\n                list.add(segment);\\n                map.put(inclination, list);\\n            }\\n        }\\n        for (double inclination : map.keySet()) {\\n            List<Segment> list = map.get(inclination);\\n            for (int i = 0; i < list.size() - 1; i++) {\\n                for (int j = i + 1; j < list.size(); j++) {\\n                    double size = list.get(i).getSizeOfRectangle(list.get(j));\\n                    if (size != 0)\\n                        min = Math.min(min, size);\\n                }\\n            }\\n        }\\n        if (min == Double.MAX_VALUE) return 0;\\n        return min;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static class Segment {\\n        int[] a;\\n        int[] b;\\n        int dx;\\n        int dy;\\n        double inclination;\\n        Double length;\\n\\n        public Segment(int[] a, int[] b) {\\n            // sort by x-value\\n            if (a[0] <= b[0]) {\\n                this.a = a;\\n                this.b = b;\\n            } else {\\n                this.a = b;\\n                this.b = a;\\n            }\\n            dx = a[0] - b[0];\\n            dy = a[1] - b[1];\\n            inclination = calculateInclination();\\n        }\\n\\n        public double getLength() {\\n            if (this.length == null)\\n                this.length = Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\\n            return this.length;\\n        }\\n\\n        public double getSizeOfRectangle(Segment another) {\\n            Segment s1 = new Segment(this.a, another.a);\\n            Segment s2 = new Segment(this.b, another.b);\\n\\n            if (isInSameLine(another)) return 0;\\n            if (isOrthogonalWith(s1) && isOrthogonalWith(s2)) {\\n                return this.getLength() * s1.getLength();\\n            }\\n            return 0;\\n\\n        }\\n\\n        // check if two segments are in same line\\n        private boolean isInSameLine(Segment another) {\\n            int dx2 = another.a[0] - a[0];\\n            int dy2 = another.a[1] - a[1];\\n\\n            return dy * dx2 == dy2 * dx;\\n        }\\n\\n        // check if two segments are orthogonal\\n        private boolean isOrthogonalWith(Segment another) {\\n            if ((dx == 0 && another.dy == 0 || dy == 0 && another.dy == 0)) return true;\\n\\n            return dx * another.dx == -dy * another.dy;\\n        }\\n\\n        private double calculateInclination() {\\n            // use Double.MAX_VALUE as infinite value\\n            if (a[0] - b[0] == 0) return Double.MAX_VALUE;\\n\\n            double inclination = ((double) a[1] - b[1]) / ((double) a[0] - b[0]);\\n            // convert -0.0 to +0.0\\n            if (inclination == -0) return 0;\\n\\n            return inclination;\\n        }\\n    }\\n\\n    public static double minAreaFreeRect(int[][] points) {\\n        double min = Double.MAX_VALUE;\\n        int n = points.length;\\n\\n        // K: inclination , V: segment\\n        Map<Double, List<Segment>> map = new HashMap<>();\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                Segment segment = new Segment(points[i], points[j]);\\n                double inclination = segment.inclination;\\n                List<Segment> list = map.get(inclination);\\n                if (list == null) {\\n                    list = new ArrayList<>();\\n\\n                }\\n                list.add(segment);\\n                map.put(inclination, list);\\n            }\\n        }\\n        for (double inclination : map.keySet()) {\\n            List<Segment> list = map.get(inclination);\\n            for (int i = 0; i < list.size() - 1; i++) {\\n                for (int j = i + 1; j < list.size(); j++) {\\n                    double size = list.get(i).getSizeOfRectangle(list.get(j));\\n                    if (size != 0)\\n                        min = Math.min(min, size);\\n                }\\n            }\\n        }\\n        if (min == Double.MAX_VALUE) return 0;\\n        return min;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079513,
                "title": "python-fast-and-easy-solution-better-than-90-online-submissions",
                "content": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        if len(points)<4:\\n            return 0\\n        \\n        def dis(x,y):\\n            return ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5\\n        \\n        diagonal={}\\n        area=float(\"inf\")\\n        for i in range(len(points)):\\n            for j in range(i):\\n                p1=points[i]\\n                p2=points[j]\\n                \\n                cx=(p1[0]+p2[0])/2\\n                cy=(p1[1]+p2[1])/2\\n                le=(p2[0]-p1[0])**2+(p2[1]-p1[1])**2\\n                \\n                if diagonal.get((cx,cy,le))==None:\\n                    diagonal[(cx,cy,le)]=[(p1,p2)]\\n                else:\\n                    diagonal[(cx,cy,le)].append((p1,p2))\\n        for i in diagonal:\\n            if len(diagonal[i])>1:\\n                \\n                for j in range(len(diagonal[i])):\\n                    for k in range(j):\\n                        \\n                        p1=diagonal[i][j][0]\\n                        p2=diagonal[i][j][1]\\n                        p3=diagonal[i][k][0]\\n                        p4=diagonal[i][k][1]\\n                        \\n                        area=min(area,dis(p1,p3)*dis(p2,p3))\\n        return area if area!=float(\"inf\") else 0\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        if len(points)<4:\\n            return 0\\n        \\n        def dis(x,y):\\n            return ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5\\n        \\n        diagonal={}\\n        area=float(\"inf\")\\n        for i in range(len(points)):\\n            for j in range(i):\\n                p1=points[i]\\n                p2=points[j]\\n                \\n                cx=(p1[0]+p2[0])/2\\n                cy=(p1[1]+p2[1])/2\\n                le=(p2[0]-p1[0])**2+(p2[1]-p1[1])**2\\n                \\n                if diagonal.get((cx,cy,le))==None:\\n                    diagonal[(cx,cy,le)]=[(p1,p2)]\\n                else:\\n                    diagonal[(cx,cy,le)].append((p1,p2))\\n        for i in diagonal:\\n            if len(diagonal[i])>1:\\n                \\n                for j in range(len(diagonal[i])):\\n                    for k in range(j):\\n                        \\n                        p1=diagonal[i][j][0]\\n                        p2=diagonal[i][j][1]\\n                        p3=diagonal[i][k][0]\\n                        p4=diagonal[i][k][1]\\n                        \\n                        area=min(area,dis(p1,p3)*dis(p2,p3))\\n        return area if area!=float(\"inf\") else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072798,
                "title": "golang-brute-force-solution",
                "content": "```go\\nfunc minAreaFreeRect(points [][]int) float64 {\\n\\thash := map[[2]int]struct{}{}\\n\\tfor _, p := range points {\\n\\t\\thash[[...]int{p[0], p[1]}] = struct{}{}\\n\\t}\\n\\tminRect := 0.0\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tfor j := i+1; j < len(points); j++ {\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n                if k == i || k == j {\\n                    continue\\n                }\\n\\t\\t\\t\\tif area, exist := getArea(points[i], points[j], points[k], hash); exist {\\n\\t\\t\\t\\t\\tif minRect == 0.0 || minRect > area {\\n\\t\\t\\t\\t\\t\\tminRect = area\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn minRect\\n}\\n\\nfunc getArea(x, y, z []int, hash map[[2]int]struct{}) (float64, bool) {\\n\\ta := (x[1] - y[1]) * (y[1] - z[1])\\n\\tb := (x[0] - y[0]) * (y[0] - z[0])\\n    // a == -b means LineXY is perpendicular to lineYZ\\n\\tif a != -b {\\n\\t\\treturn 0.0, false\\n\\t}\\n    // calculate the other point q\\n\\tqx := x[0] + z[0] - y[0]\\n\\tqy := x[1] + z[1] - y[1]\\n    // q must exist in hash\\n\\tif _, exist := hash[[...]int{qx, qy}]; !exist {\\n\\t\\treturn 0.0, false\\n\\t}\\n\\tarea := math.Hypot(float64(x[1]-y[1]), float64(x[0]-y[0])) * math.Hypot(float64(y[1]-z[1]), float64(y[0]-z[0]))\\n\\treturn area, true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minAreaFreeRect(points [][]int) float64 {\\n\\thash := map[[2]int]struct{}{}\\n\\tfor _, p := range points {\\n\\t\\thash[[...]int{p[0], p[1]}] = struct{}{}\\n\\t}\\n\\tminRect := 0.0\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tfor j := i+1; j < len(points); j++ {\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n                if k == i || k == j {\\n                    continue\\n                }\\n\\t\\t\\t\\tif area, exist := getArea(points[i], points[j], points[k], hash); exist {\\n\\t\\t\\t\\t\\tif minRect == 0.0 || minRect > area {\\n\\t\\t\\t\\t\\t\\tminRect = area\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn minRect\\n}\\n\\nfunc getArea(x, y, z []int, hash map[[2]int]struct{}) (float64, bool) {\\n\\ta := (x[1] - y[1]) * (y[1] - z[1])\\n\\tb := (x[0] - y[0]) * (y[0] - z[0])\\n    // a == -b means LineXY is perpendicular to lineYZ\\n\\tif a != -b {\\n\\t\\treturn 0.0, false\\n\\t}\\n    // calculate the other point q\\n\\tqx := x[0] + z[0] - y[0]\\n\\tqy := x[1] + z[1] - y[1]\\n    // q must exist in hash\\n\\tif _, exist := hash[[...]int{qx, qy}]; !exist {\\n\\t\\treturn 0.0, false\\n\\t}\\n\\tarea := math.Hypot(float64(x[1]-y[1]), float64(x[0]-y[0])) * math.Hypot(float64(y[1]-z[1]), float64(y[0]-z[0]))\\n\\treturn area, true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1005746,
                "title": "c-o-n-3-beating-98-95-runtime-with-detailed-explanation",
                "content": "This is a hard problem. \\n\\nFor any two points   i and  j,  we can draw a line between them and use the line as c of a triangle.  For any third point l1: we record a triangle and the edges have the following relation  a^2+ b^2=c^2. \\n\\nNow the goal is to find the fourth point l2,  it can also form another triangle satisfiying the same relation\\n\\na^2+ b^2=c^2\\n\\n\\nSo we have 4 points with 3 triangles sharing the same edge c, as follows: \\n\\n```\\n   i         l2\\n       b\\n   -------\\na | \\\\      |\\n  |   \\\\  c |  a\\n  |     \\\\  |\\n  l1- ---- j\\n      b\\n```\\n\\nc= dist(i,j)     // we need power 2 one both side, so we calculate dist_square (i,j)\\na = dist(i, l)\\nb= dist(l, j)\\n\\n```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int sz=points.size();\\n\\n        //must short points first by first dimension x. \\n\\t\\t // We find boundary points first, then find middle points in the triangles. \\n        sort (points.begin(), points.end());\\n\\n        // long instead of int to avoid overflow after multiplication\\n        vector<vector<long>> dist_square(sz, vector<long>(sz,0));\\n\\n        // dist_square[i][j] for any two points indexed i and j\\n        for (int i=0; i<sz;i++)\\n            for (int j=i+1; j<sz; j++)\\n            {\\n                long dx= points[i][0]-points[j][0], dy= points[i][1]-points[j][1];\\n                dist_square[i][j]= dx*dx + dy*dy;\\n                dist_square[j][i]=  dist_square[i][j];\\n            }\\n\\n        long min_area_square= numeric_limits<long>::max();\\n\\n        // now find all i,j, then l1, then l2\\n        for (int i=0; i<sz; i++)\\n            for (int j=sz-1; j>i+2; j--) // i0, i1,i2, j, at least four points between [i,j]\\n            {\\n                long c_square= dist_square[i][j];                \\n                if (c_square==0) continue; // skip 0 len c edge\\n\\n                // a^2+ b^2=c^2:   pair of a2 and b2 satisfying the equation\\n                unordered_map <long, vector<pair<long,long>>> c2pairs;\\n\\n                for (int l=i+1; l<j; l++)\\n                {\\n                    long a_square= dist_square[i][l];\\n                    long b_square= dist_square[j][l];\\n\\n                    //optimize: even if we found a square, the area would be too large\\n                    if (a_square*b_square >= min_area_square) continue;\\n                  \\n                    if (a_square+b_square==c_square) // a new l is found\\n                    {\\n                        if (c2pairs.count(c_square)) // prevous l ??\\n                        {\\n                            for (auto p: c2pairs[c_square])\\n                            {\\n                                // matching same a b pairs:\\n                                // it is possible same c_square, but differnt a, b pair\\n                                if ( (p.first==a_square && p.second==b_square) ||\\n                                     (p.first==b_square && p.second==a_square) )\\n                                { \\n                                    min_area_square= min (min_area_square,  a_square*b_square);\\n                                    break; // one square of same a,b,c length is enough\\n                                }\\n                            }\\n                        }\\n                        // store current triangle anyway\\n                        c2pairs[c_square].push_back({a_square, b_square});\\n                    }\\n\\n                }\\n            }\\n\\n        if (min_area_square==numeric_limits<long>::max() )\\n            return 0.0;\\n        return sqrt ((double)min_area_square);\\n\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n   i         l2\\n       b\\n   -------\\na | \\\\      |\\n  |   \\\\  c |  a\\n  |     \\\\  |\\n  l1- ---- j\\n      b\\n```\n```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int sz=points.size();\\n\\n        //must short points first by first dimension x. \\n\\t\\t // We find boundary points first, then find middle points in the triangles. \\n        sort (points.begin(), points.end());\\n\\n        // long instead of int to avoid overflow after multiplication\\n        vector<vector<long>> dist_square(sz, vector<long>(sz,0));\\n\\n        // dist_square[i][j] for any two points indexed i and j\\n        for (int i=0; i<sz;i++)\\n            for (int j=i+1; j<sz; j++)\\n            {\\n                long dx= points[i][0]-points[j][0], dy= points[i][1]-points[j][1];\\n                dist_square[i][j]= dx*dx + dy*dy;\\n                dist_square[j][i]=  dist_square[i][j];\\n            }\\n\\n        long min_area_square= numeric_limits<long>::max();\\n\\n        // now find all i,j, then l1, then l2\\n        for (int i=0; i<sz; i++)\\n            for (int j=sz-1; j>i+2; j--) // i0, i1,i2, j, at least four points between [i,j]\\n            {\\n                long c_square= dist_square[i][j];                \\n                if (c_square==0) continue; // skip 0 len c edge\\n\\n                // a^2+ b^2=c^2:   pair of a2 and b2 satisfying the equation\\n                unordered_map <long, vector<pair<long,long>>> c2pairs;\\n\\n                for (int l=i+1; l<j; l++)\\n                {\\n                    long a_square= dist_square[i][l];\\n                    long b_square= dist_square[j][l];\\n\\n                    //optimize: even if we found a square, the area would be too large\\n                    if (a_square*b_square >= min_area_square) continue;\\n                  \\n                    if (a_square+b_square==c_square) // a new l is found\\n                    {\\n                        if (c2pairs.count(c_square)) // prevous l ??\\n                        {\\n                            for (auto p: c2pairs[c_square])\\n                            {\\n                                // matching same a b pairs:\\n                                // it is possible same c_square, but differnt a, b pair\\n                                if ( (p.first==a_square && p.second==b_square) ||\\n                                     (p.first==b_square && p.second==a_square) )\\n                                { \\n                                    min_area_square= min (min_area_square,  a_square*b_square);\\n                                    break; // one square of same a,b,c length is enough\\n                                }\\n                            }\\n                        }\\n                        // store current triangle anyway\\n                        c2pairs[c_square].push_back({a_square, b_square});\\n                    }\\n\\n                }\\n            }\\n\\n        if (min_area_square==numeric_limits<long>::max() )\\n            return 0.0;\\n        return sqrt ((double)min_area_square);\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003541,
                "title": "c-using-hashmap-with-distance-plus-center-as-key-under-readable-oo-design",
                "content": "```\\nstruct Point {\\n    Point(int x, int y) : x{x}, y{y} {}\\n    Point(const vector<int> &p) : Point(p[0], p[1]) {}\\n    \\n    int dis() {\\n        return x*x+y*y;\\n    }\\n    \\n    uint hash() {\\n        return (uint)x<<16|y;\\n    }\\n    \\n    const int x, y;\\n};\\n\\nstruct Line {\\n    Line(const Point &p1, const Point &p2) : p1{p1}, p2{p2} {}\\n    Line(const vector<int> &p1, const vector<int> &p2) : Line(Point(p1), Point(p2)) {}\\n    \\n    uint64_t hash() {\\n        Point cent(p1.x+p2.x, p1.y+p2.y);\\n        Point vec(p2.x-p1.x, p2.y-p1.y);\\n        return (uint64_t)cent.hash()<<32|vec.dis();\\n    }\\n    \\n    const Point p1, p2;\\n};\\n\\n\\nclass Solution {\\n    int area(const Point& p1, const Point& p2, const Point& p3) {\\n        return abs(p1.x*(p2.y-p3.y)+p2.x*(p3.y-p1.y)+p3.x*(p1.y-p2.y));\\n    }\\n    \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& ps) {\\n        unordered_map<uint64_t, vector<Line>> table;\\n        int ret = INT_MAX;\\n        for(int i=0;i<ps.size();i++)\\n            for(int j=i+1;j<ps.size();j++) {\\n                auto l = Line(ps[i], ps[j]);\\n                table[l.hash()].emplace_back(l);\\n            }\\n        for(auto it:table) {\\n            auto &lines = it.second;\\n            for(int i=0;i<lines.size();i++)\\n                for(int j=i+1;j<lines.size();j++)\\n                    if(auto a = area(lines[i].p1, lines[i].p2, lines[j].p1))\\n                        ret = min(ret, a);\\n        }\\n        return ret == INT_MAX ? 0 : ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Point {\\n    Point(int x, int y) : x{x}, y{y} {}\\n    Point(const vector<int> &p) : Point(p[0], p[1]) {}\\n    \\n    int dis() {\\n        return x*x+y*y;\\n    }\\n    \\n    uint hash() {\\n        return (uint)x<<16|y;\\n    }\\n    \\n    const int x, y;\\n};\\n\\nstruct Line {\\n    Line(const Point &p1, const Point &p2) : p1{p1}, p2{p2} {}\\n    Line(const vector<int> &p1, const vector<int> &p2) : Line(Point(p1), Point(p2)) {}\\n    \\n    uint64_t hash() {\\n        Point cent(p1.x+p2.x, p1.y+p2.y);\\n        Point vec(p2.x-p1.x, p2.y-p1.y);\\n        return (uint64_t)cent.hash()<<32|vec.dis();\\n    }\\n    \\n    const Point p1, p2;\\n};\\n\\n\\nclass Solution {\\n    int area(const Point& p1, const Point& p2, const Point& p3) {\\n        return abs(p1.x*(p2.y-p3.y)+p2.x*(p3.y-p1.y)+p3.x*(p1.y-p2.y));\\n    }\\n    \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& ps) {\\n        unordered_map<uint64_t, vector<Line>> table;\\n        int ret = INT_MAX;\\n        for(int i=0;i<ps.size();i++)\\n            for(int j=i+1;j<ps.size();j++) {\\n                auto l = Line(ps[i], ps[j]);\\n                table[l.hash()].emplace_back(l);\\n            }\\n        for(auto it:table) {\\n            auto &lines = it.second;\\n            for(int i=0;i<lines.size();i++)\\n                for(int j=i+1;j<lines.size();j++)\\n                    if(auto a = area(lines[i].p1, lines[i].p2, lines[j].p1))\\n                        ret = min(ret, a);\\n        }\\n        return ret == INT_MAX ? 0 : ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980904,
                "title": "checking-cyles",
                "content": "I think that this question can also be solved by checking if any cycle is formed between coordinates and storing the area in a set\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 979868,
                "title": "c-simple-solution-hashset",
                "content": "```\\nclass Solution {\\npublic:\\n    struct SimpleHash {\\n    size_t operator()(const std::pair<int, int>& p) const {\\n        return p.first ^ p.second;\\n    }\\n};\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        //check form parallelogram and then check if the angle is 90 degree\\n        unordered_set<pair<int, int>, SimpleHash> allPoints;\\n        for (auto x: points) {\\n            allPoints.insert(make_pair(x[0], x[1]));\\n        }\\n        double ans = DBL_MAX;\\n        for (int i = 0; i < points.size(); i++) {\\n            pair<int, int> p1 = make_pair(points[i][0], points[i][1]);\\n            for (int j = 0; j < points.size(); j++) {\\n                if (i == j) continue;\\n                pair<int, int> p2 = make_pair(points[j][0], points[j][1]);\\n                for (int k = 0; k < points.size(); k++) {\\n                    if (k == i || k == j) continue;\\n                    pair<int, int> p3 = make_pair(points[k][0], points[k][1]);\\n                    pair<int, int> p4 = make_pair((p2.first+p3.first-p1.first), (p2.second+p3.second-p1.second));\\n                    //if can form parallelogram\\n                    if (allPoints.count(p4)) {\\n                        //dot product of (p2 - p1) and (p3 - p1)\\n                        int dot = (p2.first - p1.first) * (p3.first - p1.first) + (p2.second - p1.second) * (p3.second - p1.second);\\n                        if (dot == 0) {\\n                            double a = pow(p2.first - p1.first, 2) + pow(p2.second - p1.second, 2);\\n                            double b = pow(p3.first - p1.first, 2) + pow(p3.second - p1.second, 2);\\n                            double area = sqrt(a * b);\\n                            ans = min(ans, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans < DBL_MAX ? ans : 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct SimpleHash {\\n    size_t operator()(const std::pair<int, int>& p) const {\\n        return p.first ^ p.second;\\n    }\\n};\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        //check form parallelogram and then check if the angle is 90 degree\\n        unordered_set<pair<int, int>, SimpleHash> allPoints;\\n        for (auto x: points) {\\n            allPoints.insert(make_pair(x[0], x[1]));\\n        }\\n        double ans = DBL_MAX;\\n        for (int i = 0; i < points.size(); i++) {\\n            pair<int, int> p1 = make_pair(points[i][0], points[i][1]);\\n            for (int j = 0; j < points.size(); j++) {\\n                if (i == j) continue;\\n                pair<int, int> p2 = make_pair(points[j][0], points[j][1]);\\n                for (int k = 0; k < points.size(); k++) {\\n                    if (k == i || k == j) continue;\\n                    pair<int, int> p3 = make_pair(points[k][0], points[k][1]);\\n                    pair<int, int> p4 = make_pair((p2.first+p3.first-p1.first), (p2.second+p3.second-p1.second));\\n                    //if can form parallelogram\\n                    if (allPoints.count(p4)) {\\n                        //dot product of (p2 - p1) and (p3 - p1)\\n                        int dot = (p2.first - p1.first) * (p3.first - p1.first) + (p2.second - p1.second) * (p3.second - p1.second);\\n                        if (dot == 0) {\\n                            double a = pow(p2.first - p1.first, 2) + pow(p2.second - p1.second, 2);\\n                            double b = pow(p3.first - p1.first, 2) + pow(p3.second - p1.second, 2);\\n                            double area = sqrt(a * b);\\n                            ans = min(ans, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans < DBL_MAX ? ans : 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960164,
                "title": "python3-intersecting-diagonals-math",
                "content": "```\\nfrom typing import List, Tuple\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        # key: for rect, diagonals from corners will:\\n        # 1) intersect at common midpoint\\n        # 2) and be of equal length\\n\\n        # going through and comparing two points:\\n        # calculate distance between points (hello math)\\n        # calculate midpoint between points (hello math)\\n        # store in dict {(mid, dist) : [(pairs)]}\\n\\n        # then go through dict keys with len > 1\\n        # compare points against each other,\\n        # calc distance between pair1 point1 and pair2 both points\\n        # product of these distances == area\\n        # track for min area\\n        # O(N^2) time and O(N) space\\n\\n        def get_dist(p1, p2) -> float:\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            return (abs(x1-x2)**2 + abs(y1-y2)**2)**0.5\\n\\n        def get_mid(p1, p2) -> Tuple[float, float]:\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            return ((x1+x2)/2, (y1+y2)/2)\\n\\n        d = defaultdict(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                mid = get_mid(points[i], points[j])\\n                dist = get_dist(points[i], points[j])\\n                d[(mid, dist)].append( (points[i], points[j]) )\\n\\n        res = float(\"inf\")\\n        for k in d:\\n            if len(d[k]) > 1:\\n                for i in range(len(d[k])):\\n                    for j in range(i+1, len(d[k])):\\n                        p1, p2 = d[k][i]\\n                        p3, p4 = d[k][j]\\n\\n                        side1 = get_dist(p1,p3)\\n                        side2 = get_dist(p1,p4)\\n                        res = min(res, side1 * side2)\\n\\n        return res if res < float(\"inf\") else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List, Tuple\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        # key: for rect, diagonals from corners will:\\n        # 1) intersect at common midpoint\\n        # 2) and be of equal length\\n\\n        # going through and comparing two points:\\n        # calculate distance between points (hello math)\\n        # calculate midpoint between points (hello math)\\n        # store in dict {(mid, dist) : [(pairs)]}\\n\\n        # then go through dict keys with len > 1\\n        # compare points against each other,\\n        # calc distance between pair1 point1 and pair2 both points\\n        # product of these distances == area\\n        # track for min area\\n        # O(N^2) time and O(N) space\\n\\n        def get_dist(p1, p2) -> float:\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            return (abs(x1-x2)**2 + abs(y1-y2)**2)**0.5\\n\\n        def get_mid(p1, p2) -> Tuple[float, float]:\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            return ((x1+x2)/2, (y1+y2)/2)\\n\\n        d = defaultdict(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                mid = get_mid(points[i], points[j])\\n                dist = get_dist(points[i], points[j])\\n                d[(mid, dist)].append( (points[i], points[j]) )\\n\\n        res = float(\"inf\")\\n        for k in d:\\n            if len(d[k]) > 1:\\n                for i in range(len(d[k])):\\n                    for j in range(i+1, len(d[k])):\\n                        p1, p2 = d[k][i]\\n                        p3, p4 = d[k][j]\\n\\n                        side1 = get_dist(p1,p3)\\n                        side2 = get_dist(p1,p4)\\n                        res = min(res, side1 * side2)\\n\\n        return res if res < float(\"inf\") else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958965,
                "title": "python-o-n-2-solution-98-17",
                "content": "- Find each pair of nodes, calculate `(x1+x2), (y1+y2)` as key and add this `point pair` to dictionary `groups`.\\n- Eventually in each entry in this dictionary, we have a list of `point pairs`, and any pair of `point pairs` can form a parallelogram.\\n- Then we check if the parallelogram is rectangle by checking if orthogonal.\\n- I thinks this is `O(n^2)` because:\\n\\t- First looping over the points is definitely `O(n^2)`\\n\\t- Then for the looping over `groups` part, worst case would be every `point pair` falls into the same group (i.e. any pair of point pairs can form a parallelogram), in which case the list length would be `n/2`. So looping over pairs of `point pairs` is still `O(n^2)`\\n\\t\\t- The reason it\\'s `n/2` is because if all points are inside the same `group`, any point can only appear in one `point pair` (since the group key `(x1+x2), (y1+y2)` is fixed)\\n\\t\\t- **UPDATE**: ok... now I think about it the worst case should be every 2 `point pairs` fall into different groups.. Could somebody help me explain what\\'s the correct way to calculate the overall complexity\\n\\n\\n---\\n\\n   ```\\n   class Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n\\t\\n        if not points:\\n            return 0\\n     \\n        groups = dict()\\n        minarea = float(\\'inf\\')\\n        area = lambda x1,y1,x2,y2,x3,y3: (((x1-x3)**2 + (y1-y3)**2) * ((x2-x3)**2 + (y2-y3)**2)) ** (1/2)\\n        orthogonal = lambda x1,y1,x2,y2,x3,y3: (x1-x3) * (x2-x3) + (y1-y3) * (y2-y3) == 0\\n     \\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                (x1, y1), (x2, y2) = points[i], points[j]\\n                xsum, ysum = x1 + x2, y1 + y2\\n                if (xsum, ysum) not in groups:\\n                    groups[(xsum, ysum)] = []\\n                groups[(xsum, ysum)].append((x1, y1, x2, y2))\\n     \\n        for group in groups.values():\\n            for i in range(len(group)):\\n                for j in range(i+1, len(group)):\\n                    (x1, y1, x2, y2), (x3, y3, _, _) = group[i], group[j]\\n                    if orthogonal(x1,y1,x2,y2,x3,y3):\\n                        minarea = min(minarea, area(x1,y1,x2,y2,x3,y3))\\n\\n        return minarea if minarea != float(\\'inf\\') else 0",
                "solutionTags": [],
                "code": "- Find each pair of nodes, calculate `(x1+x2), (y1+y2)` as key and add this `point pair` to dictionary `groups`.\\n- Eventually in each entry in this dictionary, we have a list of `point pairs`, and any pair of `point pairs` can form a parallelogram.\\n- Then we check if the parallelogram is rectangle by checking if orthogonal.\\n- I thinks this is `O(n^2)` because:\\n\\t- First looping over the points is definitely `O(n^2)`\\n\\t- Then for the looping over `groups` part, worst case would be every `point pair` falls into the same group (i.e. any pair of point pairs can form a parallelogram), in which case the list length would be `n/2`. So looping over pairs of `point pairs` is still `O(n^2)`\\n\\t\\t- The reason it\\'s `n/2` is because if all points are inside the same `group`, any point can only appear in one `point pair` (since the group key `(x1+x2), (y1+y2)` is fixed)\\n\\t\\t- **UPDATE**: ok... now I think about it the worst case should be every 2 `point pairs` fall into different groups.. Could somebody help me explain what\\'s the correct way to calculate the overall complexity\\n\\n\\n---\\n\\n   ```\\n   class Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n\\t\\n        if not points:\\n            return 0\\n     \\n        groups = dict()\\n        minarea = float(\\'inf\\')\\n        area = lambda x1,y1,x2,y2,x3,y3: (((x1-x3)**2 + (y1-y3)**2) * ((x2-x3)**2 + (y2-y3)**2)) ** (1/2)\\n        orthogonal = lambda x1,y1,x2,y2,x3,y3: (x1-x3) * (x2-x3) + (y1-y3) * (y2-y3) == 0\\n     \\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                (x1, y1), (x2, y2) = points[i], points[j]\\n                xsum, ysum = x1 + x2, y1 + y2\\n                if (xsum, ysum) not in groups:\\n                    groups[(xsum, ysum)] = []\\n                groups[(xsum, ysum)].append((x1, y1, x2, y2))\\n     \\n        for group in groups.values():\\n            for i in range(len(group)):\\n                for j in range(i+1, len(group)):\\n                    (x1, y1, x2, y2), (x3, y3, _, _) = group[i], group[j]\\n                    if orthogonal(x1,y1,x2,y2,x3,y3):\\n                        minarea = min(minarea, area(x1,y1,x2,y2,x3,y3))\\n\\n        return minarea if minarea != float(\\'inf\\') else 0",
                "codeTag": "Java"
            },
            {
                "id": 948439,
                "title": "swift-o-n-3-solution-using-math-vectors",
                "content": "<img src=\"https://assets.leetcode.com/users/images/b93e8a04-87c2-4fe9-bce6-1e09e54fd8f4_1606296386.2932158.png\" height=200 />\\n\\n```swift\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        guard points.count >= 4 else { return 0 }\\n        let vectors = points.map { Vector([0, 0], $0) }\\n        var set = Set(vectors), res = 0 as Double\\n        for OA in vectors { for OB in vectors where OA != OB { for OC in vectors where OC != OA && OC != OB {\\n            let AB = OB - OA // vector AB = A->B\\n            let AC = OC - OA // vector AC = A->C\\n            if AB * AC != 0 { continue } // AB \\u22A5 AC\\n            let OD = OB + AC // OD = OB + vector AC, so that ABCD forms a rect\\n            if !set.contains(OD) { continue }\\n            let s = AB.length * AC.length  // |AB|*|AC|\\n            res = (res == 0) ? s : min(res, s)\\n        }}}\\n        return res\\n    }\\n\\n    private struct Vector: Hashable {\\n        let x: Int, y: Int\\n        init(_ from: [Int], _ to: [Int]) {\\n            x = to[0] - from[0]\\n            y = to[1] - from[1]\\n        }\\n        static func +(lhs: Vector, rhs: Vector) -> Vector {\\n            return Vector([0, 0], [lhs.x + rhs.x, lhs.y + rhs.y])\\n        }\\n        static func -(lhs: Vector, rhs: Vector) -> Vector {\\n            return Vector([0, 0], [lhs.x - rhs.x, lhs.y - rhs.y])\\n        }\\n        static func *(lhs: Vector, rhs: Vector) -> Int {\\n            return lhs.x * rhs.x + lhs.y * rhs.y\\n        }\\n        var length: Double {\\n            return sqrt(Double(x * x + y * y))\\n        }\\n    }\\n}\\n```\\n\\nOr if you don\\'t want to define a struct:\\n```swift\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        guard points.count >= 4 else { return 0 }\\n        var set = Set(points), res = 0 as Double\\n        for p1 in points { for p2 in points where p1 != p2 { for p3 in points where p3 != p1 && p3 != p2 {\\n            let v1 = [p2[0] - p1[0], p2[1] - p1[1]] // v1 = p1->p2\\n            let v2 = [p3[0] - p1[0], p3[1] - p1[1]] // v2 = p1->p3\\n            if v1[0] * v2[0] + v1[1] * v2[1] != 0 { continue } // v1 & v2: perpendicular\\n            let p4 = [p2[0] + v2[0], p2[1] + v2[1]] // p2 + v2\\n            if !set.contains(p4) { continue }\\n            let s = sqrt(\\n                Double(v1[0] * v1[0] + v1[1] * v1[1]) \\n                * Double(v2[0] * v2[0] + v2[1] * v2[1])\\n            )  // |v1|*|v2|\\n            if res == 0 {\\n                res = s\\n            } else {\\n                res = min(res, s)\\n            }\\n        }}}\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        guard points.count >= 4 else { return 0 }\\n        let vectors = points.map { Vector([0, 0], $0) }\\n        var set = Set(vectors), res = 0 as Double\\n        for OA in vectors { for OB in vectors where OA != OB { for OC in vectors where OC != OA && OC != OB {\\n            let AB = OB - OA // vector AB = A->B\\n            let AC = OC - OA // vector AC = A->C\\n            if AB * AC != 0 { continue } // AB \\u22A5 AC\\n            let OD = OB + AC // OD = OB + vector AC, so that ABCD forms a rect\\n            if !set.contains(OD) { continue }\\n            let s = AB.length * AC.length  // |AB|*|AC|\\n            res = (res == 0) ? s : min(res, s)\\n        }}}\\n        return res\\n    }\\n\\n    private struct Vector: Hashable {\\n        let x: Int, y: Int\\n        init(_ from: [Int], _ to: [Int]) {\\n            x = to[0] - from[0]\\n            y = to[1] - from[1]\\n        }\\n        static func +(lhs: Vector, rhs: Vector) -> Vector {\\n            return Vector([0, 0], [lhs.x + rhs.x, lhs.y + rhs.y])\\n        }\\n        static func -(lhs: Vector, rhs: Vector) -> Vector {\\n            return Vector([0, 0], [lhs.x - rhs.x, lhs.y - rhs.y])\\n        }\\n        static func *(lhs: Vector, rhs: Vector) -> Int {\\n            return lhs.x * rhs.x + lhs.y * rhs.y\\n        }\\n        var length: Double {\\n            return sqrt(Double(x * x + y * y))\\n        }\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        guard points.count >= 4 else { return 0 }\\n        var set = Set(points), res = 0 as Double\\n        for p1 in points { for p2 in points where p1 != p2 { for p3 in points where p3 != p1 && p3 != p2 {\\n            let v1 = [p2[0] - p1[0], p2[1] - p1[1]] // v1 = p1->p2\\n            let v2 = [p3[0] - p1[0], p3[1] - p1[1]] // v2 = p1->p3\\n            if v1[0] * v2[0] + v1[1] * v2[1] != 0 { continue } // v1 & v2: perpendicular\\n            let p4 = [p2[0] + v2[0], p2[1] + v2[1]] // p2 + v2\\n            if !set.contains(p4) { continue }\\n            let s = sqrt(\\n                Double(v1[0] * v1[0] + v1[1] * v1[1]) \\n                * Double(v2[0] * v2[0] + v2[1] * v2[1])\\n            )  // |v1|*|v2|\\n            if res == 0 {\\n                res = s\\n            } else {\\n                res = min(res, s)\\n            }\\n        }}}\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903402,
                "title": "simple-solution-to-find-diagonal",
                "content": "```python\\nfrom collections import defaultdict\\nfrom math import sqrt\\n\\ndef distance(p1, p2):\\n    return sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        mem = defaultdict(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                p1, p2 = points[i], points[j]\\n                d = distance(p1, p2)\\n                mid = (p2[0] + p1[0]) / 2, (p2[1] + p1[1]) / 2\\n                mem[mid, d].append((p1, p2))\\n        min_area = float(\\'inf\\')\\n        for pairs in mem.values():\\n            for i in range(len(pairs)):\\n                for j in range(i+1, len(pairs)):\\n                    (p1, p2), (p3, p4) = pairs[i], pairs[j]\\n                    new_area = distance(p1, p3) * distance(p1, p4)\\n                    min_area = min(min_area, new_area)\\n        return min_area if min_area < float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict\\nfrom math import sqrt\\n\\ndef distance(p1, p2):\\n    return sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        mem = defaultdict(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                p1, p2 = points[i], points[j]\\n                d = distance(p1, p2)\\n                mid = (p2[0] + p1[0]) / 2, (p2[1] + p1[1]) / 2\\n                mem[mid, d].append((p1, p2))\\n        min_area = float(\\'inf\\')\\n        for pairs in mem.values():\\n            for i in range(len(pairs)):\\n                for j in range(i+1, len(pairs)):\\n                    (p1, p2), (p3, p4) = pairs[i], pairs[j]\\n                    new_area = distance(p1, p3) * distance(p1, p4)\\n                    min_area = min(min_area, new_area)\\n        return min_area if min_area < float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869489,
                "title": "c-simple-intuitive-code-with-explanation",
                "content": "```\\n// Bizzare interview question\\n// Main Idea: All points in a rectagle are equidistant from the diagonal interesection\\n// Find the center between each pair of points and use that as the key (diagonal interection as key i.e. dist + p2x-p1x/2, p2y-p1y/2)\\n// Any 2 points from all points which are indexed by same key can form a rectangle.\\n// Itereate thru all pair of points in each group of points indexed by the key\\n// and get the min aray\\npublic class Solution {\\n    public double MinAreaFreeRect(int[][] points) {\\n        var row = points.Length;\\n        var col = row > 0 ? points[0].Length : 0;\\n        \\n        if(row == 0 || col == 0)\\n            return 0;\\n        \\n        var pointsGroup = new Dictionary<string, List<(int[] Point1, int[] Point2)>>();\\n        for(var i = 0; i < row; i++)\\n        {\\n            for(var j = i + 1; j < row; j++)\\n            {\\n                var p1 = points[i];\\n                var p2 = points[j];\\n                \\n                var dist = (p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]);\\n                var centerX = (p2[0] + p1[0]) / 2.0;\\n                var centerY = (p2[1] + p1[1]) / 2.0;\\n                \\n                var key = dist + \":\" + centerX + \"-\" + centerY;\\n                if(!pointsGroup.ContainsKey(key))\\n                {\\n                    pointsGroup.Add(key, new List<(int[], int[])>(){(p2, p1)});\\n                }\\n                else\\n                {\\n                    pointsGroup[key].Add((p2, p1));\\n                }\\n            }\\n        }\\n        \\n        var minResult = double.MaxValue;\\n        // A group contains all pairs of points with the same distance and middle point, any two of these pairs form a rectangle with each other.\\n        // We iterate through all rectangles that can be formed with the given points, we compute the area of each rectangle and maintain the min area.\\n        \\n        foreach(var allPoints in pointsGroup.Values)\\n        {\\n            for(var i = 0; i < allPoints.Count; i++)\\n            {\\n                for(var j = i + 1; j < allPoints.Count; j++)\\n                {\\n                    var p1 = allPoints[i].Point1;\\n                    var p2 = allPoints[i].Point2;\\n                    var p3 = allPoints[j].Point1;\\n                    \\n                    double firstSidelen = Math.Sqrt((p1[0] - p3[0]) * (p1[0] - p3[0]) + (p1[1] - p3[1]) * (p1[1] - p3[1]));\\n                    double secondSideLen = Math.Sqrt((p2[0] - p3[0]) * (p2[0] - p3[0]) + (p2[1] - p3[1]) * (p2[1] - p3[1]));\\n                    double area = firstSidelen * secondSideLen;\\n                    minResult = Math.Min(minResult, area);\\n                }\\n            }\\n        }\\n     \\n        return minResult == double.MaxValue ? 0 : minResult;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Bizzare interview question\\n// Main Idea: All points in a rectagle are equidistant from the diagonal interesection\\n// Find the center between each pair of points and use that as the key (diagonal interection as key i.e. dist + p2x-p1x/2, p2y-p1y/2)\\n// Any 2 points from all points which are indexed by same key can form a rectangle.\\n// Itereate thru all pair of points in each group of points indexed by the key\\n// and get the min aray\\npublic class Solution {\\n    public double MinAreaFreeRect(int[][] points) {\\n        var row = points.Length;\\n        var col = row > 0 ? points[0].Length : 0;\\n        \\n        if(row == 0 || col == 0)\\n            return 0;\\n        \\n        var pointsGroup = new Dictionary<string, List<(int[] Point1, int[] Point2)>>();\\n        for(var i = 0; i < row; i++)\\n        {\\n            for(var j = i + 1; j < row; j++)\\n            {\\n                var p1 = points[i];\\n                var p2 = points[j];\\n                \\n                var dist = (p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]);\\n                var centerX = (p2[0] + p1[0]) / 2.0;\\n                var centerY = (p2[1] + p1[1]) / 2.0;\\n                \\n                var key = dist + \":\" + centerX + \"-\" + centerY;\\n                if(!pointsGroup.ContainsKey(key))\\n                {\\n                    pointsGroup.Add(key, new List<(int[], int[])>(){(p2, p1)});\\n                }\\n                else\\n                {\\n                    pointsGroup[key].Add((p2, p1));\\n                }\\n            }\\n        }\\n        \\n        var minResult = double.MaxValue;\\n        // A group contains all pairs of points with the same distance and middle point, any two of these pairs form a rectangle with each other.\\n        // We iterate through all rectangles that can be formed with the given points, we compute the area of each rectangle and maintain the min area.\\n        \\n        foreach(var allPoints in pointsGroup.Values)\\n        {\\n            for(var i = 0; i < allPoints.Count; i++)\\n            {\\n                for(var j = i + 1; j < allPoints.Count; j++)\\n                {\\n                    var p1 = allPoints[i].Point1;\\n                    var p2 = allPoints[i].Point2;\\n                    var p3 = allPoints[j].Point1;\\n                    \\n                    double firstSidelen = Math.Sqrt((p1[0] - p3[0]) * (p1[0] - p3[0]) + (p1[1] - p3[1]) * (p1[1] - p3[1]));\\n                    double secondSideLen = Math.Sqrt((p2[0] - p3[0]) * (p2[0] - p3[0]) + (p2[1] - p3[1]) * (p2[1] - p3[1]));\\n                    double area = firstSidelen * secondSideLen;\\n                    minResult = Math.Min(minResult, area);\\n                }\\n            }\\n        }\\n     \\n        return minResult == double.MaxValue ? 0 : minResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829244,
                "title": "straightforward-c-o-n-3",
                "content": "Iterating over the triples this way, with `i < j < k` and trying to set the vertex at `i`, `j`, and `k`, rather than trying all triples `(i, j, k)` where `i`, `j`, and `k` are distinct (like in [@wangzi6147\\'s solution](https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/208470/Java-O(N3)-bruteforce)), seems to make the solution somewhat faster (160ms to 94ms).\\n\\nOf course not faster than the O(N^2) solution, but it is fairly straightforward and easy to understand.\\n\\nBeats 70% time, 90% memory.\\n\\n```cpp\\nint dotProd(int p1, int p2, int p3, vector<vector<int>> &points) {\\n\\t// calculate dot product: x1 * x2 + y1 * y2, make sure it\\'s equal to zero\\n\\treturn (points[p2][0] - points[p1][0]) * (points[p3][0] - points[p1][0])\\n\\t\\t+ (points[p2][1] - points[p1][1]) * (points[p3][1] - points[p1][1]);\\n}\\n\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tint i, j, k, len = points.size(), p1, p2, p3, x1, x2, y1, y2;\\n\\tdouble area, minArea = -1;\\n\\n\\t// save all (x, y) pairs (encoded into a single integer) in a hashset for quick searches\\n\\tunordered_set<int> ps(0);\\n\\tfor (i = 0; i < len; ++i)\\n\\t\\tps.insert(points[i][0] * 40000 + points[i][1]);\\n\\n\\t// cubic search for rectangles; loop over every triple (i, j, k), where i > j > k\\n\\tfor (i = 2; i < len; ++i) {\\n\\t\\tfor (j = 1; j < i; ++j) {\\n\\t\\t\\tfor (k = 0; k < j; ++k) {\\n\\t\\t\\t\\t// check if JIK or IJK or IKJ is a right angle by calculating the dot\\n\\t\\t\\t\\t// product of two vectors and checking if it\\'s zero; if one is a right angle,\\n\\t\\t\\t\\t// set the vertex point to be p1; otherwise no valid right angle, continue\\n\\t\\t\\t\\tif (dotProd(p1 = i, p2 = j, p3 = k, points)\\n\\t\\t\\t\\t   && dotProd(p1 = j, p2 = i, p3 = k, points)\\n\\t\\t\\t\\t   && dotProd(p1 = k, p2 = i, p3 = j, points))\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tx1 = points[p2][0] - points[p1][0];\\n\\t\\t\\t\\tx2 = points[p3][0] - points[p1][0];\\n\\t\\t\\t\\ty1 = points[p2][1] - points[p1][1];\\n\\t\\t\\t\\ty2 = points[p3][1] - points[p1][1];\\n\\n\\t\\t\\t\\t// area is sqrt((x1^2 + y1^2) * (x2^2 + y2^2))\\n\\t\\t\\t\\tarea = sqrt(((unsigned long) x1*x1 + y1*y1) * (x2*x2 + y2*y2));\\n\\t\\t\\t\\tif (minArea != -1 && area >= minArea)\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t// try to complete this rectangle: fourth point at (p1.x + x1 + x2, p1.y + y1 + y2)\\n\\t\\t\\t\\t// hashset makes searching for the fourth point roughly O(1)\\n\\t\\t\\t\\tif (ps.count((points[p1][0] + x1 + x2) * 40000 + (points[p1][1] + y1 + y2)))\\n\\t\\t\\t\\t\\tminArea = area;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn minArea == -1 ? 0 : minArea;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dotProd(int p1, int p2, int p3, vector<vector<int>> &points) {\\n\\t// calculate dot product: x1 * x2 + y1 * y2, make sure it\\'s equal to zero\\n\\treturn (points[p2][0] - points[p1][0]) * (points[p3][0] - points[p1][0])\\n\\t\\t+ (points[p2][1] - points[p1][1]) * (points[p3][1] - points[p1][1]);\\n}\\n\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tint i, j, k, len = points.size(), p1, p2, p3, x1, x2, y1, y2;\\n\\tdouble area, minArea = -1;\\n\\n\\t// save all (x, y) pairs (encoded into a single integer) in a hashset for quick searches\\n\\tunordered_set<int> ps(0);\\n\\tfor (i = 0; i < len; ++i)\\n\\t\\tps.insert(points[i][0] * 40000 + points[i][1]);\\n\\n\\t// cubic search for rectangles; loop over every triple (i, j, k), where i > j > k\\n\\tfor (i = 2; i < len; ++i) {\\n\\t\\tfor (j = 1; j < i; ++j) {\\n\\t\\t\\tfor (k = 0; k < j; ++k) {\\n\\t\\t\\t\\t// check if JIK or IJK or IKJ is a right angle by calculating the dot\\n\\t\\t\\t\\t// product of two vectors and checking if it\\'s zero; if one is a right angle,\\n\\t\\t\\t\\t// set the vertex point to be p1; otherwise no valid right angle, continue\\n\\t\\t\\t\\tif (dotProd(p1 = i, p2 = j, p3 = k, points)\\n\\t\\t\\t\\t   && dotProd(p1 = j, p2 = i, p3 = k, points)\\n\\t\\t\\t\\t   && dotProd(p1 = k, p2 = i, p3 = j, points))\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tx1 = points[p2][0] - points[p1][0];\\n\\t\\t\\t\\tx2 = points[p3][0] - points[p1][0];\\n\\t\\t\\t\\ty1 = points[p2][1] - points[p1][1];\\n\\t\\t\\t\\ty2 = points[p3][1] - points[p1][1];\\n\\n\\t\\t\\t\\t// area is sqrt((x1^2 + y1^2) * (x2^2 + y2^2))\\n\\t\\t\\t\\tarea = sqrt(((unsigned long) x1*x1 + y1*y1) * (x2*x2 + y2*y2));\\n\\t\\t\\t\\tif (minArea != -1 && area >= minArea)\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t// try to complete this rectangle: fourth point at (p1.x + x1 + x2, p1.y + y1 + y2)\\n\\t\\t\\t\\t// hashset makes searching for the fourth point roughly O(1)\\n\\t\\t\\t\\tif (ps.count((points[p1][0] + x1 + x2) * 40000 + (points[p1][1] + y1 + y2)))\\n\\t\\t\\t\\t\\tminArea = area;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn minArea == -1 ? 0 : minArea;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823346,
                "title": "go-group-by-center-and-length",
                "content": "```go\\nfunc minAreaFreeRect(points [][]int) float64 {\\n    // group pointer pairs by key [3]int{center_x*2, center_y*2, dis2}\\n    var centers = make(map[[3]int][][2]int)\\n    \\n    for i, p1:= range points {\\n        for j := i+1; j < len(points); j++ {\\n            var p2 = points[j]\\n            \\n            var cp = [3]int{p1[0]+p2[0], p1[1]+p2[1], dis2(p1, p2)}\\n            \\n            var v = centers[cp]\\n            v = append(v, [2]int{i, j})\\n            centers[cp] = v\\n        }\\n    }\\n    \\n    var ret = 0\\n    \\n    for _, l := range centers {\\n        for i := 0; i < len(l); i++ {\\n            for j := i+1; j < len(l); j++ {\\n                var p0, p2, p3 = points[l[i][0]], points[l[j][0]], points[l[j][1]]\\n                var area2 = dis2(p0, p2) * dis2(p0, p3)\\n                if ret == 0 || ret > area2 {\\n                    ret = area2\\n                }\\n            }\\n        }\\n    }\\n    \\n    return math.Sqrt(float64(ret))\\n}\\n\\nfunc dis2(p0, p1 []int) int {\\n    var dx = p0[0] - p1[0]\\n    var dy = p0[1] - p1[1]\\n    return dx*dx + dy*dy\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc minAreaFreeRect(points [][]int) float64 {\\n    // group pointer pairs by key [3]int{center_x*2, center_y*2, dis2}\\n    var centers = make(map[[3]int][][2]int)\\n    \\n    for i, p1:= range points {\\n        for j := i+1; j < len(points); j++ {\\n            var p2 = points[j]\\n            \\n            var cp = [3]int{p1[0]+p2[0], p1[1]+p2[1], dis2(p1, p2)}\\n            \\n            var v = centers[cp]\\n            v = append(v, [2]int{i, j})\\n            centers[cp] = v\\n        }\\n    }\\n    \\n    var ret = 0\\n    \\n    for _, l := range centers {\\n        for i := 0; i < len(l); i++ {\\n            for j := i+1; j < len(l); j++ {\\n                var p0, p2, p3 = points[l[i][0]], points[l[j][0]], points[l[j][1]]\\n                var area2 = dis2(p0, p2) * dis2(p0, p3)\\n                if ret == 0 || ret > area2 {\\n                    ret = area2\\n                }\\n            }\\n        }\\n    }\\n    \\n    return math.Sqrt(float64(ret))\\n}\\n\\nfunc dis2(p0, p1 []int) int {\\n    var dx = p0[0] - p1[0]\\n    var dy = p0[1] - p1[1]\\n    return dx*dx + dy*dy\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788054,
                "title": "java-o-n-2-average-time-complexity",
                "content": "Two diagonals of rectangle have equal length and their intersection point is the middle of both diagonals.\\nso we  need to check all the point pairs one time.\\n\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        double s = Integer.MAX_VALUE;\\n        for(int i = 0; i<n; i++){\\n            for(int j = i+1; j<n; j++){\\n                double x = ((double)points[i][0]+points[j][0])/2;\\n                double y = ((double)points[i][1]+points[j][1])/2;\\n                double l = Math.pow(points[i][0]-points[j][0],2) + Math.pow(points[i][1]-points[j][1],2);\\n                String key = l + \" \" + x + \" \" + y;\\n                if(map.containsKey(key)){\\n                    for(Integer z : map.get(key)){\\n                        s = Math.min(s, calcSquare(i,j,z, points));\\n                    }\\n                }\\n                map.computeIfAbsent(key, nil->new ArrayList<>()).add(i);\\n            }\\n        }\\n        return s == Integer.MAX_VALUE ? 0 : s;\\n    }\\n    \\n    private double calcSquare(int x, int y, int z, int[][] points){\\n        double l = Math.pow(Math.pow(points[x][0]-points[z][0],2)+Math.pow(points[x][1] - points[z][1],2),0.5);\\n        double w = Math.pow(Math.pow(points[y][0]-points[z][0],2)+Math.pow(points[y][1] - points[z][1],2),0.5);\\n        return l*w;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        double s = Integer.MAX_VALUE;\\n        for(int i = 0; i<n; i++){\\n            for(int j = i+1; j<n; j++){\\n                double x = ((double)points[i][0]+points[j][0])/2;\\n                double y = ((double)points[i][1]+points[j][1])/2;\\n                double l = Math.pow(points[i][0]-points[j][0],2) + Math.pow(points[i][1]-points[j][1],2);\\n                String key = l + \" \" + x + \" \" + y;\\n                if(map.containsKey(key)){\\n                    for(Integer z : map.get(key)){\\n                        s = Math.min(s, calcSquare(i,j,z, points));\\n                    }\\n                }\\n                map.computeIfAbsent(key, nil->new ArrayList<>()).add(i);\\n            }\\n        }\\n        return s == Integer.MAX_VALUE ? 0 : s;\\n    }\\n    \\n    private double calcSquare(int x, int y, int z, int[][] points){\\n        double l = Math.pow(Math.pow(points[x][0]-points[z][0],2)+Math.pow(points[x][1] - points[z][1],2),0.5);\\n        double w = Math.pow(Math.pow(points[y][0]-points[z][0],2)+Math.pow(points[y][1] - points[z][1],2),0.5);\\n        return l*w;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786415,
                "title": "possible-wrong-test-case",
                "content": "For test case: [[21096,38753],[2304,26303],[3969,29792],[33983,32544],[15376,38207],[15512,38241],[1232,20799],[37696,13697],[30465,4400],[20799,38768],[8100,34535],[38785,20000],[1241,20988],[38207,24624],[1300,21785],[38768,20799],[38241,24488],[18215,38700],[1793,24624],[28127,3064],[36575,28840],[33983,7456],[4340,30375],[37340,12775],[26201,2268],[27225,37340],[3816,29537],[1759,24488],[11873,36936],[37017,12044],[28840,36575],[12044,37017],[4972,31271],[38753,21096],[35028,31271],[7456,33983],[38700,21785],[36936,11873],[36031,29792],[35028,8729],[20000,38785],[1247,21096],[30375,35660],[20799,1232],[36184,29537],[1575,23660],[20000,1215],[18904,38753],[34535,31900],[29792,36031]]\\n\\nThe expected output is 209460264.00000, but we can get a smaller rectangle by using these 4 points from the input [[28127,3064], [4972,31271], [35028,8729], [11873,36936]]. The min area should be 30018430.00000.\\n\\nIf you just give [[28127,3064], [4972,31271], [35028,8729], [11873,36936]] as input to formal solution, it will return 30018430.00000.\\n\\nAm I missing something?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 768415,
                "title": "c-geometry",
                "content": "```c++\\nclass Solution {\\n    string getKey(int &x,int &y)\\n    {\\n        return to_string(x)+\"_\"+to_string(y);\\n    }\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans=0;\\n        unordered_map<string,int> f;\\n        for(auto it:points)\\n            f[getKey(it[0],it[1])]=1;\\n        int n=points.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    int x1=points[i][0],y1=points[i][1];\\n                    int x2=points[j][0],y2=points[j][1];\\n                    int x3=points[k][0],y3=points[k][1];\\n                    if(((x2-x1)*(x3-x1)+(y2-y1)*(y3-y1))!=0)continue;\\n                    int x4=x3+x2-x1,y4=y3+y2-y1;\\n                    if(f.count(getKey(x4,y4))==0)continue;\\n                    double l=pow(pow(x2-x1,2)+pow(y2-y1,2),0.5);\\n                    double w=pow(pow(x3-x1,2)+pow(y3-y1,2),0.5);\\n                    double area=l*w;\\n                    if(ans==0)ans=area;\\n                    else if(area<ans)ans=area;\\n                }\\n            }\\n        }\\n        return ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\n    string getKey(int &x,int &y)\\n    {\\n        return to_string(x)+\"_\"+to_string(y);\\n    }\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans=0;\\n        unordered_map<string,int> f;\\n        for(auto it:points)\\n            f[getKey(it[0],it[1])]=1;\\n        int n=points.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    int x1=points[i][0],y1=points[i][1];\\n                    int x2=points[j][0],y2=points[j][1];\\n                    int x3=points[k][0],y3=points[k][1];\\n                    if(((x2-x1)*(x3-x1)+(y2-y1)*(y3-y1))!=0)continue;\\n                    int x4=x3+x2-x1,y4=y3+y2-y1;\\n                    if(f.count(getKey(x4,y4))==0)continue;\\n                    double l=pow(pow(x2-x1,2)+pow(y2-y1,2),0.5);\\n                    double w=pow(pow(x3-x1,2)+pow(y3-y1,2),0.5);\\n                    double area=l*w;\\n                    if(ans==0)ans=area;\\n                    else if(area<ans)ans=area;\\n                }\\n            }\\n        }\\n        return ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760954,
                "title": "python-using-vectors-sketches-and-explanation-included",
                "content": "```\\n\\t\\t\\t\\t\\t\\t   p4\\n\\t\\t\\t\\t\\t\\t   /\\\\\\n\\t  p1   p3          p1 /  \\\\ p3\\n\\t   \\\\  /               \\\\  /\\n    v12 \\\\/ v23             \\\\/\\n\\t\\tp2                 p2\\n```\\n\\nApproach to finding a rectangle:\\n\\n1. Pick a point ```p2```\\n2. For all possible points ```p1``` and ```p3``` check if the vector between ```(p1,p2)``` and the vector between ```(p2,p3)``` are perpendicular (orthogonal).  If they are not perpendicular, then this cannot be the corner of a rectangle.  \\n3. If the two vectors ```v12``` and ```v23``` are orthogonal, check if area of the rectangle they make is smaller than the smallest rectangle found so far (```smallest_rectangle```)\\n4. If it is, then check if ```p4``` exists in ```points_set```, converted to a set for O(1) lookup times.\\n\\n```python\\ndef minAreaFreeRect(self, points: List[List[int]]) -> float:\\n\\n\\tdef is_orthogonal(v12, v23) -> bool:\\n\\t\\t\\'\\'\\'\\n\\t\\treturns True if vectors v12 and v23 are orthogonal\\n\\t\\tvector v12 connects points p1 and p2\\n\\t\\tvector v23 connects points p2 and p3\\n\\n\\t\\t p1      p3\\n\\t\\t   \\\\    /\\n\\t\\tv12 \\\\  / v23\\n\\t\\t\\t \\\\/ \\n\\t\\t\\t p2\\n\\t\\t\\'\\'\\'\\n\\t\\treturn not v12[0]*v23[0]+v12[1]*v23[1]\\n\\n\\tdef fourth_point(p2, v12, v23) -> tuple:\\n\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t\\t\\t\\t   p4\\n\\t\\t\\t\\t\\t\\t\\t   /\\\\\\n\\t\\t  p1   p3          p1 /  \\\\ p3\\n\\t\\t   \\\\  /               \\\\  /\\n\\t\\t\\t\\\\/                 \\\\/\\n\\t\\t\\tp2                 p2\\n\\n\\t\\tp2 is the shared point between two orthogonal vectors\\n\\n\\t\\treturns p4 (x,y) that completes the rectangle\\n\\t\\t\\'\\'\\'\\n\\t\\treturn (p2[0]+v12[0]+v23[0], p2[1]+v12[1]+v23[1])\\n\\n\\tdef area(v12, v23) -> int:\\n\\t\\t\\'\\'\\'\\n\\t\\tgiven vectors v12 and v23 returns the area of the rectangle\\n\\t\\t\\'\\'\\'\\n\\t\\tlength_12 = (v12[0]**2 + v12[1]**2)**0.5\\n\\t\\tlength_23 = (v23[0]**2 + v23[1]**2)**0.5\\n\\t\\treturn length_12*length_23\\n\\n\\tdef vector(p1, p2):\\n\\t\\t\\'\\'\\'\\n\\t\\treturns the vector that points from p2 to p1\\n\\t\\t\\'\\'\\'\\n\\t\\treturn (p2[0]-p1[0], p2[1]-p1[1])\\n\\n\\tpoint_set = set(tuple(p) for p in points)\\n\\tsmallest_rectangle = float(\\'inf\\')\\n\\n\\tfor i in range(len(points)):\\n\\t\\tp1 = points[i]\\n\\n\\t\\tfor j in range(i+1, len(points)):\\n\\n\\t\\t\\tp2 = points[j]\\n\\t\\t\\tv12 = vector(p2,p1)\\n\\n\\t\\t\\tfor k in range(j+1, len(points)):\\n\\n\\t\\t\\t\\tp3 = points[k]\\n\\t\\t\\t\\tv23 = vector(p2,p3)\\n\\n\\t\\t\\t\\tif is_orthogonal(v12,v23):\\n\\n\\t\\t\\t\\t\\tA = area(v12,v23)\\n\\t\\t\\t\\t\\tif (A < smallest_rectangle) and (fourth_point(p2,v12,v23) in point_set):\\n\\t\\t\\t\\t\\t\\tsmallest_rectangle = A\\n\\n\\treturn 0 if smallest_rectangle == float(\\'inf\\') else smallest \\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t\\t   p4\\n\\t\\t\\t\\t\\t\\t   /\\\\\\n\\t  p1   p3          p1 /  \\\\ p3\\n\\t   \\\\  /               \\\\  /\\n    v12 \\\\/ v23             \\\\/\\n\\t\\tp2                 p2\\n```\n```p2```\n```p1```\n```p3```\n```(p1,p2)```\n```(p2,p3)```\n```v12```\n```v23```\n```smallest_rectangle```\n```p4```\n```points_set```\n```python\\ndef minAreaFreeRect(self, points: List[List[int]]) -> float:\\n\\n\\tdef is_orthogonal(v12, v23) -> bool:\\n\\t\\t\\'\\'\\'\\n\\t\\treturns True if vectors v12 and v23 are orthogonal\\n\\t\\tvector v12 connects points p1 and p2\\n\\t\\tvector v23 connects points p2 and p3\\n\\n\\t\\t p1      p3\\n\\t\\t   \\\\    /\\n\\t\\tv12 \\\\  / v23\\n\\t\\t\\t \\\\/ \\n\\t\\t\\t p2\\n\\t\\t\\'\\'\\'\\n\\t\\treturn not v12[0]*v23[0]+v12[1]*v23[1]\\n\\n\\tdef fourth_point(p2, v12, v23) -> tuple:\\n\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t\\t\\t\\t   p4\\n\\t\\t\\t\\t\\t\\t\\t   /\\\\\\n\\t\\t  p1   p3          p1 /  \\\\ p3\\n\\t\\t   \\\\  /               \\\\  /\\n\\t\\t\\t\\\\/                 \\\\/\\n\\t\\t\\tp2                 p2\\n\\n\\t\\tp2 is the shared point between two orthogonal vectors\\n\\n\\t\\treturns p4 (x,y) that completes the rectangle\\n\\t\\t\\'\\'\\'\\n\\t\\treturn (p2[0]+v12[0]+v23[0], p2[1]+v12[1]+v23[1])\\n\\n\\tdef area(v12, v23) -> int:\\n\\t\\t\\'\\'\\'\\n\\t\\tgiven vectors v12 and v23 returns the area of the rectangle\\n\\t\\t\\'\\'\\'\\n\\t\\tlength_12 = (v12[0]**2 + v12[1]**2)**0.5\\n\\t\\tlength_23 = (v23[0]**2 + v23[1]**2)**0.5\\n\\t\\treturn length_12*length_23\\n\\n\\tdef vector(p1, p2):\\n\\t\\t\\'\\'\\'\\n\\t\\treturns the vector that points from p2 to p1\\n\\t\\t\\'\\'\\'\\n\\t\\treturn (p2[0]-p1[0], p2[1]-p1[1])\\n\\n\\tpoint_set = set(tuple(p) for p in points)\\n\\tsmallest_rectangle = float(\\'inf\\')\\n\\n\\tfor i in range(len(points)):\\n\\t\\tp1 = points[i]\\n\\n\\t\\tfor j in range(i+1, len(points)):\\n\\n\\t\\t\\tp2 = points[j]\\n\\t\\t\\tv12 = vector(p2,p1)\\n\\n\\t\\t\\tfor k in range(j+1, len(points)):\\n\\n\\t\\t\\t\\tp3 = points[k]\\n\\t\\t\\t\\tv23 = vector(p2,p3)\\n\\n\\t\\t\\t\\tif is_orthogonal(v12,v23):\\n\\n\\t\\t\\t\\t\\tA = area(v12,v23)\\n\\t\\t\\t\\t\\tif (A < smallest_rectangle) and (fourth_point(p2,v12,v23) in point_set):\\n\\t\\t\\t\\t\\t\\tsmallest_rectangle = A\\n\\n\\treturn 0 if smallest_rectangle == float(\\'inf\\') else smallest \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 739670,
                "title": "o-n-n-16ms",
                "content": "This solutsion is based on the following observations:\\n1. Parallelogram\\'s diagonals bissect each other. [Wikipedia - Parallelogram](https://en.wikipedia.org/wiki/Parallelogram#Characterizations)\\n2. A rectangle is a parallelogram with diagonals of equal length. [Wikipedia - Rectangle](https://en.wikipedia.org/wiki/Rectangle#Characterizations)\\n\\nTherefore:\\n1. partition segemts by their diagonal\\'s centers.\\n2. two segments of the same length comprise a rectangle.\\n\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        List<Point> ps = distinct(points);\\n        \\n        Map<Point, List<Segment>> centers = new HashMap<>();\\n        for (int i = 0; i < ps.size(); i++) {\\n            Point start = ps.get(i);\\n            for (int j = i + 1; j < ps.size(); j++) {\\n                Point end = ps.get(j);\\n                Segment s = new Segment(start, end);\\n                centers.computeIfAbsent(s.diagonal(), k -> new ArrayList<>()).add(s);\\n            }\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        for (Point center : centers.keySet()) {\\n            List<Segment> segments = centers.get(center);\\n            for (int i = 0; i < segments.size(); i++) {\\n                Segment a = segments.get(i);\\n                for (int j = i + 1; j < segments.size(); j++) {\\n                    Segment b = segments.get(j);\\n                    if (a.length() == b.length()) {\\n                        minArea = Math.min(minArea, area(a, b));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (minArea == Double.MAX_VALUE) {\\n            return 0;\\n        }\\n        \\n        return Math.sqrt(minArea);\\n    }\\n    \\n    private List<Point> distinct(int[][] points) {\\n        Set<Point> ps = new HashSet<>();\\n        for (int[] p : points) {\\n            ps.add(new Point(p[0], p[1]));\\n        }\\n        return new ArrayList<>(ps);\\n    }\\n    \\n    private double area(Segment a, Segment b) {\\n        return new Segment(a.start, b.start).length() * new Segment(b.start, a.end).length();\\n    }\\n}\\n\\nclass Segment {\\n    final Point start;\\n    final Point end;\\n    \\n    Segment(Point s, Point e) {\\n        start = s;\\n        end = e;\\n    }\\n    \\n    Point diagonal() {\\n        return new Point((start.x + end.x) / 2, (start.y + end.y) / 2);\\n    }\\n    \\n    double length() {\\n        double dx = start.x - end.x;\\n        double dy = start.y - end.y;\\n        return dx * dx + dy * dy;\\n    }\\n\\n}\\n\\nclass Point {\\n    final double x;\\n    final double y;\\n    \\n    Point(double x, double y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(x, y);\\n    }\\n    \\n    @Override\\n    public boolean equals(Object o) {\\n        if (!(o instanceof Point)) {\\n            return false;\\n        }\\n        \\n        Point other = (Point) o;\\n        return x == other.x && y == other.y;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        List<Point> ps = distinct(points);\\n        \\n        Map<Point, List<Segment>> centers = new HashMap<>();\\n        for (int i = 0; i < ps.size(); i++) {\\n            Point start = ps.get(i);\\n            for (int j = i + 1; j < ps.size(); j++) {\\n                Point end = ps.get(j);\\n                Segment s = new Segment(start, end);\\n                centers.computeIfAbsent(s.diagonal(), k -> new ArrayList<>()).add(s);\\n            }\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        for (Point center : centers.keySet()) {\\n            List<Segment> segments = centers.get(center);\\n            for (int i = 0; i < segments.size(); i++) {\\n                Segment a = segments.get(i);\\n                for (int j = i + 1; j < segments.size(); j++) {\\n                    Segment b = segments.get(j);\\n                    if (a.length() == b.length()) {\\n                        minArea = Math.min(minArea, area(a, b));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (minArea == Double.MAX_VALUE) {\\n            return 0;\\n        }\\n        \\n        return Math.sqrt(minArea);\\n    }\\n    \\n    private List<Point> distinct(int[][] points) {\\n        Set<Point> ps = new HashSet<>();\\n        for (int[] p : points) {\\n            ps.add(new Point(p[0], p[1]));\\n        }\\n        return new ArrayList<>(ps);\\n    }\\n    \\n    private double area(Segment a, Segment b) {\\n        return new Segment(a.start, b.start).length() * new Segment(b.start, a.end).length();\\n    }\\n}\\n\\nclass Segment {\\n    final Point start;\\n    final Point end;\\n    \\n    Segment(Point s, Point e) {\\n        start = s;\\n        end = e;\\n    }\\n    \\n    Point diagonal() {\\n        return new Point((start.x + end.x) / 2, (start.y + end.y) / 2);\\n    }\\n    \\n    double length() {\\n        double dx = start.x - end.x;\\n        double dy = start.y - end.y;\\n        return dx * dx + dy * dy;\\n    }\\n\\n}\\n\\nclass Point {\\n    final double x;\\n    final double y;\\n    \\n    Point(double x, double y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(x, y);\\n    }\\n    \\n    @Override\\n    public boolean equals(Object o) {\\n        if (!(o instanceof Point)) {\\n            return false;\\n        }\\n        \\n        Point other = (Point) o;\\n        return x == other.x && y == other.y;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646633,
                "title": "c-mapping-lensq-center-corner-points-with-comments",
                "content": "```cpp\\nprivate:\\n    // square of segment(p1, p2) length \\n    long lenSq(vector<int>& p1, vector<int>& p2) {\\n      return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n    }\\n  \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& pts) \\n    {\\n      // PtGroups: (len^2, 2*xc, 2*yc)-> {{x1,y1},...} \\n      // where segment (x1,y)-(x2,y2) has length len and center (xc,yc)\\n      unordered_map<string, vector<vector<int>>> PtGroups; // group by center and length \\n      \\n      for (int j = 1; j < pts.size(); j++) \\n        for (int i = 0; i < j; i++) \\n        {\\n          int xc2 = pts[i][0]+pts[j][0];\\n          int yc2 = pts[i][1]+pts[j][1];\\n          long distSq = lenSq(pts[i], pts[j]);\\n          string key = to_string(distSq) + \" \" + to_string(xc2) + \" \" + to_string(yc2);\\n          PtGroups[key].push_back(pts[i]); // just need one end point\\n        }\\n      \\n      long minAreaSq = LONG_MAX;\\n      for (auto& p : PtGroups) {\\n        stringstream key(p.first);\\n        string tmp; key >> tmp;\\n        long distSq = stol(tmp);\\n        \\n        for (int j = 1; j < p.second.size(); j++)\\n          for (int i = 0; i < j; i++)\\n          {\\n            auto p1 = p.second[i];\\n            auto p2 = p.second[j];\\n            minAreaSq = min(minAreaSq, lenSq(p1,p2)*(distSq - lenSq(p1,p2))); // using Pythagoras\\'s Theorem\\n          }\\n      }\\n      \\n      return minAreaSq == LONG_MAX? 0 : sqrt(minAreaSq);\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\nprivate:\\n    // square of segment(p1, p2) length \\n    long lenSq(vector<int>& p1, vector<int>& p2) {\\n      return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n    }\\n  \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& pts) \\n    {\\n      // PtGroups: (len^2, 2*xc, 2*yc)-> {{x1,y1},...} \\n      // where segment (x1,y)-(x2,y2) has length len and center (xc,yc)\\n      unordered_map<string, vector<vector<int>>> PtGroups; // group by center and length \\n      \\n      for (int j = 1; j < pts.size(); j++) \\n        for (int i = 0; i < j; i++) \\n        {\\n          int xc2 = pts[i][0]+pts[j][0];\\n          int yc2 = pts[i][1]+pts[j][1];\\n          long distSq = lenSq(pts[i], pts[j]);\\n          string key = to_string(distSq) + \" \" + to_string(xc2) + \" \" + to_string(yc2);\\n          PtGroups[key].push_back(pts[i]); // just need one end point\\n        }\\n      \\n      long minAreaSq = LONG_MAX;\\n      for (auto& p : PtGroups) {\\n        stringstream key(p.first);\\n        string tmp; key >> tmp;\\n        long distSq = stol(tmp);\\n        \\n        for (int j = 1; j < p.second.size(); j++)\\n          for (int i = 0; i < j; i++)\\n          {\\n            auto p1 = p.second[i];\\n            auto p2 = p.second[j];\\n            minAreaSq = min(minAreaSq, lenSq(p1,p2)*(distSq - lenSq(p1,p2))); // using Pythagoras\\'s Theorem\\n          }\\n      }\\n      \\n      return minAreaSq == LONG_MAX? 0 : sqrt(minAreaSq);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 645675,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        auto pack = [](const vector<int> &p) {\\n            return (uint64_t(p[0])<<32) | p[1];\\n        };\\n\\n        unordered_set<int64_t> s;\\n        for (const auto &p : points) {\\n            s.insert(pack(p));\\n        }\\n\\n        double best = -1;\\n        for (int a_index=0; a_index<points.size(); ++a_index) {\\n            const auto &a = points[a_index];\\n            for (int b_index=a_index+1; b_index<points.size(); ++b_index) {\\n                const auto &b = points[b_index];\\n                for (int c_index=b_index+1; c_index<points.size(); ++c_index) {\\n                    const auto &c = points[c_index];\\n                    const int ab_x = b[0]-a[0];\\n                    const int ab_y = b[1]-a[1];\\n\\n                    const int ac_x = c[0]-a[0];\\n                    const int ac_y = c[1]-a[1];\\n\\n                    if (ab_x*ac_x+ab_y*ac_y != 0) continue;\\n\\n                    const int d_x  = a[0] + ab_x + ac_x;\\n                    const int d_y  = a[1] + ab_y + ac_y;\\n\\n                    if (s.find(pack({d_x, d_y})) == s.end()) {\\n                        continue;\\n                    }\\n\\n                    const double area = sqrt((double(ab_x)*ab_x+ab_y*ab_y)*(ac_x*ac_x+ac_y*ac_y));\\n                    if (area>0.000000001) {\\n                        if (best<0 || area<best) {\\n                            best = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return best < 0 ? 0 : best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        auto pack = [](const vector<int> &p) {\\n            return (uint64_t(p[0])<<32) | p[1];\\n        };\\n\\n        unordered_set<int64_t> s;\\n        for (const auto &p : points) {\\n            s.insert(pack(p));\\n        }\\n\\n        double best = -1;\\n        for (int a_index=0; a_index<points.size(); ++a_index) {\\n            const auto &a = points[a_index];\\n            for (int b_index=a_index+1; b_index<points.size(); ++b_index) {\\n                const auto &b = points[b_index];\\n                for (int c_index=b_index+1; c_index<points.size(); ++c_index) {\\n                    const auto &c = points[c_index];\\n                    const int ab_x = b[0]-a[0];\\n                    const int ab_y = b[1]-a[1];\\n\\n                    const int ac_x = c[0]-a[0];\\n                    const int ac_y = c[1]-a[1];\\n\\n                    if (ab_x*ac_x+ab_y*ac_y != 0) continue;\\n\\n                    const int d_x  = a[0] + ab_x + ac_x;\\n                    const int d_y  = a[1] + ab_y + ac_y;\\n\\n                    if (s.find(pack({d_x, d_y})) == s.end()) {\\n                        continue;\\n                    }\\n\\n                    const double area = sqrt((double(ab_x)*ab_x+ab_y*ab_y)*(ac_x*ac_x+ac_y*ac_y));\\n                    if (area>0.000000001) {\\n                        if (best<0 || area<best) {\\n                            best = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return best < 0 ? 0 : best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640740,
                "title": "python3-10-lines",
                "content": "1. key: mid, diagonal length\\n2. min\\n3. if float(\"inf\") return 0\\n```\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        ans, dic = float(\"inf\"), {}\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                key = ((points[i][0] + points[j][0])/2, (points[i][1] + points[j][1])/2, ((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)**0.5)\\n                if key in dic:\\n                    for val in dic[key]:\\n                        ans = min(ans, ((points[i][0]-val[0][0])**2 + (points[i][1]-val[0][1])**2)**0.5 * ((points[i][0]-val[1][0])**2 + (points[i][1]-val[1][1])**2)**0.5)\\n                dic[key] = dic.get(key, []) + [(points[i], points[j])]\\n        return ans if ans != float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        ans, dic = float(\"inf\"), {}\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                key = ((points[i][0] + points[j][0])/2, (points[i][1] + points[j][1])/2, ((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)**0.5)\\n                if key in dic:\\n                    for val in dic[key]:\\n                        ans = min(ans, ((points[i][0]-val[0][0])**2 + (points[i][1]-val[0][1])**2)**0.5 * ((points[i][0]-val[1][0])**2 + (points[i][1]-val[1][1])**2)**0.5)\\n                dic[key] = dic.get(key, []) + [(points[i], points[j])]\\n        return ans if ans != float(\\'inf\\') else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 625617,
                "title": "python-prefix-solution",
                "content": "**Explanation**\\n\\nLoop through all the points and for each point build a distance D => dict{distance:edges} to to store all the distance:edges information\\n\\nIf the distance of two edges are same that means we can try to build a rectangle from the diagonal pair, the rest of the thing is to check if all the pair-edges in the rectangle has the same length, if valid that means this is a valid rectangle.\\n\\n```\\nimport math\\n    def minAreaFreeRect(self, P: List[List[int]]) -> float:\\n        if len(P) < 4:return 0\\n        \\n        def dis(A, B):\\n            return (A[0]-B[0])**2 + (A[1]-B[1])**2\\n        \\n        D = defaultdict(lambda:[])\\n        ans = math.inf\\n        for i in range(len(P)-1):\\n            for j in range(i+1, len(P)):\\n                D[dis(P[i], P[j])].append(((P[i][0], P[i][1]), (P[j][0],P[j][1])))\\n        \\n        for d in D:\\n            for i in range(len(D[d])-1):\\n                for j in range(i+1, len(D[d])):\\n                    if dis(D[d][i][0], D[d][j][0]) == dis(D[d][i][1], D[d][j][1]):\\n                        if dis(D[d][i][0], D[d][j][1]) == dis(D[d][i][1], D[d][j][0]):\\n                            ans = min(ans, dis(D[d][i][0], D[d][j][0])*dis(D[d][i][0], D[d][j][1]))\\n\\n        return math.sqrt(ans) if ans!=inf else float(0)\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\n    def minAreaFreeRect(self, P: List[List[int]]) -> float:\\n        if len(P) < 4:return 0\\n        \\n        def dis(A, B):\\n            return (A[0]-B[0])**2 + (A[1]-B[1])**2\\n        \\n        D = defaultdict(lambda:[])\\n        ans = math.inf\\n        for i in range(len(P)-1):\\n            for j in range(i+1, len(P)):\\n                D[dis(P[i], P[j])].append(((P[i][0], P[i][1]), (P[j][0],P[j][1])))\\n        \\n        for d in D:\\n            for i in range(len(D[d])-1):\\n                for j in range(i+1, len(D[d])):\\n                    if dis(D[d][i][0], D[d][j][0]) == dis(D[d][i][1], D[d][j][1]):\\n                        if dis(D[d][i][0], D[d][j][1]) == dis(D[d][i][1], D[d][j][0]):\\n                            ans = min(ans, dis(D[d][i][0], D[d][j][0])*dis(D[d][i][0], D[d][j][1]))\\n\\n        return math.sqrt(ans) if ans!=inf else float(0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 598104,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        using point = vector<int>;\\n        if(points.size() < 4)\\n            return 0;\\n        // radius ----> {ith, jth}\\n        unordered_map<int, vector<pair<int, int>>> hashmap;\\n        for(int i = 0; i < points.size(); ++i)\\n        {\\n            for(int j = i + 1; j < points.size(); ++j)\\n            {\\n                const point& p1 = points[i];\\n                const point& p2 = points[j];\\n                int radius = pow((p2[0] - p1[0]), 2) + pow((p2[1] - p1[1]), 2);\\n                // std::cout << radius << std::endl;\\n                hashmap[radius].push_back({i, j});\\n            }\\n        }\\n        double ans = 2e9;\\n        for(const auto& hashItem : hashmap)\\n        {\\n            for(int i = 0; i < hashItem.second.size(); ++i)\\n            {\\n                const point& p1 = points[hashItem.second[i].first];\\n                const point& p2 = points[hashItem.second[i].second];\\n                for(int j = i + 1; j < hashItem.second.size(); ++j)\\n                {\\n                    const point& p3 = points[hashItem.second[j].first];\\n                    const point& p4 = points[hashItem.second[j].second];\\n                 \\n                    int dx1 = p3[0] - p1[0];\\n                    int dx2 = p4[0] - p1[0];\\n                    int dy1 = p3[1] - p1[1];\\n                    int dy2 = p4[1] - p1[1];\\n                    if(dx1 * dx2 + dy1 * dy2 != 0)\\n                        continue;\\n                    dx1 = p3[0] - p2[0];\\n                    dx2 = p4[0] - p2[0];\\n                    dy1 = p3[1] - p2[1];\\n                    dy2 = p4[1] - p2[1];\\n                    if(dx1 * dx2 + dy1 * dy2 != 0)\\n                        continue;\\n                    double area = sqrt(dx1 * dx1 + dy1 * dy1) * sqrt(dx2 * dx2 + dy2 * dy2);\\n                    ans = area == 0 ? ans : min(ans, area);\\n                }\\n                \\n                \\n            }\\n        }\\n        return ans == 2e9 ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        using point = vector<int>;\\n        if(points.size() < 4)\\n            return 0;\\n        // radius ----> {ith, jth}\\n        unordered_map<int, vector<pair<int, int>>> hashmap;\\n        for(int i = 0; i < points.size(); ++i)\\n        {\\n            for(int j = i + 1; j < points.size(); ++j)\\n            {\\n                const point& p1 = points[i];\\n                const point& p2 = points[j];\\n                int radius = pow((p2[0] - p1[0]), 2) + pow((p2[1] - p1[1]), 2);\\n                // std::cout << radius << std::endl;\\n                hashmap[radius].push_back({i, j});\\n            }\\n        }\\n        double ans = 2e9;\\n        for(const auto& hashItem : hashmap)\\n        {\\n            for(int i = 0; i < hashItem.second.size(); ++i)\\n            {\\n                const point& p1 = points[hashItem.second[i].first];\\n                const point& p2 = points[hashItem.second[i].second];\\n                for(int j = i + 1; j < hashItem.second.size(); ++j)\\n                {\\n                    const point& p3 = points[hashItem.second[j].first];\\n                    const point& p4 = points[hashItem.second[j].second];\\n                 \\n                    int dx1 = p3[0] - p1[0];\\n                    int dx2 = p4[0] - p1[0];\\n                    int dy1 = p3[1] - p1[1];\\n                    int dy2 = p4[1] - p1[1];\\n                    if(dx1 * dx2 + dy1 * dy2 != 0)\\n                        continue;\\n                    dx1 = p3[0] - p2[0];\\n                    dx2 = p4[0] - p2[0];\\n                    dy1 = p3[1] - p2[1];\\n                    dy2 = p4[1] - p2[1];\\n                    if(dx1 * dx2 + dy1 * dy2 != 0)\\n                        continue;\\n                    double area = sqrt(dx1 * dx1 + dy1 * dy1) * sqrt(dx2 * dx2 + dy2 * dy2);\\n                    ans = area == 0 ? ans : min(ans, area);\\n                }\\n                \\n                \\n            }\\n        }\\n        return ans == 2e9 ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 559772,
                "title": "c-28ms-o-n-3-vector-math",
                "content": "```\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tauto pack = [](const vector<int> &p) {return (uint64_t(p[0])<<32) | p[1];};\\n\\n\\tunordered_set<int64_t> s;\\n\\tfor (const auto &p : points) {\\n\\t\\ts.insert(pack(p));\\n\\t}\\n\\n\\tdouble best = -1;\\n\\t// take every 3 points and see if there is a corner\\n\\tfor (int a_index=0; a_index<points.size(); ++a_index) {\\n\\t\\tconst auto &a = points[a_index];\\n\\t\\tfor (int b_index=a_index+1; b_index<points.size(); ++b_index) {\\n\\t\\t\\tconst auto &b = points[b_index];\\n\\t\\t\\tfor (int c_index=b_index+1; c_index<points.size(); ++c_index) {\\n\\t\\t\\t\\tconst auto &c = points[c_index];\\n\\t\\t\\t\\t// build vectors ab and ac\\n\\t\\t\\t\\tconst int ab_x = b[0]-a[0];\\n\\t\\t\\t\\tconst int ab_y = b[1]-a[1];\\n\\n\\t\\t\\t\\tconst int ac_x = c[0]-a[0];\\n\\t\\t\\t\\tconst int ac_y = c[1]-a[1];\\n\\n\\t\\t\\t\\t// vectors ab and ac are orthogonal if the scalar product is zero\\n\\t\\t\\t\\tif (ab_x*ac_x+ab_y*ac_y != 0) {\\n\\t\\t\\t\\t\\t// not orthogonal: ab and ac cannot form sides of a rectangle\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// point d is sum of vectors ab and ac\\n\\t\\t\\t\\tconst int d_x  = a[0] + ab_x + ac_x;\\n\\t\\t\\t\\tconst int d_y  = a[1] + ab_y + ac_y;\\n\\n\\t\\t\\t\\t// does d exist?\\n\\t\\t\\t\\tif (s.find(pack({d_x, d_y})) == s.end()) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// area is length of vector ab * length of vector ac\\n\\t\\t\\t\\tconst double area = sqrt((double(ab_x)*ab_x+ab_y*ab_y)*(ac_x*ac_x+ac_y*ac_y));\\n\\t\\t\\t\\tif (area>0.000000001) { // ignore empty rects\\n\\t\\t\\t\\t\\tif (best<0 || area<best) {\\n\\t\\t\\t\\t\\t\\tbest = area;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn best < 0 ? 0 : best;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tauto pack = [](const vector<int> &p) {return (uint64_t(p[0])<<32) | p[1];};\\n\\n\\tunordered_set<int64_t> s;\\n\\tfor (const auto &p : points) {\\n\\t\\ts.insert(pack(p));\\n\\t}\\n\\n\\tdouble best = -1;\\n\\t// take every 3 points and see if there is a corner\\n\\tfor (int a_index=0; a_index<points.size(); ++a_index) {\\n\\t\\tconst auto &a = points[a_index];\\n\\t\\tfor (int b_index=a_index+1; b_index<points.size(); ++b_index) {\\n\\t\\t\\tconst auto &b = points[b_index];\\n\\t\\t\\tfor (int c_index=b_index+1; c_index<points.size(); ++c_index) {\\n\\t\\t\\t\\tconst auto &c = points[c_index];\\n\\t\\t\\t\\t// build vectors ab and ac\\n\\t\\t\\t\\tconst int ab_x = b[0]-a[0];\\n\\t\\t\\t\\tconst int ab_y = b[1]-a[1];\\n\\n\\t\\t\\t\\tconst int ac_x = c[0]-a[0];\\n\\t\\t\\t\\tconst int ac_y = c[1]-a[1];\\n\\n\\t\\t\\t\\t// vectors ab and ac are orthogonal if the scalar product is zero\\n\\t\\t\\t\\tif (ab_x*ac_x+ab_y*ac_y != 0) {\\n\\t\\t\\t\\t\\t// not orthogonal: ab and ac cannot form sides of a rectangle\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// point d is sum of vectors ab and ac\\n\\t\\t\\t\\tconst int d_x  = a[0] + ab_x + ac_x;\\n\\t\\t\\t\\tconst int d_y  = a[1] + ab_y + ac_y;\\n\\n\\t\\t\\t\\t// does d exist?\\n\\t\\t\\t\\tif (s.find(pack({d_x, d_y})) == s.end()) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// area is length of vector ab * length of vector ac\\n\\t\\t\\t\\tconst double area = sqrt((double(ab_x)*ab_x+ab_y*ab_y)*(ac_x*ac_x+ac_y*ac_y));\\n\\t\\t\\t\\tif (area>0.000000001) { // ignore empty rects\\n\\t\\t\\t\\t\\tif (best<0 || area<best) {\\n\\t\\t\\t\\t\\t\\tbest = area;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn best < 0 ? 0 : best;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558516,
                "title": "c-beats-70",
                "content": "Run time = 36-52 ms / beats ~70 %\\n\\nThe idea is to record all the pairs of points which have the same middle point, and then check among all the pairs sharing the same middle point, if any two pairs give inner product of zero.\\n\\n```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int n = points.size();\\n        unordered_map<long int, vector<pair<int, int>>> m;\\n        for (int i = 0; i < n-1; i++)\\n        {\\n            for (int j = i + 1; j < n; j++)\\n            {\\n                long int tmp = (points[i][0] + points[j][0]) * 80001.0 + (points[i][1] + points[j][1]);\\n                m[tmp].push_back(pair(i, j));\\n            }\\n        }\\n        double ret = 2e9;\\n        for (auto it = m.begin(); it != m.end(); it++)\\n        {\\n            if (it->second.size() == 1) continue;\\n            for (int i = 0; i < it->second.size()-1; i++)\\n            {\\n                for (int j = i + 1; j < it->second.size(); j++)\\n                {\\n                    int dx1 = points[it->second[i].first][0] - points[it->second[j].first][0];\\n                    int dy1 = points[it->second[i].first][1] - points[it->second[j].first][1];\\n                    int dx2 = points[it->second[i].first][0] - points[it->second[j].second][0];\\n                    int dy2 = points[it->second[i].first][1] - points[it->second[j].second][1];\\n                    if (dx1 * dx2 + dy1 * dy2 != 0) continue;\\n                    ret = min(ret, sqrt(dx1 * dx1 + dy1 * dy1) * sqrt(dx2 * dx2 + dy2 * dy2));\\n                }\\n            }\\n        }\\n        return ret == 2e9 ? 0 : ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int n = points.size();\\n        unordered_map<long int, vector<pair<int, int>>> m;\\n        for (int i = 0; i < n-1; i++)\\n        {\\n            for (int j = i + 1; j < n; j++)\\n            {\\n                long int tmp = (points[i][0] + points[j][0]) * 80001.0 + (points[i][1] + points[j][1]);\\n                m[tmp].push_back(pair(i, j));\\n            }\\n        }\\n        double ret = 2e9;\\n        for (auto it = m.begin(); it != m.end(); it++)\\n        {\\n            if (it->second.size() == 1) continue;\\n            for (int i = 0; i < it->second.size()-1; i++)\\n            {\\n                for (int j = i + 1; j < it->second.size(); j++)\\n                {\\n                    int dx1 = points[it->second[i].first][0] - points[it->second[j].first][0];\\n                    int dy1 = points[it->second[i].first][1] - points[it->second[j].first][1];\\n                    int dx2 = points[it->second[i].first][0] - points[it->second[j].second][0];\\n                    int dy2 = points[it->second[i].first][1] - points[it->second[j].second][1];\\n                    if (dx1 * dx2 + dy1 * dy2 != 0) continue;\\n                    ret = min(ret, sqrt(dx1 * dx1 + dy1 * dy1) * sqrt(dx2 * dx2 + dy2 * dy2));\\n                }\\n            }\\n        }\\n        return ret == 2e9 ? 0 : ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556215,
                "title": "963-minimum-area-rectangle-ii-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Diagonal as Key**\\n| O(T): O(n^3) | O(S): O(n) | Rt: 76ms | \\n```python\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        rst, l = float(\\'inf\\'), len(points)\\n        if l < 4: return 0\\n        dt = {}\\n        for i in range(l-1):\\n            x1, y1 = points[i]\\n            for j in range(i+1, l):\\n                x2, y2 = points[j]\\n                x, y = (x1 + x2) / 2, (y1 + y2) / 2\\n                distance = (x2-x1) * (x2-x1) + (y2-y1) * (y2-y1)\\n                key = (x, y, distance)\\n                if key not in dt: dt[key] = []\\n                dt[key].append((i, j))\\n                \\n        for k in dt:\\n            if len(dt[k]) > 1:\\n                arr, le = dt[k], len(dt[k])\\n                for i in range(le-1):\\n                    a, b = arr[i]\\n                    x1, y1, x2, y2 = *points[a], *points[b]\\n                    for j in range(i+1, le):\\n                        x3, y3 = points[arr[j][0]]\\n                        m, n = ((x3-x1)**2 + (y3-y1)**2)**0.5, ((x3-x2)**2 + (y3-y2)**2)**0.5\\n                        rst = min(rst, m*n)\\n        return 0 if rst == float(\\'inf\\') else rst\\n```\\nReferrence: https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/208361/JAVA-O(n2)-using-Map\\n\\n",
                "solutionTags": [],
                "code": "```python\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        rst, l = float(\\'inf\\'), len(points)\\n        if l < 4: return 0\\n        dt = {}\\n        for i in range(l-1):\\n            x1, y1 = points[i]\\n            for j in range(i+1, l):\\n                x2, y2 = points[j]\\n                x, y = (x1 + x2) / 2, (y1 + y2) / 2\\n                distance = (x2-x1) * (x2-x1) + (y2-y1) * (y2-y1)\\n                key = (x, y, distance)\\n                if key not in dt: dt[key] = []\\n                dt[key].append((i, j))\\n                \\n        for k in dt:\\n            if len(dt[k]) > 1:\\n                arr, le = dt[k], len(dt[k])\\n                for i in range(le-1):\\n                    a, b = arr[i]\\n                    x1, y1, x2, y2 = *points[a], *points[b]\\n                    for j in range(i+1, le):\\n                        x3, y3 = points[arr[j][0]]\\n                        m, n = ((x3-x1)**2 + (y3-y1)**2)**0.5, ((x3-x2)**2 + (y3-y2)**2)**0.5\\n                        rst = min(rst, m*n)\\n        return 0 if rst == float(\\'inf\\') else rst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 526517,
                "title": "golang-o-n-3",
                "content": "```\\nfunc minAreaFreeRect(points [][]int) float64 {\\n\\tpositionsMap := make(map[string]bool)\\n\\tfor _, point := range points {\\n\\t\\tx, y := point[0], point[1]\\n\\t\\tpositionsMap[fmt.Sprintf(\"%s:%s\", x, y)] = true\\n\\t}\\n\\tres := math.MaxFloat64\\n\\tfound := false\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tx1, y1 := points[i][0], points[i][1]\\n\\t\\tfor j := 0; j < len(points); j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tx2, y2 := points[j][0], points[j][1]\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n\\t\\t\\t\\tif k == i || k == j {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx3, y3 := points[k][0], points[k][1]\\n\\t\\t\\t\\tif (y2-y1)*(y3-y2)+(x2-x1)*(x3-x2) != 0 {\\n\\t\\t\\t\\t\\t// check if it\\'s 90 degrees at point j\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx4, y4 := x1+x3-x2, y1+y3-y2\\n\\t\\t\\t\\tif !positionsMap[fmt.Sprintf(\"%s:%s\", x4, y4)] {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tl, w := math.Sqrt(float64((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))), math.Sqrt(float64((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3)))\\n\\t\\t\\t\\tres = min(res, l*w)\\n\\t\\t\\t\\tfound = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif found {\\n\\t\\treturn res\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc min(x, y float64) float64 {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\n\\treturn y\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minAreaFreeRect(points [][]int) float64 {\\n\\tpositionsMap := make(map[string]bool)\\n\\tfor _, point := range points {\\n\\t\\tx, y := point[0], point[1]\\n\\t\\tpositionsMap[fmt.Sprintf(\"%s:%s\", x, y)] = true\\n\\t}\\n\\tres := math.MaxFloat64\\n\\tfound := false\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tx1, y1 := points[i][0], points[i][1]\\n\\t\\tfor j := 0; j < len(points); j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tx2, y2 := points[j][0], points[j][1]\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n\\t\\t\\t\\tif k == i || k == j {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx3, y3 := points[k][0], points[k][1]\\n\\t\\t\\t\\tif (y2-y1)*(y3-y2)+(x2-x1)*(x3-x2) != 0 {\\n\\t\\t\\t\\t\\t// check if it\\'s 90 degrees at point j\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx4, y4 := x1+x3-x2, y1+y3-y2\\n\\t\\t\\t\\tif !positionsMap[fmt.Sprintf(\"%s:%s\", x4, y4)] {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tl, w := math.Sqrt(float64((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))), math.Sqrt(float64((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3)))\\n\\t\\t\\t\\tres = min(res, l*w)\\n\\t\\t\\t\\tfound = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif found {\\n\\t\\treturn res\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc min(x, y float64) float64 {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\n\\treturn y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506690,
                "title": "javascript-iterate-triangles-to-n-3",
                "content": "```\\nconst isPerpendicular = ([x1, y1], [x2, y2], [x3, y3]) => {       // X.Y = |X| * |Y| * cos(angle)  --> cos(90) = 0\\n    const dot = ( (x2-x1) * (x3-x1) ) + ( (y2-y1) * (y3-y1) );\\n    return dot == 0;\\n}\\n\\nconst calculateArea = ([x1, y1], [x2, y2], [x3, y3]) => {\\n    const a = Math.sqrt( Math.pow((x2-x1), 2) + Math.pow((y2-y1), 2) );\\n    const b = Math.sqrt( Math.pow((x3-x1), 2) + Math.pow((y3-y1), 2) );\\n    return a * b;\\n}\\n\\nconst minAreaFreeRect = points => {\\n\\tif(points.length < 4){  return 0 ;}\\n    const pointsMap = new Map()\\n    for(let [x,y] of points){ \\n        pointsMap.set(40000*x + y, true) ; \\n    }\\n    let min = Infinity;\\n    \\n    for(let [x1, y1] of points){\\n        for(let [x2, y2] of points){\\n            if(x2 != x1 || y2 != y1){                                 // point 2 & 1 are different\\n                for(let [x3, y3] of points){\\n                    const cond31 = x3 != x1 || y3 != y1;              // point 3 & 1 are different\\n                    const cond32 = x3 != x2 || y3 != y2;              // point 3 & 2 are different\\n                    if(cond31 && cond32){\\n                        const x4 = x3 + x2 - x1 ;\\n                        const y4 = y3 + y2 - y1 ;\\n                        const p4 = 40000 *x4 + y4 ;\\n                        if(pointsMap.has(p4)){                                  \\n                            if(isPerpendicular([x1, y1], [x2, y2], [x3, y3])){                     // if angle is 90 degree\\n                                const area = calculateArea([x1, y1], [x2, y2], [x3, y3])\\n                                min = Math.min(min , area)\\n                            }\\n                        } \\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return min == Infinity ? 0 : min; \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst isPerpendicular = ([x1, y1], [x2, y2], [x3, y3]) => {       // X.Y = |X| * |Y| * cos(angle)  --> cos(90) = 0\\n    const dot = ( (x2-x1) * (x3-x1) ) + ( (y2-y1) * (y3-y1) );\\n    return dot == 0;\\n}\\n\\nconst calculateArea = ([x1, y1], [x2, y2], [x3, y3]) => {\\n    const a = Math.sqrt( Math.pow((x2-x1), 2) + Math.pow((y2-y1), 2) );\\n    const b = Math.sqrt( Math.pow((x3-x1), 2) + Math.pow((y3-y1), 2) );\\n    return a * b;\\n}\\n\\nconst minAreaFreeRect = points => {\\n\\tif(points.length < 4){  return 0 ;}\\n    const pointsMap = new Map()\\n    for(let [x,y] of points){ \\n        pointsMap.set(40000*x + y, true) ; \\n    }\\n    let min = Infinity;\\n    \\n    for(let [x1, y1] of points){\\n        for(let [x2, y2] of points){\\n            if(x2 != x1 || y2 != y1){                                 // point 2 & 1 are different\\n                for(let [x3, y3] of points){\\n                    const cond31 = x3 != x1 || y3 != y1;              // point 3 & 1 are different\\n                    const cond32 = x3 != x2 || y3 != y2;              // point 3 & 2 are different\\n                    if(cond31 && cond32){\\n                        const x4 = x3 + x2 - x1 ;\\n                        const y4 = y3 + y2 - y1 ;\\n                        const p4 = 40000 *x4 + y4 ;\\n                        if(pointsMap.has(p4)){                                  \\n                            if(isPerpendicular([x1, y1], [x2, y2], [x3, y3])){                     // if angle is 90 degree\\n                                const area = calculateArea([x1, y1], [x2, y2], [x3, y3])\\n                                min = Math.min(min , area)\\n                            }\\n                        } \\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return min == Infinity ? 0 : min; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 494733,
                "title": "javascript-iterate-triangle",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    let area = Infinity , pointsMap = {} , len = points.length;\\n    \\n    //corner case\\n    if(len < 4) return 0;\\n    \\n    //points map\\n    for(let point of points){\\n        const [x , y ] = point;\\n        pointsMap[40000*x + y] = true;\\n    }\\n    \\n    for(let pointOne of points){\\n        const [x1 , y1] = pointOne;\\n        for(let pointTwo of points){\\n            if(pointTwo != pointOne){\\n                const [x2 , y2] = pointTwo;\\n                for(let pointThree of points){\\n                    if(pointThree != pointTwo){\\n                        const [x3 , y3] = pointThree;\\n                        //prove it\\'s triangle\\n                        let triangleVal = (y2-y1)*(y3-y1) + (x2-x1)*(x3-x1)\\n                        if(triangleVal === 0){\\n                            let y4 = y2 + y3 - y1;\\n                            let x4 = x2 + x3 - x1;\\n                            if(pointsMap[40000*x4 + y4]){\\n                                let curArea = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)) * Math.sqrt((x3-x1)*(x3-x1) + (y3-y1)*(y3-y1));\\n                                if(curArea !== 0) area = Math.min(area , curArea);\\n                            }\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return area === Infinity ? 0 : area;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    let area = Infinity , pointsMap = {} , len = points.length;\\n    \\n    //corner case\\n    if(len < 4) return 0;\\n    \\n    //points map\\n    for(let point of points){\\n        const [x , y ] = point;\\n        pointsMap[40000*x + y] = true;\\n    }\\n    \\n    for(let pointOne of points){\\n        const [x1 , y1] = pointOne;\\n        for(let pointTwo of points){\\n            if(pointTwo != pointOne){\\n                const [x2 , y2] = pointTwo;\\n                for(let pointThree of points){\\n                    if(pointThree != pointTwo){\\n                        const [x3 , y3] = pointThree;\\n                        //prove it\\'s triangle\\n                        let triangleVal = (y2-y1)*(y3-y1) + (x2-x1)*(x3-x1)\\n                        if(triangleVal === 0){\\n                            let y4 = y2 + y3 - y1;\\n                            let x4 = x2 + x3 - x1;\\n                            if(pointsMap[40000*x4 + y4]){\\n                                let curArea = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)) * Math.sqrt((x3-x1)*(x3-x1) + (y3-y1)*(y3-y1));\\n                                if(curArea !== 0) area = Math.min(area , curArea);\\n                            }\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return area === Infinity ? 0 : area;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466570,
                "title": "python-faster-than-90-less-use-than-100-with-some-explanation",
                "content": "```\\nimport math\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        size = len(points)\\n        dic = {}\\n        res = float(\\'inf\\')\\n        for i in range(size):\\n            point1 = points[i]\\n            for j in range(i+1,size):\\n                point2 = points[j]\\n                x = point1[0] - point2[0]\\n                y = point1[1] - point2[1]\\n                if x < 0:\\n                    x = -x\\n                    y = -y\\n                    pair = [point2, point1]\\n                else:   pair = [point1, point2]\\n                vec = (x,y)\\n                if vec not in dic:\\n                    dic[vec] = [pair]\\n                else:\\n                    dic[vec].append(pair)\\n            #end for\\n        #end for\\n        \\n        ### Above finding all pairs point that have same maginitude vector\\n        \\n        vecs = dic.keys()\\n        for vec in vecs:\\n            pairs = dic[vec]\\n            size = len(pairs)\\n            if size < 2:\\n                continue    #   if there is only one pair points is not enough to\\n                            #   construct a rectangle\\n            #   Looping the those pairs point\\n            for i in range(size):\\n                p1, p2 = pairs[i][0], pairs[i][1]\\n                for j in range(i+1,size):\\n                    p3 = pairs[j][0]\\n                    x = p1[0] - p3[0]\\n                    y = p1[1] - p3[1]\\n                    #   check there is a right angle\\n                    if (x * vec[0] + y * vec[1]) != 0:    \\n                        continue\\n                    length = math.sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2)\\n                    width = math.sqrt((p1[0]-p3[0])**2+(p1[1]-p3[1])**2)\\n                    area = length * width\\n                    res = min(res,area)\\n        return res if res!=float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        size = len(points)\\n        dic = {}\\n        res = float(\\'inf\\')\\n        for i in range(size):\\n            point1 = points[i]\\n            for j in range(i+1,size):\\n                point2 = points[j]\\n                x = point1[0] - point2[0]\\n                y = point1[1] - point2[1]\\n                if x < 0:\\n                    x = -x\\n                    y = -y\\n                    pair = [point2, point1]\\n                else:   pair = [point1, point2]\\n                vec = (x,y)\\n                if vec not in dic:\\n                    dic[vec] = [pair]\\n                else:\\n                    dic[vec].append(pair)\\n            #end for\\n        #end for\\n        \\n        ### Above finding all pairs point that have same maginitude vector\\n        \\n        vecs = dic.keys()\\n        for vec in vecs:\\n            pairs = dic[vec]\\n            size = len(pairs)\\n            if size < 2:\\n                continue    #   if there is only one pair points is not enough to\\n                            #   construct a rectangle\\n            #   Looping the those pairs point\\n            for i in range(size):\\n                p1, p2 = pairs[i][0], pairs[i][1]\\n                for j in range(i+1,size):\\n                    p3 = pairs[j][0]\\n                    x = p1[0] - p3[0]\\n                    y = p1[1] - p3[1]\\n                    #   check there is a right angle\\n                    if (x * vec[0] + y * vec[1]) != 0:    \\n                        continue\\n                    length = math.sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2)\\n                    width = math.sqrt((p1[0]-p3[0])**2+(p1[1]-p3[1])**2)\\n                    area = length * width\\n                    res = min(res,area)\\n        return res if res!=float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420870,
                "title": "wrong-test-case",
                "content": "I think there is a wrong test case. \\n![image](https://assets.leetcode.com/users/dakzholov/image_1572897490.png)\\nHere we see that the points (3, 1) (2, 1) (0, 1) (0,2) are in the given list. But the expected answer is 2.0\\n\\n![image](https://assets.leetcode.com/users/dakzholov/image_1572897560.png)\\nIn case I include only thouse points, the system gives 3.0 as the answer.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "I think there is a wrong test case. \\n![image](https://assets.leetcode.com/users/dakzholov/image_1572897490.png)\\nHere we see that the points (3, 1) (2, 1) (0, 1) (0,2) are in the given list. But the expected answer is 2.0\\n\\n![image](https://assets.leetcode.com/users/dakzholov/image_1572897560.png)\\nIn case I include only thouse points, the system gives 3.0 as the answer.\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 385835,
                "title": "swift-984-ms-faster-than-100-00-21-5-mb-less-than-100-00-o-n2-modular-solution",
                "content": "```\\nimport Foundation\\n\\nclass Solution {\\n    struct Diagonal {\\n        let from : (Int,Int)\\n        let to : (Int,Int)\\n        let length :Double\\n        var md : (Double,Double) {\\n            let xLength = from.0 + to.0\\n            let yLength = from.1 + to.1\\n            return (Double(xLength)/2,Double(yLength)/2)\\n            \\n        }\\n       \\n    }\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        \\n        guard points.count >= 4 else { return 0 }\\n        \\n        let MAX_AREA :Double = Double.greatestFiniteMagnitude\\n        \\n        var minArea :Double = MAX_AREA\\n        \\n        let ds = getDiagonals(points)\\n        \\n        for i in 0 ..< ds.count  {\\n            \\n            let md1 = ds[i].md\\n            \\n            for j in i+1 ..< ds.count  {\\n                \\n                let md2 = ds[j].md\\n               \\n               \\n                \\n                \\n                if md1.0 == md2.0 && md1.1 == md2.1 && ds[i].length == ds[j].length  {\\n                    \\n                   \\n                    let sideLength1 = calDistanceBetweenTwoPoints(ds[j].from,ds[i].from)\\n                    let sideLength2 = calDistanceBetweenTwoPoints(ds[j].from,ds[i].to)\\n                    \\n                    let area = sideLength1 * sideLength2\\n                    \\n                    \\n                    if area < minArea {\\n                        \\n                        minArea = area\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return minArea == MAX_AREA ? 0 : minArea\\n    }\\n    func getDiagonals(_ points :[[Int]] ) -> [Diagonal] {\\n        \\n        var ds = [Diagonal]()\\n        \\n        for i in 0 ..< points.count {\\n            \\n            let p1 = (points[i][0],points[i][1])\\n            \\n            for j in i+1 ..< points.count  {\\n                \\n                \\n                \\n                let p2 = (points[j][0],points[j][1])\\n                \\n                let d = Diagonal(from:p1,to:p2,length:calDistanceBetweenTwoPoints(p1, p2))\\n                \\n                ds.append(d)\\n                \\n            }\\n            \\n        }\\n        \\n        return ds\\n        \\n        \\n    }\\n    func calDistanceBetweenTwoPoints(_ p1:(Int,Int),_ p2:(Int,Int) ) -> Double {\\n        \\n        let dx = p2.0 - p1.0\\n        let dy = p2.1 - p1.1\\n        \\n        \\n        return Double((dy*dy)+(dx*dx)).squareRoot()\\n        \\n    }\\n   \\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    struct Diagonal {\\n        let from : (Int,Int)\\n        let to : (Int,Int)\\n        let length :Double\\n        var md : (Double,Double) {\\n            let xLength = from.0 + to.0\\n            let yLength = from.1 + to.1\\n            return (Double(xLength)/2,Double(yLength)/2)\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 363487,
                "title": "java-55-ms-faster-than-23-33-37-1-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Map<String, List<int[]>>> ps = new HashMap<>();\\n        int n = points.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                String c = (points[i][0] + points[j][0]) + \" \" + (points[i][1] + points[j][1]);\\n                int r = r2(points[i], points[j]);\\n                ps.computeIfAbsent(r, map -> new HashMap<>()).computeIfAbsent(c, list -> new ArrayList<>()).add(new int[]{points[i][0], points[i][1], points[j][0], points[j][1]});\\n            }\\n        }\\n        double ans = Double.MAX_VALUE;\\n        for (Map<String, List<int[]>> map : ps.values()) {\\n            for (List<int[]> list : map.values()) {\\n                for (int i = 0; i < list.size(); ++i) {\\n                    int[] p1 = list.get(i);\\n                    int[] P = new int[]{p1[0], p1[1]};\\n                    for (int j = i + 1; j < list.size(); ++j) {\\n                        int[] p2 = list.get(j);\\n                        double area = Math.sqrt(r2(P, new int[]{p2[0], p2[1]})) * Math.sqrt(r2(P, new int[]{p2[2], p2[3]}));\\n                        ans = Math.min(ans, area);\\n                    }\\n                }\\n            }\\n        }\\n        return Double.compare(ans, Double.MAX_VALUE) == 0 ? 0 : ans;\\n    }\\n    \\n    private int r2(int[] a, int[] b) {\\n        return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Map<String, List<int[]>>> ps = new HashMap<>();\\n        int n = points.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                String c = (points[i][0] + points[j][0]) + \" \" + (points[i][1] + points[j][1]);\\n                int r = r2(points[i], points[j]);\\n                ps.computeIfAbsent(r, map -> new HashMap<>()).computeIfAbsent(c, list -> new ArrayList<>()).add(new int[]{points[i][0], points[i][1], points[j][0], points[j][1]});\\n            }\\n        }\\n        double ans = Double.MAX_VALUE;\\n        for (Map<String, List<int[]>> map : ps.values()) {\\n            for (List<int[]> list : map.values()) {\\n                for (int i = 0; i < list.size(); ++i) {\\n                    int[] p1 = list.get(i);\\n                    int[] P = new int[]{p1[0], p1[1]};\\n                    for (int j = i + 1; j < list.size(); ++j) {\\n                        int[] p2 = list.get(j);\\n                        double area = Math.sqrt(r2(P, new int[]{p2[0], p2[1]})) * Math.sqrt(r2(P, new int[]{p2[2], p2[3]}));\\n                        ans = Math.min(ans, area);\\n                    }\\n                }\\n            }\\n        }\\n        return Double.compare(ans, Double.MAX_VALUE) == 0 ? 0 : ans;\\n    }\\n    \\n    private int r2(int[] a, int[] b) {\\n        return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349229,
                "title": "java-map-solution",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<String, Map<Double, List<int[]>>> map = new HashMap<>();\\n        int n = points.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                double centerX = ((double)points[i][0] + points[j][0]) / 2;\\n                double centerY = ((double)points[i][1] + points[j][1]) / 2;\\n                double dist = ((double)points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                String str = centerX + \" \" + centerY;\\n                map.putIfAbsent(str, new HashMap<>());\\n                map.get(str).putIfAbsent(dist, new ArrayList<>());\\n                map.get(str).get(dist).add(points[i]); \\n                map.get(str).get(dist).add(points[j]);\\n            }\\n        }\\n        double min = Double.MAX_VALUE;\\n        for (String c : map.keySet()) {\\n            for (double d : map.get(c).keySet()) {\\n                List<int[]> list = map.get(c).get(d);\\n                if (list.size() >= 4) {\\n                    for (int i = 0; i + 2 < list.size(); i += 2) {\\n                        for (int j = i + 2; j + 1 < list.size(); j += 2) {\\n                            double dist1 = Math.sqrt(((double)list.get(i)[0] - list.get(j)[0]) * ((double)list.get(i)[0] - list.get(j)[0]) + ((double)list.get(i)[1] - list.get(j)[1]) * ((double)list.get(i)[1] - list.get(j)[1]));\\n                            double dist2 = Math.sqrt(((double)list.get(i)[0] - list.get(j + 1)[0]) * ((double)list.get(i)[0] - list.get(j + 1)[0]) + ((double)list.get(i)[1] - list.get(j + 1)[1]) * ((double)list.get(i)[1] - list.get(j + 1)[1]));\\n                            min = Math.min(dist1 * dist2, min);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<String, Map<Double, List<int[]>>> map = new HashMap<>();\\n        int n = points.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                double centerX = ((double)points[i][0] + points[j][0]) / 2;\\n                double centerY = ((double)points[i][1] + points[j][1]) / 2;\\n                double dist = ((double)points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                String str = centerX + \" \" + centerY;\\n                map.putIfAbsent(str, new HashMap<>());\\n                map.get(str).putIfAbsent(dist, new ArrayList<>());\\n                map.get(str).get(dist).add(points[i]); \\n                map.get(str).get(dist).add(points[j]);\\n            }\\n        }\\n        double min = Double.MAX_VALUE;\\n        for (String c : map.keySet()) {\\n            for (double d : map.get(c).keySet()) {\\n                List<int[]> list = map.get(c).get(d);\\n                if (list.size() >= 4) {\\n                    for (int i = 0; i + 2 < list.size(); i += 2) {\\n                        for (int j = i + 2; j + 1 < list.size(); j += 2) {\\n                            double dist1 = Math.sqrt(((double)list.get(i)[0] - list.get(j)[0]) * ((double)list.get(i)[0] - list.get(j)[0]) + ((double)list.get(i)[1] - list.get(j)[1]) * ((double)list.get(i)[1] - list.get(j)[1]));\\n                            double dist2 = Math.sqrt(((double)list.get(i)[0] - list.get(j + 1)[0]) * ((double)list.get(i)[0] - list.get(j + 1)[0]) + ((double)list.get(i)[1] - list.get(j + 1)[1]) * ((double)list.get(i)[1] - list.get(j + 1)[1]));\\n                            min = Math.min(dist1 * dist2, min);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344351,
                "title": "fast-c-solution-faster-than-94-74-of-c-online-submissions",
                "content": "Runtime: 20 ms, faster than 94.74% of C++ online submissions for Minimum Area Rectangle II.\\nMemory Usage: 14.9 MB, less than 62.34% of C++ online submissions for Minimum Area Rectangle II.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> Point;\\n    //For points a and b, define a < b if and only if\\n    // a.first < b.first or else if a.first == b.first then if a.second < b.second.\\n    inline long ComputeSquareOfDistance(const Point a, const Point b) {\\n        long d1 = a.first - b.first;\\n        long d2 = a.second - b.second;\\n        return d1 * d1 + d2 * d2;\\n    }\\n    inline long ComputeAreaOfRectangle(Point a0, Point a1, Point b0, Point b1) {\\n        long d1 = ComputeSquareOfDistance(a0, a1);\\n        long d2 = ComputeSquareOfDistance(a0, b0);\\n        assert(d1 == ComputeSquareOfDistance(b0, b1));\\n        assert(d2 == ComputeSquareOfDistance(a1, b1));\\n        return sqrt(d1 * d2);\\n    }\\n    //Assumes that a0 <= a1 and b0 <= b1.\\n    inline bool DoesFormRectaangle(Point a0, Point a1, Point b0, Point b1) {\\n        long square_of_diagonal1_dist = ComputeSquareOfDistance(a0, b1);\\n        long square_of_diagonal2_dist = ComputeSquareOfDistance(a1, b0);\\n        return square_of_diagonal1_dist == square_of_diagonal2_dist;\\n    }\\n    inline Point GetVector(Point &p0, Point &p1) {\\n        if (p0.first > p1.first || p0.first == p1.first && p1.first < p0.first)\\n            swap(p0, p1);\\n        return {p1.first - p0.first, p1.second - p0.second};\\n    }\\n    struct PointHash {\\n        size_t operator()(const Point &p) const {\\n            return hash<int>{}(p.first) ^ (hash<int>{}(p.second));\\n        }\\n    };\\n    void FillInVectorToPointsMap(vector<Point>& points, unordered_multimap<Point, pair<Point*, Point*>, PointHash> &vec_to_points) {\\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = i + 1; j < points.size(); ++j) {\\n                Point p0 = points[i], p1 = points[j];\\n                Point vec = GetVector(p0, p1);\\n                //Map vec back to the points that created it, where we insert it\\n                // so that *ptr0 <= *ptr1.\\n                Point * ptr0 = &(points[i]), * ptr1 = &(points[j]);\\n                if (p0 != points[i])\\n                    swap(ptr0, ptr1);\\n                vec_to_points.insert({vec, make_pair(ptr0, ptr1)});\\n            }\\n        }\\n        return ;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        vector<Point> actual_points;\\n        for (const vector<int> &v : points)\\n            actual_points.push_back({v[0], v[1]});\\n        unordered_multimap<Point, pair<Point*, Point*>, PointHash> vec_to_points;\\n        FillInVectorToPointsMap(actual_points, vec_to_points);\\n        double min_area = numeric_limits<double>::max();\\n\\n        while (vec_to_points.size() > 0) {\\n            auto it_start = vec_to_points.begin();\\n            Point vec = it_start->first;\\n            auto range = vec_to_points.equal_range(vec);\\n            if (distance(range.first, range.second) == 1) { //If vec only has 1 pair of points associated with it then move on\\n                vec_to_points.erase(it_start);\\n                continue;\\n            }\\n\\t\\t\\t//We now go through every pair of elements in this range (where each element is a pair of points).\\n            for (auto it = range.first; it != range.second; ) {\\n                auto second_it = it;\\n                ++second_it;\\n                if (second_it == range.second)\\n                    break;\\n                pair<Point *, Point *> a_ptrs = it->second;\\n                Point a0 = *(a_ptrs.first), a1 = *(a_ptrs.second);\\n                for (auto it2 = second_it; it2 != range.second; ++it2) {\\n                    pair<Point *, Point *> b_ptrs = it2->second;\\n                    Point b0 = *(b_ptrs.first), b1 = *(b_ptrs.second);\\n                    if (DoesFormRectaangle(a0, a1, b0, b1)) {\\n                        double area_of_rectangle = ComputeAreaOfRectangle(a0, a1, b0, b1);\\n                        if (area_of_rectangle < min_area)\\n                            min_area = area_of_rectangle;\\n                    }\\n                }\\n                it = second_it;\\n            }\\n            \\n            //Erase the points just considered.\\n            for (auto it = range.first; it != range.second; ) {\\n                auto next_it = it;\\n                ++next_it;\\n                vec_to_points.erase(it);\\n                it = next_it;\\n            }\\n        }\\n        if (min_area == numeric_limits<double>::max())\\n            return 0;\\n        return min_area;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> Point;\\n    //For points a and b, define a < b if and only if\\n    // a.first < b.first or else if a.first == b.first then if a.second < b.second.\\n    inline long ComputeSquareOfDistance(const Point a, const Point b) {\\n        long d1 = a.first - b.first;\\n        long d2 = a.second - b.second;\\n        return d1 * d1 + d2 * d2;\\n    }\\n    inline long ComputeAreaOfRectangle(Point a0, Point a1, Point b0, Point b1) {\\n        long d1 = ComputeSquareOfDistance(a0, a1);\\n        long d2 = ComputeSquareOfDistance(a0, b0);\\n        assert(d1 == ComputeSquareOfDistance(b0, b1));\\n        assert(d2 == ComputeSquareOfDistance(a1, b1));\\n        return sqrt(d1 * d2);\\n    }\\n    //Assumes that a0 <= a1 and b0 <= b1.\\n    inline bool DoesFormRectaangle(Point a0, Point a1, Point b0, Point b1) {\\n        long square_of_diagonal1_dist = ComputeSquareOfDistance(a0, b1);\\n        long square_of_diagonal2_dist = ComputeSquareOfDistance(a1, b0);\\n        return square_of_diagonal1_dist == square_of_diagonal2_dist;\\n    }\\n    inline Point GetVector(Point &p0, Point &p1) {\\n        if (p0.first > p1.first || p0.first == p1.first && p1.first < p0.first)\\n            swap(p0, p1);\\n        return {p1.first - p0.first, p1.second - p0.second};\\n    }\\n    struct PointHash {\\n        size_t operator()(const Point &p) const {\\n            return hash<int>{}(p.first) ^ (hash<int>{}(p.second));\\n        }\\n    };\\n    void FillInVectorToPointsMap(vector<Point>& points, unordered_multimap<Point, pair<Point*, Point*>, PointHash> &vec_to_points) {\\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = i + 1; j < points.size(); ++j) {\\n                Point p0 = points[i], p1 = points[j];\\n                Point vec = GetVector(p0, p1);\\n                //Map vec back to the points that created it, where we insert it\\n                // so that *ptr0 <= *ptr1.\\n                Point * ptr0 = &(points[i]), * ptr1 = &(points[j]);\\n                if (p0 != points[i])\\n                    swap(ptr0, ptr1);\\n                vec_to_points.insert({vec, make_pair(ptr0, ptr1)});\\n            }\\n        }\\n        return ;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        vector<Point> actual_points;\\n        for (const vector<int> &v : points)\\n            actual_points.push_back({v[0], v[1]});\\n        unordered_multimap<Point, pair<Point*, Point*>, PointHash> vec_to_points;\\n        FillInVectorToPointsMap(actual_points, vec_to_points);\\n        double min_area = numeric_limits<double>::max();\\n\\n        while (vec_to_points.size() > 0) {\\n            auto it_start = vec_to_points.begin();\\n            Point vec = it_start->first;\\n            auto range = vec_to_points.equal_range(vec);\\n            if (distance(range.first, range.second) == 1) { //If vec only has 1 pair of points associated with it then move on\\n                vec_to_points.erase(it_start);\\n                continue;\\n            }\\n\\t\\t\\t//We now go through every pair of elements in this range (where each element is a pair of points).\\n            for (auto it = range.first; it != range.second; ) {\\n                auto second_it = it;\\n                ++second_it;\\n                if (second_it == range.second)\\n                    break;\\n                pair<Point *, Point *> a_ptrs = it->second;\\n                Point a0 = *(a_ptrs.first), a1 = *(a_ptrs.second);\\n                for (auto it2 = second_it; it2 != range.second; ++it2) {\\n                    pair<Point *, Point *> b_ptrs = it2->second;\\n                    Point b0 = *(b_ptrs.first), b1 = *(b_ptrs.second);\\n                    if (DoesFormRectaangle(a0, a1, b0, b1)) {\\n                        double area_of_rectangle = ComputeAreaOfRectangle(a0, a1, b0, b1);\\n                        if (area_of_rectangle < min_area)\\n                            min_area = area_of_rectangle;\\n                    }\\n                }\\n                it = second_it;\\n            }\\n            \\n            //Erase the points just considered.\\n            for (auto it = range.first; it != range.second; ) {\\n                auto next_it = it;\\n                ++next_it;\\n                vec_to_points.erase(it);\\n                it = next_it;\\n            }\\n        }\\n        if (min_area == numeric_limits<double>::max())\\n            return 0;\\n        return min_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342888,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public double MinAreaFreeRect(int[][] points)\\n    {\\n        if (points.Length < 4) return 0.0;\\n        double result = double.MaxValue;\\n        var dict = new Dictionary<string, List<int[]>>();\\n        for (int i = 0; i < points.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < points.Length; j++)\\n            {\\n                int[] p1 = points[j], p2 = points[i];\\n                double dis = Distance(p1, p2), centerX = (double)(p1[0] + p2[0]) / 2, centerY = (double)(p1[1] + p2[1]) / 2;\\n                var key = dis + \":\" + centerX + \":\" + centerY;\\n                if (!dict.ContainsKey(key)) dict[key] = new List<int[]>();\\n                dict[key].Add(new int[] { i, j });\\n            }\\n        }\\n\\n        foreach (List<int[]> list in dict.Values)\\n        {\\n            for (int i = 0; i < list.Count - 1; i++)                                                                                              \\n            {\\n                for (int j = i + 1; j < list.Count; j++)\\n                {\\n                    int p1 = list[i][0], p2 = list[j][0], p3 = list[j][1];\\n                    result = Math.Min(result, Distance(points[p1], points[p2]) * Distance(points[p1], points[p3]));\\n                }\\n            }\\n        }\\n\\n        return result == double.MaxValue ? 0.0 : result;\\n    }\\n\\n    private double Distance(int[] p1, int[] p2)\\n    {\\n        return Math.Sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public double MinAreaFreeRect(int[][] points)\\n    {\\n        if (points.Length < 4) return 0.0;\\n        double result = double.MaxValue;\\n        var dict = new Dictionary<string, List<int[]>>();\\n        for (int i = 0; i < points.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < points.Length; j++)\\n            {\\n                int[] p1 = points[j], p2 = points[i];\\n                double dis = Distance(p1, p2), centerX = (double)(p1[0] + p2[0]) / 2, centerY = (double)(p1[1] + p2[1]) / 2;\\n                var key = dis + \":\" + centerX + \":\" + centerY;\\n                if (!dict.ContainsKey(key)) dict[key] = new List<int[]>();\\n                dict[key].Add(new int[] { i, j });\\n            }\\n        }\\n\\n        foreach (List<int[]> list in dict.Values)\\n        {\\n            for (int i = 0; i < list.Count - 1; i++)                                                                                              \\n            {\\n                for (int j = i + 1; j < list.Count; j++)\\n                {\\n                    int p1 = list[i][0], p2 = list[j][0], p3 = list[j][1];\\n                    result = Math.Min(result, Distance(points[p1], points[p2]) * Distance(points[p1], points[p3]));\\n                }\\n            }\\n        }\\n\\n        return result == double.MaxValue ? 0.0 : result;\\n    }\\n\\n    private double Distance(int[] p1, int[] p2)\\n    {\\n        return Math.Sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248447,
                "title": "java-solution-slow-and-clean",
                "content": "```\\nclass Solution {\\n    private double minArea = Double.MAX_VALUE;\\n    \\n    public double minAreaFreeRect(int[][] points) {\\n        minAreaRectHelper(points, new ArrayList<Point>(), 0);\\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    private void minAreaRectHelper(int[][] points, List<Point> pointList, int i) {\\n        if (pointList.size() == 4) {\\n            double area = area(pointList);\\n            if (area > 0) {\\n                minArea = Math.min(minArea, area);\\n            }\\n            return;\\n        }\\n        if (i == points.length) {\\n            return;\\n        }\\n        \\n        for (int j = i; j < points.length; j++) {\\n            pointList.add(new Point(points[j][0], points[j][1]));\\n            minAreaRectHelper(points, pointList, j + 1);\\n            pointList.remove(pointList.size() - 1);\\n        }\\n    }\\n    \\n    private double area(List<Point> points) {\\n        Map<Integer, Integer> mapX = new HashMap<>();\\n        Map<Integer, Integer> mapY = new HashMap<>();\\n        \\n        // There shouldn\\'t be more than 2 points on a straight line\\n        for (Point point : points) {\\n            int valX = mapX.containsKey(point.x) ? mapX.get(point.x) : 0;\\n            int valY = mapY.containsKey(point.y) ? mapY.get(point.y) : 0;\\n            if (valX == 2 || valY == 2) {\\n                return 0;\\n            }\\n            mapX.put(point.x, valX + 1);\\n            mapY.put(point.y, valY + 1);\\n        }\\n        \\n        List<Double> distances = new ArrayList<>();\\n        \\n        for (int i = 0; i < points.size() - 1; i++) {\\n            for (int j = i + 1; j < points.size(); j++) {\\n                double distance = distance(points.get(i), points.get(j));\\n                if (!distances.contains(distance)) {\\n                    distances.add(distance);\\n                }\\n            }\\n        }\\n        \\n        Collections.sort(distances);\\n        \\n        // There should not be more than 3 distinct distances (length, breadth, diagonal)\\n        if (distances.size() > 3) {\\n            return 0;\\n        }\\n        // Square\\n        if (distances.size() == 2 && ((distances.get(0) * 2) == distances.get(1))) {\\n            return distances.get(0);\\n        }\\n        // Non-square Rectangle\\n        if (distances.size() == 3 && (distances.get(0) + distances.get(1) == distances.get(2))) {\\n            return Math.sqrt(distances.get(0)) * Math.sqrt(distances.get(1));\\n        }\\n        return 0;\\n    }\\n    \\n    private double distance(Point p1, Point p2) {\\n        int diffX = Math.abs(p1.x - p2.x);\\n        int diffY = Math.abs(p1.y - p2.y);\\n        return Math.pow(diffX, 2) + Math.pow(diffY, 2);\\n    }\\n}\\n\\nclass Point {\\n    int x;\\n    int y;\\n    \\n    Point(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n```\\n\\n**A Better and Faster Solution**\\nhttps://leetcode.com/problems/minimum-area-rectangle-ii/discuss/209117/Short-Java-Solution-!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private double minArea = Double.MAX_VALUE;\\n    \\n    public double minAreaFreeRect(int[][] points) {\\n        minAreaRectHelper(points, new ArrayList<Point>(), 0);\\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    private void minAreaRectHelper(int[][] points, List<Point> pointList, int i) {\\n        if (pointList.size() == 4) {\\n            double area = area(pointList);\\n            if (area > 0) {\\n                minArea = Math.min(minArea, area);\\n            }\\n            return;\\n        }\\n        if (i == points.length) {\\n            return;\\n        }\\n        \\n        for (int j = i; j < points.length; j++) {\\n            pointList.add(new Point(points[j][0], points[j][1]));\\n            minAreaRectHelper(points, pointList, j + 1);\\n            pointList.remove(pointList.size() - 1);\\n        }\\n    }\\n    \\n    private double area(List<Point> points) {\\n        Map<Integer, Integer> mapX = new HashMap<>();\\n        Map<Integer, Integer> mapY = new HashMap<>();\\n        \\n        // There shouldn\\'t be more than 2 points on a straight line\\n        for (Point point : points) {\\n            int valX = mapX.containsKey(point.x) ? mapX.get(point.x) : 0;\\n            int valY = mapY.containsKey(point.y) ? mapY.get(point.y) : 0;\\n            if (valX == 2 || valY == 2) {\\n                return 0;\\n            }\\n            mapX.put(point.x, valX + 1);\\n            mapY.put(point.y, valY + 1);\\n        }\\n        \\n        List<Double> distances = new ArrayList<>();\\n        \\n        for (int i = 0; i < points.size() - 1; i++) {\\n            for (int j = i + 1; j < points.size(); j++) {\\n                double distance = distance(points.get(i), points.get(j));\\n                if (!distances.contains(distance)) {\\n                    distances.add(distance);\\n                }\\n            }\\n        }\\n        \\n        Collections.sort(distances);\\n        \\n        // There should not be more than 3 distinct distances (length, breadth, diagonal)\\n        if (distances.size() > 3) {\\n            return 0;\\n        }\\n        // Square\\n        if (distances.size() == 2 && ((distances.get(0) * 2) == distances.get(1))) {\\n            return distances.get(0);\\n        }\\n        // Non-square Rectangle\\n        if (distances.size() == 3 && (distances.get(0) + distances.get(1) == distances.get(2))) {\\n            return Math.sqrt(distances.get(0)) * Math.sqrt(distances.get(1));\\n        }\\n        return 0;\\n    }\\n    \\n    private double distance(Point p1, Point p2) {\\n        int diffX = Math.abs(p1.x - p2.x);\\n        int diffY = Math.abs(p1.y - p2.y);\\n        return Math.pow(diffX, 2) + Math.pow(diffY, 2);\\n    }\\n}\\n\\nclass Point {\\n    int x;\\n    int y;\\n    \\n    Point(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245769,
                "title": "o-n-3-method-c",
                "content": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nstruct myHash \\n{\\n    size_t operator()(pair<int, int> __val) const\\n    {\\n        return static_cast<size_t>(__val.first * 101 + __val.second);\\n    }\\n};\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        //\\u8FD9\\u9898\\u7684question \\u662F\\u7ED9\\u4F60\\u4E00\\u4E9B\\u70B9,\\u5982\\u4F55\\u627E\\u5230\\u6700\\u5C0F\\u7684\\u77E9\\u5F62\\u5462,\\u8FD9\\u4E2A\\u95EE\\u9898,\\u6709\\u70B9\\u96BE,\\u9700\\u8981\\u6211\\u4EEC\\u82B1\\u5927\\u91CF\\u7684\\u65F6\\u95F4\\u53BB\\u601D\\u8003\\u95EE\\u9898.\\n        //\\u5982\\u4F55\\u505A\\u5230\\u4E00\\u4E2A\\u6280\\u672F\\u7537\\u662F\\u4E00\\u79CD\\u5B66\\u95EE\\n        //\\u8003\\u8651\\u5230\\u4E00\\u4E2A\\u5E73\\u884C\\u56DB\\u8FB9\\u5F62\\u95EE\\u9898,\\n        //\\u6211\\u4EEC\\u6709   \\u5BF9\\u4E8E\\u5BF9\\u9876\\u70B9(p2,p3) and (p1,p4) \\u6211\\u4EEC\\u6709 p1+p4 = p2+p3  \\u53EF\\u4EE5\\u4ECE\\u5411\\u91CF\\u89D2\\u5EA6\\u6765\\u89E3\\u91CA p4 = p2+p3-p1\\n        // \\u5224\\u65AD\\u6211\\u4EEC\\u7684\\u811A\\u662F\\u5426\\u662F\\u76F4\\u89D2\\u7684\\u64CD\\u4F5C,\\u4E5F\\u975E\\u5E38\\u7684\\u65B9\\u4FBF\\u6211\\u4EEC\\u53EA\\u9700\\u5224\\u65AD,(p2-p1).(p3-p1) = 0 \\u5373\\u53EF\\n        // \\u5176\\u4ED6\\u7684\\u65B9\\u6CD5\\u662F\\u5173\\u4E8Eiterate centers\\n        //key1  --->  radicus   key2--->center  val-----> all point satisfied this question\\n        \\n        int N = points.size();\\n        \\n        unordered_set<pair<int,int>,myHash > sets;\\n        for(int i = 0;i<N;i++)\\n        {\\n            sets.insert(pair<int,int>(points[i][0],points[i][1]));\\n        }\\n        double ans = INT_MAX;\\n        //fix one point the other points is oppsite point\\n        for(int  i = 0;i<N;i++)\\n        {\\n            auto p1 = pair<int,int>(points[i][0],points[i][1]);\\n            for(int j = 0;j<N;j++)\\n            {\\n                if(j==i)\\n                    continue;\\n                auto p2 = pair<int,int>(points[j][0],points[j][1]);\\n                for(int k = j+1;k<N;k++)\\n                {\\n                    if(k ==i)\\n                    {\\n                        continue;\\n                    }\\n                    auto p3 = pair<int,int>(points[k][0],points[k][1]);\\n                    pair<int,int> p4;\\n                    p4.first = p2.first+p3.first-p1.first;\\n                    p4.second = p2.second+p3.second-p1.second;\\n                    //\\u6784\\u6210\\u5E73\\u884C\\u56DB\\u8FB9\\u5F62\\n                    if(sets.count(p4))\\n                    {\\n                        pair<int,int> l1,l2;\\n                        l1.first = p1.first-p2.first;\\n                        l2.first = p1.first-p3.first;\\n                        l1.second = p1.second-p2.second;\\n                        l2.second = p1.second-p3.second;\\n                        int degree = l1.first*l2.first+l1.second*l2.second;\\n                        if(degree == 0)\\n                        {\\n                            double area = longth(l1)*longth(l2);\\n                            ans = ans>area?area:ans;\\n                        }\\n                        \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans == INT_MAX?0:ans;\\n    }\\n    double longth(pair<int,int> & x)\\n    {\\n        return sqrt(x.first*x.first+x.second*x.second);\\n    }\\n        \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nstruct myHash \\n{\\n    size_t operator()(pair<int, int> __val) const\\n    {\\n        return static_cast<size_t>(__val.first * 101 + __val.second);\\n    }\\n};\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        //\\u8FD9\\u9898\\u7684question \\u662F\\u7ED9\\u4F60\\u4E00\\u4E9B\\u70B9,\\u5982\\u4F55\\u627E\\u5230\\u6700\\u5C0F\\u7684\\u77E9\\u5F62\\u5462,\\u8FD9\\u4E2A\\u95EE\\u9898,\\u6709\\u70B9\\u96BE,\\u9700\\u8981\\u6211\\u4EEC\\u82B1\\u5927\\u91CF\\u7684\\u65F6\\u95F4\\u53BB\\u601D\\u8003\\u95EE\\u9898.\\n        //\\u5982\\u4F55\\u505A\\u5230\\u4E00\\u4E2A\\u6280\\u672F\\u7537\\u662F\\u4E00\\u79CD\\u5B66\\u95EE\\n        //\\u8003\\u8651\\u5230\\u4E00\\u4E2A\\u5E73\\u884C\\u56DB\\u8FB9\\u5F62\\u95EE\\u9898,\\n        //\\u6211\\u4EEC\\u6709   \\u5BF9\\u4E8E\\u5BF9\\u9876\\u70B9(p2,p3) and (p1,p4) \\u6211\\u4EEC\\u6709 p1+p4 = p2+p3  \\u53EF\\u4EE5\\u4ECE\\u5411\\u91CF\\u89D2\\u5EA6\\u6765\\u89E3\\u91CA p4 = p2+p3-p1\\n        // \\u5224\\u65AD\\u6211\\u4EEC\\u7684\\u811A\\u662F\\u5426\\u662F\\u76F4\\u89D2\\u7684\\u64CD\\u4F5C,\\u4E5F\\u975E\\u5E38\\u7684\\u65B9\\u4FBF\\u6211\\u4EEC\\u53EA\\u9700\\u5224\\u65AD,(p2-p1).(p3-p1) = 0 \\u5373\\u53EF\\n        // \\u5176\\u4ED6\\u7684\\u65B9\\u6CD5\\u662F\\u5173\\u4E8Eiterate centers\\n        //key1  --->  radicus   key2--->center  val-----> all point satisfied this question\\n        \\n        int N = points.size();\\n        \\n        unordered_set<pair<int,int>,myHash > sets;\\n        for(int i = 0;i<N;i++)\\n        {\\n            sets.insert(pair<int,int>(points[i][0],points[i][1]));\\n        }\\n        double ans = INT_MAX;\\n        //fix one point the other points is oppsite point\\n        for(int  i = 0;i<N;i++)\\n        {\\n            auto p1 = pair<int,int>(points[i][0],points[i][1]);\\n            for(int j = 0;j<N;j++)\\n            {\\n                if(j==i)\\n                    continue;\\n                auto p2 = pair<int,int>(points[j][0],points[j][1]);\\n                for(int k = j+1;k<N;k++)\\n                {\\n                    if(k ==i)\\n                    {\\n                        continue;\\n                    }\\n                    auto p3 = pair<int,int>(points[k][0],points[k][1]);\\n                    pair<int,int> p4;\\n                    p4.first = p2.first+p3.first-p1.first;\\n                    p4.second = p2.second+p3.second-p1.second;\\n                    //\\u6784\\u6210\\u5E73\\u884C\\u56DB\\u8FB9\\u5F62\\n                    if(sets.count(p4))\\n                    {\\n                        pair<int,int> l1,l2;\\n                        l1.first = p1.first-p2.first;\\n                        l2.first = p1.first-p3.first;\\n                        l1.second = p1.second-p2.second;\\n                        l2.second = p1.second-p3.second;\\n                        int degree = l1.first*l2.first+l1.second*l2.second;\\n                        if(degree == 0)\\n                        {\\n                            double area = longth(l1)*longth(l2);\\n                            ans = ans>area?area:ans;\\n                        }\\n                        \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans == INT_MAX?0:ans;\\n    }\\n    double longth(pair<int,int> & x)\\n    {\\n        return sqrt(x.first*x.first+x.second*x.second);\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228883,
                "title": "java-map-solution",
                "content": "s1 -> use y/x as the key\\ns2 -> use what\\'s mentioned in Solution Section, the mid of two points as the key;\\nremember to use Long, as Int will overflow.\\n```\\nclass Solution {\\n\\n    // i != j\\n    private String getKey(int i, int j) {\\n        if (i == 0) {\\n            return \"NaN\";\\n        }\\n        if (j == 0) {\\n            return \"0\";\\n        }\\n        boolean flag = true;\\n        if (i < 0) {\\n            i = -i;\\n            flag = !flag;\\n        }\\n        if (j < 0) {\\n            j = -j;\\n            flag = !flag;\\n        }\\n        int gcd = gcd(i, j);\\n        i = i / gcd;\\n        j = j / gcd;\\n        StringBuilder sb = new StringBuilder();\\n        if (!flag) {\\n            sb.append(\"-\");\\n        }\\n        sb.append(i);\\n        sb.append(\",\");\\n        sb.append(j);\\n        return sb.toString();\\n\\n    }\\n\\n    private int gcd(int i, int j) {\\n        while (j != 0) {\\n            int tmp = j;\\n            j = i % j;\\n            i = tmp;\\n        }\\n        return i;\\n    }\\n\\n    public double minAreaFreeRect(int[][] points) {\\n        return s2(points);\\n    }\\n    \\n    private String getKey2(int[] point1, int[] point2) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(point1[0] + point2[0]);\\n        sb.append(\",\");\\n        sb.append(point1[1] + point2[1]);\\n        return sb.toString();\\n    }\\n    \\n    private double s2(int[][] points) {\\n        if (points.length < 4) {\\n            return 0;\\n        }\\n        Map<String, Map<Long, List<int[]>>> maps = new HashMap<>();\\n        for (int i = 0; i < points.length - 1; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                if (!equal(points[i], points[j])) {\\n                    String key = getKey2(points[i], points[j]);\\n                    long innerKey = dis(points[i], points[j]);\\n                    if (!maps.containsKey(key)) {\\n                        maps.put(key, new HashMap<>());\\n                    }\\n                    if (!maps.get(key).containsKey(innerKey)) {\\n                        maps.get(key).put(innerKey, new ArrayList<>());\\n                    }\\n                    maps.get(key).get(innerKey).add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        double max = 0;\\n        for (Map<Long, List<int[]>> map : maps.values()) {\\n            for (List<int[]> list : map.values()) {\\n                for (int i = 0; i < list.size() - 1; i++) {\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        // list.get(i)[0], list.get(i)[1]\\n                        // list.get(j)[0], list.get(j)[1]\\n\\n                        if (!equal(points[list.get(i)[0]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[0]], points[list.get(j)[1]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[1]])) {\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(j)[1]], points[list.get(j)[0]])) {\\n                                double area = Math.sqrt(dis(points[list.get(i)[0]], points[list.get(j)[1]]) * dis(points[list.get(i)[0]], points[list.get(j)[0]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n            }\\n\\n\\n        }\\n        return max;\\n    }\\n\\n    private double s1(int[][] points) {\\n        if (points.length < 4) {\\n            return 0;\\n        }\\n\\n        Map<String, Map<Long, List<int[]>>> maps = new HashMap<>();\\n        for (int i = 0; i < points.length - 1; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                if (!equal(points[i], points[j])) {\\n                    String key = getKey(points[j][0] - points[i][0], points[j][1] - points[i][1]);\\n                    long innerKey = dis(points[i], points[j]);\\n                    if (!maps.containsKey(key)) {\\n                        maps.put(key, new HashMap<>());\\n                    }\\n                    if (!maps.get(key).containsKey(innerKey)) {\\n                        maps.get(key).put(innerKey, new ArrayList<>());\\n                    }\\n                    maps.get(key).get(innerKey).add(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        double max = 0;\\n        for (Map<Long, List<int[]>> map : maps.values()) {\\n            for (Map.Entry<Long, List<int[]>> entry : map.entrySet()) {\\n                Long key = entry.getKey();\\n                List<int[]> list = entry.getValue();\\n                for (int i = 0; i < list.size() - 1; i++) {\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        // list.get(i)[0], list.get(i)[1]\\n                        // list.get(j)[0], list.get(j)[1]\\n\\n                        if (!equal(points[list.get(i)[0]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[0]], points[list.get(j)[1]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[1]])) {\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                    isVertical(points[list.get(i)[1]], points[list.get(i)[0]], points[list.get(j)[1]])) {\\n                                double area = Math.sqrt(key * dis(points[list.get(i)[0]], points[list.get(j)[0]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(i)[1]], points[list.get(j)[1]]) &&\\n                                    isVertical(points[list.get(i)[1]], points[list.get(i)[0]], points[list.get(j)[0]])) {\\n                                double area = Math.sqrt(key * dis(points[list.get(i)[0]], points[list.get(j)[1]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n            }\\n\\n\\n        }\\n        return max;\\n    }\\n\\n    private boolean isVertical(int[] point1, int[] point2, int[] point3) {\\n        int[] vector12 = new int[] {point2[0] - point1[0], point2[1] - point1[1]};\\n        int[] vector13 = new int[] {point3[0] - point1[0], point3[1] - point1[1]};\\n        return vector12[0] * vector13[0] + vector12[1] * vector13[1] == 0;\\n    }\\n\\n    private boolean equal(int[] point1, int[] point2) {\\n        return point1[0] == point2[0] && point1[1] == point2[1];\\n    }\\n\\n    private long dis(int[] point1, int[] point2) {\\n        return (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    // i != j\\n    private String getKey(int i, int j) {\\n        if (i == 0) {\\n            return \"NaN\";\\n        }\\n        if (j == 0) {\\n            return \"0\";\\n        }\\n        boolean flag = true;\\n        if (i < 0) {\\n            i = -i;\\n            flag = !flag;\\n        }\\n        if (j < 0) {\\n            j = -j;\\n            flag = !flag;\\n        }\\n        int gcd = gcd(i, j);\\n        i = i / gcd;\\n        j = j / gcd;\\n        StringBuilder sb = new StringBuilder();\\n        if (!flag) {\\n            sb.append(\"-\");\\n        }\\n        sb.append(i);\\n        sb.append(\",\");\\n        sb.append(j);\\n        return sb.toString();\\n\\n    }\\n\\n    private int gcd(int i, int j) {\\n        while (j != 0) {\\n            int tmp = j;\\n            j = i % j;\\n            i = tmp;\\n        }\\n        return i;\\n    }\\n\\n    public double minAreaFreeRect(int[][] points) {\\n        return s2(points);\\n    }\\n    \\n    private String getKey2(int[] point1, int[] point2) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(point1[0] + point2[0]);\\n        sb.append(\",\");\\n        sb.append(point1[1] + point2[1]);\\n        return sb.toString();\\n    }\\n    \\n    private double s2(int[][] points) {\\n        if (points.length < 4) {\\n            return 0;\\n        }\\n        Map<String, Map<Long, List<int[]>>> maps = new HashMap<>();\\n        for (int i = 0; i < points.length - 1; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                if (!equal(points[i], points[j])) {\\n                    String key = getKey2(points[i], points[j]);\\n                    long innerKey = dis(points[i], points[j]);\\n                    if (!maps.containsKey(key)) {\\n                        maps.put(key, new HashMap<>());\\n                    }\\n                    if (!maps.get(key).containsKey(innerKey)) {\\n                        maps.get(key).put(innerKey, new ArrayList<>());\\n                    }\\n                    maps.get(key).get(innerKey).add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        double max = 0;\\n        for (Map<Long, List<int[]>> map : maps.values()) {\\n            for (List<int[]> list : map.values()) {\\n                for (int i = 0; i < list.size() - 1; i++) {\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        // list.get(i)[0], list.get(i)[1]\\n                        // list.get(j)[0], list.get(j)[1]\\n\\n                        if (!equal(points[list.get(i)[0]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[0]], points[list.get(j)[1]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[1]])) {\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(j)[1]], points[list.get(j)[0]])) {\\n                                double area = Math.sqrt(dis(points[list.get(i)[0]], points[list.get(j)[1]]) * dis(points[list.get(i)[0]], points[list.get(j)[0]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n            }\\n\\n\\n        }\\n        return max;\\n    }\\n\\n    private double s1(int[][] points) {\\n        if (points.length < 4) {\\n            return 0;\\n        }\\n\\n        Map<String, Map<Long, List<int[]>>> maps = new HashMap<>();\\n        for (int i = 0; i < points.length - 1; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                if (!equal(points[i], points[j])) {\\n                    String key = getKey(points[j][0] - points[i][0], points[j][1] - points[i][1]);\\n                    long innerKey = dis(points[i], points[j]);\\n                    if (!maps.containsKey(key)) {\\n                        maps.put(key, new HashMap<>());\\n                    }\\n                    if (!maps.get(key).containsKey(innerKey)) {\\n                        maps.get(key).put(innerKey, new ArrayList<>());\\n                    }\\n                    maps.get(key).get(innerKey).add(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        double max = 0;\\n        for (Map<Long, List<int[]>> map : maps.values()) {\\n            for (Map.Entry<Long, List<int[]>> entry : map.entrySet()) {\\n                Long key = entry.getKey();\\n                List<int[]> list = entry.getValue();\\n                for (int i = 0; i < list.size() - 1; i++) {\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        // list.get(i)[0], list.get(i)[1]\\n                        // list.get(j)[0], list.get(j)[1]\\n\\n                        if (!equal(points[list.get(i)[0]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[0]], points[list.get(j)[1]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[1]])) {\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                    isVertical(points[list.get(i)[1]], points[list.get(i)[0]], points[list.get(j)[1]])) {\\n                                double area = Math.sqrt(key * dis(points[list.get(i)[0]], points[list.get(j)[0]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(i)[1]], points[list.get(j)[1]]) &&\\n                                    isVertical(points[list.get(i)[1]], points[list.get(i)[0]], points[list.get(j)[0]])) {\\n                                double area = Math.sqrt(key * dis(points[list.get(i)[0]], points[list.get(j)[1]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n            }\\n\\n\\n        }\\n        return max;\\n    }\\n\\n    private boolean isVertical(int[] point1, int[] point2, int[] point3) {\\n        int[] vector12 = new int[] {point2[0] - point1[0], point2[1] - point1[1]};\\n        int[] vector13 = new int[] {point3[0] - point1[0], point3[1] - point1[1]};\\n        return vector12[0] * vector13[0] + vector12[1] * vector13[1] == 0;\\n    }\\n\\n    private boolean equal(int[] point1, int[] point2) {\\n        return point1[0] == point2[0] && point1[1] == point2[1];\\n    }\\n\\n    private long dis(int[] point1, int[] point2) {\\n        return (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227259,
                "title": "python-o-n-2",
                "content": "\\tdef minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        n = len(points)\\n        d = collections.defaultdict(list)\\n        \\n        for i in range(n - 1):\\n            pi = points[i]\\n            for j in range(i + 1, n):\\n                pj = points[j]\\n                length = ((pi[0] - pj[0]) ** 2) + ((pi[1] - pj[1]) ** 2)\\n                cx = (pi[0] + pj[0]) / 2.0\\n                cy = (pi[1] + pj[1]) / 2.0\\n                d[(length, cx, cy)].append((i, j))\\n        \\n        res = float(\"inf\")\\n        for ls in d.values():\\n            length = len(ls)\\n            for i in range(length - 1):\\n                p0, p2 = points[ls[i][0]], points[ls[i][1]]\\n                for j in range(i + 1, length):\\n                    p1, p3 = points[ls[j][0]], points[ls[j][1]]\\n                    d1 = math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\\n                    d2 = math.sqrt((p0[0] - p3[0]) ** 2 + (p0[1] - p3[1]) ** 2)\\n                    res = min(res, d1 * d2)\\n        \\n        return res if res != float(\"inf\") else 0",
                "solutionTags": [],
                "code": "\\tdef minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        n = len(points)\\n        d = collections.defaultdict(list)\\n        \\n        for i in range(n - 1):\\n            pi = points[i]\\n            for j in range(i + 1, n):\\n                pj = points[j]\\n                length = ((pi[0] - pj[0]) ** 2) + ((pi[1] - pj[1]) ** 2)\\n                cx = (pi[0] + pj[0]) / 2.0\\n                cy = (pi[1] + pj[1]) / 2.0\\n                d[(length, cx, cy)].append((i, j))\\n        \\n        res = float(\"inf\")\\n        for ls in d.values():\\n            length = len(ls)\\n            for i in range(length - 1):\\n                p0, p2 = points[ls[i][0]], points[ls[i][1]]\\n                for j in range(i + 1, length):\\n                    p1, p3 = points[ls[j][0]], points[ls[j][1]]\\n                    d1 = math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\\n                    d2 = math.sqrt((p0[0] - p3[0]) ** 2 + (p0[1] - p3[1]) ** 2)\\n                    res = min(res, d1 * d2)\\n        \\n        return res if res != float(\"inf\") else 0",
                "codeTag": "Python3"
            },
            {
                "id": 214704,
                "title": "python-two-methods-straightforward-o-n-3-and-record-center-o-n-2-log-n",
                "content": "Starightforward O(N^3)\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = set(map(tuple, points))\\n        ans = float(\\'inf\\')\\n        \\n        for p1, p2, p3 in itertools.combinations(points, 3):\\n            p4 = p2[0] + p3[0] - p1[0], p2[1] + p3[1] - p1[1]\\n            if p4 in points and self.checkAngle(p1, p2, p3):\\n                area = self.getArea(p1, p2, p3)\\n                if area < ans:\\n                    ans = area\\n        return ans if ans < float(\\'inf\\') else 0\\n    \\n    def checkAngle(self, p1, p2, p3):\\n        vec21 = p2[0] - p1[0], p2[1] - p1[1]\\n        vec31 = p3[0] - p1[0], p3[1] - p1[1]\\n        return vec21[0] * vec31[0] + vec21[1] * vec31[1] == 0\\n    \\n    def getArea(self, p1, p2, p3):\\n        len21 = ((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)**0.5\\n        len31 = ((p3[0] - p1[0])**2 + (p3[1] - p1[1])**2)**0.5\\n        return len21*len31\\n```\\n\\nRecord centers seen\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = [complex(*p) for p in points]\\n        seen = collections.defaultdict(list)\\n        for P, Q in itertools.combinations(points, 2):\\n            center = (P + Q) / 2\\n            radius = abs(center - P)\\n            seen[center, radius].append(P)\\n            \\n        ans = float(\\'inf\\')\\n        for (center, radius), candidates in seen.items():\\n            for P, Q in itertools.combinations(candidates, 2):\\n                ans = min(ans, abs(P - Q) * abs(P - (2*center - Q)))\\n        return ans if ans < float(\\'inf\\') else 0\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = set(map(tuple, points))\\n        ans = float(\\'inf\\')\\n        \\n        for p1, p2, p3 in itertools.combinations(points, 3):\\n            p4 = p2[0] + p3[0] - p1[0], p2[1] + p3[1] - p1[1]\\n            if p4 in points and self.checkAngle(p1, p2, p3):\\n                area = self.getArea(p1, p2, p3)\\n                if area < ans:\\n                    ans = area\\n        return ans if ans < float(\\'inf\\') else 0\\n    \\n    def checkAngle(self, p1, p2, p3):\\n        vec21 = p2[0] - p1[0], p2[1] - p1[1]\\n        vec31 = p3[0] - p1[0], p3[1] - p1[1]\\n        return vec21[0] * vec31[0] + vec21[1] * vec31[1] == 0\\n    \\n    def getArea(self, p1, p2, p3):\\n        len21 = ((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)**0.5\\n        len31 = ((p3[0] - p1[0])**2 + (p3[1] - p1[1])**2)**0.5\\n        return len21*len31\\n```\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = [complex(*p) for p in points]\\n        seen = collections.defaultdict(list)\\n        for P, Q in itertools.combinations(points, 2):\\n            center = (P + Q) / 2\\n            radius = abs(center - P)\\n            seen[center, radius].append(P)\\n            \\n        ans = float(\\'inf\\')\\n        for (center, radius), candidates in seen.items():\\n            for P, Q in itertools.combinations(candidates, 2):\\n                ans = min(ans, abs(P - Q) * abs(P - (2*center - Q)))\\n        return ans if ans < float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210350,
                "title": "python-faster-than-72-73",
                "content": "https://blog.csdn.net/fuxuemingzhu/article/details/85223775\\n\\t \\'\\'\\'\\n\\t  from collections import defaultdict\\n        \\n        dict=defaultdict(list)\\n        \\n        for i,(x1,y1) in enumerate(points[:-1]):\\n            for j,(x2,y2) in enumerate(points[i+1:],i+1):\\n                \\n                l=(y2-y1)**2+(x2-x1)**2\\n                x=(x1+x2)/2\\n                y=(y1+y2)/2\\n                \\n                dict[(l,x,y)].append((x1,y1,x2,y2))\\n                \\n        res=1<<30\\n        for elem in dict.values():\\n            if len(elem)<=1:\\n                continue\\n            for i,(x1,y1,x2,y2) in enumerate(elem[:-1]):\\n                for j,(x11,y11,x22,y22) in enumerate(elem[i+1:],i+1):\\n                    d=(y11-y1)**2.0+(x11-x1)**2.0\\n                    h1=(y2-y11)**2.0+(x2-x11)**2.0\\n                    h2=(y22-y11)**2.0+(x22-x11)**2.0\\n                    h=min(h1,h2)\\n                    area=(d*h)**0.5\\n                    res=min(res,area)\\n                        \\n        return(res if res<1<<30 else 0)",
                "solutionTags": [],
                "code": "https://blog.csdn.net/fuxuemingzhu/article/details/85223775\\n\\t \\'\\'\\'\\n\\t  from collections import defaultdict\\n        \\n        dict=defaultdict(list)\\n        \\n        for i,(x1,y1) in enumerate(points[:-1]):\\n            for j,(x2,y2) in enumerate(points[i+1:],i+1):\\n                \\n                l=(y2-y1)**2+(x2-x1)**2\\n                x=(x1+x2)/2\\n                y=(y1+y2)/2\\n                \\n                dict[(l,x,y)].append((x1,y1,x2,y2))\\n                \\n        res=1<<30\\n        for elem in dict.values():\\n            if len(elem)<=1:\\n                continue\\n            for i,(x1,y1,x2,y2) in enumerate(elem[:-1]):\\n                for j,(x11,y11,x22,y22) in enumerate(elem[i+1:],i+1):\\n                    d=(y11-y1)**2.0+(x11-x1)**2.0\\n                    h1=(y2-y11)**2.0+(x2-x11)**2.0\\n                    h2=(y22-y11)**2.0+(x22-x11)**2.0\\n                    h=min(h1,h2)\\n                    area=(d*h)**0.5\\n                    res=min(res,area)\\n                        \\n        return(res if res<1<<30 else 0)",
                "codeTag": "Python3"
            },
            {
                "id": 210126,
                "title": "java-o-n-2-grouping-pairs-with-diagonal",
                "content": "A diagonal contains the centroid location of two points, and the length (distance between two points) of this diagonal.\\nTwo pairs sharing the same diagonal will be able to make a rectangle.\\n\\n```\\nclass Solution {\\n\\n    public static class Diagonal {\\n\\n        double len;\\n        double x;\\n        double y;\\n        public Diagonal(int x1, int y1, int x2, int y2) {\\n            this.len = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n            this.x = (x1 + x2) / 2d;\\n            this.y = (y1 + y2) / 2d;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (!(o instanceof Diagonal)) return false;\\n\\n            Diagonal diagonal = (Diagonal) o;\\n\\n            if (Double.compare(diagonal.len, len) != 0) return false;\\n            if (Double.compare(diagonal.x, x) != 0) return false;\\n            return Double.compare(diagonal.y, y) == 0;\\n\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            int result;\\n            long temp;\\n            temp = Double.doubleToLongBits(len);\\n            result = (int) (temp ^ (temp >>> 32));\\n            temp = Double.doubleToLongBits(x);\\n            result = 31 * result + (int) (temp ^ (temp >>> 32));\\n            temp = Double.doubleToLongBits(y);\\n            result = 31 * result + (int) (temp ^ (temp >>> 32));\\n            return result;\\n        }\\n    }\\n\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Diagonal, List<int[]>> map = new HashMap<>();\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                Diagonal diagonal = new Diagonal(x1, y1, x2, y2);\\n                map.putIfAbsent(diagonal, new ArrayList<>());\\n                map.get(diagonal).add(new int[]{ x1, y1, x2, y2 });\\n            }\\n        }\\n        double min = Integer.MAX_VALUE;\\n        for (Diagonal diagonal : map.keySet()) {\\n            List<int[]> ls = map.get(diagonal);\\n            for (int i = 0; i < ls.size(); i++) {\\n                for (int j = i + 1; j < ls.size(); j++) {\\n                    int[] p1 = ls.get(i);\\n                    int[] p2 = ls.get(j);\\n                    min = Math.min(min, area(p1[0], p1[1], p1[2], p1[3], p2[0], p2[1], p2[2], p2[3]));\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? 0d : min;\\n    }\\n\\n    private double area(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\\n        double width = distance(x1, y1, x3, y3);\\n        double height = distance(x1, y1, x4, y4);\\n        return width * height;\\n    }\\n\\n    private double distance(int x1, int y1, int x2, int y2) {\\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public static class Diagonal {\\n\\n        double len;\\n        double x;\\n        double y;\\n        public Diagonal(int x1, int y1, int x2, int y2) {\\n            this.len = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n            this.x = (x1 + x2) / 2d;\\n            this.y = (y1 + y2) / 2d;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (!(o instanceof Diagonal)) return false;\\n\\n            Diagonal diagonal = (Diagonal) o;\\n\\n            if (Double.compare(diagonal.len, len) != 0) return false;\\n            if (Double.compare(diagonal.x, x) != 0) return false;\\n            return Double.compare(diagonal.y, y) == 0;\\n\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            int result;\\n            long temp;\\n            temp = Double.doubleToLongBits(len);\\n            result = (int) (temp ^ (temp >>> 32));\\n            temp = Double.doubleToLongBits(x);\\n            result = 31 * result + (int) (temp ^ (temp >>> 32));\\n            temp = Double.doubleToLongBits(y);\\n            result = 31 * result + (int) (temp ^ (temp >>> 32));\\n            return result;\\n        }\\n    }\\n\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Diagonal, List<int[]>> map = new HashMap<>();\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                Diagonal diagonal = new Diagonal(x1, y1, x2, y2);\\n                map.putIfAbsent(diagonal, new ArrayList<>());\\n                map.get(diagonal).add(new int[]{ x1, y1, x2, y2 });\\n            }\\n        }\\n        double min = Integer.MAX_VALUE;\\n        for (Diagonal diagonal : map.keySet()) {\\n            List<int[]> ls = map.get(diagonal);\\n            for (int i = 0; i < ls.size(); i++) {\\n                for (int j = i + 1; j < ls.size(); j++) {\\n                    int[] p1 = ls.get(i);\\n                    int[] p2 = ls.get(j);\\n                    min = Math.min(min, area(p1[0], p1[1], p1[2], p1[3], p2[0], p2[1], p2[2], p2[3]));\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? 0d : min;\\n    }\\n\\n    private double area(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\\n        double width = distance(x1, y1, x3, y3);\\n        double height = distance(x1, y1, x4, y4);\\n        return width * height;\\n    }\\n\\n    private double distance(int x1, int y1, int x2, int y2) {\\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209700,
                "title": "c-group-lines-by-slope-length-and-test-for-perpendicularity-beats-95-71",
                "content": "The basic idea is that two lines with the same slope and length are candidates for a rectangle.\\nFor example,\\n```\\n|    |\\n|    |\\n|    |\\n```\\nand\\n```\\n\\\\       \\\\\\n \\\\       \\\\\\n  \\\\       \\\\\\n  ```\\n  However, the following two lines share a slope and length\\n  ```\\n  |\\n  |       |\\n  |       |\\n          |\\n```\\nand obviosuly they cannot form a rectangle so we have to make sure if we connect both lines that the connected lines are prependicular to the original one.\\nTo make things easier we connect the mid points of the lines.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n       \\n        //Group pair of points by the distance and the slope of the formed line segments.\\n        map<pair<double,double>, vector<pair<double,double>> > h;\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                pair<double,double> p1 = make_pair(points[i][0],points[i][1]);\\n                pair<double,double> p2 = make_pair(points[j][0],points[j][1]);\\n                double d = distance(p1,p2);\\n                //if(d == 0 ) continue;   \\n                double slope = calc_slope(p1,p2);\\n                //we store the mid point\\n                h[make_pair(d,slope) ].push_back( make_pair((p1.first+p2.first)/2.0, (p1.second+p2.second)/2.0) );\\n            }\\n        }\\n        \\n        /*We search for two lines with the same slope and length, however, we have to make sure that we can\\n        connect both ends with a line prependicaulr to both line segments.\\n        This to avoid the considering the following two lines\\n        |\\n        |\\n        |\\n              |\\n              |\\n              |\\n        */\\n        double m = std::numeric_limits<double>::max();\\n         for(auto &p :h ) { \\n             if(p.second.size() > 1 ) \\n             for(int i=0;i<p.second.size();i++) { \\n                for(int j=i+1;j<p.second.size();j++) {\\n                    double d = distance(p.second[i],p.second[j]);\\n                    double slope = calc_slope(p.second[i],p.second[j]);\\n                    \\n                    /*here we test if the two lines are perpendicular by forming a line -call it X - between the\\n                    midpoints of both lines and check if X is perpendicular to both lines by multiplying both slopes\\n                    -1 means its ok. However, a vertical line has an undefined (double max in our implementation ) slope while horizontal one has 0\\n                    so we check for that corner case\\n                    */\\n                    if( (slope == std::numeric_limits<double>::max() && p.first.second == 0 ) || \\n                       (p.first.second == std::numeric_limits<double>::max() && slope == 0 ) ||\\n                       ( abs(-1 - (slope * p.first.second ) ) < 0.01 ) ) {\\n                        m = min(m,d*p.first.first);\\n                    }\\n                    \\n                }\\n             }\\n         }\\n        return m == std::numeric_limits<double>::max()? 0 : m;\\n       \\n    }\\nprivate:\\n    double distance(pair<double,double> &p1,pair<double,double> &p2) { \\n        return sqrt( pow(p1.first-p2.first,2) + pow(p1.second-p2.second,2) );\\n    }\\n     double calc_slope(pair<double,double> &p1,pair<double,double> &p2) { \\n        double dem = p1.first - p2.first;\\n        double slope=std::numeric_limits<double>::max();\\n        if(dem !=0 ) slope = (p1.second-p2.second)/dem;  \\n         return slope;\\n     }\\n};\\n```\\nThe upper bound running time is O(n^2)\\n",
                "solutionTags": [],
                "code": "```\\n|    |\\n|    |\\n|    |\\n```\n```\\n\\\\       \\\\\\n \\\\       \\\\\\n  \\\\       \\\\\\n  ```\n```\\n  |\\n  |       |\\n  |       |\\n          |\\n```\n```\\n\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n       \\n        //Group pair of points by the distance and the slope of the formed line segments.\\n        map<pair<double,double>, vector<pair<double,double>> > h;\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                pair<double,double> p1 = make_pair(points[i][0],points[i][1]);\\n                pair<double,double> p2 = make_pair(points[j][0],points[j][1]);\\n                double d = distance(p1,p2);\\n                //if(d == 0 ) continue;   \\n                double slope = calc_slope(p1,p2);\\n                //we store the mid point\\n                h[make_pair(d,slope) ].push_back( make_pair((p1.first+p2.first)/2.0, (p1.second+p2.second)/2.0) );\\n            }\\n        }\\n        \\n        /*We search for two lines with the same slope and length, however, we have to make sure that we can\\n        connect both ends with a line prependicaulr to both line segments.\\n        This to avoid the considering the following two lines\\n        |\\n        |\\n        |\\n              |\\n              |\\n              |\\n        */\\n        double m = std::numeric_limits<double>::max();\\n         for(auto &p :h ) { \\n             if(p.second.size() > 1 ) \\n             for(int i=0;i<p.second.size();i++) { \\n                for(int j=i+1;j<p.second.size();j++) {\\n                    double d = distance(p.second[i],p.second[j]);\\n                    double slope = calc_slope(p.second[i],p.second[j]);\\n                    \\n                    /*here we test if the two lines are perpendicular by forming a line -call it X - between the\\n                    midpoints of both lines and check if X is perpendicular to both lines by multiplying both slopes\\n                    -1 means its ok. However, a vertical line has an undefined (double max in our implementation ) slope while horizontal one has 0\\n                    so we check for that corner case\\n                    */\\n                    if( (slope == std::numeric_limits<double>::max() && p.first.second == 0 ) || \\n                       (p.first.second == std::numeric_limits<double>::max() && slope == 0 ) ||\\n                       ( abs(-1 - (slope * p.first.second ) ) < 0.01 ) ) {\\n                        m = min(m,d*p.first.first);\\n                    }\\n                    \\n                }\\n             }\\n         }\\n        return m == std::numeric_limits<double>::max()? 0 : m;\\n       \\n    }\\nprivate:\\n    double distance(pair<double,double> &p1,pair<double,double> &p2) { \\n        return sqrt( pow(p1.first-p2.first,2) + pow(p1.second-p2.second,2) );\\n    }\\n     double calc_slope(pair<double,double> &p1,pair<double,double> &p2) { \\n        double dem = p1.first - p2.first;\\n        double slope=std::numeric_limits<double>::max();\\n        if(dem !=0 ) slope = (p1.second-p2.second)/dem;  \\n         return slope;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209065,
                "title": "python3-92ms-o-n-2-beat-100",
                "content": "Main idea is that in a rectangle, the two diagonals have same length and same midpoint. We go through each pair of points, and put the pair in the bucket of (midpoint, length). Loop through each bucket and compute the areas.\\n\\n```\\nfrom collections import defaultdict\\nimport math\\n\\ndef sq_norm(p1,p2):\\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1])**2\\n    \\ndef area(p1,p2,p3):\\n    return math.sqrt(sq_norm(p1,p3) * sq_norm(p2,p3))\\n\\nclass Solution:\\n    def minAreaFreeRect(self, p):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        \\n        ans = 1E9\\n        \\n        m = defaultdict(list)\\n        for p1 in p:\\n            for p2 in p:\\n                if p1 < p2:\\n                    mid = (p1[0]+p2[0], p1[1] + p2[1], sq_norm(p1, p2))\\n                    sf = m[mid]\\n                    for p3 in sf:\\n                        ans = min(area(p1, p2, p3), ans)\\n                    m[mid].append(p1)\\n        return ans if ans < 1E9 else 0\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nimport math\\n\\ndef sq_norm(p1,p2):\\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1])**2\\n    \\ndef area(p1,p2,p3):\\n    return math.sqrt(sq_norm(p1,p3) * sq_norm(p2,p3))\\n\\nclass Solution:\\n    def minAreaFreeRect(self, p):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        \\n        ans = 1E9\\n        \\n        m = defaultdict(list)\\n        for p1 in p:\\n            for p2 in p:\\n                if p1 < p2:\\n                    mid = (p1[0]+p2[0], p1[1] + p2[1], sq_norm(p1, p2))\\n                    sf = m[mid]\\n                    for p3 in sf:\\n                        ans = min(area(p1, p2, p3), ans)\\n                    m[mid].append(p1)\\n        return ans if ans < 1E9 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208963,
                "title": "simple-python3-solution-o-n-2-using-slope-and-inner-product-beat-100-188-ms",
                "content": "```\\ndef minAreaFreeRect(self, points):\\n        dist = lambda x1, y1, x2, y2: (x1-x2)**2 + (y1-y2)**2\\n        inner = lambda p1, p2, p3: (p2[0] - p1[0]) * (p3[0] - p2[0]) + (p2[1] - p1[1]) * (p3[1] - p2[1])             \\n        area = lambda p1, p2, p3, p4: float(\\'inf\\') if not (inner(p1, p2, p3) == 0 and inner(p2, p3, p4) == 0 and inner(p3, p4, p1) == 0) else (dist(*p1, *p2) * dist(*p2, *p3))**.5                \\n        slope = lambda x1, y1, x2, y2: int((y2-y1)/ float(x2-x1) * 10**5) if x1 != x2 else float(\\'inf\\')            \\n    \\n        ans = float(\\'inf\\')              \\n        memo = collections.defaultdict(list)        \\n        for i, p in enumerate(points):\\n            for j, q in enumerate(points[:i]):\\n                memo[slope(*p, *q)].append([p, q])                \\n        for sl, cands in memo.items():\\n            for P1, P2 in itertools.permutations(cands, 2):\\n                p1, p2 = sorted(P1)\\n                p3, p4 = sorted(P2)\\n                ans = min(ans, area(p1, p2, p4, p3))                                        \\n        return ans if ans < float(\\'inf\\') else 0",
                "solutionTags": [],
                "code": "```\\ndef minAreaFreeRect(self, points):\\n        dist = lambda x1, y1, x2, y2: (x1-x2)**2 + (y1-y2)**2\\n        inner = lambda p1, p2, p3: (p2[0] - p1[0]) * (p3[0] - p2[0]) + (p2[1] - p1[1]) * (p3[1] - p2[1])             \\n        area = lambda p1, p2, p3, p4: float(\\'inf\\') if not (inner(p1, p2, p3) == 0 and inner(p2, p3, p4) == 0 and inner(p3, p4, p1) == 0) else (dist(*p1, *p2) * dist(*p2, *p3))**.5                \\n        slope = lambda x1, y1, x2, y2: int((y2-y1)/ float(x2-x1) * 10**5) if x1 != x2 else float(\\'inf\\')            \\n    \\n        ans = float(\\'inf\\')              \\n        memo = collections.defaultdict(list)        \\n        for i, p in enumerate(points):\\n            for j, q in enumerate(points[:i]):\\n                memo[slope(*p, *q)].append([p, q])                \\n        for sl, cands in memo.items():\\n            for P1, P2 in itertools.permutations(cands, 2):\\n                p1, p2 = sorted(P1)\\n                p3, p4 = sorted(P2)\\n                ans = min(ans, area(p1, p2, p4, p3))                                        \\n        return ans if ans < float(\\'inf\\') else 0",
                "codeTag": "Python3"
            },
            {
                "id": 208912,
                "title": "192ms-python3-solution-beaten-100",
                "content": "Steps:\\n1. Calculate the slopes of all straight segments and store them in **ijMap** which takes the point index pair as the key. Also, store the slope relations in a multi-dimension map - **relations** which takes the index of the start point as the first key, the slope as the second key and a set of the end points\\' indexes as the value. Note the slope is represented as a (dy, dx) pair where both are integers and dx is always greater than 0.\\n2. Loop thru all point pair (i0, i1) where i0 < i1. Get the slope of (i0, i1) and the slope of the other ajacent side. Now we have a set - **i3Set** of point i3 which connects to i1 and has the correct slope. Then we loop all possible i2 which connects to i0 and has the correct slope. For each i2, we have a set of possible i3 - **relations\\\\[i2\\\\]\\\\[inc01\\\\]**. If this set has intersection with **i3Set**, we get a valid rectangle and we can compute its area.\\nNote I have normalized all slopes by the maximum common divisor. And the slopes are optimized when the straight segment is parrellel to the x axis or the y axis.\\n```\\nfrom collections import defaultdict\\nimport math\\n\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        N = len(points)\\n        relations = [defaultdict(set) for i in range(N)]\\n        ijMap = dict()\\n        for i, (x0, y0) in enumerate(points):\\n            for j, (x1, y1) in enumerate(points[i + 1:], i + 1):\\n                incline = self.getIncline(x0, y0, x1, y1)\\n                relations[i][incline].add(j)\\n                relations[j][incline].add(i)\\n                ijMap[(i, j)] = ijMap[(j, i)] = incline\\n        minArea = math.inf\\n        for i0 in range(N):\\n            for i1 in range(i0 + 1, N):\\n                inc01 = ijMap[(i0, i1)]\\n                inc02 = self.getRevIncline(*inc01)\\n                i3Set = relations[i1][inc02]\\n                for i2 in relations[i0][inc02]:\\n                    if not i3Set.isdisjoint(relations[i2][inc01]):\\n                        minArea = min(\\n                            minArea, self.calArea(points, i0, i1, i2))\\n        return minArea if minArea != math.inf else 0\\n\\n    def calArea(self, points, i0, i1, i2):\\n        x0, y0 = points[i0]\\n        x1, y1 = points[i1]\\n        x2, y2 = points[i2]\\n        return math.sqrt(((x1 - x0)*(x1 - x0) + (y1 - y0) * (y1 - y0)) * ((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0)))\\n\\n    def getRevIncline(self, dy, dx):\\n        if dy == math.inf:\\n            return 0, 1\\n        if dy == 0:\\n            return math.inf, 1\\n        return (-dx, dy) if dy > 0 else (dx, -dy)\\n\\n    def getIncline(self, x0, y0, x1, y1):\\n        if x0 == x1:\\n            return math.inf, 1\\n        if y0 == y1:\\n            return 0, 1\\n        dx, dy = x1 - x0, y1 - y0\\n        cf = self.getCommonFactor(dx, dy)\\n        dx, dy = dx // cf, dy // cf\\n        return (dy, dx) if dx > 0 else (-dy, -dx)\\n\\n    def getCommonFactor(self, a, b):\\n        a, b = abs(a), abs(b)\\n        a = a % b\\n        while a != 0:\\n            b = b % a\\n            a, b = b, a\\n        return b\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nimport math\\n\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        N = len(points)\\n        relations = [defaultdict(set) for i in range(N)]\\n        ijMap = dict()\\n        for i, (x0, y0) in enumerate(points):\\n            for j, (x1, y1) in enumerate(points[i + 1:], i + 1):\\n                incline = self.getIncline(x0, y0, x1, y1)\\n                relations[i][incline].add(j)\\n                relations[j][incline].add(i)\\n                ijMap[(i, j)] = ijMap[(j, i)] = incline\\n        minArea = math.inf\\n        for i0 in range(N):\\n            for i1 in range(i0 + 1, N):\\n                inc01 = ijMap[(i0, i1)]\\n                inc02 = self.getRevIncline(*inc01)\\n                i3Set = relations[i1][inc02]\\n                for i2 in relations[i0][inc02]:\\n                    if not i3Set.isdisjoint(relations[i2][inc01]):\\n                        minArea = min(\\n                            minArea, self.calArea(points, i0, i1, i2))\\n        return minArea if minArea != math.inf else 0\\n\\n    def calArea(self, points, i0, i1, i2):\\n        x0, y0 = points[i0]\\n        x1, y1 = points[i1]\\n        x2, y2 = points[i2]\\n        return math.sqrt(((x1 - x0)*(x1 - x0) + (y1 - y0) * (y1 - y0)) * ((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0)))\\n\\n    def getRevIncline(self, dy, dx):\\n        if dy == math.inf:\\n            return 0, 1\\n        if dy == 0:\\n            return math.inf, 1\\n        return (-dx, dy) if dy > 0 else (dx, -dy)\\n\\n    def getIncline(self, x0, y0, x1, y1):\\n        if x0 == x1:\\n            return math.inf, 1\\n        if y0 == y1:\\n            return 0, 1\\n        dx, dy = x1 - x0, y1 - y0\\n        cf = self.getCommonFactor(dx, dy)\\n        dx, dy = dx // cf, dy // cf\\n        return (dy, dx) if dx > 0 else (-dy, -dx)\\n\\n    def getCommonFactor(self, a, b):\\n        a, b = abs(a), abs(b)\\n        a = a % b\\n        while a != 0:\\n            b = b % a\\n            a, b = b, a\\n        return b\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208911,
                "title": "java-backtracking",
                "content": "1. Using backtrack to construct all possible points set.\\n2. Check the points set and calculate the area if the points can make up a rectangle.\\n3. Store the minimal rectangle area value.\\n\\n\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        double[] res = new double[1];\\n        res[0] = Double.MAX_VALUE;\\n        backtracking(points, new ArrayList<>(), 0, res);\\n        return res[0] == Double.MAX_VALUE? 0 : res[0];\\n    }\\n\\n    private void backtracking(int[][] points, List<int[]> vertex, int index, double[] min) {\\n        if (vertex.size() >= 4) {\\n            // judge Rectangle\\n            double[] area = new double[1];\\n            if (isSquare(vertex,area)) {\\n                min[0] = Math.min(min[0], area[0]);\\n            }\\n            return;\\n        } else {\\n            for(int i = index; i < points.length; i++) {\\n\\n                vertex.add(points[i]);\\n                backtracking(points, vertex, i+1, min);\\n                vertex.remove(vertex.size() - 1);\\n            }\\n        }\\n\\n    }\\n\\n    public boolean isSquare (List<int[]> vertex, double[] area){\\n        int p[][]={{vertex.get(0)[0], vertex.get(0)[1]},\\n                {vertex.get(1)[0], vertex.get(1)[1]},\\n                {vertex.get(2)[0], vertex.get(2)[1]},\\n                {vertex.get(3)[0], vertex.get(3)[1]}};\\n        double cx = (double)(p[0][0] + p[1][0] + p[2][0] + p[3][0]) / 4;\\n        double cy = (double)(p[0][1] + p[1][1] + p[2][1] + p[3][1]) / 4;\\n        double dd1,dd2,dd3,dd4;\\n        dd1 = (cx - p[0][0])*(cx - p[0][0]) + (cy - p[0][1])*(cy - p[0][1]);\\n        dd2 = (cx - p[1][0])*(cx - p[1][0]) + (cy - p[1][1])*(cy - p[1][1]); \\n        dd3 = (cx - p[2][0])*(cx - p[2][0]) + (cy - p[2][1])*(cy - p[2][1]); \\n        dd4 = (cx - p[3][0])*(cx - p[3][0]) + (cy - p[3][1])*(cy - p[3][1]); \\n        boolean res = (dd1==dd2 && dd1==dd3 && dd1==dd4);\\n        \\n        if (res) {\\n            int cnt=0;\\n            double  len[]=new double[6];\\n            for(int i=0;i<=3;i++){\\n                for(int j=i+1;j<=3;j++){\\n                    len[cnt++]=(p[i][0]-p[j][0])*(p[i][0]-p[j][0])+\\n                            (p[i][1]-p[j][1])*(p[i][1]-p[j][1]);\\n                }\\n\\n            }\\n            Arrays.sort(len);\\n            area[0] = Math.sqrt(len[0]*len[2]);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        double[] res = new double[1];\\n        res[0] = Double.MAX_VALUE;\\n        backtracking(points, new ArrayList<>(), 0, res);\\n        return res[0] == Double.MAX_VALUE? 0 : res[0];\\n    }\\n\\n    private void backtracking(int[][] points, List<int[]> vertex, int index, double[] min) {\\n        if (vertex.size() >= 4) {\\n            // judge Rectangle\\n            double[] area = new double[1];\\n            if (isSquare(vertex,area)) {\\n                min[0] = Math.min(min[0], area[0]);\\n            }\\n            return;\\n        } else {\\n            for(int i = index; i < points.length; i++) {\\n\\n                vertex.add(points[i]);\\n                backtracking(points, vertex, i+1, min);\\n                vertex.remove(vertex.size() - 1);\\n            }\\n        }\\n\\n    }\\n\\n    public boolean isSquare (List<int[]> vertex, double[] area){\\n        int p[][]={{vertex.get(0)[0], vertex.get(0)[1]},\\n                {vertex.get(1)[0], vertex.get(1)[1]},\\n                {vertex.get(2)[0], vertex.get(2)[1]},\\n                {vertex.get(3)[0], vertex.get(3)[1]}};\\n        double cx = (double)(p[0][0] + p[1][0] + p[2][0] + p[3][0]) / 4;\\n        double cy = (double)(p[0][1] + p[1][1] + p[2][1] + p[3][1]) / 4;\\n        double dd1,dd2,dd3,dd4;\\n        dd1 = (cx - p[0][0])*(cx - p[0][0]) + (cy - p[0][1])*(cy - p[0][1]);\\n        dd2 = (cx - p[1][0])*(cx - p[1][0]) + (cy - p[1][1])*(cy - p[1][1]); \\n        dd3 = (cx - p[2][0])*(cx - p[2][0]) + (cy - p[2][1])*(cy - p[2][1]); \\n        dd4 = (cx - p[3][0])*(cx - p[3][0]) + (cy - p[3][1])*(cy - p[3][1]); \\n        boolean res = (dd1==dd2 && dd1==dd3 && dd1==dd4);\\n        \\n        if (res) {\\n            int cnt=0;\\n            double  len[]=new double[6];\\n            for(int i=0;i<=3;i++){\\n                for(int j=i+1;j<=3;j++){\\n                    len[cnt++]=(p[i][0]-p[j][0])*(p[i][0]-p[j][0])+\\n                            (p[i][1]-p[j][1])*(p[i][1]-p[j][1]);\\n                }\\n\\n            }\\n            Arrays.sort(len);\\n            area[0] = Math.sqrt(len[0]*len[2]);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208908,
                "title": "an-easy-o-n-3-way-to-solve",
                "content": "\\'\\'\\'\\nclass Solution(object):\\n    \\n    def recarea(self,a,b,c):\\n        x1=a[0]\\n        y1=a[1]\\n        x2=b[0]\\n        y2=b[1]\\n        x3=c[0]\\n        y3=c[1]\\n        return abs(x1*y2+x2*y3+x3*y1-x1*y3-x2*y1-x3*y2) + 0.0\\n    \\n    def vec_mul(self,va,vb):\\n        return va[0] * vb[0] + va[1] * vb[1]\\n    \\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        minarea = 0\\n        length = len(points)\\n        if length < 4:\\n            return 0\\n        for i in range(0,length):\\n            for j in range(i+1,length):\\n                for k in range(j+1,length):\\n                    pi = points[i]\\n                    pj = points[j]\\n                    pk = points[k]\\n                    temparea = self.recarea(pi,pj,pk)\\n                    if temparea > minarea and minarea != 0:\\n                        continue\\n                    v_ij = [pj[0]-pi[0],pj[1]-pi[1]]\\n                    v_ik = [pk[0]-pi[0],pk[1]-pi[1]]\\n                    v_jk = [pk[0]-pj[0],pk[1]-pj[1]]\\n                    if self.vec_mul(v_ij,v_jk) == 0:\\n                        t = [pi[0]+v_jk[0],pi[1]+v_jk[1]]\\n                        if t in points:\\n                            minarea = temparea \\n                    elif self.vec_mul(v_ij,v_ik) == 0:\\n                        t = [pj[0]+v_ik[0],pj[1]+v_ik[1]]\\n                        if t in points:\\n                            minarea = temparea\\n                    elif self.vec_mul(v_jk,v_ik) == 0:\\n                        t = [pi[0]-v_jk[0],pi[1]-v_jk[1]]\\n                        if t in points:\\n                            minarea = temparea\\n        return minarea\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution(object):\\n    \\n    def recarea(self,a,b,c):\\n        x1=a[0]\\n        y1=a[1]\\n        x2=b[0]\\n        y2=b[1]\\n        x3=c[0]\\n        y3=c[1]\\n        return abs(x1*y2+x2*y3+x3*y1-x1*y3-x2*y1-x3*y2) + 0.0\\n    \\n    def vec_mul(self,va,vb):\\n        return va[0] * vb[0] + va[1] * vb[1]\\n    \\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        minarea = 0\\n        length = len(points)\\n        if length < 4:\\n            return 0\\n        for i in range(0,length):\\n            for j in range(i+1,length):\\n                for k in range(j+1,length):\\n                    pi = points[i]\\n                    pj = points[j]\\n                    pk = points[k]\\n                    temparea = self.recarea(pi,pj,pk)\\n                    if temparea > minarea and minarea != 0:\\n                        continue\\n                    v_ij = [pj[0]-pi[0],pj[1]-pi[1]]\\n                    v_ik = [pk[0]-pi[0],pk[1]-pi[1]]\\n                    v_jk = [pk[0]-pj[0],pk[1]-pj[1]]\\n                    if self.vec_mul(v_ij,v_jk) == 0:\\n                        t = [pi[0]+v_jk[0],pi[1]+v_jk[1]]\\n                        if t in points:\\n                            minarea = temparea \\n                    elif self.vec_mul(v_ij,v_ik) == 0:\\n                        t = [pj[0]+v_ik[0],pj[1]+v_ik[1]]\\n                        if t in points:\\n                            minarea = temparea\\n                    elif self.vec_mul(v_jk,v_ik) == 0:\\n                        t = [pi[0]-v_jk[0],pi[1]-v_jk[1]]\\n                        if t in points:\\n                            minarea = temparea\\n        return minarea\\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 208801,
                "title": "python-use-math-vector",
                "content": "```\\ndef minAreaFreeRect(self, points):\\n        vectorMap = {}\\n        for i in range(len(points)):\\n            p1 = points[i]\\n            for j in range(i + 1, len(points)):\\n                p2 = points[j]\\n                indexP1, indexP2 = i, j\\n                vector = (p2[0] - p1[0], p2[1] - p1[1])\\n                if vector[0] < 0 or (vector[0] == 0 and vector[1] < 0):\\n                    # consider vector with inverse direction\\n                    vector = (-vector[0], -vector[1])\\n                    indexP1, indexP2 = indexP2, indexP1\\n                if vector not in vectorMap:\\n                    vectorMap[vector] = [[indexP1, indexP2]]\\n                else:\\n                    vectorMap[vector].append([indexP1, indexP2])\\n        \\n        res = sys.maxint\\n        for vector, pairs in vectorMap.iteritems():\\n            if len(pairs) > 1:\\n                for i in range(len(pairs)):\\n                    p1 = points[pairs[i][0]]\\n                    for j in range(i + 1, len(pairs)):\\n                        p2 = points[pairs[j][0]]\\n                        # use start points of two vectors to get the third side\\n                        v3 = [p2[0] - p1[0], p2[1] - p1[1]]\\n                        if (vector[0] * v3[0] + vector[1] * v3[1]) == 0:\\n                            # is rectangle\\n                            area = abs(vector[0] * v3[1] - vector[1] * v3[0])\\n                            if area < res:\\n                                res = area\\n                            \\n        if res == sys.maxint:\\n            return 0\\n        else:\\n            return res\\n```\\n\\nIdea:\\n1. put all vectors (a pair of points) into map and group them by magnitude and direction.\\n2. check if any 2 vectors with the same magnitude and direction can form a rectangle and save the minimum area.",
                "solutionTags": [],
                "code": "```\\ndef minAreaFreeRect(self, points):\\n        vectorMap = {}\\n        for i in range(len(points)):\\n            p1 = points[i]\\n            for j in range(i + 1, len(points)):\\n                p2 = points[j]\\n                indexP1, indexP2 = i, j\\n                vector = (p2[0] - p1[0], p2[1] - p1[1])\\n                if vector[0] < 0 or (vector[0] == 0 and vector[1] < 0):\\n                    # consider vector with inverse direction\\n                    vector = (-vector[0], -vector[1])\\n                    indexP1, indexP2 = indexP2, indexP1\\n                if vector not in vectorMap:\\n                    vectorMap[vector] = [[indexP1, indexP2]]\\n                else:\\n                    vectorMap[vector].append([indexP1, indexP2])\\n        \\n        res = sys.maxint\\n        for vector, pairs in vectorMap.iteritems():\\n            if len(pairs) > 1:\\n                for i in range(len(pairs)):\\n                    p1 = points[pairs[i][0]]\\n                    for j in range(i + 1, len(pairs)):\\n                        p2 = points[pairs[j][0]]\\n                        # use start points of two vectors to get the third side\\n                        v3 = [p2[0] - p1[0], p2[1] - p1[1]]\\n                        if (vector[0] * v3[0] + vector[1] * v3[1]) == 0:\\n                            # is rectangle\\n                            area = abs(vector[0] * v3[1] - vector[1] * v3[0])\\n                            if area < res:\\n                                res = area\\n                            \\n        if res == sys.maxint:\\n            return 0\\n        else:\\n            return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 208596,
                "title": "c-o-n-3-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n  struct myHash\\n{\\n\\tsize_t operator()(pair<int, int> __val) const\\n\\t{\\n\\t\\treturn static_cast<size_t>(__val.first * 40001 + __val.second);\\n\\t}\\n};\\nstruct Point {\\n\\tint x;\\n\\tint y;\\n\\tPoint(int a=0, int b=0)\\n\\t{\\n\\t\\tx = a;\\n\\t\\ty = b;\\n\\t}\\n\\n};\\ndouble dis(Point a, Point b)\\n{\\n\\tdouble dis = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);\\n\\n\\treturn sqrt(dis);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tunordered_set<pair<int,int>,myHash> store;\\n\\tPoint * A = new Point[points.size()];\\n\\tfor (int i = 0; i<points.size(); i++)\\n\\t{\\n\\t\\tPoint a(points[i][0], points[i][1]);\\n\\t\\tA[i] = a;\\n\\t\\tstore.insert({ points[i][0], points[i][1] });\\n\\t}\\n\\tdouble val = INT_MAX;\\n\\t//A1+ A4==A2+A3\\n\\tfor (int i = 0; i<points.size(); i++)\\n\\t\\tfor (int j = i + 1; j<points.size(); j++)\\n\\t\\t\\tfor (int k = j + 1; k<points.size(); k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint dx = A[j].x + A[k].x - A[i].x;\\n\\t\\t\\t\\tint dy = A[j].y + A[k].y - A[i].y;\\n\\t\\t\\t\\tPoint b(dx, dy);\\n\\t\\t\\t\\tif (store.count({ dx, dy }) != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint dot = ((A[j].x - A[i].x) * (A[k].x - A[i].x) + (A[j].y - A[i].y) * (A[k].y - A[i].y));\\n\\t\\t\\t\\t\\tif (dot == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdouble distance = dis(A[i], A[j])*dis(A[i], A[k]);\\n\\n\\t\\t\\t\\t\\t\\tval = min(val, distance);\\n\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\n\\n\\t\\t\\t}\\n    if(abs(val-INT_MAX)<0.0001) return 0;\\n\\treturn val;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  struct myHash\\n{\\n\\tsize_t operator()(pair<int, int> __val) const\\n\\t{\\n\\t\\treturn static_cast<size_t>(__val.first * 40001 + __val.second);\\n\\t}\\n};\\nstruct Point {\\n\\tint x;\\n\\tint y;\\n\\tPoint(int a=0, int b=0)\\n\\t{\\n\\t\\tx = a;\\n\\t\\ty = b;\\n\\t}\\n\\n};\\ndouble dis(Point a, Point b)\\n{\\n\\tdouble dis = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);\\n\\n\\treturn sqrt(dis);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tunordered_set<pair<int,int>,myHash> store;\\n\\tPoint * A = new Point[points.size()];\\n\\tfor (int i = 0; i<points.size(); i++)\\n\\t{\\n\\t\\tPoint a(points[i][0], points[i][1]);\\n\\t\\tA[i] = a;\\n\\t\\tstore.insert({ points[i][0], points[i][1] });\\n\\t}\\n\\tdouble val = INT_MAX;\\n\\t//A1+ A4==A2+A3\\n\\tfor (int i = 0; i<points.size(); i++)\\n\\t\\tfor (int j = i + 1; j<points.size(); j++)\\n\\t\\t\\tfor (int k = j + 1; k<points.size(); k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint dx = A[j].x + A[k].x - A[i].x;\\n\\t\\t\\t\\tint dy = A[j].y + A[k].y - A[i].y;\\n\\t\\t\\t\\tPoint b(dx, dy);\\n\\t\\t\\t\\tif (store.count({ dx, dy }) != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint dot = ((A[j].x - A[i].x) * (A[k].x - A[i].x) + (A[j].y - A[i].y) * (A[k].y - A[i].y));\\n\\t\\t\\t\\t\\tif (dot == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdouble distance = dis(A[i], A[j])*dis(A[i], A[k]);\\n\\n\\t\\t\\t\\t\\t\\tval = min(val, distance);\\n\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\n\\n\\t\\t\\t}\\n    if(abs(val-INT_MAX)<0.0001) return 0;\\n\\treturn val;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208584,
                "title": "java-easy-understanding-solution",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if (points == null || points.length < 4) {\\n            return 0;\\n        }\\n        \\n        // check the fourth point\\n        Set<String> checker = new HashSet<String>();\\n        for (int[] point : points) {\\n            checker.add(point[0] + \"-\" + point[1]);\\n        }\\n        \\n        // check rectangle\\n        double result = Double.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                for (int k = 0; k < j; k++) {\\n                    int[] p1 = points[i], p2 = points[j], p3 = points[k];\\n\\t\\t\\t\\t\\t// get the fourth point\\n                    int x = p2[0] + p3[0] - p1[0];\\n                    int y = p2[1] + p3[1] - p1[1];\\n                    // two lines needs to be vertical\\n                    if (checker.contains(x + \"-\" + y) && checkDirectionHelper(p1, p2, p3)) {\\n                        result = Math.min(result, getAreaHelper(p1, p2, p3));\\n                    }\\n                }\\n            }\\n        }\\n        return result == Double.MAX_VALUE ? 0 : result;\\n    }\\n    \\n    private double getAreaHelper(int[] p1, int[] p2, int[] p3) {\\n        double d1 = getDistanceHelper(p1, p2);\\n        double d2 = getDistanceHelper(p2, p3);\\n        double d3 = getDistanceHelper(p1, p3);\\n        List<Double> distances = new ArrayList<Double>();\\n        distances.add(d1);\\n        distances.add(d2);\\n        distances.add(d3);\\n        Collections.sort(distances);\\n        return distances.get(0) * distances.get(1);\\n    }\\n    \\n    private double getDistanceHelper(int[] p1, int[] p2) {\\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\\n    }\\n    \\n    private boolean checkDirectionHelper(int[] p1, int[] p2, int[] p3) {\\n        int x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1], x3 = p3[0], y3 = p3[1];\\n        return (y2 - y1) * (y3 - y1) + (x2 - x1) * (x3 - x1) == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if (points == null || points.length < 4) {\\n            return 0;\\n        }\\n        \\n        // check the fourth point\\n        Set<String> checker = new HashSet<String>();\\n        for (int[] point : points) {\\n            checker.add(point[0] + \"-\" + point[1]);\\n        }\\n        \\n        // check rectangle\\n        double result = Double.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                for (int k = 0; k < j; k++) {\\n                    int[] p1 = points[i], p2 = points[j], p3 = points[k];\\n\\t\\t\\t\\t\\t// get the fourth point\\n                    int x = p2[0] + p3[0] - p1[0];\\n                    int y = p2[1] + p3[1] - p1[1];\\n                    // two lines needs to be vertical\\n                    if (checker.contains(x + \"-\" + y) && checkDirectionHelper(p1, p2, p3)) {\\n                        result = Math.min(result, getAreaHelper(p1, p2, p3));\\n                    }\\n                }\\n            }\\n        }\\n        return result == Double.MAX_VALUE ? 0 : result;\\n    }\\n    \\n    private double getAreaHelper(int[] p1, int[] p2, int[] p3) {\\n        double d1 = getDistanceHelper(p1, p2);\\n        double d2 = getDistanceHelper(p2, p3);\\n        double d3 = getDistanceHelper(p1, p3);\\n        List<Double> distances = new ArrayList<Double>();\\n        distances.add(d1);\\n        distances.add(d2);\\n        distances.add(d3);\\n        Collections.sort(distances);\\n        return distances.get(0) * distances.get(1);\\n    }\\n    \\n    private double getDistanceHelper(int[] p1, int[] p2) {\\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\\n    }\\n    \\n    private boolean checkDirectionHelper(int[] p1, int[] p2, int[] p3) {\\n        int x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1], x3 = p3[0], y3 = p3[1];\\n        return (y2 - y1) * (y3 - y1) + (x2 - x1) * (x3 - x1) == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208552,
                "title": "python-o-n-2-beats-100-10-lines-with-explanation",
                "content": "ideas:\\n1) make center, and distance of a pair to be a key to a hash map and list to be a value\\n2) make a vector out of a pair by subtracting 2 end points and append to list corresponds to the key\\n3) do cross product to calculate area of the rectangle if 2 pairs with same center and distance found\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        st_pt, mn = collections.defaultdict(list), math.inf\\n        for l1, l2 in itertools.combinations((complex(*z) for z in points), 2):\\n            v1 = l1 - l2\\n            key = (l1 + l2, v1*v1.conjugate())\\n            for v2 in st_pt[key]:\\n                mn = min(abs(v1.imag*v2.real - v2.imag*v1.real)/2, mn)\\n            st_pt[key].append(v1)\\n        return mn if mn != math.inf else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        st_pt, mn = collections.defaultdict(list), math.inf\\n        for l1, l2 in itertools.combinations((complex(*z) for z in points), 2):\\n            v1 = l1 - l2\\n            key = (l1 + l2, v1*v1.conjugate())\\n            for v2 in st_pt[key]:\\n                mn = min(abs(v1.imag*v2.real - v2.imag*v1.real)/2, mn)\\n            st_pt[key].append(v1)\\n        return mn if mn != math.inf else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208427,
                "title": "js-o-n-4-solution",
                "content": "```\\nvar minAreaFreeRect = function(points) {\\n    let min = Infinity;\\n    for(let i=0;i<points.length;i++) {\\n        for(let j=0;j<points.length;j++) {\\n            if(i==j) continue;\\n            for(let k=0;k<points.length;k++) {\\n                if(i==k||j==k) continue;\\n                for(let l=0;l<points.length;l++) {\\n                    min = Math.min(min, isRect(points[i],points[j],points[k],points[l]));\\n                }\\n            }    \\n        }\\n    }\\n    return min==Infinity?0:min;\\n};\\n\\nvar isRect = function (p1,p2,p3,p4) {\\n    let d1 = distSq(p1, p2); // from p1 to p2 \\n    let d2 = distSq(p2, p3); // from p2 to p3 \\n    let d3 = distSq(p3, p4); // from p3 to p4 \\n    let d4 = distSq(p1, p4); // from p1 to p4 \\n\\n    let dg1 = distSq(p1, p3); // dialognal 1\\n    let dg2 = distSq(p2, p4); // dialognal 2\\n    \\n    if(d1==d3&&d2==d4&&dg1==dg2) {\\n        return Math.sqrt(d1*d2);  \\n    }\\n    \\n    return Infinity;\\n}\\n\\nvar distSq = function(p1,p2) {\\n    return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar minAreaFreeRect = function(points) {\\n    let min = Infinity;\\n    for(let i=0;i<points.length;i++) {\\n        for(let j=0;j<points.length;j++) {\\n            if(i==j) continue;\\n            for(let k=0;k<points.length;k++) {\\n                if(i==k||j==k) continue;\\n                for(let l=0;l<points.length;l++) {\\n                    min = Math.min(min, isRect(points[i],points[j],points[k],points[l]));\\n                }\\n            }    \\n        }\\n    }\\n    return min==Infinity?0:min;\\n};\\n\\nvar isRect = function (p1,p2,p3,p4) {\\n    let d1 = distSq(p1, p2); // from p1 to p2 \\n    let d2 = distSq(p2, p3); // from p2 to p3 \\n    let d3 = distSq(p3, p4); // from p3 to p4 \\n    let d4 = distSq(p1, p4); // from p1 to p4 \\n\\n    let dg1 = distSq(p1, p3); // dialognal 1\\n    let dg2 = distSq(p2, p4); // dialognal 2\\n    \\n    if(d1==d3&&d2==d4&&dg1==dg2) {\\n        return Math.sqrt(d1*d2);  \\n    }\\n    \\n    return Infinity;\\n}\\n\\nvar distSq = function(p1,p2) {\\n    return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208350,
                "title": "is-o-n-4-allowed-for-n-50",
                "content": "I am never able to pass it with O(n^4) solution but I wonder why some could pass it?",
                "solutionTags": [],
                "code": "I am never able to pass it with O(n^4) solution but I wonder why some could pass it?",
                "codeTag": "Unknown"
            },
            {
                "id": 208325,
                "title": "using-set-o-n-3log-n-c-20-ms",
                "content": "```\\nProblem can\\'t be done solved in O(n^4) (brute force ) .\\nSo we need to reduce time complexity. I used set to store the co-ordinates of rectangle.\\nand Then used set as replacement for 4th loop in solution\\n\\n```\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &p1,vector<int> &p2,vector<int>&p3){\\n\\t\\n\\t// function to find wheater given 3 points intersect at right angle\\n        \\n        int x1 = p1[0]-p2[0];\\n        int x2 = p3[0] - p2[0];\\n        \\n        int y1 = p1[1] -p2[1];\\n        int y2 = p3[1] -p2[1];\\n        \\n        \\n        if((y1==0 && x2==0) || (y2==0 && x1==0)){\\n            return true;\\n        }\\n        else if(y1==0 || x1==0 || y2==0 || x2==0)\\n            return false;\\n        \\n        else if(x1*x2==-y1*y2){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    double dist(vector<int> &p1,vector<int> &p2){\\n        return sqrt((pow(p1[0]-p2[0],2))+ pow(p1[1]-p2[1],2));\\n    }\\n    \\n    double Area(vector<int> &p1,vector<int> &p2,vector<int>&p3){\\n        return dist(p1,p2) * dist(p2,p3);\\n    }\\n    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        set<pair<int,int> > hmap;\\n        \\n        int n = points.size();\\n        \\n        if(n<3)\\n            return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            hmap.insert({points[i][0],points[i][1]});\\n        }\\n        \\n        double sol=INT_MAX;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(isValid(points[i],points[j],points[k])){\\n                        int x = points[i][0] + points[k][0] - points[j][0];\\n                        int y = points[i][1] + points[k][1] - points[j][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[i],points[j],points[k]));\\n                        }\\n                    }\\n                   else  if(isValid(points[i],points[k],points[j])){\\n                        int x = points[i][0] + points[j][0] - points[k][0];\\n                        int y = points[i][1] + points[j][1] - points[k][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[i],points[k],points[j]));\\n                        }\\n                    }\\n                   else if(isValid(points[j],points[i],points[k])){\\n                        int x = points[j][0] + points[k][0] - points[i][0];\\n                        int y = points[j][1] + points[k][1] - points[i][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[j],points[i],points[k]));\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return sol==INT_MAX?0:sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nProblem can\\'t be done solved in O(n^4) (brute force ) .\\nSo we need to reduce time complexity. I used set to store the co-ordinates of rectangle.\\nand Then used set as replacement for 4th loop in solution\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &p1,vector<int> &p2,vector<int>&p3){\\n\\t\\n\\t// function to find wheater given 3 points intersect at right angle\\n        \\n        int x1 = p1[0]-p2[0];\\n        int x2 = p3[0] - p2[0];\\n        \\n        int y1 = p1[1] -p2[1];\\n        int y2 = p3[1] -p2[1];\\n        \\n        \\n        if((y1==0 && x2==0) || (y2==0 && x1==0)){\\n            return true;\\n        }\\n        else if(y1==0 || x1==0 || y2==0 || x2==0)\\n            return false;\\n        \\n        else if(x1*x2==-y1*y2){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    double dist(vector<int> &p1,vector<int> &p2){\\n        return sqrt((pow(p1[0]-p2[0],2))+ pow(p1[1]-p2[1],2));\\n    }\\n    \\n    double Area(vector<int> &p1,vector<int> &p2,vector<int>&p3){\\n        return dist(p1,p2) * dist(p2,p3);\\n    }\\n    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        set<pair<int,int> > hmap;\\n        \\n        int n = points.size();\\n        \\n        if(n<3)\\n            return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            hmap.insert({points[i][0],points[i][1]});\\n        }\\n        \\n        double sol=INT_MAX;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(isValid(points[i],points[j],points[k])){\\n                        int x = points[i][0] + points[k][0] - points[j][0];\\n                        int y = points[i][1] + points[k][1] - points[j][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[i],points[j],points[k]));\\n                        }\\n                    }\\n                   else  if(isValid(points[i],points[k],points[j])){\\n                        int x = points[i][0] + points[j][0] - points[k][0];\\n                        int y = points[i][1] + points[j][1] - points[k][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[i],points[k],points[j]));\\n                        }\\n                    }\\n                   else if(isValid(points[j],points[i],points[k])){\\n                        int x = points[j][0] + points[k][0] - points[i][0];\\n                        int y = points[j][1] + points[k][1] - points[i][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[j],points[i],points[k]));\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return sol==INT_MAX?0:sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200357,
                "title": "c-understanding-vectors-dot-product",
                "content": "`Good Read:` https://cp-algorithms.com/geometry/basic-geometry.html\\n\\n```\\nusing ll = long long int;\\nclass point {\\n    public:\\n    double x;\\n    double y;\\n\\n    point(double x, double y) : x(x), y(y) {}\\n    \\n    point(vector<int> &p) : x(p[0]), y(p[1]) {}\\n    \\n    double distance(double x1, double y1) {\\n        return sqrt((x1 - x) * (x1 - x) + (y1 - y) * (y1 - y));\\n    }  \\n};\\n\\nclass Solution {\\n    unordered_map<double, vector<vector<point>>> pointMap;\\n    \\n\\t/**\\n\\t\\tmiddle point = (p1 + p2) / 2\\n\\t\\tbut we are creating a hash to keep in pointMap using similar equation.\\n\\t*/\\n    double getMiddlePoint(point &p1, point &p2) {\\n        return ((p1.x + p2.x) * (1e9) + (p1.y + p2.y) * (2)) / 2;\\n    }\\n    \\n    bool is90(point p1, point p2, point p3) {\\n        point v1 = {p1.x - p2.x, p1.y - p2.y}; // vector\\n        point v2 = {p3.x - p2.x, p3.y - p2.y}; // vector\\n        \\n        // compute dot product of vectors\\n        auto dot = v1.x * v2.x + v1.y * v2.y;\\n        // not equal points\\n        bool d1 = p1.x != p2.x or p1.y != p2.y;\\n        bool d2 = p1.x != p3.x or p1.y != p3.y;\\n        \\n        return d1 and d2 and dot == 0;\\n    }\\n    \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        pointMap.clear();\\n        \\n        // create a map using middle point pairs\\n        for (int ptr1 = 0; ptr1 < points.size(); ptr1++) {\\n            for (int ptr2 = ptr1 + 1; ptr2 < points.size(); ptr2++) {\\n                auto point1 = point(points[ptr1]);\\n                auto point2 = point(points[ptr2]);\\n                \\n                auto point3 = getMiddlePoint(point1, point2);\\n                pointMap[point3].push_back({point1, point2});\\n            }\\n        }\\n        \\n        double area = 1e18;\\n        for (auto [middlePoint, pointList]: pointMap) {\\n            for (int ptr1 = 0; ptr1 < pointList.size(); ptr1++) {\\n                for (int ptr2 = ptr1 + 1; ptr2 < pointList.size(); ptr2++) {\\n                    auto pointlist1 = pointList[ptr1];\\n                    auto pointlist2 = pointList[ptr2];\\n                    \\n                    if (is90(pointlist1[0], pointlist2[0], pointlist1[1]) && is90(pointlist2[0], pointlist1[0], pointlist2[1])) {\\n                        double d1 = pointlist1[0].distance(pointlist2[0].x, pointlist2[0].y);\\n                        double d2 = pointlist1[1].distance(pointlist2[0].x, pointlist2[0].y);\\n                        \\n                        area = min(area, d1 * d2);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return area == (1e18) ? 0 : area;\\n    }\\n};",
                "solutionTags": [
                    "Geometry"
                ],
                "code": "class Solution {\\n    unordered_map<double, vector<vector<point>>> pointMap;\\n    \\n\\t/**\\n\\t\\tmiddle point = (p1 + p2) / 2\\n\\t\\tbut we are creating a hash to keep in pointMap using similar equation.\\n\\t*/\\n    double getMiddlePoint(point &p1, point &p2) {\\n        return ((p1.x + p2.x) * (1e9) + (p1.y + p2.y) * (2)) / 2;\\n    }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1744586,
                "content": [
                    {
                        "username": "aryabhishek",
                        "content": "So, no one is going to say anything?"
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s hard af, how is this problem supposed to be a medium problem lol"
                    }
                ]
            }
        ]
    },
    {
        "title": "Design Underground System",
        "question_content": "<p>An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.</p>\n\n<p>Implement the <code>UndergroundSystem</code> class:</p>\n\n<ul>\n\t<li><code>void checkIn(int id, string stationName, int t)</code>\n\n\t<ul>\n\t\t<li>A customer with a card ID equal to <code>id</code>, checks in at the station <code>stationName</code> at time <code>t</code>.</li>\n\t\t<li>A customer can only be checked into one place at a time.</li>\n\t</ul>\n\t</li>\n\t<li><code>void checkOut(int id, string stationName, int t)</code>\n\t<ul>\n\t\t<li>A customer with a card ID equal to <code>id</code>, checks out from the station <code>stationName</code> at time <code>t</code>.</li>\n\t</ul>\n\t</li>\n\t<li><code>double getAverageTime(string startStation, string endStation)</code>\n\t<ul>\n\t\t<li>Returns the average time it takes to travel from <code>startStation</code> to <code>endStation</code>.</li>\n\t\t<li>The average time is computed from all the previous traveling times from <code>startStation</code> to <code>endStation</code> that happened <strong>directly</strong>, meaning a check in at <code>startStation</code> followed by a check out from <code>endStation</code>.</li>\n\t\t<li>The time it takes to travel from <code>startStation</code> to <code>endStation</code> <strong>may be different</strong> from the time it takes to travel from <code>endStation</code> to <code>startStation</code>.</li>\n\t\t<li>There will be at least one customer that has traveled from <code>startStation</code> to <code>endStation</code> before <code>getAverageTime</code> is called.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>You may assume all calls to the <code>checkIn</code> and <code>checkOut</code> methods are consistent. If a customer checks in at time <code>t<sub>1</sub></code> then checks out at time <code>t<sub>2</sub></code>, then <code>t<sub>1</sub> &lt; t<sub>2</sub></code>. All events happen in chronological order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;UndergroundSystem&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;getAverageTime&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;]\n[[],[45,&quot;Leyton&quot;,3],[32,&quot;Paradise&quot;,8],[27,&quot;Leyton&quot;,10],[45,&quot;Waterloo&quot;,15],[27,&quot;Waterloo&quot;,20],[32,&quot;Cambridge&quot;,22],[&quot;Paradise&quot;,&quot;Cambridge&quot;],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Leyton&quot;,24],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Waterloo&quot;,38],[&quot;Leyton&quot;,&quot;Waterloo&quot;]]\n\n<strong>Output</strong>\n[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]\n\n<strong>Explanation</strong>\nUndergroundSystem undergroundSystem = new UndergroundSystem();\nundergroundSystem.checkIn(45, &quot;Leyton&quot;, 3);\nundergroundSystem.checkIn(32, &quot;Paradise&quot;, 8);\nundergroundSystem.checkIn(27, &quot;Leyton&quot;, 10);\nundergroundSystem.checkOut(45, &quot;Waterloo&quot;, 15);  // Customer 45 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 15-3 = 12\nundergroundSystem.checkOut(27, &quot;Waterloo&quot;, 20);  // Customer 27 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 20-10 = 10\nundergroundSystem.checkOut(32, &quot;Cambridge&quot;, 22); // Customer 32 &quot;Paradise&quot; -&gt; &quot;Cambridge&quot; in 22-8 = 14\nundergroundSystem.getAverageTime(&quot;Paradise&quot;, &quot;Cambridge&quot;); // return 14.00000. One trip &quot;Paradise&quot; -&gt; &quot;Cambridge&quot;, (14) / 1 = 14\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);    // return 11.00000. Two trips &quot;Leyton&quot; -&gt; &quot;Waterloo&quot;, (10 + 12) / 2 = 11\nundergroundSystem.checkIn(10, &quot;Leyton&quot;, 24);\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);    // return 11.00000\nundergroundSystem.checkOut(10, &quot;Waterloo&quot;, 38);  // Customer 10 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 38-24 = 14\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);    // return 12.00000. Three trips &quot;Leyton&quot; -&gt; &quot;Waterloo&quot;, (10 + 12 + 14) / 3 = 12\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;UndergroundSystem&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;]\n[[],[10,&quot;Leyton&quot;,3],[10,&quot;Paradise&quot;,8],[&quot;Leyton&quot;,&quot;Paradise&quot;],[5,&quot;Leyton&quot;,10],[5,&quot;Paradise&quot;,16],[&quot;Leyton&quot;,&quot;Paradise&quot;],[2,&quot;Leyton&quot;,21],[2,&quot;Paradise&quot;,30],[&quot;Leyton&quot;,&quot;Paradise&quot;]]\n\n<strong>Output</strong>\n[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]\n\n<strong>Explanation</strong>\nUndergroundSystem undergroundSystem = new UndergroundSystem();\nundergroundSystem.checkIn(10, &quot;Leyton&quot;, 3);\nundergroundSystem.checkOut(10, &quot;Paradise&quot;, 8); // Customer 10 &quot;Leyton&quot; -&gt; &quot;Paradise&quot; in 8-3 = 5\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Paradise&quot;); // return 5.00000, (5) / 1 = 5\nundergroundSystem.checkIn(5, &quot;Leyton&quot;, 10);\nundergroundSystem.checkOut(5, &quot;Paradise&quot;, 16); // Customer 5 &quot;Leyton&quot; -&gt; &quot;Paradise&quot; in 16-10 = 6\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Paradise&quot;); // return 5.50000, (5 + 6) / 2 = 5.5\nundergroundSystem.checkIn(2, &quot;Leyton&quot;, 21);\nundergroundSystem.checkOut(2, &quot;Paradise&quot;, 30); // Customer 2 &quot;Leyton&quot; -&gt; &quot;Paradise&quot; in 30-21 = 9\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Paradise&quot;); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= id, t &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= stationName.length, startStation.length, endStation.length &lt;= 10</code></li>\n\t<li>All strings consist of uppercase and lowercase English letters and digits.</li>\n\t<li>There will be at most <code>2 * 10<sup>4</sup></code> calls <strong>in total</strong> to <code>checkIn</code>, <code>checkOut</code>, and <code>getAverageTime</code>.</li>\n\t<li>Answers within <code>10<sup>-5</sup></code> of the actual value will be accepted.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 554879,
                "title": "c-java-python-hashmap-pair-clean-concise-o-1",
                "content": "In Java 8, a [Pair<V, K>](https://docs.oracle.com/javafx/2/api/javafx/util/Pair.html) is added in `javafx.util` package. The class represent key-value pairs and supports very basic operations like `getKey()`, `getValue()`, `hashCode()`, `equals(java.lang.Object o)`.\\n\\n\\n<iframe src=\"https://leetcode.com/playground/gWGFUbiY/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>",
                "solutionTags": [],
                "code": "In Java 8, a [Pair<V, K>](https://docs.oracle.com/javafx/2/api/javafx/util/Pair.html) is added in `javafx.util` package. The class represent key-value pairs and supports very basic operations like `getKey()`, `getValue()`, `hashCode()`, `equals(java.lang.Object o)`.\\n\\n\\n<iframe src=\"https://leetcode.com/playground/gWGFUbiY/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>",
                "codeTag": "Java"
            },
            {
                "id": 672744,
                "title": "java-solution-for-easy-understanding-using-oops",
                "content": "```\\nclass Passenger {\\n    int checkinTime;\\n    int checkoutTime;\\n    String checkinLocation;\\n    String checkoutLocation;\\n\\n    public Passenger(String checkinLocation, int checkinTime) {\\n        this.checkinLocation = checkinLocation;\\n        this.checkinTime = checkinTime;\\n    }\\n\\n    void checkout(String checkoutLocation, int checkoutTime) {\\n        this.checkoutLocation = checkoutLocation;\\n        this.checkoutTime = checkoutTime;\\n    }\\n\\n}\\n\\nclass Route {\\n    String startStation;\\n    String endStation;\\n    int totalNumberOfTrips;\\n    long totalTimeSpentInTrips;\\n\\n    public Route(String startStation, String endStation) {\\n        this.startStation = startStation;\\n        this.endStation = endStation;\\n    }\\n\\n    double getAverageTime() {\\n        return (double) totalTimeSpentInTrips / totalNumberOfTrips;\\n    }\\n\\n    void addTrip(int startTime, int endTime) {\\n        totalTimeSpentInTrips += endTime - startTime;\\n        totalNumberOfTrips++;\\n    }\\n}\\n\\nclass UndergroundSystem {\\n\\n    Map<Integer, Passenger> currentPassengerMap;\\n    Map<String, Route> routeMap;\\n\\n    public UndergroundSystem() {\\n        currentPassengerMap = new HashMap<>();\\n        routeMap = new HashMap<>();\\n    }\\n\\n    public void checkIn(int id, String stationName, int t) {\\n        if (!currentPassengerMap.containsKey(id)) {\\n            Passenger passenger = new Passenger(stationName, t);\\n            currentPassengerMap.put(id, passenger);\\n        }\\n    }\\n\\n    public void checkOut(int id, String stationName, int t) {\\n        if (currentPassengerMap.containsKey(id)) {\\n            Passenger passenger = currentPassengerMap.get(id);\\n            passenger.checkout(stationName, t);\\n            String routeKey = passenger.checkinLocation + \",\" + passenger.checkoutLocation;\\n            Route route = routeMap.getOrDefault(routeKey, new Route(passenger.checkinLocation, passenger.checkoutLocation));\\n            route.addTrip(passenger.checkinTime, passenger.checkoutTime);\\n            routeMap.put(routeKey, route);\\n            currentPassengerMap.remove(id);\\n        }\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        return routeMap.get(startStation + \",\" + endStation).getAverageTime();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Passenger {\\n    int checkinTime;\\n    int checkoutTime;\\n    String checkinLocation;\\n    String checkoutLocation;\\n\\n    public Passenger(String checkinLocation, int checkinTime) {\\n        this.checkinLocation = checkinLocation;\\n        this.checkinTime = checkinTime;\\n    }\\n\\n    void checkout(String checkoutLocation, int checkoutTime) {\\n        this.checkoutLocation = checkoutLocation;\\n        this.checkoutTime = checkoutTime;\\n    }\\n\\n}\\n\\nclass Route {\\n    String startStation;\\n    String endStation;\\n    int totalNumberOfTrips;\\n    long totalTimeSpentInTrips;\\n\\n    public Route(String startStation, String endStation) {\\n        this.startStation = startStation;\\n        this.endStation = endStation;\\n    }\\n\\n    double getAverageTime() {\\n        return (double) totalTimeSpentInTrips / totalNumberOfTrips;\\n    }\\n\\n    void addTrip(int startTime, int endTime) {\\n        totalTimeSpentInTrips += endTime - startTime;\\n        totalNumberOfTrips++;\\n    }\\n}\\n\\nclass UndergroundSystem {\\n\\n    Map<Integer, Passenger> currentPassengerMap;\\n    Map<String, Route> routeMap;\\n\\n    public UndergroundSystem() {\\n        currentPassengerMap = new HashMap<>();\\n        routeMap = new HashMap<>();\\n    }\\n\\n    public void checkIn(int id, String stationName, int t) {\\n        if (!currentPassengerMap.containsKey(id)) {\\n            Passenger passenger = new Passenger(stationName, t);\\n            currentPassengerMap.put(id, passenger);\\n        }\\n    }\\n\\n    public void checkOut(int id, String stationName, int t) {\\n        if (currentPassengerMap.containsKey(id)) {\\n            Passenger passenger = currentPassengerMap.get(id);\\n            passenger.checkout(stationName, t);\\n            String routeKey = passenger.checkinLocation + \",\" + passenger.checkoutLocation;\\n            Route route = routeMap.getOrDefault(routeKey, new Route(passenger.checkinLocation, passenger.checkoutLocation));\\n            route.addTrip(passenger.checkinTime, passenger.checkoutTime);\\n            routeMap.put(routeKey, route);\\n            currentPassengerMap.remove(id);\\n        }\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        return routeMap.get(startStation + \",\" + endStation).getAverageTime();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118415,
                "title": "python-dictionary-counters-solution-explained",
                "content": "The main difficulty of this problem is very long statement, and probably you will spend more time understanding what is asked that to code it. So, what we have here. We have several persons, defined by `id`, which Check In at some `station` and some `time` and then Check Out from some other station at another time. We need to calculate times this person spend to go from one station to another and then calculate average time for all persons. Let us keep 3 pieces of information:\\n\\n1. `self.ids` is dictionary, where for each person(id) we will keep pair `(station, time)` if the last action this person did is check In and empty if it was check OUt\\n2. `self.pairs` is counter, where for each pair of stations we keep total time spend between two stations.\\n3. `self.freqs` is counter, where for each pair of stations we keep how many trips we have between these two stations.\\n\\nNow, let us discuss, what our functions will do:\\n1. `checkIn(self, id, stationName, t)`: we just put pair `(stationName, t)` into `self.ids[id]`.\\n2. `checkOut(self, id, stationName, t)`. Here we look at person `id`, extract information about his last station visited (pop it from `self.ids[id]` and update `self.pairs`, `self.freqs` for these pairs of stations.\\n3. `getAverageTime(self, startStation, endStation)`: here we just look at dictionaries `self.pairs` and `self.freqs` and directly return result.\\n\\n**Complexity**: time compexlty is `O(1)` for all `3` operations. Space complexity potentially is `O(Q)`, where `Q` is toatl number of queries.\\n\\n```\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.ids = {}\\n        self.pairs = Counter()\\n        self.freqs = Counter()\\n        \\n    def checkIn(self, id, stationName, t):\\n        self.ids[id] = (stationName, t)\\n\\n    def checkOut(self, id, stationName, t):\\n        Name2, t2 = self.ids.pop(id)\\n        self.pairs[(Name2, stationName)] += t-t2\\n        self.freqs[(Name2, stationName)] += 1\\n        \\n    def getAverageTime(self, startStation, endStation):\\n        return self.pairs[startStation, endStation]/self.freqs[startStation, endStation]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.ids = {}\\n        self.pairs = Counter()\\n        self.freqs = Counter()\\n        \\n    def checkIn(self, id, stationName, t):\\n        self.ids[id] = (stationName, t)\\n\\n    def checkOut(self, id, stationName, t):\\n        Name2, t2 = self.ids.pop(id)\\n        self.pairs[(Name2, stationName)] += t-t2\\n        self.freqs[(Name2, stationName)] += 1\\n        \\n    def getAverageTime(self, startStation, endStation):\\n        return self.pairs[startStation, endStation]/self.freqs[startStation, endStation]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554899,
                "title": "c-minimalizm",
                "content": "We need a hash map for check-ins `m`, and hash map for the statistic `stats`. For each combinatino of `startStation + endStation`, we track the total duration and the number of trips.\\n\\n```cpp\\nunordered_map<int, pair<string, int>> m;\\nunordered_map<string, pair<int, int>> stats;\\nvoid checkIn(int id, string startStation, int timeIn) {\\n    m[id] = {startStation, timeIn};\\n}\\nvoid checkOut(int id, string endStation, int timeOut) {\\n    const auto &[startStation, timeIn] = m[id];\\n    auto &[totalDuration, tripsCnt] = stats[startStation + \">\" + endStation];\\n    totalDuration += timeOut - timeIn;\\n    ++tripsCnt;\\n}\\ndouble getAverageTime(string startStation, string endStation) {\\n    auto [totalDuration, tripsCnt] = stats[startStation + \">\" + endStation];\\n    return (double)totalDuration / tripsCnt;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nunordered_map<int, pair<string, int>> m;\\nunordered_map<string, pair<int, int>> stats;\\nvoid checkIn(int id, string startStation, int timeIn) {\\n    m[id] = {startStation, timeIn};\\n}\\nvoid checkOut(int id, string endStation, int timeOut) {\\n    const auto &[startStation, timeIn] = m[id];\\n    auto &[totalDuration, tripsCnt] = stats[startStation + \">\" + endStation];\\n    totalDuration += timeOut - timeIn;\\n    ++tripsCnt;\\n}\\ndouble getAverageTime(string startStation, string endStation) {\\n    auto [totalDuration, tripsCnt] = stats[startStation + \">\" + endStation];\\n    return (double)totalDuration / tripsCnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976674,
                "title": "explanation",
                "content": "We, need to Design an Underground System,\\n**This system will do 3 thing\\'s for us :-**\\n1. Check customer into a station\\n\\n\\n2. Check customer out of a station\\n3. Average travel b/w station\\n\\n<hr>\\n<hr>\\n\\n**`checkIn(int id, String stationName, int t)`**\\nhere **id** is a unique identification to customer\\n& **stationName** must check customer name into station at time **t**\\n\\n<hr>\\n<hr>\\n\\n**`checkOut(int id, String stationName, int t)`**\\nwe have to reach to our final station\\n\\n<hr>\\n<hr>\\n\\n**`getAverageTime(String startStation, String endStation)`**\\ncalculate avergae time b/w these 2 stations\\n\\n<hr>\\n<hr>\\n\\n```\\nNow we have to keep Track of our customer checkedIn & checkedOut unique Id\\'s using our map\\nSo, we just create a map called passengersArrivals\\nMap<id, (id, station, t)> passengersArrivals;\\n```\\n\\n```\\nNow we have to keep Track of all previous station & once again we gonna use map for that\\n\\nTake 2 station\\'s :-   A         ,          B\\n& we have a comma b/w them. That\\'ll be the unique key b/w travel of those 2 stations.\\n\\nSo, in our map we\\'ll have:-\\nmap<names, (total, count)> routeAverage;\\nhere total is :- sum of all the travel that has happen b/w these 2 stations\\nhere count is :- amount of customer that travel b/w these 2 stations\\n\\nEasily compute the avergae in any time by simple doing \"total / count\"\\n```\\n\\n**Let\\'s Understood it visually,**\\n\\n![image](https://assets.leetcode.com/users/images/6650fece-806f-4f8a-8273-9a765eae9bb7_1650766902.7239835.gif)\\n\\n```\\nclass UndergroundSystem {\\n    \\n    class passenger{\\n        public int id;\\n        public String stationName;\\n        public int time;\\n        \\n        public passenger(int id, String stationName, int time){\\n            this.id = id;\\n            this.stationName = stationName;\\n            this.time = time;\\n        }\\n    }\\n    \\n    class route{\\n        public double total = 0;\\n        public int count = 0;\\n        \\n        public void update(int difference){\\n            count++;\\n            total += difference;\\n        }\\n        public double getAvg(){\\n            return total / count;\\n        }\\n    }\\n    \\n    public Map<Integer, passenger> passengersArrivals;\\n    public Map<String, route> routeAverage;\\n\\n    public UndergroundSystem() {\\n        passengersArrivals = new HashMap<>();\\n        routeAverage = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        passengersArrivals.put(id, new passenger(id, stationName, t));\\n    }\\n    \\n    public final String DELIMETER = \",\";\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        passenger arrivePassenger = passengersArrivals.get(id);\\n        passengersArrivals.remove(id);\\n        \\n        int difference = t - arrivePassenger.time;\\n        String key = arrivePassenger.stationName + DELIMETER + stationName;\\n        \\n        route average = routeAverage.containsKey(key) ? routeAverage.get(key) : new route();\\n        average.update(difference);\\n        \\n        routeAverage.put(key, average);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = startStation + DELIMETER + endStation;\\n        return routeAverage.get(key).getAvg();\\n    }\\n}\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(1) as we are using HashMap, anything we are doing inserting, removing taking O(1)\\n\\n* **Space Complexity :-** BigO(N + M) where N is no. of passengersArrivals we have & M is no. of routeAverage we have",
                "solutionTags": [],
                "code": "```\\nNow we have to keep Track of our customer checkedIn & checkedOut unique Id\\'s using our map\\nSo, we just create a map called passengersArrivals\\nMap<id, (id, station, t)> passengersArrivals;\\n```\n```\\nNow we have to keep Track of all previous station & once again we gonna use map for that\\n\\nTake 2 station\\'s :-   A         ,          B\\n& we have a comma b/w them. That\\'ll be the unique key b/w travel of those 2 stations.\\n\\nSo, in our map we\\'ll have:-\\nmap<names, (total, count)> routeAverage;\\nhere total is :- sum of all the travel that has happen b/w these 2 stations\\nhere count is :- amount of customer that travel b/w these 2 stations\\n\\nEasily compute the avergae in any time by simple doing \"total / count\"\\n```\n```\\nclass UndergroundSystem {\\n    \\n    class passenger{\\n        public int id;\\n        public String stationName;\\n        public int time;\\n        \\n        public passenger(int id, String stationName, int time){\\n            this.id = id;\\n            this.stationName = stationName;\\n            this.time = time;\\n        }\\n    }\\n    \\n    class route{\\n        public double total = 0;\\n        public int count = 0;\\n        \\n        public void update(int difference){\\n            count++;\\n            total += difference;\\n        }\\n        public double getAvg(){\\n            return total / count;\\n        }\\n    }\\n    \\n    public Map<Integer, passenger> passengersArrivals;\\n    public Map<String, route> routeAverage;\\n\\n    public UndergroundSystem() {\\n        passengersArrivals = new HashMap<>();\\n        routeAverage = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        passengersArrivals.put(id, new passenger(id, stationName, t));\\n    }\\n    \\n    public final String DELIMETER = \",\";\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        passenger arrivePassenger = passengersArrivals.get(id);\\n        passengersArrivals.remove(id);\\n        \\n        int difference = t - arrivePassenger.time;\\n        String key = arrivePassenger.stationName + DELIMETER + stationName;\\n        \\n        route average = routeAverage.containsKey(key) ? routeAverage.get(key) : new route();\\n        average.update(difference);\\n        \\n        routeAverage.put(key, average);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = startStation + DELIMETER + endStation;\\n        return routeAverage.get(key).getAvg();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580382,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for first 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution\\n\\n# Search \\uD83D\\uDC49 `Design Underground System By Tech Wired` \\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n\\n# Approach:\\n\\nTo design the \"Underground System,\" we can use two data structures: one to store the check-in information and another to store the travel times. Here is the overall approach:\\n\\n- For check-in:\\nWhen a customer checks in, store their ID along with the station name and check-in time in a dictionary or map. This will allow us to retrieve the check-in information later when the customer checks out.\\n- For check-out:\\nWhen a customer checks out, retrieve their check-in information from the dictionary using their ID.\\nCalculate the travel time by subtracting the check-in time from the current check-out time.\\n- Update the travel times dictionary:\\nIf the (start_station, end_station) pair already exists in the dictionary, update the total time and increment the count.\\nOtherwise, create a new entry in the dictionary with the initial travel time and count.\\n- For calculating average travel time:\\nRetrieve the total time and count from the travel times dictionary for the given (startStation, endStation) pair.\\nCalculate and return the average travel time by dividing the total time by the count.\\n# Intuition:\\n\\nThe approach leverages the concept of storing relevant information at check-in and using it to calculate the travel times at check-out. By storing the check-in information in a dictionary or map, we can easily retrieve it when needed. Similarly, the travel times are stored in another dictionary, where the (start_station, end_station) pair serves as the key, and the total time and count are stored as values.\\n\\nThe use of these data structures allows for efficient retrieval and update operations. The solution optimizes both time and space complexity by removing unnecessary check-in information once the customer has checked out and by utilizing appropriate data structures to track travel times efficiently.\\n\\n```Python []\\nclass UndergroundSystem:\\n    def __init__(self):\\n        # Dictionary to store total travel time and count for each (start_station, end_station) pair\\n        self.travel_times = {}\\n\\n        # Dictionary to store check-in information with customer_id as key and (start_station, check_in_time) as value\\n        self.check_ins = {}\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.check_ins[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        start_station, check_in_time = self.check_ins.pop(id)\\n        travel = (start_station, stationName)\\n        travel_time = t - check_in_time\\n\\n        if travel in self.travel_times:\\n            total_time, count = self.travel_times[travel]\\n            self.travel_times[travel] = (total_time + travel_time, count + 1)\\n        else:\\n            self.travel_times[travel] = (travel_time, 1)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        travel = (startStation, endStation)\\n        total_time, count = self.travel_times[travel]\\n        return total_time / count\\n\\n```\\n```Java []\\n\\nclass UndergroundSystem {\\n    private Map<Integer, CheckInInfo> checkIns;\\n    private Map<String, TravelInfo> travelTimes;\\n\\n    public UndergroundSystem() {\\n        checkIns = new HashMap<>();\\n        travelTimes = new HashMap<>();\\n    }\\n\\n    public void checkIn(int id, String stationName, int t) {\\n        checkIns.put(id, new CheckInInfo(stationName, t));\\n    }\\n\\n    public void checkOut(int id, String stationName, int t) {\\n        CheckInInfo checkInInfo = checkIns.remove(id);\\n        String travel = checkInInfo.stationName + \",\" + stationName;\\n        int travelTime = t - checkInInfo.checkInTime;\\n\\n        if (travelTimes.containsKey(travel)) {\\n            TravelInfo travelInfo = travelTimes.get(travel);\\n            travelInfo.totalTime += travelTime;\\n            travelInfo.count++;\\n        } else {\\n            travelTimes.put(travel, new TravelInfo(travelTime, 1));\\n        }\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        String travel = startStation + \",\" + endStation;\\n        TravelInfo travelInfo = travelTimes.get(travel);\\n        return (double) travelInfo.totalTime / travelInfo.count;\\n    }\\n\\n    private class CheckInInfo {\\n        String stationName;\\n        int checkInTime;\\n\\n        public CheckInInfo(String stationName, int checkInTime) {\\n            this.stationName = stationName;\\n            this.checkInTime = checkInTime;\\n        }\\n    }\\n\\n    private class TravelInfo {\\n        int totalTime;\\n        int count;\\n\\n        public TravelInfo(int totalTime, int count) {\\n            this.totalTime = totalTime;\\n            this.count = count;\\n        }\\n    }\\n}\\n\\n```\\n```C++ []\\n\\n\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {}\\n\\n    void checkIn(int id, string stationName, int t) {\\n        checkIns[id] = make_pair(stationName, t);\\n    }\\n\\n    void checkOut(int id, string stationName, int t) {\\n        auto checkInInfo = checkIns[id];\\n        checkIns.erase(id);\\n        string travel = checkInInfo.first + \",\" + stationName;\\n        int travelTime = t - checkInInfo.second;\\n\\n        if (travelTimes.find(travel) != travelTimes.end()) {\\n            travelTimes[travel].first += travelTime;\\n            travelTimes[travel].second++;\\n        } else {\\n            travelTimes[travel] = make_pair(travelTime, 1);\\n        }\\n    }\\n\\n    double getAverageTime(string startStation, string endStation) {\\n        string travel = startStation + \",\" + endStation;\\n        auto travelInfo = travelTimes[travel];\\n        return (double) travelInfo.first / travelInfo.second;\\n    }\\n\\nprivate:\\n    unordered_map<int, pair<string, int>> checkIns;\\n    unordered_map<string, pair<int, int>> travelTimes;\\n};\\n\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Design"
                ],
                "code": "```Python []\\nclass UndergroundSystem:\\n    def __init__(self):\\n        # Dictionary to store total travel time and count for each (start_station, end_station) pair\\n        self.travel_times = {}\\n\\n        # Dictionary to store check-in information with customer_id as key and (start_station, check_in_time) as value\\n        self.check_ins = {}\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.check_ins[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        start_station, check_in_time = self.check_ins.pop(id)\\n        travel = (start_station, stationName)\\n        travel_time = t - check_in_time\\n\\n        if travel in self.travel_times:\\n            total_time, count = self.travel_times[travel]\\n            self.travel_times[travel] = (total_time + travel_time, count + 1)\\n        else:\\n            self.travel_times[travel] = (travel_time, 1)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        travel = (startStation, endStation)\\n        total_time, count = self.travel_times[travel]\\n        return total_time / count\\n\\n```\n```Java []\\n\\nclass UndergroundSystem {\\n    private Map<Integer, CheckInInfo> checkIns;\\n    private Map<String, TravelInfo> travelTimes;\\n\\n    public UndergroundSystem() {\\n        checkIns = new HashMap<>();\\n        travelTimes = new HashMap<>();\\n    }\\n\\n    public void checkIn(int id, String stationName, int t) {\\n        checkIns.put(id, new CheckInInfo(stationName, t));\\n    }\\n\\n    public void checkOut(int id, String stationName, int t) {\\n        CheckInInfo checkInInfo = checkIns.remove(id);\\n        String travel = checkInInfo.stationName + \",\" + stationName;\\n        int travelTime = t - checkInInfo.checkInTime;\\n\\n        if (travelTimes.containsKey(travel)) {\\n            TravelInfo travelInfo = travelTimes.get(travel);\\n            travelInfo.totalTime += travelTime;\\n            travelInfo.count++;\\n        } else {\\n            travelTimes.put(travel, new TravelInfo(travelTime, 1));\\n        }\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        String travel = startStation + \",\" + endStation;\\n        TravelInfo travelInfo = travelTimes.get(travel);\\n        return (double) travelInfo.totalTime / travelInfo.count;\\n    }\\n\\n    private class CheckInInfo {\\n        String stationName;\\n        int checkInTime;\\n\\n        public CheckInInfo(String stationName, int checkInTime) {\\n            this.stationName = stationName;\\n            this.checkInTime = checkInTime;\\n        }\\n    }\\n\\n    private class TravelInfo {\\n        int totalTime;\\n        int count;\\n\\n        public TravelInfo(int totalTime, int count) {\\n            this.totalTime = totalTime;\\n            this.count = count;\\n        }\\n    }\\n}\\n\\n```\n```C++ []\\n\\n\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {}\\n\\n    void checkIn(int id, string stationName, int t) {\\n        checkIns[id] = make_pair(stationName, t);\\n    }\\n\\n    void checkOut(int id, string stationName, int t) {\\n        auto checkInInfo = checkIns[id];\\n        checkIns.erase(id);\\n        string travel = checkInInfo.first + \",\" + stationName;\\n        int travelTime = t - checkInInfo.second;\\n\\n        if (travelTimes.find(travel) != travelTimes.end()) {\\n            travelTimes[travel].first += travelTime;\\n            travelTimes[travel].second++;\\n        } else {\\n            travelTimes[travel] = make_pair(travelTime, 1);\\n        }\\n    }\\n\\n    double getAverageTime(string startStation, string endStation) {\\n        string travel = startStation + \",\" + endStation;\\n        auto travelInfo = travelTimes[travel];\\n        return (double) travelInfo.first / travelInfo.second;\\n    }\\n\\nprivate:\\n    unordered_map<int, pair<string, int>> checkIns;\\n    unordered_map<string, pair<int, int>> travelTimes;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976515,
                "title": "c-unordered-map",
                "content": "Solved LIVE ON STREAM.  Tune in everyday 6pm PT (4pm on saturday\\'s).  Link in profile.\\n\\n```\\nclass UndergroundSystem {\\npublic:\\n    //startStation:endStation -> {totalTime, numberOfTrips}\\n    unordered_map<string, pair<long long, int>> stationTimes;\\n    //customerId -> startStation\\n    unordered_map<int, pair<string,int>> inTransit;\\n    UndergroundSystem() {\\n        stationTimes.clear();\\n        inTransit.clear();\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(inTransit.find(id) != inTransit.end()) return;\\n        inTransit[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& info = inTransit[id];\\n        string startStation = info.first;\\n        int startTime = info.second;\\n        string key = startStation + \":\" + stationName;\\n        int time = t - startTime;\\n        \\n        if(stationTimes.find(key) != stationTimes.end()) {\\n            auto& oldTimes = stationTimes[key];\\n            oldTimes.first += time;\\n            oldTimes.second++;\\n        } else {\\n            stationTimes[key] = {time, 1};\\n        }\\n        inTransit.erase(id);\\n        \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string key = startStation + \":\" + endStation;\\n        auto& info = stationTimes[key];\\n        double avg = (double)info.first / (double)info.second;\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    //startStation:endStation -> {totalTime, numberOfTrips}\\n    unordered_map<string, pair<long long, int>> stationTimes;\\n    //customerId -> startStation\\n    unordered_map<int, pair<string,int>> inTransit;\\n    UndergroundSystem() {\\n        stationTimes.clear();\\n        inTransit.clear();\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(inTransit.find(id) != inTransit.end()) return;\\n        inTransit[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& info = inTransit[id];\\n        string startStation = info.first;\\n        int startTime = info.second;\\n        string key = startStation + \":\" + stationName;\\n        int time = t - startTime;\\n        \\n        if(stationTimes.find(key) != stationTimes.end()) {\\n            auto& oldTimes = stationTimes[key];\\n            oldTimes.first += time;\\n            oldTimes.second++;\\n        } else {\\n            stationTimes[key] = {time, 1};\\n        }\\n        inTransit.erase(id);\\n        \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string key = startStation + \":\" + endStation;\\n        auto& info = stationTimes[key];\\n        double avg = (double)info.first / (double)info.second;\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555393,
                "title": "clean-python-code",
                "content": "\\n\\n\\tdef __init__(self):\\n        self.user = collections.defaultdict(list)\\n        self.dest = collections.defaultdict(list)\\n\\n    def checkIn(self, id, stationName, t):\\n        \"\"\"\\n        :type id: int\\n        :type stationName: str\\n        :type t: int\\n        :rtype: None\\n        \"\"\"\\n        self.user[id] = [stationName, t]\\n\\n    def checkOut(self, id, stationName, t):\\n        \"\"\"\\n        :type id: int\\n        :type stationName: str\\n        :type t: int\\n        :rtype: None\\n        \"\"\"\\n        start_station, prev_time = self.user[id]\\n        self.dest[(start_station, stationName)].append(t-prev_time)\\n\\n    def getAverageTime(self, startStation, endStation):\\n        \"\"\"\\n        :type startStation: str\\n        :type endStation: str\\n        :rtype: float\\n        \"\"\"\\n        return float(sum(self.dest[(startStation,endStation)]))/len(self.dest[(startStation,endStation)])",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n\\tdef __init__(self):\\n        self.user = collections.defaultdict(list)\\n        self.dest = collections.defaultdict(list)\\n\\n    def checkIn(self, id, stationName, t):\\n        \"\"\"\\n        :type id: int\\n        :type stationName: str\\n        :type t: int\\n        :rtype: None\\n        \"\"\"\\n        self.user[id] = [stationName, t]\\n\\n    def checkOut(self, id, stationName, t):\\n        \"\"\"\\n        :type id: int\\n        :type stationName: str\\n        :type t: int\\n        :rtype: None\\n        \"\"\"\\n        start_station, prev_time = self.user[id]\\n        self.dest[(start_station, stationName)].append(t-prev_time)\\n\\n    def getAverageTime(self, startStation, endStation):\\n        \"\"\"\\n        :type startStation: str\\n        :type endStation: str\\n        :rtype: float\\n        \"\"\"\\n        return float(sum(self.dest[(startStation,endStation)]))/len(self.dest[(startStation,endStation)])",
                "codeTag": "Python3"
            },
            {
                "id": 1977026,
                "title": "easiest-way-by-using-map",
                "content": "```\\n//Please do upvote, if you like my solution :)\\n//and free to ask if have any query :)\\nclass dataa{\\npublic:\\n    string from;\\n    string to;\\n    int in;\\n    int out;\\n};\\nclass UndergroundSystem {\\npublic:\\n    map<pair<string,string>,vector<int>> loc;\\n    map<int,dataa> store;\\n\\t\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        dataa d;\\n        d.from = stationName;\\n        d.in = t;\\n        store[id] = d;\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        dataa d = store[id];\\n        d.to = stationName;\\n        d.out = t;\\n        loc[{d.from,d.to}].push_back(d.out-d.in);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        auto &time = loc[{startStation,endStation}];\\n        double size = time.size();\\n        return accumulate(time.begin(),time.end(),0)/size;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\n//Please do upvote, if you like my solution :)\\n//and free to ask if have any query :)\\nclass dataa{\\npublic:\\n    string from;\\n    string to;\\n    int in;\\n    int out;\\n};\\nclass UndergroundSystem {\\npublic:\\n    map<pair<string,string>,vector<int>> loc;\\n    map<int,dataa> store;\\n\\t\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        dataa d;\\n        d.from = stationName;\\n        d.in = t;\\n        store[id] = d;\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        dataa d = store[id];\\n        d.to = stationName;\\n        d.out = t;\\n        loc[{d.from,d.to}].push_back(d.out-d.in);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        auto &time = loc[{startStation,endStation}];\\n        double size = time.size();\\n        return accumulate(time.begin(),time.end(),0)/size;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118373,
                "title": "short-easy-w-explanation-o-1-time-beats-100-time-space",
                "content": "We need two data structures, specifically hashmaps - \\n* **`checkIns`** : It maps customer id to checkin station and time.\\n* **`routeTimings`**: It maps startStation-endStation to total timings and number of records of startStation-endStation till now.\\n\\nThe rest of solution can be understood from comments in the solution below : \\n\\n```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int> >checkIns;        // id : {stationName, time}\\n    unordered_map<string, pair<int, int> >routeTimings;    // startStation-endStation : {sumOfTime, count}\\npublic:\\n    UndergroundSystem() {  }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkIns[id] = {stationName, t};           // store id checked in at stationName at time t\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n\\t    //                     startStation       -    endStation\\n        string startToEnd = checkIns[id].first + \\'-\\' + stationName; \\n\\t\\t// update route\\'s total time and count\\n        routeTimings[startToEnd] = {routeTimings[startToEnd].first + (t - checkIns[id].second), routeTimings[startToEnd].second + 1};\\n        checkIns.erase(id); // erase checkin data to free up memory\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        pair<int, int> p = routeTimings[startStation + \\'-\\' + endStation];\\n\\t\\t// divide   total time by total cound to get average route time\\n        return (double)p.first / p.second;\\n    }\\n};\\n```\\n**`Time Complexity`** : **`O(1)`** , since a hashmap functions in amortized O(1) time.\\n**`Space Complexity`** : **`O(N^2)`**, where `N` is total number of stations. In the worst case, routes from all stations to all stations will have to be stored. For a graph having `N` nodes, max number of edges is equal to `N*(N-1)/2` = `O(N^2)`\\n\\n\\n![image](https://assets.leetcode.com/users/images/7dc0354a-24a0-43f8-8165-e22bdce68e67_1616232947.3673246.png)\\n\\nThe 100% memory was achieved by storing *hash of string* instead of the whole string itself. Try it at your end and a good hash function might lead to an even lower runtime\\n\\n----------\\n---------\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int> >checkIns;        // id : {stationName, time}\\n    unordered_map<string, pair<int, int> >routeTimings;    // startStation-endStation : {sumOfTime, count}\\npublic:\\n    UndergroundSystem() {  }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkIns[id] = {stationName, t};           // store id checked in at stationName at time t\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n\\t    //                     startStation       -    endStation\\n        string startToEnd = checkIns[id].first + \\'-\\' + stationName; \\n\\t\\t// update route\\'s total time and count\\n        routeTimings[startToEnd] = {routeTimings[startToEnd].first + (t - checkIns[id].second), routeTimings[startToEnd].second + 1};\\n        checkIns.erase(id); // erase checkin data to free up memory\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        pair<int, int> p = routeTimings[startStation + \\'-\\' + endStation];\\n\\t\\t// divide   total time by total cound to get average route time\\n        return (double)p.first / p.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580975,
                "title": "java-using-maps-12-lines-beast-82",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UndergroundSystem {\\n  private Map<Integer, Pair<String, Integer>> checkIns = new HashMap<>();\\n  private Map<Pair<String, String>, int[]> times = new HashMap<>();\\n  \\n  public void checkIn(int id, String stationName, int t) {\\n    checkIns.put(id, new Pair(stationName, t));\\n  }\\n  \\n  public void checkOut(int id, String stationName, int t) {\\n    var startStation = checkIns.get(id).getKey();\\n    var startTime = checkIns.get(id).getValue();\\n    checkIns.remove(id);\\n\\n    var pair = new Pair(startStation, stationName);\\n    var totalTime = times.containsKey(pair) ? times.get(pair)[0] : 0;\\n    var dataPoints = times.containsKey(pair) ? times.get(pair)[1] : 0;\\n\\n    times.put(pair, new int[] {totalTime + t - startTime, dataPoints + 1});\\n  }\\n  \\n  public double getAverageTime(String startStation, String endStation) {\\n    var pair = new Pair(startStation, endStation);\\n\\n    return (double) times.get(pair)[0] / times.get(pair)[1];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass UndergroundSystem {\\n  private Map<Integer, Pair<String, Integer>> checkIns = new HashMap<>();\\n  private Map<Pair<String, String>, int[]> times = new HashMap<>();\\n  \\n  public void checkIn(int id, String stationName, int t) {\\n    checkIns.put(id, new Pair(stationName, t));\\n  }\\n  \\n  public void checkOut(int id, String stationName, int t) {\\n    var startStation = checkIns.get(id).getKey();\\n    var startTime = checkIns.get(id).getValue();\\n    checkIns.remove(id);\\n\\n    var pair = new Pair(startStation, stationName);\\n    var totalTime = times.containsKey(pair) ? times.get(pair)[0] : 0;\\n    var dataPoints = times.containsKey(pair) ? times.get(pair)[1] : 0;\\n\\n    times.put(pair, new int[] {totalTime + t - startTime, dataPoints + 1});\\n  }\\n  \\n  public double getAverageTime(String startStation, String endStation) {\\n    var pair = new Pair(startStation, endStation);\\n\\n    return (double) times.get(pair)[0] / times.get(pair)[1];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976766,
                "title": "python-two-dictionaries-simple-and-short",
                "content": "We\\'ll keep a dictionary of the checked in customers that will keep track of `startStation` and `startTime`. When the customer checks out, the total time of their trip will be added to a second dictionary that keeps track of all the times from `startStation` to `endStation`. \\n\\n*Same solution in C++ <a href=\"https://leetcode.com/problems/design-underground-system/discuss/1976796/C%2B%2B-or-Double-unordered_map-or-Simple-and-Short\">here</a>.*\\n```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.tripTimes = {}\\n        self.checkedInCustomers = {}\\n        \\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkedInCustomers[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        startStation, startTime = self.checkedInCustomers[id]\\n        del self.checkedInCustomers[id]\\n        tripTime = t - startTime\\n        \\n        if (startStation, stationName) not in self.tripTimes:\\n            self.tripTimes[(startStation, stationName)] = [tripTime, 1]\\n        else:\\n            self.tripTimes[(startStation, stationName)][0] += tripTime\\n            self.tripTimes[(startStation, stationName)][1] += 1\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        sumOfTimes, numberOfTrips = self.tripTimes[(startStation, endStation)]\\n        \\n        return sumOfTimes / numberOfTrips\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.tripTimes = {}\\n        self.checkedInCustomers = {}\\n        \\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkedInCustomers[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        startStation, startTime = self.checkedInCustomers[id]\\n        del self.checkedInCustomers[id]\\n        tripTime = t - startTime\\n        \\n        if (startStation, stationName) not in self.tripTimes:\\n            self.tripTimes[(startStation, stationName)] = [tripTime, 1]\\n        else:\\n            self.tripTimes[(startStation, stationName)][0] += tripTime\\n            self.tripTimes[(startStation, stationName)][1] += 1\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        sumOfTimes, numberOfTrips = self.tripTimes[(startStation, endStation)]\\n        \\n        return sumOfTimes / numberOfTrips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118385,
                "title": "c-fastest-solution-to-date-92ms-explained-100-time-60-space",
                "content": "Great design problem that we can tackle in a rather straightforward way with 2 data structures - plus the extra challenge of squeezing as much performance as possible out of it.\\n\\nTo do so, we declare at class level 2 support variables:\\n* `checkInMap`, as the name implies, will store data on checkins, in the `id => {entryStation, entryTime}` format (the latter being a `pair<string, int>` );\\n* `avgTimesMap`, as the name implies, will store data on checkins, in the `travelName => {numberOfTravels, overallTime}` format (the latter being a `pair<int, int>` ).\\n\\nWe do not need a constructor here (since each test will instantiate a new `UndergroundSystem` object) and can move on with the easiest bit, `checkIn`, in which we will just store `{stationName, -t}` in `checkInMap[id]`.\\n\\nNotice that we do not need to do any extra checks, since we are told we will be always dealt valid travels; and notice we stored `-t` for convenience, since we will now subtract the starting time as we proceed to write `checkOut`.\\n\\nThis function will:\\n* retrieve and store in `entryData` information about the checkin of the same `id`;\\n* compute `travelName` trivially as the sum of the entry and exit station names (I considered hashing it a bit better, but it seemed needlessly expensive/convoluted);\\n* work on `currTravel`, updating the number of travels by `1` and the overall duration by `entryData.second + t` (ie: the exit time - the entry time, since we stored the latter as a negative value in `entryData.second` before);\\n* update `avgTimesMap[travelName]` with `currTravel`.\\n\\nFinally, in `getAverageTime`, we will just have to:\\n* similarly compute `travelName`as the sum of the entry and exit station names;\\n* retrieve the stored information for `travelName`  and put it into `currTravel`;\\n* return the quotient of the overall time (`currTravel.first`) divided by the number of travels (`currTravel.second`), after casting one of them as a double (instead of storing them as `double`s, that might cost more memory for little gain).\\n\\nThe code:\\n\\n```cpp\\nclass UndergroundSystem {\\n    // id => {entryStation, entryTime}\\n    unordered_map<int, pair<string, int>> checkInMap;\\n    // travelName => {numberOfTravels, overallTime}\\n    unordered_map<string, pair<int, int>> avgTimesMap;\\npublic:\\n    UndergroundSystem() {\\n        // cout << \"I am a constructor and I am as useless as \\\\\"ueue\\\\\" in \\\\\"queue\\\\\"\\\\n\";\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInMap[id] = {stationName, -t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        // retrieving matching checkin data\\n        auto entryData = checkInMap[id];\\n        // computing travelName id\\n        string travelName = entryData.first + stationName;\\n        // updating data on the current travel\\n        auto currTravel = avgTimesMap[travelName];\\n        currTravel.first++;\\n        currTravel.second += entryData.second + t;\\n        avgTimesMap[travelName] = currTravel;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        // computing travelName id\\n        string travelName = startStation + endStation;\\n        // retrieving data on current travel\\n        auto currTravel = avgTimesMap[travelName];\\n        // returning the average time\\n        return currTravel.second / (double)currTravel.first;\\n    }\\n};\\n```\\n\\nBut, wait a moment: we are hashing twice in `checkOut` - can we avoid it? Well, probably so, so I refactored it a bit and got better performance :):\\n\\n```cpp\\n    void checkOut(int id, string stationName, int t) {\\n        // retrieving matching checkin data\\n        auto entryData = checkInMap[id];\\n        // computing travelName id\\n        string travelName = entryData.first + stationName;\\n        // updating data on the current travel\\n        auto currTravel = avgTimesMap.find(travelName);\\n        if (currTravel == end(avgTimesMap)) avgTimesMap[travelName] = {1, entryData.second + t};\\n        else {\\n            currTravel->second.first++;\\n            currTravel->second.second += entryData.second + t;\\n        }\\n    }\\n```\\n\\nUsing built-in like `.insert()` seems to perform a bit more slowly, I guess because we dereference more with that format:\\n\\n```cpp\\n    void checkOut(int id, string stationName, int t) {\\n        // retrieving matching checkin data\\n        auto entryData = checkInMap[id];\\n        // computing travelName id\\n        string travelName = entryData.first + stationName;\\n        // updating data on the current travel\\n        int updatedTime = entryData.second + t;\\n        auto currInsertion = avgTimesMap.insert({travelName, {1, updatedTime}});\\n        if (!currInsertion.second) {\\n            currInsertion.first->second.first++;\\n            currInsertion.first->second.second += entryData.second + t;\\n        }\\n    }\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/5180a0ff-d4eb-4325-9c76-5890881f3fc0_1616233310.6566305.png)\\n\\nAnd as a trivia from a big fan of arrays and alternatives that avoid the costly hashing function I tried also to replace the first map with this:\\n\\n```cpp\\n    // id => {entryStation, entryTime}\\n    pair<string, int> checkInMap[1000001];\\n```\\n\\nBut it was crazy slow, at about 450-500ms :D\\n\\nI thought it was maybe related with having pairs together, but still mortally slow replacing them with separated arrays:\\n\\n```cpp\\nclass UndergroundSystem {\\n    // id => entryStation\\n    string checkInName[1000001];\\n    // id => entryTime\\n    int checkInTime[1000001];\\n    // id => {numberOfTravels, overallTime}\\n    unordered_map<string, pair<int, int>> avgTimesMap;\\npublic:\\n    UndergroundSystem() {\\n        // cout << \"I am a constructor and I am as useless as \\\\\"ueue\\\\\" in \\\\\"queue\\\\\"\\\\n\";\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInName[id] = stationName;\\n        checkInTime[id] = -t;\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        // retrieving matching checkin data\\n        int travelTime = checkInTime[id] + t;\\n        // computing travelName id\\n        string travelName = checkInName[id] + stationName;\\n        // updating data on the current travel\\n        auto currTravel = avgTimesMap.find(travelName);\\n        if (currTravel == end(avgTimesMap)) avgTimesMap[travelName] = {1, travelTime};\\n        else {\\n            currTravel->second.first++;\\n            currTravel->second.second += travelTime;\\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        // computing travelName id\\n        string travelName = startStation + endStation;\\n        // retrieving data on current travel\\n        auto currTravel = avgTimesMap[travelName];\\n        // returning the average time\\n        return currTravel.second / (double)currTravel.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass UndergroundSystem {\\n    // id => {entryStation, entryTime}\\n    unordered_map<int, pair<string, int>> checkInMap;\\n    // travelName => {numberOfTravels, overallTime}\\n    unordered_map<string, pair<int, int>> avgTimesMap;\\npublic:\\n    UndergroundSystem() {\\n        // cout << \"I am a constructor and I am as useless as \\\\\"ueue\\\\\" in \\\\\"queue\\\\\"\\\\n\";\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInMap[id] = {stationName, -t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        // retrieving matching checkin data\\n        auto entryData = checkInMap[id];\\n        // computing travelName id\\n        string travelName = entryData.first + stationName;\\n        // updating data on the current travel\\n        auto currTravel = avgTimesMap[travelName];\\n        currTravel.first++;\\n        currTravel.second += entryData.second + t;\\n        avgTimesMap[travelName] = currTravel;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        // computing travelName id\\n        string travelName = startStation + endStation;\\n        // retrieving data on current travel\\n        auto currTravel = avgTimesMap[travelName];\\n        // returning the average time\\n        return currTravel.second / (double)currTravel.first;\\n    }\\n};\\n```\n```cpp\\n    void checkOut(int id, string stationName, int t) {\\n        // retrieving matching checkin data\\n        auto entryData = checkInMap[id];\\n        // computing travelName id\\n        string travelName = entryData.first + stationName;\\n        // updating data on the current travel\\n        auto currTravel = avgTimesMap.find(travelName);\\n        if (currTravel == end(avgTimesMap)) avgTimesMap[travelName] = {1, entryData.second + t};\\n        else {\\n            currTravel->second.first++;\\n            currTravel->second.second += entryData.second + t;\\n        }\\n    }\\n```\n```cpp\\n    void checkOut(int id, string stationName, int t) {\\n        // retrieving matching checkin data\\n        auto entryData = checkInMap[id];\\n        // computing travelName id\\n        string travelName = entryData.first + stationName;\\n        // updating data on the current travel\\n        int updatedTime = entryData.second + t;\\n        auto currInsertion = avgTimesMap.insert({travelName, {1, updatedTime}});\\n        if (!currInsertion.second) {\\n            currInsertion.first->second.first++;\\n            currInsertion.first->second.second += entryData.second + t;\\n        }\\n    }\\n```\n```cpp\\n    // id => {entryStation, entryTime}\\n    pair<string, int> checkInMap[1000001];\\n```\n```cpp\\nclass UndergroundSystem {\\n    // id => entryStation\\n    string checkInName[1000001];\\n    // id => entryTime\\n    int checkInTime[1000001];\\n    // id => {numberOfTravels, overallTime}\\n    unordered_map<string, pair<int, int>> avgTimesMap;\\npublic:\\n    UndergroundSystem() {\\n        // cout << \"I am a constructor and I am as useless as \\\\\"ueue\\\\\" in \\\\\"queue\\\\\"\\\\n\";\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInName[id] = stationName;\\n        checkInTime[id] = -t;\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        // retrieving matching checkin data\\n        int travelTime = checkInTime[id] + t;\\n        // computing travelName id\\n        string travelName = checkInName[id] + stationName;\\n        // updating data on the current travel\\n        auto currTravel = avgTimesMap.find(travelName);\\n        if (currTravel == end(avgTimesMap)) avgTimesMap[travelName] = {1, travelTime};\\n        else {\\n            currTravel->second.first++;\\n            currTravel->second.second += travelTime;\\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        // computing travelName id\\n        string travelName = startStation + endStation;\\n        // retrieving data on current travel\\n        auto currTravel = avgTimesMap[travelName];\\n        // returning the average time\\n        return currTravel.second / (double)currTravel.first;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 554802,
                "title": "python-map-solution",
                "content": "```\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.times = defaultdict(lambda : defaultdict(lambda : [0, 0]))\\n        self.transit = defaultdict(list)\\n        \\n\\n    def checkIn(self, id: int, sname: str, t: int) -> None:\\n        self.transit[id].extend([sname, t])\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        srcname, srct = self.transit[id]\\n        count, val = self.times[srcname][stationName] \\n        self.times[srcname][stationName] = [count+1, val+t-srct] \\n        self.transit[id] = []\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        count, val = self.times[startStation][endStation] \\n        return val / count\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.times = defaultdict(lambda : defaultdict(lambda : [0, 0]))\\n        self.transit = defaultdict(list)\\n        \\n\\n    def checkIn(self, id: int, sname: str, t: int) -> None:\\n        self.transit[id].extend([sname, t])\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        srcname, srct = self.transit[id]\\n        count, val = self.times[srcname][stationName] \\n        self.times[srcname][stationName] = [count+1, val+t-srct] \\n        self.transit[id] = []\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        count, val = self.times[startStation][endStation] \\n        return val / count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616336,
                "title": "clean-hashmap-o-1-java",
                "content": "```\\nprivate class StationEntry {\\n        private String stationName;\\n        private int time;\\n\\n        StationEntry(String stationName, int time) {\\n            this.stationName = stationName;\\n            this.time = time;\\n        }\\n    }\\n\\n    Map<Integer, StationEntry> map; // Mapping of id with which station he checked in and ay what time.\\n    Map<String,Integer> countMap; // Mapping of startStation & endStation (one key) with the number of times someone checked in and checked out\\n    Map<String,Double> diffMap; //  Mapping of startStation & endStation (one key) with the diff of the values.\\n\\n    public UndergroundSystem() {\\n        map = new HashMap<>();\\n        countMap =new HashMap<>();\\n        diffMap = new HashMap<>();\\n    }\\n\\n    public void checkIn(int id, String stationName, int t) {\\n        StationEntry entry = new StationEntry(stationName,t);\\n        map.put(id,entry);\\n    }\\n\\n    // calculate diff at checkout time itself.\\n    public void checkOut(int id, String stationName, int t) {\\n        StationEntry entry = map.get(id);\\n        double diff = t - entry.time;\\n        String key = entry.stationName+\"-\"+stationName;\\n        diffMap.put(key,diffMap.getOrDefault(key,0.0)+diff);\\n        countMap.put(key,countMap.getOrDefault(key,0)+1);\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = startStation+\"-\"+endStation;\\n        if(diffMap.containsKey(key)) {\\n            return (diffMap.get(key)/countMap.get(key));\\n        }\\n        return 0.0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate class StationEntry {\\n        private String stationName;\\n        private int time;\\n\\n        StationEntry(String stationName, int time) {\\n            this.stationName = stationName;\\n            this.time = time;\\n        }\\n    }\\n\\n    Map<Integer, StationEntry> map; // Mapping of id with which station he checked in and ay what time.\\n    Map<String,Integer> countMap; // Mapping of startStation & endStation (one key) with the number of times someone checked in and checked out\\n    Map<String,Double> diffMap; //  Mapping of startStation & endStation (one key) with the diff of the values.\\n\\n    public UndergroundSystem() {\\n        map = new HashMap<>();\\n        countMap =new HashMap<>();\\n        diffMap = new HashMap<>();\\n    }\\n\\n    public void checkIn(int id, String stationName, int t) {\\n        StationEntry entry = new StationEntry(stationName,t);\\n        map.put(id,entry);\\n    }\\n\\n    // calculate diff at checkout time itself.\\n    public void checkOut(int id, String stationName, int t) {\\n        StationEntry entry = map.get(id);\\n        double diff = t - entry.time;\\n        String key = entry.stationName+\"-\"+stationName;\\n        diffMap.put(key,diffMap.getOrDefault(key,0.0)+diff);\\n        countMap.put(key,countMap.getOrDefault(key,0)+1);\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = startStation+\"-\"+endStation;\\n        if(diffMap.containsKey(key)) {\\n            return (diffMap.get(key)/countMap.get(key));\\n        }\\n        return 0.0;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582807,
                "title": "java-easy-using-hashmap-intuitive",
                "content": "```\\nclass Pair{\\n    String stationName;\\n    int time;\\n    int distance;\\n    int noofroutes;\\n    Pair(String stationName,int time){\\n        this.stationName=stationName;\\n        this.time=time;\\n    }\\n    Pair(int distance,int noofroutes){\\n        this.distance=distance;\\n        this.noofroutes=noofroutes;\\n    }\\n    \\n}\\nclass UndergroundSystem {\\n    HashMap<String,Pair> travel;\\n    HashMap<Integer,Pair> checkin;\\n    public UndergroundSystem() {\\n        travel=new HashMap<>();\\n        checkin=new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkin.put(id,new Pair(stationName,t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        String startStationName=checkin.get(id).stationName;\\n        int arrivaltime=checkin.get(id).time;\\n        int totaltimetravelled=t-arrivaltime;\\n        String route=startStationName+\"-\"+stationName;\\n        if(!travel.containsKey(route)){\\n            travel.put(route,new Pair(totaltimetravelled,1));\\n        }\\n        else{\\n            int dist=travel.get(route).distance;\\n            int noofroutes=travel.get(route).noofroutes;\\n            travel.put(route,new Pair(dist+totaltimetravelled,noofroutes+1));\\n        }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String route=startStation+\"-\"+endStation;\\n        double avg=0.0;\\n        if(!travel.containsKey(route)){\\n            return avg;\\n        }\\n        else{\\n            avg=travel.get(route).distance/(double)travel.get(route).noofroutes;\\n        }\\n        return avg;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/66a065f3-56e4-4532-b56a-26e671565183_1685545737.1393461.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Pair{\\n    String stationName;\\n    int time;\\n    int distance;\\n    int noofroutes;\\n    Pair(String stationName,int time){\\n        this.stationName=stationName;\\n        this.time=time;\\n    }\\n    Pair(int distance,int noofroutes){\\n        this.distance=distance;\\n        this.noofroutes=noofroutes;\\n    }\\n    \\n}\\nclass UndergroundSystem {\\n    HashMap<String,Pair> travel;\\n    HashMap<Integer,Pair> checkin;\\n    public UndergroundSystem() {\\n        travel=new HashMap<>();\\n        checkin=new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkin.put(id,new Pair(stationName,t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        String startStationName=checkin.get(id).stationName;\\n        int arrivaltime=checkin.get(id).time;\\n        int totaltimetravelled=t-arrivaltime;\\n        String route=startStationName+\"-\"+stationName;\\n        if(!travel.containsKey(route)){\\n            travel.put(route,new Pair(totaltimetravelled,1));\\n        }\\n        else{\\n            int dist=travel.get(route).distance;\\n            int noofroutes=travel.get(route).noofroutes;\\n            travel.put(route,new Pair(dist+totaltimetravelled,noofroutes+1));\\n        }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String route=startStation+\"-\"+endStation;\\n        double avg=0.0;\\n        if(!travel.containsKey(route)){\\n            return avg;\\n        }\\n        else{\\n            avg=travel.get(route).distance/(double)travel.get(route).noofroutes;\\n        }\\n        return avg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581328,
                "title": "c-easy-map",
                "content": "# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n    map<int,pair<int,string>>m;\\n    map<string,pair<int,int>>p;\\n    UndergroundSystem() {\\n        m.clear();\\n        p.clear();\\n    }\\n    \\n    void checkIn(int id, string s, int t) {\\n       m[id] = {t,s};\\n    }\\n    \\n    void checkOut(int id, string s, int t) {\\n        string d = m[id].second + \" \" + s;\\n        auto &i = p[d];\\n        i.first += t - m[id].first;\\n        i.second++;\\n    }\\n    \\n    double getAverageTime(string s, string e) {\\n        string route = s +\" \" + e;\\n        return (double)p[route].first/p[route].second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/c0cdea64-2df5-4fa2-82e1-5f9326090b11_1685516284.455964.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    map<int,pair<int,string>>m;\\n    map<string,pair<int,int>>p;\\n    UndergroundSystem() {\\n        m.clear();\\n        p.clear();\\n    }\\n    \\n    void checkIn(int id, string s, int t) {\\n       m[id] = {t,s};\\n    }\\n    \\n    void checkOut(int id, string s, int t) {\\n        string d = m[id].second + \" \" + s;\\n        auto &i = p[d];\\n        i.first += t - m[id].first;\\n        i.second++;\\n    }\\n    \\n    double getAverageTime(string s, string e) {\\n        string route = s +\" \" + e;\\n        return (double)p[route].first/p[route].second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977911,
                "title": "java-simple-implementation-with-custom-class",
                "content": "```\\n\\nclass passengerData{\\n    int t;\\n    String st;\\n    public passengerData(int t , String st){\\n        this.t =  t;\\n        this.st =  st;\\n    }\\n\\n}\\n\\nclass avgObject{\\n    double total;\\n    int c;\\n    \\n    public avgObject(int c, double time){\\n        this.c =  c;\\n        this.total  =  time;\\n    }\\n    \\n    void updateAvg(double newavg){        \\n        this.total +=  newavg;\\n        this.c+=1;        \\n    }    \\n}\\n\\nclass UndergroundSystem {\\n\\n    \\n    final HashMap<Integer,passengerData> train ;\\n    final Map<String,HashMap<String,avgObject >> record ;\\n    \\n    public UndergroundSystem() {\\n        train =  new HashMap<>();\\n        record =  new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n      \\n        passengerData newcust =  new passengerData(t,stationName);\\n        train.put(id,newcust);\\n        \\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        passengerData cust =  train.get(id);\\n        String startStation =  cust.st;\\n        int duration =  t - cust.t;\\n        \\n        record.putIfAbsent(startStation,new HashMap<>());        \\n        HashMap<String,avgObject > endstation = record.get(startStation);\\n        \\n        avgObject e = endstation.get(stationName);\\n        \\n        if(e!=null){                        \\n            e.updateAvg(duration);\\n        }\\n        else{\\n            avgObject entry =  new avgObject(1,duration);\\n            endstation.put(stationName,entry);            \\n        }\\n        train.remove(id);             \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        HashMap<String,avgObject > station =  record.get(startStation);\\n        avgObject entry =  station.get(endStation);       \\n        return (double)entry.total/entry.c;\\n       \\n    }    \\n}\\n\\n\\n```\\n![image](https://assets.leetcode.com/users/images/9288157c-89a5-4c07-9353-76abe81af972_1650790066.8322887.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass passengerData{\\n    int t;\\n    String st;\\n    public passengerData(int t , String st){\\n        this.t =  t;\\n        this.st =  st;\\n    }\\n\\n}\\n\\nclass avgObject{\\n    double total;\\n    int c;\\n    \\n    public avgObject(int c, double time){\\n        this.c =  c;\\n        this.total  =  time;\\n    }\\n    \\n    void updateAvg(double newavg){        \\n        this.total +=  newavg;\\n        this.c+=1;        \\n    }    \\n}\\n\\nclass UndergroundSystem {\\n\\n    \\n    final HashMap<Integer,passengerData> train ;\\n    final Map<String,HashMap<String,avgObject >> record ;\\n    \\n    public UndergroundSystem() {\\n        train =  new HashMap<>();\\n        record =  new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n      \\n        passengerData newcust =  new passengerData(t,stationName);\\n        train.put(id,newcust);\\n        \\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        passengerData cust =  train.get(id);\\n        String startStation =  cust.st;\\n        int duration =  t - cust.t;\\n        \\n        record.putIfAbsent(startStation,new HashMap<>());        \\n        HashMap<String,avgObject > endstation = record.get(startStation);\\n        \\n        avgObject e = endstation.get(stationName);\\n        \\n        if(e!=null){                        \\n            e.updateAvg(duration);\\n        }\\n        else{\\n            avgObject entry =  new avgObject(1,duration);\\n            endstation.put(stationName,entry);            \\n        }\\n        train.remove(id);             \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        HashMap<String,avgObject > station =  record.get(startStation);\\n        avgObject entry =  station.get(endStation);       \\n        return (double)entry.total/entry.c;\\n       \\n    }    \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580687,
                "title": "python-3-easy-using-hashtable-beats-97",
                "content": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.journey = {}\\n        self.history = {} # (startStation, endStation) => (allTime, allCount)\\n\\n    def checkIn(self, id: int, startStation: str, t: int) -> None:\\n        self.journey[id] = (startStation, t)\\n        \\n\\n    def checkOut(self, id: int, endStation: str, endTime: int) -> None:\\n        startStation, startTime = self.journey.pop(id)\\n        key = (startStation, endStation)\\n        allTime, allCount = self.history.get(key, (0, 0))\\n        self.history[key] = (allTime + (endTime - startTime), allCount + 1)\\n        \\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        key = (startStation, endStation)\\n        allTime, allCount = self.history.get(key, (0, 0))\\n        return allTime / allCount\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.journey = {}\\n        self.history = {} # (startStation, endStation) => (allTime, allCount)\\n\\n    def checkIn(self, id: int, startStation: str, t: int) -> None:\\n        self.journey[id] = (startStation, t)\\n        \\n\\n    def checkOut(self, id: int, endStation: str, endTime: int) -> None:\\n        startStation, startTime = self.journey.pop(id)\\n        key = (startStation, endStation)\\n        allTime, allCount = self.history.get(key, (0, 0))\\n        self.history[key] = (allTime + (endTime - startTime), allCount + 1)\\n        \\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        key = (startStation, endStation)\\n        allTime, allCount = self.history.get(key, (0, 0))\\n        return allTime / allCount\\n",
                "codeTag": "Java"
            },
            {
                "id": 554957,
                "title": "javascript-o-1-for-all-methods",
                "content": "- Time Complexity: O(1)\\n- Space Complexity: O(N + M) `size of this.avg and this.train`\\n```JavaScript\\nvar UndergroundSystem = function() {\\n    this.avg = new Map();\\n    this.train = new Map();\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkIn = function(id, start, t) {\\n    this.train.set(id, [start, t]);\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkOut = function(id, end, t) {\\n    const [start, s] = this.train.get(id);\\n    const key = [start, end].join();\\n    if (this.avg.has(key)) {\\n        let [avg, cnt] = this.avg.get(key);\\n        this.avg.set(key, [avg * (cnt/++cnt) + ((t - s)/cnt), cnt]);\\n    } else {\\n        this.avg.set(key, [(t - s), 1]);\\n    }\\n    this.train.delete(id);\\n};\\n\\n/** \\n * @param {string} startStation \\n * @param {string} endStation\\n * @return {number}\\n */\\nUndergroundSystem.prototype.getAverageTime = function(start, end) {\\n    return this.avg.get([start, end].join())[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\nvar UndergroundSystem = function() {\\n    this.avg = new Map();\\n    this.train = new Map();\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkIn = function(id, start, t) {\\n    this.train.set(id, [start, t]);\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkOut = function(id, end, t) {\\n    const [start, s] = this.train.get(id);\\n    const key = [start, end].join();\\n    if (this.avg.has(key)) {\\n        let [avg, cnt] = this.avg.get(key);\\n        this.avg.set(key, [avg * (cnt/++cnt) + ((t - s)/cnt), cnt]);\\n    } else {\\n        this.avg.set(key, [(t - s), 1]);\\n    }\\n    this.train.delete(id);\\n};\\n\\n/** \\n * @param {string} startStation \\n * @param {string} endStation\\n * @return {number}\\n */\\nUndergroundSystem.prototype.getAverageTime = function(start, end) {\\n    return this.avg.get([start, end].join())[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1979304,
                "title": "dictionaries-and-named-tuples",
                "content": "```c#\\npublic class UndergroundSystem\\n{\\n    Dictionary<int, (string from, int startTime)> starts = new();\\n    Dictionary<(string, string), List<int>> times = new();\\n    \\n    public void CheckIn(int id, string from, int startTime)\\n    {\\n        starts[id] = (from, startTime);\\n    }\\n    \\n    public void CheckOut(int id, string to, int endTime)\\n    {\\n        var (from, startTime) = starts[id];\\n        var route = (from, to);\\n        if (!times.ContainsKey(route)) times[route] = new();\\n        times[route].Add(endTime - startTime);\\n    }\\n    \\n    public double GetAverageTime(string from, string to)\\n        => times[(from, to)].Average();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```c#\\npublic class UndergroundSystem\\n{\\n    Dictionary<int, (string from, int startTime)> starts = new();\\n    Dictionary<(string, string), List<int>> times = new();\\n    \\n    public void CheckIn(int id, string from, int startTime)\\n    {\\n        starts[id] = (from, startTime);\\n    }\\n    \\n    public void CheckOut(int id, string to, int endTime)\\n    {\\n        var (from, startTime) = starts[id];\\n        var route = (from, to);\\n        if (!times.ContainsKey(route)) times[route] = new();\\n        times[route].Add(endTime - startTime);\\n    }\\n    \\n    public double GetAverageTime(string from, string to)\\n        => times[(from, to)].Average();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836062,
                "title": "c-solutions",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    //startStation:endStation -> {totalTime, numberOfTrips}\\n    unordered_map<string, pair<long long, int>> stationTimes;\\n    //customerId -> startStation\\n    unordered_map<int, pair<string,int>> inTransit;\\n    UndergroundSystem() {\\n        stationTimes.clear();\\n        inTransit.clear();\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(inTransit.find(id) != inTransit.end()) return;\\n        inTransit[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& info = inTransit[id];\\n        string startStation = info.first;\\n        int startTime = info.second;\\n        string key = startStation + \":\" + stationName;\\n        int time = t - startTime;\\n        \\n        if(stationTimes.find(key) != stationTimes.end()) {\\n            auto& oldTimes = stationTimes[key];\\n            oldTimes.first += time;\\n            oldTimes.second++;\\n        } else {\\n            stationTimes[key] = {time, 1};\\n        }\\n        inTransit.erase(id);\\n        \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string key = startStation + \":\" + endStation;\\n        auto& info = stationTimes[key];\\n        double avg = (double)info.first / (double)info.second;\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    //startStation:endStation -> {totalTime, numberOfTrips}\\n    unordered_map<string, pair<long long, int>> stationTimes;\\n    //customerId -> startStation\\n    unordered_map<int, pair<string,int>> inTransit;\\n    UndergroundSystem() {\\n        stationTimes.clear();\\n        inTransit.clear();\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(inTransit.find(id) != inTransit.end()) return;\\n        inTransit[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& info = inTransit[id];\\n        string startStation = info.first;\\n        int startTime = info.second;\\n        string key = startStation + \":\" + stationName;\\n        int time = t - startTime;\\n        \\n        if(stationTimes.find(key) != stationTimes.end()) {\\n            auto& oldTimes = stationTimes[key];\\n            oldTimes.first += time;\\n            oldTimes.second++;\\n        } else {\\n            stationTimes[key] = {time, 1};\\n        }\\n        inTransit.erase(id);\\n        \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string key = startStation + \":\" + endStation;\\n        auto& info = stationTimes[key];\\n        double avg = (double)info.first / (double)info.second;\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793768,
                "title": "clear-solution-with-all-operation-in-o-1-javascript-typescript",
                "content": "Here\\'s a solution with two Maps. One for keeping track of customers id and other for averages by start/end station.\\n\\nIn JavaScript:\\n\\n```js\\nclass UndergroundSystem {\\n  customer = new Map();\\n  avg = new Map();\\n  \\n  checkIn(id, stationName, t) {\\n    this.customer.set(id, { stationName, t });\\n  }\\n  checkOut(id, stationName, t) {\\n    const checkIn = this.customer.get(id);\\n    if (!checkIn) throw new Error(`Customer ${id} didn\\'t checked in`);\\n    const key = `${checkIn.stationName}-${stationName}`;\\n    const { sum, count } = this.avg.get(key) ?? { sum: 0, count: 0 };\\n    this.avg.set(key, { sum: sum + (t - checkIn.t), count: count + 1 });\\n  }\\n  getAverageTime(startStation, endStation) {\\n    const { sum, count } = this.avg.get(`${startStation}-${endStation}`) ?? { sum: 0, count: 0 };\\n    return sum / count;\\n  }\\n}\\n\\n```\\n\\nIf you prefer types:\\n\\n```ts\\ninterface Trip {\\n  stationName: string;\\n  t: number;\\n}\\n\\ninterface AvgData {\\n  sum: number;\\n  count: number;\\n}\\n\\nclass UndergroundSystem {\\n  customer = new Map<number, Trip>();\\n  avg = new Map<string, AvgData>();\\n\\n  checkIn(id: number, stationName: string, t: number): void { // O(1)\\n    this.customer.set(id, {stationName, t});\\n  }\\n\\n  checkOut(id: number, stationName: string, t: number): void { // O(1)\\n    const checkIn = this.customer.get(id);\\n    if (!checkIn) throw new Error(`Customer ${id} didn\\'t checked in`);\\n    const key = `${checkIn.stationName}-${stationName}`;\\n    const {sum, count} = this.avg.get(key) ?? {sum: 0, count: 0};\\n    this.avg.set(key, {sum: sum + (t - checkIn.t), count: count + 1});\\n  }\\n\\n  getAverageTime(startStation: string, endStation: string): number { // O(1)\\n    const { sum, count } = this.avg.get(`${startStation}-${endStation}`) ?? {sum: 0, count: 0};\\n    return sum / count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```js\\nclass UndergroundSystem {\\n  customer = new Map();\\n  avg = new Map();\\n  \\n  checkIn(id, stationName, t) {\\n    this.customer.set(id, { stationName, t });\\n  }\\n  checkOut(id, stationName, t) {\\n    const checkIn = this.customer.get(id);\\n    if (!checkIn) throw new Error(`Customer ${id} didn\\'t checked in`);\\n    const key = `${checkIn.stationName}-${stationName}`;\\n    const { sum, count } = this.avg.get(key) ?? { sum: 0, count: 0 };\\n    this.avg.set(key, { sum: sum + (t - checkIn.t), count: count + 1 });\\n  }\\n  getAverageTime(startStation, endStation) {\\n    const { sum, count } = this.avg.get(`${startStation}-${endStation}`) ?? { sum: 0, count: 0 };\\n    return sum / count;\\n  }\\n}\\n\\n```\n```ts\\ninterface Trip {\\n  stationName: string;\\n  t: number;\\n}\\n\\ninterface AvgData {\\n  sum: number;\\n  count: number;\\n}\\n\\nclass UndergroundSystem {\\n  customer = new Map<number, Trip>();\\n  avg = new Map<string, AvgData>();\\n\\n  checkIn(id: number, stationName: string, t: number): void { // O(1)\\n    this.customer.set(id, {stationName, t});\\n  }\\n\\n  checkOut(id: number, stationName: string, t: number): void { // O(1)\\n    const checkIn = this.customer.get(id);\\n    if (!checkIn) throw new Error(`Customer ${id} didn\\'t checked in`);\\n    const key = `${checkIn.stationName}-${stationName}`;\\n    const {sum, count} = this.avg.get(key) ?? {sum: 0, count: 0};\\n    this.avg.set(key, {sum: sum + (t - checkIn.t), count: count + 1});\\n  }\\n\\n  getAverageTime(startStation: string, endStation: string): number { // O(1)\\n    const { sum, count } = this.avg.get(`${startStation}-${endStation}`) ?? {sum: 0, count: 0};\\n    return sum / count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554871,
                "title": "python3-easy-python-with-dict",
                "content": "```\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.times = defaultdict(lambda : defaultdict(lambda : [0, 0]))\\n        self.transit = {} \\n        \\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.transit[id] = [stationName, t]\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        srcName, srcTime = self.transit[id]\\n        count, totalTime = self.times[srcName][stationName] \\n        self.times[srcName][stationName] = [count+1, totalTime + t - srcTime] \\n        \\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        count, totalTime = self.times[startStation][endStation] \\n        return totalTime / count \\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.times = defaultdict(lambda : defaultdict(lambda : [0, 0]))\\n        self.transit = {} \\n        \\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.transit[id] = [stationName, t]\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        srcName, srcTime = self.transit[id]\\n        count, totalTime = self.times[srcName][stationName] \\n        self.times[srcName][stationName] = [count+1, totalTime + t - srcTime] \\n        \\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        count, totalTime = self.times[startStation][endStation] \\n        return totalTime / count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978059,
                "title": "map-based-tracking-system-better-performance-memory",
                "content": "Hi,\\n\\nFor understanding this problem, consider two person A and B travelling from X and Y, both are taking 10 and 12 minutes. Then we should give the average time to travel from X to Y is 11.\\n\\nSo here is the thought process for me.\\n\\nInitially I choose Map for better utilizing memory and better memory, I used 2 Maps       1. to store the checkIn data, (Id and their location)\\n      2. to store the timeTaken for reaching one destination from start \\n\\n\\nHere are the steps:\\na. In checkIn I save the id with their respective start place(01=\"X\")\\nb. Also, add the distance in the along with id in the second Map as it is the timetaken -> (\"01\"=10.00000)\\nc. In checkOut, we are getting the start place from first map and the time started form second map and store in second mao -> (\"X|Y\"=20-10) -> (\"X|Y\"=10.0000)\\nd. Itrate the list of items with same start and destination, find their average and return the average value. (10 & 12) ->(10+12)/2 => 11\\n\\n\\nPlease upvote if it helps, Happy learning.. :)\\n```\\n\\tHashMap<String, List<Double>> timeTaken;\\n\\tHashMap<Integer, String> checkInData;\\n    public UndergroundSystem() {\\n    \\ttimeTaken = new HashMap();\\n    \\tcheckInData = new HashMap<Integer, String>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkInData.put(id, stationName);\\n        List<Double> list = new ArrayList<Double>();\\n        list.add((double)t);\\n        timeTaken.put(id+\"\", list);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n\\t        String one = checkInData.get(id);\\n\\t        List<Double> start = timeTaken.get(id+\"\");\\n\\t        double count = t-start.get(0);\\n\\t        List<Double> list = new ArrayList<Double>();\\n\\t        list.add(count);\\n\\t        if(timeTaken.containsKey(one+\"|\"+stationName)){\\n\\t        \\tlist.addAll(timeTaken.get(one+\"|\"+stationName));\\n\\t        }\\n\\t        timeTaken.put(one+\"|\"+stationName, list);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        List<Double> list = timeTaken.get(startStation+\"|\"+endStation);\\n        double sum = 0;\\n        for(Double a: list)\\n        \\tsum = sum+a;\\n        return sum/list.size();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\nFor understanding this problem, consider two person A and B travelling from X and Y, both are taking 10 and 12 minutes. Then we should give the average time to travel from X to Y is 11.\\n\\nSo here is the thought process for me.\\n\\nInitially I choose Map for better utilizing memory and better memory, I used 2 Maps       1. to store the checkIn data, (Id and their location)\\n      2. to store the timeTaken for reaching one destination from start \\n\\n\\nHere are the steps:\\na. In checkIn I save the id with their respective start place(01=\"X\")\\nb. Also, add the distance in the along with id in the second Map as it is the timetaken -> (\"01\"=10.00000)\\nc. In checkOut, we are getting the start place from first map and the time started form second map and store in second mao -> (\"X|Y\"=20-10) -> (\"X|Y\"=10.0000)\\nd. Itrate the list of items with same start and destination, find their average and return the average value. (10 & 12) ->(10+12)/2 => 11\\n\\n\\nPlease upvote if it helps, Happy learning.. :)\\n```\\n\\tHashMap<String, List<Double>> timeTaken;\\n\\tHashMap<Integer, String> checkInData;\\n    public UndergroundSystem() {\\n    \\ttimeTaken = new HashMap();\\n    \\tcheckInData = new HashMap<Integer, String>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkInData.put(id, stationName);\\n        List<Double> list = new ArrayList<Double>();\\n        list.add((double)t);\\n        timeTaken.put(id+\"\", list);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n\\t        String one = checkInData.get(id);\\n\\t        List<Double> start = timeTaken.get(id+\"\");\\n\\t        double count = t-start.get(0);\\n\\t        List<Double> list = new ArrayList<Double>();\\n\\t        list.add(count);\\n\\t        if(timeTaken.containsKey(one+\"|\"+stationName)){\\n\\t        \\tlist.addAll(timeTaken.get(one+\"|\"+stationName));\\n\\t        }\\n\\t        timeTaken.put(one+\"|\"+stationName, list);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        List<Double> list = timeTaken.get(startStation+\"|\"+endStation);\\n        double sum = 0;\\n        for(Double a: list)\\n        \\tsum = sum+a;\\n        return sum/list.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1976943,
                "title": "java-solution-oops-easy-understanding-clean-code-hashmap",
                "content": "```\\nclass Info{\\n    int id;\\n    String stationName;\\n    int t;\\n    public Info(int id, String stationName, int t){\\n        this.id = id;\\n        this.stationName = stationName;\\n        this.t = t;\\n    }\\n}\\nclass Average{\\n    int sum;\\n    int n;\\n    public Average(){\\n        this.sum=0;\\n        this.n=0;\\n    }\\n    public Average(int sum, int n){\\n        this.sum = sum;\\n        this.n = n;\\n    }\\n}\\nclass UndergroundSystem {\\n    \\n    HashMap<String, Average> averageTimes;\\n    HashMap<Integer, Info> checks;\\n    public UndergroundSystem() {\\n        averageTimes = new HashMap<>();\\n        checks = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checks.put(id, new Info(id, stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Info info = checks.get(id);\\n        String stations = info.stationName+\"-\"+stationName;\\n        Average avg = averageTimes.getOrDefault(stations, new Average());\\n        avg.sum+=(t-info.t);\\n        avg.n+=1;\\n        averageTimes.put(stations,avg);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String stations = startStation+\"-\"+endStation;\\n        Average avg = averageTimes.get(stations);\\n        return (double)avg.sum/(double)avg.n;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Info{\\n    int id;\\n    String stationName;\\n    int t;\\n    public Info(int id, String stationName, int t){\\n        this.id = id;\\n        this.stationName = stationName;\\n        this.t = t;\\n    }\\n}\\nclass Average{\\n    int sum;\\n    int n;\\n    public Average(){\\n        this.sum=0;\\n        this.n=0;\\n    }\\n    public Average(int sum, int n){\\n        this.sum = sum;\\n        this.n = n;\\n    }\\n}\\nclass UndergroundSystem {\\n    \\n    HashMap<String, Average> averageTimes;\\n    HashMap<Integer, Info> checks;\\n    public UndergroundSystem() {\\n        averageTimes = new HashMap<>();\\n        checks = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checks.put(id, new Info(id, stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Info info = checks.get(id);\\n        String stations = info.stationName+\"-\"+stationName;\\n        Average avg = averageTimes.getOrDefault(stations, new Average());\\n        avg.sum+=(t-info.t);\\n        avg.n+=1;\\n        averageTimes.put(stations,avg);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String stations = startStation+\"-\"+endStation;\\n        Average avg = averageTimes.get(stations);\\n        return (double)avg.sum/(double)avg.n;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568192,
                "title": "javascript-easiest-to-understand-beats-99-es6-class-syntax-solution",
                "content": "```\\nclass UndergroundSystem {\\n    constructor() {\\n        this.idMap = new Map();\\n        this.durationMap = new Map();\\n    }\\n    checkIn(id, stationName, t) {\\n        this.idMap.set(id, {stationName, checkInTime: t});\\n    }\\n    checkOut(id, stationName, t) {\\n        const startStation = this.idMap.get(id);\\n        const stationRoute = `${startStation.stationName}, ${stationName}`;\\n        const duration = t - startStation.checkInTime;\\n        if(this.durationMap.has(stationRoute)) {\\n            this.durationMap.get(stationRoute).push(duration);\\n        } else {\\n            this.durationMap.set(stationRoute,[duration]);\\n        }\\n    }\\n    getAverageTime(startStation, endStation) {\\n        const durationList = this.durationMap.get(`${startStation}, ${endStation}`);\\n        return durationList.reduce((a, b) => a + b) / durationList.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    constructor() {\\n        this.idMap = new Map();\\n        this.durationMap = new Map();\\n    }\\n    checkIn(id, stationName, t) {\\n        this.idMap.set(id, {stationName, checkInTime: t});\\n    }\\n    checkOut(id, stationName, t) {\\n        const startStation = this.idMap.get(id);\\n        const stationRoute = `${startStation.stationName}, ${stationName}`;\\n        const duration = t - startStation.checkInTime;\\n        if(this.durationMap.has(stationRoute)) {\\n            this.durationMap.get(stationRoute).push(duration);\\n        } else {\\n            this.durationMap.set(stationRoute,[duration]);\\n        }\\n    }\\n    getAverageTime(startStation, endStation) {\\n        const durationList = this.durationMap.get(`${startStation}, ${endStation}`);\\n        return durationList.reduce((a, b) => a + b) / durationList.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554810,
                "title": "i-was-getting-wrong-answer-for-precision",
                "content": "My answer was 109.00000 and correct was 109.0 . I got WA for this issue..\\n\\n```\\n\\nmap<int,vector< pair<string,int> > > ID;\\nmap<pair<string,string>,pair<double,int> > ans;\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {\\n        ID.clear();\\n        ans.clear();\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        ID[id].push_back({stationName,t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        ID[id].push_back({stationName,t});\\n        auto it = ID.find(id);\\n        vector< pair<string,int> > v = it->second;\\n        string start = v[0].first;\\n        string end = v[1].first;\\n        double avg = (double)(v[1].second - v[0].second);\\n        \\n        int count=0;\\n        double cur=0.0;\\n        if( ans.find({start,end})!=ans.end() )\\n        {\\n            pair<double,int> x = ans[{start,end}];\\n            count = x.second;\\n            cur = x.first;\\n        }\\n        ans[{start,end}] = { (avg+cur),count+1};\\n        // for(auto it=ans.begin();it!=ans.end();it++)\\n        // {\\n        //     pair<string,string> s = it->first;\\n        //     cout << s.first << \":\" << s.second << \"->  \";\\n        //     pair<double,int> p = it->second;\\n        //     cout << p.first << \",\" << p.second << endl;\\n        // }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        pair<double,int> x = ans[{startStation,endStation}];\\n        return x.first/x.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n\\nmap<int,vector< pair<string,int> > > ID;\\nmap<pair<string,string>,pair<double,int> > ans;\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {\\n        ID.clear();\\n        ans.clear();\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        ID[id].push_back({stationName,t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        ID[id].push_back({stationName,t});\\n        auto it = ID.find(id);\\n        vector< pair<string,int> > v = it->second;\\n        string start = v[0].first;\\n        string end = v[1].first;\\n        double avg = (double)(v[1].second - v[0].second);\\n        \\n        int count=0;\\n        double cur=0.0;\\n        if( ans.find({start,end})!=ans.end() )\\n        {\\n            pair<double,int> x = ans[{start,end}];\\n            count = x.second;\\n            cur = x.first;\\n        }\\n        ans[{start,end}] = { (avg+cur),count+1};\\n        // for(auto it=ans.begin();it!=ans.end();it++)\\n        // {\\n        //     pair<string,string> s = it->first;\\n        //     cout << s.first << \":\" << s.second << \"->  \";\\n        //     pair<double,int> p = it->second;\\n        //     cout << p.first << \",\" << p.second << endl;\\n        // }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        pair<double,int> x = ans[{startStation,endStation}];\\n        return x.first/x.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1977632,
                "title": "lld-using-hashmap",
                "content": "```\\nclass CheckInStationTime {\\n\\n  public String name;\\n  public int t;\\n\\n  public CheckInStationTime(String name, int t) {\\n    this.name = name;\\n    this.t = t;\\n  }\\n}\\n\\nclass StationStats {\\n\\n  public long totalTime;\\n  public int count;\\n\\n  public StationStats(long totalTime, int count) {\\n    this.totalTime = totalTime;\\n    this.count = count;\\n  }\\n}\\n\\nclass UndergroundSystem {\\n\\n  private final Map<Integer, CheckInStationTime> checkInMap;\\n  private final Map<String, Map<String, StationStats>> connect;\\n\\n  public UndergroundSystem() {\\n    checkInMap = new HashMap<>();\\n    connect = new HashMap<>();\\n  }\\n\\n  public void checkIn(int id, String stationName, int t) {\\n    checkInMap.put(id, new CheckInStationTime(stationName, t));\\n  }\\n\\n  public void checkOut(int id, String stationName, int t) {\\n    String from = checkInMap.get(id).name;\\n    connect.computeIfAbsent(from, k -> new HashMap<>());\\n    StationStats stationStats = connect.get(from).get(stationName);\\n    if (stationStats == null) {\\n      stationStats = new StationStats((t - checkInMap.get(id).t), 1);\\n    } else {\\n      stationStats.totalTime += (t - checkInMap.get(id).t);\\n      ++stationStats.count;\\n    }\\n    connect.get(from).put(stationName, stationStats);\\n  }\\n\\n  public double getAverageTime(String startStation, String endStation) {\\n    StationStats stationStats = connect.get(startStation).get(endStation);\\n    return stationStats.totalTime / (double) stationStats.count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CheckInStationTime {\\n\\n  public String name;\\n  public int t;\\n\\n  public CheckInStationTime(String name, int t) {\\n    this.name = name;\\n    this.t = t;\\n  }\\n}\\n\\nclass StationStats {\\n\\n  public long totalTime;\\n  public int count;\\n\\n  public StationStats(long totalTime, int count) {\\n    this.totalTime = totalTime;\\n    this.count = count;\\n  }\\n}\\n\\nclass UndergroundSystem {\\n\\n  private final Map<Integer, CheckInStationTime> checkInMap;\\n  private final Map<String, Map<String, StationStats>> connect;\\n\\n  public UndergroundSystem() {\\n    checkInMap = new HashMap<>();\\n    connect = new HashMap<>();\\n  }\\n\\n  public void checkIn(int id, String stationName, int t) {\\n    checkInMap.put(id, new CheckInStationTime(stationName, t));\\n  }\\n\\n  public void checkOut(int id, String stationName, int t) {\\n    String from = checkInMap.get(id).name;\\n    connect.computeIfAbsent(from, k -> new HashMap<>());\\n    StationStats stationStats = connect.get(from).get(stationName);\\n    if (stationStats == null) {\\n      stationStats = new StationStats((t - checkInMap.get(id).t), 1);\\n    } else {\\n      stationStats.totalTime += (t - checkInMap.get(id).t);\\n      ++stationStats.count;\\n    }\\n    connect.get(from).put(stationName, stationStats);\\n  }\\n\\n  public double getAverageTime(String startStation, String endStation) {\\n    StationStats stationStats = connect.get(startStation).get(endStation);\\n    return stationStats.totalTime / (double) stationStats.count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118467,
                "title": "java-clean-code-self-explanatory",
                "content": "One consideration I need to make was whether integer overflow could occur. WIth 20000 operations and times maximum value of 10^6, an integer is sufficient to accumulate all journey times otherwise I might have utilised a long.\\n\\n```\\nclass UndergroundSystem {\\n    private final Map<Integer, StationAndTime> start;\\n    private final Map<String, JourneyTimeDetails> journeyToTiming;\\n\\n    public UndergroundSystem() {\\n        start = new HashMap<>();\\n        journeyToTiming = new HashMap<>();\\n    }\\n\\n    public void checkIn(int id, String stationName, int time) {\\n        start.put(id, new StationAndTime(stationName, time));\\n    }\\n\\n    public void checkOut(int id, String stationName, int time) {\\n        StationAndTime stationAndTime = start.get(id);\\n        String journeyName = stationAndTime.getStationName() + \\'>\\' + stationName;\\n        int prevTime = stationAndTime.getTime();\\n\\n        JourneyTimeDetails timeWithCount = journeyToTiming.getOrDefault(journeyName, new JourneyTimeDetails());\\n        timeWithCount.setElapseTime(timeWithCount.getElapseTime() + time - prevTime);\\n        timeWithCount.setJourneyCounts(timeWithCount.getJourneyCounts() + 1);\\n        journeyToTiming.put(journeyName, timeWithCount);\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        String journeyName = startStation + \\'>\\' + endStation;\\n        JourneyTimeDetails journeyTimeDetails = journeyToTiming.get(journeyName);\\n\\n        return (double) journeyTimeDetails.getElapseTime() / journeyTimeDetails.getJourneyCounts();\\n    }\\n\\n    static class StationAndTime {\\n        private final String stationName;\\n        private final int time;\\n\\n        public StationAndTime(String stationName, int time) {\\n            this.stationName = stationName;\\n            this.time = time;\\n        }\\n\\n        public String getStationName() {\\n            return stationName;\\n        }\\n\\n        public int getTime() {\\n            return time;\\n        }\\n    }\\n\\n    static class JourneyTimeDetails {\\n        private int elapseTime;\\n        private int journeyCounts;\\n\\n        public int getElapseTime() {\\n            return elapseTime;\\n        }\\n\\n        public void setElapseTime(int elapseTime) {\\n            this.elapseTime = elapseTime;\\n        }\\n\\n        public int getJourneyCounts() {\\n            return journeyCounts;\\n        }\\n\\n        public void setJourneyCounts(int journeyCounts) {\\n            this.journeyCounts = journeyCounts;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n    private final Map<Integer, StationAndTime> start;\\n    private final Map<String, JourneyTimeDetails> journeyToTiming;\\n\\n    public UndergroundSystem() {\\n        start = new HashMap<>();\\n        journeyToTiming = new HashMap<>();\\n    }\\n\\n    public void checkIn(int id, String stationName, int time) {\\n        start.put(id, new StationAndTime(stationName, time));\\n    }\\n\\n    public void checkOut(int id, String stationName, int time) {\\n        StationAndTime stationAndTime = start.get(id);\\n        String journeyName = stationAndTime.getStationName() + \\'>\\' + stationName;\\n        int prevTime = stationAndTime.getTime();\\n\\n        JourneyTimeDetails timeWithCount = journeyToTiming.getOrDefault(journeyName, new JourneyTimeDetails());\\n        timeWithCount.setElapseTime(timeWithCount.getElapseTime() + time - prevTime);\\n        timeWithCount.setJourneyCounts(timeWithCount.getJourneyCounts() + 1);\\n        journeyToTiming.put(journeyName, timeWithCount);\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        String journeyName = startStation + \\'>\\' + endStation;\\n        JourneyTimeDetails journeyTimeDetails = journeyToTiming.get(journeyName);\\n\\n        return (double) journeyTimeDetails.getElapseTime() / journeyTimeDetails.getJourneyCounts();\\n    }\\n\\n    static class StationAndTime {\\n        private final String stationName;\\n        private final int time;\\n\\n        public StationAndTime(String stationName, int time) {\\n            this.stationName = stationName;\\n            this.time = time;\\n        }\\n\\n        public String getStationName() {\\n            return stationName;\\n        }\\n\\n        public int getTime() {\\n            return time;\\n        }\\n    }\\n\\n    static class JourneyTimeDetails {\\n        private int elapseTime;\\n        private int journeyCounts;\\n\\n        public int getElapseTime() {\\n            return elapseTime;\\n        }\\n\\n        public void setElapseTime(int elapseTime) {\\n            this.elapseTime = elapseTime;\\n        }\\n\\n        public int getJourneyCounts() {\\n            return journeyCounts;\\n        }\\n\\n        public void setJourneyCounts(int journeyCounts) {\\n            this.journeyCounts = journeyCounts;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118298,
                "title": "java-o-n-2-maps-faster-than-99-5-easy-to-understand-step-by-step-expalined",
                "content": "hascode of a character will not be negative if below formula is implemenetd . and if every string has a unique +ve \\nhash value the formula min(code1,code2)*10 + max(code1,code2) will generate a unique hash for the pair (start , end)\\n\\ncredit goes to @yalandhong for piting out my mistakes!\\n\\nO(1) time in avg for .hashCode() calls beause it caches its previuos hash values values in memory !\\n```\\n// belowe would be my layman implementation of hashCode()  .. :P \\npublic static int hcode(String s){\\n        int code = 0 , n = s.length() , pos = 1;\\n        for(int i = 0 ; i < n ; i++)\\n            code = code + (int)(s.charAt(i))*(int)Math.pow(31 , n - pos++);\\n            \\n        return code ;\\n    }\\n```\\n```\\n// hashcode formula -> s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]*31^(0)  \\nclass UndergroundSystem {\\n    \\n    // key -> value pair explained in side \\n    \\n    Map<Integer,checkinInfo> checkin ; // id -> checkinInfo(time , station name) map \\n    Map<Integer,checkoutInfo> timemap ; // (start st, end st) -> all checkout time sums and their cnt \\n    \\n    public UndergroundSystem() {\\n        checkin = new HashMap<>();\\n        timemap = new HashMap<>();\\n    }\\n    \\n    // populate the checkininfo map , O(1) for checkin() call \\n    public void checkIn(int id, String stationName, int t) {\\n        checkinInfo obj = new checkinInfo(stationName , t);\\n        checkin.put(id , obj);\\n    }\\n    \\n    // for a checkout get the chek in info of the user and calcualate the time and in timemap \\n    // map it like (start st,end st) -> (previous times + curr time , prev cnt + 1) , O(1) for this call\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        checkinInfo cin = checkin.get(id);\\n        int code1 = cin.station.hashCode() , code2 = stationName.hashCode();\\n        int hcode = Math.max(code1,code2)*10 + Math.min(code1 , code2);\\n        double curr_time = t - cin.time ;\\n        checkoutInfo temp = timemap.getOrDefault(hcode, null) ;\\n        \\n        if(temp == null)\\n            timemap.put(hcode , new checkoutInfo(curr_time , 1));\\n        else{\\n            temp.cnt += 1;\\n            temp.time += curr_time ;\\n        }\\n    }\\n    \\n    // just get the code for the checkout pait(start st ,end st) and look in map and \\n    // return avgtime accotdinlgy , O(1) for getavgtime() call\\n    public double getAverageTime(String startStation, String endStation) {\\n        int code1 = startStation.hashCode() , code2 = endStation.hashCode();\\n        int code = Math.max(code1,code2)*10 + Math.min(code1 , code2);\\n        checkoutInfo temp = timemap.getOrDefault(code , null);\\n        \\n        return temp == null ? -1 : temp.time / temp.cnt ; \\n    }\\n    \\n    // class to hold all the check outs at a particular station starting from a particulart statioon \\n    // along with the all the prefix sum of checkouts and counts of checkouts \\n    \\n    // used to map like : (start st , end st) -> checkoutinfos \\n    private class checkoutInfo{\\n        double time ;\\n        double cnt ;\\n        checkoutInfo(double time , double cnt){\\n            this.cnt = cnt ;\\n            this.time = time ;\\n        }\\n    }\\n    \\n    // class to hold info abt check in station and check in time \\n    // used to map like : id -> checkinInfo \\n    private class checkinInfo{\\n        String station ;\\n        int time ;\\n        checkinInfo(String station, int time){\\n            this.station = station ;\\n            this.time = time ;\\n        }\\n    }\\n}\\n\\n```\\n\\npls upvote if it helps , means a lot to me tysm ;)",
                "solutionTags": [],
                "code": "```\\n// belowe would be my layman implementation of hashCode()  .. :P \\npublic static int hcode(String s){\\n        int code = 0 , n = s.length() , pos = 1;\\n        for(int i = 0 ; i < n ; i++)\\n            code = code + (int)(s.charAt(i))*(int)Math.pow(31 , n - pos++);\\n            \\n        return code ;\\n    }\\n```\n```\\n// hashcode formula -> s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]*31^(0)  \\nclass UndergroundSystem {\\n    \\n    // key -> value pair explained in side \\n    \\n    Map<Integer,checkinInfo> checkin ; // id -> checkinInfo(time , station name) map \\n    Map<Integer,checkoutInfo> timemap ; // (start st, end st) -> all checkout time sums and their cnt \\n    \\n    public UndergroundSystem() {\\n        checkin = new HashMap<>();\\n        timemap = new HashMap<>();\\n    }\\n    \\n    // populate the checkininfo map , O(1) for checkin() call \\n    public void checkIn(int id, String stationName, int t) {\\n        checkinInfo obj = new checkinInfo(stationName , t);\\n        checkin.put(id , obj);\\n    }\\n    \\n    // for a checkout get the chek in info of the user and calcualate the time and in timemap \\n    // map it like (start st,end st) -> (previous times + curr time , prev cnt + 1) , O(1) for this call\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        checkinInfo cin = checkin.get(id);\\n        int code1 = cin.station.hashCode() , code2 = stationName.hashCode();\\n        int hcode = Math.max(code1,code2)*10 + Math.min(code1 , code2);\\n        double curr_time = t - cin.time ;\\n        checkoutInfo temp = timemap.getOrDefault(hcode, null) ;\\n        \\n        if(temp == null)\\n            timemap.put(hcode , new checkoutInfo(curr_time , 1));\\n        else{\\n            temp.cnt += 1;\\n            temp.time += curr_time ;\\n        }\\n    }\\n    \\n    // just get the code for the checkout pait(start st ,end st) and look in map and \\n    // return avgtime accotdinlgy , O(1) for getavgtime() call\\n    public double getAverageTime(String startStation, String endStation) {\\n        int code1 = startStation.hashCode() , code2 = endStation.hashCode();\\n        int code = Math.max(code1,code2)*10 + Math.min(code1 , code2);\\n        checkoutInfo temp = timemap.getOrDefault(code , null);\\n        \\n        return temp == null ? -1 : temp.time / temp.cnt ; \\n    }\\n    \\n    // class to hold all the check outs at a particular station starting from a particulart statioon \\n    // along with the all the prefix sum of checkouts and counts of checkouts \\n    \\n    // used to map like : (start st , end st) -> checkoutinfos \\n    private class checkoutInfo{\\n        double time ;\\n        double cnt ;\\n        checkoutInfo(double time , double cnt){\\n            this.cnt = cnt ;\\n            this.time = time ;\\n        }\\n    }\\n    \\n    // class to hold info abt check in station and check in time \\n    // used to map like : id -> checkinInfo \\n    private class checkinInfo{\\n        String station ;\\n        int time ;\\n        checkinInfo(String station, int time){\\n            this.station = station ;\\n            this.time = time ;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118297,
                "title": "design-underground-system-js-python-java-c-easy-2-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe first thing we should realize is that since checkins and checkouts are separated, we\\'ll need some type of data structure in which to store checkin information until we find the matching checkout information.\\n\\nThe next important realization is that since we only ultimately care about route times, we don\\'t really need to store checkout info at all. As long as we store the checkin info until we get to the checkout info, we can actually just then store the trip info separately by route and get rid of the checkin and checkout information. This will help keep the space needed to a minimum.\\n\\nAs we\\'ll want to look up checkin and route info by id and route name, we should use map structures for both. For the route information, we\\'ll only need to keep track of the number of trips and the total duration, so that we can calculate the average as needed. We can also use a concatenated name for the key in the route map in order to store the trip as a whole, rather than having to keep track of both ends separately.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor better efficiency, Javascript can use a **Uint32Array** for **route**, Python can use a **tuple** for **checkins**, Java and C++ can use **pairs** for **checkins**, and Java can use **pairs** instead of concatenating the station names.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **220ms / 52.7MB** (beats 100% / 94%).\\n```javascript\\nclass UndergroundSystem {\\n    constructor() {\\n        this.checkins = new Map()\\n        this.routes = new Map()\\n    }\\n    checkIn(id, stationName, t) {\\n        this.checkins.set(id, [stationName, t])\\n    };\\n    checkOut(id, stationName, t) {\\n        let [stn, start] = this.checkins.get(id),\\n            route = stn + \",\" + stationName\\n        this.checkins.delete(id)\\n        if (!this.routes.has(route))\\n            this.routes.set(route, new Uint32Array(2))\\n        let trip = this.routes.get(route)\\n        trip[0]++, trip[1] += t - start\\n    };\\n    getAverageTime(startStation, endStation) {\\n        let [count, sum] = this.routes.get(startStation + \",\" + endStation)\\n        return sum / count\\n    };\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **224ms / 22.9MB** (beats 98% / 100%).\\n```python\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.checkins = defaultdict()\\n        self.routes = defaultdict()\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkins[id] = (stationName, t)\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        stn, start = self.checkins[id]\\n        del self.checkins[id]\\n        route = stn + \",\" + stationName\\n        if route not in self.routes: self.routes[route] = [0,0]\\n        trip = self.routes[route]\\n        trip[0] += 1\\n        trip[1] += t - start\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        count, rsum = self.routes[startStation + \",\" + endStation]\\n        return rsum / count\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **78ms / 51.9MB** (beats 100% / 78%).\\n```java\\nclass UndergroundSystem {\\n    Map<Integer, Pair<String, Integer>> checkins = new HashMap<>();\\n    Map<Pair<String, String>, int[]> routes = new HashMap<>();\\n    public void checkIn(int id, String stationName, int t) {\\n        checkins.put(id, new Pair(stationName, t));\\n    }\\n    public void checkOut(int id, String stationName, int t) {\\n        Pair<String, Integer> cIn = checkins.get(id);\\n        checkins.remove(id);\\n        Pair<String, String> route = new Pair(cIn.getKey(), stationName);\\n        int[] trip = routes.getOrDefault(route, new int[2]);\\n        trip[0]++;\\n        trip[1] += t - cIn.getValue();\\n        routes.put(route, trip);\\n    }\\n    public double getAverageTime(String startStation, String endStation) {\\n        int[] trip = routes.get(new Pair(startStation, endStation));\\n        return (double)trip[1] / trip[0];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **128ms / 58.5MB** (beats 96% / 67%).\\n```c++\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int, pair<string, int>> checkins;\\n    unordered_map<string, pair<int, int>> routes;\\n    void checkIn(int id, string stationName, int t) {\\n        checkins[id] = {stationName, t};\\n    }\\n    void checkOut(int id, string stationName, int t) {\\n        auto [stn, start] = checkins[id];\\n        checkins.erase(id);\\n        string route = stn + \",\" + stationName;\\n        routes[route].first++, routes[route].second += t - start;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        auto& [count, sum] = routes[startStation + \",\" + endStation];\\n        return (double)sum / count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nclass UndergroundSystem {\\n    constructor() {\\n        this.checkins = new Map()\\n        this.routes = new Map()\\n    }\\n    checkIn(id, stationName, t) {\\n        this.checkins.set(id, [stationName, t])\\n    };\\n    checkOut(id, stationName, t) {\\n        let [stn, start] = this.checkins.get(id),\\n            route = stn + \",\" + stationName\\n        this.checkins.delete(id)\\n        if (!this.routes.has(route))\\n            this.routes.set(route, new Uint32Array(2))\\n        let trip = this.routes.get(route)\\n        trip[0]++, trip[1] += t - start\\n    };\\n    getAverageTime(startStation, endStation) {\\n        let [count, sum] = this.routes.get(startStation + \",\" + endStation)\\n        return sum / count\\n    };\\n};\\n```\n```python\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.checkins = defaultdict()\\n        self.routes = defaultdict()\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkins[id] = (stationName, t)\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        stn, start = self.checkins[id]\\n        del self.checkins[id]\\n        route = stn + \",\" + stationName\\n        if route not in self.routes: self.routes[route] = [0,0]\\n        trip = self.routes[route]\\n        trip[0] += 1\\n        trip[1] += t - start\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        count, rsum = self.routes[startStation + \",\" + endStation]\\n        return rsum / count\\n```\n```java\\nclass UndergroundSystem {\\n    Map<Integer, Pair<String, Integer>> checkins = new HashMap<>();\\n    Map<Pair<String, String>, int[]> routes = new HashMap<>();\\n    public void checkIn(int id, String stationName, int t) {\\n        checkins.put(id, new Pair(stationName, t));\\n    }\\n    public void checkOut(int id, String stationName, int t) {\\n        Pair<String, Integer> cIn = checkins.get(id);\\n        checkins.remove(id);\\n        Pair<String, String> route = new Pair(cIn.getKey(), stationName);\\n        int[] trip = routes.getOrDefault(route, new int[2]);\\n        trip[0]++;\\n        trip[1] += t - cIn.getValue();\\n        routes.put(route, trip);\\n    }\\n    public double getAverageTime(String startStation, String endStation) {\\n        int[] trip = routes.get(new Pair(startStation, endStation));\\n        return (double)trip[1] / trip[0];\\n    }\\n}\\n```\n```c++\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int, pair<string, int>> checkins;\\n    unordered_map<string, pair<int, int>> routes;\\n    void checkIn(int id, string stationName, int t) {\\n        checkins[id] = {stationName, t};\\n    }\\n    void checkOut(int id, string stationName, int t) {\\n        auto [stn, start] = checkins[id];\\n        checkins.erase(id);\\n        string route = stn + \",\" + stationName;\\n        routes[route].first++, routes[route].second += t - start;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        auto& [count, sum] = routes[startStation + \",\" + endStation];\\n        return (double)sum / count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118276,
                "title": "c-solution",
                "content": "class UndergroundSystem {\\npublic:\\n    unordered_map<string,pair<double,int>> avg;\\n    unordered_map<int,pair<string,int>> info;\\n    \\n    void checkIn(int id, string stn, int t) {\\n        info[id]={stn,t};\\n    }\\n    void checkOut(int id, string stn, int t) {\\n        string name=info[id].first+\" \"+stn;\\n        double interval=t-info[id].second;\\n        avg[name].first+=interval;\\n        avg[name].second++;\\n    }\\n    double getAverageTime(string from, string to) {\\n        string name=from+\" \"+to;\\n        return avg[name].first/avg[name].second;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class UndergroundSystem {\\npublic:\\n    unordered_map<string,pair<double,int>> avg;\\n    unordered_map<int,pair<string,int>> info;\\n    \\n    void checkIn(int id, string stn, int t) {\\n        info[id]={stn,t};\\n    }\\n    void checkOut(int id, string stn, int t) {\\n        string name=info[id].first+\" \"+stn;\\n        double interval=t-info[id].second;\\n        avg[name].first+=interval;\\n        avg[name].second++;\\n    }\\n    double getAverageTime(string from, string to) {\\n        string name=from+\" \"+to;\\n        return avg[name].first/avg[name].second;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3581262,
                "title": "easy-beginner-friendly-explanation-space-optimised-c-python3",
                "content": "# ADVICE\\nREAD APPROACH AND TRY DOING YOURSELF .THEN SEE CODE AND UPVOTE \\uD83D\\uDE42.\\n# Approach\\nWHAT WE WANT?\\nAverage Travelling time b/w two stations .\\nOne person{id} is contributing some Travelling time for a particular \\n{start station , end station}.\\nWe will store its contribution in map .\\n```\\n   //id  StaringStationName , Checkin Time\\nmap<int, pair<string        , int         >>chkin;\\n\\nmap<pair<string,string>,pair<int,int>>avg;\\n```\\navg Map will contain \\nmap<{StartStation,EndStation},{\\u2211TravellingTime,NumberOfTimes{Start-End}Station Travel has occured}>avg;\\n // Here Travelling Time = Checkout Time -Checkin Time \\n\\nHOW WE CAN GET AVERAGE TRAVELLING TIME B/W TWO STATIONS ?\\nAns. SUM OF ALL TRAVELS FROM STARTING STATION TO FINAL STATIONS DIVIDED BY TOTAL NUMBER OF {Si , Ei} TRAVELS.\\n\\nSince we know the ID and starting station and checkin time of persons with id I{From **map chkin**} .So at the time of checkout we will add Travelling time in our **map avg** .and Also increment the freq of {Si,Ei} Travel.\\n\\nSince Given in question checkOut Happens only after checkin we don\\'t have to worry for other cases.\\n\\nFinally.\\n\\n```\\ndouble getAverageTime(string s, string e) {\\n        return avg[{s,e}].first/(double)avg[{s,e}].second;\\n}\\n```\\n\\n# Code\\n\\n```C++ []\\nclass UndergroundSystem {\\n    private :\\n    //id  station name , time t1\\n    map<int,pair<string,int>>chkin;\\n    //initial station1  final station2  sum_till_now count\\n    map<pair<string,string>,pair<int,int>>avg;\\npublic:\\n    UndergroundSystem(){}\\n    void checkIn(int id, string s, int t) {\\n        pair<string,int>p={s,t};\\n        chkin[id]=p;\\n    }\\n    void checkOut(int id, string s, int t) {\\n        int timetravel=t-chkin[id].second;\\n        avg[{chkin[id].first,s}].first+=timetravel;\\n        avg[{chkin[id].first,s}].second++;\\n    }\\n    double getAverageTime(string s, string e){\\n        return avg[{s,e}].first/(double)avg[{s,e}].second;\\n    }\\n};\\n\\n```\\n```python []\\n\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.checkIns = {}\\n        self.averageTimes = defaultdict(lambda: [0, 0])\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkIns[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        startStation, startTime = self.checkIns[id]\\n        route = (startStation, stationName)\\n        timeTravel = t - startTime\\n        self.averageTimes[route][0] += timeTravel\\n        self.averageTimes[route][1] += 1\\n\\n def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        totalTime, totalTrips = self.averageTimes[(startStation, endStation)]\\n        return totalTime / totalTrips if totalTrips > 0 else 0.0\\n\\n\\n```\\n\\nTHANK YOU \\nCODE BY:) AMAN MAURYA",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\n   //id  StaringStationName , Checkin Time\\nmap<int, pair<string        , int         >>chkin;\\n\\nmap<pair<string,string>,pair<int,int>>avg;\\n```\n```\\ndouble getAverageTime(string s, string e) {\\n        return avg[{s,e}].first/(double)avg[{s,e}].second;\\n}\\n```\n```C++ []\\nclass UndergroundSystem {\\n    private :\\n    //id  station name , time t1\\n    map<int,pair<string,int>>chkin;\\n    //initial station1  final station2  sum_till_now count\\n    map<pair<string,string>,pair<int,int>>avg;\\npublic:\\n    UndergroundSystem(){}\\n    void checkIn(int id, string s, int t) {\\n        pair<string,int>p={s,t};\\n        chkin[id]=p;\\n    }\\n    void checkOut(int id, string s, int t) {\\n        int timetravel=t-chkin[id].second;\\n        avg[{chkin[id].first,s}].first+=timetravel;\\n        avg[{chkin[id].first,s}].second++;\\n    }\\n    double getAverageTime(string s, string e){\\n        return avg[{s,e}].first/(double)avg[{s,e}].second;\\n    }\\n};\\n\\n```\n```python []\\n\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.checkIns = {}\\n        self.averageTimes = defaultdict(lambda: [0, 0])\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkIns[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        startStation, startTime = self.checkIns[id]\\n        route = (startStation, stationName)\\n        timeTravel = t - startTime\\n        self.averageTimes[route][0] += timeTravel\\n        self.averageTimes[route][1] += 1\\n\\n def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        totalTime, totalTrips = self.averageTimes[(startStation, endStation)]\\n        return totalTime / totalTrips if totalTrips > 0 else 0.0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580951,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n\\n    map<int,pair<string,int>>m1;\\n    map<pair<string,string>,vector<int>>dist;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        m1[id]={stationName,t};\\n        \\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto st=m1[id];\\n        dist[{st.first,stationName}].push_back(t-st.second);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        int c=0;\\n        auto v=dist[{startStation,endStation}];\\n        for(auto x:v)\\n        c+=x;\\n\\n        return double(c)/v.size();\\n        \\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n\\n    map<int,pair<string,int>>m1;\\n    map<pair<string,string>,vector<int>>dist;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        m1[id]={stationName,t};\\n        \\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto st=m1[id];\\n        dist[{st.first,stationName}].push_back(t-st.second);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        int c=0;\\n        auto v=dist[{startStation,endStation}];\\n        for(auto x:v)\\n        c+=x;\\n\\n        return double(c)/v.size();\\n        \\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580719,
                "title": "java-solution-for-design-underground-system-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the above solution is to keep track of the check-in and check-out times of customers, and calculate the average travel time between stations based on this information.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe UndergroundSystem class maintains two hash maps:\\n\\n- checkIns maps customer IDs to their corresponding check-in records. This allows us to keep track of the station and time when a customer checks in.\\n- stationRecords maps startStation + \"->\" + endStation routes to their corresponding station records. Each station record keeps track of the total travel time and the number of trips made on that route.\\n\\nThe checkIn method adds a new check-in record to the checkIns map.\\n\\nThe checkOut method retrieves the check-in record for the given customer ID, calculates the travel time, and updates the corresponding station record in the stationRecords map.\\n\\nThe getAverageTime method retrieves the station record for the given route and returns the average travel time.\\n\\nThe approach is to use two hash maps to store the necessary information. The checkIns map is used to map customer IDs to their check-in records, which include the station and time of check-in. The stationRecords map is used to map startStation + \"->\" + endStation routes to their corresponding station records. Each station record keeps track of the total travel time and the count of trips made on that route.\\n\\nWhen a customer checks in, the checkIn method adds a new check-in record to the checkIns map. When a customer checks out, the checkOut method retrieves the check-in record for the customer ID, calculates the travel time, and updates the corresponding station record in the stationRecords map. The getAverageTime method retrieves the station record for the given route and returns the average travel time.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the checkIn and checkOut methods is O(1) as they involve simple map operations like putting and getting elements. The time complexity of the getAverageTime method is also O(1) as it involves retrieving the station record and performing a simple division operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n), where n is the number of unique routes (startStation + \"->\" + endStation). The space is used to store the check-in records in the checkIns map and the station records in the stationRecords map. In the worst case, where there are many unique routes, the space complexity could be O(m), where m is the total number of calls to the checkIn and checkOut methods.\\n\\n# Code\\n```\\nclass UndergroundSystem {\\n    private Map<Integer, CheckInRecord> checkIns; // Maps customer ID to CheckInRecord\\n    private Map<String, StationRecord> stationRecords; // Maps startStation + \"->\" + endStation to StationRecord\\n\\n    public UndergroundSystem() {\\n        checkIns = new HashMap<>();\\n        stationRecords = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkIns.put(id, new CheckInRecord(stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        CheckInRecord checkInRecord = checkIns.get(id);\\n        String route = checkInRecord.station + \"->\" + stationName;\\n        int travelTime = t - checkInRecord.time;\\n        \\n        // Update the station record or create a new one if it doesn\\'t exist\\n        stationRecords.computeIfAbsent(route, key -> new StationRecord())\\n                     .update(travelTime);\\n        \\n        checkIns.remove(id); // Remove the check-in record\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String route = startStation + \"->\" + endStation;\\n        StationRecord stationRecord = stationRecords.get(route);\\n        \\n        // Calculate and return the average time\\n        return stationRecord.getAverageTime();\\n    }\\n}\\nclass CheckInRecord {\\n    String station;\\n    int time;\\n\\n    public CheckInRecord(String station, int time) {\\n        this.station = station;\\n        this.time = time;\\n    }\\n}\\n\\nclass StationRecord {\\n    int totalTravelTime;\\n    int count;\\n\\n    public void update(int travelTime) {\\n        totalTravelTime += travelTime;\\n        count++;\\n    }\\n\\n    public double getAverageTime() {\\n        return (double) totalTravelTime / count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    private Map<Integer, CheckInRecord> checkIns; // Maps customer ID to CheckInRecord\\n    private Map<String, StationRecord> stationRecords; // Maps startStation + \"->\" + endStation to StationRecord\\n\\n    public UndergroundSystem() {\\n        checkIns = new HashMap<>();\\n        stationRecords = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkIns.put(id, new CheckInRecord(stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        CheckInRecord checkInRecord = checkIns.get(id);\\n        String route = checkInRecord.station + \"->\" + stationName;\\n        int travelTime = t - checkInRecord.time;\\n        \\n        // Update the station record or create a new one if it doesn\\'t exist\\n        stationRecords.computeIfAbsent(route, key -> new StationRecord())\\n                     .update(travelTime);\\n        \\n        checkIns.remove(id); // Remove the check-in record\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String route = startStation + \"->\" + endStation;\\n        StationRecord stationRecord = stationRecords.get(route);\\n        \\n        // Calculate and return the average time\\n        return stationRecord.getAverageTime();\\n    }\\n}\\nclass CheckInRecord {\\n    String station;\\n    int time;\\n\\n    public CheckInRecord(String station, int time) {\\n        this.station = station;\\n        this.time = time;\\n    }\\n}\\n\\nclass StationRecord {\\n    int totalTravelTime;\\n    int count;\\n\\n    public void update(int travelTime) {\\n        totalTravelTime += travelTime;\\n        count++;\\n    }\\n\\n    public double getAverageTime() {\\n        return (double) totalTravelTime / count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580668,
                "title": "design-underground-system-optimized-solution-daily-leetcode-challenge",
                "content": "```\\nclass UndergroundSystem {\\nprivate:\\n    unordered_map<int, pair<string, int>> checkIns; // customer ID -> {stationName, check-in time}\\n    unordered_map<string, pair<double, int>> travelTimes; // startStation:endStation -> {total travel time, number of trips}\\n\\npublic:\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkIns[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& checkInInfo = checkIns[id];\\n        string route = checkInInfo.first + \":\" + stationName;\\n        double travelTime = t - checkInInfo.second;\\n        \\n        travelTimes[route].first += travelTime;\\n        travelTimes[route].second++;\\n        \\n        checkIns.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string route = startStation + \":\" + endStation;\\n        double totalTime = travelTimes[route].first;\\n        int numTrips = travelTimes[route].second;\\n        \\n        return totalTime / numTrips;\\n    }\\n};\\n```\\n\\n**Explanation**\\n\\nThe provided solution implements the \\'UndergroundSystem\\' class to keep track of customer travel times between different stations and calculate the average time it takes to travel from one station to another.\\n\\nThe class has two main data structures: \\'checkIns\\' and \\'travelTimes\\'.\\n\\nThe \\'checkIns\\' unordered map stores the check-in information for each customer. The key is the customer ID, and the value is a pair containing the station name and the check-in time. This map is used to keep track of which customer is currently checked in at which station.\\n\\nThe \\'travelTimes\\' unordered map stores the total travel time and the number of trips for each pair of start and end stations. The key is a concatenated string of the start and end station names (e.g., \"startStation:endStation\"), and the value is a pair containing the total travel time and the number of trips. This map is used to calculate the average travel time between two stations.\\n\\nThe \\'checkIn\\' method takes the customer ID, station name, and check-in time as input. It updates the \\'checkIns\\' map by associating the customer ID with the station name and check-in time.\\n\\nThe \\'checkOut\\' method takes the customer ID, station name, and check-out time as input. It retrieves the check-in information of the customer from the \\'checkIns\\' map. It then calculates the travel time by subtracting the check-in time from the check-out time. Using the start and end station names, it forms a route string. It updates the \\'travelTimes\\' map by adding the travel time to the existing total travel time for the route and incrementing the number of trips.\\n\\nThe \\'getAverageTime\\' method takes the start and end station names as input and retrieves the corresponding route from the \\'travelTimes\\' map. It calculates the average travel time by dividing the total travel time by the number of trips.\\n\\nOverall, the solution provides efficient operations for checking in and out customers and retrieving the average travel time between stations. It uses two hash maps to store the necessary information, allowing for constant time complexity for each operation. The space complexity is also constant, as the maximum number of customers and unique start-end station pairs is limited by the problem constraints.\\n\\n**Complexity Analysis**\\n\\nTime Complexity:\\n* The checkIn and checkOut methods have a time complexity of O(1) since they only involve inserting and updating elements in hash maps.\\n* The getAverageTime method also has a time complexity of O(1) since it performs a constant number of operations to retrieve the average time from the hash map.\\n* Overall, the time complexity of the solution is O(1) for each method.\\n\\nSpace Complexity:\\n* The space complexity of the solution depends on the number of unique customers and the number of unique start-end station pairs.\\n* In the worst case, if there are N unique customers and M unique start-end station pairs, the space complexity will be O(N + M).\\n* However, since the problem statement specifies that there will be at most 2 * 10^4 calls to the methods, the space complexity is effectively constant.\\n* Therefore, the space complexity of the solution is O(1).\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\nprivate:\\n    unordered_map<int, pair<string, int>> checkIns; // customer ID -> {stationName, check-in time}\\n    unordered_map<string, pair<double, int>> travelTimes; // startStation:endStation -> {total travel time, number of trips}\\n\\npublic:\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkIns[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& checkInInfo = checkIns[id];\\n        string route = checkInInfo.first + \":\" + stationName;\\n        double travelTime = t - checkInInfo.second;\\n        \\n        travelTimes[route].first += travelTime;\\n        travelTimes[route].second++;\\n        \\n        checkIns.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string route = startStation + \":\" + endStation;\\n        double totalTime = travelTimes[route].first;\\n        int numTrips = travelTimes[route].second;\\n        \\n        return totalTime / numTrips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976797,
                "title": "cpp-solution-with-explanation-easy-understanding",
                "content": "**//Code with Explanation Bleow**\\n\\n```\\nclass UndergroundSystem {\\npublic:\\n\\n    //here we are taking a map DS to save the journey details of the customer\\n    map<int,pair<int,string>> entryDetails; /*here key will be the ID, as ID is unique in the question as well,\\n                                              and pair will be the value in which we have int as time and string as station Name*/ \\n \\n    //here we are taking another map DS to save the total Traveling time between two stations\\n    map<pair<string,string>,int> totalTravelTime;/*here pair will be the key, using which we will get value \\n                                                total Travel Time of type int */\\n \\n    //here we are taking 3rd map DS to save or to keep track of number of customers who travelled in the exact same path\\n    map<pair<string,string>,int> noOfCustomers;\\n \\n    UndergroundSystem() {\\n \\n    }\\n \\n    void checkIn(int id, string stationName, int t) {\\n        entryDetails[id] = {t,stationName};//saving the ticket details of customer while purchasing!\\n    }\\n \\n    void checkOut(int id, string stationName, int t) {//only here we will check the tickets!\\n        double diff = (t-entryDetails[id].first); // here we are calculating the time difference between stations\\n \\n        totalTravelTime[{entryDetails[id].second,stationName}] += diff; //here we are adding the time difference\\n        noOfCustomers[{entryDetails[id].second,stationName}]++;/*here we are incrementing the number of customer \\n                                                                who have travelled in the exact same path*/\\n \\n        entryDetails.erase(id);//here we are erasing the details as we are checking out!\\n    }\\n \\n    double getAverageTime(string startStation, string endStation) {\\n        return ((double)totalTravelTime[{startStation,endStation}])/noOfCustomers[{startStation,endStation}];/*here we are \\n        simply deviding the total travel time with total number of customers who travelled in that exact same path*/\\n    }\\n};\\n \\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n\\n    //here we are taking a map DS to save the journey details of the customer\\n    map<int,pair<int,string>> entryDetails; /*here key will be the ID, as ID is unique in the question as well,\\n                                              and pair will be the value in which we have int as time and string as station Name*/ \\n \\n    //here we are taking another map DS to save the total Traveling time between two stations\\n    map<pair<string,string>,int> totalTravelTime;/*here pair will be the key, using which we will get value \\n                                                total Travel Time of type int */\\n \\n    //here we are taking 3rd map DS to save or to keep track of number of customers who travelled in the exact same path\\n    map<pair<string,string>,int> noOfCustomers;\\n \\n    UndergroundSystem() {\\n \\n    }\\n \\n    void checkIn(int id, string stationName, int t) {\\n        entryDetails[id] = {t,stationName};//saving the ticket details of customer while purchasing!\\n    }\\n \\n    void checkOut(int id, string stationName, int t) {//only here we will check the tickets!\\n        double diff = (t-entryDetails[id].first); // here we are calculating the time difference between stations\\n \\n        totalTravelTime[{entryDetails[id].second,stationName}] += diff; //here we are adding the time difference\\n        noOfCustomers[{entryDetails[id].second,stationName}]++;/*here we are incrementing the number of customer \\n                                                                who have travelled in the exact same path*/\\n \\n        entryDetails.erase(id);//here we are erasing the details as we are checking out!\\n    }\\n \\n    double getAverageTime(string startStation, string endStation) {\\n        return ((double)totalTravelTime[{startStation,endStation}])/noOfCustomers[{startStation,endStation}];/*here we are \\n        simply deviding the total travel time with total number of customers who travelled in that exact same path*/\\n    }\\n};\\n \\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976739,
                "title": "concise-fully-explained-interview-ready",
                "content": "```\\nclass UndergroundSystem {\\n    // ID mapped to start name and time difference\\n    HashMap<Integer, Pair<String, Integer>> check_in = new HashMap<>();\\n    \\n    // lets map a start location to another map of end locations which will have a value that will be an array to keep track of count and sum\\n\\t\\n\\t// Ex:    {  \"WaterLoo\":  { \"Cambridge\": [1, 20], \"Britain\": [3, 45] }  } \\n\\t\\n    HashMap<String, HashMap<String, int[]>> time_differences = new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    // lets first keep track of id -> name, time\\n    public void checkIn(int id, String stationName, int t) {\\n        check_in.put(id, new Pair(stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String end, int t) {\\n        // find the start location and the start time\\n        Pair<String, Integer> start = check_in.get(id);\\n        \\n        // initalize map for starting locations\\n        time_differences.putIfAbsent(start.getKey(), new HashMap<>());\\n        \\n        // initialize start location map with an entry for this current end location\\n        time_differences.get(start.getKey()).putIfAbsent(end, new int[2]);\\n        \\n        // first array indice will simply count trips\\n        time_differences.get(start.getKey()).get(end)[0]++;\\n        \\n        // count the time\\n        time_differences.get(start.getKey()).get(end)[1] += (t - start.getValue());\\n        \\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        // find ALL entries for corresponding start location\\n        HashMap<String, int[]> trips = time_differences.get(startStation);\\n        \\n        // find data points for specific end location\\n        int[] arr = trips.get(endStation);\\n        \\n        // pretty simple, sum over count\\n        return (double) arr[1] / arr[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    // ID mapped to start name and time difference\\n    HashMap<Integer, Pair<String, Integer>> check_in = new HashMap<>();\\n    \\n    // lets map a start location to another map of end locations which will have a value that will be an array to keep track of count and sum\\n\\t\\n\\t// Ex:    {  \"WaterLoo\":  { \"Cambridge\": [1, 20], \"Britain\": [3, 45] }  } \\n\\t\\n    HashMap<String, HashMap<String, int[]>> time_differences = new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    // lets first keep track of id -> name, time\\n    public void checkIn(int id, String stationName, int t) {\\n        check_in.put(id, new Pair(stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String end, int t) {\\n        // find the start location and the start time\\n        Pair<String, Integer> start = check_in.get(id);\\n        \\n        // initalize map for starting locations\\n        time_differences.putIfAbsent(start.getKey(), new HashMap<>());\\n        \\n        // initialize start location map with an entry for this current end location\\n        time_differences.get(start.getKey()).putIfAbsent(end, new int[2]);\\n        \\n        // first array indice will simply count trips\\n        time_differences.get(start.getKey()).get(end)[0]++;\\n        \\n        // count the time\\n        time_differences.get(start.getKey()).get(end)[1] += (t - start.getValue());\\n        \\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        // find ALL entries for corresponding start location\\n        HashMap<String, int[]> trips = time_differences.get(startStation);\\n        \\n        // find data points for specific end location\\n        int[] arr = trips.get(endStation);\\n        \\n        // pretty simple, sum over count\\n        return (double) arr[1] / arr[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976634,
                "title": "self-explanatory-java-solution-using-java-amazing-code-for-newbies",
                "content": "```\\nclass UndergroundSystem {\\n    \\n    class MyClass{\\n        String name;\\n        int time;\\n        \\n        public MyClass(String name, int time){\\n            this.name = name;\\n            this.time = time;\\n        }\\n    }\\n    \\n    HashMap<Integer,MyClass> map;\\n    HashMap<String,int[]> avgMap;\\n    \\n    public UndergroundSystem() {\\n        map = new HashMap<>();\\n        avgMap = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        map.put(id,new MyClass(stationName,t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        \\n        MyClass curr = map.get(id);\\n        \\n        String str = curr.name+\" \"+stationName;\\n        int time = t-curr.time;\\n        \\n        map.remove(id);\\n        \\n        if(avgMap.containsKey(str)){\\n            int[] arr = avgMap.get(str);\\n            arr[0] += time;\\n            arr[1]++;    \\n        }\\n        \\n        else{\\n            int[] arr = new int[2];\\n            arr[0] = time;\\n            arr[1] = 1;\\n            avgMap.put(str,arr);\\n        }\\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String temp = startStation+\" \"+endStation;\\n        int[] arr = avgMap.get(temp);\\n        return (double)arr[0]/(double)arr[1];\\n    }\\n}\\n```\\n\\nDo upvote if found helpful and feel free to ask your doubts in the comments below!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    \\n    class MyClass{\\n        String name;\\n        int time;\\n        \\n        public MyClass(String name, int time){\\n            this.name = name;\\n            this.time = time;\\n        }\\n    }\\n    \\n    HashMap<Integer,MyClass> map;\\n    HashMap<String,int[]> avgMap;\\n    \\n    public UndergroundSystem() {\\n        map = new HashMap<>();\\n        avgMap = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        map.put(id,new MyClass(stationName,t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        \\n        MyClass curr = map.get(id);\\n        \\n        String str = curr.name+\" \"+stationName;\\n        int time = t-curr.time;\\n        \\n        map.remove(id);\\n        \\n        if(avgMap.containsKey(str)){\\n            int[] arr = avgMap.get(str);\\n            arr[0] += time;\\n            arr[1]++;    \\n        }\\n        \\n        else{\\n            int[] arr = new int[2];\\n            arr[0] = time;\\n            arr[1] = 1;\\n            avgMap.put(str,arr);\\n        }\\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String temp = startStation+\" \"+endStation;\\n        int[] arr = avgMap.get(temp);\\n        return (double)arr[0]/(double)arr[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408328,
                "title": "c-hashmap-solution-easy-understandable-solution",
                "content": "Just 2 hashmaps and the solution is done.\\n```\\n\\tunordered_map<int, pair<string, int>> mp;\\n    map<pair<string, string>, vector<int>> mpp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(mp.find(id)!=mp.end())\\n        {\\n            mpp[{mp[id].first, stationName}].push_back(t-mp[id].second);\\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum = 0, count = 0;\\n        if(mpp.find({startStation, endStation})!=mpp.end())\\n        {\\n            for(int x : mpp[{startStation, endStation}])\\n            {\\n                sum += x;\\n                count++;\\n            }\\n        }\\n        \\n        return sum/count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\n\\tunordered_map<int, pair<string, int>> mp;\\n    map<pair<string, string>, vector<int>> mpp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(mp.find(id)!=mp.end())\\n        {\\n            mpp[{mp[id].first, stationName}].push_back(t-mp[id].second);\\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum = 0, count = 0;\\n        if(mpp.find({startStation, endStation})!=mpp.end())\\n        {\\n            for(int x : mpp[{startStation, endStation}])\\n            {\\n                sum += x;\\n                count++;\\n            }\\n        }\\n        \\n        return sum/count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119518,
                "title": "high-level-system-design-component-diagram-java-o-1-code-as-well",
                "content": "* I was thinking how one would design such a service,  I used ECS + Fargate (container orchestration service) and DynamoDB tables. \\n* I also use an Application Load Balancer which can also has support for custom targets so i use it as both to balance load and route requests to appropriate Fargate tasks\\n* I think this design should work at scale as each component can scale on its own. Thoughts?\\n* If I were to do it without AWS components, the components more or less would remain the same, we would need a load balancer, some application servers and any NoSQL database. We would just to manage the scaling ourselves.\\n* I chose NoSQL Design as we need to support high Read/Write TPS and we dont need any transaction gurantees here. \\n* Any thoughts? Am i missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/f5e87f94-cbb7-4dc3-9356-3d8bc95aa071_1616289431.3375604.png)\\n\\n```\\nclass UndergroundSystem {\\n    \\n    Map<Integer, Pair<String, Integer>> customerIdToCheckInMap; //customerId -> StartStation, StartTime\\n    Map<String, Pair<Double, Double>> stationAverageTimeMap; //station -> totalJourneyTime -> totalTrips\\n    \\n\\n    public UndergroundSystem() {\\n        customerIdToCheckInMap = new HashMap<>();\\n        stationAverageTimeMap = new HashMap<>();\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        customerIdToCheckInMap.put(id, new Pair<>(stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Pair<String, Integer> stationCheckInTime = customerIdToCheckInMap.get(id);\\n        String srcStation = stationCheckInTime.getKey();\\n        Integer checkInTime = stationCheckInTime.getValue();\\n        \\n        String key = getKey(srcStation, stationName);\\n        double journeyTime = t - checkInTime;\\n        stationAverageTimeMap.putIfAbsent(key, new Pair<>(0.0,0.0));\\n        Pair<Double,Double> distanceAndTrips = stationAverageTimeMap.get(key);\\n        double totalJourneyTime = distanceAndTrips.getKey() + journeyTime;\\n        double totalTrips = distanceAndTrips.getValue() + 1;\\n        stationAverageTimeMap.put(key, new Pair<>(totalJourneyTime, totalTrips));\\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        return stationAverageTimeMap.get(getKey(startStation,endStation )).getKey()/stationAverageTimeMap.get(getKey(startStation,endStation )).getValue();\\n    }\\n    \\n    private String getKey(String src, String dest) {\\n        return src+\"->\"+dest;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n    \\n    Map<Integer, Pair<String, Integer>> customerIdToCheckInMap; //customerId -> StartStation, StartTime\\n    Map<String, Pair<Double, Double>> stationAverageTimeMap; //station -> totalJourneyTime -> totalTrips\\n    \\n\\n    public UndergroundSystem() {\\n        customerIdToCheckInMap = new HashMap<>();\\n        stationAverageTimeMap = new HashMap<>();\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        customerIdToCheckInMap.put(id, new Pair<>(stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Pair<String, Integer> stationCheckInTime = customerIdToCheckInMap.get(id);\\n        String srcStation = stationCheckInTime.getKey();\\n        Integer checkInTime = stationCheckInTime.getValue();\\n        \\n        String key = getKey(srcStation, stationName);\\n        double journeyTime = t - checkInTime;\\n        stationAverageTimeMap.putIfAbsent(key, new Pair<>(0.0,0.0));\\n        Pair<Double,Double> distanceAndTrips = stationAverageTimeMap.get(key);\\n        double totalJourneyTime = distanceAndTrips.getKey() + journeyTime;\\n        double totalTrips = distanceAndTrips.getValue() + 1;\\n        stationAverageTimeMap.put(key, new Pair<>(totalJourneyTime, totalTrips));\\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        return stationAverageTimeMap.get(getKey(startStation,endStation )).getKey()/stationAverageTimeMap.get(getKey(startStation,endStation )).getValue();\\n    }\\n    \\n    private String getKey(String src, String dest) {\\n        return src+\"->\"+dest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118700,
                "title": "rust-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Default)]\\nstruct UndergroundSystem {\\n    checkins: HashMap<i32, (String, i32)>,\\n    travels: HashMap<(String, String), (i32, usize)>,\\n}\\n\\nimpl UndergroundSystem {\\n\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn check_in(&mut self, id: i32, station_name: String, t: i32) {\\n        self.checkins.insert(id, (station_name, t));\\n    }\\n    \\n    fn check_out(&mut self, id: i32, station_name: String, t: i32) {\\n        if let Some((start_station, start_t)) = self.checkins.get(&id) {\\n            let travel = self\\n                .travels\\n                .entry((start_station.clone(), station_name))\\n                .or_default();\\n            travel.0 += t - start_t;\\n            travel.1 += 1;\\n        }\\n    }\\n    \\n    fn get_average_time(&self, start_station: String, end_station: String) -> f64 {\\n        if let Some(&(total, len)) = self.travels.get(&(start_station, end_station)) {\\n            return f64::from(total) / len as f64;\\n        }\\n        unreachable!()\\n    }\\n}\\n ```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Default)]\\nstruct UndergroundSystem {\\n    checkins: HashMap<i32, (String, i32)>,\\n    travels: HashMap<(String, String), (i32, usize)>,\\n}\\n\\nimpl UndergroundSystem {\\n\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n    \\n    fn check_in(&mut self, id: i32, station_name: String, t: i32) {\\n        self.checkins.insert(id, (station_name, t));\\n    }\\n    \\n    fn check_out(&mut self, id: i32, station_name: String, t: i32) {\\n        if let Some((start_station, start_t)) = self.checkins.get(&id) {\\n            let travel = self\\n                .travels\\n                .entry((start_station.clone(), station_name))\\n                .or_default();\\n            travel.0 += t - start_t;\\n            travel.1 += 1;\\n        }\\n    }\\n    \\n    fn get_average_time(&self, start_station: String, end_station: String) -> f64 {\\n        if let Some(&(total, len)) = self.travels.get(&(start_station, end_station)) {\\n            return f64::from(total) / len as f64;\\n        }\\n        unreachable!()\\n    }\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1118334,
                "title": "design-underground-system-short-easy-w-explantion",
                "content": "We need two data structures, specifically hashmaps - \\n* **`checkIns`** : It maps customer id to checkin station and time.\\n* **`routeTimings`**: It maps startStation-endStation to total timings and number of records of startStation-endStation till now.\\n\\nThe rest of solution can be understood from comments in the solution below : \\n\\n```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int> >checkIns;        // id : {stationName, time}\\n    unordered_map<string, pair<int, int> >routeTimings;    // startStation-endStation : {sumOfTime, count}\\npublic:\\n    UndergroundSystem() {  }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkIns[id] = {stationName, t};           // store id checked in at stationName at time t\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n\\t    //                     startStation       -    endStation\\n        string startToEnd = checkIns[id].first + \\'-\\' + stationName; \\n\\t\\t// update route\\'s total time and count\\n        routeTimings[startToEnd] = {routeTimings[startToEnd].first + (t - checkIns[id].second), routeTimings[startToEnd].second + 1};\\n        checkIns.erase(id); // erase checkin data to free up memory\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        pair<int, int> p = routeTimings[startStation + \\'-\\' + endStation];\\n\\t\\t// divide   total time by total cound to get average route time\\n        return (double)p.first / p.second;\\n    }\\n};\\n```\\n**`Time Complexity`** : **`O(1)`** , since a hashmap functions in amortized O(1) time.\\n**`Space Complexity`** : **`O(N^2)`**, where `N` is total number of stations. In the worst case, routes from all stations to all stations will have to be stored. For a graph having `N` nodes, max number of edges is equal to `N*(N-1)/2` = `O(N^2)`\\n\\n\\n![image](https://assets.leetcode.com/users/images/7dc0354a-24a0-43f8-8165-e22bdce68e67_1616232947.3673246.png)\\n\\nThe 100% memory was achieved by storing *hash of string* instead of the whole string itself.\\n\\n----------\\n---------\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int> >checkIns;        // id : {stationName, time}\\n    unordered_map<string, pair<int, int> >routeTimings;    // startStation-endStation : {sumOfTime, count}\\npublic:\\n    UndergroundSystem() {  }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkIns[id] = {stationName, t};           // store id checked in at stationName at time t\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n\\t    //                     startStation       -    endStation\\n        string startToEnd = checkIns[id].first + \\'-\\' + stationName; \\n\\t\\t// update route\\'s total time and count\\n        routeTimings[startToEnd] = {routeTimings[startToEnd].first + (t - checkIns[id].second), routeTimings[startToEnd].second + 1};\\n        checkIns.erase(id); // erase checkin data to free up memory\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        pair<int, int> p = routeTimings[startStation + \\'-\\' + endStation];\\n\\t\\t// divide   total time by total cound to get average route time\\n        return (double)p.first / p.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589192,
                "title": "javascript-hashmap-w-comments",
                "content": "```\\nclass UndergroundSystem {\\n    // class constructor\\n    constructor() {\\n        // check ins are of type {id : {checkIn time, station name}}\\n        this.checkIns = {};\\n        // trips are of type {route : [full elapsed times]}\\n        this.trips = {};\\n    }\\n\\t\\n    checkIn(id, stationName, t) {\\n        // log check in\\n        this.checkIns[id] = {\\n            t: t,\\n            stationName: stationName,\\n        };\\n    }\\n\\t\\n    checkOut(id, stationName, t) {\\n        // create route string\\n        const route = this.checkIns[id].stationName +\\n            \\'=>\\' +\\n            stationName;\\n        // check if this route is not in trips obj yet\\n        if (!(route in this.trips))\\n            this.trips[route] = [];\\n        // push elapsed time to route: trips\\n        this.trips[route].push(t - this.checkIns[id].t);\\n    }\\n\\t\\n    getAverageTime(startStation, endStation) {\\n        // create route string\\n        const route = startStation + \\'=>\\' + endStation;\\n        // running sum\\n        let sum = 0;\\n        // iterate thru all elapsed trip times for this route\\n        for (let i = 0; i < this.trips[route].length; i++) {\\n            // add to running sum\\n            sum += this.trips[route][i];\\n        }\\n        // return avg\\n        return sum / this.trips[route].length;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    // class constructor\\n    constructor() {\\n        // check ins are of type {id : {checkIn time, station name}}\\n        this.checkIns = {};\\n        // trips are of type {route : [full elapsed times]}\\n        this.trips = {};\\n    }\\n\\t\\n    checkIn(id, stationName, t) {\\n        // log check in\\n        this.checkIns[id] = {\\n            t: t,\\n            stationName: stationName,\\n        };\\n    }\\n\\t\\n    checkOut(id, stationName, t) {\\n        // create route string\\n        const route = this.checkIns[id].stationName +\\n            \\'=>\\' +\\n            stationName;\\n        // check if this route is not in trips obj yet\\n        if (!(route in this.trips))\\n            this.trips[route] = [];\\n        // push elapsed time to route: trips\\n        this.trips[route].push(t - this.checkIns[id].t);\\n    }\\n\\t\\n    getAverageTime(startStation, endStation) {\\n        // create route string\\n        const route = startStation + \\'=>\\' + endStation;\\n        // running sum\\n        let sum = 0;\\n        // iterate thru all elapsed trip times for this route\\n        for (let i = 0; i < this.trips[route].length; i++) {\\n            // add to running sum\\n            sum += this.trips[route][i];\\n        }\\n        // return avg\\n        return sum / this.trips[route].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554900,
                "title": "hashmap-easy-implementation-with-comment",
                "content": "```\\nclass UndergroundSystem {\\n    Map<String, Integer> totalTravels = new HashMap<>();// keeps count of travel from x-> y\\n    Map<String, Long> totalTimeStay = new HashMap<>();// keeps time stay from x-> y\\n    Map<Integer, String> stationName = new HashMap<>();//keeps stationName status of customer ID\\n    Map<Integer, Integer> time = new HashMap<>();//keeps checkin time of customer ID\\n\\n    public UndergroundSystem() {\\n\\n    }\\n\\n    public void checkIn(int id, String stationName, int t) {\\n        this.stationName.put(id, stationName);// where is custID\\n        time.put(id, t);// put check in time\\n    }\\n\\n    public void checkOut(int id, String stationName, int t) {\\n        String code = this.stationName.get(id) + \"*\" + stationName;// custID start-end\\n        int cha = t - time.get(id);\\n        this.stationName.remove(id);\\n        time.remove(id);\\n        if (!totalTravels.containsKey(code)) //travelled 1st time\\n            totalTravels.put(code, 0);\\n        totalTravels.put(code, totalTravels.get(code) + 1);// update total \\n        if (!totalTimeStay.containsKey(code)) \\n            totalTimeStay.put(code, 0L);\\n        totalTimeStay.put(code, totalTimeStay.get(code) + cha);\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        String code = startStation + \"*\" + endStation;\\n        double x = totalTimeStay.get(code);\\n        return x / totalTravels.get(code);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    Map<String, Integer> totalTravels = new HashMap<>();// keeps count of travel from x-> y\\n    Map<String, Long> totalTimeStay = new HashMap<>();// keeps time stay from x-> y\\n    Map<Integer, String> stationName = new HashMap<>();//keeps stationName status of customer ID\\n    Map<Integer, Integer> time = new HashMap<>();//keeps checkin time of customer ID\\n\\n    public UndergroundSystem() {\\n\\n    }\\n\\n    public void checkIn(int id, String stationName, int t) {\\n        this.stationName.put(id, stationName);// where is custID\\n        time.put(id, t);// put check in time\\n    }\\n\\n    public void checkOut(int id, String stationName, int t) {\\n        String code = this.stationName.get(id) + \"*\" + stationName;// custID start-end\\n        int cha = t - time.get(id);\\n        this.stationName.remove(id);\\n        time.remove(id);\\n        if (!totalTravels.containsKey(code)) //travelled 1st time\\n            totalTravels.put(code, 0);\\n        totalTravels.put(code, totalTravels.get(code) + 1);// update total \\n        if (!totalTimeStay.containsKey(code)) \\n            totalTimeStay.put(code, 0L);\\n        totalTimeStay.put(code, totalTimeStay.get(code) + cha);\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        String code = startStation + \"*\" + endStation;\\n        double x = totalTimeStay.get(code);\\n        return x / totalTravels.get(code);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583118,
                "title": "easy-solution-with-intuition-and-mathematical-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem we need to know the following things \\n\\nIn the checkout time function we need to know about the checkin time for that particular id . Hence we need to store the data of startStation and startTime ( in my case i have used a map named entry for it)\\n\\nAnd i will do some calculation to find out the average time which i will store in another map for accessing this information in getAverageTime function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nMain crisp of the problem is that how we will find out the average time between two stations \\n\\nlet say we know startTime and EndTime then we can calculate avg simply as \\n\\nAverage Time = ( EndTime - StartTime) / 1;\\n\\nBut this is the case of only one person what if multiple person are travelling between same stations ? \\n\\nLet us assume we know the old average and the number of persons which have contributed for this old average and now we have a new Entry for the same range then we will first calculate time elasped for this entry \\n\\nNew Entry Time = ( EndTime - StartTime);\\n\\nNow we can calculate the new Average time as follows :\\n\\nNew Average = ( Old Average * Number of Person + New Entry Time ) / ( Number of Person + 1);\\n\\nAnd this average time we will update in our map ( named time) for the corresponding startStation and endStation\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logN) can be reduced to O(1) by using unordered map\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n    // map for time --> \\n    // key -> (StartStation EndStation) , value -> time , no of travelers so far\\n \\n    map< pair<string,string> , pair<double,int >>time;\\n    \\n    // map for tracing entry \\n    // key -> id , value -> startStation , startTime\\n    \\n\\n    map < int ,pair<string,int>> entry;\\n    \\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n         \\n         entry[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        \\n        string  startStation = entry[id].first;\\n        string  endStation   = stationName;\\n\\n        int startTime = entry[id].second;\\n        int endTime   = t;\\n\\n        int travelTime = endTime-startTime;\\n\\n        double previousAvg = time[{startStation , endStation}].first; \\n\\n        int previousDataSize = time[{startStation , endStation}].second; \\n\\n        double newAvg = (previousAvg * (double) previousDataSize + (double)travelTime)/ (previousDataSize + 1);\\n\\n        time[{startStation , endStation}].first = newAvg;\\n        time[{startStation , endStation}].second = previousDataSize + 1 ; \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n          \\n          return time[{startStation , endStation}].first;\\n\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    // map for time --> \\n    // key -> (StartStation EndStation) , value -> time , no of travelers so far\\n \\n    map< pair<string,string> , pair<double,int >>time;\\n    \\n    // map for tracing entry \\n    // key -> id , value -> startStation , startTime\\n    \\n\\n    map < int ,pair<string,int>> entry;\\n    \\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n         \\n         entry[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        \\n        string  startStation = entry[id].first;\\n        string  endStation   = stationName;\\n\\n        int startTime = entry[id].second;\\n        int endTime   = t;\\n\\n        int travelTime = endTime-startTime;\\n\\n        double previousAvg = time[{startStation , endStation}].first; \\n\\n        int previousDataSize = time[{startStation , endStation}].second; \\n\\n        double newAvg = (previousAvg * (double) previousDataSize + (double)travelTime)/ (previousDataSize + 1);\\n\\n        time[{startStation , endStation}].first = newAvg;\\n        time[{startStation , endStation}].second = previousDataSize + 1 ; \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n          \\n          return time[{startStation , endStation}].first;\\n\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581753,
                "title": "c-explained",
                "content": "```c++\\nclass UndergroundSystem {\\npublic:\\n    // stores \"start_station->end+station\", pairs total time taken and the total number of such journeys till date\\n    unordered_map<string, pair<int, int>> records;\\n    \\n    // stores id, pairs station name and timestamp of check in\\n    unordered_map<int, pair<string, int>> checkIns;\\n    \\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkIns[id] = make_pair(stationName, t);\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int time_started = checkIns[id].second;\\n        string start_station = checkIns[id].first;\\n        checkIns.erase(id);\\n        \\n        // no previous record of this station pair\\n        if (records.find(start_station + \"->\" + stationName) == records.end()) {\\n            records[start_station + \"->\" + stationName] = make_pair(t - time_started, 1);\\n        }\\n        \\n        // a previous such journey exists\\n        // increment the total count of this journey station pair\\n        // also, add to the total time taken\\n        else {\\n            int previous_total_time = records[start_station + \"->\" + stationName].first;\\n            int previous_number_of_times = records[start_station + \"->\" + stationName].second;\\n            \\n            records[start_station + \"->\" + stationName] = make_pair(previous_total_time + (t - time_started), previous_number_of_times + 1);\\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return (double) records[startStation + \"->\" + endStation].first / records[startStation + \"->\" + endStation].second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass UndergroundSystem {\\npublic:\\n    // stores \"start_station->end+station\", pairs total time taken and the total number of such journeys till date\\n    unordered_map<string, pair<int, int>> records;\\n    \\n    // stores id, pairs station name and timestamp of check in\\n    unordered_map<int, pair<string, int>> checkIns;\\n    \\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkIns[id] = make_pair(stationName, t);\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int time_started = checkIns[id].second;\\n        string start_station = checkIns[id].first;\\n        checkIns.erase(id);\\n        \\n        // no previous record of this station pair\\n        if (records.find(start_station + \"->\" + stationName) == records.end()) {\\n            records[start_station + \"->\" + stationName] = make_pair(t - time_started, 1);\\n        }\\n        \\n        // a previous such journey exists\\n        // increment the total count of this journey station pair\\n        // also, add to the total time taken\\n        else {\\n            int previous_total_time = records[start_station + \"->\" + stationName].first;\\n            int previous_number_of_times = records[start_station + \"->\" + stationName].second;\\n            \\n            records[start_station + \"->\" + stationName] = make_pair(previous_total_time + (t - time_started), previous_number_of_times + 1);\\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return (double) records[startStation + \"->\" + endStation].first / records[startStation + \"->\" + endStation].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581622,
                "title": "c-hashmap-short-and-simple",
                "content": "At first, I thought this is spread across days, which is why I stored the start_times as array of id as index, but later realised that no such state save is required.\\n\\nPlease upvote if you find the solution clean and concise.\\n***Thank You!!***\\n\\n```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int, pair<string, int>> start;\\n    unordered_map<string, unordered_map<string, int>> total, times;\\n    UndergroundSystem() {\\n        start.clear(), total.clear(), times.clear();\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        start[id] = { stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        total[start[id].first][stationName] += t - start[id].second;\\n        times[start[id].first][stationName]++;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return (total[startStation][endStation])/(double)(times[startStation][endStation]);\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int, pair<string, int>> start;\\n    unordered_map<string, unordered_map<string, int>> total, times;\\n    UndergroundSystem() {\\n        start.clear(), total.clear(), times.clear();\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        start[id] = { stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        total[start[id].first][stationName] += t - start[id].second;\\n        times[start[id].first][stationName]++;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return (total[startStation][endStation])/(double)(times[startStation][endStation]);\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1976651,
                "title": "easy-c-solution-using-2-maps",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    map<double,pair<string,double>> customer;\\n\\t//customer is storing customer id as key and stationname and time as value\\n    map<pair<string, string>, pair<double, double>> total;\\n\\t//total is storing startstation and endstation as key and totaltime and count as value\\n    UndergroundSystem() {\\n        customer.clear();\\n        total.clear();\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        customer[id]={stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        total[{customer[id].first, stationName}]={\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttotal[{customer[id].first, stationName}].first + (t-customer[id].second) ,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttotal[{customer[id].first, stationName}].second+1 };\\n\\t\\t\\n\\t\\t//total[{customer[id].first, stationName}].first = total time till now,( summation of times for the station)\\n\\t\\t// (t-customer[id].second) = total time for the current customer\\n\\t\\t//total[{customer[id].first, stationName}].second+1 = no. of customers \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return total[ { startStation,endStation } ].first / total[ { startStation, endStation } ].second;\\n\\t\\t// totaltime /no of customers\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    map<double,pair<string,double>> customer;\\n\\t//customer is storing customer id as key and stationname and time as value\\n    map<pair<string, string>, pair<double, double>> total;\\n\\t//total is storing startstation and endstation as key and totaltime and count as value\\n    UndergroundSystem() {\\n        customer.clear();\\n        total.clear();\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        customer[id]={stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        total[{customer[id].first, stationName}]={\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttotal[{customer[id].first, stationName}].first + (t-customer[id].second) ,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttotal[{customer[id].first, stationName}].second+1 };\\n\\t\\t\\n\\t\\t//total[{customer[id].first, stationName}].first = total time till now,( summation of times for the station)\\n\\t\\t// (t-customer[id].second) = total time for the current customer\\n\\t\\t//total[{customer[id].first, stationName}].second+1 = no. of customers \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return total[ { startStation,endStation } ].first / total[ { startStation, endStation } ].second;\\n\\t\\t// totaltime /no of customers\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1119552,
                "title": "java-simple-and-easy-to-understand-solution-84-ms-faster-than-97-00-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass UndergroundSystem {\\n    \\n    //mapping  of personId to\\n    // the startStation, and startTime\\n    HashMap<Integer, Person> personMap;\\n    \\n    //mapping of Pair(startStation, endStation)\\n    //to total travelling time and count\\n    HashMap<Pair<String, String>, Journey> journeyMap;\\n\\n    public UndergroundSystem() {\\n        personMap = new HashMap();\\n        journeyMap = new HashMap();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        personMap.putIfAbsent(id, new Person());\\n        \\n        //update the checkTime, and start station \\n        Person p = personMap.get(id);\\n        p.startTime = t;\\n        p.startStation = stationName;\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Person p = personMap.get(id);\\n        \\n        //get the journey, between start Station and current startion\\n        Journey journey = getJourney(p.startStation, stationName);\\n        \\n        //update travel duration, and travel count\\n        journey.totalTravelDuration += t - p.startTime;\\n        journey.totalTravelcount++;\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        Journey journey = getJourney(startStation, endStation);\\n        return (double) journey.totalTravelDuration / journey.totalTravelcount;\\n    }\\n    \\n    private Journey getJourney(String startStation, String endStation){\\n        \\n        Pair pair = new Pair(startStation, endStation);\\n        \\n        //create a journey object, \\n        //between startStation and endStation\\n        journeyMap.putIfAbsent(pair, new Journey());\\n        \\n        return journeyMap.get(pair);\\n    }\\n    \\n     \\n}\\n\\nclass Journey{\\n    //total travel duration \\n    //by each person, from startStation to endStation\\n    int totalTravelDuration;\\n    int totalTravelcount;\\n    \\n    public Journey(){\\n        this.totalTravelDuration = 0;\\n        this.totalTravelcount = 0;\\n    }\\n}\\n\\nclass Person {\\n    String startStation;\\n    int startTime;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    \\n    //mapping  of personId to\\n    // the startStation, and startTime\\n    HashMap<Integer, Person> personMap;\\n    \\n    //mapping of Pair(startStation, endStation)\\n    //to total travelling time and count\\n    HashMap<Pair<String, String>, Journey> journeyMap;\\n\\n    public UndergroundSystem() {\\n        personMap = new HashMap();\\n        journeyMap = new HashMap();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        personMap.putIfAbsent(id, new Person());\\n        \\n        //update the checkTime, and start station \\n        Person p = personMap.get(id);\\n        p.startTime = t;\\n        p.startStation = stationName;\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Person p = personMap.get(id);\\n        \\n        //get the journey, between start Station and current startion\\n        Journey journey = getJourney(p.startStation, stationName);\\n        \\n        //update travel duration, and travel count\\n        journey.totalTravelDuration += t - p.startTime;\\n        journey.totalTravelcount++;\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        Journey journey = getJourney(startStation, endStation);\\n        return (double) journey.totalTravelDuration / journey.totalTravelcount;\\n    }\\n    \\n    private Journey getJourney(String startStation, String endStation){\\n        \\n        Pair pair = new Pair(startStation, endStation);\\n        \\n        //create a journey object, \\n        //between startStation and endStation\\n        journeyMap.putIfAbsent(pair, new Journey());\\n        \\n        return journeyMap.get(pair);\\n    }\\n    \\n     \\n}\\n\\nclass Journey{\\n    //total travel duration \\n    //by each person, from startStation to endStation\\n    int totalTravelDuration;\\n    int totalTravelcount;\\n    \\n    public Journey(){\\n        this.totalTravelDuration = 0;\\n        this.totalTravelcount = 0;\\n    }\\n}\\n\\nclass Person {\\n    String startStation;\\n    int startTime;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119061,
                "title": "c-python-hashmap-pair-clean-code",
                "content": "Approach 1: hashmap\\nUse two hash tables. The first to save the check-in time for a customer and the second to update the total time between two stations.\\n\\n```\\nclass UndergroundSystem {\\npublic:\\n    void checkIn(int id, string stationName, int t) {\\n        _checkInData[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string& checkInStation = _checkInData[id].first;\\n        string fromTo = checkInStation + \\'_\\' + stationName;\\n        int new_duration = t - _checkInData[id].second;\\n        _fromTo_durations[fromTo]={_fromTo_durations[fromTo].first + new_duration, _fromTo_durations[fromTo].second + 1};\\n        //_fromTo_durations[fromTo] += {new_duration, 1};        \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string fromTo = startStation + \\'_\\' + endStation;\\n        return double(_fromTo_durations[fromTo].first) /  _fromTo_durations[fromTo].second;\\n    }\\n    \\nprivate:\\n    unordered_map<string, pair<int, int> > _fromTo_durations;\\n    unordered_map<int, pair<string, int> > _checkInData;\\n};\\n```\\n\\nApproach 2: hashmap with compact coding\\n```\\nclass UndergroundSystem { // simulation: \\npublic: //Time: O(N); Space:O(N)\\n    void checkIn(int id, string stationName, int t) {\\n        m[id] = {stationName, t}; //only keep latest checkIn info      \\n        //m.insert({id, {stationName, t}}); //ERR. keep 1st checkIn info\\n    }\\n    \\n   void checkOut(int id, string stationName, int t) {\\n        auto& [totDur, cnt] = stats[m[id].first + \"_\" + stationName];\\n        totDur += t - m[id].second;\\n        ++cnt;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        auto& [totDur, cnt] = stats[startStation + \"_\" + endStation];\\n        return (double)totDur/cnt;\\n    }\\n    \\nprivate:\\n    unordered_map<int, pair<string, int>> m;  // id->{station,time}\\n    unordered_map<string, pair<int, int>> stats;//from_to->{totDur, cnt}\\n};\\n```\\n\\nApproach 3: Python version[1][2]. \\nThanks for the coding from opensesame @[opensesame ](https://leetcode.com/opensesame/)\\n\\n\\ndictionary.get(keyname, value)\\nvalue\\tOptional. A value to return if the specified key does not exist.\\nDefault value None\\n\\n```\\nclass UndergroundSystem(object):\\n\\n    def __init__(self):\\n        self.checkinDict = {}\\n        self.stationPairDict = {}\\n\\n    def checkIn(self, id, stationName, t):        \\n        self.checkinDict[id] = (stationName, t)\\n\\n    def checkOut(self, id, stationName, t):\\n        #preStationName, preT = self.checkinDict[id]\\n        preStationName, preT = self.checkinDict.pop(id) #better since no need to keep it \\n        (totalTime, count) = self.stationPairDict.get((preStationName, stationName), (0,0))\\n        self.stationPairDict[(preStationName, stationName)] = (totalTime + t - preT, count+1)        \\n\\n    def getAverageTime(self, startStation, endStation):        \\n        (totalTime, count) = self.stationPairDict[(startStation, endStation)]\\n        return float(totalTime)/count\\n```\\n\\nApproach 4: collections.defaultdict() in python [3]\\n\\n```\\nclass UndergroundSystem(object):\\n\\n    def __init__(self):\\n        self.checkinDict = {}\\n        #self.stationPairDict = {}\\n        self.stationPairDict=collections.defaultdict(lambda:(0,0))\\n\\n    def checkIn(self, id, stationName, t):        \\n        self.checkinDict[id] = (stationName, t)\\n\\n    def checkOut(self, id, stationName, t):\\n        #preStationName, preT = self.checkinDict[id]\\n        preStationName, preT = self.checkinDict.pop(id) #better since no need to keep it \\n        #(totalTime, count) = self.stationPairDict.get((preStationName, stationName), (0,0))\\n        (totalTime, count) = self.stationPairDict[(preStationName, stationName)]\\n        self.stationPairDict[(preStationName, stationName)] = (totalTime + t - preT, count+1)        \\n\\n    def getAverageTime(self, startStation, endStation):        \\n        (totalTime, count) = self.stationPairDict[(startStation, endStation)]\\n        return float(totalTime)/count\\n```\\nReference:\\n[1] https://www.w3schools.com/python/ref_dictionary_get.asp\\n[2] https://www.programiz.com/python-programming/methods/dictionary/pop\\n[3] https://leetcode.com/problems/design-underground-system/solution/\\nself.stationPairDict = collections.defaultdict(lambda : value)\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    void checkIn(int id, string stationName, int t) {\\n        _checkInData[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string& checkInStation = _checkInData[id].first;\\n        string fromTo = checkInStation + \\'_\\' + stationName;\\n        int new_duration = t - _checkInData[id].second;\\n        _fromTo_durations[fromTo]={_fromTo_durations[fromTo].first + new_duration, _fromTo_durations[fromTo].second + 1};\\n        //_fromTo_durations[fromTo] += {new_duration, 1};        \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string fromTo = startStation + \\'_\\' + endStation;\\n        return double(_fromTo_durations[fromTo].first) /  _fromTo_durations[fromTo].second;\\n    }\\n    \\nprivate:\\n    unordered_map<string, pair<int, int> > _fromTo_durations;\\n    unordered_map<int, pair<string, int> > _checkInData;\\n};\\n```\n```\\nclass UndergroundSystem { // simulation: \\npublic: //Time: O(N); Space:O(N)\\n    void checkIn(int id, string stationName, int t) {\\n        m[id] = {stationName, t}; //only keep latest checkIn info      \\n        //m.insert({id, {stationName, t}}); //ERR. keep 1st checkIn info\\n    }\\n    \\n   void checkOut(int id, string stationName, int t) {\\n        auto& [totDur, cnt] = stats[m[id].first + \"_\" + stationName];\\n        totDur += t - m[id].second;\\n        ++cnt;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        auto& [totDur, cnt] = stats[startStation + \"_\" + endStation];\\n        return (double)totDur/cnt;\\n    }\\n    \\nprivate:\\n    unordered_map<int, pair<string, int>> m;  // id->{station,time}\\n    unordered_map<string, pair<int, int>> stats;//from_to->{totDur, cnt}\\n};\\n```\n```\\nclass UndergroundSystem(object):\\n\\n    def __init__(self):\\n        self.checkinDict = {}\\n        self.stationPairDict = {}\\n\\n    def checkIn(self, id, stationName, t):        \\n        self.checkinDict[id] = (stationName, t)\\n\\n    def checkOut(self, id, stationName, t):\\n        #preStationName, preT = self.checkinDict[id]\\n        preStationName, preT = self.checkinDict.pop(id) #better since no need to keep it \\n        (totalTime, count) = self.stationPairDict.get((preStationName, stationName), (0,0))\\n        self.stationPairDict[(preStationName, stationName)] = (totalTime + t - preT, count+1)        \\n\\n    def getAverageTime(self, startStation, endStation):        \\n        (totalTime, count) = self.stationPairDict[(startStation, endStation)]\\n        return float(totalTime)/count\\n```\n```\\nclass UndergroundSystem(object):\\n\\n    def __init__(self):\\n        self.checkinDict = {}\\n        #self.stationPairDict = {}\\n        self.stationPairDict=collections.defaultdict(lambda:(0,0))\\n\\n    def checkIn(self, id, stationName, t):        \\n        self.checkinDict[id] = (stationName, t)\\n\\n    def checkOut(self, id, stationName, t):\\n        #preStationName, preT = self.checkinDict[id]\\n        preStationName, preT = self.checkinDict.pop(id) #better since no need to keep it \\n        #(totalTime, count) = self.stationPairDict.get((preStationName, stationName), (0,0))\\n        (totalTime, count) = self.stationPairDict[(preStationName, stationName)]\\n        self.stationPairDict[(preStationName, stationName)] = (totalTime + t - preT, count+1)        \\n\\n    def getAverageTime(self, startStation, endStation):        \\n        (totalTime, count) = self.stationPairDict[(startStation, endStation)]\\n        return float(totalTime)/count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556131,
                "title": "c-100-100-two-hashmaps-and-pre-computing-of-division",
                "content": "Proof\\n-\\n![image](https://assets.leetcode.com/users/laprade/image_1585527965.png)\\n\\nThought Process\\n-\\nThe only thing we need to return is the average time. Since there could be an unlimited number of calls to this function, we don\\'t want to have to divide every time it\\'s called in order to computer the average. Additionally, if there is a very large number of trips, we won\\'t overflow. We save all current averages in a hash map.\\nWe also need to track the currently pending trips along with their start times in another hash map.\\nAll computation is done when a trip is closed out, which we know happens exactly once. We need to keep the number of trips in the first hash map so that we can properly divide and computer the average.\\n\\nAlgorithm\\n-\\n```\\npublic class UndergroundSystem {\\n    \\n    public void CheckIn(int id, string stationName, int t) {\\n        currentTrips[id] = (stationName, t);\\n    }\\n    \\n    public void CheckOut(int id, string endStation, int endTime) {\\n        var (startStation, startTime) = currentTrips[id];\\n        var time = endTime - startTime;\\n        var key = (startStation, endStation);\\n        if (averageTimes.ContainsKey(key)) {\\n            var (average, trips) = averageTimes[key];\\n            averageTimes[key] = ((average*trips+time)/(trips+1),trips+1);\\n        } else {\\n            averageTimes[key] = (time, 1);\\n        }\\n    }\\n    \\n    public double GetAverageTime(string startStation, string endStation) {\\n        return averageTimes[(startStation,endStation)].Average;\\n    }\\n    \\n    private Dictionary<int, (string Station, int Time)> currentTrips = new Dictionary<int, (string, int)>();\\n    private Dictionary<(string, string), (double Average, int)> averageTimes = new Dictionary<(string, string),(double,int)>();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class UndergroundSystem {\\n    \\n    public void CheckIn(int id, string stationName, int t) {\\n        currentTrips[id] = (stationName, t);\\n    }\\n    \\n    public void CheckOut(int id, string endStation, int endTime) {\\n        var (startStation, startTime) = currentTrips[id];\\n        var time = endTime - startTime;\\n        var key = (startStation, endStation);\\n        if (averageTimes.ContainsKey(key)) {\\n            var (average, trips) = averageTimes[key];\\n            averageTimes[key] = ((average*trips+time)/(trips+1),trips+1);\\n        } else {\\n            averageTimes[key] = (time, 1);\\n        }\\n    }\\n    \\n    public double GetAverageTime(string startStation, string endStation) {\\n        return averageTimes[(startStation,endStation)].Average;\\n    }\\n    \\n    private Dictionary<int, (string Station, int Time)> currentTrips = new Dictionary<int, (string, int)>();\\n    private Dictionary<(string, string), (double Average, int)> averageTimes = new Dictionary<(string, string),(double,int)>();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554852,
                "title": "java-hashmap",
                "content": "```\\nclass UndergroundSystem {\\n    Map<Integer, String> us = new HashMap<>();\\n    Map<String, List<Integer>> time = new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        us.put(id, stationName + \"_\" + t);           \\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        String last = us.getOrDefault(id, \"\");\\n        us.remove(id);\\n        if (last.length() == 0) return;\\n        String[] ss = last.split(\"_\");\\n        String prevStation = ss[0];\\n        int t2 = Integer.parseInt(ss[1]);\\n        String key = prevStation + \"_\" + stationName;\\n        time.computeIfAbsent(key, k -> new ArrayList<>()).add(t - t2);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = startStation + \"_\" + endStation;\\n        if (!time.containsKey(key) || time.get(key).size() == 0) return 0.0;\\n        List<Integer> l = time.get(key);\\n        double res = 0.0;\\n        for (int i : l) {\\n            res += ((double) i);\\n        }\\n        return res / ((double) l.size());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n    Map<Integer, String> us = new HashMap<>();\\n    Map<String, List<Integer>> time = new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        us.put(id, stationName + \"_\" + t);           \\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        String last = us.getOrDefault(id, \"\");\\n        us.remove(id);\\n        if (last.length() == 0) return;\\n        String[] ss = last.split(\"_\");\\n        String prevStation = ss[0];\\n        int t2 = Integer.parseInt(ss[1]);\\n        String key = prevStation + \"_\" + stationName;\\n        time.computeIfAbsent(key, k -> new ArrayList<>()).add(t - t2);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = startStation + \"_\" + endStation;\\n        if (!time.containsKey(key) || time.get(key).size() == 0) return 0.0;\\n        List<Integer> l = time.get(key);\\n        double res = 0.0;\\n        for (int i : l) {\\n            res += ((double) i);\\n        }\\n        return res / ((double) l.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639419,
                "title": "c",
                "content": "# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n        // id -> {station name,time}\\n        unordered_map<int,pair<string,int>>checkInStation; \\n\\n        // Route -> {total time,count}\\n        unordered_map<string,pair<int,int>> checkOutStation;\\n\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n          checkInStation[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n         \\n          auto cIn = checkInStation[id];\\n           checkInStation.erase(id);\\n\\n           string route = cIn.first + \"_\" + stationName;\\n\\n           checkOutStation[route].first += t - cIn.second;\\n           checkOutStation[route].second += 1;  \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n          \\n           string route  = startStation + \"_\" + endStation;\\n           auto time = checkOutStation[route];\\n\\n        return (double)time.first/time.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n        // id -> {station name,time}\\n        unordered_map<int,pair<string,int>>checkInStation; \\n\\n        // Route -> {total time,count}\\n        unordered_map<string,pair<int,int>> checkOutStation;\\n\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n          checkInStation[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n         \\n          auto cIn = checkInStation[id];\\n           checkInStation.erase(id);\\n\\n           string route = cIn.first + \"_\" + stationName;\\n\\n           checkOutStation[route].first += t - cIn.second;\\n           checkOutStation[route].second += 1;  \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n          \\n           string route  = startStation + \"_\" + endStation;\\n           auto time = checkOutStation[route];\\n\\n        return (double)time.first/time.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581483,
                "title": "video-solution-with-hints-java",
                "content": "# Explanation:\\n\\nhttps://www.youtube.com/watch?v=3r1G7CgYWfs\\n\\n# Complexity:\\n- Time complexity: $$O(1)$$ for all\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(P+S^2)$$ where $$S$$ is the number of stations on the network, and $$P$$ is the number of passengers making a journey concurrently during peak time.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` Java []\\nclass UndergroundSystem {\\n    Map<Integer, Pair<String, Integer>> checkInMap;\\n    Map<String, Pair<Integer, Integer>> travelMap;\\n    public UndergroundSystem() {\\n        checkInMap = new HashMap<>();\\n        travelMap = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkInMap.put(id, new Pair(stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Pair p = checkInMap.remove(id);\\n        String startStation = (String) p.getKey();\\n        int startTime = (Integer) p.getValue();\\n\\n        String routeKey = stationKey(startStation, stationName); // route = travelMapKey\\n\\n        int totalTime = 0;\\n        int travels = 0;\\n        \\n        Pair timeTravelPair = travelMap.getOrDefault(routeKey, new Pair(totalTime, travels));\\n\\n        totalTime = (Integer) timeTravelPair.getKey();\\n        totalTime += (t-startTime);\\n        travels = (Integer) timeTravelPair.getValue() + 1;\\n\\n        travelMap.put(routeKey, new Pair(totalTime, travels));\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String routeKey = stationKey(startStation, endStation);\\n\\n        Pair timeTravelPair = travelMap.get(routeKey);\\n\\n        double time = (Integer) timeTravelPair.getKey();\\n        int travels = (Integer) timeTravelPair.getValue();\\n\\n        return time/(1.0*travels);\\n    }\\n\\n    private String stationKey(String startStation, String endStation) {\\n        return startStation + \"->\" + endStation;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "``` Java []\\nclass UndergroundSystem {\\n    Map<Integer, Pair<String, Integer>> checkInMap;\\n    Map<String, Pair<Integer, Integer>> travelMap;\\n    public UndergroundSystem() {\\n        checkInMap = new HashMap<>();\\n        travelMap = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkInMap.put(id, new Pair(stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Pair p = checkInMap.remove(id);\\n        String startStation = (String) p.getKey();\\n        int startTime = (Integer) p.getValue();\\n\\n        String routeKey = stationKey(startStation, stationName); // route = travelMapKey\\n\\n        int totalTime = 0;\\n        int travels = 0;\\n        \\n        Pair timeTravelPair = travelMap.getOrDefault(routeKey, new Pair(totalTime, travels));\\n\\n        totalTime = (Integer) timeTravelPair.getKey();\\n        totalTime += (t-startTime);\\n        travels = (Integer) timeTravelPair.getValue() + 1;\\n\\n        travelMap.put(routeKey, new Pair(totalTime, travels));\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String routeKey = stationKey(startStation, endStation);\\n\\n        Pair timeTravelPair = travelMap.get(routeKey);\\n\\n        double time = (Integer) timeTravelPair.getKey();\\n        int travels = (Integer) timeTravelPair.getValue();\\n\\n        return time/(1.0*travels);\\n    }\\n\\n    private String stationKey(String startStation, String endStation) {\\n        return startStation + \"->\" + endStation;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580430,
                "title": "easy-c-python-solutions-with-unordered-map-dict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe concept behind this code is straightforward. Each time the checkIn and checkOut methods are called, the relevant tables are updated with the corresponding data. Hash tables are used to efficiently store the check-in and travel time information.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**main data members:**\\n\\n**unordered_map<int, pair<string, int>> in:**\\nThis map stores the check-in information for each traveler identified by their id. The pair consists of the starting station name (string) and the check-in time (int).\\n\\n**unordered_map<string, unordered_map<string, vector<int>>> time:** \\nThis nested map stores the travel time information between stations. The outer map uses the starting station name as the key, and the inner map uses the ending station name as the key. The value is a vector of integers representing the travel times between the corresponding stations.\\n\\n# Extra test cases offered by @almostmonday:\\n```\\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code passes all extra test cases, but not every successfully submit code does\\n```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int>> in;\\n    unordered_map<string,unordered_map<string, vector<int>>> time;\\npublic:   \\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        in[id]={stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& [startStation, t0]=in[id];\\n        time[startStation][stationName].push_back(t-t0);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double av=0;\\n        for(auto t: time[startStation][endStation]) \\n            av+=t;\\n        av/=time[startStation][endStation].size();\\n        return av;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```\\n# Code with comments\\n```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int>> in;    \\n// Maps passenger ID to their check-in station name and time\\n\\n    unordered_map<string,unordered_map<string, vector<int>>> time;\\n// Maps start station to end station and a vector of travel times\\n\\npublic:   \\n    UndergroundSystem() {\\n        // Constructor does not perform any specific actions\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        in[id]={stationName, t};    \\n// Store check-in station name and time for the passenger ID\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& [startStation, t0]=in[id];    \\n// Retrieve check-in station name and time for the passenger ID\\n\\n        time[startStation][stationName].push_back(t-t0);    \\n// Calculate travel time and add it to the vector of travel times for the start and end stations\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double av=0;    // Variable to store the total travel time\\n        for(auto t: time[startStation][endStation]) \\n            av+=t;    // Sum up all travel times between the start and end stations\\n        av/=time[startStation][endStation].size();    // Calculate the average travel time\\n        return av;    // Return the average travel time\\n    }\\n};\\n\\n```\\n# Python solution\\n```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.checkin = {}\\n        self.time = defaultdict(lambda: defaultdict(list))\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkin[id]=(stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        startStation, t0 = self.checkin[id]\\n        self.time[startStation][stationName].append(t - t0)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        t = self.time[startStation][endStation]\\n        av = sum(t) / len(t) \\n        return av\\n        \\n\\n\\n# Your UndergroundSystem object will be instantiated and called as such:\\n# obj = UndergroundSystem()\\n# obj.checkIn(id,stationName,t)\\n# obj.checkOut(id,stationName,t)\\n# param_3 = obj.getAverageTime(startStation,endStation)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\\n```\n```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int>> in;\\n    unordered_map<string,unordered_map<string, vector<int>>> time;\\npublic:   \\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        in[id]={stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& [startStation, t0]=in[id];\\n        time[startStation][stationName].push_back(t-t0);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double av=0;\\n        for(auto t: time[startStation][endStation]) \\n            av+=t;\\n        av/=time[startStation][endStation].size();\\n        return av;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```\n```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int>> in;    \\n// Maps passenger ID to their check-in station name and time\\n\\n    unordered_map<string,unordered_map<string, vector<int>>> time;\\n// Maps start station to end station and a vector of travel times\\n\\npublic:   \\n    UndergroundSystem() {\\n        // Constructor does not perform any specific actions\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        in[id]={stationName, t};    \\n// Store check-in station name and time for the passenger ID\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& [startStation, t0]=in[id];    \\n// Retrieve check-in station name and time for the passenger ID\\n\\n        time[startStation][stationName].push_back(t-t0);    \\n// Calculate travel time and add it to the vector of travel times for the start and end stations\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double av=0;    // Variable to store the total travel time\\n        for(auto t: time[startStation][endStation]) \\n            av+=t;    // Sum up all travel times between the start and end stations\\n        av/=time[startStation][endStation].size();    // Calculate the average travel time\\n        return av;    // Return the average travel time\\n    }\\n};\\n\\n```\n```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.checkin = {}\\n        self.time = defaultdict(lambda: defaultdict(list))\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkin[id]=(stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        startStation, t0 = self.checkin[id]\\n        self.time[startStation][stationName].append(t - t0)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        t = self.time[startStation][endStation]\\n        av = sum(t) / len(t) \\n        return av\\n        \\n\\n\\n# Your UndergroundSystem object will be instantiated and called as such:\\n# obj = UndergroundSystem()\\n# obj.checkIn(id,stationName,t)\\n# obj.checkOut(id,stationName,t)\\n# param_3 = obj.getAverageTime(startStation,endStation)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943874,
                "title": "python-beats-90",
                "content": "\\n```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.openTrips = {} #id: station, time\\n        self.completedtrips = {} # station: [trip, trip]\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        #O(1)\\n        self.openTrips[id] = (stationName, t) \\n        \\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        #O(1)\\n        startStation, timeStart = self.openTrips[id]\\n        del self.openTrips[id]\\n\\n        if startStation + \"-\"+ stationName in self.completedtrips:\\n            self.completedtrips[startStation + \"-\"+ stationName].append(t-timeStart)\\n        else:\\n            self.completedtrips[startStation + \"-\"+ stationName] = [t-timeStart]\\n        \\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        #O(N)\\n        trips = self.completedtrips[startStation + \"-\"+ endStation]\\n        return sum(trips)/len(trips)\\n        \\n\\n\\n# Your UndergroundSystem object will be instantiated and called as such:\\n# obj = UndergroundSystem()\\n# obj.checkIn(id,stationName,t)\\n# obj.checkOut(id,stationName,t)\\n# param_3 = obj.getAverageTime(startStation,endStation)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.openTrips = {} #id: station, time\\n        self.completedtrips = {} # station: [trip, trip]\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        #O(1)\\n        self.openTrips[id] = (stationName, t) \\n        \\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        #O(1)\\n        startStation, timeStart = self.openTrips[id]\\n        del self.openTrips[id]\\n\\n        if startStation + \"-\"+ stationName in self.completedtrips:\\n            self.completedtrips[startStation + \"-\"+ stationName].append(t-timeStart)\\n        else:\\n            self.completedtrips[startStation + \"-\"+ stationName] = [t-timeStart]\\n        \\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        #O(N)\\n        trips = self.completedtrips[startStation + \"-\"+ endStation]\\n        return sum(trips)/len(trips)\\n        \\n\\n\\n# Your UndergroundSystem object will be instantiated and called as such:\\n# obj = UndergroundSystem()\\n# obj.checkIn(id,stationName,t)\\n# obj.checkOut(id,stationName,t)\\n# param_3 = obj.getAverageTime(startStation,endStation)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516716,
                "title": "c-o-1",
                "content": "I\\'m using a map for O(1) averages -> map to maintain fromStation and toStation with pair of their sum and count\\n```\\nclass UndergroundSystem {\\npublic:\\n    struct User{\\n        string stationName;\\n        int time;\\n    };\\n    unordered_map<int, User> mp;\\n    // to map fromStation and toStation with pair of their sum and count\\n    unordered_map<string, unordered_map<string, pair<int, int>>> stns;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        User u;\\n        u.stationName = stationName;\\n        u.time = t;\\n        mp[id] = u;\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string fromStation = mp[id].stationName;\\n        int fromTime = mp[id].time;\\n        auto it = stns.find(fromStation);\\n\\t\\t// check if entry is to be added first time to avoid runtime errors\\n        if(it == stns.end()){\\n            unordered_map<string, pair<int, int>> tmp;\\n            tmp[stationName] = {t-fromTime, 1};\\n            stns.insert({fromStation, tmp});\\n        } else {\\n            it->second[stationName].first += t-fromTime;\\n            it->second[stationName].second ++;\\n        }\\n        // string from = it->second.find()->first;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return stns[startStation][endStation].first / (double) stns[startStation][endStation].second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    struct User{\\n        string stationName;\\n        int time;\\n    };\\n    unordered_map<int, User> mp;\\n    // to map fromStation and toStation with pair of their sum and count\\n    unordered_map<string, unordered_map<string, pair<int, int>>> stns;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        User u;\\n        u.stationName = stationName;\\n        u.time = t;\\n        mp[id] = u;\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string fromStation = mp[id].stationName;\\n        int fromTime = mp[id].time;\\n        auto it = stns.find(fromStation);\\n\\t\\t// check if entry is to be added first time to avoid runtime errors\\n        if(it == stns.end()){\\n            unordered_map<string, pair<int, int>> tmp;\\n            tmp[stationName] = {t-fromTime, 1};\\n            stns.insert({fromStation, tmp});\\n        } else {\\n            it->second[stationName].first += t-fromTime;\\n            it->second[stationName].second ++;\\n        }\\n        // string from = it->second.find()->first;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return stns[startStation][endStation].first / (double) stns[startStation][endStation].second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053797,
                "title": "probably-the-better-way-to-do-for-interviews-using-ood",
                "content": "I saw this question was sometimes asked in LLD rounds. Where you code extensibility is very important. \\n\\n```\\nclass Event:\\n    def __init__(self,id, stationName, time):\\n        self.id = id\\n        self.stationName = stationName\\n        self.time = time\\n        \\nclass Average: \\n    def __init__(self, total, count):\\n        self.total = total\\n        self.count = count\\n        \\n    def updateAverage(self, diff):\\n        self.count += 1\\n        self.total += diff\\n        \\n    def getAverage(self):\\n        return self.total / self.count\\n        \\n\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.arrivals = {}\\n        self.averages = {}\\n        \\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.arrivals[id] = Event(id, stationName, t)\\n        \\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        arrivalEvent = self.arrivals.get(id)\\n        self.arrivals.pop(id)\\n        \\n        diff = t - arrivalEvent.time\\n        \\n        key = (arrivalEvent.stationName, stationName)\\n        \\n        average = self.averages[key] if key in self.averages else Average(0, 0)\\n        average.updateAverage(diff)\\n        \\n        self.averages[key] = average\\n        \\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        key = (startStation, endStation)\\n        \\n        return self.averages.get(key).getAverage()\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Event:\\n    def __init__(self,id, stationName, time):\\n        self.id = id\\n        self.stationName = stationName\\n        self.time = time\\n        \\nclass Average: \\n    def __init__(self, total, count):\\n        self.total = total\\n        self.count = count\\n        \\n    def updateAverage(self, diff):\\n        self.count += 1\\n        self.total += diff\\n        \\n    def getAverage(self):\\n        return self.total / self.count\\n        \\n\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.arrivals = {}\\n        self.averages = {}\\n        \\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.arrivals[id] = Event(id, stationName, t)\\n        \\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        arrivalEvent = self.arrivals.get(id)\\n        self.arrivals.pop(id)\\n        \\n        diff = t - arrivalEvent.time\\n        \\n        key = (arrivalEvent.stationName, stationName)\\n        \\n        average = self.averages[key] if key in self.averages else Average(0, 0)\\n        average.updateAverage(diff)\\n        \\n        self.averages[key] = average\\n        \\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        key = (startStation, endStation)\\n        \\n        return self.averages.get(key).getAverage()\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979266,
                "title": "c-o-1-small-and-concise-easy-to-understand",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    //hash-map to store the checkin details\\n\\t//map<startstation,time>\\n    map<int,pair<string,int>> in;\\n\\n\\t//hashmap to store the total sum and count of travel between two stations\\n\\t//map<<endstation,startstation><totaltime(sum),count>>\\n    map<pair<string,string>,pair<int,int>> avg;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n\\t//update the checkin\\n        in[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n\\t//update the total time(sum) and count of travel\\n        avg[{stationName,in[id].first}]={avg[{stationName,in[id].first}].first+t-in[id].second,avg[{stationName,in[id].first}].second+1};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n\\t//return the average\\n        return double(double(avg[{endStation,startStation}].first)/double(avg[{endStation,startStation}].second));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    //hash-map to store the checkin details\\n\\t//map<startstation,time>\\n    map<int,pair<string,int>> in;\\n\\n\\t//hashmap to store the total sum and count of travel between two stations\\n\\t//map<<endstation,startstation><totaltime(sum),count>>\\n    map<pair<string,string>,pair<int,int>> avg;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n\\t//update the checkin\\n        in[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n\\t//update the total time(sum) and count of travel\\n        avg[{stationName,in[id].first}]={avg[{stationName,in[id].first}].first+t-in[id].second,avg[{stationName,in[id].first}].second+1};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n\\t//return the average\\n        return double(double(avg[{endStation,startStation}].first)/double(avg[{endStation,startStation}].second));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978623,
                "title": "c-daily-leetcoding-challenge-april-day-24",
                "content": "```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int>> currCustomer;\\n    unordered_map<string, unordered_map<string, pair<int, int>>> trips;\\npublic:\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        currCustomer[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int duration = t - currCustomer[id].second;\\n        trips[currCustomer[id].first][stationName].first += duration;\\n        trips[currCustomer[id].first][stationName].second++;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double averageTime = (double)trips[startStation][endStation].first / trips[startStation][endStation].second ;\\n        return averageTime;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int>> currCustomer;\\n    unordered_map<string, unordered_map<string, pair<int, int>>> trips;\\npublic:\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        currCustomer[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int duration = t - currCustomer[id].second;\\n        trips[currCustomer[id].first][stationName].first += duration;\\n        trips[currCustomer[id].first][stationName].second++;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double averageTime = (double)trips[startStation][endStation].first / trips[startStation][endStation].second ;\\n        return averageTime;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978331,
                "title": "javascript-map-solution-o-1-time",
                "content": "```\\n\\nvar UndergroundSystem = function() {\\n    this.map = {}\\n    this.avgTime = {}\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkIn = function(id, stationName, t) {\\n    const { map } = this\\n    map[id] = {startStation:stationName , t: t}\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkOut = function(id, stationName, t) {\\n      const { map, avgTime } = this\\n      const last = map[id]\\n      const key = `e:${stationName}+s:${last.startStation}`\\n      if(avgTime[key])\\n        avgTime[key] = { total: avgTime[key].total + t - last.t, count: avgTime[key].count + 1 }\\n      else\\n        avgTime[key] = { total: t - last.t, count: 1}\\n}\\n/** \\n * @param {string} startStation \\n * @param {string} endStation\\n * @return {number}\\n */\\nUndergroundSystem.prototype.getAverageTime = function(startStation, endStation) {\\n  const { avgTime } = this\\n  const key = `e:${endStation}+s:${startStation}`\\n  const { total, count } = avgTime[key]\\n  return total / count\\n};\\n\\n/** \\n * Your UndergroundSystem object will be instantiated and called as such:\\n * var obj = new UndergroundSystem()\\n * obj.checkIn(id,stationName,t)\\n * obj.checkOut(id,stationName,t)\\n * var param_3 = obj.getAverageTime(startStation,endStation)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n\\nvar UndergroundSystem = function() {\\n    this.map = {}\\n    this.avgTime = {}\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkIn = function(id, stationName, t) {\\n    const { map } = this\\n    map[id] = {startStation:stationName , t: t}\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkOut = function(id, stationName, t) {\\n      const { map, avgTime } = this\\n      const last = map[id]\\n      const key = `e:${stationName}+s:${last.startStation}`\\n      if(avgTime[key])\\n        avgTime[key] = { total: avgTime[key].total + t - last.t, count: avgTime[key].count + 1 }\\n      else\\n        avgTime[key] = { total: t - last.t, count: 1}\\n}\\n/** \\n * @param {string} startStation \\n * @param {string} endStation\\n * @return {number}\\n */\\nUndergroundSystem.prototype.getAverageTime = function(startStation, endStation) {\\n  const { avgTime } = this\\n  const key = `e:${endStation}+s:${startStation}`\\n  const { total, count } = avgTime[key]\\n  return total / count\\n};\\n\\n/** \\n * Your UndergroundSystem object will be instantiated and called as such:\\n * var obj = new UndergroundSystem()\\n * obj.checkIn(id,stationName,t)\\n * obj.checkOut(id,stationName,t)\\n * var param_3 = obj.getAverageTime(startStation,endStation)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977554,
                "title": "using-hashmap-c",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map< int,pair<string,int> > lastCheckInStation;\\n    unordered_map< string,unordered_map<string,double> > AverageTime;\\n    unordered_map< string,unordered_map<string,int> > AverageTimeCount;\\n    \\n    UndergroundSystem() {}\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        lastCheckInStation[id]={stationName,t};\\n    }\\n    void checkOut(int id, string stationName, int t) {\\n        string prevStation = lastCheckInStation[id].first;\\n        int prevTime = lastCheckInStation[id].second;\\n        AverageTimeCount[prevStation][stationName]++;\\n        AverageTime[prevStation][stationName] += (t - prevTime) ;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        return AverageTime[startStation][endStation] / AverageTimeCount[startStation][endStation] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map< int,pair<string,int> > lastCheckInStation;\\n    unordered_map< string,unordered_map<string,double> > AverageTime;\\n    unordered_map< string,unordered_map<string,int> > AverageTimeCount;\\n    \\n    UndergroundSystem() {}\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        lastCheckInStation[id]={stationName,t};\\n    }\\n    void checkOut(int id, string stationName, int t) {\\n        string prevStation = lastCheckInStation[id].first;\\n        int prevTime = lastCheckInStation[id].second;\\n        AverageTimeCount[prevStation][stationName]++;\\n        AverageTime[prevStation][stationName] += (t - prevTime) ;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        return AverageTime[startStation][endStation] / AverageTimeCount[startStation][endStation] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586967,
                "title": "c-2-hashmaps-pair",
                "content": "```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int>>hm;     /* customer, station in and in time */\\n    unordered_map<string, pair<double, int>>mp;  /* Station out, current average, and trip number */\\npublic:\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        hm[id] = make_pair(stationName, t);\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        mp[hm[id].first+stationName].first = (mp[hm[id].first+stationName].first * mp[hm[id].first+stationName].second\\n                                              + (t - hm[id].second))/ (mp[hm[id].first+stationName].second +1);\\n        mp[hm[id].first+stationName].second++;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string str = startStation+endStation;\\n        return mp[str].first;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int>>hm;     /* customer, station in and in time */\\n    unordered_map<string, pair<double, int>>mp;  /* Station out, current average, and trip number */\\npublic:\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        hm[id] = make_pair(stationName, t);\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        mp[hm[id].first+stationName].first = (mp[hm[id].first+stationName].first * mp[hm[id].first+stationName].second\\n                                              + (t - hm[id].second))/ (mp[hm[id].first+stationName].second +1);\\n        mp[hm[id].first+stationName].second++;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string str = startStation+endStation;\\n        return mp[str].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562122,
                "title": "java-two-hash-maps-explained-beats-99",
                "content": "Create two maps - id->Checkin object (id, from, time) and checkoutMap -> fromStation->Map<toStation, [sum_time,num_of_customers]. First one used to save checkin event info so later we can lookup initial time per customer in O(1). Second map used on check out event and has fromStation as key and another map as a value. That nested map has toStation as key and an array of doubles as a value. That array has two elements - sum of all time spend by customers and number of customers. \\n\\nOn getAverage request we use only second map, lookup by fromStation the nested map, then by toStation the array and return time/num_of_customers value.\\n\\nFor the first map it make sense to use custom object as a value. That object has id, time (checkin) and fromStation name. \\n\\n```\\npublic class UndergroundSystem {\\n  \\n  Map<Integer, CheckIn> custIdCheckIn = new HashMap();\\n\\n  Map<String, Map<String, double[]>> stationCheckedOut = new HashMap();\\n\\n  public UndergroundSystem() {\\n  }\\n\\n  public void checkIn(int id, String stationName, int t) {\\n    custIdCheckIn.put(id, new CheckIn(stationName, t));\\n  }\\n\\n  public void checkOut(int id, String stationName, int t) {\\n    CheckIn checkin = custIdCheckIn.remove(id);\\n\\n    Map<String, double[]> toMap;\\n    if (!stationCheckedOut.containsKey(checkin.from)) {\\n      toMap = new HashMap();\\n      stationCheckedOut.put(checkin.from, toMap);\\n    } else\\n      toMap = stationCheckedOut.get(checkin.from);\\n\\n    double[] nums;\\n    if (!toMap.containsKey(stationName)) {\\n      nums = new double[] { 0.0, 0.0};\\n      toMap.put(stationName,  nums);\\n    } else {\\n      nums = toMap.get(stationName);\\n    }\\n\\n    nums[1] += t - checkin.time;\\n    nums[0] += 1.0;\\n  }\\n\\n  public double getAverageTime(String startStation, String endStation) {\\n    Map<String, double[]> toMap = stationCheckedOut.get(startStation);\\n    double[] pair = toMap.get(endStation);\\n    return (double)pair[1]/pair[0];\\n  }\\n}\\n\\nclass CheckIn {\\n  String from;\\n  int time;\\n\\n  CheckIn(String from, int time) {\\n    this.from = from;\\n    this.time = time;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class UndergroundSystem {\\n  \\n  Map<Integer, CheckIn> custIdCheckIn = new HashMap();\\n\\n  Map<String, Map<String, double[]>> stationCheckedOut = new HashMap();\\n\\n  public UndergroundSystem() {\\n  }\\n\\n  public void checkIn(int id, String stationName, int t) {\\n    custIdCheckIn.put(id, new CheckIn(stationName, t));\\n  }\\n\\n  public void checkOut(int id, String stationName, int t) {\\n    CheckIn checkin = custIdCheckIn.remove(id);\\n\\n    Map<String, double[]> toMap;\\n    if (!stationCheckedOut.containsKey(checkin.from)) {\\n      toMap = new HashMap();\\n      stationCheckedOut.put(checkin.from, toMap);\\n    } else\\n      toMap = stationCheckedOut.get(checkin.from);\\n\\n    double[] nums;\\n    if (!toMap.containsKey(stationName)) {\\n      nums = new double[] { 0.0, 0.0};\\n      toMap.put(stationName,  nums);\\n    } else {\\n      nums = toMap.get(stationName);\\n    }\\n\\n    nums[1] += t - checkin.time;\\n    nums[0] += 1.0;\\n  }\\n\\n  public double getAverageTime(String startStation, String endStation) {\\n    Map<String, double[]> toMap = stationCheckedOut.get(startStation);\\n    double[] pair = toMap.get(endStation);\\n    return (double)pair[1]/pair[0];\\n  }\\n}\\n\\nclass CheckIn {\\n  String from;\\n  int time;\\n\\n  CheckIn(String from, int time) {\\n    this.from = from;\\n    this.time = time;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555135,
                "title": "c-solution",
                "content": "```\\npublic class UndergroundSystem \\n{\\n    Dictionary<string, List<int>> result;\\n    Dictionary<int, CheckIn> checkIns;\\n\\n    public UndergroundSystem()\\n    {\\n        result = new Dictionary<string, List<int>>();\\n        checkIns = new Dictionary<int, CheckIn>();\\n    }\\n    \\n    public void CheckIn(int id, string stationName, int t) \\n    {\\n        checkIns[id] = new CheckIn() {stationName = stationName, time = t};\\n    }\\n    \\n    public void CheckOut(int id, string stationName, int t) \\n    {\\n        var checkInInfo = checkIns[id];\\n        string key = checkInInfo.stationName + \":\" + stationName;\\n        int duration = t - checkInInfo.time;\\n        if(!result.ContainsKey(key))\\n            result[key] = new List<int>();\\n        result[key].Add(duration);\\n        checkIns.Remove(id);\\n    }\\n    \\n    public double GetAverageTime(string startStation, string endStation) \\n    {\\n        string key = startStation + \":\" + endStation;\\n        return (double) (result[key].Sum()) / (double) (result[key].Count); \\n        \\n    }\\n}\\n\\npublic class CheckIn\\n{\\n    public string stationName;\\n    public int time;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class UndergroundSystem \\n{\\n    Dictionary<string, List<int>> result;\\n    Dictionary<int, CheckIn> checkIns;\\n\\n    public UndergroundSystem()\\n    {\\n        result = new Dictionary<string, List<int>>();\\n        checkIns = new Dictionary<int, CheckIn>();\\n    }\\n    \\n    public void CheckIn(int id, string stationName, int t) \\n    {\\n        checkIns[id] = new CheckIn() {stationName = stationName, time = t};\\n    }\\n    \\n    public void CheckOut(int id, string stationName, int t) \\n    {\\n        var checkInInfo = checkIns[id];\\n        string key = checkInInfo.stationName + \":\" + stationName;\\n        int duration = t - checkInInfo.time;\\n        if(!result.ContainsKey(key))\\n            result[key] = new List<int>();\\n        result[key].Add(duration);\\n        checkIns.Remove(id);\\n    }\\n    \\n    public double GetAverageTime(string startStation, string endStation) \\n    {\\n        string key = startStation + \":\" + endStation;\\n        return (double) (result[key].Sum()) / (double) (result[key].Count); \\n        \\n    }\\n}\\n\\npublic class CheckIn\\n{\\n    public string stationName;\\n    public int time;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554805,
                "title": "javascript-and-c-solutions",
                "content": "**Solution # 1 - Synopsis:**\\n\\nUse hash tables to store check-in information per `id` as `notes`, and upon check-out, create \"edges\" from source-station `s1` to destination-station `s2` which contain an array of time deltas (ie. check-out time `t2` minus check-in time `t1`).  Compute the average time by accumulating the time deltas from `s1` to `s2` and dividing that sum by the length of the array of time deltas.\\n\\n**Note:** this solution is inefficient, since the average is calculated on demand in O(K) time, where K is the amount of time entries per edge.  See the **optimized solution #2 below**.\\n\\n*Javascript*\\n```\\nclass UndergroundSystem {\\n    constructor() {\\n        this.notes = {}; // { id: { s1: source-station, t1: check-in time }}\\n        this.edges = {}; // { source: { destination: { time deltas }}}\\n    }\\n    checkIn(id, s1, t1) {\\n        this.notes[id] = { s1: s1, t1: t1 };\\n    }\\n    checkOut(id, s2, t2) {\\n        let [notes, edges] = [this.notes, this.edges];\\n        let [s1, t1] = [notes[id].s1, notes[id].t1];\\n        if (!edges[s1]) edges[s1] = {};\\n        if (!edges[s1][s2]) edges[s1][s2] = [];\\n        edges[s1][s2].push(t2 - t1); // add edge (s1 \\uD83D\\uDC49 s2) with time delta abs(t1 -t2) \\u23F0\\n    }\\n    getAverageTime(s1, s2) {\\n        return this.edges[s1][s2].reduce((a, b) => a + b) / this.edges[s1][s2].length;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass UndergroundSystem {\\npublic:\\n    void checkIn(int id, string s1, int t1) {\\n        notes[id] = {s1, t1};\\n    }\\n    void checkOut(int id, string s2, int t2) {\\n        auto [s1, t1] = notes[id];\\n        edges[s1][s2].push_back(t2 - t1); // add edge (s1 \\uD83D\\uDC49 s2) with time delta abs(t1 -t2) \\u23F0\\n    }\\n    double getAverageTime(string s1, string s2) {\\n        return accumulate(edges[s1][s2].begin(), edges[s1][s2].end(), 0.0) / edges[s1][s2].size();\\n    }\\nprivate:\\n    using Note = tuple<string, int>;\\n    using Notes = unordered_map<int, Note>;\\n    Notes notes; // { id: { source-station, check-in time }}\\n    using Edges = unordered_map<string, unordered_map<string, vector<int>>>;\\n    Edges edges; // { source: { destination: { time deltas }}}\\n};\\n```\\n\\n---\\n\\n**Solution #2 - Synopsis:**\\n\\nSame general idea as above, but optimized to for each \"edge\" to store the `total` time and count `cnt` of time entries in order to calculate the average time in O(1).\\n\\n*Javascript*\\n```\\nclass UndergroundSystem {\\n    constructor() {\\n        this.notes = {}; // { id: { s1: source-station, t1: check-in time }}\\n        this.edges = {}; // { source: { destination: { total time, count of time entries }}}\\n    }\\n    checkIn(id, s1, t1) {\\n        this.notes[id] = { s1: s1, t1: t1 };\\n    }\\n    checkOut(id, s2, t2) {\\n        let [notes, edges] = [this.notes, this.edges];\\n        let [s1, t1] = [notes[id].s1, notes[id].t1];\\n        if (!edges[s1]) edges[s1] = {};\\n        if (!edges[s1][s2]) edges[s1][s2] = { total: 0, cnt: 0 };\\n        let edge = edges[s1][s2]; // update edge (s1 \\uD83D\\uDC49 s2) with time delta abs(t1 -t2) \\u23F0\\n        edge.total += (t2 - t1), ++edge.cnt;\\n    }\\n    getAverageTime(s1, s2) {\\n        let edge = this.edges[s1][s2];\\n        return edge.total / edge.cnt;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass UndergroundSystem {\\npublic:\\n    void checkIn(int id, string s1, int t1) {\\n        notes[id] = {s1, t1};\\n    }\\n    void checkOut(int id, string s2, int t2) {\\n        auto [s1, t1] = notes[id];\\n        auto& [total, cnt] = edges[s1][s2]; // update edge (s1 \\uD83D\\uDC49 s2) to include time delta abs(t1 -t2) \\u23F0\\n        total += (t2 - t1), ++cnt;\\n    }\\n    double getAverageTime(string s1, string s2) {\\n        auto [total, cnt] = edges[s1][s2];\\n        return total / cnt;\\n    }\\nprivate:\\n    using Note = tuple<string, int>;\\n    using Notes = unordered_map<int, Note>;\\n    Notes notes; // { id: { source-station, check-in time }}\\n    using Edge = tuple<double, int>;\\n    using Edges = unordered_map<string, unordered_map<string, Edge>>;\\n    Edges edges; // { source: { destination: { total time, count of time entries }}}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n    constructor() {\\n        this.notes = {}; // { id: { s1: source-station, t1: check-in time }}\\n        this.edges = {}; // { source: { destination: { time deltas }}}\\n    }\\n    checkIn(id, s1, t1) {\\n        this.notes[id] = { s1: s1, t1: t1 };\\n    }\\n    checkOut(id, s2, t2) {\\n        let [notes, edges] = [this.notes, this.edges];\\n        let [s1, t1] = [notes[id].s1, notes[id].t1];\\n        if (!edges[s1]) edges[s1] = {};\\n        if (!edges[s1][s2]) edges[s1][s2] = [];\\n        edges[s1][s2].push(t2 - t1); // add edge (s1 \\uD83D\\uDC49 s2) with time delta abs(t1 -t2) \\u23F0\\n    }\\n    getAverageTime(s1, s2) {\\n        return this.edges[s1][s2].reduce((a, b) => a + b) / this.edges[s1][s2].length;\\n    }\\n}\\n```\n```\\nclass UndergroundSystem {\\npublic:\\n    void checkIn(int id, string s1, int t1) {\\n        notes[id] = {s1, t1};\\n    }\\n    void checkOut(int id, string s2, int t2) {\\n        auto [s1, t1] = notes[id];\\n        edges[s1][s2].push_back(t2 - t1); // add edge (s1 \\uD83D\\uDC49 s2) with time delta abs(t1 -t2) \\u23F0\\n    }\\n    double getAverageTime(string s1, string s2) {\\n        return accumulate(edges[s1][s2].begin(), edges[s1][s2].end(), 0.0) / edges[s1][s2].size();\\n    }\\nprivate:\\n    using Note = tuple<string, int>;\\n    using Notes = unordered_map<int, Note>;\\n    Notes notes; // { id: { source-station, check-in time }}\\n    using Edges = unordered_map<string, unordered_map<string, vector<int>>>;\\n    Edges edges; // { source: { destination: { time deltas }}}\\n};\\n```\n```\\nclass UndergroundSystem {\\n    constructor() {\\n        this.notes = {}; // { id: { s1: source-station, t1: check-in time }}\\n        this.edges = {}; // { source: { destination: { total time, count of time entries }}}\\n    }\\n    checkIn(id, s1, t1) {\\n        this.notes[id] = { s1: s1, t1: t1 };\\n    }\\n    checkOut(id, s2, t2) {\\n        let [notes, edges] = [this.notes, this.edges];\\n        let [s1, t1] = [notes[id].s1, notes[id].t1];\\n        if (!edges[s1]) edges[s1] = {};\\n        if (!edges[s1][s2]) edges[s1][s2] = { total: 0, cnt: 0 };\\n        let edge = edges[s1][s2]; // update edge (s1 \\uD83D\\uDC49 s2) with time delta abs(t1 -t2) \\u23F0\\n        edge.total += (t2 - t1), ++edge.cnt;\\n    }\\n    getAverageTime(s1, s2) {\\n        let edge = this.edges[s1][s2];\\n        return edge.total / edge.cnt;\\n    }\\n}\\n```\n```\\nclass UndergroundSystem {\\npublic:\\n    void checkIn(int id, string s1, int t1) {\\n        notes[id] = {s1, t1};\\n    }\\n    void checkOut(int id, string s2, int t2) {\\n        auto [s1, t1] = notes[id];\\n        auto& [total, cnt] = edges[s1][s2]; // update edge (s1 \\uD83D\\uDC49 s2) to include time delta abs(t1 -t2) \\u23F0\\n        total += (t2 - t1), ++cnt;\\n    }\\n    double getAverageTime(string s1, string s2) {\\n        auto [total, cnt] = edges[s1][s2];\\n        return total / cnt;\\n    }\\nprivate:\\n    using Note = tuple<string, int>;\\n    using Notes = unordered_map<int, Note>;\\n    Notes notes; // { id: { source-station, check-in time }}\\n    using Edge = tuple<double, int>;\\n    using Edges = unordered_map<string, unordered_map<string, Edge>>;\\n    Edges edges; // { source: { destination: { total time, count of time entries }}}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581430,
                "title": "hashtable-cpp-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Use unordered maps for efficient storage and retrieval:** `The code utilizes two unordered maps, mp1 and mp2, to store and manage the data. Unordered maps provide constant-time average complexity for insertion, deletion, and retrieval operations. This choice ensures efficient storage and retrieval of passenger check-in information and average travel times for different routes.`\\n\\n- **Track check-in and check-out times separately:** `The code maintains the check-in information in mp1 using the passenger ID as the key and the station name and check-in time as the value. This separation allows the code to associate a check-out event with the corresponding check-in event by retrieving the check-in information using the passenger ID. By tracking check-in and check-out times separately, the code can calculate the total travel time for each route accurately.`\\n\\n- **Calculate average travel time using accumulated data:** `The code keeps track of the total travel time and the number of trips for each route in mp2. When calculating the average travel time for a specific route, the code retrieves the corresponding total travel time and trip count from mp2 and divides the total travel time by the trip count to obtain the average. This approach allows the code to dynamically update the average travel time as new check-out events occur and provides an accurate representation of the average travel time for each route.`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# **Track Check-In and Check-Out Events:**\\n\\n- Create an unordered map, mp1, to store check-in information with the passenger ID as the key and a pair of the station name and check-in time as the value.\\n- When a passenger checks in, update mp1 by adding the check-in information with the passenger ID as the key.\\n- When a passenger checks out, retrieve the corresponding check-in information using the passenger ID from mp1.\\n\\n# **Calculate Total Travel Time and Trip Count for Each Route:**\\n\\n- Create another unordered map, mp2, to store information about the average travel time for different routes.\\n- Construct the route name by concatenating the start station name, a hyphen, and the end station name.\\n- For each check-out event, update the total travel time and the number of trips for the corresponding route in mp2 by adding the difference between the check-out time and the check-in time to the total time and incrementing the trip count by 1.\\n \\n# **Calculate Average Travel Time for a Specific Route:**\\n\\n- To calculate the average travel time for a specific route, retrieve the total travel time and the number of trips for that route from mp2.\\nDivide the total travel time by the number of trips to obtain the average travel time.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`The time complexity is O(1) for each operation`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`the space complexity is O(N + R) where N is the number of distinct passengers and R is the number of distinct routes encountered.`\\n\\n# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int,pair<string,int>> mp1;\\n    unordered_map<string,pair<double,int>> mp2;\\n    \\n    UndergroundSystem() {\\n\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp1[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto checkIn = mp1[id];\\n        mp1.erase(id);\\n\\n        string routeName = checkIn.first + \"-\" + stationName;\\n        mp2[routeName].first += t-checkIn.second;\\n        mp2[routeName].second+=1;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string routeName = startStation+\"-\"+endStation;\\n        auto& route = mp2[routeName];\\n        return route.first/route.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```\\n![PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/fc96dfee-1f83-4182-81da-a571cf3861cf_1685517775.768538.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int,pair<string,int>> mp1;\\n    unordered_map<string,pair<double,int>> mp2;\\n    \\n    UndergroundSystem() {\\n\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp1[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto checkIn = mp1[id];\\n        mp1.erase(id);\\n\\n        string routeName = checkIn.first + \"-\" + stationName;\\n        mp2[routeName].first += t-checkIn.second;\\n        mp2[routeName].second+=1;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string routeName = startStation+\"-\"+endStation;\\n        auto& route = mp2[routeName];\\n        return route.first/route.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581079,
                "title": "simple-to-understand-solution-without-extra-classes",
                "content": "\\n\\n# Code\\n```\\nclass UndergroundSystem {\\n\\n    //Map to store times\\n    //      \"start-end\" : [t1,t2,t3]\\n    HashMap<String, List<Integer>> avgTimes;\\n\\n    //Map to keep track of each customer\\'s check in\\n    //      custId : [\"startStation\",\"checkInTime\"]\\n    // storing time as string is not recommended-used here just for simplicity\\n    //      this is where an extra class could have been useful\\n    HashMap<Integer, List<String>> checkInTimes;\\n\\n    public UndergroundSystem() {\\n        this.avgTimes = new HashMap<>();\\n        this.checkInTimes = new HashMap<Integer, List<String>>();\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n\\n        String [] val = new String[]{stationName,Integer.toString(t)};\\n\\n        checkInTimes.put(id,Arrays.asList(val));\\n        \\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        List<String> val = checkInTimes.get(id);\\n        String startStation = val.get(0);\\n        int startTime = Integer.valueOf(val.get(1));\\n\\n        String key = startStation+\"-\"+stationName;\\n        List<Integer> avg = avgTimes.get(key);\\n        if(avg!=null){\\n            avg.add(t-startTime);\\n            avgTimes.put(key,avg);\\n        }else{\\n            List<Integer> v = new ArrayList<>();\\n            v.add(t-startTime);\\n            avgTimes.put(key, v);\\n        }\\n        checkInTimes.remove(id);\\n\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        List<Integer> val = avgTimes.get(startStation+\"-\"+endStation);\\n        int no = 0;\\n        int sum = 0;\\n        for(int i=0;i<val.size(); i++){\\n            sum += val.get(i);\\n            no++;\\n        }\\n        return (double)sum/no;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```\\n\\nThis was an attempt to do it without extra classes.\\nDo suggest any improvements.\\nAnd upvote if you found it useful in anyway.",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass UndergroundSystem {\\n\\n    //Map to store times\\n    //      \"start-end\" : [t1,t2,t3]\\n    HashMap<String, List<Integer>> avgTimes;\\n\\n    //Map to keep track of each customer\\'s check in\\n    //      custId : [\"startStation\",\"checkInTime\"]\\n    // storing time as string is not recommended-used here just for simplicity\\n    //      this is where an extra class could have been useful\\n    HashMap<Integer, List<String>> checkInTimes;\\n\\n    public UndergroundSystem() {\\n        this.avgTimes = new HashMap<>();\\n        this.checkInTimes = new HashMap<Integer, List<String>>();\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n\\n        String [] val = new String[]{stationName,Integer.toString(t)};\\n\\n        checkInTimes.put(id,Arrays.asList(val));\\n        \\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        List<String> val = checkInTimes.get(id);\\n        String startStation = val.get(0);\\n        int startTime = Integer.valueOf(val.get(1));\\n\\n        String key = startStation+\"-\"+stationName;\\n        List<Integer> avg = avgTimes.get(key);\\n        if(avg!=null){\\n            avg.add(t-startTime);\\n            avgTimes.put(key,avg);\\n        }else{\\n            List<Integer> v = new ArrayList<>();\\n            v.add(t-startTime);\\n            avgTimes.put(key, v);\\n        }\\n        checkInTimes.remove(id);\\n\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        List<Integer> val = avgTimes.get(startStation+\"-\"+endStation);\\n        int no = 0;\\n        int sum = 0;\\n        for(int i=0;i<val.size(); i++){\\n            sum += val.get(i);\\n            no++;\\n        }\\n        return (double)sum/no;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580753,
                "title": "python-short-and-clean",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$, for each method.\\n\\n- Space complexity: $$O(1)$$, for each method.\\n\\n# Code\\n```python\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.check_ins = {} # station_in => t_in\\n        self.trips = defaultdict(lambda: (0, 0)) # (station_in, station_out) => (total_t, count) across all trips\\n\\n    def checkIn(self, id: int, station_name: str, t: int) -> None:\\n        self.check_ins[id] = (station_name, t)\\n\\n    def checkOut(self, id: int, station_name: str, t: int) -> None:\\n        s_out, t_out = station_name, t\\n        s_in , t_in  = self.check_ins[id]\\n\\n        self.trips[(s_in, s_out)] = tuple(map(add, self.trips[(s_in, s_out)], (t_out - t_in, 1)))\\n\\n    def getAverageTime(self, station_in: str, station_out: str) -> float:\\n        return truediv(*self.trips[(station_in, station_out)])\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```python\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.check_ins = {} # station_in => t_in\\n        self.trips = defaultdict(lambda: (0, 0)) # (station_in, station_out) => (total_t, count) across all trips\\n\\n    def checkIn(self, id: int, station_name: str, t: int) -> None:\\n        self.check_ins[id] = (station_name, t)\\n\\n    def checkOut(self, id: int, station_name: str, t: int) -> None:\\n        s_out, t_out = station_name, t\\n        s_in , t_in  = self.check_ins[id]\\n\\n        self.trips[(s_in, s_out)] = tuple(map(add, self.trips[(s_in, s_out)], (t_out - t_in, 1)))\\n\\n    def getAverageTime(self, station_in: str, station_out: str) -> float:\\n        return truediv(*self.trips[(station_in, station_out)])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580640,
                "title": "python3-solution",
                "content": "\\n```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.i=defaultdict(tuple)\\n        self.o=defaultdict(list)\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.i[id]=(t,stationName)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        starttime,startstation=self.i[id]\\n        total=t-starttime\\n        self.o[(startstation,stationName)].append(total)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        return sum(self.o[(startStation,endStation)])/len(self.o[(startStation,endStation)])\\n        \\n\\n\\n# Your UndergroundSystem object will be instantiated and called as such:\\n# obj = UndergroundSystem()\\n# obj.checkIn(id,stationName,t)\\n# obj.checkOut(id,stationName,t)\\n# param_3 = obj.getAverageTime(startStation,endStation)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.i=defaultdict(tuple)\\n        self.o=defaultdict(list)\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.i[id]=(t,stationName)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        starttime,startstation=self.i[id]\\n        total=t-starttime\\n        self.o[(startstation,stationName)].append(total)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        return sum(self.o[(startStation,endStation)])/len(self.o[(startStation,endStation)])\\n        \\n\\n\\n# Your UndergroundSystem object will be instantiated and called as such:\\n# obj = UndergroundSystem()\\n# obj.checkIn(id,stationName,t)\\n# obj.checkOut(id,stationName,t)\\n# param_3 = obj.getAverageTime(startStation,endStation)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580597,
                "title": "c-unordered-map",
                "content": "# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int, pair<string,int>>mp1;\\n    unordered_map<string, pair<double,int>>mp2;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp1[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto checkIn = mp1[id];\\n        mp1.erase(id);\\n        string routeName = checkIn.first + \"_\" + stationName;\\n        mp2[routeName].first += t - checkIn.second;\\n        mp2[routeName].second +=1;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string routeName = startStation + \"_\" + endStation;\\n        auto& route = mp2[routeName];\\n        return route.first/route.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int, pair<string,int>>mp1;\\n    unordered_map<string, pair<double,int>>mp2;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp1[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto checkIn = mp1[id];\\n        mp1.erase(id);\\n        string routeName = checkIn.first + \"_\" + stationName;\\n        mp2[routeName].first += t - checkIn.second;\\n        mp2[routeName].second +=1;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string routeName = startStation + \"_\" + endStation;\\n        auto& route = mp2[routeName];\\n        return route.first/route.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580435,
                "title": "c-eazy-small-code-hashmap",
                "content": "# Code\\n```\\nclass UndergroundSystem {\\n    unordered_map<int,pair<string,int>> ongoingTravels;\\n    unordered_map<string,unordered_map<string,double>> travelTimes;\\n    unordered_map<string,unordered_map<string,int>> travelCounts;\\n\\npublic:\\n    UndergroundSystem() {\\n        ongoingTravels.clear();\\n        travelTimes.clear();\\n    }\\n\\n    void checkIn(int id, string stationName, int t) {\\n        ongoingTravels[id] = make_pair(stationName, t);\\n    }\\n\\n    void checkOut(int id, string stationName, int t) {\\n        double travelTime = t - ongoingTravels[id].second;\\n        if (!(travelTimes.count(ongoingTravels[id].first) && travelTimes[ongoingTravels[id].first].count(stationName))) {\\n            travelTimes[ongoingTravels[id].first][stationName] = 0;\\n        }\\n        travelTimes[ongoingTravels[id].first][stationName] += travelTime;\\n        ++travelCounts[ongoingTravels[id].first][stationName];\\n        ongoingTravels.erase(id);\\n    }\\n\\n    double getAverageTime(string startStation, string endStation) {\\n        if (travelTimes.count(startStation) && travelTimes[startStation].count(endStation) &&\\n            travelCounts.count(startStation) && travelCounts[startStation].count(endStation) &&\\n            travelCounts[startStation][endStation] > 0) {\\n            return travelTimes[startStation][endStation] / travelCounts[startStation][endStation];\\n        }\\n        return 0.0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    unordered_map<int,pair<string,int>> ongoingTravels;\\n    unordered_map<string,unordered_map<string,double>> travelTimes;\\n    unordered_map<string,unordered_map<string,int>> travelCounts;\\n\\npublic:\\n    UndergroundSystem() {\\n        ongoingTravels.clear();\\n        travelTimes.clear();\\n    }\\n\\n    void checkIn(int id, string stationName, int t) {\\n        ongoingTravels[id] = make_pair(stationName, t);\\n    }\\n\\n    void checkOut(int id, string stationName, int t) {\\n        double travelTime = t - ongoingTravels[id].second;\\n        if (!(travelTimes.count(ongoingTravels[id].first) && travelTimes[ongoingTravels[id].first].count(stationName))) {\\n            travelTimes[ongoingTravels[id].first][stationName] = 0;\\n        }\\n        travelTimes[ongoingTravels[id].first][stationName] += travelTime;\\n        ++travelCounts[ongoingTravels[id].first][stationName];\\n        ongoingTravels.erase(id);\\n    }\\n\\n    double getAverageTime(string startStation, string endStation) {\\n        if (travelTimes.count(startStation) && travelTimes[startStation].count(endStation) &&\\n            travelCounts.count(startStation) && travelCounts[startStation].count(endStation) &&\\n            travelCounts[startStation][endStation] > 0) {\\n            return travelTimes[startStation][endStation] / travelCounts[startStation][endStation];\\n        }\\n        return 0.0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580371,
                "title": "daily-leetcoding-challenge-may-day-31",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3575799,
                "title": "ruby-solution-easy-understand-w-comments",
                "content": "```\\nclass UndergroundSystem\\n    def initialize()\\n        @pass_checkin = {}\\n        @travel_times = {}\\n    end\\n\\n    def check_in(id, station_name, t)\\n        # pass_checkin tracks starting time and station when passengers checkin\\n        @pass_checkin[id] = [t, station_name]\\n    end\\n\\n    def check_out(id, station_name, t)\\n        # get passenger\\'s travel time and stations of travel\\n        travel_time = t - @pass_checkin[id].first\\n        station_transfer = \"#{@pass_checkin[id].last} -> #{station_name}\"\\n        \\n        # append newly recorded travel time for this unique station pair, or create new array\\n        if @travel_times.has_key?(station_transfer)\\n            @travel_times[station_transfer] << travel_time\\n        else\\n            @travel_times[station_transfer] = [travel_time]\\n        end\\n    end\\n\\n    def get_average_time(start_station, end_station)\\n        # get array of recorded travel times for these stations, and return average\\n        arr = @travel_times[\"#{start_station} -> #{end_station}\"]\\n        return arr.sum.fdiv(arr.size)\\n    end\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass UndergroundSystem\\n    def initialize()\\n        @pass_checkin = {}\\n        @travel_times = {}\\n    end\\n\\n    def check_in(id, station_name, t)\\n        # pass_checkin tracks starting time and station when passengers checkin\\n        @pass_checkin[id] = [t, station_name]\\n    end\\n\\n    def check_out(id, station_name, t)\\n        # get passenger\\'s travel time and stations of travel\\n        travel_time = t - @pass_checkin[id].first\\n        station_transfer = \"#{@pass_checkin[id].last} -> #{station_name}\"\\n        \\n        # append newly recorded travel time for this unique station pair, or create new array\\n        if @travel_times.has_key?(station_transfer)\\n            @travel_times[station_transfer] << travel_time\\n        else\\n            @travel_times[station_transfer] = [travel_time]\\n        end\\n    end\\n\\n    def get_average_time(start_station, end_station)\\n        # get array of recorded travel times for these stations, and return average\\n        arr = @travel_times[\"#{start_station} -> #{end_station}\"]\\n        return arr.sum.fdiv(arr.size)\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543778,
                "title": "java-easy-100-solution-using-hashmap",
                "content": "```java\\nclass UndergroundSystem {\\n    private final Map<Integer, Pair<String, Integer>> customers;\\n    private final Map<String, int[]> stationsDistance;\\n\\n    public UndergroundSystem() {\\n        this.customers = new HashMap<>();\\n        this.stationsDistance = new HashMap<>();\\n    }\\n    \\n    public void checkIn(final int id, final String stationName, final int t) {\\n        this.customers.put(id, new Pair(stationName, t));\\n    }\\n    \\n    public void checkOut(final int id, final String stationName, final int t) {\\n        final Pair<String, Integer> customer = this.customers.get(id);\\n\\n        this.stationsDistance.putIfAbsent(customer.getKey() + \"-\" + stationName, new int[2]);\\n\\n        final int[] sum = this.stationsDistance.get(customer.getKey() + \"-\" + stationName);\\n\\n        sum[0] += t - customer.getValue();\\n        sum[1]++;\\n\\n        this.customers.remove(id);\\n    }\\n    \\n    public double getAverageTime(final String startStation, final String endStation) {\\n        final int[] sum = this.stationsDistance.get(startStation + \"-\" + endStation);\\n\\n        return (double) sum[0] / sum[1];\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass UndergroundSystem {\\n    private final Map<Integer, Pair<String, Integer>> customers;\\n    private final Map<String, int[]> stationsDistance;\\n\\n    public UndergroundSystem() {\\n        this.customers = new HashMap<>();\\n        this.stationsDistance = new HashMap<>();\\n    }\\n    \\n    public void checkIn(final int id, final String stationName, final int t) {\\n        this.customers.put(id, new Pair(stationName, t));\\n    }\\n    \\n    public void checkOut(final int id, final String stationName, final int t) {\\n        final Pair<String, Integer> customer = this.customers.get(id);\\n\\n        this.stationsDistance.putIfAbsent(customer.getKey() + \"-\" + stationName, new int[2]);\\n\\n        final int[] sum = this.stationsDistance.get(customer.getKey() + \"-\" + stationName);\\n\\n        sum[0] += t - customer.getValue();\\n        sum[1]++;\\n\\n        this.customers.remove(id);\\n    }\\n    \\n    public double getAverageTime(final String startStation, final String endStation) {\\n        final int[] sum = this.stationsDistance.get(startStation + \"-\" + endStation);\\n\\n        return (double) sum[0] / sum[1];\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124268,
                "title": "c-solution-using-map",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int,pair<string,int>> mp;\\n    map<pair<string,string>, pair<int,int>> avgTimeMap;\\n    \\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id]={stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int diffTime= t- (mp[id].second);\\n        avgTimeMap[{(mp[id].first),stationName}].first+= diffTime;\\n        avgTimeMap[{(mp[id].first),stationName}].second++;\\n        mp.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return (double)avgTimeMap[{startStation,endStation}].first/avgTimeMap[{startStation,endStation}].second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int,pair<string,int>> mp;\\n    map<pair<string,string>, pair<int,int>> avgTimeMap;\\n    \\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id]={stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int diffTime= t- (mp[id].second);\\n        avgTimeMap[{(mp[id].first),stationName}].first+= diffTime;\\n        avgTimeMap[{(mp[id].first),stationName}].second++;\\n        mp.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return (double)avgTimeMap[{startStation,endStation}].first/avgTimeMap[{startStation,endStation}].second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834229,
                "title": "python3",
                "content": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.temp = collections.defaultdict(list)\\n        self.dic = collections.defaultdict(list)\\n\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.temp[id] = [stationName, t]\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        self.dic[(self.temp[id][0], stationName)].append(t - self.temp[id][1])\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        return sum((self.dic[(startStation, endStation)])) / len(self.dic[(startStation, endStation)])",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.temp = collections.defaultdict(list)\\n        self.dic = collections.defaultdict(list)\\n\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.temp[id] = [stationName, t]\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        self.dic[(self.temp[id][0], stationName)].append(t - self.temp[id][1])\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        return sum((self.dic[(startStation, endStation)])) / len(self.dic[(startStation, endStation)])",
                "codeTag": "Java"
            },
            {
                "id": 2608262,
                "title": "c-using-hashmap-easy",
                "content": "```\\nclass UndergroundSystem {\\n    unordered_map<string, unordered_map<string, pair<int,int>>> mp;\\n    unordered_map<int,pair<string,int>> onTrain;    // id -> from, time\\npublic:\\n    // hash map, store connections and averages for each connection\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        onTrain[id] = make_pair(stationName, t);\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto p = onTrain[id];\\n        mp[p.first][stationName].first += t - p.second;\\n        mp[p.first][stationName].second++;\\n        onTrain.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return double(mp[startStation][endStation].first) / mp[startStation][endStation].second;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n    unordered_map<string, unordered_map<string, pair<int,int>>> mp;\\n    unordered_map<int,pair<string,int>> onTrain;    // id -> from, time\\npublic:\\n    // hash map, store connections and averages for each connection\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        onTrain[id] = make_pair(stationName, t);\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto p = onTrain[id];\\n        mp[p.first][stationName].first += t - p.second;\\n        mp[p.first][stationName].second++;\\n        onTrain.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return double(mp[startStation][endStation].first) / mp[startStation][endStation].second;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2520562,
                "title": "python-two-dictionaries",
                "content": "The idea is extemerly simple. Use one map to store current passangers in the underground system: `map[passangerId] = (startStation,startTime)` and another map to store travel times for each station combo: `map[\"startStation:endStation\"] = [t1,t2,...]`. Use built-in `mean` function to get the average time for each station combo.\\n\\n```\\nclass UndergroundSystem:\\n\\tdef __init__(self):\\n\\t\\tself.currentPassengers = defaultdict(tuple) # id -> (startStation, startTime)\\n\\t\\tself.travelTimes = defaultdict(list) # stationStart:stationEnd -> [t1,t2]\\n\\n\\tdef checkIn(self, id: int, stationName: str, t: int) -> None:\\n\\t\\tself.currentPassengers[id] = (stationName, t)\\n\\n\\tdef checkOut(self, id: int, stationName: str, t: int) -> None:\\n\\t\\tstartStation, startTime = self.currentPassengers.pop(id)\\n\\t\\tself.travelTimes[f\"{startStation}:{stationName}\"].append(t - startTime)\\n\\n\\tdef getAverageTime(self, startStation: str, endStation: str) -> float:\\n\\t\\treturn mean(self.travelTimes[f\"{startStation}:{endStation}\"])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass UndergroundSystem:\\n\\tdef __init__(self):\\n\\t\\tself.currentPassengers = defaultdict(tuple) # id -> (startStation, startTime)\\n\\t\\tself.travelTimes = defaultdict(list) # stationStart:stationEnd -> [t1,t2]\\n\\n\\tdef checkIn(self, id: int, stationName: str, t: int) -> None:\\n\\t\\tself.currentPassengers[id] = (stationName, t)\\n\\n\\tdef checkOut(self, id: int, stationName: str, t: int) -> None:\\n\\t\\tstartStation, startTime = self.currentPassengers.pop(id)\\n\\t\\tself.travelTimes[f\"{startStation}:{stationName}\"].append(t - startTime)\\n\\n\\tdef getAverageTime(self, startStation: str, endStation: str) -> float:\\n\\t\\treturn mean(self.travelTimes[f\"{startStation}:{endStation}\"])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454544,
                "title": "c-clean-4-maps-implementation-commented",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    \\n    unordered_map<int,string> in ; //stores the id with its entry point station \\n    unordered_map<int,int> timer ; //stores the id with its entry time\\n    \\n    unordered_map<string,unordered_map<string,int>> diff ; //stores the time difference between two given stations\\n    unordered_map<string,unordered_map<string,int>> count ; //stores the number of people visiting two particular stations\\n    \\n    UndergroundSystem(){}\\n    \\n    void checkIn(int id, string name, int t) {\\n        in[id] = name ;\\n        timer[id] = t ;\\n        \\n    }\\n    \\n    void checkOut(int id, string name, int t) {\\n        diff[in[id]][name] += t - timer[id] ;\\n        ++count[in[id]][name] ;\\n        in.erase(id) ; //remove the cutomer from intial station \\n        timer.erase(id) ; //remove the entrye time at intial station \\n        \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return (double)diff[startStation][endStation] / (double)count[startStation][endStation] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    \\n    unordered_map<int,string> in ; //stores the id with its entry point station \\n    unordered_map<int,int> timer ; //stores the id with its entry time\\n    \\n    unordered_map<string,unordered_map<string,int>> diff ; //stores the time difference between two given stations\\n    unordered_map<string,unordered_map<string,int>> count ; //stores the number of people visiting two particular stations\\n    \\n    UndergroundSystem(){}\\n    \\n    void checkIn(int id, string name, int t) {\\n        in[id] = name ;\\n        timer[id] = t ;\\n        \\n    }\\n    \\n    void checkOut(int id, string name, int t) {\\n        diff[in[id]][name] += t - timer[id] ;\\n        ++count[in[id]][name] ;\\n        in.erase(id) ; //remove the cutomer from intial station \\n        timer.erase(id) ; //remove the entrye time at intial station \\n        \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return (double)diff[startStation][endStation] / (double)count[startStation][endStation] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022718,
                "title": "clean-and-clear-python-solution-using-hashmap-very-easy-to-understand",
                "content": "A **seemingly complex** question that is actually not hard!\\n\\nUse **Hashmap**!\\n\\nInitiate **two hashmaps**:\\none to keep **id** to **[start station, check in time]**\\none to keep **[start station, end station]** to **[time of route, count]**\\n\\n**TIme:** O(1), for all three operations\\n**Space:** O(p + r), p is the number of passengers, r is the number of routes\\n\\n```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.id_to_startstation_and_time = {}\\n        self.route_to_time_and_count = collections.defaultdict(lambda: [0, 0])\\n                \\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.id_to_startstation_and_time[id] = [stationName, t]\\n\\n    def checkOut(self, id: int, end_station: str, t: int) -> None:\\n        start_station, start_time = self.id_to_startstation_and_time.pop(id)\\n        self.route_to_time_and_count[(start_station, end_station)][0] += (t - start_time)\\n        self.route_to_time_and_count[(start_station, end_station)][1] += 1\\n            \\n    def getAverageTime(self, start_station: str, end_station: str) -> float:\\n        total_time, total_counts = self.route_to_time_and_count[(start_station, end_station)]\\n        return total_time / total_counts\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.id_to_startstation_and_time = {}\\n        self.route_to_time_and_count = collections.defaultdict(lambda: [0, 0])\\n                \\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.id_to_startstation_and_time[id] = [stationName, t]\\n\\n    def checkOut(self, id: int, end_station: str, t: int) -> None:\\n        start_station, start_time = self.id_to_startstation_and_time.pop(id)\\n        self.route_to_time_and_count[(start_station, end_station)][0] += (t - start_time)\\n        self.route_to_time_and_count[(start_station, end_station)][1] += 1\\n            \\n    def getAverageTime(self, start_station: str, end_station: str) -> float:\\n        total_time, total_counts = self.route_to_time_and_count[(start_station, end_station)]\\n        return total_time / total_counts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979508,
                "title": "rust-free-range-implementation-faster-than-100",
                "content": "Our code is raised free range at Coding Hill Farms. We believe that happy code makes for better tasting bytes.\\n\\nI wonder what % of submissions get the \"faster than 100%\". 30% maybe? 30% of submissions are faster than 100% of submissions? =)  This designation is flawed, especially when the same code can be run twice and get different rankings.\\n\\nThis solution is probably very similar to most submissions.  I used type declarations to help make the purpose of the fields of tuples clear, rather than create several struct declarations. The time-complexity is `O(n)`.\\n\\nNo, I did not copy this from *your* code. I didn\\'t look at anyone\\'s solution before I coded this. If our code looks similar it\\'s because the problem calls for obvious idiomatic patterns. So, no.. you are not a genius and the first one to invent a unique way to use hash maps and everyone didn\\'t copy you. Get over yourself!\\n\\n```rust\\nuse std::collections::HashMap;\\n\\ntype Customer = i32;\\ntype Station  = String;\\ntype Time     = i32;\\ntype TimeAcm  = i64;\\ntype Count    = usize;\\n\\nstruct UndergroundSystem {\\n    avg_times   : HashMap<(Station, Station), (Count, TimeAcm)>,\\n    ckin_time   : HashMap<Customer, (Station, Time)>,\\n}\\n\\nimpl UndergroundSystem {\\n    fn new() -> Self {\\n        Self {\\n            avg_times   : HashMap::new(),\\n            ckin_time   : HashMap::new(),\\n        }\\n    }\\n    fn check_in(&mut self, \\n                id              : i32, \\n                station_name    : String, \\n                t               : i32) \\n    {\\n        self.ckin_time.insert(id, (station_name, t));\\n    }\\n    fn check_out(&mut self, \\n                 id             : i32, \\n                 station_name   : String, \\n                 t              : i32)\\n    {\\n        if let Some((station_in, time_in)) = self.ckin_time.remove(&id) {\\n            let     key = (station_in.clone(), station_name);\\n            let mut rec = self.avg_times.entry(key).or_insert((0, 0));\\n\\n            rec.0 += 1;\\n            rec.1 += (t - time_in) as TimeAcm;\\n        } else {\\n            panic!(\"Customer {} checking out from {} with no record of \\n                    checking in anywhere.\", id, station_name);\\n        }\\n    }\\n    fn get_average_time(&self, \\n                        start_station   : String, \\n                        end_station     : String\\n                       ) -> f64 \\n    {\\n        let key = (start_station, end_station);\\n\\n        if let Some(&(count, time_acm)) = self.avg_times.get(&key) {\\n            time_acm as f64 / count as f64\\n        } else {\\n            // LIES!!!: There will be at least one customer that has traveled \\n            //          from startStation to endStation before getAverageTime \\n            //          is called\\n            0.0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\ntype Customer = i32;\\ntype Station  = String;\\ntype Time     = i32;\\ntype TimeAcm  = i64;\\ntype Count    = usize;\\n\\nstruct UndergroundSystem {\\n    avg_times   : HashMap<(Station, Station), (Count, TimeAcm)>,\\n    ckin_time   : HashMap<Customer, (Station, Time)>,\\n}\\n\\nimpl UndergroundSystem {\\n    fn new() -> Self {\\n        Self {\\n            avg_times   : HashMap::new(),\\n            ckin_time   : HashMap::new(),\\n        }\\n    }\\n    fn check_in(&mut self, \\n                id              : i32, \\n                station_name    : String, \\n                t               : i32) \\n    {\\n        self.ckin_time.insert(id, (station_name, t));\\n    }\\n    fn check_out(&mut self, \\n                 id             : i32, \\n                 station_name   : String, \\n                 t              : i32)\\n    {\\n        if let Some((station_in, time_in)) = self.ckin_time.remove(&id) {\\n            let     key = (station_in.clone(), station_name);\\n            let mut rec = self.avg_times.entry(key).or_insert((0, 0));\\n\\n            rec.0 += 1;\\n            rec.1 += (t - time_in) as TimeAcm;\\n        } else {\\n            panic!(\"Customer {} checking out from {} with no record of \\n                    checking in anywhere.\", id, station_name);\\n        }\\n    }\\n    fn get_average_time(&self, \\n                        start_station   : String, \\n                        end_station     : String\\n                       ) -> f64 \\n    {\\n        let key = (start_station, end_station);\\n\\n        if let Some(&(count, time_acm)) = self.avg_times.get(&key) {\\n            time_acm as f64 / count as f64\\n        } else {\\n            // LIES!!!: There will be at least one customer that has traveled \\n            //          from startStation to endStation before getAverageTime \\n            //          is called\\n            0.0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1979354,
                "title": "i-love-these-questions-python-java",
                "content": "Python\\n```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.srcDestMapping = {}\\n        self.checkedIn = {}\\n        \\n    def getKey(self, startStation, endStation):\\n        return startStation + \\'->\\' + endStation\\n    \\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkedIn[id] = [stationName, t]\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        checkInStation, checkInTime = self.checkedIn[id]\\n        self.checkedIn.pop(id)\\n        \\n        key = self.getKey(checkInStation, stationName)\\n        \\n        if key in self.srcDestMapping:\\n            self.srcDestMapping[key][0] += (t - checkInTime)\\n            self.srcDestMapping[key][1] += 1\\n        else:\\n            self.srcDestMapping[key] = [t - checkInTime, 1]\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        key = self.getKey(startStation, endStation)\\n        totalTime, journeyCount  = self.srcDestMapping[key]\\n        return totalTime / journeyCount\\n```\\n\\nJava\\n\\n```\\n\\nclass UndergroundSystem {\\n    \\n    public class Node {\\n        String startStation;\\n        int startTime;\\n        public Node(String startStation, int startTime) {\\n            this.startStation = startStation;\\n            this.startTime = startTime;\\n         }\\n     }\\n\\t \\n    private Map<String, int[]> srcDestMapping = new HashMap<>();\\n    private Map<Integer, Node> checkedIn = new HashMap<>();\\n\\t\\n    private String getKey(String startStation, String endStation) {\\n        return startStation + \"->\" + endStation;\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        Node newNode = new Node(stationName, t);\\n        checkedIn.put(id, newNode);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Node node = checkedIn.get(id);\\n        String startStation = node.startStation;\\n        int startTime = node.startTime;\\n        String key = getKey(startStation, stationName);\\n        checkedIn.remove(id);\\n        \\n        if(srcDestMapping.containsKey(key)) {\\n            int arr[] = srcDestMapping.get(key);\\n            srcDestMapping.put(key, new int[] {arr[0] + (t - startTime), arr[1] + 1});\\n        }\\n        else {\\n            srcDestMapping.put(key, new int[] {(t - startTime),1});\\n        }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = getKey(startStation, endStation);\\n        int arr[] = srcDestMapping.get(key);\\n        return (double) arr[0] / arr[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.srcDestMapping = {}\\n        self.checkedIn = {}\\n        \\n    def getKey(self, startStation, endStation):\\n        return startStation + \\'->\\' + endStation\\n    \\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkedIn[id] = [stationName, t]\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        checkInStation, checkInTime = self.checkedIn[id]\\n        self.checkedIn.pop(id)\\n        \\n        key = self.getKey(checkInStation, stationName)\\n        \\n        if key in self.srcDestMapping:\\n            self.srcDestMapping[key][0] += (t - checkInTime)\\n            self.srcDestMapping[key][1] += 1\\n        else:\\n            self.srcDestMapping[key] = [t - checkInTime, 1]\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        key = self.getKey(startStation, endStation)\\n        totalTime, journeyCount  = self.srcDestMapping[key]\\n        return totalTime / journeyCount\\n```\n```\\n\\nclass UndergroundSystem {\\n    \\n    public class Node {\\n        String startStation;\\n        int startTime;\\n        public Node(String startStation, int startTime) {\\n            this.startStation = startStation;\\n            this.startTime = startTime;\\n         }\\n     }\\n\\t \\n    private Map<String, int[]> srcDestMapping = new HashMap<>();\\n    private Map<Integer, Node> checkedIn = new HashMap<>();\\n\\t\\n    private String getKey(String startStation, String endStation) {\\n        return startStation + \"->\" + endStation;\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        Node newNode = new Node(stationName, t);\\n        checkedIn.put(id, newNode);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Node node = checkedIn.get(id);\\n        String startStation = node.startStation;\\n        int startTime = node.startTime;\\n        String key = getKey(startStation, stationName);\\n        checkedIn.remove(id);\\n        \\n        if(srcDestMapping.containsKey(key)) {\\n            int arr[] = srcDestMapping.get(key);\\n            srcDestMapping.put(key, new int[] {arr[0] + (t - startTime), arr[1] + 1});\\n        }\\n        else {\\n            srcDestMapping.put(key, new int[] {(t - startTime),1});\\n        }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = getKey(startStation, endStation);\\n        int arr[] = srcDestMapping.get(key);\\n        return (double) arr[0] / arr[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979277,
                "title": "c-faster-than-100ms-easy-to-understand",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    \\n  unordered_map<int,pair<string,int>> checkin;\\n  unordered_map<string,pair<double,int>> checkout;\\n    UndergroundSystem() {\\n      \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n      checkin[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n      \\n        auto check = checkin[id];\\n        checkin.erase(id);\\n        checkout[check.first+\",\"+stationName].first+=t-check.second;\\n        checkout[check.first+\",\"+stationName].second+=1;\\n        \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n      auto check = checkout[startStation+\",\"+endStation];\\n        return (double)check.first/check.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    \\n  unordered_map<int,pair<string,int>> checkin;\\n  unordered_map<string,pair<double,int>> checkout;\\n    UndergroundSystem() {\\n      \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n      checkin[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n      \\n        auto check = checkin[id];\\n        checkin.erase(id);\\n        checkout[check.first+\",\"+stationName].first+=t-check.second;\\n        checkout[check.first+\",\"+stationName].second+=1;\\n        \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n      auto check = checkout[startStation+\",\"+endStation];\\n        return (double)check.first/check.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979004,
                "title": "java-hashmap-71",
                "content": "```\\nclass UndergroundSystem {\\n    HashMap<Integer,Transaction> persons;\\n    HashMap<String, SumTotal> avg;\\n\\n    public UndergroundSystem()\\n    {\\n        avg = new HashMap<>();\\n        persons = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t)\\n    {\\n        // Adding new transaction on record\\n        persons.put(id, new Transaction(id, stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int endT)\\n    {\\n        // Added to record \\n        Transaction t = persons.get(id);        \\n        double totalTime = endT-t.startTime;\\n        \\n        String route = t.startStation+\"-\"+stationName;\\n        if(avg.containsKey(route))      \\n        {\\n            // Updating previous record for route\\n            avg.get(route).sum += totalTime;\\n            avg.get(route).transNo++;\\n        }\\n        else  \\n        {\\n            // Adding new record\\n            avg.put(route, new SumTotal(totalTime));\\n        }        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation)\\n    {\\n        String route = startStation+\"-\"+endStation;\\n        return avg.get(route).sum / avg.get(route).transNo;\\n    }\\n}\\n\\n// class to Store Sum and number of transactions \\nclass SumTotal\\n{\\n    public double sum;\\n    public int transNo;\\n    public SumTotal(double dist)\\n    {\\n        this.sum = dist;\\n        this.transNo = 1;\\n    }\\n}\\n\\nclass Transaction\\n{\\n    public int id;\\n    public String startStation;\\n    public int startTime;\\n    public Transaction(int tTd, String stationName, int t)\\n    {\\n        this.id = tTd;\\n        this.startStation = stationName;\\n        this.startTime = t;\\n    }    \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    HashMap<Integer,Transaction> persons;\\n    HashMap<String, SumTotal> avg;\\n\\n    public UndergroundSystem()\\n    {\\n        avg = new HashMap<>();\\n        persons = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t)\\n    {\\n        // Adding new transaction on record\\n        persons.put(id, new Transaction(id, stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int endT)\\n    {\\n        // Added to record \\n        Transaction t = persons.get(id);        \\n        double totalTime = endT-t.startTime;\\n        \\n        String route = t.startStation+\"-\"+stationName;\\n        if(avg.containsKey(route))      \\n        {\\n            // Updating previous record for route\\n            avg.get(route).sum += totalTime;\\n            avg.get(route).transNo++;\\n        }\\n        else  \\n        {\\n            // Adding new record\\n            avg.put(route, new SumTotal(totalTime));\\n        }        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation)\\n    {\\n        String route = startStation+\"-\"+endStation;\\n        return avg.get(route).sum / avg.get(route).transNo;\\n    }\\n}\\n\\n// class to Store Sum and number of transactions \\nclass SumTotal\\n{\\n    public double sum;\\n    public int transNo;\\n    public SumTotal(double dist)\\n    {\\n        this.sum = dist;\\n        this.transNo = 1;\\n    }\\n}\\n\\nclass Transaction\\n{\\n    public int id;\\n    public String startStation;\\n    public int startTime;\\n    public Transaction(int tTd, String stationName, int t)\\n    {\\n        this.id = tTd;\\n        this.startStation = stationName;\\n        this.startTime = t;\\n    }    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978714,
                "title": "easy-and-proper-commented-solution-using-hash-map-in-java",
                "content": "```\\nclass UndergroundSystem {\\n    // to store the checkin time of that id on particular station\\n    HashMap<Integer,Pair<String,Integer>> mp1;\\n    \\n    /* to store the diff between checkin and checkout time between that\\n       particular stations*/\\n    HashMap<Pair<String,String>,List<Integer>> mp2;\\n\\n    public UndergroundSystem() {\\n        mp1 = new HashMap(); //initialization\\n        mp2 = new HashMap(); //initialization\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        /* since once can checkout at one station only at a time so that\\'s why \\n           we\\'re using putIfAbsent here. This will put into map only if user\\n           not chekin somewhere at that time*/\\n        mp1.putIfAbsent(id, new Pair<>(stationName,t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        int diff = t - mp1.get(id).getValue(); // diff b/w checkin and checkout\\n        Pair<String,String> p = new Pair<>(mp1.get(id).getKey(), stationName);\\n        /*\\n         we\\'re removing that id because once person checkout from that station\\n         then he can checkin further \\n        */\\n        mp1.remove(id); \\n        /*\\n            check if anyother have travelled b/w same stations\\n        */\\n        if(mp2.get(p) == null){\\n            List<Integer> diffs = new ArrayList<>();\\n            diffs.add(diff);\\n            mp2.put(p, diffs);\\n        }\\n        /*\\n            if yes then we\\'ll update the travel time list\\n        */\\n        else{\\n            mp2.get(p).add(diff);\\n        }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        Pair<String, String> p = new Pair<>(startStation, endStation);\\n        List<Integer> avg = mp2.get(p);\\n        /*\\n            gives the avg of total travel time b/w given stations \\n            by taking avg of travel time of all visitors\\n        */\\n        double ans = (avg.stream().mapToDouble(Integer::intValue).sum())/avg.size();\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    // to store the checkin time of that id on particular station\\n    HashMap<Integer,Pair<String,Integer>> mp1;\\n    \\n    /* to store the diff between checkin and checkout time between that\\n       particular stations*/\\n    HashMap<Pair<String,String>,List<Integer>> mp2;\\n\\n    public UndergroundSystem() {\\n        mp1 = new HashMap(); //initialization\\n        mp2 = new HashMap(); //initialization\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        /* since once can checkout at one station only at a time so that\\'s why \\n           we\\'re using putIfAbsent here. This will put into map only if user\\n           not chekin somewhere at that time*/\\n        mp1.putIfAbsent(id, new Pair<>(stationName,t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        int diff = t - mp1.get(id).getValue(); // diff b/w checkin and checkout\\n        Pair<String,String> p = new Pair<>(mp1.get(id).getKey(), stationName);\\n        /*\\n         we\\'re removing that id because once person checkout from that station\\n         then he can checkin further \\n        */\\n        mp1.remove(id); \\n        /*\\n            check if anyother have travelled b/w same stations\\n        */\\n        if(mp2.get(p) == null){\\n            List<Integer> diffs = new ArrayList<>();\\n            diffs.add(diff);\\n            mp2.put(p, diffs);\\n        }\\n        /*\\n            if yes then we\\'ll update the travel time list\\n        */\\n        else{\\n            mp2.get(p).add(diff);\\n        }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        Pair<String, String> p = new Pair<>(startStation, endStation);\\n        List<Integer> avg = mp2.get(p);\\n        /*\\n            gives the avg of total travel time b/w given stations \\n            by taking avg of travel time of all visitors\\n        */\\n        double ans = (avg.stream().mapToDouble(Integer::intValue).sum())/avg.size();\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978488,
                "title": "c-map-easy-approach-two-maps",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {\\n        \\n    }\\n    map<int, pair<string, int>> in;\\n    map<pair<string, string>, pair<double, int>> dist;\\n    void checkIn(int id, string stationName, int t) {\\n            in[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(dist[{in[id].first,  stationName}].first == 0){\\n            dist[{in[id].first,  stationName}].first = t - in[id].second;\\n            dist[{in[id].first,  stationName}].second=1;\\n        }\\n        else{\\n            dist[{in[id].first,  stationName}].first += (t - in[id].second);\\n            dist[{in[id].first,  stationName}].second+=1;\\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return dist[{startStation, endStation}].first/(dist[{startStation, endStation}].second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {\\n        \\n    }\\n    map<int, pair<string, int>> in;\\n    map<pair<string, string>, pair<double, int>> dist;\\n    void checkIn(int id, string stationName, int t) {\\n            in[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(dist[{in[id].first,  stationName}].first == 0){\\n            dist[{in[id].first,  stationName}].first = t - in[id].second;\\n            dist[{in[id].first,  stationName}].second=1;\\n        }\\n        else{\\n            dist[{in[id].first,  stationName}].first += (t - in[id].second);\\n            dist[{in[id].first,  stationName}].second+=1;\\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return dist[{startStation, endStation}].first/(dist[{startStation, endStation}].second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978437,
                "title": "c-easy-explanation",
                "content": "```\\nclass UndergroundSystem {\\n    \\n    // stores the ongoing travel of each id\\n    unordered_map<int,pair<string,int>> st;\\n    \\n    // stores total travel time between each source and destination\\n    unordered_map<string,unordered_map<string,double>> avg;\\n    \\n    // store total no of travels from source to destination\\n    unordered_map<string,unordered_map<string,int>> count;\\npublic:\\n    UndergroundSystem() {\\n        st.clear();\\n        avg.clear();\\n    }\\n    \\n    // initialize new travel for id\\n    void checkIn(int id, string stationName, int t) {\\n        st[id] = make_pair(stationName,t);\\n    }\\n    \\n    // increment travel time and no of travels from id\\'s source to destination\\n    void checkOut(int id, string stationName, int t) {\\n        double time = t - st[id].second;\\n                \\n        if (!(avg.count(st[id].first) and avg[st[id].first].count(stationName)))\\n            avg[st[id].first][stationName] = 0;\\n            \\n        avg[st[id].first][stationName] += time;\\n        ++count[st[id].first][stationName];\\n        \\n        st.erase(id);\\n    }\\n    \\n    // return the avg (total travel time / total no of travels)\\n    double getAverageTime(string startStation, string endStation) {\\n        return avg[startStation][endStation] / count[startStation][endStation];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    \\n    // stores the ongoing travel of each id\\n    unordered_map<int,pair<string,int>> st;\\n    \\n    // stores total travel time between each source and destination\\n    unordered_map<string,unordered_map<string,double>> avg;\\n    \\n    // store total no of travels from source to destination\\n    unordered_map<string,unordered_map<string,int>> count;\\npublic:\\n    UndergroundSystem() {\\n        st.clear();\\n        avg.clear();\\n    }\\n    \\n    // initialize new travel for id\\n    void checkIn(int id, string stationName, int t) {\\n        st[id] = make_pair(stationName,t);\\n    }\\n    \\n    // increment travel time and no of travels from id\\'s source to destination\\n    void checkOut(int id, string stationName, int t) {\\n        double time = t - st[id].second;\\n                \\n        if (!(avg.count(st[id].first) and avg[st[id].first].count(stationName)))\\n            avg[st[id].first][stationName] = 0;\\n            \\n        avg[st[id].first][stationName] += time;\\n        ++count[st[id].first][stationName];\\n        \\n        st.erase(id);\\n    }\\n    \\n    // return the avg (total travel time / total no of travels)\\n    double getAverageTime(string startStation, string endStation) {\\n        return avg[startStation][endStation] / count[startStation][endStation];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977142,
                "title": "c-use-counters-and-avoid-duplication",
                "content": "Only the total and number of travel times are stored and can be calculated immediately.\\n\\nSince the time taken between origin and destination is one-way, there can be multiple destinations for the same origin,\\nThere is room for duplicates in the string.\\nFortunately, the length of the string is 10 or less, so it will not be a burden.\\nbut, if you are concerned about storage space due to duplication, you can improve it as follows.\\nString data is managed as a separate map.\\nThe amount of computation will increase, but the storage space can be efficiently utilized because duplication is prevented.\\n\\n\\n```\\nclass UndergroundSystem {\\npublic:\\n    map<int, pair<int, int>> track; // {id, {startIndex, time}}\\n    map<pair<int, int>, pair<int, int>> travelTimes; // {{startIndex, endIndex}, {totalSum, totalCount}}\\n    \\n    map<string, int> dataToIndex;\\n    map<int, string> indexToData;\\n    \\n    UndergroundSystem() { }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        int index = indexDataIfNot(stationName);\\n        track[id] = {index, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int index = indexDataIfNot(stationName);\\n        pair<int, int>& startAndTime = track[id];\\n        pair<int, int>& sumAndCount = travelTimes[{startAndTime.first, index}];\\n        sumAndCount.first += t - startAndTime.second;\\n        sumAndCount.second++;\\n        track.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        pair<int, int>& pi = travelTimes[{getIndex(startStation), getIndex(endStation)}];\\n        return (double)pi.first/pi.second;\\n    }\\n    \\nprivate:\\n    int indexDataIfNot(string& data) {\\n        if(dataToIndex.find(data) != dataToIndex.end())\\n            return dataToIndex[data];\\n        int index = dataToIndex.size();\\n        dataToIndex[data] = index;\\n        indexToData[index] = data;\\n        return index;\\n    }\\n    \\n    string getData(int index) {\\n        return indexToData[index];\\n    }\\n    \\n    int getIndex(string& data) {\\n        return dataToIndex[data];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    map<int, pair<int, int>> track; // {id, {startIndex, time}}\\n    map<pair<int, int>, pair<int, int>> travelTimes; // {{startIndex, endIndex}, {totalSum, totalCount}}\\n    \\n    map<string, int> dataToIndex;\\n    map<int, string> indexToData;\\n    \\n    UndergroundSystem() { }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        int index = indexDataIfNot(stationName);\\n        track[id] = {index, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int index = indexDataIfNot(stationName);\\n        pair<int, int>& startAndTime = track[id];\\n        pair<int, int>& sumAndCount = travelTimes[{startAndTime.first, index}];\\n        sumAndCount.first += t - startAndTime.second;\\n        sumAndCount.second++;\\n        track.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        pair<int, int>& pi = travelTimes[{getIndex(startStation), getIndex(endStation)}];\\n        return (double)pi.first/pi.second;\\n    }\\n    \\nprivate:\\n    int indexDataIfNot(string& data) {\\n        if(dataToIndex.find(data) != dataToIndex.end())\\n            return dataToIndex[data];\\n        int index = dataToIndex.size();\\n        dataToIndex[data] = index;\\n        indexToData[index] = data;\\n        return index;\\n    }\\n    \\n    string getData(int index) {\\n        return indexToData[index];\\n    }\\n    \\n    int getIndex(string& data) {\\n        return dataToIndex[data];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977092,
                "title": "c-pair-mapping-it-s-all-about-implementation",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int , pair<string , int>> lasttime ; \\n    unordered_map<string , vector<int>> intervals ; \\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        lasttime[id] = {stationName , t} ; \\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int totaltime = t - lasttime[id].second ; \\n        string laststation = lasttime[id].first ; \\n        string code = laststation + \"-\" + stationName ; \\n        \\n        intervals[code].push_back(totaltime) ;\\n        lasttime[id] = {stationName , t} ; \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        \\n        long long total = 0 ; \\n        string code = startStation + \"-\" + endStation ; \\n        \\n        for(auto i : intervals[code])\\n        {\\n            total += i ; \\n        }\\n        double ans = (total * 1.0) / (intervals[code].size() * 1.0) ; \\n        return ans ; \\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int , pair<string , int>> lasttime ; \\n    unordered_map<string , vector<int>> intervals ; \\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        lasttime[id] = {stationName , t} ; \\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int totaltime = t - lasttime[id].second ; \\n        string laststation = lasttime[id].first ; \\n        string code = laststation + \"-\" + stationName ; \\n        \\n        intervals[code].push_back(totaltime) ;\\n        lasttime[id] = {stationName , t} ; \\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        \\n        long long total = 0 ; \\n        string code = startStation + \"-\" + endStation ; \\n        \\n        for(auto i : intervals[code])\\n        {\\n            total += i ; \\n        }\\n        double ans = (total * 1.0) / (intervals[code].size() * 1.0) ; \\n        return ans ; \\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1976723,
                "title": "c-easy-solution",
                "content": "**C++ Solution Using Hashmap**\\n```\\nclass UndergroundSystem {\\n      unordered_map<int,pair<string,int>>m;\\n          unordered_map<string,unordered_map<string,pair<int,int>>>v;\\npublic:\\n    UndergroundSystem() { }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        m[id].first=stationName;\\n        m[id].second=t;\\n    }\\n    void checkOut(int id, string stationName, int t) {\\n        if(v[m[id].first].count(stationName)<=0){\\n            v[m[id].first][stationName].second=1;\\n            v[m[id].first][stationName].first=t-m[id].second;\\n        }\\n        else{\\n             v[m[id].first][stationName].second++;\\n            v[m[id].first][stationName].first+=t-m[id].second;\\n        }\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n    double j= (double)( (double)v[startStation][endStation].first/(double)v[startStation][endStation].second);\\n        return j;\\n    }\\n};\\n```\\n**Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\n      unordered_map<int,pair<string,int>>m;\\n          unordered_map<string,unordered_map<string,pair<int,int>>>v;\\npublic:\\n    UndergroundSystem() { }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        m[id].first=stationName;\\n        m[id].second=t;\\n    }\\n    void checkOut(int id, string stationName, int t) {\\n        if(v[m[id].first].count(stationName)<=0){\\n            v[m[id].first][stationName].second=1;\\n            v[m[id].first][stationName].first=t-m[id].second;\\n        }\\n        else{\\n             v[m[id].first][stationName].second++;\\n            v[m[id].first][stationName].first+=t-m[id].second;\\n        }\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n    double j= (double)( (double)v[startStation][endStation].first/(double)v[startStation][endStation].second);\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976575,
                "title": "java-hashmap-clean-solution-91ms",
                "content": "```\\nclass UndergroundSystem {\\n    HashMap<Integer, Record> userRecords;\\n    HashMap<String, Station> endStations;\\n    public UndergroundSystem() {\\n        userRecords = new HashMap<>();\\n        endStations = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        userRecords.put(id, new Record(id, stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Record record = userRecords.get(id);\\n        record.checkOut(stationName, t);\\n        Station station = endStations.get(stationName);\\n        if (station == null) {\\n            station = new Station();\\n            endStations.put(stationName, station);\\n        }\\n        station.saveRecord(record);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        Station station = endStations.get(endStation);\\n        if (station == null) return 0;\\n        return station.getAverageTime(startStation);\\n    }\\n    public class StationInfo {\\n        public double totalTime;\\n        public int totalCount;\\n        public double getAverage() {\\n            if (totalCount == 0) {\\n                return 0;\\n            }\\n            return totalTime / totalCount;\\n        }\\n    }\\n    // End Station\\n    public class Station {\\n        // Start Station Map\\n        public Map<String, StationInfo> map;\\n        public Station () {\\n            map = new HashMap<>();\\n        }\\n        public double getAverageTime(String startStation) {\\n            StationInfo info = map.get(startStation);\\n            if (info == null) return 0;\\n            return info.getAverage();\\n        }\\n        public void saveRecord(Record record) {\\n            String startStation = record.getStartStation();\\n            StationInfo info = map.get(startStation);\\n            if (info == null) {\\n                info = new StationInfo();\\n                map.put(startStation, info);\\n            }\\n            info.totalTime += record.getTime();\\n            info.totalCount++;\\n        }\\n    }\\n    public class Record {\\n        private int id;\\n        private int checkIn;\\n        private int checkOut;\\n        private String startStation;\\n        private String endStation;\\n        public Record(int id, String station, int checkIn) {\\n            this.id = id;\\n            this.checkIn = checkIn;\\n            this.startStation = station;\\n        }\\n        public void checkIn(String station, int checkIn) {\\n            this.checkIn = checkIn;\\n            this.startStation = station;\\n        }\\n        public void checkOut(String station, int checkOut) {\\n            this.checkOut = checkOut;\\n            this.endStation = station;\\n        }\\n        public String getStartStation() {\\n            return this.startStation;\\n        }\\n        public String getEndStation() {\\n            return this.endStation;\\n        }\\n        public int getTime() {\\n            return this.checkOut - this.checkIn;\\n        }\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    HashMap<Integer, Record> userRecords;\\n    HashMap<String, Station> endStations;\\n    public UndergroundSystem() {\\n        userRecords = new HashMap<>();\\n        endStations = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        userRecords.put(id, new Record(id, stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Record record = userRecords.get(id);\\n        record.checkOut(stationName, t);\\n        Station station = endStations.get(stationName);\\n        if (station == null) {\\n            station = new Station();\\n            endStations.put(stationName, station);\\n        }\\n        station.saveRecord(record);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        Station station = endStations.get(endStation);\\n        if (station == null) return 0;\\n        return station.getAverageTime(startStation);\\n    }\\n    public class StationInfo {\\n        public double totalTime;\\n        public int totalCount;\\n        public double getAverage() {\\n            if (totalCount == 0) {\\n                return 0;\\n            }\\n            return totalTime / totalCount;\\n        }\\n    }\\n    // End Station\\n    public class Station {\\n        // Start Station Map\\n        public Map<String, StationInfo> map;\\n        public Station () {\\n            map = new HashMap<>();\\n        }\\n        public double getAverageTime(String startStation) {\\n            StationInfo info = map.get(startStation);\\n            if (info == null) return 0;\\n            return info.getAverage();\\n        }\\n        public void saveRecord(Record record) {\\n            String startStation = record.getStartStation();\\n            StationInfo info = map.get(startStation);\\n            if (info == null) {\\n                info = new StationInfo();\\n                map.put(startStation, info);\\n            }\\n            info.totalTime += record.getTime();\\n            info.totalCount++;\\n        }\\n    }\\n    public class Record {\\n        private int id;\\n        private int checkIn;\\n        private int checkOut;\\n        private String startStation;\\n        private String endStation;\\n        public Record(int id, String station, int checkIn) {\\n            this.id = id;\\n            this.checkIn = checkIn;\\n            this.startStation = station;\\n        }\\n        public void checkIn(String station, int checkIn) {\\n            this.checkIn = checkIn;\\n            this.startStation = station;\\n        }\\n        public void checkOut(String station, int checkOut) {\\n            this.checkOut = checkOut;\\n            this.endStation = station;\\n        }\\n        public String getStartStation() {\\n            return this.startStation;\\n        }\\n        public String getEndStation() {\\n            return this.endStation;\\n        }\\n        public int getTime() {\\n            return this.checkOut - this.checkIn;\\n        }\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863218,
                "title": "design-underground-system-java-solution-using-2-hashmaps",
                "content": "The solution is pretty straight-forward if we can figure out what is to be used as the key in the HashMap. Here I have taken two HashMaps:\\n\\n(i) The first one stores **String vs List of Integers**. This one will use \"startStation + endStation\" string as a key and the list will store the time taken by different commuters to travel between these two stations. This will help us to calculate the average time easily.\\n\\n(ii) The second map will simply store **Integer vs String**. The commuter ID will be the key and \"startStation + checkInTime\" string will be the value against the key. This would make the check-out function easy as we would be able to split this string into two strings i.e startStation and checkInTime.\\n\\n```\\nclass UndergroundSystem {\\n    \\n    HashMap<String, List<Integer>> avg; \\n    HashMap<Integer, String> hm;\\n    \\n    public UndergroundSystem() {\\n        avg = new HashMap<>();\\n        hm = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        hm.put(id, stationName + \" \" + t);    // Storing the ID against the checkInStation and checkInTime\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        String s = hm.get(id);  // Fetch the checkInStation and checkInTime of this commuter\\n        String[] arr = s.split(\" \");  // Splitting the string to easily access the checkInStation and checkInTime\\n        \\n        int checkInTime = Integer.parseInt(arr[1]);  // Converting time string to Integer\\n        \\n        String startToEnd = arr[0] + \" \" + stationName;  // checkInStation to checkOutStation to be used as a key in the average time calculation map\\n        if(!avg.containsKey(startToEnd)){\\n            avg.put(startToEnd, new ArrayList());\\n        }\\n        \\n        avg.get(startToEnd).add(t - checkInTime);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String startToEnd = startStation + \" \" + endStation;\\n        \\n        List<Integer> time = avg.get(startToEnd);  // Get the list which contains travel times between checkInStation and checkOutStation \\n        double average = 0.0;\\n        \\n        for(int t: time){\\n            average += t;  // Summing up the travel times\\n        }\\n        \\n        return average/time.size();  // return average time\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    \\n    HashMap<String, List<Integer>> avg; \\n    HashMap<Integer, String> hm;\\n    \\n    public UndergroundSystem() {\\n        avg = new HashMap<>();\\n        hm = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        hm.put(id, stationName + \" \" + t);    // Storing the ID against the checkInStation and checkInTime\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        String s = hm.get(id);  // Fetch the checkInStation and checkInTime of this commuter\\n        String[] arr = s.split(\" \");  // Splitting the string to easily access the checkInStation and checkInTime\\n        \\n        int checkInTime = Integer.parseInt(arr[1]);  // Converting time string to Integer\\n        \\n        String startToEnd = arr[0] + \" \" + stationName;  // checkInStation to checkOutStation to be used as a key in the average time calculation map\\n        if(!avg.containsKey(startToEnd)){\\n            avg.put(startToEnd, new ArrayList());\\n        }\\n        \\n        avg.get(startToEnd).add(t - checkInTime);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String startToEnd = startStation + \" \" + endStation;\\n        \\n        List<Integer> time = avg.get(startToEnd);  // Get the list which contains travel times between checkInStation and checkOutStation \\n        double average = 0.0;\\n        \\n        for(int t: time){\\n            average += t;  // Summing up the travel times\\n        }\\n        \\n        return average/time.size();  // return average time\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520202,
                "title": "easy-to-understand-java-hashmaps",
                "content": "```\\nclass UndergroundSystem {\\n    \\n    public class StationDetails\\n    {\\n        int startTime;\\n        String stationName;\\n        \\n        public StationDetails(int _startTime, String _stationName)\\n        {\\n            startTime = _startTime;\\n            stationName = _stationName;\\n        }\\n    }\\n    \\n    public class TimeCount\\n    {\\n        int totalTime;\\n        int customerCount;\\n        \\n        public TimeCount(int _totalTime, int _customerCount)\\n        {\\n            totalTime = _totalTime;\\n            customerCount = _customerCount;\\n        }\\n    }\\n    \\n    Map<Integer, StationDetails> stationMap;    //station details per Customer checkin\\n    Map<String, TimeCount> timeCountMap;        //total time travelled between two stations\\n    \\n    public UndergroundSystem() {\\n        stationMap = new HashMap<>();\\n        timeCountMap = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        stationMap.put(id,new StationDetails(t, stationName));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        StationDetails firstStationDetails = stationMap.get(id);\\n        \\n        String mapId = firstStationDetails.stationName + \"--\" + stationName;\\n        \\n        if(timeCountMap.containsKey(mapId))\\n        {\\n            TimeCount timeCount = timeCountMap.get(mapId);\\n            \\n            int newTotalTime = timeCount.totalTime + (t - firstStationDetails.startTime);\\n            int newCustomerCount = timeCount.customerCount + 1;\\n            \\n            timeCountMap.put(mapId,new TimeCount(newTotalTime, newCustomerCount));\\n        }\\n        else\\n        {\\n            timeCountMap.put(mapId,new TimeCount(t - firstStationDetails.startTime, 1));\\n        }\\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        \\n        TimeCount timeCount = timeCountMap.get(startStation+ \"--\" + endStation);\\n        double totalTime = timeCount.totalTime;\\n        double customerCount = timeCount.customerCount;\\n        \\n        return totalTime/customerCount;\\n    }\\n}\\n\\n\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    \\n    public class StationDetails\\n    {\\n        int startTime;\\n        String stationName;\\n        \\n        public StationDetails(int _startTime, String _stationName)\\n        {\\n            startTime = _startTime;\\n            stationName = _stationName;\\n        }\\n    }\\n    \\n    public class TimeCount\\n    {\\n        int totalTime;\\n        int customerCount;\\n        \\n        public TimeCount(int _totalTime, int _customerCount)\\n        {\\n            totalTime = _totalTime;\\n            customerCount = _customerCount;\\n        }\\n    }\\n    \\n    Map<Integer, StationDetails> stationMap;    //station details per Customer checkin\\n    Map<String, TimeCount> timeCountMap;        //total time travelled between two stations\\n    \\n    public UndergroundSystem() {\\n        stationMap = new HashMap<>();\\n        timeCountMap = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        stationMap.put(id,new StationDetails(t, stationName));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        StationDetails firstStationDetails = stationMap.get(id);\\n        \\n        String mapId = firstStationDetails.stationName + \"--\" + stationName;\\n        \\n        if(timeCountMap.containsKey(mapId))\\n        {\\n            TimeCount timeCount = timeCountMap.get(mapId);\\n            \\n            int newTotalTime = timeCount.totalTime + (t - firstStationDetails.startTime);\\n            int newCustomerCount = timeCount.customerCount + 1;\\n            \\n            timeCountMap.put(mapId,new TimeCount(newTotalTime, newCustomerCount));\\n        }\\n        else\\n        {\\n            timeCountMap.put(mapId,new TimeCount(t - firstStationDetails.startTime, 1));\\n        }\\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        \\n        TimeCount timeCount = timeCountMap.get(startStation+ \"--\" + endStation);\\n        double totalTime = timeCount.totalTime;\\n        double customerCount = timeCount.customerCount;\\n        \\n        return totalTime/customerCount;\\n    }\\n}\\n\\n\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432349,
                "title": "c-easy-solution-95-beat-o-1",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int,pair<string,int>>mp1;\\n    unordered_map<string,pair<int,int>>mp2;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp1[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string g = mp1[id].first;\\n        string y = g+\\'-\\'+stationName;\\n        int new_time = t - mp1[id].second;\\n        if(mp2.find(y)==mp2.end())\\n        {\\n            mp2[y]={new_time,1};\\n        }\\n        else\\n        {\\n            mp2[y].first+=new_time;\\n            mp2[y].second++;\\n        }\\n        mp1.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string j = startStation+\\'-\\'+endStation;\\n        int sum =mp2[j].first;\\n        int total = mp2[j].second;\\n        double ans = (double)sum/(double)total;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int,pair<string,int>>mp1;\\n    unordered_map<string,pair<int,int>>mp2;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp1[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string g = mp1[id].first;\\n        string y = g+\\'-\\'+stationName;\\n        int new_time = t - mp1[id].second;\\n        if(mp2.find(y)==mp2.end())\\n        {\\n            mp2[y]={new_time,1};\\n        }\\n        else\\n        {\\n            mp2[y].first+=new_time;\\n            mp2[y].second++;\\n        }\\n        mp1.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string j = startStation+\\'-\\'+endStation;\\n        int sum =mp2[j].first;\\n        int total = mp2[j].second;\\n        double ans = (double)sum/(double)total;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173430,
                "title": "c-oop-ish-fun-efficient-easy-to-code-read",
                "content": "Obviously in an actual interview, they\\'d expect us to ask some what if questions to clarify the problem. But here it\\'s super well scoped, very constrained.\\n\\n```\\nclass UndergroundSystem {\\nprivate:\\n    struct EntryRecord { string station; int time; };\\n\\n    struct TimeRecord {\\n        unsigned long long int totalTravelTime, numTravels;\\n\\n        TimeRecord(): totalTravelTime(0), numTravels(0) {}\\n\\n        double avg() { return 1.0 * totalTravelTime / numTravels; }\\n\\n        void addTravel(unsigned long long int travelTime) {\\n            totalTravelTime += travelTime;\\n            ++numTravels;\\n        }\\n    };\\n\\n    unordered_map<int, EntryRecord> idToEntryStation;\\n    unordered_map<string, map<string, TimeRecord>> stationMap;\\npublic:\\n    UndergroundSystem() {}\\n    \\n    void checkIn(int id, string entryStation, int entryTime) {\\n        // if id already checked in??\\n        idToEntryStation[id] = {entryStation, entryTime};\\n    }\\n\\n    void checkOut(int id, string exitStation, int exitTime) {\\n        auto [entryStation, entryTime] = idToEntryStation[id];\\n        // if id not checked in??\\n        idToEntryStation.erase(id);\\n\\n        stationMap[entryStation][exitStation].addTravel(exitTime - entryTime);\\n    }\\n\\n    double getAverageTime(string entryStation, string exitStation) {\\n        // if we have no records?!@#\\n        return stationMap[entryStation][exitStation].avg();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\nprivate:\\n    struct EntryRecord { string station; int time; };\\n\\n    struct TimeRecord {\\n        unsigned long long int totalTravelTime, numTravels;\\n\\n        TimeRecord(): totalTravelTime(0), numTravels(0) {}\\n\\n        double avg() { return 1.0 * totalTravelTime / numTravels; }\\n\\n        void addTravel(unsigned long long int travelTime) {\\n            totalTravelTime += travelTime;\\n            ++numTravels;\\n        }\\n    };\\n\\n    unordered_map<int, EntryRecord> idToEntryStation;\\n    unordered_map<string, map<string, TimeRecord>> stationMap;\\npublic:\\n    UndergroundSystem() {}\\n    \\n    void checkIn(int id, string entryStation, int entryTime) {\\n        // if id already checked in??\\n        idToEntryStation[id] = {entryStation, entryTime};\\n    }\\n\\n    void checkOut(int id, string exitStation, int exitTime) {\\n        auto [entryStation, entryTime] = idToEntryStation[id];\\n        // if id not checked in??\\n        idToEntryStation.erase(id);\\n\\n        stationMap[entryStation][exitStation].addTravel(exitTime - entryTime);\\n    }\\n\\n    double getAverageTime(string entryStation, string exitStation) {\\n        // if we have no records?!@#\\n        return stationMap[entryStation][exitStation].avg();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125839,
                "title": "javascript-o-1-time-using-2-maps-es6-class",
                "content": "All operations cost `O(1)` time\\n```javascript\\nclass Person {\\n    constructor(station, startTime) {\\n        this.startStation = station;\\n        this.startTime = startTime;\\n    }\\n}\\n\\nclass UndergroundSystem {\\n    constructor() {\\n        this.people = new Map();\\n        this.stations = new Map();\\n    }\\n    \\n    checkIn(id, stationName, t) {\\n        const customer = new Person(stationName, t);\\n        this.people.set(id, customer);\\n    }\\n    \\n    checkOut(id, endStation, t) {\\n        const { startStation, startTime } = this.people.get(id);\\n        \\n        if(!this.stations.has(startStation)) this.stations.set(startStation, new Map());\\n        const start = this.stations.get(startStation);\\n        \\n        if(!start.has(endStation)) start.set(endStation, [0, 0]);\\n        const end = start.get(endStation)\\n        \\n        end[0] += t - startTime;;\\n        end[1]++\\n    }\\n    \\n    getAverageTime(startStation, endStation) {\\n        const [total, count] = this.stations.get(startStation).get(endStation);\\n        return total / count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass Person {\\n    constructor(station, startTime) {\\n        this.startStation = station;\\n        this.startTime = startTime;\\n    }\\n}\\n\\nclass UndergroundSystem {\\n    constructor() {\\n        this.people = new Map();\\n        this.stations = new Map();\\n    }\\n    \\n    checkIn(id, stationName, t) {\\n        const customer = new Person(stationName, t);\\n        this.people.set(id, customer);\\n    }\\n    \\n    checkOut(id, endStation, t) {\\n        const { startStation, startTime } = this.people.get(id);\\n        \\n        if(!this.stations.has(startStation)) this.stations.set(startStation, new Map());\\n        const start = this.stations.get(startStation);\\n        \\n        if(!start.has(endStation)) start.set(endStation, [0, 0]);\\n        const end = start.get(endStation)\\n        \\n        end[0] += t - startTime;;\\n        end[1]++\\n    }\\n    \\n    getAverageTime(startStation, endStation) {\\n        const [total, count] = this.stations.get(startStation).get(endStation);\\n        return total / count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124807,
                "title": "very-easy-python3-beats-99-runtime",
                "content": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.checkIns = {}\\n        self.times = {}\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkIns[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        try:\\n            self.times[self.checkIns[id][0] + \"-\" + stationName].append(t-self.checkIns[id][1])\\n        except KeyError:\\n            self.times[self.checkIns[id][0] + \"-\" + stationName] = [t-self.checkIns[id][1]]\\n            \\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        return sum(self.times[startStation + \"-\" + endStation])/len(self.times[startStation + \"-\" + endStation])\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.checkIns = {}\\n        self.times = {}\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkIns[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        try:\\n            self.times[self.checkIns[id][0] + \"-\" + stationName].append(t-self.checkIns[id][1])\\n        except KeyError:\\n            self.times[self.checkIns[id][0] + \"-\" + stationName] = [t-self.checkIns[id][1]]\\n            \\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        return sum(self.times[startStation + \"-\" + endStation])/len(self.times[startStation + \"-\" + endStation])\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119098,
                "title": "1396-design-underground-system-go-golang-solution-short",
                "content": "I solved this problem way back then at weekly contest 182 in Python (took maybe a few minutes), and it popped up today in a daily contest, so this is my Golang version (it accumulates time as [sum, count] so GetAverageTime is constant). I was going to use typeless interface (Pair struct) as in Python but ended up with typed structures.\\n\\n```go\\ntype StationTime struct {\\n\\tstation string\\n\\ttime    int\\n}\\n\\ntype UndergroundSystem struct {\\n\\tids map[int]StationTime\\n\\tavg map[[2]string][2]int\\n}\\n\\nfunc Constructor() UndergroundSystem {\\n\\treturn UndergroundSystem{map[int]StationTime{}, map[[2]string][2]int{}}\\n}\\n\\nfunc (this *UndergroundSystem) CheckIn(id int, stationName string, t int) {\\n\\tthis.ids[id] = StationTime{stationName, t}\\n}\\n\\nfunc (this *UndergroundSystem) CheckOut(id int, stationName string, t int) {\\n\\tstart := this.ids[id]\\n\\tdelete(this.ids, id)\\n\\tkey := [2]string{start.station, stationName}\\n\\tv := this.avg[key]\\n\\tthis.avg[key] = [2]int{v[0] + t - start.time, v[1] + 1}\\n}\\n\\nfunc (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 {\\n\\tv := this.avg[[2]string{startStation, endStation}]\\n\\treturn float64(v[0]) / float64(v[1])\\n}\\n```\\n\\n\"Pythonic\" solution with interfaces is about 2x slower:\\n\\n```go\\ntype UndergroundSystem [2]map[interface{}]interface{}\\nfunc Constructor() UndergroundSystem {\\n\\treturn [2]map[interface{}]interface{}{{}, {}}\\n}\\nfunc (us *UndergroundSystem) CheckIn(i, s, t interface{}) {\\n\\tus[0][i] = [2]interface{}{s, t}\\n}\\nfunc (us *UndergroundSystem) CheckOut(i, s, t interface{}) {\\n\\tplace := us[0][i].([2]interface{})\\n\\troute := [2]string{place[0].(string), s.(string)}\\n\\tstate, _ := us[1][route].([2]int)\\n\\tus[1][route] = [2]int{state[0] + t.(int) - place[1].(int), state[1] + 1}\\n}\\nfunc (us *UndergroundSystem) GetAverageTime(s, e string) float64 {\\n\\tstate := us[1][[2]string{s, e}].([2]int)\\n\\treturn float64(state[0]) / float64(state[1])\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype StationTime struct {\\n\\tstation string\\n\\ttime    int\\n}\\n\\ntype UndergroundSystem struct {\\n\\tids map[int]StationTime\\n\\tavg map[[2]string][2]int\\n}\\n\\nfunc Constructor() UndergroundSystem {\\n\\treturn UndergroundSystem{map[int]StationTime{}, map[[2]string][2]int{}}\\n}\\n\\nfunc (this *UndergroundSystem) CheckIn(id int, stationName string, t int) {\\n\\tthis.ids[id] = StationTime{stationName, t}\\n}\\n\\nfunc (this *UndergroundSystem) CheckOut(id int, stationName string, t int) {\\n\\tstart := this.ids[id]\\n\\tdelete(this.ids, id)\\n\\tkey := [2]string{start.station, stationName}\\n\\tv := this.avg[key]\\n\\tthis.avg[key] = [2]int{v[0] + t - start.time, v[1] + 1}\\n}\\n\\nfunc (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 {\\n\\tv := this.avg[[2]string{startStation, endStation}]\\n\\treturn float64(v[0]) / float64(v[1])\\n}\\n```\n```go\\ntype UndergroundSystem [2]map[interface{}]interface{}\\nfunc Constructor() UndergroundSystem {\\n\\treturn [2]map[interface{}]interface{}{{}, {}}\\n}\\nfunc (us *UndergroundSystem) CheckIn(i, s, t interface{}) {\\n\\tus[0][i] = [2]interface{}{s, t}\\n}\\nfunc (us *UndergroundSystem) CheckOut(i, s, t interface{}) {\\n\\tplace := us[0][i].([2]interface{})\\n\\troute := [2]string{place[0].(string), s.(string)}\\n\\tstate, _ := us[1][route].([2]int)\\n\\tus[1][route] = [2]int{state[0] + t.(int) - place[1].(int), state[1] + 1}\\n}\\nfunc (us *UndergroundSystem) GetAverageTime(s, e string) float64 {\\n\\tstate := us[1][[2]string{s, e}].([2]int)\\n\\treturn float64(state[0]) / float64(state[1])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1118147,
                "title": "java-hashmap-of-hashmaps",
                "content": "```\\nclass UndergroundSystem {\\n    class TravelTime {\\n        int totalTime;\\n        int count;\\n        TravelTime(int tt, int c)   {\\n            totalTime = tt;\\n            count = c;\\n        }\\n    }\\n    class Ticket {\\n        String station;\\n        int time;\\n        Ticket(String st, int t)    {\\n            station = st;\\n            time = t;\\n        }\\n    }\\n    HashMap<String, HashMap<String, TravelTime>> time_map;\\n    HashMap<Integer, Ticket> ticket_map;\\n\\n    public UndergroundSystem() {\\n        time_map = new HashMap<>();\\n        ticket_map = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        Ticket tkt = new Ticket(stationName, t);\\n        ticket_map.put(id, tkt);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Ticket tkt = ticket_map.get(id);\\n        ticket_map.remove(id);\\n        if (!time_map.containsKey(tkt.station))   {\\n            time_map.put(tkt.station, new HashMap<>());\\n        }\\n        HashMap<String, TravelTime> map = time_map.get(tkt.station);\\n        if (!map.containsKey(stationName))  {\\n            TravelTime tt  = new TravelTime(t-tkt.time,1);\\n            map.put(stationName, tt);\\n        }\\n        else    {\\n            TravelTime tt  = map.get(stationName);\\n            tt.totalTime += t-tkt.time;\\n            tt.count++;\\n        }\\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        HashMap<String, TravelTime> map = time_map.get(startStation);\\n        TravelTime tt = map.get(endStation);\\n        return (double)tt.totalTime/tt.count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n    class TravelTime {\\n        int totalTime;\\n        int count;\\n        TravelTime(int tt, int c)   {\\n            totalTime = tt;\\n            count = c;\\n        }\\n    }\\n    class Ticket {\\n        String station;\\n        int time;\\n        Ticket(String st, int t)    {\\n            station = st;\\n            time = t;\\n        }\\n    }\\n    HashMap<String, HashMap<String, TravelTime>> time_map;\\n    HashMap<Integer, Ticket> ticket_map;\\n\\n    public UndergroundSystem() {\\n        time_map = new HashMap<>();\\n        ticket_map = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        Ticket tkt = new Ticket(stationName, t);\\n        ticket_map.put(id, tkt);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Ticket tkt = ticket_map.get(id);\\n        ticket_map.remove(id);\\n        if (!time_map.containsKey(tkt.station))   {\\n            time_map.put(tkt.station, new HashMap<>());\\n        }\\n        HashMap<String, TravelTime> map = time_map.get(tkt.station);\\n        if (!map.containsKey(stationName))  {\\n            TravelTime tt  = new TravelTime(t-tkt.time,1);\\n            map.put(stationName, tt);\\n        }\\n        else    {\\n            TravelTime tt  = map.get(stationName);\\n            tt.totalTime += t-tkt.time;\\n            tt.count++;\\n        }\\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        HashMap<String, TravelTime> map = time_map.get(startStation);\\n        TravelTime tt = map.get(endStation);\\n        return (double)tt.totalTime/tt.count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021434,
                "title": "python-easy-solution-two-maps",
                "content": "Hi made a simple solution. Was wondering if it would be better to calculate running average, calculate average at every step, or anything else. Some solutions sum the values at calculation, and divide by len but I thought that would be costly. Looking for improvements.\\n\\n```\\n    def __init__(self):\\n        self.averages = dict()\\n        self.checkins = dict()\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkins[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        \\n        fro, t1 = self.checkins[id]\\n        del self.checkins[id]\\n        route = fro+\"_\"+stationName\\n        total, n = self.averages.get(route, (0,0))\\n        self.averages[route] = (total+(t-t1), n+1)\\n        \\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        \\n        t, n = self.averages[startStation+\"_\"+endStation]\\n        return t/n\\n```",
                "solutionTags": [],
                "code": "```\\n    def __init__(self):\\n        self.averages = dict()\\n        self.checkins = dict()\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkins[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        \\n        fro, t1 = self.checkins[id]\\n        del self.checkins[id]\\n        route = fro+\"_\"+stationName\\n        total, n = self.averages.get(route, (0,0))\\n        self.averages[route] = (total+(t-t1), n+1)\\n        \\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        \\n        t, n = self.averages[startStation+\"_\"+endStation]\\n        return t/n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 982859,
                "title": "simple-and-faster-than-99-10-explanation-with-comments-c",
                "content": "class UndergroundSystem {\\npublic:\\n\\n    \\n    \\n\\tunordered_map<int, pair<string, int>> In;  //CheckIn map: <id, <start stationName, start time>>\\n    unordered_map<string, pair<double, int>> Avg;  //Average map: <start+end(concatenated station), <sum of all(end-start time), count of same pair of station occurance>>\\n\\tUndergroundSystem() {\\n    \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        \\n        In[id] = {stationName, t};  // simply add the pair to the checkIn map\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        \\n        string str= In[id].first + stationName; //concatenate the start and end station name.\\n        int time = t-In[id].second;     //checkOut time - checkIn time\\n        \\n        Avg[str] = make_pair(Avg[str].first + time, Avg[str].second + 1); //{prev summation time + current time, increase the occurance of the same pair of station count by 1}\\n        In.erase(id); //erase data from checkIn map.\\n        \\n    }\\n    \\n    double getAverageTime(string str1, string str2) {\\n        \\n        string str = str1+str2;     //concatenate both station name \\n        return (Avg[str].first/Avg[str].second);    //sum of time/count of occurance\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class UndergroundSystem {\\npublic:\\n\\n    \\n    \\n\\tunordered_map<int, pair<string, int>> In;  //CheckIn map: <id, <start stationName, start time>>\\n    unordered_map<string, pair<double, int>> Avg;  //Average map: <start+end(concatenated station), <sum of all(end-start time), count of same pair of station occurance>>\\n\\tUndergroundSystem() {\\n    \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        \\n        In[id] = {stationName, t};  // simply add the pair to the checkIn map\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        \\n        string str= In[id].first + stationName; //concatenate the start and end station name.\\n        int time = t-In[id].second;     //checkOut time - checkIn time\\n        \\n        Avg[str] = make_pair(Avg[str].first + time, Avg[str].second + 1); //{prev summation time + current time, increase the occurance of the same pair of station count by 1}\\n        In.erase(id); //erase data from checkIn map.\\n        \\n    }\\n    \\n    double getAverageTime(string str1, string str2) {\\n        \\n        string str = str1+str2;     //concatenate both station name \\n        return (Avg[str].first/Avg[str].second);    //sum of time/count of occurance\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 982403,
                "title": "javascript-using-map",
                "content": "```\\n\\nvar UndergroundSystem = function() {\\n    this.checkIns = new Map();\\n    this.timeBetweenStations = new Map();\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkIn = function(id, stationName, t) {\\n    this.checkIns.set(id, { stationName, time: t });\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkOut = function(id, stationName, t) {\\n    const checkInStation = this.checkIns.get(id);\\n    \\n    if (!checkInStation) {\\n        throw new Error(\\'This user has no check in\\');\\n    }\\n    \\n    const stationsRoute = `${checkInStation.stationName} - ${stationName}`;\\n    const duration = t - checkInStation.time;\\n    \\n    if (this.timeBetweenStations.has(stationsRoute)) {\\n        this.timeBetweenStations.set(\\n            stationsRoute, { \\n                total: this.timeBetweenStations.get(stationsRoute).total + duration,\\n                count: this.timeBetweenStations.get(stationsRoute).count + 1,\\n            }\\n        );\\n    } else {\\n        this.timeBetweenStations.set(\\n            stationsRoute, { \\n                total: duration,\\n                count: 1,\\n            }\\n        );\\n    }\\n};\\n\\n/** \\n * @param {string} startStation \\n * @param {string} endStation\\n * @return {number}\\n */\\nUndergroundSystem.prototype.getAverageTime = function(startStation, endStation) {\\n    const stationsRoute = `${startStation} - ${endStation}`;\\n    \\n    if (this.timeBetweenStations.has(stationsRoute)) {\\n        return this.timeBetweenStations.get(stationsRoute).total / this.timeBetweenStations.get(stationsRoute).count;\\n    }\\n    \\n    return null;\\n};\\n\\n/** \\n * Your UndergroundSystem object will be instantiated and called as such:\\n * var obj = new UndergroundSystem()\\n * obj.checkIn(id,stationName,t)\\n * obj.checkOut(id,stationName,t)\\n * var param_3 = obj.getAverageTime(startStation,endStation)\\n */",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar UndergroundSystem = function() {\\n    this.checkIns = new Map();\\n    this.timeBetweenStations = new Map();\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkIn = function(id, stationName, t) {\\n    this.checkIns.set(id, { stationName, time: t });\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkOut = function(id, stationName, t) {\\n    const checkInStation = this.checkIns.get(id);\\n    \\n    if (!checkInStation) {\\n        throw new Error(\\'This user has no check in\\');\\n    }\\n    \\n    const stationsRoute = `${checkInStation.stationName} - ${stationName}`;\\n    const duration = t - checkInStation.time;\\n    \\n    if (this.timeBetweenStations.has(stationsRoute)) {\\n        this.timeBetweenStations.set(\\n            stationsRoute, { \\n                total: this.timeBetweenStations.get(stationsRoute).total + duration,\\n                count: this.timeBetweenStations.get(stationsRoute).count + 1,\\n            }\\n        );\\n    } else {\\n        this.timeBetweenStations.set(\\n            stationsRoute, { \\n                total: duration,\\n                count: 1,\\n            }\\n        );\\n    }\\n};\\n\\n/** \\n * @param {string} startStation \\n * @param {string} endStation\\n * @return {number}\\n */\\nUndergroundSystem.prototype.getAverageTime = function(startStation, endStation) {\\n    const stationsRoute = `${startStation} - ${endStation}`;\\n    \\n    if (this.timeBetweenStations.has(stationsRoute)) {\\n        return this.timeBetweenStations.get(stationsRoute).total / this.timeBetweenStations.get(stationsRoute).count;\\n    }\\n    \\n    return null;\\n};\\n\\n/** \\n * Your UndergroundSystem object will be instantiated and called as such:\\n * var obj = new UndergroundSystem()\\n * obj.checkIn(id,stationName,t)\\n * obj.checkOut(id,stationName,t)\\n * var param_3 = obj.getAverageTime(startStation,endStation)\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 932488,
                "title": "java-using-hashmap",
                "content": "Can\\'t believe this is the question I\\'ve got during my Bloomberg interview years ago!\\n1. Key point is \"in chronological order\", so one id checks in station1 and then must checkout at station2, before he can check into another station.\\n2. One id can checkin and checkout the same station multiple times.\\nSo as long as we understand the above, this is simple question.\\n\\n```\\nclass UndergroundSystem {\\n\\n    Map<Integer, Node> checkInMap; // <id, <station, time>>\\n    Map<String, int[]> summary; // <s1_s2, [sum time, count]> \\n    public UndergroundSystem() {\\n        checkInMap = new HashMap<>();\\n        summary = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkInMap.put(id, new Node(stationName, t));\\n        \\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n\\t    // So here there must be key \"id\" in checkInMap !\\n        Node node = checkInMap.get(id);\\n        String key = node.station + \"_\" + stationName;\\n        int deltaT = t - node.t;\\n        \\n        if (!summary.containsKey(key)) {\\n            summary.put(key, new int[]{deltaT, 1});\\n        } else {\\n            int[] arr = summary.get(key);\\n            summary.put(key, new int[]{arr[0] + deltaT, arr[1] + 1});\\n        }\\n        // If wanna further optimize the space.\\n\\t\\tcheckInMap.remove(id);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = startStation + \"_\" + endStation;\\n        if (!summary.containsKey(key)) return -1;\\n        int[] arr = summary.get(key);\\n        return (double) arr[0] / arr[1];\\n    }\\n}\\n\\nclass Node {\\n    String station;\\n    int t;\\n    Node(String station, int t) {\\n        this.station = station;\\n        this.t = t;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n\\n    Map<Integer, Node> checkInMap; // <id, <station, time>>\\n    Map<String, int[]> summary; // <s1_s2, [sum time, count]> \\n    public UndergroundSystem() {\\n        checkInMap = new HashMap<>();\\n        summary = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkInMap.put(id, new Node(stationName, t));\\n        \\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n\\t    // So here there must be key \"id\" in checkInMap !\\n        Node node = checkInMap.get(id);\\n        String key = node.station + \"_\" + stationName;\\n        int deltaT = t - node.t;\\n        \\n        if (!summary.containsKey(key)) {\\n            summary.put(key, new int[]{deltaT, 1});\\n        } else {\\n            int[] arr = summary.get(key);\\n            summary.put(key, new int[]{arr[0] + deltaT, arr[1] + 1});\\n        }\\n        // If wanna further optimize the space.\\n\\t\\tcheckInMap.remove(id);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = startStation + \"_\" + endStation;\\n        if (!summary.containsKey(key)) return -1;\\n        int[] arr = summary.get(key);\\n        return (double) arr[0] / arr[1];\\n    }\\n}\\n\\nclass Node {\\n    String station;\\n    int t;\\n    Node(String station, int t) {\\n        this.station = station;\\n        this.t = t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919447,
                "title": "java-solution-user-and-station-class-oop-design",
                "content": "### User and Station\\nObviously there are 1 million better answers out there, but here I am trying to implement it in an extensible way.\\nSplitting User and Station class makes it possible to do validation on checkIn and checkOut. Moreover, I could not imagine a system without User and Station object, unless the only thing you care is Route and nothing more.\\nI was debating whether to let User has real Station object rather than just a String, since String is immutable and you can imagine there will be a lot reassigning on the value. But in the end I feel the User doesn\\'t really need to have access to the Station, so I just let Garbage Collection handle the String reassign, and use a boolean to assist validation.\\n\\n### AverageTime\\nOn returning Average time, if the requests are very frequent, you can consider another map to store the result rather than doing calculation on every single request.\\n\\nAnother discussion is on the size of the value. You can imagine the accumulation and count would be very big after some time, and converting Integer to Long is not a final solution (Just imagine NY subway system).\\nWhat you could do is to update the average value on the subsections (or whatever value based off the real scenarios)\\nExample:\\nTravelTime: [3, 3, 4, 2, 5, 6, 2]. Avg = (3 + 3 + 4 + 2 + 5 + 6 + 2) /  7 = 3.57\\nAvg for first three (3 + 3 + 4) / 3 = 3.33\\nAvg for second three (2 + 5 + 6) / 3 = 4.33\\nAvg for all: (3.33 * 3/7) + (4.33 * 3/7) + (2 * 1/7)\\nSo we can reduce the size of number by having more divisions.\\n\\n```\\nclass UndergroundSystem {\\n    HashMap<Integer, User> userMap;\\n    HashMap<String, Station> stationMap;\\n    \\n    public UndergroundSystem() {\\n        userMap = new HashMap();\\n        stationMap = new HashMap();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        User user = getUser(id);\\n        user.checkIn(stationName, t);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        User user = getUser(id);\\n        String startStationName = user.getStation();\\n        int travelTime = user.checkOut(stationName, t);\\n\\t\\t// It may look weird to create a StartStation when checkout, but the question does not require it anywhere else so just be it\\n        Station startStation = getStation(startStationName);\\n        startStation.accumulateTravelTime(stationName, travelTime);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        return stationMap.get(startStation).getAverageTime(endStation);\\n    }\\n    \\n    private User getUser(Integer id) {\\n        if(!userMap.containsKey(id)) {\\n            userMap.put(id, new User(id));\\n        }\\n\\n        return userMap.get(id);\\n    }\\n    private Station getStation(String stationName){\\n        if(!stationMap.containsKey(stationName)) {\\n            stationMap.put(stationName, new Station(stationName));\\n        }\\n\\n        return stationMap.get(stationName);\\n    }\\n}\\n\\nclass User {\\n    private String station;\\n    private Integer checkedIn;\\n    private int id;\\n    private boolean onTravel;\\n\\n    User(int id) {\\n        this.id = id;\\n        this.station = null;\\n        this.checkedIn = null;\\n        this.onTravel = false;\\n    }\\n    public void checkIn(String station, int t) {\\n        if(this.onTravel) {\\n            throw new RuntimeException();\\n        }\\n\\n        this.station = station;\\n        this.checkedIn = Integer.valueOf(t);\\n        this.onTravel = true;\\n    }\\n    public int checkOut(String station, int t) {\\n        if(!this.onTravel) {\\n            throw new RuntimeException();\\n        }\\n\\n        int res = t - this.checkedIn;\\n        this.onTravel = false;\\n        return res;\\n    }\\n    public String getStation(){\\n        return station;\\n    }\\n}\\n\\nclass Station {\\n    HashMap<String, Integer> accumulationTime;\\n    HashMap<String, Integer> travelCount;\\n    String stationName;\\n\\n    Station(String stationName){\\n        this.accumulationTime = new HashMap();\\n        this.travelCount = new HashMap();\\n        this.stationName = stationName;\\n    }\\n    public void accumulateTravelTime(String endStation, int travelTime) {\\n        accumulationTime.put(endStation, accumulationTime.getOrDefault(endStation, 0) + travelTime);\\n        travelCount.put(endStation, travelCount.getOrDefault(endStation, 0) + 1);\\n    }\\n    public double getAverageTime(String endStation) {\\n        return (double)accumulationTime.get(endStation) / travelCount.get(endStation);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n    HashMap<Integer, User> userMap;\\n    HashMap<String, Station> stationMap;\\n    \\n    public UndergroundSystem() {\\n        userMap = new HashMap();\\n        stationMap = new HashMap();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        User user = getUser(id);\\n        user.checkIn(stationName, t);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        User user = getUser(id);\\n        String startStationName = user.getStation();\\n        int travelTime = user.checkOut(stationName, t);\\n\\t\\t// It may look weird to create a StartStation when checkout, but the question does not require it anywhere else so just be it\\n        Station startStation = getStation(startStationName);\\n        startStation.accumulateTravelTime(stationName, travelTime);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        return stationMap.get(startStation).getAverageTime(endStation);\\n    }\\n    \\n    private User getUser(Integer id) {\\n        if(!userMap.containsKey(id)) {\\n            userMap.put(id, new User(id));\\n        }\\n\\n        return userMap.get(id);\\n    }\\n    private Station getStation(String stationName){\\n        if(!stationMap.containsKey(stationName)) {\\n            stationMap.put(stationName, new Station(stationName));\\n        }\\n\\n        return stationMap.get(stationName);\\n    }\\n}\\n\\nclass User {\\n    private String station;\\n    private Integer checkedIn;\\n    private int id;\\n    private boolean onTravel;\\n\\n    User(int id) {\\n        this.id = id;\\n        this.station = null;\\n        this.checkedIn = null;\\n        this.onTravel = false;\\n    }\\n    public void checkIn(String station, int t) {\\n        if(this.onTravel) {\\n            throw new RuntimeException();\\n        }\\n\\n        this.station = station;\\n        this.checkedIn = Integer.valueOf(t);\\n        this.onTravel = true;\\n    }\\n    public int checkOut(String station, int t) {\\n        if(!this.onTravel) {\\n            throw new RuntimeException();\\n        }\\n\\n        int res = t - this.checkedIn;\\n        this.onTravel = false;\\n        return res;\\n    }\\n    public String getStation(){\\n        return station;\\n    }\\n}\\n\\nclass Station {\\n    HashMap<String, Integer> accumulationTime;\\n    HashMap<String, Integer> travelCount;\\n    String stationName;\\n\\n    Station(String stationName){\\n        this.accumulationTime = new HashMap();\\n        this.travelCount = new HashMap();\\n        this.stationName = stationName;\\n    }\\n    public void accumulateTravelTime(String endStation, int travelTime) {\\n        accumulationTime.put(endStation, accumulationTime.getOrDefault(endStation, 0) + travelTime);\\n        travelCount.put(endStation, travelCount.getOrDefault(endStation, 0) + 1);\\n    }\\n    public double getAverageTime(String endStation) {\\n        return (double)accumulationTime.get(endStation) / travelCount.get(endStation);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778307,
                "title": "python-simple-dual-dictionary-solution",
                "content": "\\n    def __init__(self):\\n        self.entry = {}\\n        self.times = {}\\n    \\n    def checkIn(self, id, stationName, t):\\n        self.entry[id] = (stationName, t)\\n\\n    def checkOut(self, id, stationName, t):\\n        if self.entry.get(id)[0] + stationName not in self.times:\\n            self.times[self.entry.get(id)[0] + stationName] = [float(t - self.entry.get(id)[1])]\\n        else:\\n            self.times[self.entry.get(id)[0] + stationName].append(float(t - self.entry.get(id)[1]))\\n        \\n    def getAverageTime(self, startStation, endStation):\\n        \\n        return sum(self.times.get(startStation + endStation)) / len(self.times.get(startStation + endStation))\\n",
                "solutionTags": [],
                "code": "\\n    def __init__(self):\\n        self.entry = {}\\n        self.times = {}\\n    \\n    def checkIn(self, id, stationName, t):\\n        self.entry[id] = (stationName, t)\\n\\n    def checkOut(self, id, stationName, t):\\n        if self.entry.get(id)[0] + stationName not in self.times:\\n            self.times[self.entry.get(id)[0] + stationName] = [float(t - self.entry.get(id)[1])]\\n        else:\\n            self.times[self.entry.get(id)[0] + stationName].append(float(t - self.entry.get(id)[1]))\\n        \\n    def getAverageTime(self, startStation, endStation):\\n        \\n        return sum(self.times.get(startStation + endStation)) / len(self.times.get(startStation + endStation))\\n",
                "codeTag": "Python3"
            },
            {
                "id": 586662,
                "title": "simple-python-solution",
                "content": "````\\nclass UndergroundSystem:\\n    def __init__(self):        \\n        self.startJrnData ={}\\n        self.journeyData = collections.defaultdict(lambda: [0,0])         \\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.startJrnData[id] = [stationName,t]       \\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        startStation, startTime = self.startJrnData.pop(id)\\n        self.journeyData[(startStation,stationName)][0] += t-startTime\\n        self.journeyData[(startStation,stationName)][1] += 1       \\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:        \\n        if self.journeyData[(startStation, endStation)][1] == 0 : return (0)\\n        return( self.journeyData[(startStation,endStation)][0]/ self.journeyData[(startStation, endStation)][1])\\n```\\n",
                "solutionTags": [],
                "code": "````\\nclass UndergroundSystem:\\n    def __init__(self):        \\n        self.startJrnData ={}\\n        self.journeyData = collections.defaultdict(lambda: [0,0])         \\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.startJrnData[id] = [stationName,t]       \\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        startStation, startTime = self.startJrnData.pop(id)\\n        self.journeyData[(startStation,stationName)][0] += t-startTime\\n        self.journeyData[(startStation,stationName)][1] += 1       \\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:        \\n        if self.journeyData[(startStation, endStation)][1] == 0 : return (0)\\n        return( self.journeyData[(startStation,endStation)][0]/ self.journeyData[(startStation, endStation)][1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555774,
                "title": "c-6-lines-using-unordered-map",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        prevStation[id] = {t, stationName};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        travelTimes[prevStation[id].second + stationName].first += t - prevStation[id].first;\\n        travelTimes[prevStation[id].second + stationName].second++;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return travelTimes[startStation + endStation].first / ( travelTimes[startStation + endStation].second + 0.0);\\n    }\\n    \\nprivate:\\n    unordered_map<string,pair<int,int>> travelTimes;\\n    unordered_map<int,pair<int,string>> prevStation;\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        prevStation[id] = {t, stationName};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        travelTimes[prevStation[id].second + stationName].first += t - prevStation[id].first;\\n        travelTimes[prevStation[id].second + stationName].second++;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return travelTimes[startStation + endStation].first / ( travelTimes[startStation + endStation].second + 0.0);\\n    }\\n    \\nprivate:\\n    unordered_map<string,pair<int,int>> travelTimes;\\n    unordered_map<int,pair<int,string>> prevStation;\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555001,
                "title": "very-easy-c-solution",
                "content": "```\\n    public class UndergroundSystem\\n    {\\n\\n        private readonly IDictionary<int, (string station, int t)> _currentCheckins;\\n        private readonly IDictionary<string, (int sum, int count)> _travels;\\n\\n        public UndergroundSystem()\\n        {\\n            _currentCheckins = new Dictionary<int, (string station, int t)>();\\n            _travels = new Dictionary<string, (int sum, int count)>();\\n        }\\n\\n        public void CheckIn(int id, string stationName, int t)\\n        {\\n            _currentCheckins[id] = (stationName, t);\\n        }\\n\\n        public void CheckOut(int id, string stationName, int t)\\n        {\\n            var checkin = _currentCheckins[id];\\n            _currentCheckins.Remove(id);\\n\\n            var key = $\"{checkin.station}->{stationName}\";\\n            if (!_travels.ContainsKey(key))\\n            {\\n                _travels[key] = (0,0);\\n            }\\n\\n            _travels[key] = (_travels[key].sum + t - checkin.t, _travels[key].count + 1);\\n        }\\n\\n        public double GetAverageTime(string startStation, string endStation)\\n        {\\n            var key = $\"{startStation}->{endStation}\";\\n            if (!_travels.ContainsKey(key))\\n            {\\n                return 0;\\n            }\\n\\n            return (double) _travels[key].sum / _travels[key].count;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class UndergroundSystem\\n    {\\n\\n        private readonly IDictionary<int, (string station, int t)> _currentCheckins;\\n        private readonly IDictionary<string, (int sum, int count)> _travels;\\n\\n        public UndergroundSystem()\\n        {\\n            _currentCheckins = new Dictionary<int, (string station, int t)>();\\n            _travels = new Dictionary<string, (int sum, int count)>();\\n        }\\n\\n        public void CheckIn(int id, string stationName, int t)\\n        {\\n            _currentCheckins[id] = (stationName, t);\\n        }\\n\\n        public void CheckOut(int id, string stationName, int t)\\n        {\\n            var checkin = _currentCheckins[id];\\n            _currentCheckins.Remove(id);\\n\\n            var key = $\"{checkin.station}->{stationName}\";\\n            if (!_travels.ContainsKey(key))\\n            {\\n                _travels[key] = (0,0);\\n            }\\n\\n            _travels[key] = (_travels[key].sum + t - checkin.t, _travels[key].count + 1);\\n        }\\n\\n        public double GetAverageTime(string startStation, string endStation)\\n        {\\n            var key = $\"{startStation}->{endStation}\";\\n            if (!_travels.ContainsKey(key))\\n            {\\n                return 0;\\n            }\\n\\n            return (double) _travels[key].sum / _travels[key].count;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815037,
                "title": "javascript-1396-design-underground-system",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\ngoing from station1 to station 2\\n  remember each person time difference / how long they took in travel\\n             sum\" these all - to get all people travelling between s1 to s2 stations\\n    and also count\" how many people travelled\\n  do same for other station pairs\\n\\nfor each requested station pair\\n  do sum/count\\n    it gives average for this station1 to station2, return this\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nvar UndergroundSystem = function () {\\n  this.getKey = (s, e) => s + \",\" + e\\n\\n  let cust = {};\\n  let count = {}; // number of   start station to end station\\n  let sum = {};   // sum    of   start station to end station    time\\n\\n  this.checkIn = (id, from, t1) => {  // id, from Station Name, start Time\\n    cust[id] = [from, t1]; // save start\\n  }\\n\\n  this.checkOut = (id, to, t2) => { // id, to Station Name, end Time\\n    let [from, t1] = cust[id]; // retrieve start\\n    delete cust[id];\\n\\n    const key = this.getKey(from, to);\\n    //  sum\\n    let diff = (t2 - t1); // time difference\\n    sum[key] = (sum[key] || 0) + diff\\n    //  count\\n    count[key] = (count[key] || 0) + 1;\\n  }\\n\\n  this.getAverageTime = (from, to) => {\\n    const key = this.getKey(from, to);\\n\\n    // average = sum / count\\n    return sum[key] / count[key];\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\ngoing from station1 to station 2\\n  remember each person time difference / how long they took in travel\\n             sum\" these all - to get all people travelling between s1 to s2 stations\\n    and also count\" how many people travelled\\n  do same for other station pairs\\n\\nfor each requested station pair\\n  do sum/count\\n    it gives average for this station1 to station2, return this\\n\\n```\n```\\nvar UndergroundSystem = function () {\\n  this.getKey = (s, e) => s + \",\" + e\\n\\n  let cust = {};\\n  let count = {}; // number of   start station to end station\\n  let sum = {};   // sum    of   start station to end station    time\\n\\n  this.checkIn = (id, from, t1) => {  // id, from Station Name, start Time\\n    cust[id] = [from, t1]; // save start\\n  }\\n\\n  this.checkOut = (id, to, t2) => { // id, to Station Name, end Time\\n    let [from, t1] = cust[id]; // retrieve start\\n    delete cust[id];\\n\\n    const key = this.getKey(from, to);\\n    //  sum\\n    let diff = (t2 - t1); // time difference\\n    sum[key] = (sum[key] || 0) + diff\\n    //  count\\n    count[key] = (count[key] || 0) + 1;\\n  }\\n\\n  this.getAverageTime = (from, to) => {\\n    const key = this.getKey(from, to);\\n\\n    // average = sum / count\\n    return sum[key] / count[key];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3672576,
                "title": "c-2-hashmaps-clean-simple",
                "content": "# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {}\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        CheckIn[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string route = CheckIn[id].first + \\'_\\' + stationName;\\n        Routes[route].first += t - CheckIn[id].second;\\n        Routes[route].second++;\\n        CheckIn.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string route = startStation + \\'_\\' + endStation;\\n        return Routes[route].first / (double)Routes[route].second;\\n    }\\n\\nprivate:\\n    // route: <total time, count>\\n    unordered_map<string, pair<int, int>> Routes;\\n    // id: <start station, check-in time>\\n    unordered_map<int, pair<string, int>> CheckIn;\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {}\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        CheckIn[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string route = CheckIn[id].first + \\'_\\' + stationName;\\n        Routes[route].first += t - CheckIn[id].second;\\n        Routes[route].second++;\\n        CheckIn.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string route = startStation + \\'_\\' + endStation;\\n        return Routes[route].first / (double)Routes[route].second;\\n    }\\n\\nprivate:\\n    // route: <total time, count>\\n    unordered_map<string, pair<int, int>> Routes;\\n    // id: <start station, check-in time>\\n    unordered_map<int, pair<string, int>> CheckIn;\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583612,
                "title": "c-beats-100-using-record-as-dictionary-key-no-tuples",
                "content": "* You can use records as dictionary keys, as they automatically implement `IEquatable<T>` \\n\\n# Code\\n```\\npublic class UndergroundSystem {\\n    Dictionary<int, In> ins;\\n    Dictionary<LegDirection, LegStats> legs;\\n\\n    record In(string stationName, int t);\\n\\n    record LegDirection(string start, string end);\\n\\n    class LegStats\\n    {\\n        int _trips;\\n        long _totalTime;\\n        public LegStats(int totalTime)\\n        {\\n            _trips = 1;\\n            _totalTime = totalTime;\\n        }\\n\\n        public void Add(int totalTime)\\n        {\\n            ++_trips;\\n            _totalTime += totalTime;\\n        }\\n\\n        public double Avg() => (double)_totalTime / _trips;\\n    }\\n\\n    public UndergroundSystem() {\\n        ins = new Dictionary<int, In>();\\n        legs = new Dictionary<LegDirection, LegStats>();\\n    }\\n    \\n    public void CheckIn(int id, string stationName, int t) {\\n        ins.Add(id, new In(stationName, t));\\n    }\\n    \\n    public void CheckOut(int id, string stationName, int t) {\\n        var cin = ins[id];\\n        ins.Remove(id);\\n\\n        int duration = (t - cin.t);\\n        var dir = new LegDirection(cin.stationName, stationName);\\n        if (legs.TryGetValue(dir, out var stats))\\n        {\\n            stats.Add(duration);\\n        }\\n        else\\n        {\\n            legs.Add(dir, new LegStats(duration));\\n        }\\n    }\\n    \\n    public double GetAverageTime(string startStation, string endStation) {\\n        var dir = new LegDirection(startStation, endStation);\\n        return legs[dir].Avg();\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.CheckIn(id,stationName,t);\\n * obj.CheckOut(id,stationName,t);\\n * double param_3 = obj.GetAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class UndergroundSystem {\\n    Dictionary<int, In> ins;\\n    Dictionary<LegDirection, LegStats> legs;\\n\\n    record In(string stationName, int t);\\n\\n    record LegDirection(string start, string end);\\n\\n    class LegStats\\n    {\\n        int _trips;\\n        long _totalTime;\\n        public LegStats(int totalTime)\\n        {\\n            _trips = 1;\\n            _totalTime = totalTime;\\n        }\\n\\n        public void Add(int totalTime)\\n        {\\n            ++_trips;\\n            _totalTime += totalTime;\\n        }\\n\\n        public double Avg() => (double)_totalTime / _trips;\\n    }\\n\\n    public UndergroundSystem() {\\n        ins = new Dictionary<int, In>();\\n        legs = new Dictionary<LegDirection, LegStats>();\\n    }\\n    \\n    public void CheckIn(int id, string stationName, int t) {\\n        ins.Add(id, new In(stationName, t));\\n    }\\n    \\n    public void CheckOut(int id, string stationName, int t) {\\n        var cin = ins[id];\\n        ins.Remove(id);\\n\\n        int duration = (t - cin.t);\\n        var dir = new LegDirection(cin.stationName, stationName);\\n        if (legs.TryGetValue(dir, out var stats))\\n        {\\n            stats.Add(duration);\\n        }\\n        else\\n        {\\n            legs.Add(dir, new LegStats(duration));\\n        }\\n    }\\n    \\n    public double GetAverageTime(string startStation, string endStation) {\\n        var dir = new LegDirection(startStation, endStation);\\n        return legs[dir].Avg();\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.CheckIn(id,stationName,t);\\n * obj.CheckOut(id,stationName,t);\\n * double param_3 = obj.GetAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583258,
                "title": "java-90-faster-99-beatsspace-justwithhashmap",
                "content": "\\n***Please upvote if you like the solution.***\\n# CODE\\n```\\nclass UndergroundSystem {\\n    HashMap<String,HashMap<String,Pair>> data;\\n    HashMap<Integer,Details> inout;\\n    public UndergroundSystem() {\\n        data=new HashMap<>();\\n        inout=new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        inout.put(id,new Details(stationName,t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        int totaltime=t-inout.get(id).time;\\n        String startStation=inout.get(id).stationName;\\n        String endStation=stationName;\\n\\n        if(!data.containsKey(startStation) || !data.get(startStation).containsKey(endStation)){\\n            data.putIfAbsent(startStation,new HashMap<>());\\n            data.get(startStation).put(endStation,new Pair(totaltime,1));\\n        }\\n        else{\\n            Pair p = data.get(startStation).get(endStation);\\n            p.add(totaltime,1);\\n            data.get(startStation).put(endStation,p);\\n        }\\n        inout.remove(id);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double avgTime;\\n\\n        int sum=data.get(startStation).get(endStation).sum;\\n        int count=data.get(startStation).get(endStation).count;\\n\\n        avgTime= (double)sum/(double)count;\\n\\n        return avgTime;\\n    }\\n}\\nclass Pair{\\n    int sum=0;\\n    int count=0;\\n    Pair(int s,int c){\\n        this.sum+=s;\\n        this.count+=c;\\n    }\\n    public void add(int s,int c){\\n        this.sum+=s;\\n        this.count+=c;\\n    }\\n}\\nclass Details{\\n    String stationName;\\n    int time;\\n    Details(String stationName,int time){\\n        this.stationName=stationName;\\n        this.time=time;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    HashMap<String,HashMap<String,Pair>> data;\\n    HashMap<Integer,Details> inout;\\n    public UndergroundSystem() {\\n        data=new HashMap<>();\\n        inout=new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        inout.put(id,new Details(stationName,t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        int totaltime=t-inout.get(id).time;\\n        String startStation=inout.get(id).stationName;\\n        String endStation=stationName;\\n\\n        if(!data.containsKey(startStation) || !data.get(startStation).containsKey(endStation)){\\n            data.putIfAbsent(startStation,new HashMap<>());\\n            data.get(startStation).put(endStation,new Pair(totaltime,1));\\n        }\\n        else{\\n            Pair p = data.get(startStation).get(endStation);\\n            p.add(totaltime,1);\\n            data.get(startStation).put(endStation,p);\\n        }\\n        inout.remove(id);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double avgTime;\\n\\n        int sum=data.get(startStation).get(endStation).sum;\\n        int count=data.get(startStation).get(endStation).count;\\n\\n        avgTime= (double)sum/(double)count;\\n\\n        return avgTime;\\n    }\\n}\\nclass Pair{\\n    int sum=0;\\n    int count=0;\\n    Pair(int s,int c){\\n        this.sum+=s;\\n        this.count+=c;\\n    }\\n    public void add(int s,int c){\\n        this.sum+=s;\\n        this.count+=c;\\n    }\\n}\\nclass Details{\\n    String stationName;\\n    int time;\\n    Details(String stationName,int time){\\n        this.stationName=stationName;\\n        this.time=time;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583242,
                "title": "c-clean-code-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UndergroundSystem {\\nprivate:\\n    unordered_map<int,pair<string,int>> check_in;\\n    unordered_map<string,pair<int,int>> check_out;\\npublic:\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        check_in[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string route = check_in[id].first + \"-\" + stationName;\\n        int total_time = t - check_in[id].second;\\n        check_out[route].first += total_time;\\n        check_out[route].second += 1;\\n        check_in.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        pair<int,int> info = check_out[startStation + \"-\" + endStation];\\n        return 1.0*info.first/info.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\nprivate:\\n    unordered_map<int,pair<string,int>> check_in;\\n    unordered_map<string,pair<int,int>> check_out;\\npublic:\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        check_in[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string route = check_in[id].first + \"-\" + stationName;\\n        int total_time = t - check_in[id].second;\\n        check_out[route].first += total_time;\\n        check_out[route].second += 1;\\n        check_in.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        pair<int,int> info = check_out[startStation + \"-\" + endStation];\\n        return 1.0*info.first/info.second;\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583148,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n# Intuition\\nThe problem involves tracking the average time it takes to travel between two stations in an underground system. To solve this problem, we need to keep track of the check-in and check-out times of each passenger and use this information to calculate the average travel time between stations.\\n\\n# Approach\\n1. Create a class `UndergroundSystem` that has two instance variables: `time` and `checkin`. `time` is a dictionary that stores the total travel time and the number of trips between two stations. `checkin` is a dictionary that stores the check-in station and time for each passenger.\\n2. The `checkIn` method takes in the passenger\\'s `id`, `stationName`, and `t` (check-in time) as arguments. It stores the check-in station and time in the `checkin` dictionary using the passenger\\'s `id` as the key.\\n3. The `checkOut` method takes in the passenger\\'s `id`, `stationName`, and `t` (check-out time) as arguments. It retrieves the check-in station and time from the `checkin` dictionary using the passenger\\'s `id` as the key and removes the entry from the dictionary.\\n\\n4. The `getAverageTime` method takes in the `startStation` and `endStation` as arguments. It retrieves the total travel time and number of trips between these two stations from the `time` dictionary and calculates the average travel time by dividing the total travel time by the number of trips.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ for all methods since all operations involve constant-time dictionary lookups and updates.\\n\\n- Space complexity: $$O(P + S^2)$$ where $$P$$ is the number of passengers and $$S$$ is the number of stations since we need to store check-in information for each passenger and travel time information for each pair of stations.\\n\\n# Code\\n```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.time = {}\\n        self.checkin = {}\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkin[id] = (stationName,t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        start_station, check_in_time = self.checkin.pop(id)\\n        travel = (start_station, stationName)\\n        time = t - check_in_time\\n\\n        if travel in self.time:\\n            travel_time, count = self.time[travel]\\n            self.time[travel] = (time+travel_time,count+1)\\n        else:\\n            self.time[(travel)] = (time,1)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        travel = (startStation,endStation)\\n        total_time, count = self.time[travel]\\n        return total_time/count\\n        \\n\\n\\n# Your UndergroundSystem object will be instantiated and called as such:\\n# obj = UndergroundSystem()\\n# obj.checkIn(id,stationName,t)\\n# obj.checkOut(id,stationName,t)\\n# param_3 = obj.getAverageTime(startStation,endStation)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.time = {}\\n        self.checkin = {}\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkin[id] = (stationName,t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        start_station, check_in_time = self.checkin.pop(id)\\n        travel = (start_station, stationName)\\n        time = t - check_in_time\\n\\n        if travel in self.time:\\n            travel_time, count = self.time[travel]\\n            self.time[travel] = (time+travel_time,count+1)\\n        else:\\n            self.time[(travel)] = (time,1)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        travel = (startStation,endStation)\\n        total_time, count = self.time[travel]\\n        return total_time/count\\n        \\n\\n\\n# Your UndergroundSystem object will be instantiated and called as such:\\n# obj = UndergroundSystem()\\n# obj.checkIn(id,stationName,t)\\n# obj.checkOut(id,stationName,t)\\n# param_3 = obj.getAverageTime(startStation,endStation)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582940,
                "title": "unordered-maps",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int ,pair<string ,int>> mp;\\n    map<pair<string,string>,int> avg;\\n    map<pair<string,string>,int> cnt;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string s, int t) {\\n        mp[id] = {s,t};\\n    }\\n    \\n    void checkOut(int id, string s, int t) {\\n        auto i = mp[id];\\n        avg[{i.first,s}] +=(t-i.second);\\n        cnt[{i.first,s}]++;\\n    }\\n    \\n    double getAverageTime(string ss, string es) {\\n        return avg[{ss,es}]/(double)cnt[{ss,es}];\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int ,pair<string ,int>> mp;\\n    map<pair<string,string>,int> avg;\\n    map<pair<string,string>,int> cnt;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string s, int t) {\\n        mp[id] = {s,t};\\n    }\\n    \\n    void checkOut(int id, string s, int t) {\\n        auto i = mp[id];\\n        avg[{i.first,s}] +=(t-i.second);\\n        cnt[{i.first,s}]++;\\n    }\\n    \\n    double getAverageTime(string ss, string es) {\\n        return avg[{ss,es}]/(double)cnt[{ss,es}];\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582319,
                "title": "hashmaps-of-pairs-c",
                "content": "```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int>> in;\\n    unordered_map<string, pair<double, int>> avg;\\npublic:\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        in[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int checkInTime = in[id].second;\\n        string checkInStation = in[id].first;\\n\\n        double pre = avg[checkInStation + \"->\" + stationName].first;\\n        int cnt = avg[checkInStation + \"->\" + stationName].second;\\n        avg[checkInStation + \"->\" + stationName] = {pre + t - checkInTime, cnt + 1};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return avg[startStation + \"->\" + endStation].first / avg[startStation + \"->\" + endStation].second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    unordered_map<int, pair<string, int>> in;\\n    unordered_map<string, pair<double, int>> avg;\\npublic:\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        in[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int checkInTime = in[id].second;\\n        string checkInStation = in[id].first;\\n\\n        double pre = avg[checkInStation + \"->\" + stationName].first;\\n        int cnt = avg[checkInStation + \"->\" + stationName].second;\\n        avg[checkInStation + \"->\" + stationName] = {pre + t - checkInTime, cnt + 1};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return avg[startStation + \"->\" + endStation].first / avg[startStation + \"->\" + endStation].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582042,
                "title": "java-hashmap-easy-to-understand",
                "content": "```\\nclass UndergroundSystem {\\n    HashMap<Integer, String[]> hm;\\n    HashMap<String, Integer[]> hm1;\\n    public UndergroundSystem() {\\n        this.hm = new HashMap<>();\\n        this.hm1 = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        String[] arr = new String[] {stationName, Integer.toString(t)};\\n        if(!hm.containsKey(id)) hm.put(id, arr);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        if(hm.containsKey(id)) {\\n            String[] arr = hm.remove(id);\\n            String i = arr[0] + \"-\" + stationName;\\n            Integer a = t - Integer.parseInt(arr[1]);\\n            if(hm1.get(i) == null) {\\n                Integer[] res = new Integer[] {a, 1};\\n                hm1.put(i, res);\\n            } else {\\n                Integer[] s = hm1.get(i);\\n                s[0] += a;\\n                s[1]++;\\n                hm1.replace(i, s);\\n            }\\n        }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = startStation + \"-\" + endStation;\\n        Integer[] res = hm1.get(key);\\n        return (double) res[0] / res[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    HashMap<Integer, String[]> hm;\\n    HashMap<String, Integer[]> hm1;\\n    public UndergroundSystem() {\\n        this.hm = new HashMap<>();\\n        this.hm1 = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        String[] arr = new String[] {stationName, Integer.toString(t)};\\n        if(!hm.containsKey(id)) hm.put(id, arr);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        if(hm.containsKey(id)) {\\n            String[] arr = hm.remove(id);\\n            String i = arr[0] + \"-\" + stationName;\\n            Integer a = t - Integer.parseInt(arr[1]);\\n            if(hm1.get(i) == null) {\\n                Integer[] res = new Integer[] {a, 1};\\n                hm1.put(i, res);\\n            } else {\\n                Integer[] s = hm1.get(i);\\n                s[0] += a;\\n                s[1]++;\\n                hm1.replace(i, s);\\n            }\\n        }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = startStation + \"-\" + endStation;\\n        Integer[] res = hm1.get(key);\\n        return (double) res[0] / res[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581995,
                "title": "beating-86-12-python-easiest-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/49ba5212-262e-4a10-8981-4239531f8a66_1685529317.5107667.png)\\n\\n\\n\\n# Code\\n```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.i=defaultdict(tuple)\\n        self.o=defaultdict(list)\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.i[id]=(t,stationName)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        starttime,startstation=self.i[id]\\n        total=t-starttime\\n        self.o[(startstation,stationName)].append(total)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        return sum(self.o[(startStation,endStation)])/len(self.o[(startStation,endStation)])\\n        \\n\\n\\n# Your UndergroundSystem object will be instantiated and called as such:\\n# obj = UndergroundSystem()\\n# obj.checkIn(id,stationName,t)\\n# obj.checkOut(id,stationName,t)\\n# param_3 = obj.getAverageTime(startStation,endStation)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass UndergroundSystem:\\n\\n    def __init__(self):\\n        self.i=defaultdict(tuple)\\n        self.o=defaultdict(list)\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.i[id]=(t,stationName)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        starttime,startstation=self.i[id]\\n        total=t-starttime\\n        self.o[(startstation,stationName)].append(total)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        return sum(self.o[(startStation,endStation)])/len(self.o[(startStation,endStation)])\\n        \\n\\n\\n# Your UndergroundSystem object will be instantiated and called as such:\\n# obj = UndergroundSystem()\\n# obj.checkIn(id,stationName,t)\\n# obj.checkOut(id,stationName,t)\\n# param_3 = obj.getAverageTime(startStation,endStation)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581972,
                "title": "beating-98-57-java-easiest-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/90b9ea11-0209-4fac-8eab-23f24c68b2b4_1685528680.6606069.png)\\n\\n\\n# Code\\n```\\npublic class UndergroundSystem {\\n  \\n  Map<Integer, CheckIn> custIdCheckIn = new HashMap();\\n\\n  Map<String, Map<String, double[]>> stationCheckedOut = new HashMap();\\n\\n  public UndergroundSystem() {\\n  }\\n\\n  public void checkIn(int id, String stationName, int t) {\\n    custIdCheckIn.put(id, new CheckIn(stationName, t));\\n  }\\n\\n  public void checkOut(int id, String stationName, int t) {\\n    CheckIn checkin = custIdCheckIn.remove(id);\\n\\n    Map<String, double[]> toMap;\\n    if (!stationCheckedOut.containsKey(checkin.from)) {\\n      toMap = new HashMap();\\n      stationCheckedOut.put(checkin.from, toMap);\\n    } else\\n      toMap = stationCheckedOut.get(checkin.from);\\n\\n    double[] nums;\\n    if (!toMap.containsKey(stationName)) {\\n      nums = new double[] { 0.0, 0.0};\\n      toMap.put(stationName,  nums);\\n    } else {\\n      nums = toMap.get(stationName);\\n    }\\n\\n    nums[1] += t - checkin.time;\\n    nums[0] += 1.0;\\n  }\\n\\n  public double getAverageTime(String startStation, String endStation) {\\n    Map<String, double[]> toMap = stationCheckedOut.get(startStation);\\n    double[] pair = toMap.get(endStation);\\n    return (double)pair[1]/pair[0];\\n  }\\n}\\n\\nclass CheckIn {\\n  String from;\\n  int time;\\n\\n  CheckIn(String from, int time) {\\n    this.from = from;\\n    this.time = time;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class UndergroundSystem {\\n  \\n  Map<Integer, CheckIn> custIdCheckIn = new HashMap();\\n\\n  Map<String, Map<String, double[]>> stationCheckedOut = new HashMap();\\n\\n  public UndergroundSystem() {\\n  }\\n\\n  public void checkIn(int id, String stationName, int t) {\\n    custIdCheckIn.put(id, new CheckIn(stationName, t));\\n  }\\n\\n  public void checkOut(int id, String stationName, int t) {\\n    CheckIn checkin = custIdCheckIn.remove(id);\\n\\n    Map<String, double[]> toMap;\\n    if (!stationCheckedOut.containsKey(checkin.from)) {\\n      toMap = new HashMap();\\n      stationCheckedOut.put(checkin.from, toMap);\\n    } else\\n      toMap = stationCheckedOut.get(checkin.from);\\n\\n    double[] nums;\\n    if (!toMap.containsKey(stationName)) {\\n      nums = new double[] { 0.0, 0.0};\\n      toMap.put(stationName,  nums);\\n    } else {\\n      nums = toMap.get(stationName);\\n    }\\n\\n    nums[1] += t - checkin.time;\\n    nums[0] += 1.0;\\n  }\\n\\n  public double getAverageTime(String startStation, String endStation) {\\n    Map<String, double[]> toMap = stationCheckedOut.get(startStation);\\n    double[] pair = toMap.get(endStation);\\n    return (double)pair[1]/pair[0];\\n  }\\n}\\n\\nclass CheckIn {\\n  String from;\\n  int time;\\n\\n  CheckIn(String from, int time) {\\n    this.from = from;\\n    this.time = time;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581922,
                "title": "c-map-easy-to-understand",
                "content": "# Intuition\\n By Using Maps\\n\\n# Approach\\nBy using 3 maps, the first one which is a map of pair of string and a vector which stores the duration of trips of passengers from a particular starting station to a particular end station.\\nThe second map(s) is a map of integer keys (id) which stores name of starting station and the time at which the passenger  with a particular id started the journey from the starting station.\\nThe third map(a) is also a map of integer keys (id) which stores name of ending station and the completion time of the journey.\\nWe use maps \\'s\\'and \\'a\\' to store values of journey time of different passengers from a particular starting station to a particular ending station in map \\'m\\'.\\n\\n\\n\\n# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n    map<pair<string,string>,vector<int>> m;\\n    map<int,pair<string,int>>s;\\n    map<int,pair<string,int>>a;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        s[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        a[id]= {stationName,t-s[id].second};\\n        m[{s[id].first,a[id].first}].push_back(a[id].second);\\n\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double ans=0;\\n        for(auto e:m[{ startStation, endStation}]){\\n            ans+=e;\\n        }\\n        return(ans/(m[{ startStation, endStation}].size()));\\n\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    map<pair<string,string>,vector<int>> m;\\n    map<int,pair<string,int>>s;\\n    map<int,pair<string,int>>a;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        s[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        a[id]= {stationName,t-s[id].second};\\n        m[{s[id].first,a[id].first}].push_back(a[id].second);\\n\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double ans=0;\\n        for(auto e:m[{ startStation, endStation}]){\\n            ans+=e;\\n        }\\n        return(ans/(m[{ startStation, endStation}].size()));\\n\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581826,
                "title": "java-hashmap-easy-understandalbe-solution",
                "content": "```\\nclass UndergroundSystem {\\n//     checking time, Pair<departure point, departure time>\\n    HashMap<Integer,Pair<String,Integer>> checkin = new HashMap();\\n    \\n//  departure+\" \"+desitnation as key and Pair<sum , number of trips>\\n    HashMap<String,Pair<Integer,Integer>>  average = new HashMap();\\n        \\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkin.put(id, new Pair(stationName, t));\\n        return;\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        String departure = checkin.get(id).getKey();\\n//         time taken to reach dest  = checkout time - chekcin time\\n        int time = t - checkin.get(id).getValue();\\n        String key = \"\";\\n        key+=departure+\"_\"+stationName;\\n        int trips = 0, sum = 0;\\n        if(average.containsKey(key)){\\n            trips = average.get(key).getValue();\\n            sum = average.get(key).getKey();\\n        }\\n        sum+=time;\\n        trips++;\\n        average.put(key, new Pair(sum, trips));\\n        checkin.remove(id);\\n        return;\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = \"\";\\n        key = startStation +\"_\"+endStation;\\n        double ans = 0;\\n        double trips = average.get(key).getValue();\\n        double sum = average.get(key).getKey();\\n        ans = sum/trips;\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UndergroundSystem {\\n//     checking time, Pair<departure point, departure time>\\n    HashMap<Integer,Pair<String,Integer>> checkin = new HashMap();\\n    \\n//  departure+\" \"+desitnation as key and Pair<sum , number of trips>\\n    HashMap<String,Pair<Integer,Integer>>  average = new HashMap();\\n        \\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        checkin.put(id, new Pair(stationName, t));\\n        return;\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        String departure = checkin.get(id).getKey();\\n//         time taken to reach dest  = checkout time - chekcin time\\n        int time = t - checkin.get(id).getValue();\\n        String key = \"\";\\n        key+=departure+\"_\"+stationName;\\n        int trips = 0, sum = 0;\\n        if(average.containsKey(key)){\\n            trips = average.get(key).getValue();\\n            sum = average.get(key).getKey();\\n        }\\n        sum+=time;\\n        trips++;\\n        average.put(key, new Pair(sum, trips));\\n        checkin.remove(id);\\n        return;\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String key = \"\";\\n        key = startStation +\"_\"+endStation;\\n        double ans = 0;\\n        double trips = average.get(key).getValue();\\n        double sum = average.get(key).getKey();\\n        ans = sum/trips;\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581711,
                "title": "c-0ms",
                "content": "\\n\\n# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int,pair<string,int>> m1,m2;\\n    unordered_map<string,vector<pair<int,int>>> m;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        m1[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        m2[id]={stationName,t};\\n        string ans=\"\";\\n        ans+=m1[id].first;\\n        ans+=\"->\";\\n        ans+=m2[id].first;\\n        m[ans].push_back({m1[id].second,m2[id].second});\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string tempo=startStation + \"->\" + endStation;\\n        auto x = m[tempo];\\n        double a=0.0;\\n        int n=x.size();\\n        for(auto y:x){\\n            a+=(double)(y.second-y.first);\\n        }\\n        return (double)(a/n);\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int,pair<string,int>> m1,m2;\\n    unordered_map<string,vector<pair<int,int>>> m;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        m1[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        m2[id]={stationName,t};\\n        string ans=\"\";\\n        ans+=m1[id].first;\\n        ans+=\"->\";\\n        ans+=m2[id].first;\\n        m[ans].push_back({m1[id].second,m2[id].second});\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string tempo=startStation + \"->\" + endStation;\\n        auto x = m[tempo];\\n        double a=0.0;\\n        int n=x.size();\\n        for(auto y:x){\\n            a+=(double)(y.second-y.first);\\n        }\\n        return (double)(a/n);\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581667,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int, pair<string, int>> start;\\n    unordered_map<string, unordered_map<string, int>> total, times;\\n    UndergroundSystem() \\n    {\\n        start.clear(), total.clear(), times.clear();\\n    }\\n    void checkIn(int id, string stationName, int t)\\n     {\\n        start[id] = { stationName, t};\\n    }\\n    void checkOut(int id, string stationName, int t) \\n    {\\n        total[start[id].first][stationName] += t - start[id].second;\\n        times[start[id].first][stationName]++;\\n    }\\n    double getAverageTime(string startStation, string endStation)\\n     {\\n        return (total[startStation][endStation])/(double)(times[startStation][endStation]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int, pair<string, int>> start;\\n    unordered_map<string, unordered_map<string, int>> total, times;\\n    UndergroundSystem() \\n    {\\n        start.clear(), total.clear(), times.clear();\\n    }\\n    void checkIn(int id, string stationName, int t)\\n     {\\n        start[id] = { stationName, t};\\n    }\\n    void checkOut(int id, string stationName, int t) \\n    {\\n        total[start[id].first][stationName] += t - start[id].second;\\n        times[start[id].first][stationName]++;\\n    }\\n    double getAverageTime(string startStation, string endStation)\\n     {\\n        return (total[startStation][endStation])/(double)(times[startStation][endStation]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581643,
                "title": "c-maps-explanation-with-code",
                "content": "# Approach\\nHere I need **two maps** , let say **mp1** and **mp2**. **mp1 to store pair  {entryStation,entryTime} corresponding to id**. **mp2 to store list of absolute differences of times corresponding to (startStation+\"to\"+endStation)**.\\nNow to get average time from start station to end station, we **traverse through list corresponding to mp2 of (startStation+\"to\"+endStation)** and get the answer. \\n\\n\\n# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n    map<int,pair<string,int>>mp1;\\n    map<string,vector<int>>mp2;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp1[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string entryStation=mp1[id].first;\\n        int entryTime=mp1[id].second;\\n        string outStation=stationName;\\n        string p=entryStation+\"to\"+outStation;\\n        mp2[p].push_back(abs(t-entryTime));\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string sToE=startStation+\"to\"+endStation;\\n        double ans=0;\\n        for(int i=0; i<mp2[sToE].size(); i++){\\n            ans+=mp2[sToE][i];\\n        }\\n        return ans/mp2[sToE].size();\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    map<int,pair<string,int>>mp1;\\n    map<string,vector<int>>mp2;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp1[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string entryStation=mp1[id].first;\\n        int entryTime=mp1[id].second;\\n        string outStation=stationName;\\n        string p=entryStation+\"to\"+outStation;\\n        mp2[p].push_back(abs(t-entryTime));\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string sToE=startStation+\"to\"+endStation;\\n        double ans=0;\\n        for(int i=0; i<mp2[sToE].size(); i++){\\n            ans+=mp2[sToE][i];\\n        }\\n        return ans/mp2[sToE].size();\\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581621,
                "title": "typescript-using-hashtable-easy-to-understand-runtime-70-memory-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI love design problems, no algorithms, just code logic. For average time we just need the differences. We only need to keep track of checkins, after checkout push to the finished array the time difference and delete the checkin record.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ for checkin and checkout, $$O(n)$$ for average time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```TypeScript\\nclass UndergroundSystem {\\n    checkins: { [id: number]: [string, number] };\\n    finished: { [path: string]: number[] };\\n    constructor() {\\n        this.checkins = {};\\n        this.finished = {};\\n    }\\n\\n    checkIn(id: number, stationName: string, t: number): void {\\n        this.checkins[id] = [stationName, t];\\n    }\\n\\n    checkOut(id: number, stationName: string, t: number): void {\\n        const [startStation, inTime] = this.checkins[id];\\n        delete this.checkins[id];\\n        // If undefined, assign an array and push a value to it\\n        (this.finished[`${startStation}-${stationName}`] ??= []).push(t - inTime);\\n    }\\n\\n    getAverageTime(startStation: string, endStation: string): number {\\n        const sum = this.finished[`${startStation}-${endStation}`]\\n            .reduce((acc: number, v: number) => {\\n                return acc + v;\\n            })\\n\\n        return sum / this.finished[`${startStation}-${endStation}`].length;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * var obj = new UndergroundSystem()\\n * obj.checkIn(id,stationName,t)\\n * obj.checkOut(id,stationName,t)\\n * var param_3 = obj.getAverageTime(startStation,endStation)\\n */\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table",
                    "Design"
                ],
                "code": "```TypeScript\\nclass UndergroundSystem {\\n    checkins: { [id: number]: [string, number] };\\n    finished: { [path: string]: number[] };\\n    constructor() {\\n        this.checkins = {};\\n        this.finished = {};\\n    }\\n\\n    checkIn(id: number, stationName: string, t: number): void {\\n        this.checkins[id] = [stationName, t];\\n    }\\n\\n    checkOut(id: number, stationName: string, t: number): void {\\n        const [startStation, inTime] = this.checkins[id];\\n        delete this.checkins[id];\\n        // If undefined, assign an array and push a value to it\\n        (this.finished[`${startStation}-${stationName}`] ??= []).push(t - inTime);\\n    }\\n\\n    getAverageTime(startStation: string, endStation: string): number {\\n        const sum = this.finished[`${startStation}-${endStation}`]\\n            .reduce((acc: number, v: number) => {\\n                return acc + v;\\n            })\\n\\n        return sum / this.finished[`${startStation}-${endStation}`].length;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * var obj = new UndergroundSystem()\\n * obj.checkIn(id,stationName,t)\\n * obj.checkOut(id,stationName,t)\\n * var param_3 = obj.getAverageTime(startStation,endStation)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581619,
                "title": "easy-c-code-using-map-implementation",
                "content": "\\r\\n# Approach\\r\\nSimply Computed using map concept and implementation \\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(1)\\r\\n\\r\\n- Space complexity:\\r\\nO(map size)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass UndergroundSystem {\\r\\npublic:\\r\\n      map<int,pair<string,int>> mp; // Checkin\\r\\n    map<int,pair<string,int>> mp1; // Checkout\\r\\n     map<pair<string,string>,int> mp2 ,mp3;// mp2-> Keeping sum of Differences \\r\\n    // mp3-> keeping frequency of number of time passenger travelled from one station to another used in computation of average mkcp.\\r\\n    UndergroundSystem() {\\r\\n    //   map<int,pair<string,int>> mp;\\r\\n    // map<int,pair<string,int>> mp1;\\r\\n    //  map<pair<string,string>,int> mp2,mp3;\\r\\n\\r\\n    }\\r\\n    \\r\\n    void checkIn(int id, string stationName, int t) {\\r\\n            mp[id]={stationName,t};   \\r\\n    }\\r\\n    \\r\\n    void checkOut(int id, string stationName, int t) {\\r\\n           mp1[id]={stationName,t};\\r\\n           if(mp.find(id)!=mp.end()){\\r\\n               string s1= mp[id].first;\\r\\n               string s2= mp1[id].first;\\r\\n               int x1= mp1[id].second;\\r\\n               int x2= mp[id].second;\\r\\n               mp2[{s1,s2}]+= (x1-x2);\\r\\n               mp3[{s1,s2}]++;\\r\\n           }\\r\\n    }\\r\\n    \\r\\n    double getAverageTime(string startStation, string endStation) {\\r\\n          double x= mp2[{startStation,endStation}];\\r\\n          double y= mp3[{startStation,endStation}];\\r\\n        return (x/y);\\r\\n    }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Your UndergroundSystem object will be instantiated and called as such:\\r\\n * UndergroundSystem* obj = new UndergroundSystem();\\r\\n * obj->checkIn(id,stationName,t);\\r\\n * obj->checkOut(id,stationName,t);\\r\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\r\\n */\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass UndergroundSystem {\\r\\npublic:\\r\\n      map<int,pair<string,int>> mp; // Checkin\\r\\n    map<int,pair<string,int>> mp1; // Checkout\\r\\n     map<pair<string,string>,int> mp2 ,mp3;// mp2-> Keeping sum of Differences \\r\\n    // mp3-> keeping frequency of number of time passenger travelled from one station to another used in computation of average mkcp.\\r\\n    UndergroundSystem() {\\r\\n    //   map<int,pair<string,int>> mp;\\r\\n    // map<int,pair<string,int>> mp1;\\r\\n    //  map<pair<string,string>,int> mp2,mp3;\\r\\n\\r\\n    }\\r\\n    \\r\\n    void checkIn(int id, string stationName, int t) {\\r\\n            mp[id]={stationName,t};   \\r\\n    }\\r\\n    \\r\\n    void checkOut(int id, string stationName, int t) {\\r\\n           mp1[id]={stationName,t};\\r\\n           if(mp.find(id)!=mp.end()){\\r\\n               string s1= mp[id].first;\\r\\n               string s2= mp1[id].first;\\r\\n               int x1= mp1[id].second;\\r\\n               int x2= mp[id].second;\\r\\n               mp2[{s1,s2}]+= (x1-x2);\\r\\n               mp3[{s1,s2}]++;\\r\\n           }\\r\\n    }\\r\\n    \\r\\n    double getAverageTime(string startStation, string endStation) {\\r\\n          double x= mp2[{startStation,endStation}];\\r\\n          double y= mp3[{startStation,endStation}];\\r\\n        return (x/y);\\r\\n    }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Your UndergroundSystem object will be instantiated and called as such:\\r\\n * UndergroundSystem* obj = new UndergroundSystem();\\r\\n * obj->checkIn(id,stationName,t);\\r\\n * obj->checkOut(id,stationName,t);\\r\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\r\\n */\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581587,
                "title": "golang-using-dictionaries",
                "content": "# Code\\n```\\ntype CheckIn struct {\\n    StationName string\\n    Time int\\n}\\n\\ntype Route struct {\\n    TotalDuration int\\n    Passengers int\\n}\\n\\ntype UndergroundSystem struct {\\n    CheckIns map[int]CheckIn\\n    Routes map[string]Route\\n}\\n\\n\\nfunc Constructor() UndergroundSystem {\\n    return UndergroundSystem{\\n        CheckIns: make(map[int]CheckIn),\\n        Routes: make(map[string]Route),\\n    }\\n}\\n\\n\\nfunc (this *UndergroundSystem) CheckIn(id int, stationName string, t int)  {\\n    this.CheckIns[id] = CheckIn {\\n        StationName: stationName,\\n        Time: t,\\n    }\\n}\\n\\n\\nfunc (this *UndergroundSystem) CheckOut(id int, stationName string, t int)  {\\n    checkIn := this.CheckIns[id]\\n    routeName := checkIn.StationName + \"-\" + stationName\\n    duration := t - checkIn.Time\\n\\n    if route, ok := this.Routes[routeName]; ok {\\n        route.TotalDuration += duration\\n        route.Passengers++\\n        this.Routes[routeName] = route\\n    } else {\\n        this.Routes[routeName] = Route {\\n            TotalDuration: duration,\\n            Passengers: 1,\\n        }\\n    }\\n\\n    delete(this.CheckIns, id)\\n}\\n\\n\\nfunc (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 {\\n    routeName := startStation + \"-\" + endStation\\n    route := this.Routes[routeName]\\n\\n    return float64(route.TotalDuration) / float64(route.Passengers)\\n}\\n\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.CheckIn(id,stationName,t);\\n * obj.CheckOut(id,stationName,t);\\n * param_3 := obj.GetAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype CheckIn struct {\\n    StationName string\\n    Time int\\n}\\n\\ntype Route struct {\\n    TotalDuration int\\n    Passengers int\\n}\\n\\ntype UndergroundSystem struct {\\n    CheckIns map[int]CheckIn\\n    Routes map[string]Route\\n}\\n\\n\\nfunc Constructor() UndergroundSystem {\\n    return UndergroundSystem{\\n        CheckIns: make(map[int]CheckIn),\\n        Routes: make(map[string]Route),\\n    }\\n}\\n\\n\\nfunc (this *UndergroundSystem) CheckIn(id int, stationName string, t int)  {\\n    this.CheckIns[id] = CheckIn {\\n        StationName: stationName,\\n        Time: t,\\n    }\\n}\\n\\n\\nfunc (this *UndergroundSystem) CheckOut(id int, stationName string, t int)  {\\n    checkIn := this.CheckIns[id]\\n    routeName := checkIn.StationName + \"-\" + stationName\\n    duration := t - checkIn.Time\\n\\n    if route, ok := this.Routes[routeName]; ok {\\n        route.TotalDuration += duration\\n        route.Passengers++\\n        this.Routes[routeName] = route\\n    } else {\\n        this.Routes[routeName] = Route {\\n            TotalDuration: duration,\\n            Passengers: 1,\\n        }\\n    }\\n\\n    delete(this.CheckIns, id)\\n}\\n\\n\\nfunc (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 {\\n    routeName := startStation + \"-\" + endStation\\n    route := this.Routes[routeName]\\n\\n    return float64(route.TotalDuration) / float64(route.Passengers)\\n}\\n\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.CheckIn(id,stationName,t);\\n * obj.CheckOut(id,stationName,t);\\n * param_3 := obj.GetAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3581586,
                "title": "c-map-easy-to-understand-straightforward-solution-explained",
                "content": "My Approach-\\nI have created three maps, first one to store the checkin which is straightforward to store the ID, Start station name and intime in the cust map. \\nNow, for the checkout time, we get the ID, End Station Name and the out time. Thus, from the ID, we have the station names: start and end. We will get the start station and intime(board) from the cust map. \\nWe will store the {start, end} (station names) and the time required to travel from start to end as t-board which we will add to the map avg, which store the total time req to travel from start to end.\\nNow, assuming if 3 person travel from station start to end, we add the time required to travel from start to end in the map avg, but that time is not the avg, it is the total time. \\nSo, we create another map cnt to store the number of times the journey from start to end is commenced as cnt[{start,end}]++.\\nNow, the average time is Total time/ Number of journeys (Start to end), which we will return in the function getAverageTime.\\n\\nNote- Do not forget to typecast the integer values to double type.\\n\\nCode for better understanding\\n``` \\n    map<pair<string,string>, int> avg;\\n    map<pair<string,string>, int> cnt;\\n    map<int, pair<string,int>> cust;\\n    UndergroundSystem() {\\n    \\n\\t}\\n    void checkIn(int id, string st, int t) {\\n        cust[id]={st,t};\\n    }\\n    void checkOut(int id, string st, int t) {\\n        string last=cust[id].first; int board=cust[id].second;\\n        cust.erase(id);\\n        cnt[{last,st}]++;\\n        avg[{last,st}]+=t-board;\\n    }\\n    double getAverageTime(string last, string st) {\\n        double num=avg[{last,st}]*1.00/cnt[{last,st}];\\n        return num;\\n    }",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Design"
                ],
                "code": "My Approach-\\nI have created three maps, first one to store the checkin which is straightforward to store the ID, Start station name and intime in the cust map. \\nNow, for the checkout time, we get the ID, End Station Name and the out time. Thus, from the ID, we have the station names: start and end. We will get the start station and intime(board) from the cust map. \\nWe will store the {start, end} (station names) and the time required to travel from start to end as t-board which we will add to the map avg, which store the total time req to travel from start to end.\\nNow, assuming if 3 person travel from station start to end, we add the time required to travel from start to end in the map avg, but that time is not the avg, it is the total time. \\nSo, we create another map cnt to store the number of times the journey from start to end is commenced as cnt[{start,end}]++.\\nNow, the average time is Total time/ Number of journeys (Start to end), which we will return in the function getAverageTime.\\n\\nNote- Do not forget to typecast the integer values to double type.\\n\\nCode for better understanding\\n``` \\n    map<pair<string,string>, int> avg;\\n    map<pair<string,string>, int> cnt;\\n    map<int, pair<string,int>> cust;\\n    UndergroundSystem() {\\n    \\n\\t}\\n    void checkIn(int id, string st, int t) {\\n        cust[id]={st,t};\\n    }\\n    void checkOut(int id, string st, int t) {\\n        string last=cust[id].first; int board=cust[id].second;\\n        cust.erase(id);\\n        cnt[{last,st}]++;\\n        avg[{last,st}]+=t-board;\\n    }\\n    double getAverageTime(string last, string st) {\\n        double num=avg[{last,st}]*1.00/cnt[{last,st}];\\n        return num;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3581554,
                "title": "1396-design-underground-system-java",
                "content": "```\\nclass UndergroundSystem {\\n    HashMap<Integer,Pair<String,Integer>> CheckIn;\\n    HashMap<String,Pair<Integer,Integer>> TravelTime;\\n\\n    public UndergroundSystem() {\\n        CheckIn=new HashMap<Integer,Pair<String,Integer>>();\\n        TravelTime= new HashMap<String,Pair<Integer,Integer>>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        CheckIn.put(id,new Pair(stationName,t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Pair <String,Integer> info=CheckIn.get(id);\\n        String val=info.getKey()+\"-\"+stationName;\\n        int tt=t-info.getValue();\\n        Pair<Integer,Integer>  help=TravelTime.getOrDefault(val,new Pair(0,0));\\n        TravelTime.put(val,new Pair(help.getKey()+tt,help.getValue()+1));\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n               String val=startStation+\"-\"+endStation;\\n                Pair<Integer,Integer> avgtime=TravelTime.get(val);\\n               double tt=(double)TravelTime.get(val).getKey(),tid=(double)TravelTime.get(val).getValue();\\n                return tt/tid;\\n    }\\n}\\n ```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n    HashMap<Integer,Pair<String,Integer>> CheckIn;\\n    HashMap<String,Pair<Integer,Integer>> TravelTime;\\n\\n    public UndergroundSystem() {\\n        CheckIn=new HashMap<Integer,Pair<String,Integer>>();\\n        TravelTime= new HashMap<String,Pair<Integer,Integer>>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        CheckIn.put(id,new Pair(stationName,t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Pair <String,Integer> info=CheckIn.get(id);\\n        String val=info.getKey()+\"-\"+stationName;\\n        int tt=t-info.getValue();\\n        Pair<Integer,Integer>  help=TravelTime.getOrDefault(val,new Pair(0,0));\\n        TravelTime.put(val,new Pair(help.getKey()+tt,help.getValue()+1));\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n               String val=startStation+\"-\"+endStation;\\n                Pair<Integer,Integer> avgtime=TravelTime.get(val);\\n               double tt=(double)TravelTime.get(val).getKey(),tid=(double)TravelTime.get(val).getValue();\\n                return tt/tid;\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3581476,
                "title": "c",
                "content": "```cpp\\nclass UndergroundSystem {\\n  unordered_map< int, pair< string, int >> in;\\n  unordered_map< string, pair< int, int >> out;\\npublic:\\n  UndergroundSystem() {}\\n  void checkIn( int id, string s, int t ) {\\n    in[ id ] = { s, t };\\n  }\\n  void checkOut( int id, string s, int t ) {\\n    const string& r{ in[ id ].first + \\'|\\' + s };\\n    out[ r ].first += t - in[ id ].second;\\n    out[ r ].second++;\\n    in.erase( id );\\n  }\\n  double getAverageTime( string s, string e ) {\\n    const string& r{ s + \\'|\\' + e };\\n    return 1.0 * out[ r ].first / out[ r ].second;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```cpp\\nclass UndergroundSystem {\\n  unordered_map< int, pair< string, int >> in;\\n  unordered_map< string, pair< int, int >> out;\\npublic:\\n  UndergroundSystem() {}\\n  void checkIn( int id, string s, int t ) {\\n    in[ id ] = { s, t };\\n  }\\n  void checkOut( int id, string s, int t ) {\\n    const string& r{ in[ id ].first + \\'|\\' + s };\\n    out[ r ].first += t - in[ id ].second;\\n    out[ r ].second++;\\n    in.erase( id );\\n  }\\n  double getAverageTime( string s, string e ) {\\n    const string& r{ s + \\'|\\' + e };\\n    return 1.0 * out[ r ].first / out[ r ].second;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581341,
                "title": "day-426-tc-o-1-graph-visual",
                "content": "\\n\\n# Complexity\\n- Time complexity:o(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass UndergroundSystem {\\n    private Map<Integer, String> checkIns;\\n    private Map<String, Integer> travelTimes;\\n    private Map<String, Integer> travelCounts;\\n\\n    public UndergroundSystem() {\\n        checkIns = new HashMap<>();\\n        travelTimes = new HashMap<>();\\n        travelCounts = new HashMap<>();\\n    }\\n\\n    public void checkIn(int id, String stationName, int t) {\\n        checkIns.put(id, stationName + \",\" + t);\\n    }\\n\\n    public void checkOut(int id, String stationName, int t) {\\n        String[] checkInData = checkIns.get(id).split(\",\");\\n        String route = checkInData[0] + \"->\" + stationName;\\n        int travelTime = t - Integer.parseInt(checkInData[1]);\\n        travelTimes.put(route, travelTimes.getOrDefault(route, 0) + travelTime);\\n        travelCounts.put(route, travelCounts.getOrDefault(route, 0) + 1);\\n        checkIns.remove(id);\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        String route = startStation + \"->\" + endStation;\\n        return (double) travelTimes.get(route) / travelCounts.get(route);\\n    }\\n}\\n```\\n```java []\\nclass UndergroundSystem {\\n\\n    private HashMap<Integer,Map<String,Integer>>st;\\n    private HashMap<String,List<Integer>> avg;\\n\\n    public UndergroundSystem() {\\n        this.avg = new HashMap<>();\\n        this.st = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String sn, int t) {\\n        var s = new HashMap<String,Integer>();\\n        s.put(sn,t);\\n        st.put(id,s);\\n    }\\n    \\n    public void checkOut(int id, String sn, int t) {\\n        if(st.containsKey(id)){\\n            var entry = st.get(id).entrySet().iterator().next();\\n            var key = entry.getKey()+\"->\"+sn;\\n            var pre = entry.getValue();\\n            if(avg.containsKey(key)){\\n                var oldList = avg.get(key);\\n                oldList.add(t - pre);\\n                avg.put(key, oldList);\\n            }else avg.put(key, new ArrayList<>(List.of(t - pre)));\\n        }\\n    }\\n    public double getAverageTime(String sn, String es) {\\n        return avg.get(sn+\"->\"+es).stream().collect(Collectors.averagingInt(Integer::intValue));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Graph",
                    "Data Stream",
                    "Hash Function"
                ],
                "code": "```java []\\nclass UndergroundSystem {\\n    private Map<Integer, String> checkIns;\\n    private Map<String, Integer> travelTimes;\\n    private Map<String, Integer> travelCounts;\\n\\n    public UndergroundSystem() {\\n        checkIns = new HashMap<>();\\n        travelTimes = new HashMap<>();\\n        travelCounts = new HashMap<>();\\n    }\\n\\n    public void checkIn(int id, String stationName, int t) {\\n        checkIns.put(id, stationName + \",\" + t);\\n    }\\n\\n    public void checkOut(int id, String stationName, int t) {\\n        String[] checkInData = checkIns.get(id).split(\",\");\\n        String route = checkInData[0] + \"->\" + stationName;\\n        int travelTime = t - Integer.parseInt(checkInData[1]);\\n        travelTimes.put(route, travelTimes.getOrDefault(route, 0) + travelTime);\\n        travelCounts.put(route, travelCounts.getOrDefault(route, 0) + 1);\\n        checkIns.remove(id);\\n    }\\n\\n    public double getAverageTime(String startStation, String endStation) {\\n        String route = startStation + \"->\" + endStation;\\n        return (double) travelTimes.get(route) / travelCounts.get(route);\\n    }\\n}\\n```\n```java []\\nclass UndergroundSystem {\\n\\n    private HashMap<Integer,Map<String,Integer>>st;\\n    private HashMap<String,List<Integer>> avg;\\n\\n    public UndergroundSystem() {\\n        this.avg = new HashMap<>();\\n        this.st = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String sn, int t) {\\n        var s = new HashMap<String,Integer>();\\n        s.put(sn,t);\\n        st.put(id,s);\\n    }\\n    \\n    public void checkOut(int id, String sn, int t) {\\n        if(st.containsKey(id)){\\n            var entry = st.get(id).entrySet().iterator().next();\\n            var key = entry.getKey()+\"->\"+sn;\\n            var pre = entry.getValue();\\n            if(avg.containsKey(key)){\\n                var oldList = avg.get(key);\\n                oldList.add(t - pre);\\n                avg.put(key, oldList);\\n            }else avg.put(key, new ArrayList<>(List.of(t - pre)));\\n        }\\n    }\\n    public double getAverageTime(String sn, String es) {\\n        return avg.get(sn+\"->\"+es).stream().collect(Collectors.averagingInt(Integer::intValue));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581157,
                "title": "by-using-2-maps-in-c-easy-try-it",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nApproach is simple, keep the count of traveling time and number travellers between ecah and every stations.\\n\\n# Complexity\\n- Time complexity:O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n    map<int,pair<string,double>> box;\\n    map<pair<string,string>,pair<double,double>> time;\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        box[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        \\n        string s = box[id].first;\\n        double tmp = box[id].second;\\n        box.erase(id);\\n\\n        if(time.find({s,stationName})==time.end())\\n        {\\n        time[{s,stationName}].first = t-tmp;\\n        time[{s,stationName}].second = 1;\\n        }\\n        else\\n        {\\n            double cnt = time[{s,stationName}].second;\\n            time[{s,stationName}].first+=(t-tmp);\\n            time[{s,stationName}].second = 1+cnt;\\n        }\\n\\n    }\\n    \\n    double getAverageTime(string st, string end) {\\n\\n        if(time.find({st,end})==time.end())\\n        return 0;\\n\\n        double ttime = time[{st,end}].first;\\n        double cnt = time[{st,end}].second;\\n\\n        return ttime/cnt;  \\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    map<int,pair<string,double>> box;\\n    map<pair<string,string>,pair<double,double>> time;\\n    UndergroundSystem() {\\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        box[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        \\n        string s = box[id].first;\\n        double tmp = box[id].second;\\n        box.erase(id);\\n\\n        if(time.find({s,stationName})==time.end())\\n        {\\n        time[{s,stationName}].first = t-tmp;\\n        time[{s,stationName}].second = 1;\\n        }\\n        else\\n        {\\n            double cnt = time[{s,stationName}].second;\\n            time[{s,stationName}].first+=(t-tmp);\\n            time[{s,stationName}].second = 1+cnt;\\n        }\\n\\n    }\\n    \\n    double getAverageTime(string st, string end) {\\n\\n        if(time.find({st,end})==time.end())\\n        return 0;\\n\\n        double ttime = time[{st,end}].first;\\n        double cnt = time[{st,end}].second;\\n\\n        return ttime/cnt;  \\n    }\\n};\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem* obj = new UndergroundSystem();\\n * obj->checkIn(id,stationName,t);\\n * obj->checkOut(id,stationName,t);\\n * double param_3 = obj->getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581073,
                "title": "1396-design-underground-system-java",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(\\u2223passengers\\u2223+\\u2223stations\\u2223^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CheckIn {\\n  public String stationName;\\n  public int time;\\n  public CheckIn(String stationName, int time) {\\n    this.stationName = stationName;\\n    this.time = time;\\n  }\\n}\\n\\nclass CheckOut {\\n  public int numTrips;\\n  public int totalTime;\\n  public CheckOut(int numTrips, int totalTime) {\\n    this.numTrips = numTrips;\\n    this.totalTime = totalTime;\\n  }\\n}\\n\\nclass UndergroundSystem {\\n  public void checkIn(int id, String stationName, int t) {\\n    checkIns.put(id, new CheckIn(stationName, t));\\n  }\\n\\n  public void checkOut(int id, String stationName, int t) {\\n    final CheckIn checkIn = checkIns.get(id);\\n    checkIns.remove(id);\\n    final String route = checkIn.stationName + \"->\" + stationName;\\n    checkOuts.putIfAbsent(route, new CheckOut(0, 0));\\n    ++checkOuts.get(route).numTrips;\\n    checkOuts.get(route).totalTime += t - checkIn.time;\\n  }\\n\\n  public double getAverageTime(String startStation, String endStation) {\\n    final CheckOut checkOut = checkOuts.get(startStation + \"->\" + endStation);\\n    return checkOut.totalTime / (double) checkOut.numTrips;\\n  }\\n\\n  private Map<Integer, CheckIn> checkIns = new HashMap<>();  // {id: (stationName, time)}\\n  private Map<String, CheckOut> checkOuts = new HashMap<>(); // {route: (numTrips, totalTime)}\\n}\\n\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Design",
                    "Bitmask"
                ],
                "code": "```\\nclass CheckIn {\\n  public String stationName;\\n  public int time;\\n  public CheckIn(String stationName, int time) {\\n    this.stationName = stationName;\\n    this.time = time;\\n  }\\n}\\n\\nclass CheckOut {\\n  public int numTrips;\\n  public int totalTime;\\n  public CheckOut(int numTrips, int totalTime) {\\n    this.numTrips = numTrips;\\n    this.totalTime = totalTime;\\n  }\\n}\\n\\nclass UndergroundSystem {\\n  public void checkIn(int id, String stationName, int t) {\\n    checkIns.put(id, new CheckIn(stationName, t));\\n  }\\n\\n  public void checkOut(int id, String stationName, int t) {\\n    final CheckIn checkIn = checkIns.get(id);\\n    checkIns.remove(id);\\n    final String route = checkIn.stationName + \"->\" + stationName;\\n    checkOuts.putIfAbsent(route, new CheckOut(0, 0));\\n    ++checkOuts.get(route).numTrips;\\n    checkOuts.get(route).totalTime += t - checkIn.time;\\n  }\\n\\n  public double getAverageTime(String startStation, String endStation) {\\n    final CheckOut checkOut = checkOuts.get(startStation + \"->\" + endStation);\\n    return checkOut.totalTime / (double) checkOut.numTrips;\\n  }\\n\\n  private Map<Integer, CheckIn> checkIns = new HashMap<>();  // {id: (stationName, time)}\\n  private Map<String, CheckOut> checkOuts = new HashMap<>(); // {route: (numTrips, totalTime)}\\n}\\n\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580856,
                "title": "1396-design-underground-system",
                "content": "```\\nclass UndergroundSystem {\\nprivate:\\n    unordered_map<string,double> avgTime;\\n    unordered_map<string,pair<double,double>> stationData;\\n    unordered_map<int, pair<int,string>> checkInLog;\\npublic:\\n    UndergroundSystem() {}\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInLog[id] = make_pair(t,stationName);\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int totalTime = t - checkInLog[id].first;\\n        string stationKey = checkInLog[id].second + \"-\" + stationName;\\n        checkInLog.erase(id);\\n        \\n        stationData[stationKey].first += totalTime;\\n        stationData[stationKey].second++;\\n        avgTime[stationKey] = stationData[stationKey].first / stationData[stationKey].second;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string stationKey = startStation + \"-\" + endStation;\\n        return avgTime[stationKey];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\nprivate:\\n    unordered_map<string,double> avgTime;\\n    unordered_map<string,pair<double,double>> stationData;\\n    unordered_map<int, pair<int,string>> checkInLog;\\npublic:\\n    UndergroundSystem() {}\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInLog[id] = make_pair(t,stationName);\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        int totalTime = t - checkInLog[id].first;\\n        string stationKey = checkInLog[id].second + \"-\" + stationName;\\n        checkInLog.erase(id);\\n        \\n        stationData[stationKey].first += totalTime;\\n        stationData[stationKey].second++;\\n        avgTime[stationKey] = stationData[stationKey].first / stationData[stationKey].second;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string stationKey = startStation + \"-\" + endStation;\\n        return avgTime[stationKey];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580841,
                "title": "killer-solution-c-stl-unordered-map-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UndergroundSystem \\n{\\npublic:\\n    unordered_map<int,pair<string,int>> m;\\n    \\n    unordered_map<string,int> time,count;\\n    UndergroundSystem() \\n    {\\n\\n    }\\n\\t\\n    void checkIn(int id, string stationName, int t) \\n    {\\n        m[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) \\n    {\\n        auto p=m[id];\\n        string s=p.first+\\'#\\'+stationName;\\n        count[s]++;\\n        time[s]+=t-p.second;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) \\n    {\\n        string s=startStation+\\'#\\'+endStation;\\n        double res=time[s];\\n        return res/count[s];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem \\n{\\npublic:\\n    unordered_map<int,pair<string,int>> m;\\n    \\n    unordered_map<string,int> time,count;\\n    UndergroundSystem() \\n    {\\n\\n    }\\n\\t\\n    void checkIn(int id, string stationName, int t) \\n    {\\n        m[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) \\n    {\\n        auto p=m[id];\\n        string s=p.first+\\'#\\'+stationName;\\n        count[s]++;\\n        time[s]+=t-p.second;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) \\n    {\\n        string s=startStation+\\'#\\'+endStation;\\n        double res=time[s];\\n        return res/count[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580808,
                "title": "python-easy-understanding",
                "content": "Initialize two hash maps:\\n\\ncheckIns: This map will store the check-in information for each customer. The key will be the customer\\'s ID, and the value will be a pair consisting of the station name and the check-in time.\\ntravelTimes: This map will store the total travel time and the number of trips between each pair of stations. The key will be a string combining the start station and end station names, separated by a delimiter, and the value will be a pair consisting of the total travel time and the number of trips.\\nImplement the checkIn method:\\n\\nWhen a customer checks in, store their check-in information in the checkIns map using their ID as the key.\\nImplement the checkOut method:\\n\\nRetrieve the check-in information for the customer using their ID from the checkIns map.\\nCalculate the travel time as the difference between the check-out time and the check-in time.\\nUpdate the travelTimes map by adding the travel time to the existing total travel time and incrementing the number of trips between the start and end stations.\\nRemove the customer\\'s check-in information from the checkIns map.\\nImplement the getAverageTime method:\\n\\nRetrieve the total travel time and the number of trips between the start and end stations from the travelTimes map using the combined station name key.\\nCalculate the average travel time by dividing the total travel time by the number of trips.\\nReturn the average travel time.\\n```\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.checkIns = {}\\n        self.travelTimes = {}\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkIns[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        startStation, startTime = self.checkIns[id]\\n        del self.checkIns[id]\\n\\n        travelKey = startStation + \"->\" + stationName\\n        travelTime, numTrips = self.travelTimes.get(travelKey, (0, 0))\\n        travelTime += t - startTime\\n        numTrips += 1\\n        self.travelTimes[travelKey] = (travelTime, numTrips)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        travelKey = startStation + \"->\" + endStation\\n        travelTime, numTrips = self.travelTimes[travelKey]\\n        return travelTime / numTrips\\n\\n```\\n\\n\\n**Please upvote ;)**\\n\\n![image](https://assets.leetcode.com/users/images/36458a2a-0dcd-4608-807e-305acbf4c8d7_1685506899.5591493.jpeg)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass UndergroundSystem:\\n    def __init__(self):\\n        self.checkIns = {}\\n        self.travelTimes = {}\\n\\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\\n        self.checkIns[id] = (stationName, t)\\n\\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\\n        startStation, startTime = self.checkIns[id]\\n        del self.checkIns[id]\\n\\n        travelKey = startStation + \"->\" + stationName\\n        travelTime, numTrips = self.travelTimes.get(travelKey, (0, 0))\\n        travelTime += t - startTime\\n        numTrips += 1\\n        self.travelTimes[travelKey] = (travelTime, numTrips)\\n\\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\\n        travelKey = startStation + \"->\" + endStation\\n        travelTime, numTrips = self.travelTimes[travelKey]\\n        return travelTime / numTrips\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580738,
                "title": "c-map-super-simple-implementation",
                "content": "```\\n    // s1, s2 -> avg, numPeople\\n    map<pair<string, string> , pair<double, int>> time;\\n    \\n    // id, st, time\\n    map<int , pair<string, int>> in;\\n    map<int , pair<string, int>> out;\\n    \\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        in[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string outStation, int t) {\\n        auto i = in[id];\\n        auto inStation = i.first;\\n        auto inTime = i.second;\\n        \\n        auto travelTime = t-inTime;\\n        \\n        if(time.find({inStation, outStation}) == time.end()){\\n            time[{inStation, outStation}] = {travelTime, 1};\\n        }\\n        else{\\n            auto prevPeople = time[{inStation, outStation}].second;\\n            auto prevAvg = time[{inStation, outStation}].first;\\n            \\n            double newAvg = ((double)(prevPeople*prevAvg) + travelTime)/(prevPeople+1);\\n            time[{inStation, outStation}] = {newAvg, prevPeople+1};\\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return time[{startStation, endStation}].first;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    // s1, s2 -> avg, numPeople\\n    map<pair<string, string> , pair<double, int>> time;\\n    \\n    // id, st, time\\n    map<int , pair<string, int>> in;\\n    map<int , pair<string, int>> out;\\n    \\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        in[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string outStation, int t) {\\n        auto i = in[id];\\n        auto inStation = i.first;\\n        auto inTime = i.second;\\n        \\n        auto travelTime = t-inTime;\\n        \\n        if(time.find({inStation, outStation}) == time.end()){\\n            time[{inStation, outStation}] = {travelTime, 1};\\n        }\\n        else{\\n            auto prevPeople = time[{inStation, outStation}].second;\\n            auto prevAvg = time[{inStation, outStation}].first;\\n            \\n            double newAvg = ((double)(prevPeople*prevAvg) + travelTime)/(prevPeople+1);\\n            time[{inStation, outStation}] = {newAvg, prevPeople+1};\\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return time[{startStation, endStation}].first;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3580699,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass UndergroundSystem {\\npublic:\\n    map<pair<string,string>,pair<int,int>> totalTime;\\n    map<int,pair<string,int>> checkedIn;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(checkedIn.find(id)==checkedIn.end()){\\n            checkedIn[id]={stationName,t};\\n        }\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto customerInfo=checkedIn[id];\\n        string startStation=customerInfo.first;\\n        int timeOfCheckIn=customerInfo.second;\\n        if(totalTime.find({startStation,stationName})==totalTime.end()){\\n            totalTime[{startStation,stationName}]={t-timeOfCheckIn,1};\\n        }\\n        else{\\n            totalTime[{startStation,stationName}].first+=(t-timeOfCheckIn);\\n            totalTime[{startStation,stationName}].second++;\\n        }\\n        checkedIn.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return 1.0*totalTime[{startStation,endStation}].first/totalTime[{startStation,endStation}].second;\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/0ef6c6eb-fbc0-4607-826e-e7479deb6c04_1685503571.3854048.png)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    map<pair<string,string>,pair<int,int>> totalTime;\\n    map<int,pair<string,int>> checkedIn;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(checkedIn.find(id)==checkedIn.end()){\\n            checkedIn[id]={stationName,t};\\n        }\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto customerInfo=checkedIn[id];\\n        string startStation=customerInfo.first;\\n        int timeOfCheckIn=customerInfo.second;\\n        if(totalTime.find({startStation,stationName})==totalTime.end()){\\n            totalTime[{startStation,stationName}]={t-timeOfCheckIn,1};\\n        }\\n        else{\\n            totalTime[{startStation,stationName}].first+=(t-timeOfCheckIn);\\n            totalTime[{startStation,stationName}].second++;\\n        }\\n        checkedIn.erase(id);\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        return 1.0*totalTime[{startStation,endStation}].first/totalTime[{startStation,endStation}].second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580596,
                "title": "2-solutions-self-explanatory-c",
                "content": "# Code 1\\n```\\nclass UndergroundSystem {\\npublic:\\n    map<pair<string,string>,pair<int,int>> avgTime; // {{checkInStation,checkoutStation},{no. of people, sum of time}}\\n    unordered_map<int,pair<string,int>> checkInDetails; // {id,{station Name,time at which you checked in}}\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInDetails[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string checkInStation = checkInDetails[id].first;\\n        int currTime = t - checkInDetails[id].second;\\n        int n = avgTime[{checkInStation,stationName}].first;\\n        int sum = avgTime[{checkInStation,stationName}].second;\\n        \\n        avgTime[{checkInStation,stationName}].first = n+1;\\n        avgTime[{checkInStation,stationName}].second = sum+currTime;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        int n = avgTime[{startStation,endStation}].first;\\n        int sum = avgTime[{startStation,endStation}].second;\\n        double avg = (sum*1.0) / (1.0*n);\\n        return avg;\\n    }\\n};\\n```\\n# Code 2\\n```\\nclass UndergroundSystem {\\npublic:\\n    // route means \"checkInStation -> checkOutStation\"\\n    unordered_map<string,pair<int,int>> avgTime; // {route,{no. of people, sum of time}}\\n    unordered_map<int,pair<string,int>> checkInDetails; // {id,{checkIn station Name,time at which you checked in}}\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInDetails[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string checkInStation = checkInDetails[id].first;\\n        int currTime = t - checkInDetails[id].second;\\n\\n        string route = checkInStation + \" -> \" + stationName;\\n        \\n        avgTime[route].first += 1;\\n        avgTime[route].second += currTime;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string route = startStation + \" -> \" + endStation;\\n        int n = avgTime[route].first;\\n        int sum = avgTime[route].second;\\n        \\n        double avg = sum*1.0 / (1.0*n);\\n        return avg;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    map<pair<string,string>,pair<int,int>> avgTime; // {{checkInStation,checkoutStation},{no. of people, sum of time}}\\n    unordered_map<int,pair<string,int>> checkInDetails; // {id,{station Name,time at which you checked in}}\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInDetails[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string checkInStation = checkInDetails[id].first;\\n        int currTime = t - checkInDetails[id].second;\\n        int n = avgTime[{checkInStation,stationName}].first;\\n        int sum = avgTime[{checkInStation,stationName}].second;\\n        \\n        avgTime[{checkInStation,stationName}].first = n+1;\\n        avgTime[{checkInStation,stationName}].second = sum+currTime;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        int n = avgTime[{startStation,endStation}].first;\\n        int sum = avgTime[{startStation,endStation}].second;\\n        double avg = (sum*1.0) / (1.0*n);\\n        return avg;\\n    }\\n};\\n```\n```\\nclass UndergroundSystem {\\npublic:\\n    // route means \"checkInStation -> checkOutStation\"\\n    unordered_map<string,pair<int,int>> avgTime; // {route,{no. of people, sum of time}}\\n    unordered_map<int,pair<string,int>> checkInDetails; // {id,{checkIn station Name,time at which you checked in}}\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInDetails[id] = {stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        string checkInStation = checkInDetails[id].first;\\n        int currTime = t - checkInDetails[id].second;\\n\\n        string route = checkInStation + \" -> \" + stationName;\\n        \\n        avgTime[route].first += 1;\\n        avgTime[route].second += currTime;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string route = startStation + \" -> \" + endStation;\\n        int n = avgTime[route].first;\\n        int sum = avgTime[route].second;\\n        \\n        double avg = sum*1.0 / (1.0*n);\\n        return avg;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580574,
                "title": "simple-optimized-javascript-solution",
                "content": "\\n# Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n\\nvar UndergroundSystem = function() {\\n    this.map = {}\\n    this.avgTime = {}\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkIn = function(id, stationName, t) {\\n    const { map } = this\\n    map[id] = {startStation:stationName , t: t}\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkOut = function(id, stationName, t) {\\n      const { map, avgTime } = this\\n      const last = map[id]\\n      const key = `e:${stationName}+s:${last.startStation}`\\n      if(avgTime[key])\\n        avgTime[key] = { total: avgTime[key].total + t - last.t, count: avgTime[key].count + 1 }\\n      else\\n        avgTime[key] = { total: t - last.t, count: 1}\\n}\\n/** \\n * @param {string} startStation \\n * @param {string} endStation\\n * @return {number}\\n */\\nUndergroundSystem.prototype.getAverageTime = function(startStation, endStation) {\\n  const { avgTime } = this\\n  const key = `e:${endStation}+s:${startStation}`\\n  const { total, count } = avgTime[key]\\n  return total / count\\n};\\n\\n/** \\n * Your UndergroundSystem object will be instantiated and called as such:\\n * var obj = new UndergroundSystem()\\n * obj.checkIn(id,stationName,t)\\n * obj.checkOut(id,stationName,t)\\n * var param_3 = obj.getAverageTime(startStation,endStation)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\n\\nvar UndergroundSystem = function() {\\n    this.map = {}\\n    this.avgTime = {}\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkIn = function(id, stationName, t) {\\n    const { map } = this\\n    map[id] = {startStation:stationName , t: t}\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} stationName \\n * @param {number} t\\n * @return {void}\\n */\\nUndergroundSystem.prototype.checkOut = function(id, stationName, t) {\\n      const { map, avgTime } = this\\n      const last = map[id]\\n      const key = `e:${stationName}+s:${last.startStation}`\\n      if(avgTime[key])\\n        avgTime[key] = { total: avgTime[key].total + t - last.t, count: avgTime[key].count + 1 }\\n      else\\n        avgTime[key] = { total: t - last.t, count: 1}\\n}\\n/** \\n * @param {string} startStation \\n * @param {string} endStation\\n * @return {number}\\n */\\nUndergroundSystem.prototype.getAverageTime = function(startStation, endStation) {\\n  const { avgTime } = this\\n  const key = `e:${endStation}+s:${startStation}`\\n  const { total, count } = avgTime[key]\\n  return total / count\\n};\\n\\n/** \\n * Your UndergroundSystem object will be instantiated and called as such:\\n * var obj = new UndergroundSystem()\\n * obj.checkIn(id,stationName,t)\\n * obj.checkOut(id,stationName,t)\\n * var param_3 = obj.getAverageTime(startStation,endStation)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3580459,
                "title": "c-beginner-friendly-easy-solution-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass UndergroundSystem {\\npublic:\\nunordered_map< string  ,vector<int> >avg;\\n   unordered_map<int,pair<string,int>>cIN;\\n\\n    UndergroundSystem() {\\n     \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        cIN[id] = {stationName,t};\\n       \\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(cIN.find(id) != cIN.end()){\\n            pair<string , int>p  = cIN[id];\\n            string s  = ( p.first+\":\"+stationName);\\n            avg[s].push_back(abs(t-p.second));\\n            \\n          \\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n       string p = (startStation +\":\"+ endStation);\\n        double ans = 0 ;\\n          \\n            \\n            vector<int>v = avg[p];\\n            double sum = 0 ;\\n         for(auto x : v){\\n             sum += x;\\n         }\\n            double count = v.size();\\n          \\n            ans = sum/count;\\n        \\n\\n        return ans ;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\nunordered_map< string  ,vector<int> >avg;\\n   unordered_map<int,pair<string,int>>cIN;\\n\\n    UndergroundSystem() {\\n     \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        cIN[id] = {stationName,t};\\n       \\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(cIN.find(id) != cIN.end()){\\n            pair<string , int>p  = cIN[id];\\n            string s  = ( p.first+\":\"+stationName);\\n            avg[s].push_back(abs(t-p.second));\\n            \\n          \\n        }\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n       string p = (startStation +\":\"+ endStation);\\n        double ans = 0 ;\\n          \\n            \\n            vector<int>v = avg[p];\\n            double sum = 0 ;\\n         for(auto x : v){\\n             sum += x;\\n         }\\n            double count = v.size();\\n          \\n            ans = sum/count;\\n        \\n\\n        return ans ;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580384,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {}\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInData[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& [startStation, startTime] = checkInData[id];\\n        string route = startStation + \"_\" + stationName;\\n        travelTimes[route].first += t - startTime;\\n        travelTimes[route].second += 1;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string route = startStation + \"_\" + endStation;\\n        auto& [totalTime, numTrips] = travelTimes[route];\\n        return (double)totalTime / numTrips;\\n    }\\nprivate:\\n    unordered_map<int, pair<string, int>> checkInData;\\n    unordered_map<string, pair<int, int>> travelTimes;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    UndergroundSystem() {}\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        checkInData[id] = {stationName, t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto& [startStation, startTime] = checkInData[id];\\n        string route = startStation + \"_\" + stationName;\\n        travelTimes[route].first += t - startTime;\\n        travelTimes[route].second += 1;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string route = startStation + \"_\" + endStation;\\n        auto& [totalTime, numTrips] = travelTimes[route];\\n        return (double)totalTime / numTrips;\\n    }\\nprivate:\\n    unordered_map<int, pair<string, int>> checkInData;\\n    unordered_map<string, pair<int, int>> travelTimes;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032202,
                "title": "java-my-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Customer {\\n    String startStationName;\\n    String endStationName;\\n    int startTime;\\n    int endTime;\\n    int tripTime;\\n\\n    Customer(String startStationName, int startTime) {\\n        this.startStationName = startStationName;\\n        this.startTime = startTime;\\n    }\\n}\\n\\nclass UndergroundSystem {\\n    HashMap<Integer, Customer> customers;\\n    HashMap<String, int[]> averages;\\n\\n    public UndergroundSystem() {\\n        customers = new HashMap<Integer, Customer>();\\n        averages = new HashMap<String, int[]>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        Customer customer = new Customer(stationName, t);\\n        customers.put(id, customer);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Customer customer = customers.get(id);\\n        customer.endStationName = stationName;\\n        customer.endTime = t;\\n        customer.tripTime = customer.endTime - customer.startTime;\\n        customers.put(id, customer);\\n        \\n        String trip = customer.startStationName + \"->\" + customer.endStationName;\\n        int[] avgTripTime = averages.getOrDefault(trip, new int[2]);\\n        avgTripTime[0]++;\\n        avgTripTime[1]+=customer.tripTime;\\n        averages.put(trip, avgTripTime);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String trip = startStation + \"->\" + endStation;\\n        int[] avgTripTime = averages.get(trip);\\n        return (double)avgTripTime[1] / (double)avgTripTime[0];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Customer {\\n    String startStationName;\\n    String endStationName;\\n    int startTime;\\n    int endTime;\\n    int tripTime;\\n\\n    Customer(String startStationName, int startTime) {\\n        this.startStationName = startStationName;\\n        this.startTime = startTime;\\n    }\\n}\\n\\nclass UndergroundSystem {\\n    HashMap<Integer, Customer> customers;\\n    HashMap<String, int[]> averages;\\n\\n    public UndergroundSystem() {\\n        customers = new HashMap<Integer, Customer>();\\n        averages = new HashMap<String, int[]>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        Customer customer = new Customer(stationName, t);\\n        customers.put(id, customer);\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        Customer customer = customers.get(id);\\n        customer.endStationName = stationName;\\n        customer.endTime = t;\\n        customer.tripTime = customer.endTime - customer.startTime;\\n        customers.put(id, customer);\\n        \\n        String trip = customer.startStationName + \"->\" + customer.endStationName;\\n        int[] avgTripTime = averages.getOrDefault(trip, new int[2]);\\n        avgTripTime[0]++;\\n        avgTripTime[1]+=customer.tripTime;\\n        averages.put(trip, avgTripTime);\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        String trip = startStation + \"->\" + endStation;\\n        int[] avgTripTime = averages.get(trip);\\n        return (double)avgTripTime[1] / (double)avgTripTime[0];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872299,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UndergroundSystem {\\n    class Pair{\\n        String Start;\\n        String end;\\n        int t;\\n        Pair(String Start,String end,int t){\\n           this.Start = Start;\\n           this.end = end;\\n           this.t = t;     \\n        }\\n    }\\n     \\n    public UndergroundSystem() {\\n        hm = new HashMap<>();\\n        stationsMap = new HashMap<>();\\n\\n    }\\n    HashMap<Integer,Pair> hm;\\n    public void checkIn(int id, String stationName, int t) {\\n         hm.put(id,new Pair(stationName,\"\",t));\\n    }\\n    class avrgPair{\\n        int count;\\n        int totalT;\\n        avrgPair(int count,int totalT){\\n            this.count = count;\\n            this.totalT =totalT;\\n        }\\n    }\\n\\n    HashMap<Integer,avrgPair> stationsMap;\\n    public void checkOut(int id, String stationName, int t) {\\n        Pair  p =  hm.remove(id);\\n        String st = p.Start;\\n        int startTime = p.t;\\n        int total = t-startTime;\\n        if(stationsMap.containsKey(getHash(st,stationName))){\\n            \\n            avrgPair np = stationsMap.get(getHash(st,stationName));\\n            int co = np.count+1;\\n            int time = np.totalT+total;\\n            stationsMap.put(getHash(st,stationName),new avrgPair(co,time));\\n        }else {\\n            stationsMap.put(getHash(st,stationName),new avrgPair(1,total));\\n        }\\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        avrgPair p = stationsMap.get(getHash(startStation,endStation));\\n        int co = p.count;\\n        int time = p.totalT;\\n        double ans = (time*1.0) /(co*1.0);\\n        return ans;\\n    }\\n    public int getHash(String startStation, String endStation) {\\n        return (int) (startStation + \"#\" + endStation).hashCode();\\n    }\\n\\n}\\n \\n// 32  || aa 8\\n// 27  || a 10\\n\\n// co\\n \\n// aab || 2 22\\n// aab \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass UndergroundSystem {\\n    class Pair{\\n        String Start;\\n        String end;\\n        int t;\\n        Pair(String Start,String end,int t){\\n           this.Start = Start;\\n           this.end = end;\\n           this.t = t;     \\n        }\\n    }\\n     \\n    public UndergroundSystem() {\\n        hm = new HashMap<>();\\n        stationsMap = new HashMap<>();\\n\\n    }\\n    HashMap<Integer,Pair> hm;\\n    public void checkIn(int id, String stationName, int t) {\\n         hm.put(id,new Pair(stationName,\"\",t));\\n    }\\n    class avrgPair{\\n        int count;\\n        int totalT;\\n        avrgPair(int count,int totalT){\\n            this.count = count;\\n            this.totalT =totalT;\\n        }\\n    }\\n\\n    HashMap<Integer,avrgPair> stationsMap;\\n    public void checkOut(int id, String stationName, int t) {\\n        Pair  p =  hm.remove(id);\\n        String st = p.Start;\\n        int startTime = p.t;\\n        int total = t-startTime;\\n        if(stationsMap.containsKey(getHash(st,stationName))){\\n            \\n            avrgPair np = stationsMap.get(getHash(st,stationName));\\n            int co = np.count+1;\\n            int time = np.totalT+total;\\n            stationsMap.put(getHash(st,stationName),new avrgPair(co,time));\\n        }else {\\n            stationsMap.put(getHash(st,stationName),new avrgPair(1,total));\\n        }\\n        \\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        avrgPair p = stationsMap.get(getHash(startStation,endStation));\\n        int co = p.count;\\n        int time = p.totalT;\\n        double ans = (time*1.0) /(co*1.0);\\n        return ans;\\n    }\\n    public int getHash(String startStation, String endStation) {\\n        return (int) (startStation + \"#\" + endStation).hashCode();\\n    }\\n\\n}\\n \\n// 32  || aa 8\\n// 27  || a 10\\n\\n// co\\n \\n// aab || 2 22\\n// aab \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864489,
                "title": "java-oops-based",
                "content": "```\\nclass CheckIn {\\n    String startStation;\\n    int time;\\n    \\n    public CheckIn(String startStation, int time) {\\n        this.startStation = startStation;\\n        this.time = time;\\n    }\\n    \\n    public String getStartStation() {\\n        return startStation;\\n    }\\n    \\n    public int getTime() {\\n        return time;\\n    }\\n}\\nclass Durations {\\n    String startStation;\\n    String endStation;\\n    int durations;\\n    \\n    public Durations(String startStation, String endStation) {\\n        this.startStation = startStation;\\n        this.endStation = endStation;\\n        this.durations = 0;\\n    }\\n    \\n    public void addDuration(int time) {\\n        durations += time;\\n    }\\n    \\n    public int getTotalTime() {\\n        return durations;\\n    }\\n}\\n\\nclass Trips {\\n    String startStation;\\n    String endStation;\\n    int times;\\n    \\n    public Trips(String startStation, String endStation) {\\n        this.startStation = startStation;\\n        this.endStation = endStation;\\n        this.times = 0;\\n    }\\n    \\n    public void increment() {\\n        times += 1;\\n    } \\n    \\n    public int getTotalTrips() {\\n        return times;\\n    }\\n}\\n\\nclass UndergroundSystem {\\n    Map<Integer, CheckIn> passengerStarts;\\n    Map<Integer, Durations> durations;\\n    Map<Integer, Trips> frequency;\\n    \\n    public UndergroundSystem() {\\n        passengerStarts = new HashMap<>();\\n        durations = new HashMap<>();\\n        frequency = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        passengerStarts.put(id, new CheckIn(stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        CheckIn checkIn = passengerStarts.get(id);\\n        int startTime = checkIn.getTime();\\n        String startStation = checkIn.getStartStation();\\n        int delta = t - startTime;\\n        int hash = getHash(startStation, stationName);\\n        durations.computeIfAbsent(hash, key -> new Durations(startStation, stationName)).addDuration(delta);\\n        frequency.computeIfAbsent(hash, key -> new Trips(startStation, stationName)).increment();\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        int hash = getHash(startStation, endStation);\\n        return durations.get(hash).getTotalTime() / (frequency.get(hash).getTotalTrips() * 1.0);\\n    }\\n    \\n    public int getHash(String startStation, String endStation) {\\n        return (int) (startStation + \"#\" + endStation).hashCode();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CheckIn {\\n    String startStation;\\n    int time;\\n    \\n    public CheckIn(String startStation, int time) {\\n        this.startStation = startStation;\\n        this.time = time;\\n    }\\n    \\n    public String getStartStation() {\\n        return startStation;\\n    }\\n    \\n    public int getTime() {\\n        return time;\\n    }\\n}\\nclass Durations {\\n    String startStation;\\n    String endStation;\\n    int durations;\\n    \\n    public Durations(String startStation, String endStation) {\\n        this.startStation = startStation;\\n        this.endStation = endStation;\\n        this.durations = 0;\\n    }\\n    \\n    public void addDuration(int time) {\\n        durations += time;\\n    }\\n    \\n    public int getTotalTime() {\\n        return durations;\\n    }\\n}\\n\\nclass Trips {\\n    String startStation;\\n    String endStation;\\n    int times;\\n    \\n    public Trips(String startStation, String endStation) {\\n        this.startStation = startStation;\\n        this.endStation = endStation;\\n        this.times = 0;\\n    }\\n    \\n    public void increment() {\\n        times += 1;\\n    } \\n    \\n    public int getTotalTrips() {\\n        return times;\\n    }\\n}\\n\\nclass UndergroundSystem {\\n    Map<Integer, CheckIn> passengerStarts;\\n    Map<Integer, Durations> durations;\\n    Map<Integer, Trips> frequency;\\n    \\n    public UndergroundSystem() {\\n        passengerStarts = new HashMap<>();\\n        durations = new HashMap<>();\\n        frequency = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n        passengerStarts.put(id, new CheckIn(stationName, t));\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n        CheckIn checkIn = passengerStarts.get(id);\\n        int startTime = checkIn.getTime();\\n        String startStation = checkIn.getStartStation();\\n        int delta = t - startTime;\\n        int hash = getHash(startStation, stationName);\\n        durations.computeIfAbsent(hash, key -> new Durations(startStation, stationName)).addDuration(delta);\\n        frequency.computeIfAbsent(hash, key -> new Trips(startStation, stationName)).increment();\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        int hash = getHash(startStation, endStation);\\n        return durations.get(hash).getTotalTime() / (frequency.get(hash).getTotalTrips() * 1.0);\\n    }\\n    \\n    public int getHash(String startStation, String endStation) {\\n        return (int) (startStation + \"#\" + endStation).hashCode();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574126,
                "title": "java-solution",
                "content": "```\\nclass UndergroundSystem {\\n    Map<Integer,Integer> idTime; // id, in time\\n    Map<Integer,String> idStation;\\n    Map<String,Integer> time,len;// (from-to, timetaken) (from-to,occurence)\\n    public UndergroundSystem() {\\n        idTime =new HashMap<>();\\n        idStation =new HashMap<>();\\n        time = new HashMap<>();\\n        len = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String name, int t) {\\n        idStation.put(id,name);\\n        idTime.put(id,t);\\n    }\\n    \\n    public void checkOut(int id, String name, int t) {\\n        String from = idStation.get(id),to= name,path = from+\"-\"+to;\\n        int start = idTime.get(id);\\n        time.put(path,time.getOrDefault(path,0)+t-start);\\n        len.put(path,len.getOrDefault(path,0)+1);\\n    }\\n    \\n    public double getAverageTime(String from, String to) {\\n        String path = from+\"-\"+to;\\n        double dist = time.get(path);\\n        return dist/len.get(path);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UndergroundSystem {\\n    Map<Integer,Integer> idTime; // id, in time\\n    Map<Integer,String> idStation;\\n    Map<String,Integer> time,len;// (from-to, timetaken) (from-to,occurence)\\n    public UndergroundSystem() {\\n        idTime =new HashMap<>();\\n        idStation =new HashMap<>();\\n        time = new HashMap<>();\\n        len = new HashMap<>();\\n    }\\n    \\n    public void checkIn(int id, String name, int t) {\\n        idStation.put(id,name);\\n        idTime.put(id,t);\\n    }\\n    \\n    public void checkOut(int id, String name, int t) {\\n        String from = idStation.get(id),to= name,path = from+\"-\"+to;\\n        int start = idTime.get(id);\\n        time.put(path,time.getOrDefault(path,0)+t-start);\\n        len.put(path,len.getOrDefault(path,0)+1);\\n    }\\n    \\n    public double getAverageTime(String from, String to) {\\n        String path = from+\"-\"+to;\\n        double dist = time.get(path);\\n        return dist/len.get(path);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532884,
                "title": "c-hashmap-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int,pair<string,int>> m;\\n    unordered_map<string,int> time,count;\\n    UndergroundSystem() {\\n    }\\n\\t\\n    void checkIn(int id, string stationName, int t) {\\n        m[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto p=m[id];\\n        string s=p.first+\\'#\\'+stationName;\\n        count[s]++;\\n        time[s]+=t-p.second;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string s=startStation+\\'#\\'+endStation;\\n        double res=time[s];\\n        return res/count[s];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UndergroundSystem {\\npublic:\\n    unordered_map<int,pair<string,int>> m;\\n    unordered_map<string,int> time,count;\\n    UndergroundSystem() {\\n    }\\n\\t\\n    void checkIn(int id, string stationName, int t) {\\n        m[id]={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto p=m[id];\\n        string s=p.first+\\'#\\'+stationName;\\n        count[s]++;\\n        time[s]+=t-p.second;\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        string s=startStation+\\'#\\'+endStation;\\n        double res=time[s];\\n        return res/count[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565016,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911449,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911455,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911685,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911533,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911902,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911471,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1912027,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911629,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567752,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565016,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911449,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911455,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911685,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911533,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911902,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911471,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1912027,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1911629,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567752,
                "content": [
                    {
                        "username": "xuawai",
                        "content": "Test this simple test case:\\n`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\", \"getAverageTime\"]\\n[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`.\\n\\nIf you fail to pass all the test cases but do not know why, a possible reason is that the start station and the end station are not consistent in your codes.\\n\\nIn the above example, the customer with `id = 1` gets in the station `A` at `t1=1` and gets out in the station `B` at `t2=5`, then gets in the station `A` at `t3=10` and gets out in `B` again at `t4=20`. \\nThe expected answer should be `((t4-t3) + (t2-t1)) / 2 = 7`. \\nBut some codes may arrive at `(t4-t3) / 1 = 10`.\\n\\nThe description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly."
                    },
                    {
                        "username": "baseballlover723",
                        "content": "agreed, the description implies that checkIns and checkOuts are consistent. But I find double checkIns or checkOuts to be inconsistent or at least undefined behavior. If part of the problem is to consider that the input data might not be non sensical then I think they should clarify that explicitly. For a problem that seems pretty grounded in the real world, the expected solution is bizarre. I could easily see a strong argument that the you should only consider the last checkIn time before the first checkOut time and ignoring any other data points for that customer until they checkIn again. \\n\\nBut the expected solution expects that you count a double checkOut as 2 distinct trips, which seems counter to the problem statement, since presumably, they didn\\'t actually travel anywhere. In particular `\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]]` makes 0 sense. There should absolutely not consider this to be 2 trips.\\n\\nJust a poorly worded question imo. Good interview question though, since you can discuss with the interviewer about what to do with non sensical data."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Thank you! \"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\" Completely agree, and clearly the reason I was failing those final test cases. Saved me a lot of frustration, my friend."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What if a traveler disappears along the way? You never know what can happen."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Dhananjay40](/Dhananjay40) \\u263A\\u263A\\u263A\\u263A\\u263A\\u263A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Oh its been u...the subway killer"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "This would\\'ve been a more interesting problem if it inputted A-B, B-C and asked for A-C avg. time making it a graph problem more than just a simple hash map problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) And yes, it would be a very unusual and interesting problem of finding the shortest path in a weighted graph with incomplete data on its edges, with said data being supplemented (or made obsolete ) over time.\n\nSomething like: for our class, there would be a method periodically called, passing new info about the graph, and periodically, a method asking about the minimal path between two stations. The goal is to return the correct answer every time / or as early as it is possible to find a way based on information received so far.\n\nMoreover, you can make calls to these functions in different threads instead of being synchronous, so that our class has to be efficient in order to process the data and recalculate pathes in time.\n\nBoy, that would make an awesome problem."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cartesPerforees](/cartesPerforees) $t(A, B) \\\\neq t(A, B)$ makes sense if, for example, the paths between stations are one-way, i.e. the path from A to B and from B to A are literally two different tracks. Or even, they are the same road, just going uphill in one direction and downhill in the other. So I guess the laws of time-space work in their world as usual."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@kiryu_0](/kiryu_0) it\\'s an interesting thought tho. Maybe they could make something based on it, and find some ways to simplify the details"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@dev-null0](/dev-null0) weird flex but ok"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah that\\'s what I thought the problem meant when I saw \"Medium,\" but it\\'s just an easy"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@cartesPerforees](/cartesPerforees) Guess that\\'s why I am not a problem setter XD. Just a thought of making this into a graph problem maybe by changing the assumptions was interesting to me, didn\\'t put any thought to it :P"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Except that the problem states that $t(A,B) \\\\neq t(B,A)$, so I wouldn't be confident making the assumption that $t(A,C)=t(A,B)+t(B,C)$ in their world.\nYou might also have several routes from A to C, possibly of varying length, and since we are talking about an average of random samples, it is not possible in general to determine on-the-fly which route is the fastest (it might change with new data). So, assuming your problem is asking for the average time of the optimal route, you would have to store all the possible paths times and decide at output time which one is currently the best (which might change from one query to another).\n\nI think it would be quite tricky to properly define the problem you propose without leaving some very frustrating ambiguities. And the problem would definitely be quite hard, and pretty messy imo"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@ms232gg](/ms232gg) We do this every day  in Subways!!!!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "Except it won\\'t make any sense in this case as it is an underground railway network"
                    },
                    {
                        "username": "vitortterra",
                        "content": "This sounds like an interesting follow-up to this problem"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why this question feels like an SQL query"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": ":))))"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I tried it that way, but I became lazzy LOL"
                    },
                    {
                        "username": "NanoTree",
                        "content": "If you can\\'t figure out why you are getting it wrong, make sure you recognize that a customer can \"check in\" more than once before reaching their destination. They just can\\'t be checked in to more than on station at a time. The initial test cases don\\'t cover this.\\n\\nIn a real job, you would be able to (and expected to) ask about this detail so that you don\\'t make a wrong assumption. But in problem solving you cannot. So please, who ever writes these questions, for the love of all that is holy, please make sure you clarify details like this."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you are able and expected to ask a question to clarify this detail, then you are also able to write a clarifying test case to check it. \nIf your test case is accepted as valid input, then assume that you can encounter inputs of that form"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Oof! I have finally got my first Monthly badge.\\uD83D\\uDE05"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Congrats!!!! I spect this can be my month"
                    },
                    {
                        "username": "romegenix",
                        "content": "Lets go guys , it\\'s the final one , after hard questions like stone ages , we can solve this one ."
                    },
                    {
                        "username": "Ewok_of_Rivia",
                        "content": "Somebody else is stuck on 51?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me on 52\\n"
                    },
                    {
                        "username": "0xSeoudy",
                        "content": "me too :("
                    },
                    {
                        "username": "taikhoanx7",
                        "content": "me too"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "mee\\n"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Amazing question to clear all concepts of hashmaps"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "mere to kuch jyada hi clear ho gye maine ye use kra hai \n\n`unordered_map<string,unordered_map<string,vector<double>>> station;`\n\n bhai aur isse pehle ye use kr rha tha\n\n`unordered_map<string,vector<pair<string,vector<double>>>> station;`\n\nJust thing about the concept i am mastered now\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-underground-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two HashMaps\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1807232,
                "content": [
                    {
                        "username": "jax_ay",
                        "content": "`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\"] [[],[117077,\"OZ13ZSIN\",42],[117077,\"FU1D57HA\",125],[704903,\"OZ13ZSIN\",211],[911239,\"OZ13ZSIN\",245],[704903,\"HG98HCFL\",340],[859828,\"OZ13ZSIN\",355],[\"OZ13ZSIN\",\"FU1D57HA\"],[911239,\"FU1D57HA\",383],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[859828,\"FU1D57HA\",402],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[363027,\"OZ13ZSIN\",489],[319826,\"OZ13ZSIN\",550],[\"OZ13ZSIN\",\"FU1D57HA\"],[363027,\"HG98HCFL\",565],[319826,\"FU1D57HA\",664],[120084,\"OZ13ZSIN\",735],[\"OZ13ZSIN\",\"HG98HCFL\"],[120084,\"HG98HCFL\",832],[56672,\"OZ13ZSIN\",876],[56672,\"HG98HCFL\",912],[638995,\"OZ13ZSIN\",925],[\"OZ13ZSIN\",\"FU1D57HA\"],[638995,\"FU1D57HA\",951],[712949,\"OZ13ZSIN\",1023],[712949,\"FU1D57HA\",1033],[278482,\"T25R11PB\",1080],[\"OZ13ZSIN\",\"FU1D57HA\"],[278482,\"FU1D57HA\",1160],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[342818,\"4SBAAFIP\",1250],[342818,\"HG98HCFL\",1263],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[415673,\"OZ13ZSIN\",1270],[415673,\"NTNXSB47\",1366],[\"T25R11PB\",\"FU1D57HA\"],[597115,\"4SBAAFIP\",1385],[463555,\"OZ13ZSIN\",1461],[463555,\"HG98HCFL\",1514],[801778,\"OZ13ZSIN\",1537],[201428,\"OZ13ZSIN\",1620],[245538,\"OZ13ZSIN\",1630],[597115,\"FU1D57HA\",1657],[583112,\"OZ13ZSIN\",1690],[\"4SBAAFIP\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[691834,\"OZ13ZSIN\",1723],[250537,\"OZ13ZSIN\",1753],[201428,\"H4UTDCR8\",1804],[691834,\"FU1D57HA\",1838],[\"T25R11PB\",\"FU1D57HA\"],[245538,\"FU1D57HA\",1924],[346824,\"OZ13ZSIN\",1952],[864512,\"OZ13ZSIN\",2005],[499705,\"OZ13ZSIN\",2048],[482469,\"GQINA28A\",2058],[\"OZ13ZSIN\",\"FU1D57HA\"],[583112,\"E35YW0BM\",2080],[\"OZ13ZSIN\",\"HG98HCFL\"],[801778,\"HG98HCFL\",2082],[250415,\"I0Y75MZQ\",2149],[795633,\"OZ13ZSIN\",2196],[\"OZ13ZSIN\",\"HG98HCFL\"],[99144,\"4SBAAFIP\",2219],[83594,\"OZ13ZSIN\",2249],[346824,\"HG98HCFL\",2290],[482469,\"HG98HCFL\",2368],[499705,\"FU1D57HA\",2437],[12539,\"OZ13ZSIN\",2442],[116546,\"OZ13ZSIN\",2493],[884032,\"4SBAAFIP\",2579],[801142,\"OZ13ZSIN\",2598],[795633,\"HG98HCFL\",2693],[83594,\"HG98HCFL\",2782],[529306,\"OZ13ZSIN\",2824],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[286490,\"OZ13ZSIN\",2844],[255488,\"OZ13ZSIN\",2935],[608514,\"OZ13ZSIN\",2984],[116546,\"HG98HCFL\",3079],[250415,\"FU1D57HA\",3174],[\"OZ13ZSIN\",\"FU1D57HA\"],[884032,\"E35YW0BM\",3267],[\"OZ13ZSIN\",\"FU1D57HA\"],[529306,\"HG98HCFL\",3299],[\"OZ13ZSIN\",\"FU1D57HA\"],[892550,\"OZ13ZSIN\",3388],[892550,\"2VVKO5AZ\",3394],[14673,\"OZ13ZSIN\",3487],[\"OZ13ZSIN\",\"HG98HCFL\"],[12539,\"HG98HCFL\",3576],[\"OZ13ZSIN\",\"HG98HCFL\"],[255488,\"HG98HCFL\",3674],[\"OZ13ZSIN\",\"HG98HCFL\"],[14673,\"HG98HCFL\",3754],[864512,\"FU1D57HA\",3819],[451611,\"OZ13ZSIN\",3899],[\"4SBAAFIP\",\"E35YW0BM\"],[451611,\"HG98HCFL\",3941],[250537,\"HG98HCFL\",4027],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[286490,\"FU1D57HA\",4046],[608514,\"HG98HCFL\",4094],[827431,\"XWO403P7\",4107],[99144,\"HG98HCFL\",4136],[\"GQINA28A\",\"HG98HCFL\"],[657832,\"OZ13ZSIN\",4150],[827431,\"HG98HCFL\",4214],[\"OZ13ZSIN\",\"FU1D57HA\"],[658842,\"OZ13ZSIN\",4236],[52933,\"4SBAAFIP\",4325],[801142,\"HG98HCFL\",4413],[52933,\"E35YW0BM\",4460],[331712,\"OZ13ZSIN\",4522],[658842,\"NTNXSB47\",4615],[293734,\"OZ13ZSIN\",4665],[293734,\"HG98HCFL\",4735],[917903,\"OZ13ZSIN\",4772],[119860,\"OZ13ZSIN\",4775],[\"OZ13ZSIN\",\"HG98HCFL\"],[657832,\"E35YW0BM\",4850],[415861,\"NJB0V6ZO\",4881],[\"OZ13ZSIN\",\"FU1D57HA\"],[917903,\"HG98HCFL\",4892],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[415861,\"HG98HCFL\",4919],[\"OZ13ZSIN\",\"HG98HCFL\"],[331712,\"OGVA50NO\",4979],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[119860,\"HG98HCFL\",5034],[469875,\"OZ13ZSIN\",5053],[407362,\"XT14GVGK\",5073],[469875,\"HG98HCFL\",5126],[407362,\"HG98HCFL\",5175],[324747,\"OZ13ZSIN\",5236],[315560,\"OZ13ZSIN\",5333],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[317815,\"OZ13ZSIN\",5339],[906872,\"OZ13ZSIN\",5349],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[404251,\"OZ13ZSIN\",5375],[324747,\"HG98HCFL\",5474],[882572,\"OZ13ZSIN\",5524],[\"OZ13ZSIN\",\"HG98HCFL\"],[758501,\"OZ13ZSIN\",5561],[404251,\"FU1D57HA\",5617],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[315560,\"HG98HCFL\",5651],[758501,\"HG98HCFL\",5673],[141090,\"OZ13ZSIN\",5768],[882572,\"FU1D57HA\",5827],[906872,\"HG98HCFL\",5872],[141090,\"HG98HCFL\",5940],[\"OZ13ZSIN\",\"FU1D57HA\"],[317815,\"HG98HCFL\",5996],[436252,\"OZ13ZSIN\",6027],[\"OZ13ZSIN\",\"E35YW0BM\"],[436252,\"HG98HCFL\",6084],[\"OZ13ZSIN\",\"NTNXSB47\"],[652912,\"NJB0V6ZO\",6155],[652912,\"HG98HCFL\",6169],[269825,\"NJB0V6ZO\",6173],[831024,\"OZ13ZSIN\",6267],[831024,\"FU1D57HA\",6317],[269825,\"FU1D57HA\",6318],[794093,\"OZ13ZSIN\",6406],[\"OZ13ZSIN\",\"HG98HCFL\"],[794093,\"FU1D57HA\",6429],[798558,\"OZ13ZSIN\",6497],[798558,\"E35YW0BM\",6500],[271136,\"NJB0V6ZO\",6582],[\"OZ13ZSIN\",\"HG98HCFL\"],[608446,\"OZ13ZSIN\",6662],[608446,\"FU1D57HA\",6760],[986152,\"OZ13ZSIN\",6799],[986152,\"NTNXSB47\",6825],[271136,\"HG98HCFL\",6911],[\"OZ13ZSIN\",\"FU1D57HA\"],[341349,\"OZ13ZSIN\",6995],[595955,\"OZ13ZSIN\",7039],[58242,\"H9OKZANW\",7071],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[134319,\"OZ13ZSIN\",7119],[595955,\"FU1D57HA\",7161],[\"OZ13ZSIN\",\"HG98HCFL\"],[266781,\"OZ13ZSIN\",7208],[\"OZ13ZSIN\",\"FU1D57HA\"],[266781,\"FU1D57HA\",7298],[\"OZ13ZSIN\",\"NTNXSB47\"],[935757,\"OZ13ZSIN\",7300],[517277,\"OZ13ZSIN\",7376],[58242,\"HG98HCFL\",7459],[\"OZ13ZSIN\",\"HG98HCFL\"],[288203,\"OZ13ZSIN\",7512],[293244,\"T25R11PB\",7580],[517277,\"HG98HCFL\",7588],[293244,\"FU1D57HA\",7649],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[480741,\"OZ13ZSIN\",7748],[288203,\"CWJHORPF\",7845],[935757,\"NTNXSB47\",7940],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[341349,\"HG98HCFL\",7952],[870607,\"ST6XEPDA\",7986],[\"OZ13ZSIN\",\"CWJHORPF\"],[468450,\"6QKM8CM8\",8063],[262669,\"OZ13ZSIN\",8152],[\"OZ13ZSIN\",\"FU1D57HA\"],[103929,\"OZ13ZSIN\",8167],[415331,\"X8W3R0P7\",8215],[134319,\"E35YW0BM\",8226],[415331,\"FU1D57HA\",8240],[468450,\"HG98HCFL\",8263],[394949,\"XOK1HH1Y\",8313],[\"OZ13ZSIN\",\"HG98HCFL\"],[394949,\"FU1D57HA\",8402],[67177,\"GQINA28A\",8451],[67177,\"HG98HCFL\",8521],[796191,\"QJHWOKDQ\",8545],[\"I0Y75MZQ\",\"FU1D57HA\"],[\"H9OKZANW\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[940010,\"OZ13ZSIN\",8583],[940010,\"VL50N6D1\",8613],[21260,\"WGOD5SD4\",8683],[746866,\"NJB0V6ZO\",8732],[47896,\"OZ13ZSIN\",8802],[480741,\"CWJHORPF\",8839],[\"NJB0V6ZO\",\"HG98HCFL\"],[310852,\"XT82S77E\",8858],[796001,\"OZ13ZSIN\",8860],[\"OZ13ZSIN\",\"NTNXSB47\"],[103929,\"FU1D57HA\",8957],[739455,\"OZ13ZSIN\",8980],[\"XWO403P7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"VL50N6D1\"],[734337,\"OZ13ZSIN\",8989],[686615,\"4SBAAFIP\",9086],[21260,\"HG98HCFL\",9130],[\"OZ13ZSIN\",\"CWJHORPF\"],[217165,\"1XW6HVBY\",9228],[689774,\"OZ13ZSIN\",9313],[870607,\"NTNXSB47\",9319],[248471,\"OZ13ZSIN\",9376],[262669,\"E35YW0BM\",9427],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[20582,\"OZ13ZSIN\",9484],[310852,\"LBYS94AD\",9535],[746866,\"FU1D57HA\",9540],[689774,\"FU1D57HA\",9594],[796191,\"HG98HCFL\",9635],[\"OZ13ZSIN\",\"FU1D57HA\"],[734337,\"HG98HCFL\",9683],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[982523,\"XWO403P7\",9689],[\"OZ13ZSIN\",\"OGVA50NO\"],[982523,\"HG98HCFL\",9786],[796001,\"FU1D57HA\",9869],[248471,\"FU1D57HA\",9942],[187843,\"OZ13ZSIN\",10035],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"H9OKZANW\",\"HG98HCFL\"],[217165,\"HG98HCFL\",10100],[739455,\"HG98HCFL\",10171],[187843,\"HG98HCFL\",10226],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[20582,\"E35YW0BM\",10322],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"SAIV20VG\",10342],[\"OZ13ZSIN\",\"FU1D57HA\"],[686615,\"HG98HCFL\",10396],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"CAWYGMWL\",10402],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[800300,\"OZ13ZSIN\",10472],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"NTNXSB47\",10485],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[800300,\"HG98HCFL\",10545],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"FU1D57HA\",10581],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[47896,\"NTNXSB47\",10588],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[788823,\"83OEBTCQ\",10599],[\"CAWYGMWL\",\"NTNXSB47\"],[365416,\"OZ13ZSIN\",10690],[610273,\"OZ13ZSIN\",10757],[988219,\"FWUZEALC\",10767],[\"XT14GVGK\",\"HG98HCFL\"],[910256,\"OZ13ZSIN\",10797],[\"OZ13ZSIN\",\"CWJHORPF\"],[610273,\"FU1D57HA\",10848],[\"OZ13ZSIN\",\"FU1D57HA\"],[910256,\"HMJCZQ0K\",10920],[\"OZ13ZSIN\",\"NTNXSB47\"],[988219,\"HG98HCFL\",10930],[365416,\"HG98HCFL\",10972],[219722,\"OZ13ZSIN\",11033],[295336,\"ITA0GE26\",11107],[219722,\"R62MQ4FI\",11131],[295336,\"FU1D57HA\",11140],[788823,\"0BIIAVNU\",11199],[620927,\"T25R11PB\",11274],[620927,\"FU1D57HA\",11371],[630168,\"OZ13ZSIN\",11448],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[112534,\"OZ13ZSIN\",11449],[573142,\"OZ13ZSIN\",11546],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[454282,\"NJB0V6ZO\",11576],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[454282,\"HG98HCFL\",11643],[444090,\"6QKM8CM8\",11698],[630168,\"Y43BFD6U\",11717],[185093,\"1XW6HVBY\",11723],[217806,\"4SBAAFIP\",11814],[\"XOK1HH1Y\",\"FU1D57HA\"],[573142,\"FU1D57HA\",11874],[661431,\"UT8S3IM6\",11907],[335406,\"OZ13ZSIN\",11942],[\"T25R11PB\",\"FU1D57HA\"],[444090,\"HG98HCFL\",11995],[896969,\"QJHWOKDQ\",12032],[950584,\"NJB0V6ZO\",12097],[570450,\"NJB0V6ZO\",12128],[896969,\"HG98HCFL\",12146],[71637,\"4SBAAFIP\",12202],[923844,\"OZ13ZSIN\",12277],[\"NJB0V6ZO\",\"HG98HCFL\"],[374491,\"OZ13ZSIN\",12300],[333698,\"1XW6HVBY\",12343],[323202,\"4SBAAFIP\",12369],[489161,\"OZ13ZSIN\",12419],[489161,\"BMN7MUED\",12446],[177905,\"XOK1HH1Y\",12483],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[185093,\"FU1D57HA\",12520],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"OZ13ZSIN\",12538],[765285,\"OZ13ZSIN\",12554],[\"OZ13ZSIN\",\"VL50N6D1\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[80760,\"XOK1HH1Y\",12613],[570450,\"R47UH9EC\",12643],[777227,\"OZ13ZSIN\",12717],[30391,\"XQ8MRL86\",12743],[923844,\"NTNXSB47\",12843],[\"OZ13ZSIN\",\"HG98HCFL\"],[177905,\"HG98HCFL\",12901],[374491,\"2Z3A0H6F\",12957],[950584,\"7IO8ET8F\",13035],[\"1XW6HVBY\",\"HG98HCFL\"],[636717,\"WY85FIVE\",13122],[661431,\"L6KOAIR1\",13154],[80760,\"XIUOFK2Y\",13215],[\"OZ13ZSIN\",\"HG98HCFL\"],[428110,\"4SBAAFIP\",13262],[\"H9OKZANW\",\"HG98HCFL\"],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"83OEBTCQ\",\"0BIIAVNU\"],[502345,\"1MOLNL46\",13324],[112534,\"HG98HCFL\",13393],[\"OZ13ZSIN\",\"HG98HCFL\"],[25332,\"OZ13ZSIN\",13487],[240072,\"OZ13ZSIN\",13504],[649981,\"ITA0GE26\",13603],[363027,\"NJB0V6ZO\",13627],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"FU1D57HA\",13724],[961598,\"ST6XEPDA\",13810],[75634,\"ZWJJHOU3\",13877],[807547,\"OZ13ZSIN\",13900],[\"OZ13ZSIN\",\"FU1D57HA\"],[71637,\"HG98HCFL\",13998],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[300645,\"OZ13ZSIN\",14033],[849654,\"OZ13ZSIN\",14128],[701073,\"GQINA28A\",14209],[288997,\"WGOD5SD4\",14252],[7101,\"OZ13ZSIN\",14258],[143698,\"SH04ZH5G\",14355],[849654,\"HG98HCFL\",14395],[300645,\"RBRIS3JS\",14484],[171052,\"OZ13ZSIN\",14576],[214567,\"NJB0V6ZO\",14592],[961598,\"JYTPXJK9\",14646],[132966,\"4SR0921V\",14665],[822925,\"4SBAAFIP\",14742],[333698,\"HG98HCFL\",14835],[\"OZ13ZSIN\",\"HG98HCFL\"],[822925,\"E35YW0BM\",14920],[777227,\"HG98HCFL\",15017],[123308,\"OZ13ZSIN\",15095],[598091,\"6QKM8CM8\",15150],[363027,\"HG98HCFL\",15160],[912565,\"OZ13ZSIN\",15202],[93990,\"1XW6HVBY\",15291],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[25332,\"FU1D57HA\",15332],[143698,\"HG98HCFL\",15380],[502345,\"DYLQ657K\",15429],[171052,\"HG98HCFL\",15436],[\"1XW6HVBY\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[217806,\"FU1D57HA\",15469],[487305,\"5D5SUJ4Q\",15499],[44397,\"6QKM8CM8\",15536],[601607,\"XOK1HH1Y\",15566],[30391,\"HG98HCFL\",15586],[\"OZ13ZSIN\",\"OGVA50NO\"],[765285,\"IX7LS60B\",15641],[788097,\"T25R11PB\",15730],[300198,\"6TED6G4E\",15774],[529964,\"OZ13ZSIN\",15793],[803049,\"IEQICIHL\",15826],[\"OZ13ZSIN\",\"HG98HCFL\"],[7101,\"DKN9PRYJ\",15869],[\"T25R11PB\",\"FU1D57HA\"],[761575,\"D5TNGKU7\",15885],[93990,\"HG98HCFL\",15894],[323202,\"HG98HCFL\",15898],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"OZ13ZSIN\",15990],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"OGVA50NO\"],[213297,\"OZ13ZSIN\",16034],[300198,\"HG98HCFL\",16105],[912565,\"HG98HCFL\",16175],[806824,\"NJB0V6ZO\",16274],[417297,\"OZ13ZSIN\",16334],[\"XQ8MRL86\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[690271,\"GQINA28A\",16427],[540402,\"OZ13ZSIN\",16500],[807547,\"FU1D57HA\",16504],[335406,\"HG98HCFL\",16539],[417297,\"HG98HCFL\",16618],[192719,\"QB05LSRK\",16711],[255839,\"OZ13ZSIN\",16755],[\"OZ13ZSIN\",\"BMN7MUED\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[711297,\"OZ13ZSIN\",16810],[\"OZ13ZSIN\",\"CWJHORPF\"],[711297,\"HG98HCFL\",16899],[211279,\"VL2TL1NM\",16907],[\"XT14GVGK\",\"HG98HCFL\"],[\"XWO403P7\",\"HG98HCFL\"],[213297,\"FU1D57HA\",16964],[44397,\"7JHO6FK0\",17021],[\"4SBAAFIP\",\"HG98HCFL\"],[75634,\"H4UTDCR8\",17075],[996616,\"JYLXUII8\",17167],[775204,\"ZZLR3YVJ\",17215],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[211106,\"6TED6G4E\",17217],[649981,\"HG98HCFL\",17236],[775204,\"HG98HCFL\",17246],[806824,\"HG98HCFL\",17313],[214567,\"GWJB6BU5\",17411],[487305,\"FU1D57HA\",17496],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[237574,\"GA4KQD8H\",17572],[863199,\"OZ13ZSIN\",17616],[921800,\"OZ13ZSIN\",17693],[415592,\"NJB0V6ZO\",17784],[788097,\"FU1D57HA\",17844],[79918,\"ZR7QN32O\",17930],[240072,\"HG98HCFL\",17938],[\"OZ13ZSIN\",\"HG98HCFL\"],[253649,\"OZ13ZSIN\",17981],[545511,\"OZ13ZSIN\",18005],[237574,\"FU1D57HA\",18089],[\"OZ13ZSIN\",\"NTNXSB47\"],[255839,\"HG98HCFL\",18169],[701073,\"HJXEGP9U\",18269],[598091,\"FU1D57HA\",18287],[\"OZ13ZSIN\",\"HG98HCFL\"],[540402,\"HG98HCFL\",18349],[887853,\"GA4KQD8H\",18417],[\"XT82S77E\",\"LBYS94AD\"],[863199,\"HG98HCFL\",18484],[\"OZ13ZSIN\",\"HG98HCFL\"],[127768,\"OZ13ZSIN\",18571],[872173,\"OZ13ZSIN\",18579],[\"OZ13ZSIN\",\"HG98HCFL\"],[872173,\"UB4KML0J\",18638],[428110,\"HG98HCFL\",18720],[\"ITA0GE26\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[85526,\"OZ13ZSIN\",18803],[123308,\"HG98HCFL\",18872],[273723,\"FJVIO218\",18884],[\"OZ13ZSIN\",\"FU1D57HA\"],[716950,\"OZ13ZSIN\",18916],[436026,\"OZ13ZSIN\",18922],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[127768,\"FU1D57HA\",18931],[646079,\"IMDG88XX\",18944],[784931,\"OZ13ZSIN\",19001],[\"OZ13ZSIN\",\"OGVA50NO\"],[\"OZ13ZSIN\",\"H4UTDCR8\"],[803049,\"RPKD08C6\",19041],[627595,\"MBY9ZG7D\",19129],[386653,\"BMX2AIY5\",19179],[\"OZ13ZSIN\",\"CWJHORPF\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[211106,\"HG98HCFL\",19251],[855448,\"OZ13ZSIN\",19300],[733785,\"SPVKZTIP\",19344],[\"XOK1HH1Y\",\"HG98HCFL\"],[761575,\"HG98HCFL\",19444],[\"OZ13ZSIN\",\"HG98HCFL\"],[132966,\"H4UTDCR8\",19503],[948005,\"OZ13ZSIN\",19520],[14408,\"OZ13ZSIN\",19594],[\"I0Y75MZQ\",\"FU1D57HA\"],[85526,\"NTNXSB47\",19687],[211403,\"OZ13ZSIN\",19761],[677411,\"OZ13ZSIN\",19852],[192719,\"HG98HCFL\",19905],[887853,\"HG98HCFL\",19975],[455474,\"OZ13ZSIN\",20002],[601607,\"FU1D57HA\",20077],[14408,\"HG98HCFL\",20150],[\"OZ13ZSIN\",\"DKN9PRYJ\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[253649,\"1QLZUAXZ\",20166],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[548975,\"OZ13ZSIN\",20232],[386653,\"1QLZUAXZ\",20277],[415592,\"HG98HCFL\",20318],[716950,\"3ZJ18VKA\",20384],[84268,\"OZ13ZSIN\",20392],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[55374,\"4SBAAFIP\",20416],[851948,\"OZ13ZSIN\",20503],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"OZ13ZSIN\",20513],[615192,\"OZ13ZSIN\",20551],[851948,\"HG98HCFL\",20631],[211403,\"HG98HCFL\",20668],[677411,\"OGVA50NO\",20715],[55374,\"FU1D57HA\",20749],[457056,\"OZ13ZSIN\",20799],[\"XOK1HH1Y\",\"FU1D57HA\"],[548975,\"HG98HCFL\",20836],[41381,\"MY3O8OQI\",20908],[950414,\"OZ13ZSIN\",20971],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[873337,\"OZ13ZSIN\",21038],[\"5D5SUJ4Q\",\"FU1D57HA\"],[273723,\"FU1D57HA\",21053],[726970,\"OZ13ZSIN\",21070],[\"OZ13ZSIN\",\"HG98HCFL\"],[211279,\"HG98HCFL\",21127],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[276902,\"4T1TBZX5\",21160],[\"OZ13ZSIN\",\"HG98HCFL\"],[183959,\"OZ13ZSIN\",21209],[488167,\"OZ13ZSIN\",21250],[\"OZ13ZSIN\",\"HG98HCFL\"],[166180,\"OZ13ZSIN\",21323],[\"FJVIO218\",\"FU1D57HA\"],[636717,\"UB4KML0J\",21366],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"DLUQBV4V\",21413],[\"OZ13ZSIN\",\"FU1D57HA\"],[528132,\"LUCPET9G\",21476],[206116,\"0MOLP3NC\",21551],[183959,\"XPM6JMBR\",21562],[\"OZ13ZSIN\",\"HG98HCFL\"],[553646,\"BMX2AIY5\",21661],[\"OZ13ZSIN\",\"DLUQBV4V\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"SH04ZH5G\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"R62MQ4FI\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[724508,\"C00L36RI\",21665],[950414,\"FU1D57HA\",21721],[102566,\"NJB0V6ZO\",21819],[690271,\"HG98HCFL\",21829],[\"OZ13ZSIN\",\"HG98HCFL\"],[386570,\"OZ13ZSIN\",21870],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[733785,\"FU1D57HA\",21931],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"ZWJJHOU3\",\"H4UTDCR8\"],[493080,\"OZ13ZSIN\",21957],[\"OZ13ZSIN\",\"RBRIS3JS\"],[476818,\"NJB0V6ZO\",22018],[\"OZ13ZSIN\",\"HG98HCFL\"],[646079,\"VMT100K8\",22076],[873337,\"E35YW0BM\",22080],[529964,\"FU1D57HA\",22162],[41381,\"FU1D57HA\",22233],[\"1XW6HVBY\",\"HG98HCFL\"],[\"IMDG88XX\",\"VMT100K8\"],[724508,\"JYTPXJK9\",22301],[\"OZ13ZSIN\",\"FU1D57HA\"],[276768,\"OZ13ZSIN\",22339],[654375,\"1XW6HVBY\",22349],[276768,\"X1H2W3W0\",22438],[\"OZ13ZSIN\",\"UB4KML0J\"],[855448,\"KSOIJA62\",22533],[493080,\"FU1D57HA\",22554],[726970,\"E35YW0BM\",22603],[\"4SR0921V\",\"H4UTDCR8\"],[79918,\"R62MQ4FI\",22640],[659224,\"OZ13ZSIN\",22739],[436026,\"L6KOAIR1\",22770],[288997,\"E35YW0BM\",22850],[\"SAIV20VG\",\"FU1D57HA\"],[553646,\"FU1D57HA\",22946],[659224,\"NTNXSB47\",22957],[615192,\"HG98HCFL\",23056],[\"OZ13ZSIN\",\"E35YW0BM\"],[730441,\"1XW6HVBY\",23129],[55790,\"OZ13ZSIN\",23179],[524967,\"OZ13ZSIN\",23189],[44097,\"2GRLB4CN\",23280],[784931,\"E35YW0BM\",23343],[525825,\"OZ13ZSIN\",23384],[315479,\"XQ8MRL86\",23386],[537074,\"OZ13ZSIN\",23437],[\"XT82S77E\",\"LBYS94AD\"],[524967,\"7JIXF9D1\",23496],[559244,\"OZ13ZSIN\",23569],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[872522,\"FJVIO218\",23579],[160528,\"DE386QWN\",23602],[\"4SBAAFIP\",\"HG98HCFL\"],[832697,\"OZ13ZSIN\",23696],[439436,\"NJB0V6ZO\",23749],[559244,\"MJZC0DI0\",23811],[38958,\"4SBAAFIP\",23863],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[327722,\"OZ13ZSIN\",23901],[243726,\"OZ13ZSIN\",23955],[38958,\"WUIGDE36\",24007],[832697,\"4IBLBVYU\",24058],[626392,\"QK3YTSXO\",24064],[640646,\"OZ13ZSIN\",24084],[476818,\"R5XHXCAN\",24129],[13070,\"NJB0V6ZO\",24190],[\"VL2TL1NM\",\"HG98HCFL\"],[633159,\"GQYWQW84\",24235],[528132,\"MPBZFLN9\",24236],[668517,\"OZ13ZSIN\",24307],[627595,\"HG98HCFL\",24343],[\"OZ13ZSIN\",\"HG98HCFL\"],[438428,\"PQOMFBOJ\",24350],[386570,\"FU1D57HA\",24413],[668517,\"7JHO6FK0\",24482],[561608,\"2IVTIGII\",24575],[539280,\"ITA0GE26\",24660],[160528,\"7IO8ET8F\",24668],[\"T25R11PB\",\"FU1D57HA\"],[626392,\"FU1D57HA\",24755],[\"4SBAAFIP\",\"WUIGDE36\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[251034,\"4SBAAFIP\",24786],[968259,\"OZ13ZSIN\",24870],[640646,\"I9H1UDG4\",24892],[361979,\"OZ13ZSIN\",24945],[806004,\"WPM57THK\",25006],[488167,\"VL50N6D1\",25009],[\"XT82S77E\",\"LBYS94AD\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[\"XQ8MRL86\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HMJCZQ0K\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[787728,\"OZ13ZSIN\",25084],[95528,\"OZ13ZSIN\",25154],[825321,\"4SBAAFIP\",25200],[\"OZ13ZSIN\",\"HG98HCFL\"],[968259,\"HG98HCFL\",25234],[\"NJB0V6ZO\",\"HG98HCFL\"],[537074,\"2Z3A0H6F\",25283],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"1QLZUAXZ\"],[430837,\"ZOA7MKHB\",25342],[588541,\"OZ13ZSIN\",25380],[\"OZ13ZSIN\",\"HG98HCFL\"],[276902,\"FU1D57HA\",25448],[787728,\"BMN7MUED\",25495],[590184,\"KFRF7AEZ\",25577],[\"LUCPET9G\",\"MPBZFLN9\"],[510551,\"OZ13ZSIN\",25597],[806004,\"HG98HCFL\",25608],[925378,\"T25R11PB\",25614],[27187,\"NJB0V6ZO\",25651],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"DE386QWN\",25682],[525825,\"IX7LS60B\",25695],[876351,\"1XW6HVBY\",25761],[225487,\"SPVKZTIP\",25783],[159468,\"OZ13ZSIN\",25784],[785370,\"BMX2AIY5\",25819],[159468,\"FU1D57HA\",25847],[822091,\"1XW6HVBY\",25911],[142228,\"OZ13ZSIN\",25962],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"HG98HCFL\",25997],[6026,\"WPM57THK\",26000],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"J1X7TLQD\",26041],[42555,\"D5TNGKU7\",26042],[921331,\"XOK1HH1Y\",26066],[95528,\"GWVJKDKT\",26130],[361979,\"CWWVVCGZ\",26183],[747281,\"OZ13ZSIN\",26197],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"NJB0V6ZO\",\"7IO8ET8F\"],[590184,\"FY86VG9O\",26248],[443593,\"6TED6G4E\",26254],[921331,\"IVDGXU4R\",26354],[184691,\"XOK1HH1Y\",26394],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"D5TNGKU7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[997488,\"OZ13ZSIN\",26468],[161852,\"OZ13ZSIN\",26476],[42555,\"HG98HCFL\",26505],[948005,\"88RO58CG\",26517],[499506,\"ITA0GE26\",26545],[\"OZ13ZSIN\",\"FU1D57HA\"],[654375,\"FU1D57HA\",26593],[999272,\"OZ13ZSIN\",26641],[\"OZ13ZSIN\",\"FU1D57HA\"],[788492,\"OZ13ZSIN\",26738],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"4SBAAFIP\",\"E35YW0BM\"],[327722,\"HG98HCFL\",26780],[499506,\"GWVJKDKT\",26878],[825321,\"HG98HCFL\",26973],[\"CAWYGMWL\",\"NTNXSB47\"],[606855,\"C00L36RI\",26996],[498054,\"OZ13ZSIN\",27025],[455474,\"7JHO6FK0\",27070],[911613,\"OZ13ZSIN\",27170],[693354,\"O77WFMCI\",27225],[\"OZ13ZSIN\",\"HG98HCFL\"],[483609,\"G2LO9U87\",27250],[\"D5TNGKU7\",\"HG98HCFL\"],[914704,\"OZ13ZSIN\",27252],[835356,\"OZ13ZSIN\",27277],[\"XOK1HH1Y\",\"HG98HCFL\"],[243726,\"2Z3A0H6F\",27330],[788492,\"HG98HCFL\",27409],[\"FJVIO218\",\"FU1D57HA\"],[730441,\"HG98HCFL\",27465],[418199,\"OZ13ZSIN\",27557],[\"NJB0V6ZO\",\"HG98HCFL\"],[416184,\"X8W3R0P7\",27576],[177447,\"GQINA28A\",27661],[27187,\"Q6L1ZD92\",27684],[53005,\"MY3O8OQI\",27746],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[835356,\"HG98HCFL\",27775],[88784,\"NJB0V6ZO\",27865],[747281,\"HG98HCFL\",27921],[\"OZ13ZSIN\",\"HG98HCFL\"],[184691,\"CWWVVCGZ\",27974],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[554716,\"OZ13ZSIN\",28020],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"FU1D57HA\",28107],[\"ZR7QN32O\",\"R62MQ4FI\"],[326091,\"XOK1HH1Y\",28151],[927316,\"OZ13ZSIN\",28193],[\"T25R11PB\",\"FU1D57HA\"],[499875,\"NJB0V6ZO\",28256],[590013,\"OZ13ZSIN\",28354],[62740,\"OZ13ZSIN\",28413],[876351,\"FU1D57HA\",28469],[749462,\"OZ13ZSIN\",28525],[\"5D5SUJ4Q\",\"FU1D57HA\"],[996616,\"OGVA50NO\",28553],[177447,\"CWWVVCGZ\",28572],[\"OZ13ZSIN\",\"FU1D57HA\"],[438428,\"L6KOAIR1\",28631],[693354,\"DLUQBV4V\",28663],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[880171,\"475J29EI\",28754],[588541,\"1YA7XTV9\",28760],[457056,\"HG98HCFL\",28762],[\"OZ13ZSIN\",\"VL50N6D1\"],[84268,\"HG98HCFL\",28792],[130492,\"IMDG88XX\",28832],[163069,\"FWUZEALC\",28840],[\"C00L36RI\",\"JYTPXJK9\"],[417559,\"BMX2AIY5\",28890],[\"OZ13ZSIN\",\"HG98HCFL\"],[914704,\"FU1D57HA\",28939],[55617,\"VL2TL1NM\",28974],[\"4SBAAFIP\",\"E35YW0BM\"],[911613,\"FU1D57HA\",29069],[880171,\"HG98HCFL\",29099],[\"OZ13ZSIN\",\"FU1D57HA\"],[117275,\"4SBAAFIP\",29174],[822091,\"FU1D57HA\",29206],[775394,\"XQ8MRL86\",29284],[917846,\"4SBAAFIP\",29288],[55790,\"0NYQFXYO\",29343],[\"83OEBTCQ\",\"0BIIAVNU\"],[416184,\"HG98HCFL\",29415],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"FJVIO218\",\"FU1D57HA\"],[228425,\"OZ13ZSIN\",29438],[\"CAWYGMWL\",\"NTNXSB47\"],[87834,\"OZ13ZSIN\",29442],[633159,\"WMTPA7JN\",29482],[322118,\"OZ13ZSIN\",29526],[\"1XW6HVBY\",\"FU1D57HA\"],[675060,\"K9D63ZZC\",29617],[225487,\"RPKD08C6\",29691],[708687,\"OZ13ZSIN\",29761],[836854,\"OZ13ZSIN\",29845],[\"6QKM8CM8\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[299466,\"4SBAAFIP\",29860],[\"WGOD5SD4\",\"E35YW0BM\"],[\"X8W3R0P7\",\"FU1D57HA\"],[927316,\"HG98HCFL\",29938],[483609,\"HG98HCFL\",29995],[\"C00L36RI\",\"JYTPXJK9\"],[\"OZ13ZSIN\",\"L6KOAIR1\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"HG98HCFL\",30054],[870611,\"72Q6VPM1\",30066],[754460,\"4SBAAFIP\",30086],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[979711,\"OZ13ZSIN\",30112],[322118,\"EY70T3I1\",30197],[696824,\"ZWJJHOU3\",30263],[239811,\"WGOD5SD4\",30361],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"475J29EI\",\"HG98HCFL\"],[963752,\"1XW6HVBY\",30399],[764562,\"OZ13ZSIN\",30480],[165422,\"XQ8MRL86\",30559],[282372,\"2MKY7B5Q\",30609],[554716,\"HG98HCFL\",30700],[925378,\"HG98HCFL\",30705],[836854,\"UB4KML0J\",30802],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[328085,\"PYU6IFCW\",30865],[999272,\"NTNXSB47\",30884],[510551,\"HG98HCFL\",30903],[87834,\"HG98HCFL\",30918],[590013,\"HG98HCFL\",30950],[775394,\"MPBZFLN9\",30963],[701078,\"OZ13ZSIN\",31024],[561608,\"WIXJ6Z00\",31082],[\"OZ13ZSIN\",\"HG98HCFL\"],[328085,\"FU1D57HA\",31132],[165422,\"HG98HCFL\",31226],[997488,\"HG98HCFL\",31249],[785370,\"FY86VG9O\",31334],[186553,\"6GPMXUYZ\",31378],[282372,\"FU1D57HA\",31454],[88784,\"WMTPA7JN\",31484],[186637,\"973PO4KY\",31528],[62740,\"HG98HCFL\",31561],[206116,\"CWWVVCGZ\",31653],[525469,\"OZ13ZSIN\",31705],[\"OZ13ZSIN\",\"CWWVVCGZ\"],[109318,\"OZ13ZSIN\",31719],[954915,\"WS49LJP8\",31776],[\"OZ13ZSIN\",\"FU1D57HA\"],[166180,\"FU1D57HA\",31824],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"MY3O8OQI\",\"FU1D57HA\"],[539280,\"YZ8LNY1V\",31843],[\"OZ13ZSIN\",\"UB4KML0J\"],[901923,\"OZ13ZSIN\",31865],[963752,\"VMT100K8\",31918],[239811,\"HG98HCFL\",31990]]` wtf is this testcase bro \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "i feel stupid that i opened ur comment. LoL ! it took forever to scroll down"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "resolved ? me also getting error in this test case"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The May badge was not an easy one! Guys let\\'s get this done!!!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Yay!"
                    },
                    {
                        "username": "omeraktepe",
                        "content": "There is a test case that does not meet assumptions. \nTest case 56: [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]] \n\nIt violetes followings: \n1. A customer can only be checked into one place at a time. \n2. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order. \n\nI am too lazy to report though :)"
                    },
                    {
                        "username": "zavojchevski",
                        "content": "I agree on this, restrictions should be well explained. "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "For those failing test case 51:\\n\"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\"\\nCredit to xuawai for noticing this back in 2020."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Restrictions should be written stricter. Some strange cases which are valid:\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@psionl0](/psionl0) \\'getAverageTime\\' arguments are invalid: "
                    },
                    {
                        "username": "psionl0",
                        "content": "All your test cases work on my code but it fails on Leet testcase 49. I also tried\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"],[\"A\",\"C\"]]\n``` \nbut that seems to be an invalid test case."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[@anwendeng](/anwendeng) My code works too, but it\\'s strange."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I have tested all of your test cases and my program passed!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using  2 tables  to store the info.\nUse hash tables for check-in and travel time info! \nThe programming is easier than a standard design for Hash set!\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Thanks for spoiling the answer for people in reallllllly big font so they don\\'t accidently try to come up with the answer themselves! Real nice of you."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "but bro trust me designing a hash set is highly asked interview problem ...\\nI recalled my concept of how we can store data in hashset..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "## **Don't raise your font at us!**"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/design-underground-system/solutions/3580430/easy-c-python-solutions-with-unordered-map-dict/"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Now people here in discuss section only comment to boost up there reputation."
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "This is an issue here and with almost all of these problems. Using vague or ambiguous names for parameters would never be allowed in enterprise software development. \\'id\\' ? id of what? Argument with name \\'t\\' is it time, train, turn? the code should be explanatory even without the description. Its also a prevalent issue in the editorials and provided solutions. \\n\\nThis is also an accessibility and inclusivity issue. When working on teams where not everyone speaks or has native proficiency in the same language using abbreviations or short hand becomes a huge problem. Leetcode should try and make it\\'s examples as near to what would be expected in a real workplace not a college math class."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me feel bad for jumping over the gates every time I lost my ticket on the way.\nSorry for creating stupid edge cases to handle for some devs somewhere"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Today is a special day for me as I will be getting my first badge of leetcode.\nThrough this one month of solving questions daily, the one thing that I have learnt is nothing matters- not even motivation if you don't have the habit of being consistent throughout the journey. \nI am looking forward to be more consistent.\nHappy coding fellow leetcoders!!!"
                    }
                ]
            },
            {
                "id": 1911442,
                "content": [
                    {
                        "username": "jax_ay",
                        "content": "`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\"] [[],[117077,\"OZ13ZSIN\",42],[117077,\"FU1D57HA\",125],[704903,\"OZ13ZSIN\",211],[911239,\"OZ13ZSIN\",245],[704903,\"HG98HCFL\",340],[859828,\"OZ13ZSIN\",355],[\"OZ13ZSIN\",\"FU1D57HA\"],[911239,\"FU1D57HA\",383],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[859828,\"FU1D57HA\",402],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[363027,\"OZ13ZSIN\",489],[319826,\"OZ13ZSIN\",550],[\"OZ13ZSIN\",\"FU1D57HA\"],[363027,\"HG98HCFL\",565],[319826,\"FU1D57HA\",664],[120084,\"OZ13ZSIN\",735],[\"OZ13ZSIN\",\"HG98HCFL\"],[120084,\"HG98HCFL\",832],[56672,\"OZ13ZSIN\",876],[56672,\"HG98HCFL\",912],[638995,\"OZ13ZSIN\",925],[\"OZ13ZSIN\",\"FU1D57HA\"],[638995,\"FU1D57HA\",951],[712949,\"OZ13ZSIN\",1023],[712949,\"FU1D57HA\",1033],[278482,\"T25R11PB\",1080],[\"OZ13ZSIN\",\"FU1D57HA\"],[278482,\"FU1D57HA\",1160],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[342818,\"4SBAAFIP\",1250],[342818,\"HG98HCFL\",1263],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[415673,\"OZ13ZSIN\",1270],[415673,\"NTNXSB47\",1366],[\"T25R11PB\",\"FU1D57HA\"],[597115,\"4SBAAFIP\",1385],[463555,\"OZ13ZSIN\",1461],[463555,\"HG98HCFL\",1514],[801778,\"OZ13ZSIN\",1537],[201428,\"OZ13ZSIN\",1620],[245538,\"OZ13ZSIN\",1630],[597115,\"FU1D57HA\",1657],[583112,\"OZ13ZSIN\",1690],[\"4SBAAFIP\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[691834,\"OZ13ZSIN\",1723],[250537,\"OZ13ZSIN\",1753],[201428,\"H4UTDCR8\",1804],[691834,\"FU1D57HA\",1838],[\"T25R11PB\",\"FU1D57HA\"],[245538,\"FU1D57HA\",1924],[346824,\"OZ13ZSIN\",1952],[864512,\"OZ13ZSIN\",2005],[499705,\"OZ13ZSIN\",2048],[482469,\"GQINA28A\",2058],[\"OZ13ZSIN\",\"FU1D57HA\"],[583112,\"E35YW0BM\",2080],[\"OZ13ZSIN\",\"HG98HCFL\"],[801778,\"HG98HCFL\",2082],[250415,\"I0Y75MZQ\",2149],[795633,\"OZ13ZSIN\",2196],[\"OZ13ZSIN\",\"HG98HCFL\"],[99144,\"4SBAAFIP\",2219],[83594,\"OZ13ZSIN\",2249],[346824,\"HG98HCFL\",2290],[482469,\"HG98HCFL\",2368],[499705,\"FU1D57HA\",2437],[12539,\"OZ13ZSIN\",2442],[116546,\"OZ13ZSIN\",2493],[884032,\"4SBAAFIP\",2579],[801142,\"OZ13ZSIN\",2598],[795633,\"HG98HCFL\",2693],[83594,\"HG98HCFL\",2782],[529306,\"OZ13ZSIN\",2824],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[286490,\"OZ13ZSIN\",2844],[255488,\"OZ13ZSIN\",2935],[608514,\"OZ13ZSIN\",2984],[116546,\"HG98HCFL\",3079],[250415,\"FU1D57HA\",3174],[\"OZ13ZSIN\",\"FU1D57HA\"],[884032,\"E35YW0BM\",3267],[\"OZ13ZSIN\",\"FU1D57HA\"],[529306,\"HG98HCFL\",3299],[\"OZ13ZSIN\",\"FU1D57HA\"],[892550,\"OZ13ZSIN\",3388],[892550,\"2VVKO5AZ\",3394],[14673,\"OZ13ZSIN\",3487],[\"OZ13ZSIN\",\"HG98HCFL\"],[12539,\"HG98HCFL\",3576],[\"OZ13ZSIN\",\"HG98HCFL\"],[255488,\"HG98HCFL\",3674],[\"OZ13ZSIN\",\"HG98HCFL\"],[14673,\"HG98HCFL\",3754],[864512,\"FU1D57HA\",3819],[451611,\"OZ13ZSIN\",3899],[\"4SBAAFIP\",\"E35YW0BM\"],[451611,\"HG98HCFL\",3941],[250537,\"HG98HCFL\",4027],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[286490,\"FU1D57HA\",4046],[608514,\"HG98HCFL\",4094],[827431,\"XWO403P7\",4107],[99144,\"HG98HCFL\",4136],[\"GQINA28A\",\"HG98HCFL\"],[657832,\"OZ13ZSIN\",4150],[827431,\"HG98HCFL\",4214],[\"OZ13ZSIN\",\"FU1D57HA\"],[658842,\"OZ13ZSIN\",4236],[52933,\"4SBAAFIP\",4325],[801142,\"HG98HCFL\",4413],[52933,\"E35YW0BM\",4460],[331712,\"OZ13ZSIN\",4522],[658842,\"NTNXSB47\",4615],[293734,\"OZ13ZSIN\",4665],[293734,\"HG98HCFL\",4735],[917903,\"OZ13ZSIN\",4772],[119860,\"OZ13ZSIN\",4775],[\"OZ13ZSIN\",\"HG98HCFL\"],[657832,\"E35YW0BM\",4850],[415861,\"NJB0V6ZO\",4881],[\"OZ13ZSIN\",\"FU1D57HA\"],[917903,\"HG98HCFL\",4892],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[415861,\"HG98HCFL\",4919],[\"OZ13ZSIN\",\"HG98HCFL\"],[331712,\"OGVA50NO\",4979],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[119860,\"HG98HCFL\",5034],[469875,\"OZ13ZSIN\",5053],[407362,\"XT14GVGK\",5073],[469875,\"HG98HCFL\",5126],[407362,\"HG98HCFL\",5175],[324747,\"OZ13ZSIN\",5236],[315560,\"OZ13ZSIN\",5333],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[317815,\"OZ13ZSIN\",5339],[906872,\"OZ13ZSIN\",5349],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[404251,\"OZ13ZSIN\",5375],[324747,\"HG98HCFL\",5474],[882572,\"OZ13ZSIN\",5524],[\"OZ13ZSIN\",\"HG98HCFL\"],[758501,\"OZ13ZSIN\",5561],[404251,\"FU1D57HA\",5617],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[315560,\"HG98HCFL\",5651],[758501,\"HG98HCFL\",5673],[141090,\"OZ13ZSIN\",5768],[882572,\"FU1D57HA\",5827],[906872,\"HG98HCFL\",5872],[141090,\"HG98HCFL\",5940],[\"OZ13ZSIN\",\"FU1D57HA\"],[317815,\"HG98HCFL\",5996],[436252,\"OZ13ZSIN\",6027],[\"OZ13ZSIN\",\"E35YW0BM\"],[436252,\"HG98HCFL\",6084],[\"OZ13ZSIN\",\"NTNXSB47\"],[652912,\"NJB0V6ZO\",6155],[652912,\"HG98HCFL\",6169],[269825,\"NJB0V6ZO\",6173],[831024,\"OZ13ZSIN\",6267],[831024,\"FU1D57HA\",6317],[269825,\"FU1D57HA\",6318],[794093,\"OZ13ZSIN\",6406],[\"OZ13ZSIN\",\"HG98HCFL\"],[794093,\"FU1D57HA\",6429],[798558,\"OZ13ZSIN\",6497],[798558,\"E35YW0BM\",6500],[271136,\"NJB0V6ZO\",6582],[\"OZ13ZSIN\",\"HG98HCFL\"],[608446,\"OZ13ZSIN\",6662],[608446,\"FU1D57HA\",6760],[986152,\"OZ13ZSIN\",6799],[986152,\"NTNXSB47\",6825],[271136,\"HG98HCFL\",6911],[\"OZ13ZSIN\",\"FU1D57HA\"],[341349,\"OZ13ZSIN\",6995],[595955,\"OZ13ZSIN\",7039],[58242,\"H9OKZANW\",7071],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[134319,\"OZ13ZSIN\",7119],[595955,\"FU1D57HA\",7161],[\"OZ13ZSIN\",\"HG98HCFL\"],[266781,\"OZ13ZSIN\",7208],[\"OZ13ZSIN\",\"FU1D57HA\"],[266781,\"FU1D57HA\",7298],[\"OZ13ZSIN\",\"NTNXSB47\"],[935757,\"OZ13ZSIN\",7300],[517277,\"OZ13ZSIN\",7376],[58242,\"HG98HCFL\",7459],[\"OZ13ZSIN\",\"HG98HCFL\"],[288203,\"OZ13ZSIN\",7512],[293244,\"T25R11PB\",7580],[517277,\"HG98HCFL\",7588],[293244,\"FU1D57HA\",7649],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[480741,\"OZ13ZSIN\",7748],[288203,\"CWJHORPF\",7845],[935757,\"NTNXSB47\",7940],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[341349,\"HG98HCFL\",7952],[870607,\"ST6XEPDA\",7986],[\"OZ13ZSIN\",\"CWJHORPF\"],[468450,\"6QKM8CM8\",8063],[262669,\"OZ13ZSIN\",8152],[\"OZ13ZSIN\",\"FU1D57HA\"],[103929,\"OZ13ZSIN\",8167],[415331,\"X8W3R0P7\",8215],[134319,\"E35YW0BM\",8226],[415331,\"FU1D57HA\",8240],[468450,\"HG98HCFL\",8263],[394949,\"XOK1HH1Y\",8313],[\"OZ13ZSIN\",\"HG98HCFL\"],[394949,\"FU1D57HA\",8402],[67177,\"GQINA28A\",8451],[67177,\"HG98HCFL\",8521],[796191,\"QJHWOKDQ\",8545],[\"I0Y75MZQ\",\"FU1D57HA\"],[\"H9OKZANW\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[940010,\"OZ13ZSIN\",8583],[940010,\"VL50N6D1\",8613],[21260,\"WGOD5SD4\",8683],[746866,\"NJB0V6ZO\",8732],[47896,\"OZ13ZSIN\",8802],[480741,\"CWJHORPF\",8839],[\"NJB0V6ZO\",\"HG98HCFL\"],[310852,\"XT82S77E\",8858],[796001,\"OZ13ZSIN\",8860],[\"OZ13ZSIN\",\"NTNXSB47\"],[103929,\"FU1D57HA\",8957],[739455,\"OZ13ZSIN\",8980],[\"XWO403P7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"VL50N6D1\"],[734337,\"OZ13ZSIN\",8989],[686615,\"4SBAAFIP\",9086],[21260,\"HG98HCFL\",9130],[\"OZ13ZSIN\",\"CWJHORPF\"],[217165,\"1XW6HVBY\",9228],[689774,\"OZ13ZSIN\",9313],[870607,\"NTNXSB47\",9319],[248471,\"OZ13ZSIN\",9376],[262669,\"E35YW0BM\",9427],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[20582,\"OZ13ZSIN\",9484],[310852,\"LBYS94AD\",9535],[746866,\"FU1D57HA\",9540],[689774,\"FU1D57HA\",9594],[796191,\"HG98HCFL\",9635],[\"OZ13ZSIN\",\"FU1D57HA\"],[734337,\"HG98HCFL\",9683],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[982523,\"XWO403P7\",9689],[\"OZ13ZSIN\",\"OGVA50NO\"],[982523,\"HG98HCFL\",9786],[796001,\"FU1D57HA\",9869],[248471,\"FU1D57HA\",9942],[187843,\"OZ13ZSIN\",10035],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"H9OKZANW\",\"HG98HCFL\"],[217165,\"HG98HCFL\",10100],[739455,\"HG98HCFL\",10171],[187843,\"HG98HCFL\",10226],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[20582,\"E35YW0BM\",10322],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"SAIV20VG\",10342],[\"OZ13ZSIN\",\"FU1D57HA\"],[686615,\"HG98HCFL\",10396],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"CAWYGMWL\",10402],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[800300,\"OZ13ZSIN\",10472],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"NTNXSB47\",10485],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[800300,\"HG98HCFL\",10545],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"FU1D57HA\",10581],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[47896,\"NTNXSB47\",10588],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[788823,\"83OEBTCQ\",10599],[\"CAWYGMWL\",\"NTNXSB47\"],[365416,\"OZ13ZSIN\",10690],[610273,\"OZ13ZSIN\",10757],[988219,\"FWUZEALC\",10767],[\"XT14GVGK\",\"HG98HCFL\"],[910256,\"OZ13ZSIN\",10797],[\"OZ13ZSIN\",\"CWJHORPF\"],[610273,\"FU1D57HA\",10848],[\"OZ13ZSIN\",\"FU1D57HA\"],[910256,\"HMJCZQ0K\",10920],[\"OZ13ZSIN\",\"NTNXSB47\"],[988219,\"HG98HCFL\",10930],[365416,\"HG98HCFL\",10972],[219722,\"OZ13ZSIN\",11033],[295336,\"ITA0GE26\",11107],[219722,\"R62MQ4FI\",11131],[295336,\"FU1D57HA\",11140],[788823,\"0BIIAVNU\",11199],[620927,\"T25R11PB\",11274],[620927,\"FU1D57HA\",11371],[630168,\"OZ13ZSIN\",11448],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[112534,\"OZ13ZSIN\",11449],[573142,\"OZ13ZSIN\",11546],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[454282,\"NJB0V6ZO\",11576],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[454282,\"HG98HCFL\",11643],[444090,\"6QKM8CM8\",11698],[630168,\"Y43BFD6U\",11717],[185093,\"1XW6HVBY\",11723],[217806,\"4SBAAFIP\",11814],[\"XOK1HH1Y\",\"FU1D57HA\"],[573142,\"FU1D57HA\",11874],[661431,\"UT8S3IM6\",11907],[335406,\"OZ13ZSIN\",11942],[\"T25R11PB\",\"FU1D57HA\"],[444090,\"HG98HCFL\",11995],[896969,\"QJHWOKDQ\",12032],[950584,\"NJB0V6ZO\",12097],[570450,\"NJB0V6ZO\",12128],[896969,\"HG98HCFL\",12146],[71637,\"4SBAAFIP\",12202],[923844,\"OZ13ZSIN\",12277],[\"NJB0V6ZO\",\"HG98HCFL\"],[374491,\"OZ13ZSIN\",12300],[333698,\"1XW6HVBY\",12343],[323202,\"4SBAAFIP\",12369],[489161,\"OZ13ZSIN\",12419],[489161,\"BMN7MUED\",12446],[177905,\"XOK1HH1Y\",12483],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[185093,\"FU1D57HA\",12520],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"OZ13ZSIN\",12538],[765285,\"OZ13ZSIN\",12554],[\"OZ13ZSIN\",\"VL50N6D1\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[80760,\"XOK1HH1Y\",12613],[570450,\"R47UH9EC\",12643],[777227,\"OZ13ZSIN\",12717],[30391,\"XQ8MRL86\",12743],[923844,\"NTNXSB47\",12843],[\"OZ13ZSIN\",\"HG98HCFL\"],[177905,\"HG98HCFL\",12901],[374491,\"2Z3A0H6F\",12957],[950584,\"7IO8ET8F\",13035],[\"1XW6HVBY\",\"HG98HCFL\"],[636717,\"WY85FIVE\",13122],[661431,\"L6KOAIR1\",13154],[80760,\"XIUOFK2Y\",13215],[\"OZ13ZSIN\",\"HG98HCFL\"],[428110,\"4SBAAFIP\",13262],[\"H9OKZANW\",\"HG98HCFL\"],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"83OEBTCQ\",\"0BIIAVNU\"],[502345,\"1MOLNL46\",13324],[112534,\"HG98HCFL\",13393],[\"OZ13ZSIN\",\"HG98HCFL\"],[25332,\"OZ13ZSIN\",13487],[240072,\"OZ13ZSIN\",13504],[649981,\"ITA0GE26\",13603],[363027,\"NJB0V6ZO\",13627],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"FU1D57HA\",13724],[961598,\"ST6XEPDA\",13810],[75634,\"ZWJJHOU3\",13877],[807547,\"OZ13ZSIN\",13900],[\"OZ13ZSIN\",\"FU1D57HA\"],[71637,\"HG98HCFL\",13998],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[300645,\"OZ13ZSIN\",14033],[849654,\"OZ13ZSIN\",14128],[701073,\"GQINA28A\",14209],[288997,\"WGOD5SD4\",14252],[7101,\"OZ13ZSIN\",14258],[143698,\"SH04ZH5G\",14355],[849654,\"HG98HCFL\",14395],[300645,\"RBRIS3JS\",14484],[171052,\"OZ13ZSIN\",14576],[214567,\"NJB0V6ZO\",14592],[961598,\"JYTPXJK9\",14646],[132966,\"4SR0921V\",14665],[822925,\"4SBAAFIP\",14742],[333698,\"HG98HCFL\",14835],[\"OZ13ZSIN\",\"HG98HCFL\"],[822925,\"E35YW0BM\",14920],[777227,\"HG98HCFL\",15017],[123308,\"OZ13ZSIN\",15095],[598091,\"6QKM8CM8\",15150],[363027,\"HG98HCFL\",15160],[912565,\"OZ13ZSIN\",15202],[93990,\"1XW6HVBY\",15291],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[25332,\"FU1D57HA\",15332],[143698,\"HG98HCFL\",15380],[502345,\"DYLQ657K\",15429],[171052,\"HG98HCFL\",15436],[\"1XW6HVBY\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[217806,\"FU1D57HA\",15469],[487305,\"5D5SUJ4Q\",15499],[44397,\"6QKM8CM8\",15536],[601607,\"XOK1HH1Y\",15566],[30391,\"HG98HCFL\",15586],[\"OZ13ZSIN\",\"OGVA50NO\"],[765285,\"IX7LS60B\",15641],[788097,\"T25R11PB\",15730],[300198,\"6TED6G4E\",15774],[529964,\"OZ13ZSIN\",15793],[803049,\"IEQICIHL\",15826],[\"OZ13ZSIN\",\"HG98HCFL\"],[7101,\"DKN9PRYJ\",15869],[\"T25R11PB\",\"FU1D57HA\"],[761575,\"D5TNGKU7\",15885],[93990,\"HG98HCFL\",15894],[323202,\"HG98HCFL\",15898],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"OZ13ZSIN\",15990],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"OGVA50NO\"],[213297,\"OZ13ZSIN\",16034],[300198,\"HG98HCFL\",16105],[912565,\"HG98HCFL\",16175],[806824,\"NJB0V6ZO\",16274],[417297,\"OZ13ZSIN\",16334],[\"XQ8MRL86\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[690271,\"GQINA28A\",16427],[540402,\"OZ13ZSIN\",16500],[807547,\"FU1D57HA\",16504],[335406,\"HG98HCFL\",16539],[417297,\"HG98HCFL\",16618],[192719,\"QB05LSRK\",16711],[255839,\"OZ13ZSIN\",16755],[\"OZ13ZSIN\",\"BMN7MUED\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[711297,\"OZ13ZSIN\",16810],[\"OZ13ZSIN\",\"CWJHORPF\"],[711297,\"HG98HCFL\",16899],[211279,\"VL2TL1NM\",16907],[\"XT14GVGK\",\"HG98HCFL\"],[\"XWO403P7\",\"HG98HCFL\"],[213297,\"FU1D57HA\",16964],[44397,\"7JHO6FK0\",17021],[\"4SBAAFIP\",\"HG98HCFL\"],[75634,\"H4UTDCR8\",17075],[996616,\"JYLXUII8\",17167],[775204,\"ZZLR3YVJ\",17215],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[211106,\"6TED6G4E\",17217],[649981,\"HG98HCFL\",17236],[775204,\"HG98HCFL\",17246],[806824,\"HG98HCFL\",17313],[214567,\"GWJB6BU5\",17411],[487305,\"FU1D57HA\",17496],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[237574,\"GA4KQD8H\",17572],[863199,\"OZ13ZSIN\",17616],[921800,\"OZ13ZSIN\",17693],[415592,\"NJB0V6ZO\",17784],[788097,\"FU1D57HA\",17844],[79918,\"ZR7QN32O\",17930],[240072,\"HG98HCFL\",17938],[\"OZ13ZSIN\",\"HG98HCFL\"],[253649,\"OZ13ZSIN\",17981],[545511,\"OZ13ZSIN\",18005],[237574,\"FU1D57HA\",18089],[\"OZ13ZSIN\",\"NTNXSB47\"],[255839,\"HG98HCFL\",18169],[701073,\"HJXEGP9U\",18269],[598091,\"FU1D57HA\",18287],[\"OZ13ZSIN\",\"HG98HCFL\"],[540402,\"HG98HCFL\",18349],[887853,\"GA4KQD8H\",18417],[\"XT82S77E\",\"LBYS94AD\"],[863199,\"HG98HCFL\",18484],[\"OZ13ZSIN\",\"HG98HCFL\"],[127768,\"OZ13ZSIN\",18571],[872173,\"OZ13ZSIN\",18579],[\"OZ13ZSIN\",\"HG98HCFL\"],[872173,\"UB4KML0J\",18638],[428110,\"HG98HCFL\",18720],[\"ITA0GE26\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[85526,\"OZ13ZSIN\",18803],[123308,\"HG98HCFL\",18872],[273723,\"FJVIO218\",18884],[\"OZ13ZSIN\",\"FU1D57HA\"],[716950,\"OZ13ZSIN\",18916],[436026,\"OZ13ZSIN\",18922],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[127768,\"FU1D57HA\",18931],[646079,\"IMDG88XX\",18944],[784931,\"OZ13ZSIN\",19001],[\"OZ13ZSIN\",\"OGVA50NO\"],[\"OZ13ZSIN\",\"H4UTDCR8\"],[803049,\"RPKD08C6\",19041],[627595,\"MBY9ZG7D\",19129],[386653,\"BMX2AIY5\",19179],[\"OZ13ZSIN\",\"CWJHORPF\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[211106,\"HG98HCFL\",19251],[855448,\"OZ13ZSIN\",19300],[733785,\"SPVKZTIP\",19344],[\"XOK1HH1Y\",\"HG98HCFL\"],[761575,\"HG98HCFL\",19444],[\"OZ13ZSIN\",\"HG98HCFL\"],[132966,\"H4UTDCR8\",19503],[948005,\"OZ13ZSIN\",19520],[14408,\"OZ13ZSIN\",19594],[\"I0Y75MZQ\",\"FU1D57HA\"],[85526,\"NTNXSB47\",19687],[211403,\"OZ13ZSIN\",19761],[677411,\"OZ13ZSIN\",19852],[192719,\"HG98HCFL\",19905],[887853,\"HG98HCFL\",19975],[455474,\"OZ13ZSIN\",20002],[601607,\"FU1D57HA\",20077],[14408,\"HG98HCFL\",20150],[\"OZ13ZSIN\",\"DKN9PRYJ\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[253649,\"1QLZUAXZ\",20166],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[548975,\"OZ13ZSIN\",20232],[386653,\"1QLZUAXZ\",20277],[415592,\"HG98HCFL\",20318],[716950,\"3ZJ18VKA\",20384],[84268,\"OZ13ZSIN\",20392],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[55374,\"4SBAAFIP\",20416],[851948,\"OZ13ZSIN\",20503],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"OZ13ZSIN\",20513],[615192,\"OZ13ZSIN\",20551],[851948,\"HG98HCFL\",20631],[211403,\"HG98HCFL\",20668],[677411,\"OGVA50NO\",20715],[55374,\"FU1D57HA\",20749],[457056,\"OZ13ZSIN\",20799],[\"XOK1HH1Y\",\"FU1D57HA\"],[548975,\"HG98HCFL\",20836],[41381,\"MY3O8OQI\",20908],[950414,\"OZ13ZSIN\",20971],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[873337,\"OZ13ZSIN\",21038],[\"5D5SUJ4Q\",\"FU1D57HA\"],[273723,\"FU1D57HA\",21053],[726970,\"OZ13ZSIN\",21070],[\"OZ13ZSIN\",\"HG98HCFL\"],[211279,\"HG98HCFL\",21127],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[276902,\"4T1TBZX5\",21160],[\"OZ13ZSIN\",\"HG98HCFL\"],[183959,\"OZ13ZSIN\",21209],[488167,\"OZ13ZSIN\",21250],[\"OZ13ZSIN\",\"HG98HCFL\"],[166180,\"OZ13ZSIN\",21323],[\"FJVIO218\",\"FU1D57HA\"],[636717,\"UB4KML0J\",21366],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"DLUQBV4V\",21413],[\"OZ13ZSIN\",\"FU1D57HA\"],[528132,\"LUCPET9G\",21476],[206116,\"0MOLP3NC\",21551],[183959,\"XPM6JMBR\",21562],[\"OZ13ZSIN\",\"HG98HCFL\"],[553646,\"BMX2AIY5\",21661],[\"OZ13ZSIN\",\"DLUQBV4V\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"SH04ZH5G\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"R62MQ4FI\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[724508,\"C00L36RI\",21665],[950414,\"FU1D57HA\",21721],[102566,\"NJB0V6ZO\",21819],[690271,\"HG98HCFL\",21829],[\"OZ13ZSIN\",\"HG98HCFL\"],[386570,\"OZ13ZSIN\",21870],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[733785,\"FU1D57HA\",21931],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"ZWJJHOU3\",\"H4UTDCR8\"],[493080,\"OZ13ZSIN\",21957],[\"OZ13ZSIN\",\"RBRIS3JS\"],[476818,\"NJB0V6ZO\",22018],[\"OZ13ZSIN\",\"HG98HCFL\"],[646079,\"VMT100K8\",22076],[873337,\"E35YW0BM\",22080],[529964,\"FU1D57HA\",22162],[41381,\"FU1D57HA\",22233],[\"1XW6HVBY\",\"HG98HCFL\"],[\"IMDG88XX\",\"VMT100K8\"],[724508,\"JYTPXJK9\",22301],[\"OZ13ZSIN\",\"FU1D57HA\"],[276768,\"OZ13ZSIN\",22339],[654375,\"1XW6HVBY\",22349],[276768,\"X1H2W3W0\",22438],[\"OZ13ZSIN\",\"UB4KML0J\"],[855448,\"KSOIJA62\",22533],[493080,\"FU1D57HA\",22554],[726970,\"E35YW0BM\",22603],[\"4SR0921V\",\"H4UTDCR8\"],[79918,\"R62MQ4FI\",22640],[659224,\"OZ13ZSIN\",22739],[436026,\"L6KOAIR1\",22770],[288997,\"E35YW0BM\",22850],[\"SAIV20VG\",\"FU1D57HA\"],[553646,\"FU1D57HA\",22946],[659224,\"NTNXSB47\",22957],[615192,\"HG98HCFL\",23056],[\"OZ13ZSIN\",\"E35YW0BM\"],[730441,\"1XW6HVBY\",23129],[55790,\"OZ13ZSIN\",23179],[524967,\"OZ13ZSIN\",23189],[44097,\"2GRLB4CN\",23280],[784931,\"E35YW0BM\",23343],[525825,\"OZ13ZSIN\",23384],[315479,\"XQ8MRL86\",23386],[537074,\"OZ13ZSIN\",23437],[\"XT82S77E\",\"LBYS94AD\"],[524967,\"7JIXF9D1\",23496],[559244,\"OZ13ZSIN\",23569],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[872522,\"FJVIO218\",23579],[160528,\"DE386QWN\",23602],[\"4SBAAFIP\",\"HG98HCFL\"],[832697,\"OZ13ZSIN\",23696],[439436,\"NJB0V6ZO\",23749],[559244,\"MJZC0DI0\",23811],[38958,\"4SBAAFIP\",23863],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[327722,\"OZ13ZSIN\",23901],[243726,\"OZ13ZSIN\",23955],[38958,\"WUIGDE36\",24007],[832697,\"4IBLBVYU\",24058],[626392,\"QK3YTSXO\",24064],[640646,\"OZ13ZSIN\",24084],[476818,\"R5XHXCAN\",24129],[13070,\"NJB0V6ZO\",24190],[\"VL2TL1NM\",\"HG98HCFL\"],[633159,\"GQYWQW84\",24235],[528132,\"MPBZFLN9\",24236],[668517,\"OZ13ZSIN\",24307],[627595,\"HG98HCFL\",24343],[\"OZ13ZSIN\",\"HG98HCFL\"],[438428,\"PQOMFBOJ\",24350],[386570,\"FU1D57HA\",24413],[668517,\"7JHO6FK0\",24482],[561608,\"2IVTIGII\",24575],[539280,\"ITA0GE26\",24660],[160528,\"7IO8ET8F\",24668],[\"T25R11PB\",\"FU1D57HA\"],[626392,\"FU1D57HA\",24755],[\"4SBAAFIP\",\"WUIGDE36\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[251034,\"4SBAAFIP\",24786],[968259,\"OZ13ZSIN\",24870],[640646,\"I9H1UDG4\",24892],[361979,\"OZ13ZSIN\",24945],[806004,\"WPM57THK\",25006],[488167,\"VL50N6D1\",25009],[\"XT82S77E\",\"LBYS94AD\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[\"XQ8MRL86\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HMJCZQ0K\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[787728,\"OZ13ZSIN\",25084],[95528,\"OZ13ZSIN\",25154],[825321,\"4SBAAFIP\",25200],[\"OZ13ZSIN\",\"HG98HCFL\"],[968259,\"HG98HCFL\",25234],[\"NJB0V6ZO\",\"HG98HCFL\"],[537074,\"2Z3A0H6F\",25283],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"1QLZUAXZ\"],[430837,\"ZOA7MKHB\",25342],[588541,\"OZ13ZSIN\",25380],[\"OZ13ZSIN\",\"HG98HCFL\"],[276902,\"FU1D57HA\",25448],[787728,\"BMN7MUED\",25495],[590184,\"KFRF7AEZ\",25577],[\"LUCPET9G\",\"MPBZFLN9\"],[510551,\"OZ13ZSIN\",25597],[806004,\"HG98HCFL\",25608],[925378,\"T25R11PB\",25614],[27187,\"NJB0V6ZO\",25651],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"DE386QWN\",25682],[525825,\"IX7LS60B\",25695],[876351,\"1XW6HVBY\",25761],[225487,\"SPVKZTIP\",25783],[159468,\"OZ13ZSIN\",25784],[785370,\"BMX2AIY5\",25819],[159468,\"FU1D57HA\",25847],[822091,\"1XW6HVBY\",25911],[142228,\"OZ13ZSIN\",25962],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"HG98HCFL\",25997],[6026,\"WPM57THK\",26000],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"J1X7TLQD\",26041],[42555,\"D5TNGKU7\",26042],[921331,\"XOK1HH1Y\",26066],[95528,\"GWVJKDKT\",26130],[361979,\"CWWVVCGZ\",26183],[747281,\"OZ13ZSIN\",26197],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"NJB0V6ZO\",\"7IO8ET8F\"],[590184,\"FY86VG9O\",26248],[443593,\"6TED6G4E\",26254],[921331,\"IVDGXU4R\",26354],[184691,\"XOK1HH1Y\",26394],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"D5TNGKU7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[997488,\"OZ13ZSIN\",26468],[161852,\"OZ13ZSIN\",26476],[42555,\"HG98HCFL\",26505],[948005,\"88RO58CG\",26517],[499506,\"ITA0GE26\",26545],[\"OZ13ZSIN\",\"FU1D57HA\"],[654375,\"FU1D57HA\",26593],[999272,\"OZ13ZSIN\",26641],[\"OZ13ZSIN\",\"FU1D57HA\"],[788492,\"OZ13ZSIN\",26738],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"4SBAAFIP\",\"E35YW0BM\"],[327722,\"HG98HCFL\",26780],[499506,\"GWVJKDKT\",26878],[825321,\"HG98HCFL\",26973],[\"CAWYGMWL\",\"NTNXSB47\"],[606855,\"C00L36RI\",26996],[498054,\"OZ13ZSIN\",27025],[455474,\"7JHO6FK0\",27070],[911613,\"OZ13ZSIN\",27170],[693354,\"O77WFMCI\",27225],[\"OZ13ZSIN\",\"HG98HCFL\"],[483609,\"G2LO9U87\",27250],[\"D5TNGKU7\",\"HG98HCFL\"],[914704,\"OZ13ZSIN\",27252],[835356,\"OZ13ZSIN\",27277],[\"XOK1HH1Y\",\"HG98HCFL\"],[243726,\"2Z3A0H6F\",27330],[788492,\"HG98HCFL\",27409],[\"FJVIO218\",\"FU1D57HA\"],[730441,\"HG98HCFL\",27465],[418199,\"OZ13ZSIN\",27557],[\"NJB0V6ZO\",\"HG98HCFL\"],[416184,\"X8W3R0P7\",27576],[177447,\"GQINA28A\",27661],[27187,\"Q6L1ZD92\",27684],[53005,\"MY3O8OQI\",27746],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[835356,\"HG98HCFL\",27775],[88784,\"NJB0V6ZO\",27865],[747281,\"HG98HCFL\",27921],[\"OZ13ZSIN\",\"HG98HCFL\"],[184691,\"CWWVVCGZ\",27974],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[554716,\"OZ13ZSIN\",28020],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"FU1D57HA\",28107],[\"ZR7QN32O\",\"R62MQ4FI\"],[326091,\"XOK1HH1Y\",28151],[927316,\"OZ13ZSIN\",28193],[\"T25R11PB\",\"FU1D57HA\"],[499875,\"NJB0V6ZO\",28256],[590013,\"OZ13ZSIN\",28354],[62740,\"OZ13ZSIN\",28413],[876351,\"FU1D57HA\",28469],[749462,\"OZ13ZSIN\",28525],[\"5D5SUJ4Q\",\"FU1D57HA\"],[996616,\"OGVA50NO\",28553],[177447,\"CWWVVCGZ\",28572],[\"OZ13ZSIN\",\"FU1D57HA\"],[438428,\"L6KOAIR1\",28631],[693354,\"DLUQBV4V\",28663],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[880171,\"475J29EI\",28754],[588541,\"1YA7XTV9\",28760],[457056,\"HG98HCFL\",28762],[\"OZ13ZSIN\",\"VL50N6D1\"],[84268,\"HG98HCFL\",28792],[130492,\"IMDG88XX\",28832],[163069,\"FWUZEALC\",28840],[\"C00L36RI\",\"JYTPXJK9\"],[417559,\"BMX2AIY5\",28890],[\"OZ13ZSIN\",\"HG98HCFL\"],[914704,\"FU1D57HA\",28939],[55617,\"VL2TL1NM\",28974],[\"4SBAAFIP\",\"E35YW0BM\"],[911613,\"FU1D57HA\",29069],[880171,\"HG98HCFL\",29099],[\"OZ13ZSIN\",\"FU1D57HA\"],[117275,\"4SBAAFIP\",29174],[822091,\"FU1D57HA\",29206],[775394,\"XQ8MRL86\",29284],[917846,\"4SBAAFIP\",29288],[55790,\"0NYQFXYO\",29343],[\"83OEBTCQ\",\"0BIIAVNU\"],[416184,\"HG98HCFL\",29415],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"FJVIO218\",\"FU1D57HA\"],[228425,\"OZ13ZSIN\",29438],[\"CAWYGMWL\",\"NTNXSB47\"],[87834,\"OZ13ZSIN\",29442],[633159,\"WMTPA7JN\",29482],[322118,\"OZ13ZSIN\",29526],[\"1XW6HVBY\",\"FU1D57HA\"],[675060,\"K9D63ZZC\",29617],[225487,\"RPKD08C6\",29691],[708687,\"OZ13ZSIN\",29761],[836854,\"OZ13ZSIN\",29845],[\"6QKM8CM8\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[299466,\"4SBAAFIP\",29860],[\"WGOD5SD4\",\"E35YW0BM\"],[\"X8W3R0P7\",\"FU1D57HA\"],[927316,\"HG98HCFL\",29938],[483609,\"HG98HCFL\",29995],[\"C00L36RI\",\"JYTPXJK9\"],[\"OZ13ZSIN\",\"L6KOAIR1\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"HG98HCFL\",30054],[870611,\"72Q6VPM1\",30066],[754460,\"4SBAAFIP\",30086],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[979711,\"OZ13ZSIN\",30112],[322118,\"EY70T3I1\",30197],[696824,\"ZWJJHOU3\",30263],[239811,\"WGOD5SD4\",30361],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"475J29EI\",\"HG98HCFL\"],[963752,\"1XW6HVBY\",30399],[764562,\"OZ13ZSIN\",30480],[165422,\"XQ8MRL86\",30559],[282372,\"2MKY7B5Q\",30609],[554716,\"HG98HCFL\",30700],[925378,\"HG98HCFL\",30705],[836854,\"UB4KML0J\",30802],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[328085,\"PYU6IFCW\",30865],[999272,\"NTNXSB47\",30884],[510551,\"HG98HCFL\",30903],[87834,\"HG98HCFL\",30918],[590013,\"HG98HCFL\",30950],[775394,\"MPBZFLN9\",30963],[701078,\"OZ13ZSIN\",31024],[561608,\"WIXJ6Z00\",31082],[\"OZ13ZSIN\",\"HG98HCFL\"],[328085,\"FU1D57HA\",31132],[165422,\"HG98HCFL\",31226],[997488,\"HG98HCFL\",31249],[785370,\"FY86VG9O\",31334],[186553,\"6GPMXUYZ\",31378],[282372,\"FU1D57HA\",31454],[88784,\"WMTPA7JN\",31484],[186637,\"973PO4KY\",31528],[62740,\"HG98HCFL\",31561],[206116,\"CWWVVCGZ\",31653],[525469,\"OZ13ZSIN\",31705],[\"OZ13ZSIN\",\"CWWVVCGZ\"],[109318,\"OZ13ZSIN\",31719],[954915,\"WS49LJP8\",31776],[\"OZ13ZSIN\",\"FU1D57HA\"],[166180,\"FU1D57HA\",31824],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"MY3O8OQI\",\"FU1D57HA\"],[539280,\"YZ8LNY1V\",31843],[\"OZ13ZSIN\",\"UB4KML0J\"],[901923,\"OZ13ZSIN\",31865],[963752,\"VMT100K8\",31918],[239811,\"HG98HCFL\",31990]]` wtf is this testcase bro \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "i feel stupid that i opened ur comment. LoL ! it took forever to scroll down"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "resolved ? me also getting error in this test case"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The May badge was not an easy one! Guys let\\'s get this done!!!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Yay!"
                    },
                    {
                        "username": "omeraktepe",
                        "content": "There is a test case that does not meet assumptions. \nTest case 56: [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]] \n\nIt violetes followings: \n1. A customer can only be checked into one place at a time. \n2. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order. \n\nI am too lazy to report though :)"
                    },
                    {
                        "username": "zavojchevski",
                        "content": "I agree on this, restrictions should be well explained. "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "For those failing test case 51:\\n\"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\"\\nCredit to xuawai for noticing this back in 2020."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Restrictions should be written stricter. Some strange cases which are valid:\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@psionl0](/psionl0) \\'getAverageTime\\' arguments are invalid: "
                    },
                    {
                        "username": "psionl0",
                        "content": "All your test cases work on my code but it fails on Leet testcase 49. I also tried\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"],[\"A\",\"C\"]]\n``` \nbut that seems to be an invalid test case."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[@anwendeng](/anwendeng) My code works too, but it\\'s strange."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I have tested all of your test cases and my program passed!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using  2 tables  to store the info.\nUse hash tables for check-in and travel time info! \nThe programming is easier than a standard design for Hash set!\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Thanks for spoiling the answer for people in reallllllly big font so they don\\'t accidently try to come up with the answer themselves! Real nice of you."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "but bro trust me designing a hash set is highly asked interview problem ...\\nI recalled my concept of how we can store data in hashset..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "## **Don't raise your font at us!**"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/design-underground-system/solutions/3580430/easy-c-python-solutions-with-unordered-map-dict/"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Now people here in discuss section only comment to boost up there reputation."
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "This is an issue here and with almost all of these problems. Using vague or ambiguous names for parameters would never be allowed in enterprise software development. \\'id\\' ? id of what? Argument with name \\'t\\' is it time, train, turn? the code should be explanatory even without the description. Its also a prevalent issue in the editorials and provided solutions. \\n\\nThis is also an accessibility and inclusivity issue. When working on teams where not everyone speaks or has native proficiency in the same language using abbreviations or short hand becomes a huge problem. Leetcode should try and make it\\'s examples as near to what would be expected in a real workplace not a college math class."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me feel bad for jumping over the gates every time I lost my ticket on the way.\nSorry for creating stupid edge cases to handle for some devs somewhere"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Today is a special day for me as I will be getting my first badge of leetcode.\nThrough this one month of solving questions daily, the one thing that I have learnt is nothing matters- not even motivation if you don't have the habit of being consistent throughout the journey. \nI am looking forward to be more consistent.\nHappy coding fellow leetcoders!!!"
                    }
                ]
            },
            {
                "id": 1923105,
                "content": [
                    {
                        "username": "jax_ay",
                        "content": "`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\"] [[],[117077,\"OZ13ZSIN\",42],[117077,\"FU1D57HA\",125],[704903,\"OZ13ZSIN\",211],[911239,\"OZ13ZSIN\",245],[704903,\"HG98HCFL\",340],[859828,\"OZ13ZSIN\",355],[\"OZ13ZSIN\",\"FU1D57HA\"],[911239,\"FU1D57HA\",383],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[859828,\"FU1D57HA\",402],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[363027,\"OZ13ZSIN\",489],[319826,\"OZ13ZSIN\",550],[\"OZ13ZSIN\",\"FU1D57HA\"],[363027,\"HG98HCFL\",565],[319826,\"FU1D57HA\",664],[120084,\"OZ13ZSIN\",735],[\"OZ13ZSIN\",\"HG98HCFL\"],[120084,\"HG98HCFL\",832],[56672,\"OZ13ZSIN\",876],[56672,\"HG98HCFL\",912],[638995,\"OZ13ZSIN\",925],[\"OZ13ZSIN\",\"FU1D57HA\"],[638995,\"FU1D57HA\",951],[712949,\"OZ13ZSIN\",1023],[712949,\"FU1D57HA\",1033],[278482,\"T25R11PB\",1080],[\"OZ13ZSIN\",\"FU1D57HA\"],[278482,\"FU1D57HA\",1160],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[342818,\"4SBAAFIP\",1250],[342818,\"HG98HCFL\",1263],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[415673,\"OZ13ZSIN\",1270],[415673,\"NTNXSB47\",1366],[\"T25R11PB\",\"FU1D57HA\"],[597115,\"4SBAAFIP\",1385],[463555,\"OZ13ZSIN\",1461],[463555,\"HG98HCFL\",1514],[801778,\"OZ13ZSIN\",1537],[201428,\"OZ13ZSIN\",1620],[245538,\"OZ13ZSIN\",1630],[597115,\"FU1D57HA\",1657],[583112,\"OZ13ZSIN\",1690],[\"4SBAAFIP\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[691834,\"OZ13ZSIN\",1723],[250537,\"OZ13ZSIN\",1753],[201428,\"H4UTDCR8\",1804],[691834,\"FU1D57HA\",1838],[\"T25R11PB\",\"FU1D57HA\"],[245538,\"FU1D57HA\",1924],[346824,\"OZ13ZSIN\",1952],[864512,\"OZ13ZSIN\",2005],[499705,\"OZ13ZSIN\",2048],[482469,\"GQINA28A\",2058],[\"OZ13ZSIN\",\"FU1D57HA\"],[583112,\"E35YW0BM\",2080],[\"OZ13ZSIN\",\"HG98HCFL\"],[801778,\"HG98HCFL\",2082],[250415,\"I0Y75MZQ\",2149],[795633,\"OZ13ZSIN\",2196],[\"OZ13ZSIN\",\"HG98HCFL\"],[99144,\"4SBAAFIP\",2219],[83594,\"OZ13ZSIN\",2249],[346824,\"HG98HCFL\",2290],[482469,\"HG98HCFL\",2368],[499705,\"FU1D57HA\",2437],[12539,\"OZ13ZSIN\",2442],[116546,\"OZ13ZSIN\",2493],[884032,\"4SBAAFIP\",2579],[801142,\"OZ13ZSIN\",2598],[795633,\"HG98HCFL\",2693],[83594,\"HG98HCFL\",2782],[529306,\"OZ13ZSIN\",2824],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[286490,\"OZ13ZSIN\",2844],[255488,\"OZ13ZSIN\",2935],[608514,\"OZ13ZSIN\",2984],[116546,\"HG98HCFL\",3079],[250415,\"FU1D57HA\",3174],[\"OZ13ZSIN\",\"FU1D57HA\"],[884032,\"E35YW0BM\",3267],[\"OZ13ZSIN\",\"FU1D57HA\"],[529306,\"HG98HCFL\",3299],[\"OZ13ZSIN\",\"FU1D57HA\"],[892550,\"OZ13ZSIN\",3388],[892550,\"2VVKO5AZ\",3394],[14673,\"OZ13ZSIN\",3487],[\"OZ13ZSIN\",\"HG98HCFL\"],[12539,\"HG98HCFL\",3576],[\"OZ13ZSIN\",\"HG98HCFL\"],[255488,\"HG98HCFL\",3674],[\"OZ13ZSIN\",\"HG98HCFL\"],[14673,\"HG98HCFL\",3754],[864512,\"FU1D57HA\",3819],[451611,\"OZ13ZSIN\",3899],[\"4SBAAFIP\",\"E35YW0BM\"],[451611,\"HG98HCFL\",3941],[250537,\"HG98HCFL\",4027],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[286490,\"FU1D57HA\",4046],[608514,\"HG98HCFL\",4094],[827431,\"XWO403P7\",4107],[99144,\"HG98HCFL\",4136],[\"GQINA28A\",\"HG98HCFL\"],[657832,\"OZ13ZSIN\",4150],[827431,\"HG98HCFL\",4214],[\"OZ13ZSIN\",\"FU1D57HA\"],[658842,\"OZ13ZSIN\",4236],[52933,\"4SBAAFIP\",4325],[801142,\"HG98HCFL\",4413],[52933,\"E35YW0BM\",4460],[331712,\"OZ13ZSIN\",4522],[658842,\"NTNXSB47\",4615],[293734,\"OZ13ZSIN\",4665],[293734,\"HG98HCFL\",4735],[917903,\"OZ13ZSIN\",4772],[119860,\"OZ13ZSIN\",4775],[\"OZ13ZSIN\",\"HG98HCFL\"],[657832,\"E35YW0BM\",4850],[415861,\"NJB0V6ZO\",4881],[\"OZ13ZSIN\",\"FU1D57HA\"],[917903,\"HG98HCFL\",4892],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[415861,\"HG98HCFL\",4919],[\"OZ13ZSIN\",\"HG98HCFL\"],[331712,\"OGVA50NO\",4979],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[119860,\"HG98HCFL\",5034],[469875,\"OZ13ZSIN\",5053],[407362,\"XT14GVGK\",5073],[469875,\"HG98HCFL\",5126],[407362,\"HG98HCFL\",5175],[324747,\"OZ13ZSIN\",5236],[315560,\"OZ13ZSIN\",5333],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[317815,\"OZ13ZSIN\",5339],[906872,\"OZ13ZSIN\",5349],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[404251,\"OZ13ZSIN\",5375],[324747,\"HG98HCFL\",5474],[882572,\"OZ13ZSIN\",5524],[\"OZ13ZSIN\",\"HG98HCFL\"],[758501,\"OZ13ZSIN\",5561],[404251,\"FU1D57HA\",5617],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[315560,\"HG98HCFL\",5651],[758501,\"HG98HCFL\",5673],[141090,\"OZ13ZSIN\",5768],[882572,\"FU1D57HA\",5827],[906872,\"HG98HCFL\",5872],[141090,\"HG98HCFL\",5940],[\"OZ13ZSIN\",\"FU1D57HA\"],[317815,\"HG98HCFL\",5996],[436252,\"OZ13ZSIN\",6027],[\"OZ13ZSIN\",\"E35YW0BM\"],[436252,\"HG98HCFL\",6084],[\"OZ13ZSIN\",\"NTNXSB47\"],[652912,\"NJB0V6ZO\",6155],[652912,\"HG98HCFL\",6169],[269825,\"NJB0V6ZO\",6173],[831024,\"OZ13ZSIN\",6267],[831024,\"FU1D57HA\",6317],[269825,\"FU1D57HA\",6318],[794093,\"OZ13ZSIN\",6406],[\"OZ13ZSIN\",\"HG98HCFL\"],[794093,\"FU1D57HA\",6429],[798558,\"OZ13ZSIN\",6497],[798558,\"E35YW0BM\",6500],[271136,\"NJB0V6ZO\",6582],[\"OZ13ZSIN\",\"HG98HCFL\"],[608446,\"OZ13ZSIN\",6662],[608446,\"FU1D57HA\",6760],[986152,\"OZ13ZSIN\",6799],[986152,\"NTNXSB47\",6825],[271136,\"HG98HCFL\",6911],[\"OZ13ZSIN\",\"FU1D57HA\"],[341349,\"OZ13ZSIN\",6995],[595955,\"OZ13ZSIN\",7039],[58242,\"H9OKZANW\",7071],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[134319,\"OZ13ZSIN\",7119],[595955,\"FU1D57HA\",7161],[\"OZ13ZSIN\",\"HG98HCFL\"],[266781,\"OZ13ZSIN\",7208],[\"OZ13ZSIN\",\"FU1D57HA\"],[266781,\"FU1D57HA\",7298],[\"OZ13ZSIN\",\"NTNXSB47\"],[935757,\"OZ13ZSIN\",7300],[517277,\"OZ13ZSIN\",7376],[58242,\"HG98HCFL\",7459],[\"OZ13ZSIN\",\"HG98HCFL\"],[288203,\"OZ13ZSIN\",7512],[293244,\"T25R11PB\",7580],[517277,\"HG98HCFL\",7588],[293244,\"FU1D57HA\",7649],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[480741,\"OZ13ZSIN\",7748],[288203,\"CWJHORPF\",7845],[935757,\"NTNXSB47\",7940],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[341349,\"HG98HCFL\",7952],[870607,\"ST6XEPDA\",7986],[\"OZ13ZSIN\",\"CWJHORPF\"],[468450,\"6QKM8CM8\",8063],[262669,\"OZ13ZSIN\",8152],[\"OZ13ZSIN\",\"FU1D57HA\"],[103929,\"OZ13ZSIN\",8167],[415331,\"X8W3R0P7\",8215],[134319,\"E35YW0BM\",8226],[415331,\"FU1D57HA\",8240],[468450,\"HG98HCFL\",8263],[394949,\"XOK1HH1Y\",8313],[\"OZ13ZSIN\",\"HG98HCFL\"],[394949,\"FU1D57HA\",8402],[67177,\"GQINA28A\",8451],[67177,\"HG98HCFL\",8521],[796191,\"QJHWOKDQ\",8545],[\"I0Y75MZQ\",\"FU1D57HA\"],[\"H9OKZANW\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[940010,\"OZ13ZSIN\",8583],[940010,\"VL50N6D1\",8613],[21260,\"WGOD5SD4\",8683],[746866,\"NJB0V6ZO\",8732],[47896,\"OZ13ZSIN\",8802],[480741,\"CWJHORPF\",8839],[\"NJB0V6ZO\",\"HG98HCFL\"],[310852,\"XT82S77E\",8858],[796001,\"OZ13ZSIN\",8860],[\"OZ13ZSIN\",\"NTNXSB47\"],[103929,\"FU1D57HA\",8957],[739455,\"OZ13ZSIN\",8980],[\"XWO403P7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"VL50N6D1\"],[734337,\"OZ13ZSIN\",8989],[686615,\"4SBAAFIP\",9086],[21260,\"HG98HCFL\",9130],[\"OZ13ZSIN\",\"CWJHORPF\"],[217165,\"1XW6HVBY\",9228],[689774,\"OZ13ZSIN\",9313],[870607,\"NTNXSB47\",9319],[248471,\"OZ13ZSIN\",9376],[262669,\"E35YW0BM\",9427],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[20582,\"OZ13ZSIN\",9484],[310852,\"LBYS94AD\",9535],[746866,\"FU1D57HA\",9540],[689774,\"FU1D57HA\",9594],[796191,\"HG98HCFL\",9635],[\"OZ13ZSIN\",\"FU1D57HA\"],[734337,\"HG98HCFL\",9683],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[982523,\"XWO403P7\",9689],[\"OZ13ZSIN\",\"OGVA50NO\"],[982523,\"HG98HCFL\",9786],[796001,\"FU1D57HA\",9869],[248471,\"FU1D57HA\",9942],[187843,\"OZ13ZSIN\",10035],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"H9OKZANW\",\"HG98HCFL\"],[217165,\"HG98HCFL\",10100],[739455,\"HG98HCFL\",10171],[187843,\"HG98HCFL\",10226],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[20582,\"E35YW0BM\",10322],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"SAIV20VG\",10342],[\"OZ13ZSIN\",\"FU1D57HA\"],[686615,\"HG98HCFL\",10396],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"CAWYGMWL\",10402],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[800300,\"OZ13ZSIN\",10472],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"NTNXSB47\",10485],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[800300,\"HG98HCFL\",10545],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"FU1D57HA\",10581],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[47896,\"NTNXSB47\",10588],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[788823,\"83OEBTCQ\",10599],[\"CAWYGMWL\",\"NTNXSB47\"],[365416,\"OZ13ZSIN\",10690],[610273,\"OZ13ZSIN\",10757],[988219,\"FWUZEALC\",10767],[\"XT14GVGK\",\"HG98HCFL\"],[910256,\"OZ13ZSIN\",10797],[\"OZ13ZSIN\",\"CWJHORPF\"],[610273,\"FU1D57HA\",10848],[\"OZ13ZSIN\",\"FU1D57HA\"],[910256,\"HMJCZQ0K\",10920],[\"OZ13ZSIN\",\"NTNXSB47\"],[988219,\"HG98HCFL\",10930],[365416,\"HG98HCFL\",10972],[219722,\"OZ13ZSIN\",11033],[295336,\"ITA0GE26\",11107],[219722,\"R62MQ4FI\",11131],[295336,\"FU1D57HA\",11140],[788823,\"0BIIAVNU\",11199],[620927,\"T25R11PB\",11274],[620927,\"FU1D57HA\",11371],[630168,\"OZ13ZSIN\",11448],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[112534,\"OZ13ZSIN\",11449],[573142,\"OZ13ZSIN\",11546],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[454282,\"NJB0V6ZO\",11576],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[454282,\"HG98HCFL\",11643],[444090,\"6QKM8CM8\",11698],[630168,\"Y43BFD6U\",11717],[185093,\"1XW6HVBY\",11723],[217806,\"4SBAAFIP\",11814],[\"XOK1HH1Y\",\"FU1D57HA\"],[573142,\"FU1D57HA\",11874],[661431,\"UT8S3IM6\",11907],[335406,\"OZ13ZSIN\",11942],[\"T25R11PB\",\"FU1D57HA\"],[444090,\"HG98HCFL\",11995],[896969,\"QJHWOKDQ\",12032],[950584,\"NJB0V6ZO\",12097],[570450,\"NJB0V6ZO\",12128],[896969,\"HG98HCFL\",12146],[71637,\"4SBAAFIP\",12202],[923844,\"OZ13ZSIN\",12277],[\"NJB0V6ZO\",\"HG98HCFL\"],[374491,\"OZ13ZSIN\",12300],[333698,\"1XW6HVBY\",12343],[323202,\"4SBAAFIP\",12369],[489161,\"OZ13ZSIN\",12419],[489161,\"BMN7MUED\",12446],[177905,\"XOK1HH1Y\",12483],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[185093,\"FU1D57HA\",12520],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"OZ13ZSIN\",12538],[765285,\"OZ13ZSIN\",12554],[\"OZ13ZSIN\",\"VL50N6D1\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[80760,\"XOK1HH1Y\",12613],[570450,\"R47UH9EC\",12643],[777227,\"OZ13ZSIN\",12717],[30391,\"XQ8MRL86\",12743],[923844,\"NTNXSB47\",12843],[\"OZ13ZSIN\",\"HG98HCFL\"],[177905,\"HG98HCFL\",12901],[374491,\"2Z3A0H6F\",12957],[950584,\"7IO8ET8F\",13035],[\"1XW6HVBY\",\"HG98HCFL\"],[636717,\"WY85FIVE\",13122],[661431,\"L6KOAIR1\",13154],[80760,\"XIUOFK2Y\",13215],[\"OZ13ZSIN\",\"HG98HCFL\"],[428110,\"4SBAAFIP\",13262],[\"H9OKZANW\",\"HG98HCFL\"],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"83OEBTCQ\",\"0BIIAVNU\"],[502345,\"1MOLNL46\",13324],[112534,\"HG98HCFL\",13393],[\"OZ13ZSIN\",\"HG98HCFL\"],[25332,\"OZ13ZSIN\",13487],[240072,\"OZ13ZSIN\",13504],[649981,\"ITA0GE26\",13603],[363027,\"NJB0V6ZO\",13627],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"FU1D57HA\",13724],[961598,\"ST6XEPDA\",13810],[75634,\"ZWJJHOU3\",13877],[807547,\"OZ13ZSIN\",13900],[\"OZ13ZSIN\",\"FU1D57HA\"],[71637,\"HG98HCFL\",13998],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[300645,\"OZ13ZSIN\",14033],[849654,\"OZ13ZSIN\",14128],[701073,\"GQINA28A\",14209],[288997,\"WGOD5SD4\",14252],[7101,\"OZ13ZSIN\",14258],[143698,\"SH04ZH5G\",14355],[849654,\"HG98HCFL\",14395],[300645,\"RBRIS3JS\",14484],[171052,\"OZ13ZSIN\",14576],[214567,\"NJB0V6ZO\",14592],[961598,\"JYTPXJK9\",14646],[132966,\"4SR0921V\",14665],[822925,\"4SBAAFIP\",14742],[333698,\"HG98HCFL\",14835],[\"OZ13ZSIN\",\"HG98HCFL\"],[822925,\"E35YW0BM\",14920],[777227,\"HG98HCFL\",15017],[123308,\"OZ13ZSIN\",15095],[598091,\"6QKM8CM8\",15150],[363027,\"HG98HCFL\",15160],[912565,\"OZ13ZSIN\",15202],[93990,\"1XW6HVBY\",15291],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[25332,\"FU1D57HA\",15332],[143698,\"HG98HCFL\",15380],[502345,\"DYLQ657K\",15429],[171052,\"HG98HCFL\",15436],[\"1XW6HVBY\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[217806,\"FU1D57HA\",15469],[487305,\"5D5SUJ4Q\",15499],[44397,\"6QKM8CM8\",15536],[601607,\"XOK1HH1Y\",15566],[30391,\"HG98HCFL\",15586],[\"OZ13ZSIN\",\"OGVA50NO\"],[765285,\"IX7LS60B\",15641],[788097,\"T25R11PB\",15730],[300198,\"6TED6G4E\",15774],[529964,\"OZ13ZSIN\",15793],[803049,\"IEQICIHL\",15826],[\"OZ13ZSIN\",\"HG98HCFL\"],[7101,\"DKN9PRYJ\",15869],[\"T25R11PB\",\"FU1D57HA\"],[761575,\"D5TNGKU7\",15885],[93990,\"HG98HCFL\",15894],[323202,\"HG98HCFL\",15898],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"OZ13ZSIN\",15990],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"OGVA50NO\"],[213297,\"OZ13ZSIN\",16034],[300198,\"HG98HCFL\",16105],[912565,\"HG98HCFL\",16175],[806824,\"NJB0V6ZO\",16274],[417297,\"OZ13ZSIN\",16334],[\"XQ8MRL86\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[690271,\"GQINA28A\",16427],[540402,\"OZ13ZSIN\",16500],[807547,\"FU1D57HA\",16504],[335406,\"HG98HCFL\",16539],[417297,\"HG98HCFL\",16618],[192719,\"QB05LSRK\",16711],[255839,\"OZ13ZSIN\",16755],[\"OZ13ZSIN\",\"BMN7MUED\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[711297,\"OZ13ZSIN\",16810],[\"OZ13ZSIN\",\"CWJHORPF\"],[711297,\"HG98HCFL\",16899],[211279,\"VL2TL1NM\",16907],[\"XT14GVGK\",\"HG98HCFL\"],[\"XWO403P7\",\"HG98HCFL\"],[213297,\"FU1D57HA\",16964],[44397,\"7JHO6FK0\",17021],[\"4SBAAFIP\",\"HG98HCFL\"],[75634,\"H4UTDCR8\",17075],[996616,\"JYLXUII8\",17167],[775204,\"ZZLR3YVJ\",17215],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[211106,\"6TED6G4E\",17217],[649981,\"HG98HCFL\",17236],[775204,\"HG98HCFL\",17246],[806824,\"HG98HCFL\",17313],[214567,\"GWJB6BU5\",17411],[487305,\"FU1D57HA\",17496],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[237574,\"GA4KQD8H\",17572],[863199,\"OZ13ZSIN\",17616],[921800,\"OZ13ZSIN\",17693],[415592,\"NJB0V6ZO\",17784],[788097,\"FU1D57HA\",17844],[79918,\"ZR7QN32O\",17930],[240072,\"HG98HCFL\",17938],[\"OZ13ZSIN\",\"HG98HCFL\"],[253649,\"OZ13ZSIN\",17981],[545511,\"OZ13ZSIN\",18005],[237574,\"FU1D57HA\",18089],[\"OZ13ZSIN\",\"NTNXSB47\"],[255839,\"HG98HCFL\",18169],[701073,\"HJXEGP9U\",18269],[598091,\"FU1D57HA\",18287],[\"OZ13ZSIN\",\"HG98HCFL\"],[540402,\"HG98HCFL\",18349],[887853,\"GA4KQD8H\",18417],[\"XT82S77E\",\"LBYS94AD\"],[863199,\"HG98HCFL\",18484],[\"OZ13ZSIN\",\"HG98HCFL\"],[127768,\"OZ13ZSIN\",18571],[872173,\"OZ13ZSIN\",18579],[\"OZ13ZSIN\",\"HG98HCFL\"],[872173,\"UB4KML0J\",18638],[428110,\"HG98HCFL\",18720],[\"ITA0GE26\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[85526,\"OZ13ZSIN\",18803],[123308,\"HG98HCFL\",18872],[273723,\"FJVIO218\",18884],[\"OZ13ZSIN\",\"FU1D57HA\"],[716950,\"OZ13ZSIN\",18916],[436026,\"OZ13ZSIN\",18922],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[127768,\"FU1D57HA\",18931],[646079,\"IMDG88XX\",18944],[784931,\"OZ13ZSIN\",19001],[\"OZ13ZSIN\",\"OGVA50NO\"],[\"OZ13ZSIN\",\"H4UTDCR8\"],[803049,\"RPKD08C6\",19041],[627595,\"MBY9ZG7D\",19129],[386653,\"BMX2AIY5\",19179],[\"OZ13ZSIN\",\"CWJHORPF\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[211106,\"HG98HCFL\",19251],[855448,\"OZ13ZSIN\",19300],[733785,\"SPVKZTIP\",19344],[\"XOK1HH1Y\",\"HG98HCFL\"],[761575,\"HG98HCFL\",19444],[\"OZ13ZSIN\",\"HG98HCFL\"],[132966,\"H4UTDCR8\",19503],[948005,\"OZ13ZSIN\",19520],[14408,\"OZ13ZSIN\",19594],[\"I0Y75MZQ\",\"FU1D57HA\"],[85526,\"NTNXSB47\",19687],[211403,\"OZ13ZSIN\",19761],[677411,\"OZ13ZSIN\",19852],[192719,\"HG98HCFL\",19905],[887853,\"HG98HCFL\",19975],[455474,\"OZ13ZSIN\",20002],[601607,\"FU1D57HA\",20077],[14408,\"HG98HCFL\",20150],[\"OZ13ZSIN\",\"DKN9PRYJ\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[253649,\"1QLZUAXZ\",20166],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[548975,\"OZ13ZSIN\",20232],[386653,\"1QLZUAXZ\",20277],[415592,\"HG98HCFL\",20318],[716950,\"3ZJ18VKA\",20384],[84268,\"OZ13ZSIN\",20392],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[55374,\"4SBAAFIP\",20416],[851948,\"OZ13ZSIN\",20503],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"OZ13ZSIN\",20513],[615192,\"OZ13ZSIN\",20551],[851948,\"HG98HCFL\",20631],[211403,\"HG98HCFL\",20668],[677411,\"OGVA50NO\",20715],[55374,\"FU1D57HA\",20749],[457056,\"OZ13ZSIN\",20799],[\"XOK1HH1Y\",\"FU1D57HA\"],[548975,\"HG98HCFL\",20836],[41381,\"MY3O8OQI\",20908],[950414,\"OZ13ZSIN\",20971],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[873337,\"OZ13ZSIN\",21038],[\"5D5SUJ4Q\",\"FU1D57HA\"],[273723,\"FU1D57HA\",21053],[726970,\"OZ13ZSIN\",21070],[\"OZ13ZSIN\",\"HG98HCFL\"],[211279,\"HG98HCFL\",21127],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[276902,\"4T1TBZX5\",21160],[\"OZ13ZSIN\",\"HG98HCFL\"],[183959,\"OZ13ZSIN\",21209],[488167,\"OZ13ZSIN\",21250],[\"OZ13ZSIN\",\"HG98HCFL\"],[166180,\"OZ13ZSIN\",21323],[\"FJVIO218\",\"FU1D57HA\"],[636717,\"UB4KML0J\",21366],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"DLUQBV4V\",21413],[\"OZ13ZSIN\",\"FU1D57HA\"],[528132,\"LUCPET9G\",21476],[206116,\"0MOLP3NC\",21551],[183959,\"XPM6JMBR\",21562],[\"OZ13ZSIN\",\"HG98HCFL\"],[553646,\"BMX2AIY5\",21661],[\"OZ13ZSIN\",\"DLUQBV4V\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"SH04ZH5G\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"R62MQ4FI\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[724508,\"C00L36RI\",21665],[950414,\"FU1D57HA\",21721],[102566,\"NJB0V6ZO\",21819],[690271,\"HG98HCFL\",21829],[\"OZ13ZSIN\",\"HG98HCFL\"],[386570,\"OZ13ZSIN\",21870],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[733785,\"FU1D57HA\",21931],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"ZWJJHOU3\",\"H4UTDCR8\"],[493080,\"OZ13ZSIN\",21957],[\"OZ13ZSIN\",\"RBRIS3JS\"],[476818,\"NJB0V6ZO\",22018],[\"OZ13ZSIN\",\"HG98HCFL\"],[646079,\"VMT100K8\",22076],[873337,\"E35YW0BM\",22080],[529964,\"FU1D57HA\",22162],[41381,\"FU1D57HA\",22233],[\"1XW6HVBY\",\"HG98HCFL\"],[\"IMDG88XX\",\"VMT100K8\"],[724508,\"JYTPXJK9\",22301],[\"OZ13ZSIN\",\"FU1D57HA\"],[276768,\"OZ13ZSIN\",22339],[654375,\"1XW6HVBY\",22349],[276768,\"X1H2W3W0\",22438],[\"OZ13ZSIN\",\"UB4KML0J\"],[855448,\"KSOIJA62\",22533],[493080,\"FU1D57HA\",22554],[726970,\"E35YW0BM\",22603],[\"4SR0921V\",\"H4UTDCR8\"],[79918,\"R62MQ4FI\",22640],[659224,\"OZ13ZSIN\",22739],[436026,\"L6KOAIR1\",22770],[288997,\"E35YW0BM\",22850],[\"SAIV20VG\",\"FU1D57HA\"],[553646,\"FU1D57HA\",22946],[659224,\"NTNXSB47\",22957],[615192,\"HG98HCFL\",23056],[\"OZ13ZSIN\",\"E35YW0BM\"],[730441,\"1XW6HVBY\",23129],[55790,\"OZ13ZSIN\",23179],[524967,\"OZ13ZSIN\",23189],[44097,\"2GRLB4CN\",23280],[784931,\"E35YW0BM\",23343],[525825,\"OZ13ZSIN\",23384],[315479,\"XQ8MRL86\",23386],[537074,\"OZ13ZSIN\",23437],[\"XT82S77E\",\"LBYS94AD\"],[524967,\"7JIXF9D1\",23496],[559244,\"OZ13ZSIN\",23569],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[872522,\"FJVIO218\",23579],[160528,\"DE386QWN\",23602],[\"4SBAAFIP\",\"HG98HCFL\"],[832697,\"OZ13ZSIN\",23696],[439436,\"NJB0V6ZO\",23749],[559244,\"MJZC0DI0\",23811],[38958,\"4SBAAFIP\",23863],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[327722,\"OZ13ZSIN\",23901],[243726,\"OZ13ZSIN\",23955],[38958,\"WUIGDE36\",24007],[832697,\"4IBLBVYU\",24058],[626392,\"QK3YTSXO\",24064],[640646,\"OZ13ZSIN\",24084],[476818,\"R5XHXCAN\",24129],[13070,\"NJB0V6ZO\",24190],[\"VL2TL1NM\",\"HG98HCFL\"],[633159,\"GQYWQW84\",24235],[528132,\"MPBZFLN9\",24236],[668517,\"OZ13ZSIN\",24307],[627595,\"HG98HCFL\",24343],[\"OZ13ZSIN\",\"HG98HCFL\"],[438428,\"PQOMFBOJ\",24350],[386570,\"FU1D57HA\",24413],[668517,\"7JHO6FK0\",24482],[561608,\"2IVTIGII\",24575],[539280,\"ITA0GE26\",24660],[160528,\"7IO8ET8F\",24668],[\"T25R11PB\",\"FU1D57HA\"],[626392,\"FU1D57HA\",24755],[\"4SBAAFIP\",\"WUIGDE36\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[251034,\"4SBAAFIP\",24786],[968259,\"OZ13ZSIN\",24870],[640646,\"I9H1UDG4\",24892],[361979,\"OZ13ZSIN\",24945],[806004,\"WPM57THK\",25006],[488167,\"VL50N6D1\",25009],[\"XT82S77E\",\"LBYS94AD\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[\"XQ8MRL86\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HMJCZQ0K\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[787728,\"OZ13ZSIN\",25084],[95528,\"OZ13ZSIN\",25154],[825321,\"4SBAAFIP\",25200],[\"OZ13ZSIN\",\"HG98HCFL\"],[968259,\"HG98HCFL\",25234],[\"NJB0V6ZO\",\"HG98HCFL\"],[537074,\"2Z3A0H6F\",25283],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"1QLZUAXZ\"],[430837,\"ZOA7MKHB\",25342],[588541,\"OZ13ZSIN\",25380],[\"OZ13ZSIN\",\"HG98HCFL\"],[276902,\"FU1D57HA\",25448],[787728,\"BMN7MUED\",25495],[590184,\"KFRF7AEZ\",25577],[\"LUCPET9G\",\"MPBZFLN9\"],[510551,\"OZ13ZSIN\",25597],[806004,\"HG98HCFL\",25608],[925378,\"T25R11PB\",25614],[27187,\"NJB0V6ZO\",25651],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"DE386QWN\",25682],[525825,\"IX7LS60B\",25695],[876351,\"1XW6HVBY\",25761],[225487,\"SPVKZTIP\",25783],[159468,\"OZ13ZSIN\",25784],[785370,\"BMX2AIY5\",25819],[159468,\"FU1D57HA\",25847],[822091,\"1XW6HVBY\",25911],[142228,\"OZ13ZSIN\",25962],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"HG98HCFL\",25997],[6026,\"WPM57THK\",26000],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"J1X7TLQD\",26041],[42555,\"D5TNGKU7\",26042],[921331,\"XOK1HH1Y\",26066],[95528,\"GWVJKDKT\",26130],[361979,\"CWWVVCGZ\",26183],[747281,\"OZ13ZSIN\",26197],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"NJB0V6ZO\",\"7IO8ET8F\"],[590184,\"FY86VG9O\",26248],[443593,\"6TED6G4E\",26254],[921331,\"IVDGXU4R\",26354],[184691,\"XOK1HH1Y\",26394],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"D5TNGKU7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[997488,\"OZ13ZSIN\",26468],[161852,\"OZ13ZSIN\",26476],[42555,\"HG98HCFL\",26505],[948005,\"88RO58CG\",26517],[499506,\"ITA0GE26\",26545],[\"OZ13ZSIN\",\"FU1D57HA\"],[654375,\"FU1D57HA\",26593],[999272,\"OZ13ZSIN\",26641],[\"OZ13ZSIN\",\"FU1D57HA\"],[788492,\"OZ13ZSIN\",26738],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"4SBAAFIP\",\"E35YW0BM\"],[327722,\"HG98HCFL\",26780],[499506,\"GWVJKDKT\",26878],[825321,\"HG98HCFL\",26973],[\"CAWYGMWL\",\"NTNXSB47\"],[606855,\"C00L36RI\",26996],[498054,\"OZ13ZSIN\",27025],[455474,\"7JHO6FK0\",27070],[911613,\"OZ13ZSIN\",27170],[693354,\"O77WFMCI\",27225],[\"OZ13ZSIN\",\"HG98HCFL\"],[483609,\"G2LO9U87\",27250],[\"D5TNGKU7\",\"HG98HCFL\"],[914704,\"OZ13ZSIN\",27252],[835356,\"OZ13ZSIN\",27277],[\"XOK1HH1Y\",\"HG98HCFL\"],[243726,\"2Z3A0H6F\",27330],[788492,\"HG98HCFL\",27409],[\"FJVIO218\",\"FU1D57HA\"],[730441,\"HG98HCFL\",27465],[418199,\"OZ13ZSIN\",27557],[\"NJB0V6ZO\",\"HG98HCFL\"],[416184,\"X8W3R0P7\",27576],[177447,\"GQINA28A\",27661],[27187,\"Q6L1ZD92\",27684],[53005,\"MY3O8OQI\",27746],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[835356,\"HG98HCFL\",27775],[88784,\"NJB0V6ZO\",27865],[747281,\"HG98HCFL\",27921],[\"OZ13ZSIN\",\"HG98HCFL\"],[184691,\"CWWVVCGZ\",27974],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[554716,\"OZ13ZSIN\",28020],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"FU1D57HA\",28107],[\"ZR7QN32O\",\"R62MQ4FI\"],[326091,\"XOK1HH1Y\",28151],[927316,\"OZ13ZSIN\",28193],[\"T25R11PB\",\"FU1D57HA\"],[499875,\"NJB0V6ZO\",28256],[590013,\"OZ13ZSIN\",28354],[62740,\"OZ13ZSIN\",28413],[876351,\"FU1D57HA\",28469],[749462,\"OZ13ZSIN\",28525],[\"5D5SUJ4Q\",\"FU1D57HA\"],[996616,\"OGVA50NO\",28553],[177447,\"CWWVVCGZ\",28572],[\"OZ13ZSIN\",\"FU1D57HA\"],[438428,\"L6KOAIR1\",28631],[693354,\"DLUQBV4V\",28663],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[880171,\"475J29EI\",28754],[588541,\"1YA7XTV9\",28760],[457056,\"HG98HCFL\",28762],[\"OZ13ZSIN\",\"VL50N6D1\"],[84268,\"HG98HCFL\",28792],[130492,\"IMDG88XX\",28832],[163069,\"FWUZEALC\",28840],[\"C00L36RI\",\"JYTPXJK9\"],[417559,\"BMX2AIY5\",28890],[\"OZ13ZSIN\",\"HG98HCFL\"],[914704,\"FU1D57HA\",28939],[55617,\"VL2TL1NM\",28974],[\"4SBAAFIP\",\"E35YW0BM\"],[911613,\"FU1D57HA\",29069],[880171,\"HG98HCFL\",29099],[\"OZ13ZSIN\",\"FU1D57HA\"],[117275,\"4SBAAFIP\",29174],[822091,\"FU1D57HA\",29206],[775394,\"XQ8MRL86\",29284],[917846,\"4SBAAFIP\",29288],[55790,\"0NYQFXYO\",29343],[\"83OEBTCQ\",\"0BIIAVNU\"],[416184,\"HG98HCFL\",29415],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"FJVIO218\",\"FU1D57HA\"],[228425,\"OZ13ZSIN\",29438],[\"CAWYGMWL\",\"NTNXSB47\"],[87834,\"OZ13ZSIN\",29442],[633159,\"WMTPA7JN\",29482],[322118,\"OZ13ZSIN\",29526],[\"1XW6HVBY\",\"FU1D57HA\"],[675060,\"K9D63ZZC\",29617],[225487,\"RPKD08C6\",29691],[708687,\"OZ13ZSIN\",29761],[836854,\"OZ13ZSIN\",29845],[\"6QKM8CM8\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[299466,\"4SBAAFIP\",29860],[\"WGOD5SD4\",\"E35YW0BM\"],[\"X8W3R0P7\",\"FU1D57HA\"],[927316,\"HG98HCFL\",29938],[483609,\"HG98HCFL\",29995],[\"C00L36RI\",\"JYTPXJK9\"],[\"OZ13ZSIN\",\"L6KOAIR1\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"HG98HCFL\",30054],[870611,\"72Q6VPM1\",30066],[754460,\"4SBAAFIP\",30086],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[979711,\"OZ13ZSIN\",30112],[322118,\"EY70T3I1\",30197],[696824,\"ZWJJHOU3\",30263],[239811,\"WGOD5SD4\",30361],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"475J29EI\",\"HG98HCFL\"],[963752,\"1XW6HVBY\",30399],[764562,\"OZ13ZSIN\",30480],[165422,\"XQ8MRL86\",30559],[282372,\"2MKY7B5Q\",30609],[554716,\"HG98HCFL\",30700],[925378,\"HG98HCFL\",30705],[836854,\"UB4KML0J\",30802],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[328085,\"PYU6IFCW\",30865],[999272,\"NTNXSB47\",30884],[510551,\"HG98HCFL\",30903],[87834,\"HG98HCFL\",30918],[590013,\"HG98HCFL\",30950],[775394,\"MPBZFLN9\",30963],[701078,\"OZ13ZSIN\",31024],[561608,\"WIXJ6Z00\",31082],[\"OZ13ZSIN\",\"HG98HCFL\"],[328085,\"FU1D57HA\",31132],[165422,\"HG98HCFL\",31226],[997488,\"HG98HCFL\",31249],[785370,\"FY86VG9O\",31334],[186553,\"6GPMXUYZ\",31378],[282372,\"FU1D57HA\",31454],[88784,\"WMTPA7JN\",31484],[186637,\"973PO4KY\",31528],[62740,\"HG98HCFL\",31561],[206116,\"CWWVVCGZ\",31653],[525469,\"OZ13ZSIN\",31705],[\"OZ13ZSIN\",\"CWWVVCGZ\"],[109318,\"OZ13ZSIN\",31719],[954915,\"WS49LJP8\",31776],[\"OZ13ZSIN\",\"FU1D57HA\"],[166180,\"FU1D57HA\",31824],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"MY3O8OQI\",\"FU1D57HA\"],[539280,\"YZ8LNY1V\",31843],[\"OZ13ZSIN\",\"UB4KML0J\"],[901923,\"OZ13ZSIN\",31865],[963752,\"VMT100K8\",31918],[239811,\"HG98HCFL\",31990]]` wtf is this testcase bro \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "i feel stupid that i opened ur comment. LoL ! it took forever to scroll down"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "resolved ? me also getting error in this test case"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The May badge was not an easy one! Guys let\\'s get this done!!!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Yay!"
                    },
                    {
                        "username": "omeraktepe",
                        "content": "There is a test case that does not meet assumptions. \nTest case 56: [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]] \n\nIt violetes followings: \n1. A customer can only be checked into one place at a time. \n2. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order. \n\nI am too lazy to report though :)"
                    },
                    {
                        "username": "zavojchevski",
                        "content": "I agree on this, restrictions should be well explained. "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "For those failing test case 51:\\n\"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\"\\nCredit to xuawai for noticing this back in 2020."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Restrictions should be written stricter. Some strange cases which are valid:\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@psionl0](/psionl0) \\'getAverageTime\\' arguments are invalid: "
                    },
                    {
                        "username": "psionl0",
                        "content": "All your test cases work on my code but it fails on Leet testcase 49. I also tried\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"],[\"A\",\"C\"]]\n``` \nbut that seems to be an invalid test case."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[@anwendeng](/anwendeng) My code works too, but it\\'s strange."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I have tested all of your test cases and my program passed!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using  2 tables  to store the info.\nUse hash tables for check-in and travel time info! \nThe programming is easier than a standard design for Hash set!\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Thanks for spoiling the answer for people in reallllllly big font so they don\\'t accidently try to come up with the answer themselves! Real nice of you."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "but bro trust me designing a hash set is highly asked interview problem ...\\nI recalled my concept of how we can store data in hashset..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "## **Don't raise your font at us!**"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/design-underground-system/solutions/3580430/easy-c-python-solutions-with-unordered-map-dict/"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Now people here in discuss section only comment to boost up there reputation."
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "This is an issue here and with almost all of these problems. Using vague or ambiguous names for parameters would never be allowed in enterprise software development. \\'id\\' ? id of what? Argument with name \\'t\\' is it time, train, turn? the code should be explanatory even without the description. Its also a prevalent issue in the editorials and provided solutions. \\n\\nThis is also an accessibility and inclusivity issue. When working on teams where not everyone speaks or has native proficiency in the same language using abbreviations or short hand becomes a huge problem. Leetcode should try and make it\\'s examples as near to what would be expected in a real workplace not a college math class."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me feel bad for jumping over the gates every time I lost my ticket on the way.\nSorry for creating stupid edge cases to handle for some devs somewhere"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Today is a special day for me as I will be getting my first badge of leetcode.\nThrough this one month of solving questions daily, the one thing that I have learnt is nothing matters- not even motivation if you don't have the habit of being consistent throughout the journey. \nI am looking forward to be more consistent.\nHappy coding fellow leetcoders!!!"
                    }
                ]
            },
            {
                "id": 1912232,
                "content": [
                    {
                        "username": "jax_ay",
                        "content": "`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\"] [[],[117077,\"OZ13ZSIN\",42],[117077,\"FU1D57HA\",125],[704903,\"OZ13ZSIN\",211],[911239,\"OZ13ZSIN\",245],[704903,\"HG98HCFL\",340],[859828,\"OZ13ZSIN\",355],[\"OZ13ZSIN\",\"FU1D57HA\"],[911239,\"FU1D57HA\",383],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[859828,\"FU1D57HA\",402],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[363027,\"OZ13ZSIN\",489],[319826,\"OZ13ZSIN\",550],[\"OZ13ZSIN\",\"FU1D57HA\"],[363027,\"HG98HCFL\",565],[319826,\"FU1D57HA\",664],[120084,\"OZ13ZSIN\",735],[\"OZ13ZSIN\",\"HG98HCFL\"],[120084,\"HG98HCFL\",832],[56672,\"OZ13ZSIN\",876],[56672,\"HG98HCFL\",912],[638995,\"OZ13ZSIN\",925],[\"OZ13ZSIN\",\"FU1D57HA\"],[638995,\"FU1D57HA\",951],[712949,\"OZ13ZSIN\",1023],[712949,\"FU1D57HA\",1033],[278482,\"T25R11PB\",1080],[\"OZ13ZSIN\",\"FU1D57HA\"],[278482,\"FU1D57HA\",1160],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[342818,\"4SBAAFIP\",1250],[342818,\"HG98HCFL\",1263],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[415673,\"OZ13ZSIN\",1270],[415673,\"NTNXSB47\",1366],[\"T25R11PB\",\"FU1D57HA\"],[597115,\"4SBAAFIP\",1385],[463555,\"OZ13ZSIN\",1461],[463555,\"HG98HCFL\",1514],[801778,\"OZ13ZSIN\",1537],[201428,\"OZ13ZSIN\",1620],[245538,\"OZ13ZSIN\",1630],[597115,\"FU1D57HA\",1657],[583112,\"OZ13ZSIN\",1690],[\"4SBAAFIP\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[691834,\"OZ13ZSIN\",1723],[250537,\"OZ13ZSIN\",1753],[201428,\"H4UTDCR8\",1804],[691834,\"FU1D57HA\",1838],[\"T25R11PB\",\"FU1D57HA\"],[245538,\"FU1D57HA\",1924],[346824,\"OZ13ZSIN\",1952],[864512,\"OZ13ZSIN\",2005],[499705,\"OZ13ZSIN\",2048],[482469,\"GQINA28A\",2058],[\"OZ13ZSIN\",\"FU1D57HA\"],[583112,\"E35YW0BM\",2080],[\"OZ13ZSIN\",\"HG98HCFL\"],[801778,\"HG98HCFL\",2082],[250415,\"I0Y75MZQ\",2149],[795633,\"OZ13ZSIN\",2196],[\"OZ13ZSIN\",\"HG98HCFL\"],[99144,\"4SBAAFIP\",2219],[83594,\"OZ13ZSIN\",2249],[346824,\"HG98HCFL\",2290],[482469,\"HG98HCFL\",2368],[499705,\"FU1D57HA\",2437],[12539,\"OZ13ZSIN\",2442],[116546,\"OZ13ZSIN\",2493],[884032,\"4SBAAFIP\",2579],[801142,\"OZ13ZSIN\",2598],[795633,\"HG98HCFL\",2693],[83594,\"HG98HCFL\",2782],[529306,\"OZ13ZSIN\",2824],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[286490,\"OZ13ZSIN\",2844],[255488,\"OZ13ZSIN\",2935],[608514,\"OZ13ZSIN\",2984],[116546,\"HG98HCFL\",3079],[250415,\"FU1D57HA\",3174],[\"OZ13ZSIN\",\"FU1D57HA\"],[884032,\"E35YW0BM\",3267],[\"OZ13ZSIN\",\"FU1D57HA\"],[529306,\"HG98HCFL\",3299],[\"OZ13ZSIN\",\"FU1D57HA\"],[892550,\"OZ13ZSIN\",3388],[892550,\"2VVKO5AZ\",3394],[14673,\"OZ13ZSIN\",3487],[\"OZ13ZSIN\",\"HG98HCFL\"],[12539,\"HG98HCFL\",3576],[\"OZ13ZSIN\",\"HG98HCFL\"],[255488,\"HG98HCFL\",3674],[\"OZ13ZSIN\",\"HG98HCFL\"],[14673,\"HG98HCFL\",3754],[864512,\"FU1D57HA\",3819],[451611,\"OZ13ZSIN\",3899],[\"4SBAAFIP\",\"E35YW0BM\"],[451611,\"HG98HCFL\",3941],[250537,\"HG98HCFL\",4027],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[286490,\"FU1D57HA\",4046],[608514,\"HG98HCFL\",4094],[827431,\"XWO403P7\",4107],[99144,\"HG98HCFL\",4136],[\"GQINA28A\",\"HG98HCFL\"],[657832,\"OZ13ZSIN\",4150],[827431,\"HG98HCFL\",4214],[\"OZ13ZSIN\",\"FU1D57HA\"],[658842,\"OZ13ZSIN\",4236],[52933,\"4SBAAFIP\",4325],[801142,\"HG98HCFL\",4413],[52933,\"E35YW0BM\",4460],[331712,\"OZ13ZSIN\",4522],[658842,\"NTNXSB47\",4615],[293734,\"OZ13ZSIN\",4665],[293734,\"HG98HCFL\",4735],[917903,\"OZ13ZSIN\",4772],[119860,\"OZ13ZSIN\",4775],[\"OZ13ZSIN\",\"HG98HCFL\"],[657832,\"E35YW0BM\",4850],[415861,\"NJB0V6ZO\",4881],[\"OZ13ZSIN\",\"FU1D57HA\"],[917903,\"HG98HCFL\",4892],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[415861,\"HG98HCFL\",4919],[\"OZ13ZSIN\",\"HG98HCFL\"],[331712,\"OGVA50NO\",4979],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[119860,\"HG98HCFL\",5034],[469875,\"OZ13ZSIN\",5053],[407362,\"XT14GVGK\",5073],[469875,\"HG98HCFL\",5126],[407362,\"HG98HCFL\",5175],[324747,\"OZ13ZSIN\",5236],[315560,\"OZ13ZSIN\",5333],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[317815,\"OZ13ZSIN\",5339],[906872,\"OZ13ZSIN\",5349],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[404251,\"OZ13ZSIN\",5375],[324747,\"HG98HCFL\",5474],[882572,\"OZ13ZSIN\",5524],[\"OZ13ZSIN\",\"HG98HCFL\"],[758501,\"OZ13ZSIN\",5561],[404251,\"FU1D57HA\",5617],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[315560,\"HG98HCFL\",5651],[758501,\"HG98HCFL\",5673],[141090,\"OZ13ZSIN\",5768],[882572,\"FU1D57HA\",5827],[906872,\"HG98HCFL\",5872],[141090,\"HG98HCFL\",5940],[\"OZ13ZSIN\",\"FU1D57HA\"],[317815,\"HG98HCFL\",5996],[436252,\"OZ13ZSIN\",6027],[\"OZ13ZSIN\",\"E35YW0BM\"],[436252,\"HG98HCFL\",6084],[\"OZ13ZSIN\",\"NTNXSB47\"],[652912,\"NJB0V6ZO\",6155],[652912,\"HG98HCFL\",6169],[269825,\"NJB0V6ZO\",6173],[831024,\"OZ13ZSIN\",6267],[831024,\"FU1D57HA\",6317],[269825,\"FU1D57HA\",6318],[794093,\"OZ13ZSIN\",6406],[\"OZ13ZSIN\",\"HG98HCFL\"],[794093,\"FU1D57HA\",6429],[798558,\"OZ13ZSIN\",6497],[798558,\"E35YW0BM\",6500],[271136,\"NJB0V6ZO\",6582],[\"OZ13ZSIN\",\"HG98HCFL\"],[608446,\"OZ13ZSIN\",6662],[608446,\"FU1D57HA\",6760],[986152,\"OZ13ZSIN\",6799],[986152,\"NTNXSB47\",6825],[271136,\"HG98HCFL\",6911],[\"OZ13ZSIN\",\"FU1D57HA\"],[341349,\"OZ13ZSIN\",6995],[595955,\"OZ13ZSIN\",7039],[58242,\"H9OKZANW\",7071],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[134319,\"OZ13ZSIN\",7119],[595955,\"FU1D57HA\",7161],[\"OZ13ZSIN\",\"HG98HCFL\"],[266781,\"OZ13ZSIN\",7208],[\"OZ13ZSIN\",\"FU1D57HA\"],[266781,\"FU1D57HA\",7298],[\"OZ13ZSIN\",\"NTNXSB47\"],[935757,\"OZ13ZSIN\",7300],[517277,\"OZ13ZSIN\",7376],[58242,\"HG98HCFL\",7459],[\"OZ13ZSIN\",\"HG98HCFL\"],[288203,\"OZ13ZSIN\",7512],[293244,\"T25R11PB\",7580],[517277,\"HG98HCFL\",7588],[293244,\"FU1D57HA\",7649],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[480741,\"OZ13ZSIN\",7748],[288203,\"CWJHORPF\",7845],[935757,\"NTNXSB47\",7940],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[341349,\"HG98HCFL\",7952],[870607,\"ST6XEPDA\",7986],[\"OZ13ZSIN\",\"CWJHORPF\"],[468450,\"6QKM8CM8\",8063],[262669,\"OZ13ZSIN\",8152],[\"OZ13ZSIN\",\"FU1D57HA\"],[103929,\"OZ13ZSIN\",8167],[415331,\"X8W3R0P7\",8215],[134319,\"E35YW0BM\",8226],[415331,\"FU1D57HA\",8240],[468450,\"HG98HCFL\",8263],[394949,\"XOK1HH1Y\",8313],[\"OZ13ZSIN\",\"HG98HCFL\"],[394949,\"FU1D57HA\",8402],[67177,\"GQINA28A\",8451],[67177,\"HG98HCFL\",8521],[796191,\"QJHWOKDQ\",8545],[\"I0Y75MZQ\",\"FU1D57HA\"],[\"H9OKZANW\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[940010,\"OZ13ZSIN\",8583],[940010,\"VL50N6D1\",8613],[21260,\"WGOD5SD4\",8683],[746866,\"NJB0V6ZO\",8732],[47896,\"OZ13ZSIN\",8802],[480741,\"CWJHORPF\",8839],[\"NJB0V6ZO\",\"HG98HCFL\"],[310852,\"XT82S77E\",8858],[796001,\"OZ13ZSIN\",8860],[\"OZ13ZSIN\",\"NTNXSB47\"],[103929,\"FU1D57HA\",8957],[739455,\"OZ13ZSIN\",8980],[\"XWO403P7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"VL50N6D1\"],[734337,\"OZ13ZSIN\",8989],[686615,\"4SBAAFIP\",9086],[21260,\"HG98HCFL\",9130],[\"OZ13ZSIN\",\"CWJHORPF\"],[217165,\"1XW6HVBY\",9228],[689774,\"OZ13ZSIN\",9313],[870607,\"NTNXSB47\",9319],[248471,\"OZ13ZSIN\",9376],[262669,\"E35YW0BM\",9427],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[20582,\"OZ13ZSIN\",9484],[310852,\"LBYS94AD\",9535],[746866,\"FU1D57HA\",9540],[689774,\"FU1D57HA\",9594],[796191,\"HG98HCFL\",9635],[\"OZ13ZSIN\",\"FU1D57HA\"],[734337,\"HG98HCFL\",9683],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[982523,\"XWO403P7\",9689],[\"OZ13ZSIN\",\"OGVA50NO\"],[982523,\"HG98HCFL\",9786],[796001,\"FU1D57HA\",9869],[248471,\"FU1D57HA\",9942],[187843,\"OZ13ZSIN\",10035],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"H9OKZANW\",\"HG98HCFL\"],[217165,\"HG98HCFL\",10100],[739455,\"HG98HCFL\",10171],[187843,\"HG98HCFL\",10226],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[20582,\"E35YW0BM\",10322],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"SAIV20VG\",10342],[\"OZ13ZSIN\",\"FU1D57HA\"],[686615,\"HG98HCFL\",10396],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"CAWYGMWL\",10402],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[800300,\"OZ13ZSIN\",10472],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"NTNXSB47\",10485],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[800300,\"HG98HCFL\",10545],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"FU1D57HA\",10581],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[47896,\"NTNXSB47\",10588],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[788823,\"83OEBTCQ\",10599],[\"CAWYGMWL\",\"NTNXSB47\"],[365416,\"OZ13ZSIN\",10690],[610273,\"OZ13ZSIN\",10757],[988219,\"FWUZEALC\",10767],[\"XT14GVGK\",\"HG98HCFL\"],[910256,\"OZ13ZSIN\",10797],[\"OZ13ZSIN\",\"CWJHORPF\"],[610273,\"FU1D57HA\",10848],[\"OZ13ZSIN\",\"FU1D57HA\"],[910256,\"HMJCZQ0K\",10920],[\"OZ13ZSIN\",\"NTNXSB47\"],[988219,\"HG98HCFL\",10930],[365416,\"HG98HCFL\",10972],[219722,\"OZ13ZSIN\",11033],[295336,\"ITA0GE26\",11107],[219722,\"R62MQ4FI\",11131],[295336,\"FU1D57HA\",11140],[788823,\"0BIIAVNU\",11199],[620927,\"T25R11PB\",11274],[620927,\"FU1D57HA\",11371],[630168,\"OZ13ZSIN\",11448],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[112534,\"OZ13ZSIN\",11449],[573142,\"OZ13ZSIN\",11546],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[454282,\"NJB0V6ZO\",11576],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[454282,\"HG98HCFL\",11643],[444090,\"6QKM8CM8\",11698],[630168,\"Y43BFD6U\",11717],[185093,\"1XW6HVBY\",11723],[217806,\"4SBAAFIP\",11814],[\"XOK1HH1Y\",\"FU1D57HA\"],[573142,\"FU1D57HA\",11874],[661431,\"UT8S3IM6\",11907],[335406,\"OZ13ZSIN\",11942],[\"T25R11PB\",\"FU1D57HA\"],[444090,\"HG98HCFL\",11995],[896969,\"QJHWOKDQ\",12032],[950584,\"NJB0V6ZO\",12097],[570450,\"NJB0V6ZO\",12128],[896969,\"HG98HCFL\",12146],[71637,\"4SBAAFIP\",12202],[923844,\"OZ13ZSIN\",12277],[\"NJB0V6ZO\",\"HG98HCFL\"],[374491,\"OZ13ZSIN\",12300],[333698,\"1XW6HVBY\",12343],[323202,\"4SBAAFIP\",12369],[489161,\"OZ13ZSIN\",12419],[489161,\"BMN7MUED\",12446],[177905,\"XOK1HH1Y\",12483],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[185093,\"FU1D57HA\",12520],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"OZ13ZSIN\",12538],[765285,\"OZ13ZSIN\",12554],[\"OZ13ZSIN\",\"VL50N6D1\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[80760,\"XOK1HH1Y\",12613],[570450,\"R47UH9EC\",12643],[777227,\"OZ13ZSIN\",12717],[30391,\"XQ8MRL86\",12743],[923844,\"NTNXSB47\",12843],[\"OZ13ZSIN\",\"HG98HCFL\"],[177905,\"HG98HCFL\",12901],[374491,\"2Z3A0H6F\",12957],[950584,\"7IO8ET8F\",13035],[\"1XW6HVBY\",\"HG98HCFL\"],[636717,\"WY85FIVE\",13122],[661431,\"L6KOAIR1\",13154],[80760,\"XIUOFK2Y\",13215],[\"OZ13ZSIN\",\"HG98HCFL\"],[428110,\"4SBAAFIP\",13262],[\"H9OKZANW\",\"HG98HCFL\"],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"83OEBTCQ\",\"0BIIAVNU\"],[502345,\"1MOLNL46\",13324],[112534,\"HG98HCFL\",13393],[\"OZ13ZSIN\",\"HG98HCFL\"],[25332,\"OZ13ZSIN\",13487],[240072,\"OZ13ZSIN\",13504],[649981,\"ITA0GE26\",13603],[363027,\"NJB0V6ZO\",13627],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"FU1D57HA\",13724],[961598,\"ST6XEPDA\",13810],[75634,\"ZWJJHOU3\",13877],[807547,\"OZ13ZSIN\",13900],[\"OZ13ZSIN\",\"FU1D57HA\"],[71637,\"HG98HCFL\",13998],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[300645,\"OZ13ZSIN\",14033],[849654,\"OZ13ZSIN\",14128],[701073,\"GQINA28A\",14209],[288997,\"WGOD5SD4\",14252],[7101,\"OZ13ZSIN\",14258],[143698,\"SH04ZH5G\",14355],[849654,\"HG98HCFL\",14395],[300645,\"RBRIS3JS\",14484],[171052,\"OZ13ZSIN\",14576],[214567,\"NJB0V6ZO\",14592],[961598,\"JYTPXJK9\",14646],[132966,\"4SR0921V\",14665],[822925,\"4SBAAFIP\",14742],[333698,\"HG98HCFL\",14835],[\"OZ13ZSIN\",\"HG98HCFL\"],[822925,\"E35YW0BM\",14920],[777227,\"HG98HCFL\",15017],[123308,\"OZ13ZSIN\",15095],[598091,\"6QKM8CM8\",15150],[363027,\"HG98HCFL\",15160],[912565,\"OZ13ZSIN\",15202],[93990,\"1XW6HVBY\",15291],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[25332,\"FU1D57HA\",15332],[143698,\"HG98HCFL\",15380],[502345,\"DYLQ657K\",15429],[171052,\"HG98HCFL\",15436],[\"1XW6HVBY\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[217806,\"FU1D57HA\",15469],[487305,\"5D5SUJ4Q\",15499],[44397,\"6QKM8CM8\",15536],[601607,\"XOK1HH1Y\",15566],[30391,\"HG98HCFL\",15586],[\"OZ13ZSIN\",\"OGVA50NO\"],[765285,\"IX7LS60B\",15641],[788097,\"T25R11PB\",15730],[300198,\"6TED6G4E\",15774],[529964,\"OZ13ZSIN\",15793],[803049,\"IEQICIHL\",15826],[\"OZ13ZSIN\",\"HG98HCFL\"],[7101,\"DKN9PRYJ\",15869],[\"T25R11PB\",\"FU1D57HA\"],[761575,\"D5TNGKU7\",15885],[93990,\"HG98HCFL\",15894],[323202,\"HG98HCFL\",15898],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"OZ13ZSIN\",15990],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"OGVA50NO\"],[213297,\"OZ13ZSIN\",16034],[300198,\"HG98HCFL\",16105],[912565,\"HG98HCFL\",16175],[806824,\"NJB0V6ZO\",16274],[417297,\"OZ13ZSIN\",16334],[\"XQ8MRL86\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[690271,\"GQINA28A\",16427],[540402,\"OZ13ZSIN\",16500],[807547,\"FU1D57HA\",16504],[335406,\"HG98HCFL\",16539],[417297,\"HG98HCFL\",16618],[192719,\"QB05LSRK\",16711],[255839,\"OZ13ZSIN\",16755],[\"OZ13ZSIN\",\"BMN7MUED\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[711297,\"OZ13ZSIN\",16810],[\"OZ13ZSIN\",\"CWJHORPF\"],[711297,\"HG98HCFL\",16899],[211279,\"VL2TL1NM\",16907],[\"XT14GVGK\",\"HG98HCFL\"],[\"XWO403P7\",\"HG98HCFL\"],[213297,\"FU1D57HA\",16964],[44397,\"7JHO6FK0\",17021],[\"4SBAAFIP\",\"HG98HCFL\"],[75634,\"H4UTDCR8\",17075],[996616,\"JYLXUII8\",17167],[775204,\"ZZLR3YVJ\",17215],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[211106,\"6TED6G4E\",17217],[649981,\"HG98HCFL\",17236],[775204,\"HG98HCFL\",17246],[806824,\"HG98HCFL\",17313],[214567,\"GWJB6BU5\",17411],[487305,\"FU1D57HA\",17496],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[237574,\"GA4KQD8H\",17572],[863199,\"OZ13ZSIN\",17616],[921800,\"OZ13ZSIN\",17693],[415592,\"NJB0V6ZO\",17784],[788097,\"FU1D57HA\",17844],[79918,\"ZR7QN32O\",17930],[240072,\"HG98HCFL\",17938],[\"OZ13ZSIN\",\"HG98HCFL\"],[253649,\"OZ13ZSIN\",17981],[545511,\"OZ13ZSIN\",18005],[237574,\"FU1D57HA\",18089],[\"OZ13ZSIN\",\"NTNXSB47\"],[255839,\"HG98HCFL\",18169],[701073,\"HJXEGP9U\",18269],[598091,\"FU1D57HA\",18287],[\"OZ13ZSIN\",\"HG98HCFL\"],[540402,\"HG98HCFL\",18349],[887853,\"GA4KQD8H\",18417],[\"XT82S77E\",\"LBYS94AD\"],[863199,\"HG98HCFL\",18484],[\"OZ13ZSIN\",\"HG98HCFL\"],[127768,\"OZ13ZSIN\",18571],[872173,\"OZ13ZSIN\",18579],[\"OZ13ZSIN\",\"HG98HCFL\"],[872173,\"UB4KML0J\",18638],[428110,\"HG98HCFL\",18720],[\"ITA0GE26\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[85526,\"OZ13ZSIN\",18803],[123308,\"HG98HCFL\",18872],[273723,\"FJVIO218\",18884],[\"OZ13ZSIN\",\"FU1D57HA\"],[716950,\"OZ13ZSIN\",18916],[436026,\"OZ13ZSIN\",18922],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[127768,\"FU1D57HA\",18931],[646079,\"IMDG88XX\",18944],[784931,\"OZ13ZSIN\",19001],[\"OZ13ZSIN\",\"OGVA50NO\"],[\"OZ13ZSIN\",\"H4UTDCR8\"],[803049,\"RPKD08C6\",19041],[627595,\"MBY9ZG7D\",19129],[386653,\"BMX2AIY5\",19179],[\"OZ13ZSIN\",\"CWJHORPF\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[211106,\"HG98HCFL\",19251],[855448,\"OZ13ZSIN\",19300],[733785,\"SPVKZTIP\",19344],[\"XOK1HH1Y\",\"HG98HCFL\"],[761575,\"HG98HCFL\",19444],[\"OZ13ZSIN\",\"HG98HCFL\"],[132966,\"H4UTDCR8\",19503],[948005,\"OZ13ZSIN\",19520],[14408,\"OZ13ZSIN\",19594],[\"I0Y75MZQ\",\"FU1D57HA\"],[85526,\"NTNXSB47\",19687],[211403,\"OZ13ZSIN\",19761],[677411,\"OZ13ZSIN\",19852],[192719,\"HG98HCFL\",19905],[887853,\"HG98HCFL\",19975],[455474,\"OZ13ZSIN\",20002],[601607,\"FU1D57HA\",20077],[14408,\"HG98HCFL\",20150],[\"OZ13ZSIN\",\"DKN9PRYJ\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[253649,\"1QLZUAXZ\",20166],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[548975,\"OZ13ZSIN\",20232],[386653,\"1QLZUAXZ\",20277],[415592,\"HG98HCFL\",20318],[716950,\"3ZJ18VKA\",20384],[84268,\"OZ13ZSIN\",20392],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[55374,\"4SBAAFIP\",20416],[851948,\"OZ13ZSIN\",20503],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"OZ13ZSIN\",20513],[615192,\"OZ13ZSIN\",20551],[851948,\"HG98HCFL\",20631],[211403,\"HG98HCFL\",20668],[677411,\"OGVA50NO\",20715],[55374,\"FU1D57HA\",20749],[457056,\"OZ13ZSIN\",20799],[\"XOK1HH1Y\",\"FU1D57HA\"],[548975,\"HG98HCFL\",20836],[41381,\"MY3O8OQI\",20908],[950414,\"OZ13ZSIN\",20971],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[873337,\"OZ13ZSIN\",21038],[\"5D5SUJ4Q\",\"FU1D57HA\"],[273723,\"FU1D57HA\",21053],[726970,\"OZ13ZSIN\",21070],[\"OZ13ZSIN\",\"HG98HCFL\"],[211279,\"HG98HCFL\",21127],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[276902,\"4T1TBZX5\",21160],[\"OZ13ZSIN\",\"HG98HCFL\"],[183959,\"OZ13ZSIN\",21209],[488167,\"OZ13ZSIN\",21250],[\"OZ13ZSIN\",\"HG98HCFL\"],[166180,\"OZ13ZSIN\",21323],[\"FJVIO218\",\"FU1D57HA\"],[636717,\"UB4KML0J\",21366],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"DLUQBV4V\",21413],[\"OZ13ZSIN\",\"FU1D57HA\"],[528132,\"LUCPET9G\",21476],[206116,\"0MOLP3NC\",21551],[183959,\"XPM6JMBR\",21562],[\"OZ13ZSIN\",\"HG98HCFL\"],[553646,\"BMX2AIY5\",21661],[\"OZ13ZSIN\",\"DLUQBV4V\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"SH04ZH5G\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"R62MQ4FI\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[724508,\"C00L36RI\",21665],[950414,\"FU1D57HA\",21721],[102566,\"NJB0V6ZO\",21819],[690271,\"HG98HCFL\",21829],[\"OZ13ZSIN\",\"HG98HCFL\"],[386570,\"OZ13ZSIN\",21870],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[733785,\"FU1D57HA\",21931],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"ZWJJHOU3\",\"H4UTDCR8\"],[493080,\"OZ13ZSIN\",21957],[\"OZ13ZSIN\",\"RBRIS3JS\"],[476818,\"NJB0V6ZO\",22018],[\"OZ13ZSIN\",\"HG98HCFL\"],[646079,\"VMT100K8\",22076],[873337,\"E35YW0BM\",22080],[529964,\"FU1D57HA\",22162],[41381,\"FU1D57HA\",22233],[\"1XW6HVBY\",\"HG98HCFL\"],[\"IMDG88XX\",\"VMT100K8\"],[724508,\"JYTPXJK9\",22301],[\"OZ13ZSIN\",\"FU1D57HA\"],[276768,\"OZ13ZSIN\",22339],[654375,\"1XW6HVBY\",22349],[276768,\"X1H2W3W0\",22438],[\"OZ13ZSIN\",\"UB4KML0J\"],[855448,\"KSOIJA62\",22533],[493080,\"FU1D57HA\",22554],[726970,\"E35YW0BM\",22603],[\"4SR0921V\",\"H4UTDCR8\"],[79918,\"R62MQ4FI\",22640],[659224,\"OZ13ZSIN\",22739],[436026,\"L6KOAIR1\",22770],[288997,\"E35YW0BM\",22850],[\"SAIV20VG\",\"FU1D57HA\"],[553646,\"FU1D57HA\",22946],[659224,\"NTNXSB47\",22957],[615192,\"HG98HCFL\",23056],[\"OZ13ZSIN\",\"E35YW0BM\"],[730441,\"1XW6HVBY\",23129],[55790,\"OZ13ZSIN\",23179],[524967,\"OZ13ZSIN\",23189],[44097,\"2GRLB4CN\",23280],[784931,\"E35YW0BM\",23343],[525825,\"OZ13ZSIN\",23384],[315479,\"XQ8MRL86\",23386],[537074,\"OZ13ZSIN\",23437],[\"XT82S77E\",\"LBYS94AD\"],[524967,\"7JIXF9D1\",23496],[559244,\"OZ13ZSIN\",23569],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[872522,\"FJVIO218\",23579],[160528,\"DE386QWN\",23602],[\"4SBAAFIP\",\"HG98HCFL\"],[832697,\"OZ13ZSIN\",23696],[439436,\"NJB0V6ZO\",23749],[559244,\"MJZC0DI0\",23811],[38958,\"4SBAAFIP\",23863],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[327722,\"OZ13ZSIN\",23901],[243726,\"OZ13ZSIN\",23955],[38958,\"WUIGDE36\",24007],[832697,\"4IBLBVYU\",24058],[626392,\"QK3YTSXO\",24064],[640646,\"OZ13ZSIN\",24084],[476818,\"R5XHXCAN\",24129],[13070,\"NJB0V6ZO\",24190],[\"VL2TL1NM\",\"HG98HCFL\"],[633159,\"GQYWQW84\",24235],[528132,\"MPBZFLN9\",24236],[668517,\"OZ13ZSIN\",24307],[627595,\"HG98HCFL\",24343],[\"OZ13ZSIN\",\"HG98HCFL\"],[438428,\"PQOMFBOJ\",24350],[386570,\"FU1D57HA\",24413],[668517,\"7JHO6FK0\",24482],[561608,\"2IVTIGII\",24575],[539280,\"ITA0GE26\",24660],[160528,\"7IO8ET8F\",24668],[\"T25R11PB\",\"FU1D57HA\"],[626392,\"FU1D57HA\",24755],[\"4SBAAFIP\",\"WUIGDE36\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[251034,\"4SBAAFIP\",24786],[968259,\"OZ13ZSIN\",24870],[640646,\"I9H1UDG4\",24892],[361979,\"OZ13ZSIN\",24945],[806004,\"WPM57THK\",25006],[488167,\"VL50N6D1\",25009],[\"XT82S77E\",\"LBYS94AD\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[\"XQ8MRL86\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HMJCZQ0K\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[787728,\"OZ13ZSIN\",25084],[95528,\"OZ13ZSIN\",25154],[825321,\"4SBAAFIP\",25200],[\"OZ13ZSIN\",\"HG98HCFL\"],[968259,\"HG98HCFL\",25234],[\"NJB0V6ZO\",\"HG98HCFL\"],[537074,\"2Z3A0H6F\",25283],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"1QLZUAXZ\"],[430837,\"ZOA7MKHB\",25342],[588541,\"OZ13ZSIN\",25380],[\"OZ13ZSIN\",\"HG98HCFL\"],[276902,\"FU1D57HA\",25448],[787728,\"BMN7MUED\",25495],[590184,\"KFRF7AEZ\",25577],[\"LUCPET9G\",\"MPBZFLN9\"],[510551,\"OZ13ZSIN\",25597],[806004,\"HG98HCFL\",25608],[925378,\"T25R11PB\",25614],[27187,\"NJB0V6ZO\",25651],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"DE386QWN\",25682],[525825,\"IX7LS60B\",25695],[876351,\"1XW6HVBY\",25761],[225487,\"SPVKZTIP\",25783],[159468,\"OZ13ZSIN\",25784],[785370,\"BMX2AIY5\",25819],[159468,\"FU1D57HA\",25847],[822091,\"1XW6HVBY\",25911],[142228,\"OZ13ZSIN\",25962],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"HG98HCFL\",25997],[6026,\"WPM57THK\",26000],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"J1X7TLQD\",26041],[42555,\"D5TNGKU7\",26042],[921331,\"XOK1HH1Y\",26066],[95528,\"GWVJKDKT\",26130],[361979,\"CWWVVCGZ\",26183],[747281,\"OZ13ZSIN\",26197],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"NJB0V6ZO\",\"7IO8ET8F\"],[590184,\"FY86VG9O\",26248],[443593,\"6TED6G4E\",26254],[921331,\"IVDGXU4R\",26354],[184691,\"XOK1HH1Y\",26394],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"D5TNGKU7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[997488,\"OZ13ZSIN\",26468],[161852,\"OZ13ZSIN\",26476],[42555,\"HG98HCFL\",26505],[948005,\"88RO58CG\",26517],[499506,\"ITA0GE26\",26545],[\"OZ13ZSIN\",\"FU1D57HA\"],[654375,\"FU1D57HA\",26593],[999272,\"OZ13ZSIN\",26641],[\"OZ13ZSIN\",\"FU1D57HA\"],[788492,\"OZ13ZSIN\",26738],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"4SBAAFIP\",\"E35YW0BM\"],[327722,\"HG98HCFL\",26780],[499506,\"GWVJKDKT\",26878],[825321,\"HG98HCFL\",26973],[\"CAWYGMWL\",\"NTNXSB47\"],[606855,\"C00L36RI\",26996],[498054,\"OZ13ZSIN\",27025],[455474,\"7JHO6FK0\",27070],[911613,\"OZ13ZSIN\",27170],[693354,\"O77WFMCI\",27225],[\"OZ13ZSIN\",\"HG98HCFL\"],[483609,\"G2LO9U87\",27250],[\"D5TNGKU7\",\"HG98HCFL\"],[914704,\"OZ13ZSIN\",27252],[835356,\"OZ13ZSIN\",27277],[\"XOK1HH1Y\",\"HG98HCFL\"],[243726,\"2Z3A0H6F\",27330],[788492,\"HG98HCFL\",27409],[\"FJVIO218\",\"FU1D57HA\"],[730441,\"HG98HCFL\",27465],[418199,\"OZ13ZSIN\",27557],[\"NJB0V6ZO\",\"HG98HCFL\"],[416184,\"X8W3R0P7\",27576],[177447,\"GQINA28A\",27661],[27187,\"Q6L1ZD92\",27684],[53005,\"MY3O8OQI\",27746],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[835356,\"HG98HCFL\",27775],[88784,\"NJB0V6ZO\",27865],[747281,\"HG98HCFL\",27921],[\"OZ13ZSIN\",\"HG98HCFL\"],[184691,\"CWWVVCGZ\",27974],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[554716,\"OZ13ZSIN\",28020],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"FU1D57HA\",28107],[\"ZR7QN32O\",\"R62MQ4FI\"],[326091,\"XOK1HH1Y\",28151],[927316,\"OZ13ZSIN\",28193],[\"T25R11PB\",\"FU1D57HA\"],[499875,\"NJB0V6ZO\",28256],[590013,\"OZ13ZSIN\",28354],[62740,\"OZ13ZSIN\",28413],[876351,\"FU1D57HA\",28469],[749462,\"OZ13ZSIN\",28525],[\"5D5SUJ4Q\",\"FU1D57HA\"],[996616,\"OGVA50NO\",28553],[177447,\"CWWVVCGZ\",28572],[\"OZ13ZSIN\",\"FU1D57HA\"],[438428,\"L6KOAIR1\",28631],[693354,\"DLUQBV4V\",28663],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[880171,\"475J29EI\",28754],[588541,\"1YA7XTV9\",28760],[457056,\"HG98HCFL\",28762],[\"OZ13ZSIN\",\"VL50N6D1\"],[84268,\"HG98HCFL\",28792],[130492,\"IMDG88XX\",28832],[163069,\"FWUZEALC\",28840],[\"C00L36RI\",\"JYTPXJK9\"],[417559,\"BMX2AIY5\",28890],[\"OZ13ZSIN\",\"HG98HCFL\"],[914704,\"FU1D57HA\",28939],[55617,\"VL2TL1NM\",28974],[\"4SBAAFIP\",\"E35YW0BM\"],[911613,\"FU1D57HA\",29069],[880171,\"HG98HCFL\",29099],[\"OZ13ZSIN\",\"FU1D57HA\"],[117275,\"4SBAAFIP\",29174],[822091,\"FU1D57HA\",29206],[775394,\"XQ8MRL86\",29284],[917846,\"4SBAAFIP\",29288],[55790,\"0NYQFXYO\",29343],[\"83OEBTCQ\",\"0BIIAVNU\"],[416184,\"HG98HCFL\",29415],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"FJVIO218\",\"FU1D57HA\"],[228425,\"OZ13ZSIN\",29438],[\"CAWYGMWL\",\"NTNXSB47\"],[87834,\"OZ13ZSIN\",29442],[633159,\"WMTPA7JN\",29482],[322118,\"OZ13ZSIN\",29526],[\"1XW6HVBY\",\"FU1D57HA\"],[675060,\"K9D63ZZC\",29617],[225487,\"RPKD08C6\",29691],[708687,\"OZ13ZSIN\",29761],[836854,\"OZ13ZSIN\",29845],[\"6QKM8CM8\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[299466,\"4SBAAFIP\",29860],[\"WGOD5SD4\",\"E35YW0BM\"],[\"X8W3R0P7\",\"FU1D57HA\"],[927316,\"HG98HCFL\",29938],[483609,\"HG98HCFL\",29995],[\"C00L36RI\",\"JYTPXJK9\"],[\"OZ13ZSIN\",\"L6KOAIR1\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"HG98HCFL\",30054],[870611,\"72Q6VPM1\",30066],[754460,\"4SBAAFIP\",30086],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[979711,\"OZ13ZSIN\",30112],[322118,\"EY70T3I1\",30197],[696824,\"ZWJJHOU3\",30263],[239811,\"WGOD5SD4\",30361],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"475J29EI\",\"HG98HCFL\"],[963752,\"1XW6HVBY\",30399],[764562,\"OZ13ZSIN\",30480],[165422,\"XQ8MRL86\",30559],[282372,\"2MKY7B5Q\",30609],[554716,\"HG98HCFL\",30700],[925378,\"HG98HCFL\",30705],[836854,\"UB4KML0J\",30802],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[328085,\"PYU6IFCW\",30865],[999272,\"NTNXSB47\",30884],[510551,\"HG98HCFL\",30903],[87834,\"HG98HCFL\",30918],[590013,\"HG98HCFL\",30950],[775394,\"MPBZFLN9\",30963],[701078,\"OZ13ZSIN\",31024],[561608,\"WIXJ6Z00\",31082],[\"OZ13ZSIN\",\"HG98HCFL\"],[328085,\"FU1D57HA\",31132],[165422,\"HG98HCFL\",31226],[997488,\"HG98HCFL\",31249],[785370,\"FY86VG9O\",31334],[186553,\"6GPMXUYZ\",31378],[282372,\"FU1D57HA\",31454],[88784,\"WMTPA7JN\",31484],[186637,\"973PO4KY\",31528],[62740,\"HG98HCFL\",31561],[206116,\"CWWVVCGZ\",31653],[525469,\"OZ13ZSIN\",31705],[\"OZ13ZSIN\",\"CWWVVCGZ\"],[109318,\"OZ13ZSIN\",31719],[954915,\"WS49LJP8\",31776],[\"OZ13ZSIN\",\"FU1D57HA\"],[166180,\"FU1D57HA\",31824],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"MY3O8OQI\",\"FU1D57HA\"],[539280,\"YZ8LNY1V\",31843],[\"OZ13ZSIN\",\"UB4KML0J\"],[901923,\"OZ13ZSIN\",31865],[963752,\"VMT100K8\",31918],[239811,\"HG98HCFL\",31990]]` wtf is this testcase bro \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "i feel stupid that i opened ur comment. LoL ! it took forever to scroll down"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "resolved ? me also getting error in this test case"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The May badge was not an easy one! Guys let\\'s get this done!!!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Yay!"
                    },
                    {
                        "username": "omeraktepe",
                        "content": "There is a test case that does not meet assumptions. \nTest case 56: [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]] \n\nIt violetes followings: \n1. A customer can only be checked into one place at a time. \n2. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order. \n\nI am too lazy to report though :)"
                    },
                    {
                        "username": "zavojchevski",
                        "content": "I agree on this, restrictions should be well explained. "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "For those failing test case 51:\\n\"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\"\\nCredit to xuawai for noticing this back in 2020."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Restrictions should be written stricter. Some strange cases which are valid:\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@psionl0](/psionl0) \\'getAverageTime\\' arguments are invalid: "
                    },
                    {
                        "username": "psionl0",
                        "content": "All your test cases work on my code but it fails on Leet testcase 49. I also tried\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"],[\"A\",\"C\"]]\n``` \nbut that seems to be an invalid test case."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[@anwendeng](/anwendeng) My code works too, but it\\'s strange."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I have tested all of your test cases and my program passed!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using  2 tables  to store the info.\nUse hash tables for check-in and travel time info! \nThe programming is easier than a standard design for Hash set!\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Thanks for spoiling the answer for people in reallllllly big font so they don\\'t accidently try to come up with the answer themselves! Real nice of you."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "but bro trust me designing a hash set is highly asked interview problem ...\\nI recalled my concept of how we can store data in hashset..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "## **Don't raise your font at us!**"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/design-underground-system/solutions/3580430/easy-c-python-solutions-with-unordered-map-dict/"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Now people here in discuss section only comment to boost up there reputation."
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "This is an issue here and with almost all of these problems. Using vague or ambiguous names for parameters would never be allowed in enterprise software development. \\'id\\' ? id of what? Argument with name \\'t\\' is it time, train, turn? the code should be explanatory even without the description. Its also a prevalent issue in the editorials and provided solutions. \\n\\nThis is also an accessibility and inclusivity issue. When working on teams where not everyone speaks or has native proficiency in the same language using abbreviations or short hand becomes a huge problem. Leetcode should try and make it\\'s examples as near to what would be expected in a real workplace not a college math class."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me feel bad for jumping over the gates every time I lost my ticket on the way.\nSorry for creating stupid edge cases to handle for some devs somewhere"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Today is a special day for me as I will be getting my first badge of leetcode.\nThrough this one month of solving questions daily, the one thing that I have learnt is nothing matters- not even motivation if you don't have the habit of being consistent throughout the journey. \nI am looking forward to be more consistent.\nHappy coding fellow leetcoders!!!"
                    }
                ]
            },
            {
                "id": 1912150,
                "content": [
                    {
                        "username": "jax_ay",
                        "content": "`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\"] [[],[117077,\"OZ13ZSIN\",42],[117077,\"FU1D57HA\",125],[704903,\"OZ13ZSIN\",211],[911239,\"OZ13ZSIN\",245],[704903,\"HG98HCFL\",340],[859828,\"OZ13ZSIN\",355],[\"OZ13ZSIN\",\"FU1D57HA\"],[911239,\"FU1D57HA\",383],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[859828,\"FU1D57HA\",402],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[363027,\"OZ13ZSIN\",489],[319826,\"OZ13ZSIN\",550],[\"OZ13ZSIN\",\"FU1D57HA\"],[363027,\"HG98HCFL\",565],[319826,\"FU1D57HA\",664],[120084,\"OZ13ZSIN\",735],[\"OZ13ZSIN\",\"HG98HCFL\"],[120084,\"HG98HCFL\",832],[56672,\"OZ13ZSIN\",876],[56672,\"HG98HCFL\",912],[638995,\"OZ13ZSIN\",925],[\"OZ13ZSIN\",\"FU1D57HA\"],[638995,\"FU1D57HA\",951],[712949,\"OZ13ZSIN\",1023],[712949,\"FU1D57HA\",1033],[278482,\"T25R11PB\",1080],[\"OZ13ZSIN\",\"FU1D57HA\"],[278482,\"FU1D57HA\",1160],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[342818,\"4SBAAFIP\",1250],[342818,\"HG98HCFL\",1263],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[415673,\"OZ13ZSIN\",1270],[415673,\"NTNXSB47\",1366],[\"T25R11PB\",\"FU1D57HA\"],[597115,\"4SBAAFIP\",1385],[463555,\"OZ13ZSIN\",1461],[463555,\"HG98HCFL\",1514],[801778,\"OZ13ZSIN\",1537],[201428,\"OZ13ZSIN\",1620],[245538,\"OZ13ZSIN\",1630],[597115,\"FU1D57HA\",1657],[583112,\"OZ13ZSIN\",1690],[\"4SBAAFIP\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[691834,\"OZ13ZSIN\",1723],[250537,\"OZ13ZSIN\",1753],[201428,\"H4UTDCR8\",1804],[691834,\"FU1D57HA\",1838],[\"T25R11PB\",\"FU1D57HA\"],[245538,\"FU1D57HA\",1924],[346824,\"OZ13ZSIN\",1952],[864512,\"OZ13ZSIN\",2005],[499705,\"OZ13ZSIN\",2048],[482469,\"GQINA28A\",2058],[\"OZ13ZSIN\",\"FU1D57HA\"],[583112,\"E35YW0BM\",2080],[\"OZ13ZSIN\",\"HG98HCFL\"],[801778,\"HG98HCFL\",2082],[250415,\"I0Y75MZQ\",2149],[795633,\"OZ13ZSIN\",2196],[\"OZ13ZSIN\",\"HG98HCFL\"],[99144,\"4SBAAFIP\",2219],[83594,\"OZ13ZSIN\",2249],[346824,\"HG98HCFL\",2290],[482469,\"HG98HCFL\",2368],[499705,\"FU1D57HA\",2437],[12539,\"OZ13ZSIN\",2442],[116546,\"OZ13ZSIN\",2493],[884032,\"4SBAAFIP\",2579],[801142,\"OZ13ZSIN\",2598],[795633,\"HG98HCFL\",2693],[83594,\"HG98HCFL\",2782],[529306,\"OZ13ZSIN\",2824],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[286490,\"OZ13ZSIN\",2844],[255488,\"OZ13ZSIN\",2935],[608514,\"OZ13ZSIN\",2984],[116546,\"HG98HCFL\",3079],[250415,\"FU1D57HA\",3174],[\"OZ13ZSIN\",\"FU1D57HA\"],[884032,\"E35YW0BM\",3267],[\"OZ13ZSIN\",\"FU1D57HA\"],[529306,\"HG98HCFL\",3299],[\"OZ13ZSIN\",\"FU1D57HA\"],[892550,\"OZ13ZSIN\",3388],[892550,\"2VVKO5AZ\",3394],[14673,\"OZ13ZSIN\",3487],[\"OZ13ZSIN\",\"HG98HCFL\"],[12539,\"HG98HCFL\",3576],[\"OZ13ZSIN\",\"HG98HCFL\"],[255488,\"HG98HCFL\",3674],[\"OZ13ZSIN\",\"HG98HCFL\"],[14673,\"HG98HCFL\",3754],[864512,\"FU1D57HA\",3819],[451611,\"OZ13ZSIN\",3899],[\"4SBAAFIP\",\"E35YW0BM\"],[451611,\"HG98HCFL\",3941],[250537,\"HG98HCFL\",4027],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[286490,\"FU1D57HA\",4046],[608514,\"HG98HCFL\",4094],[827431,\"XWO403P7\",4107],[99144,\"HG98HCFL\",4136],[\"GQINA28A\",\"HG98HCFL\"],[657832,\"OZ13ZSIN\",4150],[827431,\"HG98HCFL\",4214],[\"OZ13ZSIN\",\"FU1D57HA\"],[658842,\"OZ13ZSIN\",4236],[52933,\"4SBAAFIP\",4325],[801142,\"HG98HCFL\",4413],[52933,\"E35YW0BM\",4460],[331712,\"OZ13ZSIN\",4522],[658842,\"NTNXSB47\",4615],[293734,\"OZ13ZSIN\",4665],[293734,\"HG98HCFL\",4735],[917903,\"OZ13ZSIN\",4772],[119860,\"OZ13ZSIN\",4775],[\"OZ13ZSIN\",\"HG98HCFL\"],[657832,\"E35YW0BM\",4850],[415861,\"NJB0V6ZO\",4881],[\"OZ13ZSIN\",\"FU1D57HA\"],[917903,\"HG98HCFL\",4892],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[415861,\"HG98HCFL\",4919],[\"OZ13ZSIN\",\"HG98HCFL\"],[331712,\"OGVA50NO\",4979],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[119860,\"HG98HCFL\",5034],[469875,\"OZ13ZSIN\",5053],[407362,\"XT14GVGK\",5073],[469875,\"HG98HCFL\",5126],[407362,\"HG98HCFL\",5175],[324747,\"OZ13ZSIN\",5236],[315560,\"OZ13ZSIN\",5333],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[317815,\"OZ13ZSIN\",5339],[906872,\"OZ13ZSIN\",5349],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[404251,\"OZ13ZSIN\",5375],[324747,\"HG98HCFL\",5474],[882572,\"OZ13ZSIN\",5524],[\"OZ13ZSIN\",\"HG98HCFL\"],[758501,\"OZ13ZSIN\",5561],[404251,\"FU1D57HA\",5617],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[315560,\"HG98HCFL\",5651],[758501,\"HG98HCFL\",5673],[141090,\"OZ13ZSIN\",5768],[882572,\"FU1D57HA\",5827],[906872,\"HG98HCFL\",5872],[141090,\"HG98HCFL\",5940],[\"OZ13ZSIN\",\"FU1D57HA\"],[317815,\"HG98HCFL\",5996],[436252,\"OZ13ZSIN\",6027],[\"OZ13ZSIN\",\"E35YW0BM\"],[436252,\"HG98HCFL\",6084],[\"OZ13ZSIN\",\"NTNXSB47\"],[652912,\"NJB0V6ZO\",6155],[652912,\"HG98HCFL\",6169],[269825,\"NJB0V6ZO\",6173],[831024,\"OZ13ZSIN\",6267],[831024,\"FU1D57HA\",6317],[269825,\"FU1D57HA\",6318],[794093,\"OZ13ZSIN\",6406],[\"OZ13ZSIN\",\"HG98HCFL\"],[794093,\"FU1D57HA\",6429],[798558,\"OZ13ZSIN\",6497],[798558,\"E35YW0BM\",6500],[271136,\"NJB0V6ZO\",6582],[\"OZ13ZSIN\",\"HG98HCFL\"],[608446,\"OZ13ZSIN\",6662],[608446,\"FU1D57HA\",6760],[986152,\"OZ13ZSIN\",6799],[986152,\"NTNXSB47\",6825],[271136,\"HG98HCFL\",6911],[\"OZ13ZSIN\",\"FU1D57HA\"],[341349,\"OZ13ZSIN\",6995],[595955,\"OZ13ZSIN\",7039],[58242,\"H9OKZANW\",7071],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[134319,\"OZ13ZSIN\",7119],[595955,\"FU1D57HA\",7161],[\"OZ13ZSIN\",\"HG98HCFL\"],[266781,\"OZ13ZSIN\",7208],[\"OZ13ZSIN\",\"FU1D57HA\"],[266781,\"FU1D57HA\",7298],[\"OZ13ZSIN\",\"NTNXSB47\"],[935757,\"OZ13ZSIN\",7300],[517277,\"OZ13ZSIN\",7376],[58242,\"HG98HCFL\",7459],[\"OZ13ZSIN\",\"HG98HCFL\"],[288203,\"OZ13ZSIN\",7512],[293244,\"T25R11PB\",7580],[517277,\"HG98HCFL\",7588],[293244,\"FU1D57HA\",7649],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[480741,\"OZ13ZSIN\",7748],[288203,\"CWJHORPF\",7845],[935757,\"NTNXSB47\",7940],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[341349,\"HG98HCFL\",7952],[870607,\"ST6XEPDA\",7986],[\"OZ13ZSIN\",\"CWJHORPF\"],[468450,\"6QKM8CM8\",8063],[262669,\"OZ13ZSIN\",8152],[\"OZ13ZSIN\",\"FU1D57HA\"],[103929,\"OZ13ZSIN\",8167],[415331,\"X8W3R0P7\",8215],[134319,\"E35YW0BM\",8226],[415331,\"FU1D57HA\",8240],[468450,\"HG98HCFL\",8263],[394949,\"XOK1HH1Y\",8313],[\"OZ13ZSIN\",\"HG98HCFL\"],[394949,\"FU1D57HA\",8402],[67177,\"GQINA28A\",8451],[67177,\"HG98HCFL\",8521],[796191,\"QJHWOKDQ\",8545],[\"I0Y75MZQ\",\"FU1D57HA\"],[\"H9OKZANW\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[940010,\"OZ13ZSIN\",8583],[940010,\"VL50N6D1\",8613],[21260,\"WGOD5SD4\",8683],[746866,\"NJB0V6ZO\",8732],[47896,\"OZ13ZSIN\",8802],[480741,\"CWJHORPF\",8839],[\"NJB0V6ZO\",\"HG98HCFL\"],[310852,\"XT82S77E\",8858],[796001,\"OZ13ZSIN\",8860],[\"OZ13ZSIN\",\"NTNXSB47\"],[103929,\"FU1D57HA\",8957],[739455,\"OZ13ZSIN\",8980],[\"XWO403P7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"VL50N6D1\"],[734337,\"OZ13ZSIN\",8989],[686615,\"4SBAAFIP\",9086],[21260,\"HG98HCFL\",9130],[\"OZ13ZSIN\",\"CWJHORPF\"],[217165,\"1XW6HVBY\",9228],[689774,\"OZ13ZSIN\",9313],[870607,\"NTNXSB47\",9319],[248471,\"OZ13ZSIN\",9376],[262669,\"E35YW0BM\",9427],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[20582,\"OZ13ZSIN\",9484],[310852,\"LBYS94AD\",9535],[746866,\"FU1D57HA\",9540],[689774,\"FU1D57HA\",9594],[796191,\"HG98HCFL\",9635],[\"OZ13ZSIN\",\"FU1D57HA\"],[734337,\"HG98HCFL\",9683],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[982523,\"XWO403P7\",9689],[\"OZ13ZSIN\",\"OGVA50NO\"],[982523,\"HG98HCFL\",9786],[796001,\"FU1D57HA\",9869],[248471,\"FU1D57HA\",9942],[187843,\"OZ13ZSIN\",10035],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"H9OKZANW\",\"HG98HCFL\"],[217165,\"HG98HCFL\",10100],[739455,\"HG98HCFL\",10171],[187843,\"HG98HCFL\",10226],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[20582,\"E35YW0BM\",10322],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"SAIV20VG\",10342],[\"OZ13ZSIN\",\"FU1D57HA\"],[686615,\"HG98HCFL\",10396],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"CAWYGMWL\",10402],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[800300,\"OZ13ZSIN\",10472],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"NTNXSB47\",10485],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[800300,\"HG98HCFL\",10545],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"FU1D57HA\",10581],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[47896,\"NTNXSB47\",10588],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[788823,\"83OEBTCQ\",10599],[\"CAWYGMWL\",\"NTNXSB47\"],[365416,\"OZ13ZSIN\",10690],[610273,\"OZ13ZSIN\",10757],[988219,\"FWUZEALC\",10767],[\"XT14GVGK\",\"HG98HCFL\"],[910256,\"OZ13ZSIN\",10797],[\"OZ13ZSIN\",\"CWJHORPF\"],[610273,\"FU1D57HA\",10848],[\"OZ13ZSIN\",\"FU1D57HA\"],[910256,\"HMJCZQ0K\",10920],[\"OZ13ZSIN\",\"NTNXSB47\"],[988219,\"HG98HCFL\",10930],[365416,\"HG98HCFL\",10972],[219722,\"OZ13ZSIN\",11033],[295336,\"ITA0GE26\",11107],[219722,\"R62MQ4FI\",11131],[295336,\"FU1D57HA\",11140],[788823,\"0BIIAVNU\",11199],[620927,\"T25R11PB\",11274],[620927,\"FU1D57HA\",11371],[630168,\"OZ13ZSIN\",11448],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[112534,\"OZ13ZSIN\",11449],[573142,\"OZ13ZSIN\",11546],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[454282,\"NJB0V6ZO\",11576],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[454282,\"HG98HCFL\",11643],[444090,\"6QKM8CM8\",11698],[630168,\"Y43BFD6U\",11717],[185093,\"1XW6HVBY\",11723],[217806,\"4SBAAFIP\",11814],[\"XOK1HH1Y\",\"FU1D57HA\"],[573142,\"FU1D57HA\",11874],[661431,\"UT8S3IM6\",11907],[335406,\"OZ13ZSIN\",11942],[\"T25R11PB\",\"FU1D57HA\"],[444090,\"HG98HCFL\",11995],[896969,\"QJHWOKDQ\",12032],[950584,\"NJB0V6ZO\",12097],[570450,\"NJB0V6ZO\",12128],[896969,\"HG98HCFL\",12146],[71637,\"4SBAAFIP\",12202],[923844,\"OZ13ZSIN\",12277],[\"NJB0V6ZO\",\"HG98HCFL\"],[374491,\"OZ13ZSIN\",12300],[333698,\"1XW6HVBY\",12343],[323202,\"4SBAAFIP\",12369],[489161,\"OZ13ZSIN\",12419],[489161,\"BMN7MUED\",12446],[177905,\"XOK1HH1Y\",12483],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[185093,\"FU1D57HA\",12520],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"OZ13ZSIN\",12538],[765285,\"OZ13ZSIN\",12554],[\"OZ13ZSIN\",\"VL50N6D1\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[80760,\"XOK1HH1Y\",12613],[570450,\"R47UH9EC\",12643],[777227,\"OZ13ZSIN\",12717],[30391,\"XQ8MRL86\",12743],[923844,\"NTNXSB47\",12843],[\"OZ13ZSIN\",\"HG98HCFL\"],[177905,\"HG98HCFL\",12901],[374491,\"2Z3A0H6F\",12957],[950584,\"7IO8ET8F\",13035],[\"1XW6HVBY\",\"HG98HCFL\"],[636717,\"WY85FIVE\",13122],[661431,\"L6KOAIR1\",13154],[80760,\"XIUOFK2Y\",13215],[\"OZ13ZSIN\",\"HG98HCFL\"],[428110,\"4SBAAFIP\",13262],[\"H9OKZANW\",\"HG98HCFL\"],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"83OEBTCQ\",\"0BIIAVNU\"],[502345,\"1MOLNL46\",13324],[112534,\"HG98HCFL\",13393],[\"OZ13ZSIN\",\"HG98HCFL\"],[25332,\"OZ13ZSIN\",13487],[240072,\"OZ13ZSIN\",13504],[649981,\"ITA0GE26\",13603],[363027,\"NJB0V6ZO\",13627],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"FU1D57HA\",13724],[961598,\"ST6XEPDA\",13810],[75634,\"ZWJJHOU3\",13877],[807547,\"OZ13ZSIN\",13900],[\"OZ13ZSIN\",\"FU1D57HA\"],[71637,\"HG98HCFL\",13998],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[300645,\"OZ13ZSIN\",14033],[849654,\"OZ13ZSIN\",14128],[701073,\"GQINA28A\",14209],[288997,\"WGOD5SD4\",14252],[7101,\"OZ13ZSIN\",14258],[143698,\"SH04ZH5G\",14355],[849654,\"HG98HCFL\",14395],[300645,\"RBRIS3JS\",14484],[171052,\"OZ13ZSIN\",14576],[214567,\"NJB0V6ZO\",14592],[961598,\"JYTPXJK9\",14646],[132966,\"4SR0921V\",14665],[822925,\"4SBAAFIP\",14742],[333698,\"HG98HCFL\",14835],[\"OZ13ZSIN\",\"HG98HCFL\"],[822925,\"E35YW0BM\",14920],[777227,\"HG98HCFL\",15017],[123308,\"OZ13ZSIN\",15095],[598091,\"6QKM8CM8\",15150],[363027,\"HG98HCFL\",15160],[912565,\"OZ13ZSIN\",15202],[93990,\"1XW6HVBY\",15291],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[25332,\"FU1D57HA\",15332],[143698,\"HG98HCFL\",15380],[502345,\"DYLQ657K\",15429],[171052,\"HG98HCFL\",15436],[\"1XW6HVBY\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[217806,\"FU1D57HA\",15469],[487305,\"5D5SUJ4Q\",15499],[44397,\"6QKM8CM8\",15536],[601607,\"XOK1HH1Y\",15566],[30391,\"HG98HCFL\",15586],[\"OZ13ZSIN\",\"OGVA50NO\"],[765285,\"IX7LS60B\",15641],[788097,\"T25R11PB\",15730],[300198,\"6TED6G4E\",15774],[529964,\"OZ13ZSIN\",15793],[803049,\"IEQICIHL\",15826],[\"OZ13ZSIN\",\"HG98HCFL\"],[7101,\"DKN9PRYJ\",15869],[\"T25R11PB\",\"FU1D57HA\"],[761575,\"D5TNGKU7\",15885],[93990,\"HG98HCFL\",15894],[323202,\"HG98HCFL\",15898],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"OZ13ZSIN\",15990],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"OGVA50NO\"],[213297,\"OZ13ZSIN\",16034],[300198,\"HG98HCFL\",16105],[912565,\"HG98HCFL\",16175],[806824,\"NJB0V6ZO\",16274],[417297,\"OZ13ZSIN\",16334],[\"XQ8MRL86\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[690271,\"GQINA28A\",16427],[540402,\"OZ13ZSIN\",16500],[807547,\"FU1D57HA\",16504],[335406,\"HG98HCFL\",16539],[417297,\"HG98HCFL\",16618],[192719,\"QB05LSRK\",16711],[255839,\"OZ13ZSIN\",16755],[\"OZ13ZSIN\",\"BMN7MUED\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[711297,\"OZ13ZSIN\",16810],[\"OZ13ZSIN\",\"CWJHORPF\"],[711297,\"HG98HCFL\",16899],[211279,\"VL2TL1NM\",16907],[\"XT14GVGK\",\"HG98HCFL\"],[\"XWO403P7\",\"HG98HCFL\"],[213297,\"FU1D57HA\",16964],[44397,\"7JHO6FK0\",17021],[\"4SBAAFIP\",\"HG98HCFL\"],[75634,\"H4UTDCR8\",17075],[996616,\"JYLXUII8\",17167],[775204,\"ZZLR3YVJ\",17215],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[211106,\"6TED6G4E\",17217],[649981,\"HG98HCFL\",17236],[775204,\"HG98HCFL\",17246],[806824,\"HG98HCFL\",17313],[214567,\"GWJB6BU5\",17411],[487305,\"FU1D57HA\",17496],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[237574,\"GA4KQD8H\",17572],[863199,\"OZ13ZSIN\",17616],[921800,\"OZ13ZSIN\",17693],[415592,\"NJB0V6ZO\",17784],[788097,\"FU1D57HA\",17844],[79918,\"ZR7QN32O\",17930],[240072,\"HG98HCFL\",17938],[\"OZ13ZSIN\",\"HG98HCFL\"],[253649,\"OZ13ZSIN\",17981],[545511,\"OZ13ZSIN\",18005],[237574,\"FU1D57HA\",18089],[\"OZ13ZSIN\",\"NTNXSB47\"],[255839,\"HG98HCFL\",18169],[701073,\"HJXEGP9U\",18269],[598091,\"FU1D57HA\",18287],[\"OZ13ZSIN\",\"HG98HCFL\"],[540402,\"HG98HCFL\",18349],[887853,\"GA4KQD8H\",18417],[\"XT82S77E\",\"LBYS94AD\"],[863199,\"HG98HCFL\",18484],[\"OZ13ZSIN\",\"HG98HCFL\"],[127768,\"OZ13ZSIN\",18571],[872173,\"OZ13ZSIN\",18579],[\"OZ13ZSIN\",\"HG98HCFL\"],[872173,\"UB4KML0J\",18638],[428110,\"HG98HCFL\",18720],[\"ITA0GE26\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[85526,\"OZ13ZSIN\",18803],[123308,\"HG98HCFL\",18872],[273723,\"FJVIO218\",18884],[\"OZ13ZSIN\",\"FU1D57HA\"],[716950,\"OZ13ZSIN\",18916],[436026,\"OZ13ZSIN\",18922],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[127768,\"FU1D57HA\",18931],[646079,\"IMDG88XX\",18944],[784931,\"OZ13ZSIN\",19001],[\"OZ13ZSIN\",\"OGVA50NO\"],[\"OZ13ZSIN\",\"H4UTDCR8\"],[803049,\"RPKD08C6\",19041],[627595,\"MBY9ZG7D\",19129],[386653,\"BMX2AIY5\",19179],[\"OZ13ZSIN\",\"CWJHORPF\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[211106,\"HG98HCFL\",19251],[855448,\"OZ13ZSIN\",19300],[733785,\"SPVKZTIP\",19344],[\"XOK1HH1Y\",\"HG98HCFL\"],[761575,\"HG98HCFL\",19444],[\"OZ13ZSIN\",\"HG98HCFL\"],[132966,\"H4UTDCR8\",19503],[948005,\"OZ13ZSIN\",19520],[14408,\"OZ13ZSIN\",19594],[\"I0Y75MZQ\",\"FU1D57HA\"],[85526,\"NTNXSB47\",19687],[211403,\"OZ13ZSIN\",19761],[677411,\"OZ13ZSIN\",19852],[192719,\"HG98HCFL\",19905],[887853,\"HG98HCFL\",19975],[455474,\"OZ13ZSIN\",20002],[601607,\"FU1D57HA\",20077],[14408,\"HG98HCFL\",20150],[\"OZ13ZSIN\",\"DKN9PRYJ\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[253649,\"1QLZUAXZ\",20166],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[548975,\"OZ13ZSIN\",20232],[386653,\"1QLZUAXZ\",20277],[415592,\"HG98HCFL\",20318],[716950,\"3ZJ18VKA\",20384],[84268,\"OZ13ZSIN\",20392],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[55374,\"4SBAAFIP\",20416],[851948,\"OZ13ZSIN\",20503],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"OZ13ZSIN\",20513],[615192,\"OZ13ZSIN\",20551],[851948,\"HG98HCFL\",20631],[211403,\"HG98HCFL\",20668],[677411,\"OGVA50NO\",20715],[55374,\"FU1D57HA\",20749],[457056,\"OZ13ZSIN\",20799],[\"XOK1HH1Y\",\"FU1D57HA\"],[548975,\"HG98HCFL\",20836],[41381,\"MY3O8OQI\",20908],[950414,\"OZ13ZSIN\",20971],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[873337,\"OZ13ZSIN\",21038],[\"5D5SUJ4Q\",\"FU1D57HA\"],[273723,\"FU1D57HA\",21053],[726970,\"OZ13ZSIN\",21070],[\"OZ13ZSIN\",\"HG98HCFL\"],[211279,\"HG98HCFL\",21127],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[276902,\"4T1TBZX5\",21160],[\"OZ13ZSIN\",\"HG98HCFL\"],[183959,\"OZ13ZSIN\",21209],[488167,\"OZ13ZSIN\",21250],[\"OZ13ZSIN\",\"HG98HCFL\"],[166180,\"OZ13ZSIN\",21323],[\"FJVIO218\",\"FU1D57HA\"],[636717,\"UB4KML0J\",21366],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"DLUQBV4V\",21413],[\"OZ13ZSIN\",\"FU1D57HA\"],[528132,\"LUCPET9G\",21476],[206116,\"0MOLP3NC\",21551],[183959,\"XPM6JMBR\",21562],[\"OZ13ZSIN\",\"HG98HCFL\"],[553646,\"BMX2AIY5\",21661],[\"OZ13ZSIN\",\"DLUQBV4V\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"SH04ZH5G\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"R62MQ4FI\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[724508,\"C00L36RI\",21665],[950414,\"FU1D57HA\",21721],[102566,\"NJB0V6ZO\",21819],[690271,\"HG98HCFL\",21829],[\"OZ13ZSIN\",\"HG98HCFL\"],[386570,\"OZ13ZSIN\",21870],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[733785,\"FU1D57HA\",21931],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"ZWJJHOU3\",\"H4UTDCR8\"],[493080,\"OZ13ZSIN\",21957],[\"OZ13ZSIN\",\"RBRIS3JS\"],[476818,\"NJB0V6ZO\",22018],[\"OZ13ZSIN\",\"HG98HCFL\"],[646079,\"VMT100K8\",22076],[873337,\"E35YW0BM\",22080],[529964,\"FU1D57HA\",22162],[41381,\"FU1D57HA\",22233],[\"1XW6HVBY\",\"HG98HCFL\"],[\"IMDG88XX\",\"VMT100K8\"],[724508,\"JYTPXJK9\",22301],[\"OZ13ZSIN\",\"FU1D57HA\"],[276768,\"OZ13ZSIN\",22339],[654375,\"1XW6HVBY\",22349],[276768,\"X1H2W3W0\",22438],[\"OZ13ZSIN\",\"UB4KML0J\"],[855448,\"KSOIJA62\",22533],[493080,\"FU1D57HA\",22554],[726970,\"E35YW0BM\",22603],[\"4SR0921V\",\"H4UTDCR8\"],[79918,\"R62MQ4FI\",22640],[659224,\"OZ13ZSIN\",22739],[436026,\"L6KOAIR1\",22770],[288997,\"E35YW0BM\",22850],[\"SAIV20VG\",\"FU1D57HA\"],[553646,\"FU1D57HA\",22946],[659224,\"NTNXSB47\",22957],[615192,\"HG98HCFL\",23056],[\"OZ13ZSIN\",\"E35YW0BM\"],[730441,\"1XW6HVBY\",23129],[55790,\"OZ13ZSIN\",23179],[524967,\"OZ13ZSIN\",23189],[44097,\"2GRLB4CN\",23280],[784931,\"E35YW0BM\",23343],[525825,\"OZ13ZSIN\",23384],[315479,\"XQ8MRL86\",23386],[537074,\"OZ13ZSIN\",23437],[\"XT82S77E\",\"LBYS94AD\"],[524967,\"7JIXF9D1\",23496],[559244,\"OZ13ZSIN\",23569],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[872522,\"FJVIO218\",23579],[160528,\"DE386QWN\",23602],[\"4SBAAFIP\",\"HG98HCFL\"],[832697,\"OZ13ZSIN\",23696],[439436,\"NJB0V6ZO\",23749],[559244,\"MJZC0DI0\",23811],[38958,\"4SBAAFIP\",23863],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[327722,\"OZ13ZSIN\",23901],[243726,\"OZ13ZSIN\",23955],[38958,\"WUIGDE36\",24007],[832697,\"4IBLBVYU\",24058],[626392,\"QK3YTSXO\",24064],[640646,\"OZ13ZSIN\",24084],[476818,\"R5XHXCAN\",24129],[13070,\"NJB0V6ZO\",24190],[\"VL2TL1NM\",\"HG98HCFL\"],[633159,\"GQYWQW84\",24235],[528132,\"MPBZFLN9\",24236],[668517,\"OZ13ZSIN\",24307],[627595,\"HG98HCFL\",24343],[\"OZ13ZSIN\",\"HG98HCFL\"],[438428,\"PQOMFBOJ\",24350],[386570,\"FU1D57HA\",24413],[668517,\"7JHO6FK0\",24482],[561608,\"2IVTIGII\",24575],[539280,\"ITA0GE26\",24660],[160528,\"7IO8ET8F\",24668],[\"T25R11PB\",\"FU1D57HA\"],[626392,\"FU1D57HA\",24755],[\"4SBAAFIP\",\"WUIGDE36\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[251034,\"4SBAAFIP\",24786],[968259,\"OZ13ZSIN\",24870],[640646,\"I9H1UDG4\",24892],[361979,\"OZ13ZSIN\",24945],[806004,\"WPM57THK\",25006],[488167,\"VL50N6D1\",25009],[\"XT82S77E\",\"LBYS94AD\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[\"XQ8MRL86\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HMJCZQ0K\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[787728,\"OZ13ZSIN\",25084],[95528,\"OZ13ZSIN\",25154],[825321,\"4SBAAFIP\",25200],[\"OZ13ZSIN\",\"HG98HCFL\"],[968259,\"HG98HCFL\",25234],[\"NJB0V6ZO\",\"HG98HCFL\"],[537074,\"2Z3A0H6F\",25283],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"1QLZUAXZ\"],[430837,\"ZOA7MKHB\",25342],[588541,\"OZ13ZSIN\",25380],[\"OZ13ZSIN\",\"HG98HCFL\"],[276902,\"FU1D57HA\",25448],[787728,\"BMN7MUED\",25495],[590184,\"KFRF7AEZ\",25577],[\"LUCPET9G\",\"MPBZFLN9\"],[510551,\"OZ13ZSIN\",25597],[806004,\"HG98HCFL\",25608],[925378,\"T25R11PB\",25614],[27187,\"NJB0V6ZO\",25651],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"DE386QWN\",25682],[525825,\"IX7LS60B\",25695],[876351,\"1XW6HVBY\",25761],[225487,\"SPVKZTIP\",25783],[159468,\"OZ13ZSIN\",25784],[785370,\"BMX2AIY5\",25819],[159468,\"FU1D57HA\",25847],[822091,\"1XW6HVBY\",25911],[142228,\"OZ13ZSIN\",25962],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"HG98HCFL\",25997],[6026,\"WPM57THK\",26000],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"J1X7TLQD\",26041],[42555,\"D5TNGKU7\",26042],[921331,\"XOK1HH1Y\",26066],[95528,\"GWVJKDKT\",26130],[361979,\"CWWVVCGZ\",26183],[747281,\"OZ13ZSIN\",26197],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"NJB0V6ZO\",\"7IO8ET8F\"],[590184,\"FY86VG9O\",26248],[443593,\"6TED6G4E\",26254],[921331,\"IVDGXU4R\",26354],[184691,\"XOK1HH1Y\",26394],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"D5TNGKU7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[997488,\"OZ13ZSIN\",26468],[161852,\"OZ13ZSIN\",26476],[42555,\"HG98HCFL\",26505],[948005,\"88RO58CG\",26517],[499506,\"ITA0GE26\",26545],[\"OZ13ZSIN\",\"FU1D57HA\"],[654375,\"FU1D57HA\",26593],[999272,\"OZ13ZSIN\",26641],[\"OZ13ZSIN\",\"FU1D57HA\"],[788492,\"OZ13ZSIN\",26738],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"4SBAAFIP\",\"E35YW0BM\"],[327722,\"HG98HCFL\",26780],[499506,\"GWVJKDKT\",26878],[825321,\"HG98HCFL\",26973],[\"CAWYGMWL\",\"NTNXSB47\"],[606855,\"C00L36RI\",26996],[498054,\"OZ13ZSIN\",27025],[455474,\"7JHO6FK0\",27070],[911613,\"OZ13ZSIN\",27170],[693354,\"O77WFMCI\",27225],[\"OZ13ZSIN\",\"HG98HCFL\"],[483609,\"G2LO9U87\",27250],[\"D5TNGKU7\",\"HG98HCFL\"],[914704,\"OZ13ZSIN\",27252],[835356,\"OZ13ZSIN\",27277],[\"XOK1HH1Y\",\"HG98HCFL\"],[243726,\"2Z3A0H6F\",27330],[788492,\"HG98HCFL\",27409],[\"FJVIO218\",\"FU1D57HA\"],[730441,\"HG98HCFL\",27465],[418199,\"OZ13ZSIN\",27557],[\"NJB0V6ZO\",\"HG98HCFL\"],[416184,\"X8W3R0P7\",27576],[177447,\"GQINA28A\",27661],[27187,\"Q6L1ZD92\",27684],[53005,\"MY3O8OQI\",27746],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[835356,\"HG98HCFL\",27775],[88784,\"NJB0V6ZO\",27865],[747281,\"HG98HCFL\",27921],[\"OZ13ZSIN\",\"HG98HCFL\"],[184691,\"CWWVVCGZ\",27974],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[554716,\"OZ13ZSIN\",28020],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"FU1D57HA\",28107],[\"ZR7QN32O\",\"R62MQ4FI\"],[326091,\"XOK1HH1Y\",28151],[927316,\"OZ13ZSIN\",28193],[\"T25R11PB\",\"FU1D57HA\"],[499875,\"NJB0V6ZO\",28256],[590013,\"OZ13ZSIN\",28354],[62740,\"OZ13ZSIN\",28413],[876351,\"FU1D57HA\",28469],[749462,\"OZ13ZSIN\",28525],[\"5D5SUJ4Q\",\"FU1D57HA\"],[996616,\"OGVA50NO\",28553],[177447,\"CWWVVCGZ\",28572],[\"OZ13ZSIN\",\"FU1D57HA\"],[438428,\"L6KOAIR1\",28631],[693354,\"DLUQBV4V\",28663],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[880171,\"475J29EI\",28754],[588541,\"1YA7XTV9\",28760],[457056,\"HG98HCFL\",28762],[\"OZ13ZSIN\",\"VL50N6D1\"],[84268,\"HG98HCFL\",28792],[130492,\"IMDG88XX\",28832],[163069,\"FWUZEALC\",28840],[\"C00L36RI\",\"JYTPXJK9\"],[417559,\"BMX2AIY5\",28890],[\"OZ13ZSIN\",\"HG98HCFL\"],[914704,\"FU1D57HA\",28939],[55617,\"VL2TL1NM\",28974],[\"4SBAAFIP\",\"E35YW0BM\"],[911613,\"FU1D57HA\",29069],[880171,\"HG98HCFL\",29099],[\"OZ13ZSIN\",\"FU1D57HA\"],[117275,\"4SBAAFIP\",29174],[822091,\"FU1D57HA\",29206],[775394,\"XQ8MRL86\",29284],[917846,\"4SBAAFIP\",29288],[55790,\"0NYQFXYO\",29343],[\"83OEBTCQ\",\"0BIIAVNU\"],[416184,\"HG98HCFL\",29415],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"FJVIO218\",\"FU1D57HA\"],[228425,\"OZ13ZSIN\",29438],[\"CAWYGMWL\",\"NTNXSB47\"],[87834,\"OZ13ZSIN\",29442],[633159,\"WMTPA7JN\",29482],[322118,\"OZ13ZSIN\",29526],[\"1XW6HVBY\",\"FU1D57HA\"],[675060,\"K9D63ZZC\",29617],[225487,\"RPKD08C6\",29691],[708687,\"OZ13ZSIN\",29761],[836854,\"OZ13ZSIN\",29845],[\"6QKM8CM8\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[299466,\"4SBAAFIP\",29860],[\"WGOD5SD4\",\"E35YW0BM\"],[\"X8W3R0P7\",\"FU1D57HA\"],[927316,\"HG98HCFL\",29938],[483609,\"HG98HCFL\",29995],[\"C00L36RI\",\"JYTPXJK9\"],[\"OZ13ZSIN\",\"L6KOAIR1\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"HG98HCFL\",30054],[870611,\"72Q6VPM1\",30066],[754460,\"4SBAAFIP\",30086],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[979711,\"OZ13ZSIN\",30112],[322118,\"EY70T3I1\",30197],[696824,\"ZWJJHOU3\",30263],[239811,\"WGOD5SD4\",30361],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"475J29EI\",\"HG98HCFL\"],[963752,\"1XW6HVBY\",30399],[764562,\"OZ13ZSIN\",30480],[165422,\"XQ8MRL86\",30559],[282372,\"2MKY7B5Q\",30609],[554716,\"HG98HCFL\",30700],[925378,\"HG98HCFL\",30705],[836854,\"UB4KML0J\",30802],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[328085,\"PYU6IFCW\",30865],[999272,\"NTNXSB47\",30884],[510551,\"HG98HCFL\",30903],[87834,\"HG98HCFL\",30918],[590013,\"HG98HCFL\",30950],[775394,\"MPBZFLN9\",30963],[701078,\"OZ13ZSIN\",31024],[561608,\"WIXJ6Z00\",31082],[\"OZ13ZSIN\",\"HG98HCFL\"],[328085,\"FU1D57HA\",31132],[165422,\"HG98HCFL\",31226],[997488,\"HG98HCFL\",31249],[785370,\"FY86VG9O\",31334],[186553,\"6GPMXUYZ\",31378],[282372,\"FU1D57HA\",31454],[88784,\"WMTPA7JN\",31484],[186637,\"973PO4KY\",31528],[62740,\"HG98HCFL\",31561],[206116,\"CWWVVCGZ\",31653],[525469,\"OZ13ZSIN\",31705],[\"OZ13ZSIN\",\"CWWVVCGZ\"],[109318,\"OZ13ZSIN\",31719],[954915,\"WS49LJP8\",31776],[\"OZ13ZSIN\",\"FU1D57HA\"],[166180,\"FU1D57HA\",31824],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"MY3O8OQI\",\"FU1D57HA\"],[539280,\"YZ8LNY1V\",31843],[\"OZ13ZSIN\",\"UB4KML0J\"],[901923,\"OZ13ZSIN\",31865],[963752,\"VMT100K8\",31918],[239811,\"HG98HCFL\",31990]]` wtf is this testcase bro \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "i feel stupid that i opened ur comment. LoL ! it took forever to scroll down"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "resolved ? me also getting error in this test case"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The May badge was not an easy one! Guys let\\'s get this done!!!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Yay!"
                    },
                    {
                        "username": "omeraktepe",
                        "content": "There is a test case that does not meet assumptions. \nTest case 56: [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]] \n\nIt violetes followings: \n1. A customer can only be checked into one place at a time. \n2. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order. \n\nI am too lazy to report though :)"
                    },
                    {
                        "username": "zavojchevski",
                        "content": "I agree on this, restrictions should be well explained. "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "For those failing test case 51:\\n\"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\"\\nCredit to xuawai for noticing this back in 2020."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Restrictions should be written stricter. Some strange cases which are valid:\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@psionl0](/psionl0) \\'getAverageTime\\' arguments are invalid: "
                    },
                    {
                        "username": "psionl0",
                        "content": "All your test cases work on my code but it fails on Leet testcase 49. I also tried\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"],[\"A\",\"C\"]]\n``` \nbut that seems to be an invalid test case."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[@anwendeng](/anwendeng) My code works too, but it\\'s strange."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I have tested all of your test cases and my program passed!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using  2 tables  to store the info.\nUse hash tables for check-in and travel time info! \nThe programming is easier than a standard design for Hash set!\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Thanks for spoiling the answer for people in reallllllly big font so they don\\'t accidently try to come up with the answer themselves! Real nice of you."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "but bro trust me designing a hash set is highly asked interview problem ...\\nI recalled my concept of how we can store data in hashset..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "## **Don't raise your font at us!**"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/design-underground-system/solutions/3580430/easy-c-python-solutions-with-unordered-map-dict/"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Now people here in discuss section only comment to boost up there reputation."
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "This is an issue here and with almost all of these problems. Using vague or ambiguous names for parameters would never be allowed in enterprise software development. \\'id\\' ? id of what? Argument with name \\'t\\' is it time, train, turn? the code should be explanatory even without the description. Its also a prevalent issue in the editorials and provided solutions. \\n\\nThis is also an accessibility and inclusivity issue. When working on teams where not everyone speaks or has native proficiency in the same language using abbreviations or short hand becomes a huge problem. Leetcode should try and make it\\'s examples as near to what would be expected in a real workplace not a college math class."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me feel bad for jumping over the gates every time I lost my ticket on the way.\nSorry for creating stupid edge cases to handle for some devs somewhere"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Today is a special day for me as I will be getting my first badge of leetcode.\nThrough this one month of solving questions daily, the one thing that I have learnt is nothing matters- not even motivation if you don't have the habit of being consistent throughout the journey. \nI am looking forward to be more consistent.\nHappy coding fellow leetcoders!!!"
                    }
                ]
            },
            {
                "id": 1911475,
                "content": [
                    {
                        "username": "jax_ay",
                        "content": "`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\"] [[],[117077,\"OZ13ZSIN\",42],[117077,\"FU1D57HA\",125],[704903,\"OZ13ZSIN\",211],[911239,\"OZ13ZSIN\",245],[704903,\"HG98HCFL\",340],[859828,\"OZ13ZSIN\",355],[\"OZ13ZSIN\",\"FU1D57HA\"],[911239,\"FU1D57HA\",383],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[859828,\"FU1D57HA\",402],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[363027,\"OZ13ZSIN\",489],[319826,\"OZ13ZSIN\",550],[\"OZ13ZSIN\",\"FU1D57HA\"],[363027,\"HG98HCFL\",565],[319826,\"FU1D57HA\",664],[120084,\"OZ13ZSIN\",735],[\"OZ13ZSIN\",\"HG98HCFL\"],[120084,\"HG98HCFL\",832],[56672,\"OZ13ZSIN\",876],[56672,\"HG98HCFL\",912],[638995,\"OZ13ZSIN\",925],[\"OZ13ZSIN\",\"FU1D57HA\"],[638995,\"FU1D57HA\",951],[712949,\"OZ13ZSIN\",1023],[712949,\"FU1D57HA\",1033],[278482,\"T25R11PB\",1080],[\"OZ13ZSIN\",\"FU1D57HA\"],[278482,\"FU1D57HA\",1160],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[342818,\"4SBAAFIP\",1250],[342818,\"HG98HCFL\",1263],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[415673,\"OZ13ZSIN\",1270],[415673,\"NTNXSB47\",1366],[\"T25R11PB\",\"FU1D57HA\"],[597115,\"4SBAAFIP\",1385],[463555,\"OZ13ZSIN\",1461],[463555,\"HG98HCFL\",1514],[801778,\"OZ13ZSIN\",1537],[201428,\"OZ13ZSIN\",1620],[245538,\"OZ13ZSIN\",1630],[597115,\"FU1D57HA\",1657],[583112,\"OZ13ZSIN\",1690],[\"4SBAAFIP\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[691834,\"OZ13ZSIN\",1723],[250537,\"OZ13ZSIN\",1753],[201428,\"H4UTDCR8\",1804],[691834,\"FU1D57HA\",1838],[\"T25R11PB\",\"FU1D57HA\"],[245538,\"FU1D57HA\",1924],[346824,\"OZ13ZSIN\",1952],[864512,\"OZ13ZSIN\",2005],[499705,\"OZ13ZSIN\",2048],[482469,\"GQINA28A\",2058],[\"OZ13ZSIN\",\"FU1D57HA\"],[583112,\"E35YW0BM\",2080],[\"OZ13ZSIN\",\"HG98HCFL\"],[801778,\"HG98HCFL\",2082],[250415,\"I0Y75MZQ\",2149],[795633,\"OZ13ZSIN\",2196],[\"OZ13ZSIN\",\"HG98HCFL\"],[99144,\"4SBAAFIP\",2219],[83594,\"OZ13ZSIN\",2249],[346824,\"HG98HCFL\",2290],[482469,\"HG98HCFL\",2368],[499705,\"FU1D57HA\",2437],[12539,\"OZ13ZSIN\",2442],[116546,\"OZ13ZSIN\",2493],[884032,\"4SBAAFIP\",2579],[801142,\"OZ13ZSIN\",2598],[795633,\"HG98HCFL\",2693],[83594,\"HG98HCFL\",2782],[529306,\"OZ13ZSIN\",2824],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[286490,\"OZ13ZSIN\",2844],[255488,\"OZ13ZSIN\",2935],[608514,\"OZ13ZSIN\",2984],[116546,\"HG98HCFL\",3079],[250415,\"FU1D57HA\",3174],[\"OZ13ZSIN\",\"FU1D57HA\"],[884032,\"E35YW0BM\",3267],[\"OZ13ZSIN\",\"FU1D57HA\"],[529306,\"HG98HCFL\",3299],[\"OZ13ZSIN\",\"FU1D57HA\"],[892550,\"OZ13ZSIN\",3388],[892550,\"2VVKO5AZ\",3394],[14673,\"OZ13ZSIN\",3487],[\"OZ13ZSIN\",\"HG98HCFL\"],[12539,\"HG98HCFL\",3576],[\"OZ13ZSIN\",\"HG98HCFL\"],[255488,\"HG98HCFL\",3674],[\"OZ13ZSIN\",\"HG98HCFL\"],[14673,\"HG98HCFL\",3754],[864512,\"FU1D57HA\",3819],[451611,\"OZ13ZSIN\",3899],[\"4SBAAFIP\",\"E35YW0BM\"],[451611,\"HG98HCFL\",3941],[250537,\"HG98HCFL\",4027],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[286490,\"FU1D57HA\",4046],[608514,\"HG98HCFL\",4094],[827431,\"XWO403P7\",4107],[99144,\"HG98HCFL\",4136],[\"GQINA28A\",\"HG98HCFL\"],[657832,\"OZ13ZSIN\",4150],[827431,\"HG98HCFL\",4214],[\"OZ13ZSIN\",\"FU1D57HA\"],[658842,\"OZ13ZSIN\",4236],[52933,\"4SBAAFIP\",4325],[801142,\"HG98HCFL\",4413],[52933,\"E35YW0BM\",4460],[331712,\"OZ13ZSIN\",4522],[658842,\"NTNXSB47\",4615],[293734,\"OZ13ZSIN\",4665],[293734,\"HG98HCFL\",4735],[917903,\"OZ13ZSIN\",4772],[119860,\"OZ13ZSIN\",4775],[\"OZ13ZSIN\",\"HG98HCFL\"],[657832,\"E35YW0BM\",4850],[415861,\"NJB0V6ZO\",4881],[\"OZ13ZSIN\",\"FU1D57HA\"],[917903,\"HG98HCFL\",4892],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[415861,\"HG98HCFL\",4919],[\"OZ13ZSIN\",\"HG98HCFL\"],[331712,\"OGVA50NO\",4979],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[119860,\"HG98HCFL\",5034],[469875,\"OZ13ZSIN\",5053],[407362,\"XT14GVGK\",5073],[469875,\"HG98HCFL\",5126],[407362,\"HG98HCFL\",5175],[324747,\"OZ13ZSIN\",5236],[315560,\"OZ13ZSIN\",5333],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[317815,\"OZ13ZSIN\",5339],[906872,\"OZ13ZSIN\",5349],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[404251,\"OZ13ZSIN\",5375],[324747,\"HG98HCFL\",5474],[882572,\"OZ13ZSIN\",5524],[\"OZ13ZSIN\",\"HG98HCFL\"],[758501,\"OZ13ZSIN\",5561],[404251,\"FU1D57HA\",5617],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[315560,\"HG98HCFL\",5651],[758501,\"HG98HCFL\",5673],[141090,\"OZ13ZSIN\",5768],[882572,\"FU1D57HA\",5827],[906872,\"HG98HCFL\",5872],[141090,\"HG98HCFL\",5940],[\"OZ13ZSIN\",\"FU1D57HA\"],[317815,\"HG98HCFL\",5996],[436252,\"OZ13ZSIN\",6027],[\"OZ13ZSIN\",\"E35YW0BM\"],[436252,\"HG98HCFL\",6084],[\"OZ13ZSIN\",\"NTNXSB47\"],[652912,\"NJB0V6ZO\",6155],[652912,\"HG98HCFL\",6169],[269825,\"NJB0V6ZO\",6173],[831024,\"OZ13ZSIN\",6267],[831024,\"FU1D57HA\",6317],[269825,\"FU1D57HA\",6318],[794093,\"OZ13ZSIN\",6406],[\"OZ13ZSIN\",\"HG98HCFL\"],[794093,\"FU1D57HA\",6429],[798558,\"OZ13ZSIN\",6497],[798558,\"E35YW0BM\",6500],[271136,\"NJB0V6ZO\",6582],[\"OZ13ZSIN\",\"HG98HCFL\"],[608446,\"OZ13ZSIN\",6662],[608446,\"FU1D57HA\",6760],[986152,\"OZ13ZSIN\",6799],[986152,\"NTNXSB47\",6825],[271136,\"HG98HCFL\",6911],[\"OZ13ZSIN\",\"FU1D57HA\"],[341349,\"OZ13ZSIN\",6995],[595955,\"OZ13ZSIN\",7039],[58242,\"H9OKZANW\",7071],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[134319,\"OZ13ZSIN\",7119],[595955,\"FU1D57HA\",7161],[\"OZ13ZSIN\",\"HG98HCFL\"],[266781,\"OZ13ZSIN\",7208],[\"OZ13ZSIN\",\"FU1D57HA\"],[266781,\"FU1D57HA\",7298],[\"OZ13ZSIN\",\"NTNXSB47\"],[935757,\"OZ13ZSIN\",7300],[517277,\"OZ13ZSIN\",7376],[58242,\"HG98HCFL\",7459],[\"OZ13ZSIN\",\"HG98HCFL\"],[288203,\"OZ13ZSIN\",7512],[293244,\"T25R11PB\",7580],[517277,\"HG98HCFL\",7588],[293244,\"FU1D57HA\",7649],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[480741,\"OZ13ZSIN\",7748],[288203,\"CWJHORPF\",7845],[935757,\"NTNXSB47\",7940],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[341349,\"HG98HCFL\",7952],[870607,\"ST6XEPDA\",7986],[\"OZ13ZSIN\",\"CWJHORPF\"],[468450,\"6QKM8CM8\",8063],[262669,\"OZ13ZSIN\",8152],[\"OZ13ZSIN\",\"FU1D57HA\"],[103929,\"OZ13ZSIN\",8167],[415331,\"X8W3R0P7\",8215],[134319,\"E35YW0BM\",8226],[415331,\"FU1D57HA\",8240],[468450,\"HG98HCFL\",8263],[394949,\"XOK1HH1Y\",8313],[\"OZ13ZSIN\",\"HG98HCFL\"],[394949,\"FU1D57HA\",8402],[67177,\"GQINA28A\",8451],[67177,\"HG98HCFL\",8521],[796191,\"QJHWOKDQ\",8545],[\"I0Y75MZQ\",\"FU1D57HA\"],[\"H9OKZANW\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[940010,\"OZ13ZSIN\",8583],[940010,\"VL50N6D1\",8613],[21260,\"WGOD5SD4\",8683],[746866,\"NJB0V6ZO\",8732],[47896,\"OZ13ZSIN\",8802],[480741,\"CWJHORPF\",8839],[\"NJB0V6ZO\",\"HG98HCFL\"],[310852,\"XT82S77E\",8858],[796001,\"OZ13ZSIN\",8860],[\"OZ13ZSIN\",\"NTNXSB47\"],[103929,\"FU1D57HA\",8957],[739455,\"OZ13ZSIN\",8980],[\"XWO403P7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"VL50N6D1\"],[734337,\"OZ13ZSIN\",8989],[686615,\"4SBAAFIP\",9086],[21260,\"HG98HCFL\",9130],[\"OZ13ZSIN\",\"CWJHORPF\"],[217165,\"1XW6HVBY\",9228],[689774,\"OZ13ZSIN\",9313],[870607,\"NTNXSB47\",9319],[248471,\"OZ13ZSIN\",9376],[262669,\"E35YW0BM\",9427],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[20582,\"OZ13ZSIN\",9484],[310852,\"LBYS94AD\",9535],[746866,\"FU1D57HA\",9540],[689774,\"FU1D57HA\",9594],[796191,\"HG98HCFL\",9635],[\"OZ13ZSIN\",\"FU1D57HA\"],[734337,\"HG98HCFL\",9683],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[982523,\"XWO403P7\",9689],[\"OZ13ZSIN\",\"OGVA50NO\"],[982523,\"HG98HCFL\",9786],[796001,\"FU1D57HA\",9869],[248471,\"FU1D57HA\",9942],[187843,\"OZ13ZSIN\",10035],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"H9OKZANW\",\"HG98HCFL\"],[217165,\"HG98HCFL\",10100],[739455,\"HG98HCFL\",10171],[187843,\"HG98HCFL\",10226],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[20582,\"E35YW0BM\",10322],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"SAIV20VG\",10342],[\"OZ13ZSIN\",\"FU1D57HA\"],[686615,\"HG98HCFL\",10396],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"CAWYGMWL\",10402],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[800300,\"OZ13ZSIN\",10472],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"NTNXSB47\",10485],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[800300,\"HG98HCFL\",10545],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"FU1D57HA\",10581],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[47896,\"NTNXSB47\",10588],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[788823,\"83OEBTCQ\",10599],[\"CAWYGMWL\",\"NTNXSB47\"],[365416,\"OZ13ZSIN\",10690],[610273,\"OZ13ZSIN\",10757],[988219,\"FWUZEALC\",10767],[\"XT14GVGK\",\"HG98HCFL\"],[910256,\"OZ13ZSIN\",10797],[\"OZ13ZSIN\",\"CWJHORPF\"],[610273,\"FU1D57HA\",10848],[\"OZ13ZSIN\",\"FU1D57HA\"],[910256,\"HMJCZQ0K\",10920],[\"OZ13ZSIN\",\"NTNXSB47\"],[988219,\"HG98HCFL\",10930],[365416,\"HG98HCFL\",10972],[219722,\"OZ13ZSIN\",11033],[295336,\"ITA0GE26\",11107],[219722,\"R62MQ4FI\",11131],[295336,\"FU1D57HA\",11140],[788823,\"0BIIAVNU\",11199],[620927,\"T25R11PB\",11274],[620927,\"FU1D57HA\",11371],[630168,\"OZ13ZSIN\",11448],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[112534,\"OZ13ZSIN\",11449],[573142,\"OZ13ZSIN\",11546],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[454282,\"NJB0V6ZO\",11576],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[454282,\"HG98HCFL\",11643],[444090,\"6QKM8CM8\",11698],[630168,\"Y43BFD6U\",11717],[185093,\"1XW6HVBY\",11723],[217806,\"4SBAAFIP\",11814],[\"XOK1HH1Y\",\"FU1D57HA\"],[573142,\"FU1D57HA\",11874],[661431,\"UT8S3IM6\",11907],[335406,\"OZ13ZSIN\",11942],[\"T25R11PB\",\"FU1D57HA\"],[444090,\"HG98HCFL\",11995],[896969,\"QJHWOKDQ\",12032],[950584,\"NJB0V6ZO\",12097],[570450,\"NJB0V6ZO\",12128],[896969,\"HG98HCFL\",12146],[71637,\"4SBAAFIP\",12202],[923844,\"OZ13ZSIN\",12277],[\"NJB0V6ZO\",\"HG98HCFL\"],[374491,\"OZ13ZSIN\",12300],[333698,\"1XW6HVBY\",12343],[323202,\"4SBAAFIP\",12369],[489161,\"OZ13ZSIN\",12419],[489161,\"BMN7MUED\",12446],[177905,\"XOK1HH1Y\",12483],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[185093,\"FU1D57HA\",12520],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"OZ13ZSIN\",12538],[765285,\"OZ13ZSIN\",12554],[\"OZ13ZSIN\",\"VL50N6D1\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[80760,\"XOK1HH1Y\",12613],[570450,\"R47UH9EC\",12643],[777227,\"OZ13ZSIN\",12717],[30391,\"XQ8MRL86\",12743],[923844,\"NTNXSB47\",12843],[\"OZ13ZSIN\",\"HG98HCFL\"],[177905,\"HG98HCFL\",12901],[374491,\"2Z3A0H6F\",12957],[950584,\"7IO8ET8F\",13035],[\"1XW6HVBY\",\"HG98HCFL\"],[636717,\"WY85FIVE\",13122],[661431,\"L6KOAIR1\",13154],[80760,\"XIUOFK2Y\",13215],[\"OZ13ZSIN\",\"HG98HCFL\"],[428110,\"4SBAAFIP\",13262],[\"H9OKZANW\",\"HG98HCFL\"],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"83OEBTCQ\",\"0BIIAVNU\"],[502345,\"1MOLNL46\",13324],[112534,\"HG98HCFL\",13393],[\"OZ13ZSIN\",\"HG98HCFL\"],[25332,\"OZ13ZSIN\",13487],[240072,\"OZ13ZSIN\",13504],[649981,\"ITA0GE26\",13603],[363027,\"NJB0V6ZO\",13627],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"FU1D57HA\",13724],[961598,\"ST6XEPDA\",13810],[75634,\"ZWJJHOU3\",13877],[807547,\"OZ13ZSIN\",13900],[\"OZ13ZSIN\",\"FU1D57HA\"],[71637,\"HG98HCFL\",13998],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[300645,\"OZ13ZSIN\",14033],[849654,\"OZ13ZSIN\",14128],[701073,\"GQINA28A\",14209],[288997,\"WGOD5SD4\",14252],[7101,\"OZ13ZSIN\",14258],[143698,\"SH04ZH5G\",14355],[849654,\"HG98HCFL\",14395],[300645,\"RBRIS3JS\",14484],[171052,\"OZ13ZSIN\",14576],[214567,\"NJB0V6ZO\",14592],[961598,\"JYTPXJK9\",14646],[132966,\"4SR0921V\",14665],[822925,\"4SBAAFIP\",14742],[333698,\"HG98HCFL\",14835],[\"OZ13ZSIN\",\"HG98HCFL\"],[822925,\"E35YW0BM\",14920],[777227,\"HG98HCFL\",15017],[123308,\"OZ13ZSIN\",15095],[598091,\"6QKM8CM8\",15150],[363027,\"HG98HCFL\",15160],[912565,\"OZ13ZSIN\",15202],[93990,\"1XW6HVBY\",15291],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[25332,\"FU1D57HA\",15332],[143698,\"HG98HCFL\",15380],[502345,\"DYLQ657K\",15429],[171052,\"HG98HCFL\",15436],[\"1XW6HVBY\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[217806,\"FU1D57HA\",15469],[487305,\"5D5SUJ4Q\",15499],[44397,\"6QKM8CM8\",15536],[601607,\"XOK1HH1Y\",15566],[30391,\"HG98HCFL\",15586],[\"OZ13ZSIN\",\"OGVA50NO\"],[765285,\"IX7LS60B\",15641],[788097,\"T25R11PB\",15730],[300198,\"6TED6G4E\",15774],[529964,\"OZ13ZSIN\",15793],[803049,\"IEQICIHL\",15826],[\"OZ13ZSIN\",\"HG98HCFL\"],[7101,\"DKN9PRYJ\",15869],[\"T25R11PB\",\"FU1D57HA\"],[761575,\"D5TNGKU7\",15885],[93990,\"HG98HCFL\",15894],[323202,\"HG98HCFL\",15898],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"OZ13ZSIN\",15990],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"OGVA50NO\"],[213297,\"OZ13ZSIN\",16034],[300198,\"HG98HCFL\",16105],[912565,\"HG98HCFL\",16175],[806824,\"NJB0V6ZO\",16274],[417297,\"OZ13ZSIN\",16334],[\"XQ8MRL86\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[690271,\"GQINA28A\",16427],[540402,\"OZ13ZSIN\",16500],[807547,\"FU1D57HA\",16504],[335406,\"HG98HCFL\",16539],[417297,\"HG98HCFL\",16618],[192719,\"QB05LSRK\",16711],[255839,\"OZ13ZSIN\",16755],[\"OZ13ZSIN\",\"BMN7MUED\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[711297,\"OZ13ZSIN\",16810],[\"OZ13ZSIN\",\"CWJHORPF\"],[711297,\"HG98HCFL\",16899],[211279,\"VL2TL1NM\",16907],[\"XT14GVGK\",\"HG98HCFL\"],[\"XWO403P7\",\"HG98HCFL\"],[213297,\"FU1D57HA\",16964],[44397,\"7JHO6FK0\",17021],[\"4SBAAFIP\",\"HG98HCFL\"],[75634,\"H4UTDCR8\",17075],[996616,\"JYLXUII8\",17167],[775204,\"ZZLR3YVJ\",17215],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[211106,\"6TED6G4E\",17217],[649981,\"HG98HCFL\",17236],[775204,\"HG98HCFL\",17246],[806824,\"HG98HCFL\",17313],[214567,\"GWJB6BU5\",17411],[487305,\"FU1D57HA\",17496],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[237574,\"GA4KQD8H\",17572],[863199,\"OZ13ZSIN\",17616],[921800,\"OZ13ZSIN\",17693],[415592,\"NJB0V6ZO\",17784],[788097,\"FU1D57HA\",17844],[79918,\"ZR7QN32O\",17930],[240072,\"HG98HCFL\",17938],[\"OZ13ZSIN\",\"HG98HCFL\"],[253649,\"OZ13ZSIN\",17981],[545511,\"OZ13ZSIN\",18005],[237574,\"FU1D57HA\",18089],[\"OZ13ZSIN\",\"NTNXSB47\"],[255839,\"HG98HCFL\",18169],[701073,\"HJXEGP9U\",18269],[598091,\"FU1D57HA\",18287],[\"OZ13ZSIN\",\"HG98HCFL\"],[540402,\"HG98HCFL\",18349],[887853,\"GA4KQD8H\",18417],[\"XT82S77E\",\"LBYS94AD\"],[863199,\"HG98HCFL\",18484],[\"OZ13ZSIN\",\"HG98HCFL\"],[127768,\"OZ13ZSIN\",18571],[872173,\"OZ13ZSIN\",18579],[\"OZ13ZSIN\",\"HG98HCFL\"],[872173,\"UB4KML0J\",18638],[428110,\"HG98HCFL\",18720],[\"ITA0GE26\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[85526,\"OZ13ZSIN\",18803],[123308,\"HG98HCFL\",18872],[273723,\"FJVIO218\",18884],[\"OZ13ZSIN\",\"FU1D57HA\"],[716950,\"OZ13ZSIN\",18916],[436026,\"OZ13ZSIN\",18922],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[127768,\"FU1D57HA\",18931],[646079,\"IMDG88XX\",18944],[784931,\"OZ13ZSIN\",19001],[\"OZ13ZSIN\",\"OGVA50NO\"],[\"OZ13ZSIN\",\"H4UTDCR8\"],[803049,\"RPKD08C6\",19041],[627595,\"MBY9ZG7D\",19129],[386653,\"BMX2AIY5\",19179],[\"OZ13ZSIN\",\"CWJHORPF\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[211106,\"HG98HCFL\",19251],[855448,\"OZ13ZSIN\",19300],[733785,\"SPVKZTIP\",19344],[\"XOK1HH1Y\",\"HG98HCFL\"],[761575,\"HG98HCFL\",19444],[\"OZ13ZSIN\",\"HG98HCFL\"],[132966,\"H4UTDCR8\",19503],[948005,\"OZ13ZSIN\",19520],[14408,\"OZ13ZSIN\",19594],[\"I0Y75MZQ\",\"FU1D57HA\"],[85526,\"NTNXSB47\",19687],[211403,\"OZ13ZSIN\",19761],[677411,\"OZ13ZSIN\",19852],[192719,\"HG98HCFL\",19905],[887853,\"HG98HCFL\",19975],[455474,\"OZ13ZSIN\",20002],[601607,\"FU1D57HA\",20077],[14408,\"HG98HCFL\",20150],[\"OZ13ZSIN\",\"DKN9PRYJ\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[253649,\"1QLZUAXZ\",20166],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[548975,\"OZ13ZSIN\",20232],[386653,\"1QLZUAXZ\",20277],[415592,\"HG98HCFL\",20318],[716950,\"3ZJ18VKA\",20384],[84268,\"OZ13ZSIN\",20392],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[55374,\"4SBAAFIP\",20416],[851948,\"OZ13ZSIN\",20503],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"OZ13ZSIN\",20513],[615192,\"OZ13ZSIN\",20551],[851948,\"HG98HCFL\",20631],[211403,\"HG98HCFL\",20668],[677411,\"OGVA50NO\",20715],[55374,\"FU1D57HA\",20749],[457056,\"OZ13ZSIN\",20799],[\"XOK1HH1Y\",\"FU1D57HA\"],[548975,\"HG98HCFL\",20836],[41381,\"MY3O8OQI\",20908],[950414,\"OZ13ZSIN\",20971],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[873337,\"OZ13ZSIN\",21038],[\"5D5SUJ4Q\",\"FU1D57HA\"],[273723,\"FU1D57HA\",21053],[726970,\"OZ13ZSIN\",21070],[\"OZ13ZSIN\",\"HG98HCFL\"],[211279,\"HG98HCFL\",21127],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[276902,\"4T1TBZX5\",21160],[\"OZ13ZSIN\",\"HG98HCFL\"],[183959,\"OZ13ZSIN\",21209],[488167,\"OZ13ZSIN\",21250],[\"OZ13ZSIN\",\"HG98HCFL\"],[166180,\"OZ13ZSIN\",21323],[\"FJVIO218\",\"FU1D57HA\"],[636717,\"UB4KML0J\",21366],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"DLUQBV4V\",21413],[\"OZ13ZSIN\",\"FU1D57HA\"],[528132,\"LUCPET9G\",21476],[206116,\"0MOLP3NC\",21551],[183959,\"XPM6JMBR\",21562],[\"OZ13ZSIN\",\"HG98HCFL\"],[553646,\"BMX2AIY5\",21661],[\"OZ13ZSIN\",\"DLUQBV4V\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"SH04ZH5G\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"R62MQ4FI\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[724508,\"C00L36RI\",21665],[950414,\"FU1D57HA\",21721],[102566,\"NJB0V6ZO\",21819],[690271,\"HG98HCFL\",21829],[\"OZ13ZSIN\",\"HG98HCFL\"],[386570,\"OZ13ZSIN\",21870],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[733785,\"FU1D57HA\",21931],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"ZWJJHOU3\",\"H4UTDCR8\"],[493080,\"OZ13ZSIN\",21957],[\"OZ13ZSIN\",\"RBRIS3JS\"],[476818,\"NJB0V6ZO\",22018],[\"OZ13ZSIN\",\"HG98HCFL\"],[646079,\"VMT100K8\",22076],[873337,\"E35YW0BM\",22080],[529964,\"FU1D57HA\",22162],[41381,\"FU1D57HA\",22233],[\"1XW6HVBY\",\"HG98HCFL\"],[\"IMDG88XX\",\"VMT100K8\"],[724508,\"JYTPXJK9\",22301],[\"OZ13ZSIN\",\"FU1D57HA\"],[276768,\"OZ13ZSIN\",22339],[654375,\"1XW6HVBY\",22349],[276768,\"X1H2W3W0\",22438],[\"OZ13ZSIN\",\"UB4KML0J\"],[855448,\"KSOIJA62\",22533],[493080,\"FU1D57HA\",22554],[726970,\"E35YW0BM\",22603],[\"4SR0921V\",\"H4UTDCR8\"],[79918,\"R62MQ4FI\",22640],[659224,\"OZ13ZSIN\",22739],[436026,\"L6KOAIR1\",22770],[288997,\"E35YW0BM\",22850],[\"SAIV20VG\",\"FU1D57HA\"],[553646,\"FU1D57HA\",22946],[659224,\"NTNXSB47\",22957],[615192,\"HG98HCFL\",23056],[\"OZ13ZSIN\",\"E35YW0BM\"],[730441,\"1XW6HVBY\",23129],[55790,\"OZ13ZSIN\",23179],[524967,\"OZ13ZSIN\",23189],[44097,\"2GRLB4CN\",23280],[784931,\"E35YW0BM\",23343],[525825,\"OZ13ZSIN\",23384],[315479,\"XQ8MRL86\",23386],[537074,\"OZ13ZSIN\",23437],[\"XT82S77E\",\"LBYS94AD\"],[524967,\"7JIXF9D1\",23496],[559244,\"OZ13ZSIN\",23569],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[872522,\"FJVIO218\",23579],[160528,\"DE386QWN\",23602],[\"4SBAAFIP\",\"HG98HCFL\"],[832697,\"OZ13ZSIN\",23696],[439436,\"NJB0V6ZO\",23749],[559244,\"MJZC0DI0\",23811],[38958,\"4SBAAFIP\",23863],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[327722,\"OZ13ZSIN\",23901],[243726,\"OZ13ZSIN\",23955],[38958,\"WUIGDE36\",24007],[832697,\"4IBLBVYU\",24058],[626392,\"QK3YTSXO\",24064],[640646,\"OZ13ZSIN\",24084],[476818,\"R5XHXCAN\",24129],[13070,\"NJB0V6ZO\",24190],[\"VL2TL1NM\",\"HG98HCFL\"],[633159,\"GQYWQW84\",24235],[528132,\"MPBZFLN9\",24236],[668517,\"OZ13ZSIN\",24307],[627595,\"HG98HCFL\",24343],[\"OZ13ZSIN\",\"HG98HCFL\"],[438428,\"PQOMFBOJ\",24350],[386570,\"FU1D57HA\",24413],[668517,\"7JHO6FK0\",24482],[561608,\"2IVTIGII\",24575],[539280,\"ITA0GE26\",24660],[160528,\"7IO8ET8F\",24668],[\"T25R11PB\",\"FU1D57HA\"],[626392,\"FU1D57HA\",24755],[\"4SBAAFIP\",\"WUIGDE36\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[251034,\"4SBAAFIP\",24786],[968259,\"OZ13ZSIN\",24870],[640646,\"I9H1UDG4\",24892],[361979,\"OZ13ZSIN\",24945],[806004,\"WPM57THK\",25006],[488167,\"VL50N6D1\",25009],[\"XT82S77E\",\"LBYS94AD\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[\"XQ8MRL86\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HMJCZQ0K\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[787728,\"OZ13ZSIN\",25084],[95528,\"OZ13ZSIN\",25154],[825321,\"4SBAAFIP\",25200],[\"OZ13ZSIN\",\"HG98HCFL\"],[968259,\"HG98HCFL\",25234],[\"NJB0V6ZO\",\"HG98HCFL\"],[537074,\"2Z3A0H6F\",25283],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"1QLZUAXZ\"],[430837,\"ZOA7MKHB\",25342],[588541,\"OZ13ZSIN\",25380],[\"OZ13ZSIN\",\"HG98HCFL\"],[276902,\"FU1D57HA\",25448],[787728,\"BMN7MUED\",25495],[590184,\"KFRF7AEZ\",25577],[\"LUCPET9G\",\"MPBZFLN9\"],[510551,\"OZ13ZSIN\",25597],[806004,\"HG98HCFL\",25608],[925378,\"T25R11PB\",25614],[27187,\"NJB0V6ZO\",25651],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"DE386QWN\",25682],[525825,\"IX7LS60B\",25695],[876351,\"1XW6HVBY\",25761],[225487,\"SPVKZTIP\",25783],[159468,\"OZ13ZSIN\",25784],[785370,\"BMX2AIY5\",25819],[159468,\"FU1D57HA\",25847],[822091,\"1XW6HVBY\",25911],[142228,\"OZ13ZSIN\",25962],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"HG98HCFL\",25997],[6026,\"WPM57THK\",26000],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"J1X7TLQD\",26041],[42555,\"D5TNGKU7\",26042],[921331,\"XOK1HH1Y\",26066],[95528,\"GWVJKDKT\",26130],[361979,\"CWWVVCGZ\",26183],[747281,\"OZ13ZSIN\",26197],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"NJB0V6ZO\",\"7IO8ET8F\"],[590184,\"FY86VG9O\",26248],[443593,\"6TED6G4E\",26254],[921331,\"IVDGXU4R\",26354],[184691,\"XOK1HH1Y\",26394],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"D5TNGKU7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[997488,\"OZ13ZSIN\",26468],[161852,\"OZ13ZSIN\",26476],[42555,\"HG98HCFL\",26505],[948005,\"88RO58CG\",26517],[499506,\"ITA0GE26\",26545],[\"OZ13ZSIN\",\"FU1D57HA\"],[654375,\"FU1D57HA\",26593],[999272,\"OZ13ZSIN\",26641],[\"OZ13ZSIN\",\"FU1D57HA\"],[788492,\"OZ13ZSIN\",26738],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"4SBAAFIP\",\"E35YW0BM\"],[327722,\"HG98HCFL\",26780],[499506,\"GWVJKDKT\",26878],[825321,\"HG98HCFL\",26973],[\"CAWYGMWL\",\"NTNXSB47\"],[606855,\"C00L36RI\",26996],[498054,\"OZ13ZSIN\",27025],[455474,\"7JHO6FK0\",27070],[911613,\"OZ13ZSIN\",27170],[693354,\"O77WFMCI\",27225],[\"OZ13ZSIN\",\"HG98HCFL\"],[483609,\"G2LO9U87\",27250],[\"D5TNGKU7\",\"HG98HCFL\"],[914704,\"OZ13ZSIN\",27252],[835356,\"OZ13ZSIN\",27277],[\"XOK1HH1Y\",\"HG98HCFL\"],[243726,\"2Z3A0H6F\",27330],[788492,\"HG98HCFL\",27409],[\"FJVIO218\",\"FU1D57HA\"],[730441,\"HG98HCFL\",27465],[418199,\"OZ13ZSIN\",27557],[\"NJB0V6ZO\",\"HG98HCFL\"],[416184,\"X8W3R0P7\",27576],[177447,\"GQINA28A\",27661],[27187,\"Q6L1ZD92\",27684],[53005,\"MY3O8OQI\",27746],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[835356,\"HG98HCFL\",27775],[88784,\"NJB0V6ZO\",27865],[747281,\"HG98HCFL\",27921],[\"OZ13ZSIN\",\"HG98HCFL\"],[184691,\"CWWVVCGZ\",27974],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[554716,\"OZ13ZSIN\",28020],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"FU1D57HA\",28107],[\"ZR7QN32O\",\"R62MQ4FI\"],[326091,\"XOK1HH1Y\",28151],[927316,\"OZ13ZSIN\",28193],[\"T25R11PB\",\"FU1D57HA\"],[499875,\"NJB0V6ZO\",28256],[590013,\"OZ13ZSIN\",28354],[62740,\"OZ13ZSIN\",28413],[876351,\"FU1D57HA\",28469],[749462,\"OZ13ZSIN\",28525],[\"5D5SUJ4Q\",\"FU1D57HA\"],[996616,\"OGVA50NO\",28553],[177447,\"CWWVVCGZ\",28572],[\"OZ13ZSIN\",\"FU1D57HA\"],[438428,\"L6KOAIR1\",28631],[693354,\"DLUQBV4V\",28663],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[880171,\"475J29EI\",28754],[588541,\"1YA7XTV9\",28760],[457056,\"HG98HCFL\",28762],[\"OZ13ZSIN\",\"VL50N6D1\"],[84268,\"HG98HCFL\",28792],[130492,\"IMDG88XX\",28832],[163069,\"FWUZEALC\",28840],[\"C00L36RI\",\"JYTPXJK9\"],[417559,\"BMX2AIY5\",28890],[\"OZ13ZSIN\",\"HG98HCFL\"],[914704,\"FU1D57HA\",28939],[55617,\"VL2TL1NM\",28974],[\"4SBAAFIP\",\"E35YW0BM\"],[911613,\"FU1D57HA\",29069],[880171,\"HG98HCFL\",29099],[\"OZ13ZSIN\",\"FU1D57HA\"],[117275,\"4SBAAFIP\",29174],[822091,\"FU1D57HA\",29206],[775394,\"XQ8MRL86\",29284],[917846,\"4SBAAFIP\",29288],[55790,\"0NYQFXYO\",29343],[\"83OEBTCQ\",\"0BIIAVNU\"],[416184,\"HG98HCFL\",29415],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"FJVIO218\",\"FU1D57HA\"],[228425,\"OZ13ZSIN\",29438],[\"CAWYGMWL\",\"NTNXSB47\"],[87834,\"OZ13ZSIN\",29442],[633159,\"WMTPA7JN\",29482],[322118,\"OZ13ZSIN\",29526],[\"1XW6HVBY\",\"FU1D57HA\"],[675060,\"K9D63ZZC\",29617],[225487,\"RPKD08C6\",29691],[708687,\"OZ13ZSIN\",29761],[836854,\"OZ13ZSIN\",29845],[\"6QKM8CM8\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[299466,\"4SBAAFIP\",29860],[\"WGOD5SD4\",\"E35YW0BM\"],[\"X8W3R0P7\",\"FU1D57HA\"],[927316,\"HG98HCFL\",29938],[483609,\"HG98HCFL\",29995],[\"C00L36RI\",\"JYTPXJK9\"],[\"OZ13ZSIN\",\"L6KOAIR1\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"HG98HCFL\",30054],[870611,\"72Q6VPM1\",30066],[754460,\"4SBAAFIP\",30086],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[979711,\"OZ13ZSIN\",30112],[322118,\"EY70T3I1\",30197],[696824,\"ZWJJHOU3\",30263],[239811,\"WGOD5SD4\",30361],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"475J29EI\",\"HG98HCFL\"],[963752,\"1XW6HVBY\",30399],[764562,\"OZ13ZSIN\",30480],[165422,\"XQ8MRL86\",30559],[282372,\"2MKY7B5Q\",30609],[554716,\"HG98HCFL\",30700],[925378,\"HG98HCFL\",30705],[836854,\"UB4KML0J\",30802],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[328085,\"PYU6IFCW\",30865],[999272,\"NTNXSB47\",30884],[510551,\"HG98HCFL\",30903],[87834,\"HG98HCFL\",30918],[590013,\"HG98HCFL\",30950],[775394,\"MPBZFLN9\",30963],[701078,\"OZ13ZSIN\",31024],[561608,\"WIXJ6Z00\",31082],[\"OZ13ZSIN\",\"HG98HCFL\"],[328085,\"FU1D57HA\",31132],[165422,\"HG98HCFL\",31226],[997488,\"HG98HCFL\",31249],[785370,\"FY86VG9O\",31334],[186553,\"6GPMXUYZ\",31378],[282372,\"FU1D57HA\",31454],[88784,\"WMTPA7JN\",31484],[186637,\"973PO4KY\",31528],[62740,\"HG98HCFL\",31561],[206116,\"CWWVVCGZ\",31653],[525469,\"OZ13ZSIN\",31705],[\"OZ13ZSIN\",\"CWWVVCGZ\"],[109318,\"OZ13ZSIN\",31719],[954915,\"WS49LJP8\",31776],[\"OZ13ZSIN\",\"FU1D57HA\"],[166180,\"FU1D57HA\",31824],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"MY3O8OQI\",\"FU1D57HA\"],[539280,\"YZ8LNY1V\",31843],[\"OZ13ZSIN\",\"UB4KML0J\"],[901923,\"OZ13ZSIN\",31865],[963752,\"VMT100K8\",31918],[239811,\"HG98HCFL\",31990]]` wtf is this testcase bro \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "i feel stupid that i opened ur comment. LoL ! it took forever to scroll down"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "resolved ? me also getting error in this test case"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The May badge was not an easy one! Guys let\\'s get this done!!!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Yay!"
                    },
                    {
                        "username": "omeraktepe",
                        "content": "There is a test case that does not meet assumptions. \nTest case 56: [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]] \n\nIt violetes followings: \n1. A customer can only be checked into one place at a time. \n2. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order. \n\nI am too lazy to report though :)"
                    },
                    {
                        "username": "zavojchevski",
                        "content": "I agree on this, restrictions should be well explained. "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "For those failing test case 51:\\n\"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\"\\nCredit to xuawai for noticing this back in 2020."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Restrictions should be written stricter. Some strange cases which are valid:\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@psionl0](/psionl0) \\'getAverageTime\\' arguments are invalid: "
                    },
                    {
                        "username": "psionl0",
                        "content": "All your test cases work on my code but it fails on Leet testcase 49. I also tried\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"],[\"A\",\"C\"]]\n``` \nbut that seems to be an invalid test case."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[@anwendeng](/anwendeng) My code works too, but it\\'s strange."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I have tested all of your test cases and my program passed!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using  2 tables  to store the info.\nUse hash tables for check-in and travel time info! \nThe programming is easier than a standard design for Hash set!\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Thanks for spoiling the answer for people in reallllllly big font so they don\\'t accidently try to come up with the answer themselves! Real nice of you."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "but bro trust me designing a hash set is highly asked interview problem ...\\nI recalled my concept of how we can store data in hashset..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "## **Don't raise your font at us!**"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/design-underground-system/solutions/3580430/easy-c-python-solutions-with-unordered-map-dict/"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Now people here in discuss section only comment to boost up there reputation."
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "This is an issue here and with almost all of these problems. Using vague or ambiguous names for parameters would never be allowed in enterprise software development. \\'id\\' ? id of what? Argument with name \\'t\\' is it time, train, turn? the code should be explanatory even without the description. Its also a prevalent issue in the editorials and provided solutions. \\n\\nThis is also an accessibility and inclusivity issue. When working on teams where not everyone speaks or has native proficiency in the same language using abbreviations or short hand becomes a huge problem. Leetcode should try and make it\\'s examples as near to what would be expected in a real workplace not a college math class."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me feel bad for jumping over the gates every time I lost my ticket on the way.\nSorry for creating stupid edge cases to handle for some devs somewhere"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Today is a special day for me as I will be getting my first badge of leetcode.\nThrough this one month of solving questions daily, the one thing that I have learnt is nothing matters- not even motivation if you don't have the habit of being consistent throughout the journey. \nI am looking forward to be more consistent.\nHappy coding fellow leetcoders!!!"
                    }
                ]
            },
            {
                "id": 1912156,
                "content": [
                    {
                        "username": "jax_ay",
                        "content": "`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\"] [[],[117077,\"OZ13ZSIN\",42],[117077,\"FU1D57HA\",125],[704903,\"OZ13ZSIN\",211],[911239,\"OZ13ZSIN\",245],[704903,\"HG98HCFL\",340],[859828,\"OZ13ZSIN\",355],[\"OZ13ZSIN\",\"FU1D57HA\"],[911239,\"FU1D57HA\",383],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[859828,\"FU1D57HA\",402],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[363027,\"OZ13ZSIN\",489],[319826,\"OZ13ZSIN\",550],[\"OZ13ZSIN\",\"FU1D57HA\"],[363027,\"HG98HCFL\",565],[319826,\"FU1D57HA\",664],[120084,\"OZ13ZSIN\",735],[\"OZ13ZSIN\",\"HG98HCFL\"],[120084,\"HG98HCFL\",832],[56672,\"OZ13ZSIN\",876],[56672,\"HG98HCFL\",912],[638995,\"OZ13ZSIN\",925],[\"OZ13ZSIN\",\"FU1D57HA\"],[638995,\"FU1D57HA\",951],[712949,\"OZ13ZSIN\",1023],[712949,\"FU1D57HA\",1033],[278482,\"T25R11PB\",1080],[\"OZ13ZSIN\",\"FU1D57HA\"],[278482,\"FU1D57HA\",1160],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[342818,\"4SBAAFIP\",1250],[342818,\"HG98HCFL\",1263],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[415673,\"OZ13ZSIN\",1270],[415673,\"NTNXSB47\",1366],[\"T25R11PB\",\"FU1D57HA\"],[597115,\"4SBAAFIP\",1385],[463555,\"OZ13ZSIN\",1461],[463555,\"HG98HCFL\",1514],[801778,\"OZ13ZSIN\",1537],[201428,\"OZ13ZSIN\",1620],[245538,\"OZ13ZSIN\",1630],[597115,\"FU1D57HA\",1657],[583112,\"OZ13ZSIN\",1690],[\"4SBAAFIP\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[691834,\"OZ13ZSIN\",1723],[250537,\"OZ13ZSIN\",1753],[201428,\"H4UTDCR8\",1804],[691834,\"FU1D57HA\",1838],[\"T25R11PB\",\"FU1D57HA\"],[245538,\"FU1D57HA\",1924],[346824,\"OZ13ZSIN\",1952],[864512,\"OZ13ZSIN\",2005],[499705,\"OZ13ZSIN\",2048],[482469,\"GQINA28A\",2058],[\"OZ13ZSIN\",\"FU1D57HA\"],[583112,\"E35YW0BM\",2080],[\"OZ13ZSIN\",\"HG98HCFL\"],[801778,\"HG98HCFL\",2082],[250415,\"I0Y75MZQ\",2149],[795633,\"OZ13ZSIN\",2196],[\"OZ13ZSIN\",\"HG98HCFL\"],[99144,\"4SBAAFIP\",2219],[83594,\"OZ13ZSIN\",2249],[346824,\"HG98HCFL\",2290],[482469,\"HG98HCFL\",2368],[499705,\"FU1D57HA\",2437],[12539,\"OZ13ZSIN\",2442],[116546,\"OZ13ZSIN\",2493],[884032,\"4SBAAFIP\",2579],[801142,\"OZ13ZSIN\",2598],[795633,\"HG98HCFL\",2693],[83594,\"HG98HCFL\",2782],[529306,\"OZ13ZSIN\",2824],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[286490,\"OZ13ZSIN\",2844],[255488,\"OZ13ZSIN\",2935],[608514,\"OZ13ZSIN\",2984],[116546,\"HG98HCFL\",3079],[250415,\"FU1D57HA\",3174],[\"OZ13ZSIN\",\"FU1D57HA\"],[884032,\"E35YW0BM\",3267],[\"OZ13ZSIN\",\"FU1D57HA\"],[529306,\"HG98HCFL\",3299],[\"OZ13ZSIN\",\"FU1D57HA\"],[892550,\"OZ13ZSIN\",3388],[892550,\"2VVKO5AZ\",3394],[14673,\"OZ13ZSIN\",3487],[\"OZ13ZSIN\",\"HG98HCFL\"],[12539,\"HG98HCFL\",3576],[\"OZ13ZSIN\",\"HG98HCFL\"],[255488,\"HG98HCFL\",3674],[\"OZ13ZSIN\",\"HG98HCFL\"],[14673,\"HG98HCFL\",3754],[864512,\"FU1D57HA\",3819],[451611,\"OZ13ZSIN\",3899],[\"4SBAAFIP\",\"E35YW0BM\"],[451611,\"HG98HCFL\",3941],[250537,\"HG98HCFL\",4027],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[286490,\"FU1D57HA\",4046],[608514,\"HG98HCFL\",4094],[827431,\"XWO403P7\",4107],[99144,\"HG98HCFL\",4136],[\"GQINA28A\",\"HG98HCFL\"],[657832,\"OZ13ZSIN\",4150],[827431,\"HG98HCFL\",4214],[\"OZ13ZSIN\",\"FU1D57HA\"],[658842,\"OZ13ZSIN\",4236],[52933,\"4SBAAFIP\",4325],[801142,\"HG98HCFL\",4413],[52933,\"E35YW0BM\",4460],[331712,\"OZ13ZSIN\",4522],[658842,\"NTNXSB47\",4615],[293734,\"OZ13ZSIN\",4665],[293734,\"HG98HCFL\",4735],[917903,\"OZ13ZSIN\",4772],[119860,\"OZ13ZSIN\",4775],[\"OZ13ZSIN\",\"HG98HCFL\"],[657832,\"E35YW0BM\",4850],[415861,\"NJB0V6ZO\",4881],[\"OZ13ZSIN\",\"FU1D57HA\"],[917903,\"HG98HCFL\",4892],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[415861,\"HG98HCFL\",4919],[\"OZ13ZSIN\",\"HG98HCFL\"],[331712,\"OGVA50NO\",4979],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[119860,\"HG98HCFL\",5034],[469875,\"OZ13ZSIN\",5053],[407362,\"XT14GVGK\",5073],[469875,\"HG98HCFL\",5126],[407362,\"HG98HCFL\",5175],[324747,\"OZ13ZSIN\",5236],[315560,\"OZ13ZSIN\",5333],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[317815,\"OZ13ZSIN\",5339],[906872,\"OZ13ZSIN\",5349],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[404251,\"OZ13ZSIN\",5375],[324747,\"HG98HCFL\",5474],[882572,\"OZ13ZSIN\",5524],[\"OZ13ZSIN\",\"HG98HCFL\"],[758501,\"OZ13ZSIN\",5561],[404251,\"FU1D57HA\",5617],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[315560,\"HG98HCFL\",5651],[758501,\"HG98HCFL\",5673],[141090,\"OZ13ZSIN\",5768],[882572,\"FU1D57HA\",5827],[906872,\"HG98HCFL\",5872],[141090,\"HG98HCFL\",5940],[\"OZ13ZSIN\",\"FU1D57HA\"],[317815,\"HG98HCFL\",5996],[436252,\"OZ13ZSIN\",6027],[\"OZ13ZSIN\",\"E35YW0BM\"],[436252,\"HG98HCFL\",6084],[\"OZ13ZSIN\",\"NTNXSB47\"],[652912,\"NJB0V6ZO\",6155],[652912,\"HG98HCFL\",6169],[269825,\"NJB0V6ZO\",6173],[831024,\"OZ13ZSIN\",6267],[831024,\"FU1D57HA\",6317],[269825,\"FU1D57HA\",6318],[794093,\"OZ13ZSIN\",6406],[\"OZ13ZSIN\",\"HG98HCFL\"],[794093,\"FU1D57HA\",6429],[798558,\"OZ13ZSIN\",6497],[798558,\"E35YW0BM\",6500],[271136,\"NJB0V6ZO\",6582],[\"OZ13ZSIN\",\"HG98HCFL\"],[608446,\"OZ13ZSIN\",6662],[608446,\"FU1D57HA\",6760],[986152,\"OZ13ZSIN\",6799],[986152,\"NTNXSB47\",6825],[271136,\"HG98HCFL\",6911],[\"OZ13ZSIN\",\"FU1D57HA\"],[341349,\"OZ13ZSIN\",6995],[595955,\"OZ13ZSIN\",7039],[58242,\"H9OKZANW\",7071],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[134319,\"OZ13ZSIN\",7119],[595955,\"FU1D57HA\",7161],[\"OZ13ZSIN\",\"HG98HCFL\"],[266781,\"OZ13ZSIN\",7208],[\"OZ13ZSIN\",\"FU1D57HA\"],[266781,\"FU1D57HA\",7298],[\"OZ13ZSIN\",\"NTNXSB47\"],[935757,\"OZ13ZSIN\",7300],[517277,\"OZ13ZSIN\",7376],[58242,\"HG98HCFL\",7459],[\"OZ13ZSIN\",\"HG98HCFL\"],[288203,\"OZ13ZSIN\",7512],[293244,\"T25R11PB\",7580],[517277,\"HG98HCFL\",7588],[293244,\"FU1D57HA\",7649],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[480741,\"OZ13ZSIN\",7748],[288203,\"CWJHORPF\",7845],[935757,\"NTNXSB47\",7940],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[341349,\"HG98HCFL\",7952],[870607,\"ST6XEPDA\",7986],[\"OZ13ZSIN\",\"CWJHORPF\"],[468450,\"6QKM8CM8\",8063],[262669,\"OZ13ZSIN\",8152],[\"OZ13ZSIN\",\"FU1D57HA\"],[103929,\"OZ13ZSIN\",8167],[415331,\"X8W3R0P7\",8215],[134319,\"E35YW0BM\",8226],[415331,\"FU1D57HA\",8240],[468450,\"HG98HCFL\",8263],[394949,\"XOK1HH1Y\",8313],[\"OZ13ZSIN\",\"HG98HCFL\"],[394949,\"FU1D57HA\",8402],[67177,\"GQINA28A\",8451],[67177,\"HG98HCFL\",8521],[796191,\"QJHWOKDQ\",8545],[\"I0Y75MZQ\",\"FU1D57HA\"],[\"H9OKZANW\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[940010,\"OZ13ZSIN\",8583],[940010,\"VL50N6D1\",8613],[21260,\"WGOD5SD4\",8683],[746866,\"NJB0V6ZO\",8732],[47896,\"OZ13ZSIN\",8802],[480741,\"CWJHORPF\",8839],[\"NJB0V6ZO\",\"HG98HCFL\"],[310852,\"XT82S77E\",8858],[796001,\"OZ13ZSIN\",8860],[\"OZ13ZSIN\",\"NTNXSB47\"],[103929,\"FU1D57HA\",8957],[739455,\"OZ13ZSIN\",8980],[\"XWO403P7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"VL50N6D1\"],[734337,\"OZ13ZSIN\",8989],[686615,\"4SBAAFIP\",9086],[21260,\"HG98HCFL\",9130],[\"OZ13ZSIN\",\"CWJHORPF\"],[217165,\"1XW6HVBY\",9228],[689774,\"OZ13ZSIN\",9313],[870607,\"NTNXSB47\",9319],[248471,\"OZ13ZSIN\",9376],[262669,\"E35YW0BM\",9427],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[20582,\"OZ13ZSIN\",9484],[310852,\"LBYS94AD\",9535],[746866,\"FU1D57HA\",9540],[689774,\"FU1D57HA\",9594],[796191,\"HG98HCFL\",9635],[\"OZ13ZSIN\",\"FU1D57HA\"],[734337,\"HG98HCFL\",9683],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[982523,\"XWO403P7\",9689],[\"OZ13ZSIN\",\"OGVA50NO\"],[982523,\"HG98HCFL\",9786],[796001,\"FU1D57HA\",9869],[248471,\"FU1D57HA\",9942],[187843,\"OZ13ZSIN\",10035],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"H9OKZANW\",\"HG98HCFL\"],[217165,\"HG98HCFL\",10100],[739455,\"HG98HCFL\",10171],[187843,\"HG98HCFL\",10226],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[20582,\"E35YW0BM\",10322],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"SAIV20VG\",10342],[\"OZ13ZSIN\",\"FU1D57HA\"],[686615,\"HG98HCFL\",10396],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"CAWYGMWL\",10402],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[800300,\"OZ13ZSIN\",10472],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"NTNXSB47\",10485],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[800300,\"HG98HCFL\",10545],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"FU1D57HA\",10581],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[47896,\"NTNXSB47\",10588],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[788823,\"83OEBTCQ\",10599],[\"CAWYGMWL\",\"NTNXSB47\"],[365416,\"OZ13ZSIN\",10690],[610273,\"OZ13ZSIN\",10757],[988219,\"FWUZEALC\",10767],[\"XT14GVGK\",\"HG98HCFL\"],[910256,\"OZ13ZSIN\",10797],[\"OZ13ZSIN\",\"CWJHORPF\"],[610273,\"FU1D57HA\",10848],[\"OZ13ZSIN\",\"FU1D57HA\"],[910256,\"HMJCZQ0K\",10920],[\"OZ13ZSIN\",\"NTNXSB47\"],[988219,\"HG98HCFL\",10930],[365416,\"HG98HCFL\",10972],[219722,\"OZ13ZSIN\",11033],[295336,\"ITA0GE26\",11107],[219722,\"R62MQ4FI\",11131],[295336,\"FU1D57HA\",11140],[788823,\"0BIIAVNU\",11199],[620927,\"T25R11PB\",11274],[620927,\"FU1D57HA\",11371],[630168,\"OZ13ZSIN\",11448],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[112534,\"OZ13ZSIN\",11449],[573142,\"OZ13ZSIN\",11546],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[454282,\"NJB0V6ZO\",11576],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[454282,\"HG98HCFL\",11643],[444090,\"6QKM8CM8\",11698],[630168,\"Y43BFD6U\",11717],[185093,\"1XW6HVBY\",11723],[217806,\"4SBAAFIP\",11814],[\"XOK1HH1Y\",\"FU1D57HA\"],[573142,\"FU1D57HA\",11874],[661431,\"UT8S3IM6\",11907],[335406,\"OZ13ZSIN\",11942],[\"T25R11PB\",\"FU1D57HA\"],[444090,\"HG98HCFL\",11995],[896969,\"QJHWOKDQ\",12032],[950584,\"NJB0V6ZO\",12097],[570450,\"NJB0V6ZO\",12128],[896969,\"HG98HCFL\",12146],[71637,\"4SBAAFIP\",12202],[923844,\"OZ13ZSIN\",12277],[\"NJB0V6ZO\",\"HG98HCFL\"],[374491,\"OZ13ZSIN\",12300],[333698,\"1XW6HVBY\",12343],[323202,\"4SBAAFIP\",12369],[489161,\"OZ13ZSIN\",12419],[489161,\"BMN7MUED\",12446],[177905,\"XOK1HH1Y\",12483],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[185093,\"FU1D57HA\",12520],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"OZ13ZSIN\",12538],[765285,\"OZ13ZSIN\",12554],[\"OZ13ZSIN\",\"VL50N6D1\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[80760,\"XOK1HH1Y\",12613],[570450,\"R47UH9EC\",12643],[777227,\"OZ13ZSIN\",12717],[30391,\"XQ8MRL86\",12743],[923844,\"NTNXSB47\",12843],[\"OZ13ZSIN\",\"HG98HCFL\"],[177905,\"HG98HCFL\",12901],[374491,\"2Z3A0H6F\",12957],[950584,\"7IO8ET8F\",13035],[\"1XW6HVBY\",\"HG98HCFL\"],[636717,\"WY85FIVE\",13122],[661431,\"L6KOAIR1\",13154],[80760,\"XIUOFK2Y\",13215],[\"OZ13ZSIN\",\"HG98HCFL\"],[428110,\"4SBAAFIP\",13262],[\"H9OKZANW\",\"HG98HCFL\"],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"83OEBTCQ\",\"0BIIAVNU\"],[502345,\"1MOLNL46\",13324],[112534,\"HG98HCFL\",13393],[\"OZ13ZSIN\",\"HG98HCFL\"],[25332,\"OZ13ZSIN\",13487],[240072,\"OZ13ZSIN\",13504],[649981,\"ITA0GE26\",13603],[363027,\"NJB0V6ZO\",13627],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"FU1D57HA\",13724],[961598,\"ST6XEPDA\",13810],[75634,\"ZWJJHOU3\",13877],[807547,\"OZ13ZSIN\",13900],[\"OZ13ZSIN\",\"FU1D57HA\"],[71637,\"HG98HCFL\",13998],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[300645,\"OZ13ZSIN\",14033],[849654,\"OZ13ZSIN\",14128],[701073,\"GQINA28A\",14209],[288997,\"WGOD5SD4\",14252],[7101,\"OZ13ZSIN\",14258],[143698,\"SH04ZH5G\",14355],[849654,\"HG98HCFL\",14395],[300645,\"RBRIS3JS\",14484],[171052,\"OZ13ZSIN\",14576],[214567,\"NJB0V6ZO\",14592],[961598,\"JYTPXJK9\",14646],[132966,\"4SR0921V\",14665],[822925,\"4SBAAFIP\",14742],[333698,\"HG98HCFL\",14835],[\"OZ13ZSIN\",\"HG98HCFL\"],[822925,\"E35YW0BM\",14920],[777227,\"HG98HCFL\",15017],[123308,\"OZ13ZSIN\",15095],[598091,\"6QKM8CM8\",15150],[363027,\"HG98HCFL\",15160],[912565,\"OZ13ZSIN\",15202],[93990,\"1XW6HVBY\",15291],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[25332,\"FU1D57HA\",15332],[143698,\"HG98HCFL\",15380],[502345,\"DYLQ657K\",15429],[171052,\"HG98HCFL\",15436],[\"1XW6HVBY\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[217806,\"FU1D57HA\",15469],[487305,\"5D5SUJ4Q\",15499],[44397,\"6QKM8CM8\",15536],[601607,\"XOK1HH1Y\",15566],[30391,\"HG98HCFL\",15586],[\"OZ13ZSIN\",\"OGVA50NO\"],[765285,\"IX7LS60B\",15641],[788097,\"T25R11PB\",15730],[300198,\"6TED6G4E\",15774],[529964,\"OZ13ZSIN\",15793],[803049,\"IEQICIHL\",15826],[\"OZ13ZSIN\",\"HG98HCFL\"],[7101,\"DKN9PRYJ\",15869],[\"T25R11PB\",\"FU1D57HA\"],[761575,\"D5TNGKU7\",15885],[93990,\"HG98HCFL\",15894],[323202,\"HG98HCFL\",15898],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"OZ13ZSIN\",15990],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"OGVA50NO\"],[213297,\"OZ13ZSIN\",16034],[300198,\"HG98HCFL\",16105],[912565,\"HG98HCFL\",16175],[806824,\"NJB0V6ZO\",16274],[417297,\"OZ13ZSIN\",16334],[\"XQ8MRL86\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[690271,\"GQINA28A\",16427],[540402,\"OZ13ZSIN\",16500],[807547,\"FU1D57HA\",16504],[335406,\"HG98HCFL\",16539],[417297,\"HG98HCFL\",16618],[192719,\"QB05LSRK\",16711],[255839,\"OZ13ZSIN\",16755],[\"OZ13ZSIN\",\"BMN7MUED\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[711297,\"OZ13ZSIN\",16810],[\"OZ13ZSIN\",\"CWJHORPF\"],[711297,\"HG98HCFL\",16899],[211279,\"VL2TL1NM\",16907],[\"XT14GVGK\",\"HG98HCFL\"],[\"XWO403P7\",\"HG98HCFL\"],[213297,\"FU1D57HA\",16964],[44397,\"7JHO6FK0\",17021],[\"4SBAAFIP\",\"HG98HCFL\"],[75634,\"H4UTDCR8\",17075],[996616,\"JYLXUII8\",17167],[775204,\"ZZLR3YVJ\",17215],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[211106,\"6TED6G4E\",17217],[649981,\"HG98HCFL\",17236],[775204,\"HG98HCFL\",17246],[806824,\"HG98HCFL\",17313],[214567,\"GWJB6BU5\",17411],[487305,\"FU1D57HA\",17496],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[237574,\"GA4KQD8H\",17572],[863199,\"OZ13ZSIN\",17616],[921800,\"OZ13ZSIN\",17693],[415592,\"NJB0V6ZO\",17784],[788097,\"FU1D57HA\",17844],[79918,\"ZR7QN32O\",17930],[240072,\"HG98HCFL\",17938],[\"OZ13ZSIN\",\"HG98HCFL\"],[253649,\"OZ13ZSIN\",17981],[545511,\"OZ13ZSIN\",18005],[237574,\"FU1D57HA\",18089],[\"OZ13ZSIN\",\"NTNXSB47\"],[255839,\"HG98HCFL\",18169],[701073,\"HJXEGP9U\",18269],[598091,\"FU1D57HA\",18287],[\"OZ13ZSIN\",\"HG98HCFL\"],[540402,\"HG98HCFL\",18349],[887853,\"GA4KQD8H\",18417],[\"XT82S77E\",\"LBYS94AD\"],[863199,\"HG98HCFL\",18484],[\"OZ13ZSIN\",\"HG98HCFL\"],[127768,\"OZ13ZSIN\",18571],[872173,\"OZ13ZSIN\",18579],[\"OZ13ZSIN\",\"HG98HCFL\"],[872173,\"UB4KML0J\",18638],[428110,\"HG98HCFL\",18720],[\"ITA0GE26\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[85526,\"OZ13ZSIN\",18803],[123308,\"HG98HCFL\",18872],[273723,\"FJVIO218\",18884],[\"OZ13ZSIN\",\"FU1D57HA\"],[716950,\"OZ13ZSIN\",18916],[436026,\"OZ13ZSIN\",18922],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[127768,\"FU1D57HA\",18931],[646079,\"IMDG88XX\",18944],[784931,\"OZ13ZSIN\",19001],[\"OZ13ZSIN\",\"OGVA50NO\"],[\"OZ13ZSIN\",\"H4UTDCR8\"],[803049,\"RPKD08C6\",19041],[627595,\"MBY9ZG7D\",19129],[386653,\"BMX2AIY5\",19179],[\"OZ13ZSIN\",\"CWJHORPF\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[211106,\"HG98HCFL\",19251],[855448,\"OZ13ZSIN\",19300],[733785,\"SPVKZTIP\",19344],[\"XOK1HH1Y\",\"HG98HCFL\"],[761575,\"HG98HCFL\",19444],[\"OZ13ZSIN\",\"HG98HCFL\"],[132966,\"H4UTDCR8\",19503],[948005,\"OZ13ZSIN\",19520],[14408,\"OZ13ZSIN\",19594],[\"I0Y75MZQ\",\"FU1D57HA\"],[85526,\"NTNXSB47\",19687],[211403,\"OZ13ZSIN\",19761],[677411,\"OZ13ZSIN\",19852],[192719,\"HG98HCFL\",19905],[887853,\"HG98HCFL\",19975],[455474,\"OZ13ZSIN\",20002],[601607,\"FU1D57HA\",20077],[14408,\"HG98HCFL\",20150],[\"OZ13ZSIN\",\"DKN9PRYJ\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[253649,\"1QLZUAXZ\",20166],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[548975,\"OZ13ZSIN\",20232],[386653,\"1QLZUAXZ\",20277],[415592,\"HG98HCFL\",20318],[716950,\"3ZJ18VKA\",20384],[84268,\"OZ13ZSIN\",20392],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[55374,\"4SBAAFIP\",20416],[851948,\"OZ13ZSIN\",20503],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"OZ13ZSIN\",20513],[615192,\"OZ13ZSIN\",20551],[851948,\"HG98HCFL\",20631],[211403,\"HG98HCFL\",20668],[677411,\"OGVA50NO\",20715],[55374,\"FU1D57HA\",20749],[457056,\"OZ13ZSIN\",20799],[\"XOK1HH1Y\",\"FU1D57HA\"],[548975,\"HG98HCFL\",20836],[41381,\"MY3O8OQI\",20908],[950414,\"OZ13ZSIN\",20971],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[873337,\"OZ13ZSIN\",21038],[\"5D5SUJ4Q\",\"FU1D57HA\"],[273723,\"FU1D57HA\",21053],[726970,\"OZ13ZSIN\",21070],[\"OZ13ZSIN\",\"HG98HCFL\"],[211279,\"HG98HCFL\",21127],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[276902,\"4T1TBZX5\",21160],[\"OZ13ZSIN\",\"HG98HCFL\"],[183959,\"OZ13ZSIN\",21209],[488167,\"OZ13ZSIN\",21250],[\"OZ13ZSIN\",\"HG98HCFL\"],[166180,\"OZ13ZSIN\",21323],[\"FJVIO218\",\"FU1D57HA\"],[636717,\"UB4KML0J\",21366],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"DLUQBV4V\",21413],[\"OZ13ZSIN\",\"FU1D57HA\"],[528132,\"LUCPET9G\",21476],[206116,\"0MOLP3NC\",21551],[183959,\"XPM6JMBR\",21562],[\"OZ13ZSIN\",\"HG98HCFL\"],[553646,\"BMX2AIY5\",21661],[\"OZ13ZSIN\",\"DLUQBV4V\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"SH04ZH5G\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"R62MQ4FI\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[724508,\"C00L36RI\",21665],[950414,\"FU1D57HA\",21721],[102566,\"NJB0V6ZO\",21819],[690271,\"HG98HCFL\",21829],[\"OZ13ZSIN\",\"HG98HCFL\"],[386570,\"OZ13ZSIN\",21870],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[733785,\"FU1D57HA\",21931],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"ZWJJHOU3\",\"H4UTDCR8\"],[493080,\"OZ13ZSIN\",21957],[\"OZ13ZSIN\",\"RBRIS3JS\"],[476818,\"NJB0V6ZO\",22018],[\"OZ13ZSIN\",\"HG98HCFL\"],[646079,\"VMT100K8\",22076],[873337,\"E35YW0BM\",22080],[529964,\"FU1D57HA\",22162],[41381,\"FU1D57HA\",22233],[\"1XW6HVBY\",\"HG98HCFL\"],[\"IMDG88XX\",\"VMT100K8\"],[724508,\"JYTPXJK9\",22301],[\"OZ13ZSIN\",\"FU1D57HA\"],[276768,\"OZ13ZSIN\",22339],[654375,\"1XW6HVBY\",22349],[276768,\"X1H2W3W0\",22438],[\"OZ13ZSIN\",\"UB4KML0J\"],[855448,\"KSOIJA62\",22533],[493080,\"FU1D57HA\",22554],[726970,\"E35YW0BM\",22603],[\"4SR0921V\",\"H4UTDCR8\"],[79918,\"R62MQ4FI\",22640],[659224,\"OZ13ZSIN\",22739],[436026,\"L6KOAIR1\",22770],[288997,\"E35YW0BM\",22850],[\"SAIV20VG\",\"FU1D57HA\"],[553646,\"FU1D57HA\",22946],[659224,\"NTNXSB47\",22957],[615192,\"HG98HCFL\",23056],[\"OZ13ZSIN\",\"E35YW0BM\"],[730441,\"1XW6HVBY\",23129],[55790,\"OZ13ZSIN\",23179],[524967,\"OZ13ZSIN\",23189],[44097,\"2GRLB4CN\",23280],[784931,\"E35YW0BM\",23343],[525825,\"OZ13ZSIN\",23384],[315479,\"XQ8MRL86\",23386],[537074,\"OZ13ZSIN\",23437],[\"XT82S77E\",\"LBYS94AD\"],[524967,\"7JIXF9D1\",23496],[559244,\"OZ13ZSIN\",23569],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[872522,\"FJVIO218\",23579],[160528,\"DE386QWN\",23602],[\"4SBAAFIP\",\"HG98HCFL\"],[832697,\"OZ13ZSIN\",23696],[439436,\"NJB0V6ZO\",23749],[559244,\"MJZC0DI0\",23811],[38958,\"4SBAAFIP\",23863],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[327722,\"OZ13ZSIN\",23901],[243726,\"OZ13ZSIN\",23955],[38958,\"WUIGDE36\",24007],[832697,\"4IBLBVYU\",24058],[626392,\"QK3YTSXO\",24064],[640646,\"OZ13ZSIN\",24084],[476818,\"R5XHXCAN\",24129],[13070,\"NJB0V6ZO\",24190],[\"VL2TL1NM\",\"HG98HCFL\"],[633159,\"GQYWQW84\",24235],[528132,\"MPBZFLN9\",24236],[668517,\"OZ13ZSIN\",24307],[627595,\"HG98HCFL\",24343],[\"OZ13ZSIN\",\"HG98HCFL\"],[438428,\"PQOMFBOJ\",24350],[386570,\"FU1D57HA\",24413],[668517,\"7JHO6FK0\",24482],[561608,\"2IVTIGII\",24575],[539280,\"ITA0GE26\",24660],[160528,\"7IO8ET8F\",24668],[\"T25R11PB\",\"FU1D57HA\"],[626392,\"FU1D57HA\",24755],[\"4SBAAFIP\",\"WUIGDE36\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[251034,\"4SBAAFIP\",24786],[968259,\"OZ13ZSIN\",24870],[640646,\"I9H1UDG4\",24892],[361979,\"OZ13ZSIN\",24945],[806004,\"WPM57THK\",25006],[488167,\"VL50N6D1\",25009],[\"XT82S77E\",\"LBYS94AD\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[\"XQ8MRL86\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HMJCZQ0K\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[787728,\"OZ13ZSIN\",25084],[95528,\"OZ13ZSIN\",25154],[825321,\"4SBAAFIP\",25200],[\"OZ13ZSIN\",\"HG98HCFL\"],[968259,\"HG98HCFL\",25234],[\"NJB0V6ZO\",\"HG98HCFL\"],[537074,\"2Z3A0H6F\",25283],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"1QLZUAXZ\"],[430837,\"ZOA7MKHB\",25342],[588541,\"OZ13ZSIN\",25380],[\"OZ13ZSIN\",\"HG98HCFL\"],[276902,\"FU1D57HA\",25448],[787728,\"BMN7MUED\",25495],[590184,\"KFRF7AEZ\",25577],[\"LUCPET9G\",\"MPBZFLN9\"],[510551,\"OZ13ZSIN\",25597],[806004,\"HG98HCFL\",25608],[925378,\"T25R11PB\",25614],[27187,\"NJB0V6ZO\",25651],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"DE386QWN\",25682],[525825,\"IX7LS60B\",25695],[876351,\"1XW6HVBY\",25761],[225487,\"SPVKZTIP\",25783],[159468,\"OZ13ZSIN\",25784],[785370,\"BMX2AIY5\",25819],[159468,\"FU1D57HA\",25847],[822091,\"1XW6HVBY\",25911],[142228,\"OZ13ZSIN\",25962],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"HG98HCFL\",25997],[6026,\"WPM57THK\",26000],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"J1X7TLQD\",26041],[42555,\"D5TNGKU7\",26042],[921331,\"XOK1HH1Y\",26066],[95528,\"GWVJKDKT\",26130],[361979,\"CWWVVCGZ\",26183],[747281,\"OZ13ZSIN\",26197],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"NJB0V6ZO\",\"7IO8ET8F\"],[590184,\"FY86VG9O\",26248],[443593,\"6TED6G4E\",26254],[921331,\"IVDGXU4R\",26354],[184691,\"XOK1HH1Y\",26394],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"D5TNGKU7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[997488,\"OZ13ZSIN\",26468],[161852,\"OZ13ZSIN\",26476],[42555,\"HG98HCFL\",26505],[948005,\"88RO58CG\",26517],[499506,\"ITA0GE26\",26545],[\"OZ13ZSIN\",\"FU1D57HA\"],[654375,\"FU1D57HA\",26593],[999272,\"OZ13ZSIN\",26641],[\"OZ13ZSIN\",\"FU1D57HA\"],[788492,\"OZ13ZSIN\",26738],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"4SBAAFIP\",\"E35YW0BM\"],[327722,\"HG98HCFL\",26780],[499506,\"GWVJKDKT\",26878],[825321,\"HG98HCFL\",26973],[\"CAWYGMWL\",\"NTNXSB47\"],[606855,\"C00L36RI\",26996],[498054,\"OZ13ZSIN\",27025],[455474,\"7JHO6FK0\",27070],[911613,\"OZ13ZSIN\",27170],[693354,\"O77WFMCI\",27225],[\"OZ13ZSIN\",\"HG98HCFL\"],[483609,\"G2LO9U87\",27250],[\"D5TNGKU7\",\"HG98HCFL\"],[914704,\"OZ13ZSIN\",27252],[835356,\"OZ13ZSIN\",27277],[\"XOK1HH1Y\",\"HG98HCFL\"],[243726,\"2Z3A0H6F\",27330],[788492,\"HG98HCFL\",27409],[\"FJVIO218\",\"FU1D57HA\"],[730441,\"HG98HCFL\",27465],[418199,\"OZ13ZSIN\",27557],[\"NJB0V6ZO\",\"HG98HCFL\"],[416184,\"X8W3R0P7\",27576],[177447,\"GQINA28A\",27661],[27187,\"Q6L1ZD92\",27684],[53005,\"MY3O8OQI\",27746],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[835356,\"HG98HCFL\",27775],[88784,\"NJB0V6ZO\",27865],[747281,\"HG98HCFL\",27921],[\"OZ13ZSIN\",\"HG98HCFL\"],[184691,\"CWWVVCGZ\",27974],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[554716,\"OZ13ZSIN\",28020],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"FU1D57HA\",28107],[\"ZR7QN32O\",\"R62MQ4FI\"],[326091,\"XOK1HH1Y\",28151],[927316,\"OZ13ZSIN\",28193],[\"T25R11PB\",\"FU1D57HA\"],[499875,\"NJB0V6ZO\",28256],[590013,\"OZ13ZSIN\",28354],[62740,\"OZ13ZSIN\",28413],[876351,\"FU1D57HA\",28469],[749462,\"OZ13ZSIN\",28525],[\"5D5SUJ4Q\",\"FU1D57HA\"],[996616,\"OGVA50NO\",28553],[177447,\"CWWVVCGZ\",28572],[\"OZ13ZSIN\",\"FU1D57HA\"],[438428,\"L6KOAIR1\",28631],[693354,\"DLUQBV4V\",28663],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[880171,\"475J29EI\",28754],[588541,\"1YA7XTV9\",28760],[457056,\"HG98HCFL\",28762],[\"OZ13ZSIN\",\"VL50N6D1\"],[84268,\"HG98HCFL\",28792],[130492,\"IMDG88XX\",28832],[163069,\"FWUZEALC\",28840],[\"C00L36RI\",\"JYTPXJK9\"],[417559,\"BMX2AIY5\",28890],[\"OZ13ZSIN\",\"HG98HCFL\"],[914704,\"FU1D57HA\",28939],[55617,\"VL2TL1NM\",28974],[\"4SBAAFIP\",\"E35YW0BM\"],[911613,\"FU1D57HA\",29069],[880171,\"HG98HCFL\",29099],[\"OZ13ZSIN\",\"FU1D57HA\"],[117275,\"4SBAAFIP\",29174],[822091,\"FU1D57HA\",29206],[775394,\"XQ8MRL86\",29284],[917846,\"4SBAAFIP\",29288],[55790,\"0NYQFXYO\",29343],[\"83OEBTCQ\",\"0BIIAVNU\"],[416184,\"HG98HCFL\",29415],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"FJVIO218\",\"FU1D57HA\"],[228425,\"OZ13ZSIN\",29438],[\"CAWYGMWL\",\"NTNXSB47\"],[87834,\"OZ13ZSIN\",29442],[633159,\"WMTPA7JN\",29482],[322118,\"OZ13ZSIN\",29526],[\"1XW6HVBY\",\"FU1D57HA\"],[675060,\"K9D63ZZC\",29617],[225487,\"RPKD08C6\",29691],[708687,\"OZ13ZSIN\",29761],[836854,\"OZ13ZSIN\",29845],[\"6QKM8CM8\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[299466,\"4SBAAFIP\",29860],[\"WGOD5SD4\",\"E35YW0BM\"],[\"X8W3R0P7\",\"FU1D57HA\"],[927316,\"HG98HCFL\",29938],[483609,\"HG98HCFL\",29995],[\"C00L36RI\",\"JYTPXJK9\"],[\"OZ13ZSIN\",\"L6KOAIR1\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"HG98HCFL\",30054],[870611,\"72Q6VPM1\",30066],[754460,\"4SBAAFIP\",30086],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[979711,\"OZ13ZSIN\",30112],[322118,\"EY70T3I1\",30197],[696824,\"ZWJJHOU3\",30263],[239811,\"WGOD5SD4\",30361],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"475J29EI\",\"HG98HCFL\"],[963752,\"1XW6HVBY\",30399],[764562,\"OZ13ZSIN\",30480],[165422,\"XQ8MRL86\",30559],[282372,\"2MKY7B5Q\",30609],[554716,\"HG98HCFL\",30700],[925378,\"HG98HCFL\",30705],[836854,\"UB4KML0J\",30802],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[328085,\"PYU6IFCW\",30865],[999272,\"NTNXSB47\",30884],[510551,\"HG98HCFL\",30903],[87834,\"HG98HCFL\",30918],[590013,\"HG98HCFL\",30950],[775394,\"MPBZFLN9\",30963],[701078,\"OZ13ZSIN\",31024],[561608,\"WIXJ6Z00\",31082],[\"OZ13ZSIN\",\"HG98HCFL\"],[328085,\"FU1D57HA\",31132],[165422,\"HG98HCFL\",31226],[997488,\"HG98HCFL\",31249],[785370,\"FY86VG9O\",31334],[186553,\"6GPMXUYZ\",31378],[282372,\"FU1D57HA\",31454],[88784,\"WMTPA7JN\",31484],[186637,\"973PO4KY\",31528],[62740,\"HG98HCFL\",31561],[206116,\"CWWVVCGZ\",31653],[525469,\"OZ13ZSIN\",31705],[\"OZ13ZSIN\",\"CWWVVCGZ\"],[109318,\"OZ13ZSIN\",31719],[954915,\"WS49LJP8\",31776],[\"OZ13ZSIN\",\"FU1D57HA\"],[166180,\"FU1D57HA\",31824],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"MY3O8OQI\",\"FU1D57HA\"],[539280,\"YZ8LNY1V\",31843],[\"OZ13ZSIN\",\"UB4KML0J\"],[901923,\"OZ13ZSIN\",31865],[963752,\"VMT100K8\",31918],[239811,\"HG98HCFL\",31990]]` wtf is this testcase bro \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "i feel stupid that i opened ur comment. LoL ! it took forever to scroll down"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "resolved ? me also getting error in this test case"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The May badge was not an easy one! Guys let\\'s get this done!!!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Yay!"
                    },
                    {
                        "username": "omeraktepe",
                        "content": "There is a test case that does not meet assumptions. \nTest case 56: [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]] \n\nIt violetes followings: \n1. A customer can only be checked into one place at a time. \n2. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order. \n\nI am too lazy to report though :)"
                    },
                    {
                        "username": "zavojchevski",
                        "content": "I agree on this, restrictions should be well explained. "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "For those failing test case 51:\\n\"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\"\\nCredit to xuawai for noticing this back in 2020."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Restrictions should be written stricter. Some strange cases which are valid:\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@psionl0](/psionl0) \\'getAverageTime\\' arguments are invalid: "
                    },
                    {
                        "username": "psionl0",
                        "content": "All your test cases work on my code but it fails on Leet testcase 49. I also tried\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"],[\"A\",\"C\"]]\n``` \nbut that seems to be an invalid test case."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[@anwendeng](/anwendeng) My code works too, but it\\'s strange."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I have tested all of your test cases and my program passed!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using  2 tables  to store the info.\nUse hash tables for check-in and travel time info! \nThe programming is easier than a standard design for Hash set!\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Thanks for spoiling the answer for people in reallllllly big font so they don\\'t accidently try to come up with the answer themselves! Real nice of you."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "but bro trust me designing a hash set is highly asked interview problem ...\\nI recalled my concept of how we can store data in hashset..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "## **Don't raise your font at us!**"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/design-underground-system/solutions/3580430/easy-c-python-solutions-with-unordered-map-dict/"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Now people here in discuss section only comment to boost up there reputation."
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "This is an issue here and with almost all of these problems. Using vague or ambiguous names for parameters would never be allowed in enterprise software development. \\'id\\' ? id of what? Argument with name \\'t\\' is it time, train, turn? the code should be explanatory even without the description. Its also a prevalent issue in the editorials and provided solutions. \\n\\nThis is also an accessibility and inclusivity issue. When working on teams where not everyone speaks or has native proficiency in the same language using abbreviations or short hand becomes a huge problem. Leetcode should try and make it\\'s examples as near to what would be expected in a real workplace not a college math class."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me feel bad for jumping over the gates every time I lost my ticket on the way.\nSorry for creating stupid edge cases to handle for some devs somewhere"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Today is a special day for me as I will be getting my first badge of leetcode.\nThrough this one month of solving questions daily, the one thing that I have learnt is nothing matters- not even motivation if you don't have the habit of being consistent throughout the journey. \nI am looking forward to be more consistent.\nHappy coding fellow leetcoders!!!"
                    }
                ]
            },
            {
                "id": 1912115,
                "content": [
                    {
                        "username": "jax_ay",
                        "content": "`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\"] [[],[117077,\"OZ13ZSIN\",42],[117077,\"FU1D57HA\",125],[704903,\"OZ13ZSIN\",211],[911239,\"OZ13ZSIN\",245],[704903,\"HG98HCFL\",340],[859828,\"OZ13ZSIN\",355],[\"OZ13ZSIN\",\"FU1D57HA\"],[911239,\"FU1D57HA\",383],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[859828,\"FU1D57HA\",402],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[363027,\"OZ13ZSIN\",489],[319826,\"OZ13ZSIN\",550],[\"OZ13ZSIN\",\"FU1D57HA\"],[363027,\"HG98HCFL\",565],[319826,\"FU1D57HA\",664],[120084,\"OZ13ZSIN\",735],[\"OZ13ZSIN\",\"HG98HCFL\"],[120084,\"HG98HCFL\",832],[56672,\"OZ13ZSIN\",876],[56672,\"HG98HCFL\",912],[638995,\"OZ13ZSIN\",925],[\"OZ13ZSIN\",\"FU1D57HA\"],[638995,\"FU1D57HA\",951],[712949,\"OZ13ZSIN\",1023],[712949,\"FU1D57HA\",1033],[278482,\"T25R11PB\",1080],[\"OZ13ZSIN\",\"FU1D57HA\"],[278482,\"FU1D57HA\",1160],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[342818,\"4SBAAFIP\",1250],[342818,\"HG98HCFL\",1263],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[415673,\"OZ13ZSIN\",1270],[415673,\"NTNXSB47\",1366],[\"T25R11PB\",\"FU1D57HA\"],[597115,\"4SBAAFIP\",1385],[463555,\"OZ13ZSIN\",1461],[463555,\"HG98HCFL\",1514],[801778,\"OZ13ZSIN\",1537],[201428,\"OZ13ZSIN\",1620],[245538,\"OZ13ZSIN\",1630],[597115,\"FU1D57HA\",1657],[583112,\"OZ13ZSIN\",1690],[\"4SBAAFIP\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[691834,\"OZ13ZSIN\",1723],[250537,\"OZ13ZSIN\",1753],[201428,\"H4UTDCR8\",1804],[691834,\"FU1D57HA\",1838],[\"T25R11PB\",\"FU1D57HA\"],[245538,\"FU1D57HA\",1924],[346824,\"OZ13ZSIN\",1952],[864512,\"OZ13ZSIN\",2005],[499705,\"OZ13ZSIN\",2048],[482469,\"GQINA28A\",2058],[\"OZ13ZSIN\",\"FU1D57HA\"],[583112,\"E35YW0BM\",2080],[\"OZ13ZSIN\",\"HG98HCFL\"],[801778,\"HG98HCFL\",2082],[250415,\"I0Y75MZQ\",2149],[795633,\"OZ13ZSIN\",2196],[\"OZ13ZSIN\",\"HG98HCFL\"],[99144,\"4SBAAFIP\",2219],[83594,\"OZ13ZSIN\",2249],[346824,\"HG98HCFL\",2290],[482469,\"HG98HCFL\",2368],[499705,\"FU1D57HA\",2437],[12539,\"OZ13ZSIN\",2442],[116546,\"OZ13ZSIN\",2493],[884032,\"4SBAAFIP\",2579],[801142,\"OZ13ZSIN\",2598],[795633,\"HG98HCFL\",2693],[83594,\"HG98HCFL\",2782],[529306,\"OZ13ZSIN\",2824],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[286490,\"OZ13ZSIN\",2844],[255488,\"OZ13ZSIN\",2935],[608514,\"OZ13ZSIN\",2984],[116546,\"HG98HCFL\",3079],[250415,\"FU1D57HA\",3174],[\"OZ13ZSIN\",\"FU1D57HA\"],[884032,\"E35YW0BM\",3267],[\"OZ13ZSIN\",\"FU1D57HA\"],[529306,\"HG98HCFL\",3299],[\"OZ13ZSIN\",\"FU1D57HA\"],[892550,\"OZ13ZSIN\",3388],[892550,\"2VVKO5AZ\",3394],[14673,\"OZ13ZSIN\",3487],[\"OZ13ZSIN\",\"HG98HCFL\"],[12539,\"HG98HCFL\",3576],[\"OZ13ZSIN\",\"HG98HCFL\"],[255488,\"HG98HCFL\",3674],[\"OZ13ZSIN\",\"HG98HCFL\"],[14673,\"HG98HCFL\",3754],[864512,\"FU1D57HA\",3819],[451611,\"OZ13ZSIN\",3899],[\"4SBAAFIP\",\"E35YW0BM\"],[451611,\"HG98HCFL\",3941],[250537,\"HG98HCFL\",4027],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[286490,\"FU1D57HA\",4046],[608514,\"HG98HCFL\",4094],[827431,\"XWO403P7\",4107],[99144,\"HG98HCFL\",4136],[\"GQINA28A\",\"HG98HCFL\"],[657832,\"OZ13ZSIN\",4150],[827431,\"HG98HCFL\",4214],[\"OZ13ZSIN\",\"FU1D57HA\"],[658842,\"OZ13ZSIN\",4236],[52933,\"4SBAAFIP\",4325],[801142,\"HG98HCFL\",4413],[52933,\"E35YW0BM\",4460],[331712,\"OZ13ZSIN\",4522],[658842,\"NTNXSB47\",4615],[293734,\"OZ13ZSIN\",4665],[293734,\"HG98HCFL\",4735],[917903,\"OZ13ZSIN\",4772],[119860,\"OZ13ZSIN\",4775],[\"OZ13ZSIN\",\"HG98HCFL\"],[657832,\"E35YW0BM\",4850],[415861,\"NJB0V6ZO\",4881],[\"OZ13ZSIN\",\"FU1D57HA\"],[917903,\"HG98HCFL\",4892],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[415861,\"HG98HCFL\",4919],[\"OZ13ZSIN\",\"HG98HCFL\"],[331712,\"OGVA50NO\",4979],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[119860,\"HG98HCFL\",5034],[469875,\"OZ13ZSIN\",5053],[407362,\"XT14GVGK\",5073],[469875,\"HG98HCFL\",5126],[407362,\"HG98HCFL\",5175],[324747,\"OZ13ZSIN\",5236],[315560,\"OZ13ZSIN\",5333],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[317815,\"OZ13ZSIN\",5339],[906872,\"OZ13ZSIN\",5349],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[404251,\"OZ13ZSIN\",5375],[324747,\"HG98HCFL\",5474],[882572,\"OZ13ZSIN\",5524],[\"OZ13ZSIN\",\"HG98HCFL\"],[758501,\"OZ13ZSIN\",5561],[404251,\"FU1D57HA\",5617],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[315560,\"HG98HCFL\",5651],[758501,\"HG98HCFL\",5673],[141090,\"OZ13ZSIN\",5768],[882572,\"FU1D57HA\",5827],[906872,\"HG98HCFL\",5872],[141090,\"HG98HCFL\",5940],[\"OZ13ZSIN\",\"FU1D57HA\"],[317815,\"HG98HCFL\",5996],[436252,\"OZ13ZSIN\",6027],[\"OZ13ZSIN\",\"E35YW0BM\"],[436252,\"HG98HCFL\",6084],[\"OZ13ZSIN\",\"NTNXSB47\"],[652912,\"NJB0V6ZO\",6155],[652912,\"HG98HCFL\",6169],[269825,\"NJB0V6ZO\",6173],[831024,\"OZ13ZSIN\",6267],[831024,\"FU1D57HA\",6317],[269825,\"FU1D57HA\",6318],[794093,\"OZ13ZSIN\",6406],[\"OZ13ZSIN\",\"HG98HCFL\"],[794093,\"FU1D57HA\",6429],[798558,\"OZ13ZSIN\",6497],[798558,\"E35YW0BM\",6500],[271136,\"NJB0V6ZO\",6582],[\"OZ13ZSIN\",\"HG98HCFL\"],[608446,\"OZ13ZSIN\",6662],[608446,\"FU1D57HA\",6760],[986152,\"OZ13ZSIN\",6799],[986152,\"NTNXSB47\",6825],[271136,\"HG98HCFL\",6911],[\"OZ13ZSIN\",\"FU1D57HA\"],[341349,\"OZ13ZSIN\",6995],[595955,\"OZ13ZSIN\",7039],[58242,\"H9OKZANW\",7071],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[134319,\"OZ13ZSIN\",7119],[595955,\"FU1D57HA\",7161],[\"OZ13ZSIN\",\"HG98HCFL\"],[266781,\"OZ13ZSIN\",7208],[\"OZ13ZSIN\",\"FU1D57HA\"],[266781,\"FU1D57HA\",7298],[\"OZ13ZSIN\",\"NTNXSB47\"],[935757,\"OZ13ZSIN\",7300],[517277,\"OZ13ZSIN\",7376],[58242,\"HG98HCFL\",7459],[\"OZ13ZSIN\",\"HG98HCFL\"],[288203,\"OZ13ZSIN\",7512],[293244,\"T25R11PB\",7580],[517277,\"HG98HCFL\",7588],[293244,\"FU1D57HA\",7649],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[480741,\"OZ13ZSIN\",7748],[288203,\"CWJHORPF\",7845],[935757,\"NTNXSB47\",7940],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[341349,\"HG98HCFL\",7952],[870607,\"ST6XEPDA\",7986],[\"OZ13ZSIN\",\"CWJHORPF\"],[468450,\"6QKM8CM8\",8063],[262669,\"OZ13ZSIN\",8152],[\"OZ13ZSIN\",\"FU1D57HA\"],[103929,\"OZ13ZSIN\",8167],[415331,\"X8W3R0P7\",8215],[134319,\"E35YW0BM\",8226],[415331,\"FU1D57HA\",8240],[468450,\"HG98HCFL\",8263],[394949,\"XOK1HH1Y\",8313],[\"OZ13ZSIN\",\"HG98HCFL\"],[394949,\"FU1D57HA\",8402],[67177,\"GQINA28A\",8451],[67177,\"HG98HCFL\",8521],[796191,\"QJHWOKDQ\",8545],[\"I0Y75MZQ\",\"FU1D57HA\"],[\"H9OKZANW\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[940010,\"OZ13ZSIN\",8583],[940010,\"VL50N6D1\",8613],[21260,\"WGOD5SD4\",8683],[746866,\"NJB0V6ZO\",8732],[47896,\"OZ13ZSIN\",8802],[480741,\"CWJHORPF\",8839],[\"NJB0V6ZO\",\"HG98HCFL\"],[310852,\"XT82S77E\",8858],[796001,\"OZ13ZSIN\",8860],[\"OZ13ZSIN\",\"NTNXSB47\"],[103929,\"FU1D57HA\",8957],[739455,\"OZ13ZSIN\",8980],[\"XWO403P7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"VL50N6D1\"],[734337,\"OZ13ZSIN\",8989],[686615,\"4SBAAFIP\",9086],[21260,\"HG98HCFL\",9130],[\"OZ13ZSIN\",\"CWJHORPF\"],[217165,\"1XW6HVBY\",9228],[689774,\"OZ13ZSIN\",9313],[870607,\"NTNXSB47\",9319],[248471,\"OZ13ZSIN\",9376],[262669,\"E35YW0BM\",9427],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[20582,\"OZ13ZSIN\",9484],[310852,\"LBYS94AD\",9535],[746866,\"FU1D57HA\",9540],[689774,\"FU1D57HA\",9594],[796191,\"HG98HCFL\",9635],[\"OZ13ZSIN\",\"FU1D57HA\"],[734337,\"HG98HCFL\",9683],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[982523,\"XWO403P7\",9689],[\"OZ13ZSIN\",\"OGVA50NO\"],[982523,\"HG98HCFL\",9786],[796001,\"FU1D57HA\",9869],[248471,\"FU1D57HA\",9942],[187843,\"OZ13ZSIN\",10035],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"H9OKZANW\",\"HG98HCFL\"],[217165,\"HG98HCFL\",10100],[739455,\"HG98HCFL\",10171],[187843,\"HG98HCFL\",10226],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[20582,\"E35YW0BM\",10322],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"SAIV20VG\",10342],[\"OZ13ZSIN\",\"FU1D57HA\"],[686615,\"HG98HCFL\",10396],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"CAWYGMWL\",10402],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[800300,\"OZ13ZSIN\",10472],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"NTNXSB47\",10485],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[800300,\"HG98HCFL\",10545],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"FU1D57HA\",10581],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[47896,\"NTNXSB47\",10588],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[788823,\"83OEBTCQ\",10599],[\"CAWYGMWL\",\"NTNXSB47\"],[365416,\"OZ13ZSIN\",10690],[610273,\"OZ13ZSIN\",10757],[988219,\"FWUZEALC\",10767],[\"XT14GVGK\",\"HG98HCFL\"],[910256,\"OZ13ZSIN\",10797],[\"OZ13ZSIN\",\"CWJHORPF\"],[610273,\"FU1D57HA\",10848],[\"OZ13ZSIN\",\"FU1D57HA\"],[910256,\"HMJCZQ0K\",10920],[\"OZ13ZSIN\",\"NTNXSB47\"],[988219,\"HG98HCFL\",10930],[365416,\"HG98HCFL\",10972],[219722,\"OZ13ZSIN\",11033],[295336,\"ITA0GE26\",11107],[219722,\"R62MQ4FI\",11131],[295336,\"FU1D57HA\",11140],[788823,\"0BIIAVNU\",11199],[620927,\"T25R11PB\",11274],[620927,\"FU1D57HA\",11371],[630168,\"OZ13ZSIN\",11448],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[112534,\"OZ13ZSIN\",11449],[573142,\"OZ13ZSIN\",11546],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[454282,\"NJB0V6ZO\",11576],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[454282,\"HG98HCFL\",11643],[444090,\"6QKM8CM8\",11698],[630168,\"Y43BFD6U\",11717],[185093,\"1XW6HVBY\",11723],[217806,\"4SBAAFIP\",11814],[\"XOK1HH1Y\",\"FU1D57HA\"],[573142,\"FU1D57HA\",11874],[661431,\"UT8S3IM6\",11907],[335406,\"OZ13ZSIN\",11942],[\"T25R11PB\",\"FU1D57HA\"],[444090,\"HG98HCFL\",11995],[896969,\"QJHWOKDQ\",12032],[950584,\"NJB0V6ZO\",12097],[570450,\"NJB0V6ZO\",12128],[896969,\"HG98HCFL\",12146],[71637,\"4SBAAFIP\",12202],[923844,\"OZ13ZSIN\",12277],[\"NJB0V6ZO\",\"HG98HCFL\"],[374491,\"OZ13ZSIN\",12300],[333698,\"1XW6HVBY\",12343],[323202,\"4SBAAFIP\",12369],[489161,\"OZ13ZSIN\",12419],[489161,\"BMN7MUED\",12446],[177905,\"XOK1HH1Y\",12483],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[185093,\"FU1D57HA\",12520],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"OZ13ZSIN\",12538],[765285,\"OZ13ZSIN\",12554],[\"OZ13ZSIN\",\"VL50N6D1\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[80760,\"XOK1HH1Y\",12613],[570450,\"R47UH9EC\",12643],[777227,\"OZ13ZSIN\",12717],[30391,\"XQ8MRL86\",12743],[923844,\"NTNXSB47\",12843],[\"OZ13ZSIN\",\"HG98HCFL\"],[177905,\"HG98HCFL\",12901],[374491,\"2Z3A0H6F\",12957],[950584,\"7IO8ET8F\",13035],[\"1XW6HVBY\",\"HG98HCFL\"],[636717,\"WY85FIVE\",13122],[661431,\"L6KOAIR1\",13154],[80760,\"XIUOFK2Y\",13215],[\"OZ13ZSIN\",\"HG98HCFL\"],[428110,\"4SBAAFIP\",13262],[\"H9OKZANW\",\"HG98HCFL\"],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"83OEBTCQ\",\"0BIIAVNU\"],[502345,\"1MOLNL46\",13324],[112534,\"HG98HCFL\",13393],[\"OZ13ZSIN\",\"HG98HCFL\"],[25332,\"OZ13ZSIN\",13487],[240072,\"OZ13ZSIN\",13504],[649981,\"ITA0GE26\",13603],[363027,\"NJB0V6ZO\",13627],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"FU1D57HA\",13724],[961598,\"ST6XEPDA\",13810],[75634,\"ZWJJHOU3\",13877],[807547,\"OZ13ZSIN\",13900],[\"OZ13ZSIN\",\"FU1D57HA\"],[71637,\"HG98HCFL\",13998],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[300645,\"OZ13ZSIN\",14033],[849654,\"OZ13ZSIN\",14128],[701073,\"GQINA28A\",14209],[288997,\"WGOD5SD4\",14252],[7101,\"OZ13ZSIN\",14258],[143698,\"SH04ZH5G\",14355],[849654,\"HG98HCFL\",14395],[300645,\"RBRIS3JS\",14484],[171052,\"OZ13ZSIN\",14576],[214567,\"NJB0V6ZO\",14592],[961598,\"JYTPXJK9\",14646],[132966,\"4SR0921V\",14665],[822925,\"4SBAAFIP\",14742],[333698,\"HG98HCFL\",14835],[\"OZ13ZSIN\",\"HG98HCFL\"],[822925,\"E35YW0BM\",14920],[777227,\"HG98HCFL\",15017],[123308,\"OZ13ZSIN\",15095],[598091,\"6QKM8CM8\",15150],[363027,\"HG98HCFL\",15160],[912565,\"OZ13ZSIN\",15202],[93990,\"1XW6HVBY\",15291],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[25332,\"FU1D57HA\",15332],[143698,\"HG98HCFL\",15380],[502345,\"DYLQ657K\",15429],[171052,\"HG98HCFL\",15436],[\"1XW6HVBY\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[217806,\"FU1D57HA\",15469],[487305,\"5D5SUJ4Q\",15499],[44397,\"6QKM8CM8\",15536],[601607,\"XOK1HH1Y\",15566],[30391,\"HG98HCFL\",15586],[\"OZ13ZSIN\",\"OGVA50NO\"],[765285,\"IX7LS60B\",15641],[788097,\"T25R11PB\",15730],[300198,\"6TED6G4E\",15774],[529964,\"OZ13ZSIN\",15793],[803049,\"IEQICIHL\",15826],[\"OZ13ZSIN\",\"HG98HCFL\"],[7101,\"DKN9PRYJ\",15869],[\"T25R11PB\",\"FU1D57HA\"],[761575,\"D5TNGKU7\",15885],[93990,\"HG98HCFL\",15894],[323202,\"HG98HCFL\",15898],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"OZ13ZSIN\",15990],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"OGVA50NO\"],[213297,\"OZ13ZSIN\",16034],[300198,\"HG98HCFL\",16105],[912565,\"HG98HCFL\",16175],[806824,\"NJB0V6ZO\",16274],[417297,\"OZ13ZSIN\",16334],[\"XQ8MRL86\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[690271,\"GQINA28A\",16427],[540402,\"OZ13ZSIN\",16500],[807547,\"FU1D57HA\",16504],[335406,\"HG98HCFL\",16539],[417297,\"HG98HCFL\",16618],[192719,\"QB05LSRK\",16711],[255839,\"OZ13ZSIN\",16755],[\"OZ13ZSIN\",\"BMN7MUED\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[711297,\"OZ13ZSIN\",16810],[\"OZ13ZSIN\",\"CWJHORPF\"],[711297,\"HG98HCFL\",16899],[211279,\"VL2TL1NM\",16907],[\"XT14GVGK\",\"HG98HCFL\"],[\"XWO403P7\",\"HG98HCFL\"],[213297,\"FU1D57HA\",16964],[44397,\"7JHO6FK0\",17021],[\"4SBAAFIP\",\"HG98HCFL\"],[75634,\"H4UTDCR8\",17075],[996616,\"JYLXUII8\",17167],[775204,\"ZZLR3YVJ\",17215],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[211106,\"6TED6G4E\",17217],[649981,\"HG98HCFL\",17236],[775204,\"HG98HCFL\",17246],[806824,\"HG98HCFL\",17313],[214567,\"GWJB6BU5\",17411],[487305,\"FU1D57HA\",17496],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[237574,\"GA4KQD8H\",17572],[863199,\"OZ13ZSIN\",17616],[921800,\"OZ13ZSIN\",17693],[415592,\"NJB0V6ZO\",17784],[788097,\"FU1D57HA\",17844],[79918,\"ZR7QN32O\",17930],[240072,\"HG98HCFL\",17938],[\"OZ13ZSIN\",\"HG98HCFL\"],[253649,\"OZ13ZSIN\",17981],[545511,\"OZ13ZSIN\",18005],[237574,\"FU1D57HA\",18089],[\"OZ13ZSIN\",\"NTNXSB47\"],[255839,\"HG98HCFL\",18169],[701073,\"HJXEGP9U\",18269],[598091,\"FU1D57HA\",18287],[\"OZ13ZSIN\",\"HG98HCFL\"],[540402,\"HG98HCFL\",18349],[887853,\"GA4KQD8H\",18417],[\"XT82S77E\",\"LBYS94AD\"],[863199,\"HG98HCFL\",18484],[\"OZ13ZSIN\",\"HG98HCFL\"],[127768,\"OZ13ZSIN\",18571],[872173,\"OZ13ZSIN\",18579],[\"OZ13ZSIN\",\"HG98HCFL\"],[872173,\"UB4KML0J\",18638],[428110,\"HG98HCFL\",18720],[\"ITA0GE26\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[85526,\"OZ13ZSIN\",18803],[123308,\"HG98HCFL\",18872],[273723,\"FJVIO218\",18884],[\"OZ13ZSIN\",\"FU1D57HA\"],[716950,\"OZ13ZSIN\",18916],[436026,\"OZ13ZSIN\",18922],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[127768,\"FU1D57HA\",18931],[646079,\"IMDG88XX\",18944],[784931,\"OZ13ZSIN\",19001],[\"OZ13ZSIN\",\"OGVA50NO\"],[\"OZ13ZSIN\",\"H4UTDCR8\"],[803049,\"RPKD08C6\",19041],[627595,\"MBY9ZG7D\",19129],[386653,\"BMX2AIY5\",19179],[\"OZ13ZSIN\",\"CWJHORPF\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[211106,\"HG98HCFL\",19251],[855448,\"OZ13ZSIN\",19300],[733785,\"SPVKZTIP\",19344],[\"XOK1HH1Y\",\"HG98HCFL\"],[761575,\"HG98HCFL\",19444],[\"OZ13ZSIN\",\"HG98HCFL\"],[132966,\"H4UTDCR8\",19503],[948005,\"OZ13ZSIN\",19520],[14408,\"OZ13ZSIN\",19594],[\"I0Y75MZQ\",\"FU1D57HA\"],[85526,\"NTNXSB47\",19687],[211403,\"OZ13ZSIN\",19761],[677411,\"OZ13ZSIN\",19852],[192719,\"HG98HCFL\",19905],[887853,\"HG98HCFL\",19975],[455474,\"OZ13ZSIN\",20002],[601607,\"FU1D57HA\",20077],[14408,\"HG98HCFL\",20150],[\"OZ13ZSIN\",\"DKN9PRYJ\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[253649,\"1QLZUAXZ\",20166],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[548975,\"OZ13ZSIN\",20232],[386653,\"1QLZUAXZ\",20277],[415592,\"HG98HCFL\",20318],[716950,\"3ZJ18VKA\",20384],[84268,\"OZ13ZSIN\",20392],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[55374,\"4SBAAFIP\",20416],[851948,\"OZ13ZSIN\",20503],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"OZ13ZSIN\",20513],[615192,\"OZ13ZSIN\",20551],[851948,\"HG98HCFL\",20631],[211403,\"HG98HCFL\",20668],[677411,\"OGVA50NO\",20715],[55374,\"FU1D57HA\",20749],[457056,\"OZ13ZSIN\",20799],[\"XOK1HH1Y\",\"FU1D57HA\"],[548975,\"HG98HCFL\",20836],[41381,\"MY3O8OQI\",20908],[950414,\"OZ13ZSIN\",20971],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[873337,\"OZ13ZSIN\",21038],[\"5D5SUJ4Q\",\"FU1D57HA\"],[273723,\"FU1D57HA\",21053],[726970,\"OZ13ZSIN\",21070],[\"OZ13ZSIN\",\"HG98HCFL\"],[211279,\"HG98HCFL\",21127],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[276902,\"4T1TBZX5\",21160],[\"OZ13ZSIN\",\"HG98HCFL\"],[183959,\"OZ13ZSIN\",21209],[488167,\"OZ13ZSIN\",21250],[\"OZ13ZSIN\",\"HG98HCFL\"],[166180,\"OZ13ZSIN\",21323],[\"FJVIO218\",\"FU1D57HA\"],[636717,\"UB4KML0J\",21366],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"DLUQBV4V\",21413],[\"OZ13ZSIN\",\"FU1D57HA\"],[528132,\"LUCPET9G\",21476],[206116,\"0MOLP3NC\",21551],[183959,\"XPM6JMBR\",21562],[\"OZ13ZSIN\",\"HG98HCFL\"],[553646,\"BMX2AIY5\",21661],[\"OZ13ZSIN\",\"DLUQBV4V\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"SH04ZH5G\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"R62MQ4FI\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[724508,\"C00L36RI\",21665],[950414,\"FU1D57HA\",21721],[102566,\"NJB0V6ZO\",21819],[690271,\"HG98HCFL\",21829],[\"OZ13ZSIN\",\"HG98HCFL\"],[386570,\"OZ13ZSIN\",21870],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[733785,\"FU1D57HA\",21931],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"ZWJJHOU3\",\"H4UTDCR8\"],[493080,\"OZ13ZSIN\",21957],[\"OZ13ZSIN\",\"RBRIS3JS\"],[476818,\"NJB0V6ZO\",22018],[\"OZ13ZSIN\",\"HG98HCFL\"],[646079,\"VMT100K8\",22076],[873337,\"E35YW0BM\",22080],[529964,\"FU1D57HA\",22162],[41381,\"FU1D57HA\",22233],[\"1XW6HVBY\",\"HG98HCFL\"],[\"IMDG88XX\",\"VMT100K8\"],[724508,\"JYTPXJK9\",22301],[\"OZ13ZSIN\",\"FU1D57HA\"],[276768,\"OZ13ZSIN\",22339],[654375,\"1XW6HVBY\",22349],[276768,\"X1H2W3W0\",22438],[\"OZ13ZSIN\",\"UB4KML0J\"],[855448,\"KSOIJA62\",22533],[493080,\"FU1D57HA\",22554],[726970,\"E35YW0BM\",22603],[\"4SR0921V\",\"H4UTDCR8\"],[79918,\"R62MQ4FI\",22640],[659224,\"OZ13ZSIN\",22739],[436026,\"L6KOAIR1\",22770],[288997,\"E35YW0BM\",22850],[\"SAIV20VG\",\"FU1D57HA\"],[553646,\"FU1D57HA\",22946],[659224,\"NTNXSB47\",22957],[615192,\"HG98HCFL\",23056],[\"OZ13ZSIN\",\"E35YW0BM\"],[730441,\"1XW6HVBY\",23129],[55790,\"OZ13ZSIN\",23179],[524967,\"OZ13ZSIN\",23189],[44097,\"2GRLB4CN\",23280],[784931,\"E35YW0BM\",23343],[525825,\"OZ13ZSIN\",23384],[315479,\"XQ8MRL86\",23386],[537074,\"OZ13ZSIN\",23437],[\"XT82S77E\",\"LBYS94AD\"],[524967,\"7JIXF9D1\",23496],[559244,\"OZ13ZSIN\",23569],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[872522,\"FJVIO218\",23579],[160528,\"DE386QWN\",23602],[\"4SBAAFIP\",\"HG98HCFL\"],[832697,\"OZ13ZSIN\",23696],[439436,\"NJB0V6ZO\",23749],[559244,\"MJZC0DI0\",23811],[38958,\"4SBAAFIP\",23863],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[327722,\"OZ13ZSIN\",23901],[243726,\"OZ13ZSIN\",23955],[38958,\"WUIGDE36\",24007],[832697,\"4IBLBVYU\",24058],[626392,\"QK3YTSXO\",24064],[640646,\"OZ13ZSIN\",24084],[476818,\"R5XHXCAN\",24129],[13070,\"NJB0V6ZO\",24190],[\"VL2TL1NM\",\"HG98HCFL\"],[633159,\"GQYWQW84\",24235],[528132,\"MPBZFLN9\",24236],[668517,\"OZ13ZSIN\",24307],[627595,\"HG98HCFL\",24343],[\"OZ13ZSIN\",\"HG98HCFL\"],[438428,\"PQOMFBOJ\",24350],[386570,\"FU1D57HA\",24413],[668517,\"7JHO6FK0\",24482],[561608,\"2IVTIGII\",24575],[539280,\"ITA0GE26\",24660],[160528,\"7IO8ET8F\",24668],[\"T25R11PB\",\"FU1D57HA\"],[626392,\"FU1D57HA\",24755],[\"4SBAAFIP\",\"WUIGDE36\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[251034,\"4SBAAFIP\",24786],[968259,\"OZ13ZSIN\",24870],[640646,\"I9H1UDG4\",24892],[361979,\"OZ13ZSIN\",24945],[806004,\"WPM57THK\",25006],[488167,\"VL50N6D1\",25009],[\"XT82S77E\",\"LBYS94AD\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[\"XQ8MRL86\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HMJCZQ0K\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[787728,\"OZ13ZSIN\",25084],[95528,\"OZ13ZSIN\",25154],[825321,\"4SBAAFIP\",25200],[\"OZ13ZSIN\",\"HG98HCFL\"],[968259,\"HG98HCFL\",25234],[\"NJB0V6ZO\",\"HG98HCFL\"],[537074,\"2Z3A0H6F\",25283],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"1QLZUAXZ\"],[430837,\"ZOA7MKHB\",25342],[588541,\"OZ13ZSIN\",25380],[\"OZ13ZSIN\",\"HG98HCFL\"],[276902,\"FU1D57HA\",25448],[787728,\"BMN7MUED\",25495],[590184,\"KFRF7AEZ\",25577],[\"LUCPET9G\",\"MPBZFLN9\"],[510551,\"OZ13ZSIN\",25597],[806004,\"HG98HCFL\",25608],[925378,\"T25R11PB\",25614],[27187,\"NJB0V6ZO\",25651],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"DE386QWN\",25682],[525825,\"IX7LS60B\",25695],[876351,\"1XW6HVBY\",25761],[225487,\"SPVKZTIP\",25783],[159468,\"OZ13ZSIN\",25784],[785370,\"BMX2AIY5\",25819],[159468,\"FU1D57HA\",25847],[822091,\"1XW6HVBY\",25911],[142228,\"OZ13ZSIN\",25962],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"HG98HCFL\",25997],[6026,\"WPM57THK\",26000],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"J1X7TLQD\",26041],[42555,\"D5TNGKU7\",26042],[921331,\"XOK1HH1Y\",26066],[95528,\"GWVJKDKT\",26130],[361979,\"CWWVVCGZ\",26183],[747281,\"OZ13ZSIN\",26197],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"NJB0V6ZO\",\"7IO8ET8F\"],[590184,\"FY86VG9O\",26248],[443593,\"6TED6G4E\",26254],[921331,\"IVDGXU4R\",26354],[184691,\"XOK1HH1Y\",26394],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"D5TNGKU7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[997488,\"OZ13ZSIN\",26468],[161852,\"OZ13ZSIN\",26476],[42555,\"HG98HCFL\",26505],[948005,\"88RO58CG\",26517],[499506,\"ITA0GE26\",26545],[\"OZ13ZSIN\",\"FU1D57HA\"],[654375,\"FU1D57HA\",26593],[999272,\"OZ13ZSIN\",26641],[\"OZ13ZSIN\",\"FU1D57HA\"],[788492,\"OZ13ZSIN\",26738],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"4SBAAFIP\",\"E35YW0BM\"],[327722,\"HG98HCFL\",26780],[499506,\"GWVJKDKT\",26878],[825321,\"HG98HCFL\",26973],[\"CAWYGMWL\",\"NTNXSB47\"],[606855,\"C00L36RI\",26996],[498054,\"OZ13ZSIN\",27025],[455474,\"7JHO6FK0\",27070],[911613,\"OZ13ZSIN\",27170],[693354,\"O77WFMCI\",27225],[\"OZ13ZSIN\",\"HG98HCFL\"],[483609,\"G2LO9U87\",27250],[\"D5TNGKU7\",\"HG98HCFL\"],[914704,\"OZ13ZSIN\",27252],[835356,\"OZ13ZSIN\",27277],[\"XOK1HH1Y\",\"HG98HCFL\"],[243726,\"2Z3A0H6F\",27330],[788492,\"HG98HCFL\",27409],[\"FJVIO218\",\"FU1D57HA\"],[730441,\"HG98HCFL\",27465],[418199,\"OZ13ZSIN\",27557],[\"NJB0V6ZO\",\"HG98HCFL\"],[416184,\"X8W3R0P7\",27576],[177447,\"GQINA28A\",27661],[27187,\"Q6L1ZD92\",27684],[53005,\"MY3O8OQI\",27746],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[835356,\"HG98HCFL\",27775],[88784,\"NJB0V6ZO\",27865],[747281,\"HG98HCFL\",27921],[\"OZ13ZSIN\",\"HG98HCFL\"],[184691,\"CWWVVCGZ\",27974],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[554716,\"OZ13ZSIN\",28020],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"FU1D57HA\",28107],[\"ZR7QN32O\",\"R62MQ4FI\"],[326091,\"XOK1HH1Y\",28151],[927316,\"OZ13ZSIN\",28193],[\"T25R11PB\",\"FU1D57HA\"],[499875,\"NJB0V6ZO\",28256],[590013,\"OZ13ZSIN\",28354],[62740,\"OZ13ZSIN\",28413],[876351,\"FU1D57HA\",28469],[749462,\"OZ13ZSIN\",28525],[\"5D5SUJ4Q\",\"FU1D57HA\"],[996616,\"OGVA50NO\",28553],[177447,\"CWWVVCGZ\",28572],[\"OZ13ZSIN\",\"FU1D57HA\"],[438428,\"L6KOAIR1\",28631],[693354,\"DLUQBV4V\",28663],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[880171,\"475J29EI\",28754],[588541,\"1YA7XTV9\",28760],[457056,\"HG98HCFL\",28762],[\"OZ13ZSIN\",\"VL50N6D1\"],[84268,\"HG98HCFL\",28792],[130492,\"IMDG88XX\",28832],[163069,\"FWUZEALC\",28840],[\"C00L36RI\",\"JYTPXJK9\"],[417559,\"BMX2AIY5\",28890],[\"OZ13ZSIN\",\"HG98HCFL\"],[914704,\"FU1D57HA\",28939],[55617,\"VL2TL1NM\",28974],[\"4SBAAFIP\",\"E35YW0BM\"],[911613,\"FU1D57HA\",29069],[880171,\"HG98HCFL\",29099],[\"OZ13ZSIN\",\"FU1D57HA\"],[117275,\"4SBAAFIP\",29174],[822091,\"FU1D57HA\",29206],[775394,\"XQ8MRL86\",29284],[917846,\"4SBAAFIP\",29288],[55790,\"0NYQFXYO\",29343],[\"83OEBTCQ\",\"0BIIAVNU\"],[416184,\"HG98HCFL\",29415],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"FJVIO218\",\"FU1D57HA\"],[228425,\"OZ13ZSIN\",29438],[\"CAWYGMWL\",\"NTNXSB47\"],[87834,\"OZ13ZSIN\",29442],[633159,\"WMTPA7JN\",29482],[322118,\"OZ13ZSIN\",29526],[\"1XW6HVBY\",\"FU1D57HA\"],[675060,\"K9D63ZZC\",29617],[225487,\"RPKD08C6\",29691],[708687,\"OZ13ZSIN\",29761],[836854,\"OZ13ZSIN\",29845],[\"6QKM8CM8\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[299466,\"4SBAAFIP\",29860],[\"WGOD5SD4\",\"E35YW0BM\"],[\"X8W3R0P7\",\"FU1D57HA\"],[927316,\"HG98HCFL\",29938],[483609,\"HG98HCFL\",29995],[\"C00L36RI\",\"JYTPXJK9\"],[\"OZ13ZSIN\",\"L6KOAIR1\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"HG98HCFL\",30054],[870611,\"72Q6VPM1\",30066],[754460,\"4SBAAFIP\",30086],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[979711,\"OZ13ZSIN\",30112],[322118,\"EY70T3I1\",30197],[696824,\"ZWJJHOU3\",30263],[239811,\"WGOD5SD4\",30361],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"475J29EI\",\"HG98HCFL\"],[963752,\"1XW6HVBY\",30399],[764562,\"OZ13ZSIN\",30480],[165422,\"XQ8MRL86\",30559],[282372,\"2MKY7B5Q\",30609],[554716,\"HG98HCFL\",30700],[925378,\"HG98HCFL\",30705],[836854,\"UB4KML0J\",30802],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[328085,\"PYU6IFCW\",30865],[999272,\"NTNXSB47\",30884],[510551,\"HG98HCFL\",30903],[87834,\"HG98HCFL\",30918],[590013,\"HG98HCFL\",30950],[775394,\"MPBZFLN9\",30963],[701078,\"OZ13ZSIN\",31024],[561608,\"WIXJ6Z00\",31082],[\"OZ13ZSIN\",\"HG98HCFL\"],[328085,\"FU1D57HA\",31132],[165422,\"HG98HCFL\",31226],[997488,\"HG98HCFL\",31249],[785370,\"FY86VG9O\",31334],[186553,\"6GPMXUYZ\",31378],[282372,\"FU1D57HA\",31454],[88784,\"WMTPA7JN\",31484],[186637,\"973PO4KY\",31528],[62740,\"HG98HCFL\",31561],[206116,\"CWWVVCGZ\",31653],[525469,\"OZ13ZSIN\",31705],[\"OZ13ZSIN\",\"CWWVVCGZ\"],[109318,\"OZ13ZSIN\",31719],[954915,\"WS49LJP8\",31776],[\"OZ13ZSIN\",\"FU1D57HA\"],[166180,\"FU1D57HA\",31824],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"MY3O8OQI\",\"FU1D57HA\"],[539280,\"YZ8LNY1V\",31843],[\"OZ13ZSIN\",\"UB4KML0J\"],[901923,\"OZ13ZSIN\",31865],[963752,\"VMT100K8\",31918],[239811,\"HG98HCFL\",31990]]` wtf is this testcase bro \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "i feel stupid that i opened ur comment. LoL ! it took forever to scroll down"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "resolved ? me also getting error in this test case"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The May badge was not an easy one! Guys let\\'s get this done!!!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Yay!"
                    },
                    {
                        "username": "omeraktepe",
                        "content": "There is a test case that does not meet assumptions. \nTest case 56: [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]] \n\nIt violetes followings: \n1. A customer can only be checked into one place at a time. \n2. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order. \n\nI am too lazy to report though :)"
                    },
                    {
                        "username": "zavojchevski",
                        "content": "I agree on this, restrictions should be well explained. "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "For those failing test case 51:\\n\"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\"\\nCredit to xuawai for noticing this back in 2020."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Restrictions should be written stricter. Some strange cases which are valid:\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@psionl0](/psionl0) \\'getAverageTime\\' arguments are invalid: "
                    },
                    {
                        "username": "psionl0",
                        "content": "All your test cases work on my code but it fails on Leet testcase 49. I also tried\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"],[\"A\",\"C\"]]\n``` \nbut that seems to be an invalid test case."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[@anwendeng](/anwendeng) My code works too, but it\\'s strange."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I have tested all of your test cases and my program passed!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using  2 tables  to store the info.\nUse hash tables for check-in and travel time info! \nThe programming is easier than a standard design for Hash set!\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Thanks for spoiling the answer for people in reallllllly big font so they don\\'t accidently try to come up with the answer themselves! Real nice of you."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "but bro trust me designing a hash set is highly asked interview problem ...\\nI recalled my concept of how we can store data in hashset..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "## **Don't raise your font at us!**"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/design-underground-system/solutions/3580430/easy-c-python-solutions-with-unordered-map-dict/"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Now people here in discuss section only comment to boost up there reputation."
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "This is an issue here and with almost all of these problems. Using vague or ambiguous names for parameters would never be allowed in enterprise software development. \\'id\\' ? id of what? Argument with name \\'t\\' is it time, train, turn? the code should be explanatory even without the description. Its also a prevalent issue in the editorials and provided solutions. \\n\\nThis is also an accessibility and inclusivity issue. When working on teams where not everyone speaks or has native proficiency in the same language using abbreviations or short hand becomes a huge problem. Leetcode should try and make it\\'s examples as near to what would be expected in a real workplace not a college math class."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me feel bad for jumping over the gates every time I lost my ticket on the way.\nSorry for creating stupid edge cases to handle for some devs somewhere"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Today is a special day for me as I will be getting my first badge of leetcode.\nThrough this one month of solving questions daily, the one thing that I have learnt is nothing matters- not even motivation if you don't have the habit of being consistent throughout the journey. \nI am looking forward to be more consistent.\nHappy coding fellow leetcoders!!!"
                    }
                ]
            },
            {
                "id": 1912073,
                "content": [
                    {
                        "username": "jax_ay",
                        "content": "`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\"] [[],[117077,\"OZ13ZSIN\",42],[117077,\"FU1D57HA\",125],[704903,\"OZ13ZSIN\",211],[911239,\"OZ13ZSIN\",245],[704903,\"HG98HCFL\",340],[859828,\"OZ13ZSIN\",355],[\"OZ13ZSIN\",\"FU1D57HA\"],[911239,\"FU1D57HA\",383],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[859828,\"FU1D57HA\",402],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[363027,\"OZ13ZSIN\",489],[319826,\"OZ13ZSIN\",550],[\"OZ13ZSIN\",\"FU1D57HA\"],[363027,\"HG98HCFL\",565],[319826,\"FU1D57HA\",664],[120084,\"OZ13ZSIN\",735],[\"OZ13ZSIN\",\"HG98HCFL\"],[120084,\"HG98HCFL\",832],[56672,\"OZ13ZSIN\",876],[56672,\"HG98HCFL\",912],[638995,\"OZ13ZSIN\",925],[\"OZ13ZSIN\",\"FU1D57HA\"],[638995,\"FU1D57HA\",951],[712949,\"OZ13ZSIN\",1023],[712949,\"FU1D57HA\",1033],[278482,\"T25R11PB\",1080],[\"OZ13ZSIN\",\"FU1D57HA\"],[278482,\"FU1D57HA\",1160],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[342818,\"4SBAAFIP\",1250],[342818,\"HG98HCFL\",1263],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[415673,\"OZ13ZSIN\",1270],[415673,\"NTNXSB47\",1366],[\"T25R11PB\",\"FU1D57HA\"],[597115,\"4SBAAFIP\",1385],[463555,\"OZ13ZSIN\",1461],[463555,\"HG98HCFL\",1514],[801778,\"OZ13ZSIN\",1537],[201428,\"OZ13ZSIN\",1620],[245538,\"OZ13ZSIN\",1630],[597115,\"FU1D57HA\",1657],[583112,\"OZ13ZSIN\",1690],[\"4SBAAFIP\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[691834,\"OZ13ZSIN\",1723],[250537,\"OZ13ZSIN\",1753],[201428,\"H4UTDCR8\",1804],[691834,\"FU1D57HA\",1838],[\"T25R11PB\",\"FU1D57HA\"],[245538,\"FU1D57HA\",1924],[346824,\"OZ13ZSIN\",1952],[864512,\"OZ13ZSIN\",2005],[499705,\"OZ13ZSIN\",2048],[482469,\"GQINA28A\",2058],[\"OZ13ZSIN\",\"FU1D57HA\"],[583112,\"E35YW0BM\",2080],[\"OZ13ZSIN\",\"HG98HCFL\"],[801778,\"HG98HCFL\",2082],[250415,\"I0Y75MZQ\",2149],[795633,\"OZ13ZSIN\",2196],[\"OZ13ZSIN\",\"HG98HCFL\"],[99144,\"4SBAAFIP\",2219],[83594,\"OZ13ZSIN\",2249],[346824,\"HG98HCFL\",2290],[482469,\"HG98HCFL\",2368],[499705,\"FU1D57HA\",2437],[12539,\"OZ13ZSIN\",2442],[116546,\"OZ13ZSIN\",2493],[884032,\"4SBAAFIP\",2579],[801142,\"OZ13ZSIN\",2598],[795633,\"HG98HCFL\",2693],[83594,\"HG98HCFL\",2782],[529306,\"OZ13ZSIN\",2824],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[286490,\"OZ13ZSIN\",2844],[255488,\"OZ13ZSIN\",2935],[608514,\"OZ13ZSIN\",2984],[116546,\"HG98HCFL\",3079],[250415,\"FU1D57HA\",3174],[\"OZ13ZSIN\",\"FU1D57HA\"],[884032,\"E35YW0BM\",3267],[\"OZ13ZSIN\",\"FU1D57HA\"],[529306,\"HG98HCFL\",3299],[\"OZ13ZSIN\",\"FU1D57HA\"],[892550,\"OZ13ZSIN\",3388],[892550,\"2VVKO5AZ\",3394],[14673,\"OZ13ZSIN\",3487],[\"OZ13ZSIN\",\"HG98HCFL\"],[12539,\"HG98HCFL\",3576],[\"OZ13ZSIN\",\"HG98HCFL\"],[255488,\"HG98HCFL\",3674],[\"OZ13ZSIN\",\"HG98HCFL\"],[14673,\"HG98HCFL\",3754],[864512,\"FU1D57HA\",3819],[451611,\"OZ13ZSIN\",3899],[\"4SBAAFIP\",\"E35YW0BM\"],[451611,\"HG98HCFL\",3941],[250537,\"HG98HCFL\",4027],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[286490,\"FU1D57HA\",4046],[608514,\"HG98HCFL\",4094],[827431,\"XWO403P7\",4107],[99144,\"HG98HCFL\",4136],[\"GQINA28A\",\"HG98HCFL\"],[657832,\"OZ13ZSIN\",4150],[827431,\"HG98HCFL\",4214],[\"OZ13ZSIN\",\"FU1D57HA\"],[658842,\"OZ13ZSIN\",4236],[52933,\"4SBAAFIP\",4325],[801142,\"HG98HCFL\",4413],[52933,\"E35YW0BM\",4460],[331712,\"OZ13ZSIN\",4522],[658842,\"NTNXSB47\",4615],[293734,\"OZ13ZSIN\",4665],[293734,\"HG98HCFL\",4735],[917903,\"OZ13ZSIN\",4772],[119860,\"OZ13ZSIN\",4775],[\"OZ13ZSIN\",\"HG98HCFL\"],[657832,\"E35YW0BM\",4850],[415861,\"NJB0V6ZO\",4881],[\"OZ13ZSIN\",\"FU1D57HA\"],[917903,\"HG98HCFL\",4892],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[415861,\"HG98HCFL\",4919],[\"OZ13ZSIN\",\"HG98HCFL\"],[331712,\"OGVA50NO\",4979],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[119860,\"HG98HCFL\",5034],[469875,\"OZ13ZSIN\",5053],[407362,\"XT14GVGK\",5073],[469875,\"HG98HCFL\",5126],[407362,\"HG98HCFL\",5175],[324747,\"OZ13ZSIN\",5236],[315560,\"OZ13ZSIN\",5333],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[317815,\"OZ13ZSIN\",5339],[906872,\"OZ13ZSIN\",5349],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[404251,\"OZ13ZSIN\",5375],[324747,\"HG98HCFL\",5474],[882572,\"OZ13ZSIN\",5524],[\"OZ13ZSIN\",\"HG98HCFL\"],[758501,\"OZ13ZSIN\",5561],[404251,\"FU1D57HA\",5617],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[315560,\"HG98HCFL\",5651],[758501,\"HG98HCFL\",5673],[141090,\"OZ13ZSIN\",5768],[882572,\"FU1D57HA\",5827],[906872,\"HG98HCFL\",5872],[141090,\"HG98HCFL\",5940],[\"OZ13ZSIN\",\"FU1D57HA\"],[317815,\"HG98HCFL\",5996],[436252,\"OZ13ZSIN\",6027],[\"OZ13ZSIN\",\"E35YW0BM\"],[436252,\"HG98HCFL\",6084],[\"OZ13ZSIN\",\"NTNXSB47\"],[652912,\"NJB0V6ZO\",6155],[652912,\"HG98HCFL\",6169],[269825,\"NJB0V6ZO\",6173],[831024,\"OZ13ZSIN\",6267],[831024,\"FU1D57HA\",6317],[269825,\"FU1D57HA\",6318],[794093,\"OZ13ZSIN\",6406],[\"OZ13ZSIN\",\"HG98HCFL\"],[794093,\"FU1D57HA\",6429],[798558,\"OZ13ZSIN\",6497],[798558,\"E35YW0BM\",6500],[271136,\"NJB0V6ZO\",6582],[\"OZ13ZSIN\",\"HG98HCFL\"],[608446,\"OZ13ZSIN\",6662],[608446,\"FU1D57HA\",6760],[986152,\"OZ13ZSIN\",6799],[986152,\"NTNXSB47\",6825],[271136,\"HG98HCFL\",6911],[\"OZ13ZSIN\",\"FU1D57HA\"],[341349,\"OZ13ZSIN\",6995],[595955,\"OZ13ZSIN\",7039],[58242,\"H9OKZANW\",7071],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[134319,\"OZ13ZSIN\",7119],[595955,\"FU1D57HA\",7161],[\"OZ13ZSIN\",\"HG98HCFL\"],[266781,\"OZ13ZSIN\",7208],[\"OZ13ZSIN\",\"FU1D57HA\"],[266781,\"FU1D57HA\",7298],[\"OZ13ZSIN\",\"NTNXSB47\"],[935757,\"OZ13ZSIN\",7300],[517277,\"OZ13ZSIN\",7376],[58242,\"HG98HCFL\",7459],[\"OZ13ZSIN\",\"HG98HCFL\"],[288203,\"OZ13ZSIN\",7512],[293244,\"T25R11PB\",7580],[517277,\"HG98HCFL\",7588],[293244,\"FU1D57HA\",7649],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[480741,\"OZ13ZSIN\",7748],[288203,\"CWJHORPF\",7845],[935757,\"NTNXSB47\",7940],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[341349,\"HG98HCFL\",7952],[870607,\"ST6XEPDA\",7986],[\"OZ13ZSIN\",\"CWJHORPF\"],[468450,\"6QKM8CM8\",8063],[262669,\"OZ13ZSIN\",8152],[\"OZ13ZSIN\",\"FU1D57HA\"],[103929,\"OZ13ZSIN\",8167],[415331,\"X8W3R0P7\",8215],[134319,\"E35YW0BM\",8226],[415331,\"FU1D57HA\",8240],[468450,\"HG98HCFL\",8263],[394949,\"XOK1HH1Y\",8313],[\"OZ13ZSIN\",\"HG98HCFL\"],[394949,\"FU1D57HA\",8402],[67177,\"GQINA28A\",8451],[67177,\"HG98HCFL\",8521],[796191,\"QJHWOKDQ\",8545],[\"I0Y75MZQ\",\"FU1D57HA\"],[\"H9OKZANW\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[940010,\"OZ13ZSIN\",8583],[940010,\"VL50N6D1\",8613],[21260,\"WGOD5SD4\",8683],[746866,\"NJB0V6ZO\",8732],[47896,\"OZ13ZSIN\",8802],[480741,\"CWJHORPF\",8839],[\"NJB0V6ZO\",\"HG98HCFL\"],[310852,\"XT82S77E\",8858],[796001,\"OZ13ZSIN\",8860],[\"OZ13ZSIN\",\"NTNXSB47\"],[103929,\"FU1D57HA\",8957],[739455,\"OZ13ZSIN\",8980],[\"XWO403P7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"VL50N6D1\"],[734337,\"OZ13ZSIN\",8989],[686615,\"4SBAAFIP\",9086],[21260,\"HG98HCFL\",9130],[\"OZ13ZSIN\",\"CWJHORPF\"],[217165,\"1XW6HVBY\",9228],[689774,\"OZ13ZSIN\",9313],[870607,\"NTNXSB47\",9319],[248471,\"OZ13ZSIN\",9376],[262669,\"E35YW0BM\",9427],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[20582,\"OZ13ZSIN\",9484],[310852,\"LBYS94AD\",9535],[746866,\"FU1D57HA\",9540],[689774,\"FU1D57HA\",9594],[796191,\"HG98HCFL\",9635],[\"OZ13ZSIN\",\"FU1D57HA\"],[734337,\"HG98HCFL\",9683],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[982523,\"XWO403P7\",9689],[\"OZ13ZSIN\",\"OGVA50NO\"],[982523,\"HG98HCFL\",9786],[796001,\"FU1D57HA\",9869],[248471,\"FU1D57HA\",9942],[187843,\"OZ13ZSIN\",10035],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"H9OKZANW\",\"HG98HCFL\"],[217165,\"HG98HCFL\",10100],[739455,\"HG98HCFL\",10171],[187843,\"HG98HCFL\",10226],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[20582,\"E35YW0BM\",10322],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"SAIV20VG\",10342],[\"OZ13ZSIN\",\"FU1D57HA\"],[686615,\"HG98HCFL\",10396],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"CAWYGMWL\",10402],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[800300,\"OZ13ZSIN\",10472],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"NTNXSB47\",10485],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[800300,\"HG98HCFL\",10545],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"FU1D57HA\",10581],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[47896,\"NTNXSB47\",10588],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[788823,\"83OEBTCQ\",10599],[\"CAWYGMWL\",\"NTNXSB47\"],[365416,\"OZ13ZSIN\",10690],[610273,\"OZ13ZSIN\",10757],[988219,\"FWUZEALC\",10767],[\"XT14GVGK\",\"HG98HCFL\"],[910256,\"OZ13ZSIN\",10797],[\"OZ13ZSIN\",\"CWJHORPF\"],[610273,\"FU1D57HA\",10848],[\"OZ13ZSIN\",\"FU1D57HA\"],[910256,\"HMJCZQ0K\",10920],[\"OZ13ZSIN\",\"NTNXSB47\"],[988219,\"HG98HCFL\",10930],[365416,\"HG98HCFL\",10972],[219722,\"OZ13ZSIN\",11033],[295336,\"ITA0GE26\",11107],[219722,\"R62MQ4FI\",11131],[295336,\"FU1D57HA\",11140],[788823,\"0BIIAVNU\",11199],[620927,\"T25R11PB\",11274],[620927,\"FU1D57HA\",11371],[630168,\"OZ13ZSIN\",11448],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[112534,\"OZ13ZSIN\",11449],[573142,\"OZ13ZSIN\",11546],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[454282,\"NJB0V6ZO\",11576],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[454282,\"HG98HCFL\",11643],[444090,\"6QKM8CM8\",11698],[630168,\"Y43BFD6U\",11717],[185093,\"1XW6HVBY\",11723],[217806,\"4SBAAFIP\",11814],[\"XOK1HH1Y\",\"FU1D57HA\"],[573142,\"FU1D57HA\",11874],[661431,\"UT8S3IM6\",11907],[335406,\"OZ13ZSIN\",11942],[\"T25R11PB\",\"FU1D57HA\"],[444090,\"HG98HCFL\",11995],[896969,\"QJHWOKDQ\",12032],[950584,\"NJB0V6ZO\",12097],[570450,\"NJB0V6ZO\",12128],[896969,\"HG98HCFL\",12146],[71637,\"4SBAAFIP\",12202],[923844,\"OZ13ZSIN\",12277],[\"NJB0V6ZO\",\"HG98HCFL\"],[374491,\"OZ13ZSIN\",12300],[333698,\"1XW6HVBY\",12343],[323202,\"4SBAAFIP\",12369],[489161,\"OZ13ZSIN\",12419],[489161,\"BMN7MUED\",12446],[177905,\"XOK1HH1Y\",12483],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[185093,\"FU1D57HA\",12520],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"OZ13ZSIN\",12538],[765285,\"OZ13ZSIN\",12554],[\"OZ13ZSIN\",\"VL50N6D1\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[80760,\"XOK1HH1Y\",12613],[570450,\"R47UH9EC\",12643],[777227,\"OZ13ZSIN\",12717],[30391,\"XQ8MRL86\",12743],[923844,\"NTNXSB47\",12843],[\"OZ13ZSIN\",\"HG98HCFL\"],[177905,\"HG98HCFL\",12901],[374491,\"2Z3A0H6F\",12957],[950584,\"7IO8ET8F\",13035],[\"1XW6HVBY\",\"HG98HCFL\"],[636717,\"WY85FIVE\",13122],[661431,\"L6KOAIR1\",13154],[80760,\"XIUOFK2Y\",13215],[\"OZ13ZSIN\",\"HG98HCFL\"],[428110,\"4SBAAFIP\",13262],[\"H9OKZANW\",\"HG98HCFL\"],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"83OEBTCQ\",\"0BIIAVNU\"],[502345,\"1MOLNL46\",13324],[112534,\"HG98HCFL\",13393],[\"OZ13ZSIN\",\"HG98HCFL\"],[25332,\"OZ13ZSIN\",13487],[240072,\"OZ13ZSIN\",13504],[649981,\"ITA0GE26\",13603],[363027,\"NJB0V6ZO\",13627],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"FU1D57HA\",13724],[961598,\"ST6XEPDA\",13810],[75634,\"ZWJJHOU3\",13877],[807547,\"OZ13ZSIN\",13900],[\"OZ13ZSIN\",\"FU1D57HA\"],[71637,\"HG98HCFL\",13998],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[300645,\"OZ13ZSIN\",14033],[849654,\"OZ13ZSIN\",14128],[701073,\"GQINA28A\",14209],[288997,\"WGOD5SD4\",14252],[7101,\"OZ13ZSIN\",14258],[143698,\"SH04ZH5G\",14355],[849654,\"HG98HCFL\",14395],[300645,\"RBRIS3JS\",14484],[171052,\"OZ13ZSIN\",14576],[214567,\"NJB0V6ZO\",14592],[961598,\"JYTPXJK9\",14646],[132966,\"4SR0921V\",14665],[822925,\"4SBAAFIP\",14742],[333698,\"HG98HCFL\",14835],[\"OZ13ZSIN\",\"HG98HCFL\"],[822925,\"E35YW0BM\",14920],[777227,\"HG98HCFL\",15017],[123308,\"OZ13ZSIN\",15095],[598091,\"6QKM8CM8\",15150],[363027,\"HG98HCFL\",15160],[912565,\"OZ13ZSIN\",15202],[93990,\"1XW6HVBY\",15291],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[25332,\"FU1D57HA\",15332],[143698,\"HG98HCFL\",15380],[502345,\"DYLQ657K\",15429],[171052,\"HG98HCFL\",15436],[\"1XW6HVBY\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[217806,\"FU1D57HA\",15469],[487305,\"5D5SUJ4Q\",15499],[44397,\"6QKM8CM8\",15536],[601607,\"XOK1HH1Y\",15566],[30391,\"HG98HCFL\",15586],[\"OZ13ZSIN\",\"OGVA50NO\"],[765285,\"IX7LS60B\",15641],[788097,\"T25R11PB\",15730],[300198,\"6TED6G4E\",15774],[529964,\"OZ13ZSIN\",15793],[803049,\"IEQICIHL\",15826],[\"OZ13ZSIN\",\"HG98HCFL\"],[7101,\"DKN9PRYJ\",15869],[\"T25R11PB\",\"FU1D57HA\"],[761575,\"D5TNGKU7\",15885],[93990,\"HG98HCFL\",15894],[323202,\"HG98HCFL\",15898],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"OZ13ZSIN\",15990],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"OGVA50NO\"],[213297,\"OZ13ZSIN\",16034],[300198,\"HG98HCFL\",16105],[912565,\"HG98HCFL\",16175],[806824,\"NJB0V6ZO\",16274],[417297,\"OZ13ZSIN\",16334],[\"XQ8MRL86\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[690271,\"GQINA28A\",16427],[540402,\"OZ13ZSIN\",16500],[807547,\"FU1D57HA\",16504],[335406,\"HG98HCFL\",16539],[417297,\"HG98HCFL\",16618],[192719,\"QB05LSRK\",16711],[255839,\"OZ13ZSIN\",16755],[\"OZ13ZSIN\",\"BMN7MUED\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[711297,\"OZ13ZSIN\",16810],[\"OZ13ZSIN\",\"CWJHORPF\"],[711297,\"HG98HCFL\",16899],[211279,\"VL2TL1NM\",16907],[\"XT14GVGK\",\"HG98HCFL\"],[\"XWO403P7\",\"HG98HCFL\"],[213297,\"FU1D57HA\",16964],[44397,\"7JHO6FK0\",17021],[\"4SBAAFIP\",\"HG98HCFL\"],[75634,\"H4UTDCR8\",17075],[996616,\"JYLXUII8\",17167],[775204,\"ZZLR3YVJ\",17215],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[211106,\"6TED6G4E\",17217],[649981,\"HG98HCFL\",17236],[775204,\"HG98HCFL\",17246],[806824,\"HG98HCFL\",17313],[214567,\"GWJB6BU5\",17411],[487305,\"FU1D57HA\",17496],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[237574,\"GA4KQD8H\",17572],[863199,\"OZ13ZSIN\",17616],[921800,\"OZ13ZSIN\",17693],[415592,\"NJB0V6ZO\",17784],[788097,\"FU1D57HA\",17844],[79918,\"ZR7QN32O\",17930],[240072,\"HG98HCFL\",17938],[\"OZ13ZSIN\",\"HG98HCFL\"],[253649,\"OZ13ZSIN\",17981],[545511,\"OZ13ZSIN\",18005],[237574,\"FU1D57HA\",18089],[\"OZ13ZSIN\",\"NTNXSB47\"],[255839,\"HG98HCFL\",18169],[701073,\"HJXEGP9U\",18269],[598091,\"FU1D57HA\",18287],[\"OZ13ZSIN\",\"HG98HCFL\"],[540402,\"HG98HCFL\",18349],[887853,\"GA4KQD8H\",18417],[\"XT82S77E\",\"LBYS94AD\"],[863199,\"HG98HCFL\",18484],[\"OZ13ZSIN\",\"HG98HCFL\"],[127768,\"OZ13ZSIN\",18571],[872173,\"OZ13ZSIN\",18579],[\"OZ13ZSIN\",\"HG98HCFL\"],[872173,\"UB4KML0J\",18638],[428110,\"HG98HCFL\",18720],[\"ITA0GE26\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[85526,\"OZ13ZSIN\",18803],[123308,\"HG98HCFL\",18872],[273723,\"FJVIO218\",18884],[\"OZ13ZSIN\",\"FU1D57HA\"],[716950,\"OZ13ZSIN\",18916],[436026,\"OZ13ZSIN\",18922],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[127768,\"FU1D57HA\",18931],[646079,\"IMDG88XX\",18944],[784931,\"OZ13ZSIN\",19001],[\"OZ13ZSIN\",\"OGVA50NO\"],[\"OZ13ZSIN\",\"H4UTDCR8\"],[803049,\"RPKD08C6\",19041],[627595,\"MBY9ZG7D\",19129],[386653,\"BMX2AIY5\",19179],[\"OZ13ZSIN\",\"CWJHORPF\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[211106,\"HG98HCFL\",19251],[855448,\"OZ13ZSIN\",19300],[733785,\"SPVKZTIP\",19344],[\"XOK1HH1Y\",\"HG98HCFL\"],[761575,\"HG98HCFL\",19444],[\"OZ13ZSIN\",\"HG98HCFL\"],[132966,\"H4UTDCR8\",19503],[948005,\"OZ13ZSIN\",19520],[14408,\"OZ13ZSIN\",19594],[\"I0Y75MZQ\",\"FU1D57HA\"],[85526,\"NTNXSB47\",19687],[211403,\"OZ13ZSIN\",19761],[677411,\"OZ13ZSIN\",19852],[192719,\"HG98HCFL\",19905],[887853,\"HG98HCFL\",19975],[455474,\"OZ13ZSIN\",20002],[601607,\"FU1D57HA\",20077],[14408,\"HG98HCFL\",20150],[\"OZ13ZSIN\",\"DKN9PRYJ\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[253649,\"1QLZUAXZ\",20166],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[548975,\"OZ13ZSIN\",20232],[386653,\"1QLZUAXZ\",20277],[415592,\"HG98HCFL\",20318],[716950,\"3ZJ18VKA\",20384],[84268,\"OZ13ZSIN\",20392],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[55374,\"4SBAAFIP\",20416],[851948,\"OZ13ZSIN\",20503],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"OZ13ZSIN\",20513],[615192,\"OZ13ZSIN\",20551],[851948,\"HG98HCFL\",20631],[211403,\"HG98HCFL\",20668],[677411,\"OGVA50NO\",20715],[55374,\"FU1D57HA\",20749],[457056,\"OZ13ZSIN\",20799],[\"XOK1HH1Y\",\"FU1D57HA\"],[548975,\"HG98HCFL\",20836],[41381,\"MY3O8OQI\",20908],[950414,\"OZ13ZSIN\",20971],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[873337,\"OZ13ZSIN\",21038],[\"5D5SUJ4Q\",\"FU1D57HA\"],[273723,\"FU1D57HA\",21053],[726970,\"OZ13ZSIN\",21070],[\"OZ13ZSIN\",\"HG98HCFL\"],[211279,\"HG98HCFL\",21127],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[276902,\"4T1TBZX5\",21160],[\"OZ13ZSIN\",\"HG98HCFL\"],[183959,\"OZ13ZSIN\",21209],[488167,\"OZ13ZSIN\",21250],[\"OZ13ZSIN\",\"HG98HCFL\"],[166180,\"OZ13ZSIN\",21323],[\"FJVIO218\",\"FU1D57HA\"],[636717,\"UB4KML0J\",21366],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"DLUQBV4V\",21413],[\"OZ13ZSIN\",\"FU1D57HA\"],[528132,\"LUCPET9G\",21476],[206116,\"0MOLP3NC\",21551],[183959,\"XPM6JMBR\",21562],[\"OZ13ZSIN\",\"HG98HCFL\"],[553646,\"BMX2AIY5\",21661],[\"OZ13ZSIN\",\"DLUQBV4V\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"SH04ZH5G\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"R62MQ4FI\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[724508,\"C00L36RI\",21665],[950414,\"FU1D57HA\",21721],[102566,\"NJB0V6ZO\",21819],[690271,\"HG98HCFL\",21829],[\"OZ13ZSIN\",\"HG98HCFL\"],[386570,\"OZ13ZSIN\",21870],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[733785,\"FU1D57HA\",21931],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"ZWJJHOU3\",\"H4UTDCR8\"],[493080,\"OZ13ZSIN\",21957],[\"OZ13ZSIN\",\"RBRIS3JS\"],[476818,\"NJB0V6ZO\",22018],[\"OZ13ZSIN\",\"HG98HCFL\"],[646079,\"VMT100K8\",22076],[873337,\"E35YW0BM\",22080],[529964,\"FU1D57HA\",22162],[41381,\"FU1D57HA\",22233],[\"1XW6HVBY\",\"HG98HCFL\"],[\"IMDG88XX\",\"VMT100K8\"],[724508,\"JYTPXJK9\",22301],[\"OZ13ZSIN\",\"FU1D57HA\"],[276768,\"OZ13ZSIN\",22339],[654375,\"1XW6HVBY\",22349],[276768,\"X1H2W3W0\",22438],[\"OZ13ZSIN\",\"UB4KML0J\"],[855448,\"KSOIJA62\",22533],[493080,\"FU1D57HA\",22554],[726970,\"E35YW0BM\",22603],[\"4SR0921V\",\"H4UTDCR8\"],[79918,\"R62MQ4FI\",22640],[659224,\"OZ13ZSIN\",22739],[436026,\"L6KOAIR1\",22770],[288997,\"E35YW0BM\",22850],[\"SAIV20VG\",\"FU1D57HA\"],[553646,\"FU1D57HA\",22946],[659224,\"NTNXSB47\",22957],[615192,\"HG98HCFL\",23056],[\"OZ13ZSIN\",\"E35YW0BM\"],[730441,\"1XW6HVBY\",23129],[55790,\"OZ13ZSIN\",23179],[524967,\"OZ13ZSIN\",23189],[44097,\"2GRLB4CN\",23280],[784931,\"E35YW0BM\",23343],[525825,\"OZ13ZSIN\",23384],[315479,\"XQ8MRL86\",23386],[537074,\"OZ13ZSIN\",23437],[\"XT82S77E\",\"LBYS94AD\"],[524967,\"7JIXF9D1\",23496],[559244,\"OZ13ZSIN\",23569],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[872522,\"FJVIO218\",23579],[160528,\"DE386QWN\",23602],[\"4SBAAFIP\",\"HG98HCFL\"],[832697,\"OZ13ZSIN\",23696],[439436,\"NJB0V6ZO\",23749],[559244,\"MJZC0DI0\",23811],[38958,\"4SBAAFIP\",23863],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[327722,\"OZ13ZSIN\",23901],[243726,\"OZ13ZSIN\",23955],[38958,\"WUIGDE36\",24007],[832697,\"4IBLBVYU\",24058],[626392,\"QK3YTSXO\",24064],[640646,\"OZ13ZSIN\",24084],[476818,\"R5XHXCAN\",24129],[13070,\"NJB0V6ZO\",24190],[\"VL2TL1NM\",\"HG98HCFL\"],[633159,\"GQYWQW84\",24235],[528132,\"MPBZFLN9\",24236],[668517,\"OZ13ZSIN\",24307],[627595,\"HG98HCFL\",24343],[\"OZ13ZSIN\",\"HG98HCFL\"],[438428,\"PQOMFBOJ\",24350],[386570,\"FU1D57HA\",24413],[668517,\"7JHO6FK0\",24482],[561608,\"2IVTIGII\",24575],[539280,\"ITA0GE26\",24660],[160528,\"7IO8ET8F\",24668],[\"T25R11PB\",\"FU1D57HA\"],[626392,\"FU1D57HA\",24755],[\"4SBAAFIP\",\"WUIGDE36\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[251034,\"4SBAAFIP\",24786],[968259,\"OZ13ZSIN\",24870],[640646,\"I9H1UDG4\",24892],[361979,\"OZ13ZSIN\",24945],[806004,\"WPM57THK\",25006],[488167,\"VL50N6D1\",25009],[\"XT82S77E\",\"LBYS94AD\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[\"XQ8MRL86\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HMJCZQ0K\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[787728,\"OZ13ZSIN\",25084],[95528,\"OZ13ZSIN\",25154],[825321,\"4SBAAFIP\",25200],[\"OZ13ZSIN\",\"HG98HCFL\"],[968259,\"HG98HCFL\",25234],[\"NJB0V6ZO\",\"HG98HCFL\"],[537074,\"2Z3A0H6F\",25283],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"1QLZUAXZ\"],[430837,\"ZOA7MKHB\",25342],[588541,\"OZ13ZSIN\",25380],[\"OZ13ZSIN\",\"HG98HCFL\"],[276902,\"FU1D57HA\",25448],[787728,\"BMN7MUED\",25495],[590184,\"KFRF7AEZ\",25577],[\"LUCPET9G\",\"MPBZFLN9\"],[510551,\"OZ13ZSIN\",25597],[806004,\"HG98HCFL\",25608],[925378,\"T25R11PB\",25614],[27187,\"NJB0V6ZO\",25651],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"DE386QWN\",25682],[525825,\"IX7LS60B\",25695],[876351,\"1XW6HVBY\",25761],[225487,\"SPVKZTIP\",25783],[159468,\"OZ13ZSIN\",25784],[785370,\"BMX2AIY5\",25819],[159468,\"FU1D57HA\",25847],[822091,\"1XW6HVBY\",25911],[142228,\"OZ13ZSIN\",25962],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"HG98HCFL\",25997],[6026,\"WPM57THK\",26000],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"J1X7TLQD\",26041],[42555,\"D5TNGKU7\",26042],[921331,\"XOK1HH1Y\",26066],[95528,\"GWVJKDKT\",26130],[361979,\"CWWVVCGZ\",26183],[747281,\"OZ13ZSIN\",26197],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"NJB0V6ZO\",\"7IO8ET8F\"],[590184,\"FY86VG9O\",26248],[443593,\"6TED6G4E\",26254],[921331,\"IVDGXU4R\",26354],[184691,\"XOK1HH1Y\",26394],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"D5TNGKU7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[997488,\"OZ13ZSIN\",26468],[161852,\"OZ13ZSIN\",26476],[42555,\"HG98HCFL\",26505],[948005,\"88RO58CG\",26517],[499506,\"ITA0GE26\",26545],[\"OZ13ZSIN\",\"FU1D57HA\"],[654375,\"FU1D57HA\",26593],[999272,\"OZ13ZSIN\",26641],[\"OZ13ZSIN\",\"FU1D57HA\"],[788492,\"OZ13ZSIN\",26738],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"4SBAAFIP\",\"E35YW0BM\"],[327722,\"HG98HCFL\",26780],[499506,\"GWVJKDKT\",26878],[825321,\"HG98HCFL\",26973],[\"CAWYGMWL\",\"NTNXSB47\"],[606855,\"C00L36RI\",26996],[498054,\"OZ13ZSIN\",27025],[455474,\"7JHO6FK0\",27070],[911613,\"OZ13ZSIN\",27170],[693354,\"O77WFMCI\",27225],[\"OZ13ZSIN\",\"HG98HCFL\"],[483609,\"G2LO9U87\",27250],[\"D5TNGKU7\",\"HG98HCFL\"],[914704,\"OZ13ZSIN\",27252],[835356,\"OZ13ZSIN\",27277],[\"XOK1HH1Y\",\"HG98HCFL\"],[243726,\"2Z3A0H6F\",27330],[788492,\"HG98HCFL\",27409],[\"FJVIO218\",\"FU1D57HA\"],[730441,\"HG98HCFL\",27465],[418199,\"OZ13ZSIN\",27557],[\"NJB0V6ZO\",\"HG98HCFL\"],[416184,\"X8W3R0P7\",27576],[177447,\"GQINA28A\",27661],[27187,\"Q6L1ZD92\",27684],[53005,\"MY3O8OQI\",27746],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[835356,\"HG98HCFL\",27775],[88784,\"NJB0V6ZO\",27865],[747281,\"HG98HCFL\",27921],[\"OZ13ZSIN\",\"HG98HCFL\"],[184691,\"CWWVVCGZ\",27974],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[554716,\"OZ13ZSIN\",28020],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"FU1D57HA\",28107],[\"ZR7QN32O\",\"R62MQ4FI\"],[326091,\"XOK1HH1Y\",28151],[927316,\"OZ13ZSIN\",28193],[\"T25R11PB\",\"FU1D57HA\"],[499875,\"NJB0V6ZO\",28256],[590013,\"OZ13ZSIN\",28354],[62740,\"OZ13ZSIN\",28413],[876351,\"FU1D57HA\",28469],[749462,\"OZ13ZSIN\",28525],[\"5D5SUJ4Q\",\"FU1D57HA\"],[996616,\"OGVA50NO\",28553],[177447,\"CWWVVCGZ\",28572],[\"OZ13ZSIN\",\"FU1D57HA\"],[438428,\"L6KOAIR1\",28631],[693354,\"DLUQBV4V\",28663],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[880171,\"475J29EI\",28754],[588541,\"1YA7XTV9\",28760],[457056,\"HG98HCFL\",28762],[\"OZ13ZSIN\",\"VL50N6D1\"],[84268,\"HG98HCFL\",28792],[130492,\"IMDG88XX\",28832],[163069,\"FWUZEALC\",28840],[\"C00L36RI\",\"JYTPXJK9\"],[417559,\"BMX2AIY5\",28890],[\"OZ13ZSIN\",\"HG98HCFL\"],[914704,\"FU1D57HA\",28939],[55617,\"VL2TL1NM\",28974],[\"4SBAAFIP\",\"E35YW0BM\"],[911613,\"FU1D57HA\",29069],[880171,\"HG98HCFL\",29099],[\"OZ13ZSIN\",\"FU1D57HA\"],[117275,\"4SBAAFIP\",29174],[822091,\"FU1D57HA\",29206],[775394,\"XQ8MRL86\",29284],[917846,\"4SBAAFIP\",29288],[55790,\"0NYQFXYO\",29343],[\"83OEBTCQ\",\"0BIIAVNU\"],[416184,\"HG98HCFL\",29415],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"FJVIO218\",\"FU1D57HA\"],[228425,\"OZ13ZSIN\",29438],[\"CAWYGMWL\",\"NTNXSB47\"],[87834,\"OZ13ZSIN\",29442],[633159,\"WMTPA7JN\",29482],[322118,\"OZ13ZSIN\",29526],[\"1XW6HVBY\",\"FU1D57HA\"],[675060,\"K9D63ZZC\",29617],[225487,\"RPKD08C6\",29691],[708687,\"OZ13ZSIN\",29761],[836854,\"OZ13ZSIN\",29845],[\"6QKM8CM8\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[299466,\"4SBAAFIP\",29860],[\"WGOD5SD4\",\"E35YW0BM\"],[\"X8W3R0P7\",\"FU1D57HA\"],[927316,\"HG98HCFL\",29938],[483609,\"HG98HCFL\",29995],[\"C00L36RI\",\"JYTPXJK9\"],[\"OZ13ZSIN\",\"L6KOAIR1\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"HG98HCFL\",30054],[870611,\"72Q6VPM1\",30066],[754460,\"4SBAAFIP\",30086],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[979711,\"OZ13ZSIN\",30112],[322118,\"EY70T3I1\",30197],[696824,\"ZWJJHOU3\",30263],[239811,\"WGOD5SD4\",30361],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"475J29EI\",\"HG98HCFL\"],[963752,\"1XW6HVBY\",30399],[764562,\"OZ13ZSIN\",30480],[165422,\"XQ8MRL86\",30559],[282372,\"2MKY7B5Q\",30609],[554716,\"HG98HCFL\",30700],[925378,\"HG98HCFL\",30705],[836854,\"UB4KML0J\",30802],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[328085,\"PYU6IFCW\",30865],[999272,\"NTNXSB47\",30884],[510551,\"HG98HCFL\",30903],[87834,\"HG98HCFL\",30918],[590013,\"HG98HCFL\",30950],[775394,\"MPBZFLN9\",30963],[701078,\"OZ13ZSIN\",31024],[561608,\"WIXJ6Z00\",31082],[\"OZ13ZSIN\",\"HG98HCFL\"],[328085,\"FU1D57HA\",31132],[165422,\"HG98HCFL\",31226],[997488,\"HG98HCFL\",31249],[785370,\"FY86VG9O\",31334],[186553,\"6GPMXUYZ\",31378],[282372,\"FU1D57HA\",31454],[88784,\"WMTPA7JN\",31484],[186637,\"973PO4KY\",31528],[62740,\"HG98HCFL\",31561],[206116,\"CWWVVCGZ\",31653],[525469,\"OZ13ZSIN\",31705],[\"OZ13ZSIN\",\"CWWVVCGZ\"],[109318,\"OZ13ZSIN\",31719],[954915,\"WS49LJP8\",31776],[\"OZ13ZSIN\",\"FU1D57HA\"],[166180,\"FU1D57HA\",31824],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"MY3O8OQI\",\"FU1D57HA\"],[539280,\"YZ8LNY1V\",31843],[\"OZ13ZSIN\",\"UB4KML0J\"],[901923,\"OZ13ZSIN\",31865],[963752,\"VMT100K8\",31918],[239811,\"HG98HCFL\",31990]]` wtf is this testcase bro \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "i feel stupid that i opened ur comment. LoL ! it took forever to scroll down"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "resolved ? me also getting error in this test case"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The May badge was not an easy one! Guys let\\'s get this done!!!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Yay!"
                    },
                    {
                        "username": "omeraktepe",
                        "content": "There is a test case that does not meet assumptions. \nTest case 56: [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]] \n\nIt violetes followings: \n1. A customer can only be checked into one place at a time. \n2. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order. \n\nI am too lazy to report though :)"
                    },
                    {
                        "username": "zavojchevski",
                        "content": "I agree on this, restrictions should be well explained. "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "For those failing test case 51:\\n\"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\"\\nCredit to xuawai for noticing this back in 2020."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Restrictions should be written stricter. Some strange cases which are valid:\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@psionl0](/psionl0) \\'getAverageTime\\' arguments are invalid: "
                    },
                    {
                        "username": "psionl0",
                        "content": "All your test cases work on my code but it fails on Leet testcase 49. I also tried\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"],[\"A\",\"C\"]]\n``` \nbut that seems to be an invalid test case."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[@anwendeng](/anwendeng) My code works too, but it\\'s strange."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I have tested all of your test cases and my program passed!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using  2 tables  to store the info.\nUse hash tables for check-in and travel time info! \nThe programming is easier than a standard design for Hash set!\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Thanks for spoiling the answer for people in reallllllly big font so they don\\'t accidently try to come up with the answer themselves! Real nice of you."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "but bro trust me designing a hash set is highly asked interview problem ...\\nI recalled my concept of how we can store data in hashset..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "## **Don't raise your font at us!**"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/design-underground-system/solutions/3580430/easy-c-python-solutions-with-unordered-map-dict/"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Now people here in discuss section only comment to boost up there reputation."
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "This is an issue here and with almost all of these problems. Using vague or ambiguous names for parameters would never be allowed in enterprise software development. \\'id\\' ? id of what? Argument with name \\'t\\' is it time, train, turn? the code should be explanatory even without the description. Its also a prevalent issue in the editorials and provided solutions. \\n\\nThis is also an accessibility and inclusivity issue. When working on teams where not everyone speaks or has native proficiency in the same language using abbreviations or short hand becomes a huge problem. Leetcode should try and make it\\'s examples as near to what would be expected in a real workplace not a college math class."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me feel bad for jumping over the gates every time I lost my ticket on the way.\nSorry for creating stupid edge cases to handle for some devs somewhere"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Today is a special day for me as I will be getting my first badge of leetcode.\nThrough this one month of solving questions daily, the one thing that I have learnt is nothing matters- not even motivation if you don't have the habit of being consistent throughout the journey. \nI am looking forward to be more consistent.\nHappy coding fellow leetcoders!!!"
                    }
                ]
            },
            {
                "id": 1911986,
                "content": [
                    {
                        "username": "jax_ay",
                        "content": "`[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkIn\",\"getAverageTime\",\"checkIn\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"checkOut\"] [[],[117077,\"OZ13ZSIN\",42],[117077,\"FU1D57HA\",125],[704903,\"OZ13ZSIN\",211],[911239,\"OZ13ZSIN\",245],[704903,\"HG98HCFL\",340],[859828,\"OZ13ZSIN\",355],[\"OZ13ZSIN\",\"FU1D57HA\"],[911239,\"FU1D57HA\",383],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[859828,\"FU1D57HA\",402],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[363027,\"OZ13ZSIN\",489],[319826,\"OZ13ZSIN\",550],[\"OZ13ZSIN\",\"FU1D57HA\"],[363027,\"HG98HCFL\",565],[319826,\"FU1D57HA\",664],[120084,\"OZ13ZSIN\",735],[\"OZ13ZSIN\",\"HG98HCFL\"],[120084,\"HG98HCFL\",832],[56672,\"OZ13ZSIN\",876],[56672,\"HG98HCFL\",912],[638995,\"OZ13ZSIN\",925],[\"OZ13ZSIN\",\"FU1D57HA\"],[638995,\"FU1D57HA\",951],[712949,\"OZ13ZSIN\",1023],[712949,\"FU1D57HA\",1033],[278482,\"T25R11PB\",1080],[\"OZ13ZSIN\",\"FU1D57HA\"],[278482,\"FU1D57HA\",1160],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[342818,\"4SBAAFIP\",1250],[342818,\"HG98HCFL\",1263],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[415673,\"OZ13ZSIN\",1270],[415673,\"NTNXSB47\",1366],[\"T25R11PB\",\"FU1D57HA\"],[597115,\"4SBAAFIP\",1385],[463555,\"OZ13ZSIN\",1461],[463555,\"HG98HCFL\",1514],[801778,\"OZ13ZSIN\",1537],[201428,\"OZ13ZSIN\",1620],[245538,\"OZ13ZSIN\",1630],[597115,\"FU1D57HA\",1657],[583112,\"OZ13ZSIN\",1690],[\"4SBAAFIP\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[691834,\"OZ13ZSIN\",1723],[250537,\"OZ13ZSIN\",1753],[201428,\"H4UTDCR8\",1804],[691834,\"FU1D57HA\",1838],[\"T25R11PB\",\"FU1D57HA\"],[245538,\"FU1D57HA\",1924],[346824,\"OZ13ZSIN\",1952],[864512,\"OZ13ZSIN\",2005],[499705,\"OZ13ZSIN\",2048],[482469,\"GQINA28A\",2058],[\"OZ13ZSIN\",\"FU1D57HA\"],[583112,\"E35YW0BM\",2080],[\"OZ13ZSIN\",\"HG98HCFL\"],[801778,\"HG98HCFL\",2082],[250415,\"I0Y75MZQ\",2149],[795633,\"OZ13ZSIN\",2196],[\"OZ13ZSIN\",\"HG98HCFL\"],[99144,\"4SBAAFIP\",2219],[83594,\"OZ13ZSIN\",2249],[346824,\"HG98HCFL\",2290],[482469,\"HG98HCFL\",2368],[499705,\"FU1D57HA\",2437],[12539,\"OZ13ZSIN\",2442],[116546,\"OZ13ZSIN\",2493],[884032,\"4SBAAFIP\",2579],[801142,\"OZ13ZSIN\",2598],[795633,\"HG98HCFL\",2693],[83594,\"HG98HCFL\",2782],[529306,\"OZ13ZSIN\",2824],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[286490,\"OZ13ZSIN\",2844],[255488,\"OZ13ZSIN\",2935],[608514,\"OZ13ZSIN\",2984],[116546,\"HG98HCFL\",3079],[250415,\"FU1D57HA\",3174],[\"OZ13ZSIN\",\"FU1D57HA\"],[884032,\"E35YW0BM\",3267],[\"OZ13ZSIN\",\"FU1D57HA\"],[529306,\"HG98HCFL\",3299],[\"OZ13ZSIN\",\"FU1D57HA\"],[892550,\"OZ13ZSIN\",3388],[892550,\"2VVKO5AZ\",3394],[14673,\"OZ13ZSIN\",3487],[\"OZ13ZSIN\",\"HG98HCFL\"],[12539,\"HG98HCFL\",3576],[\"OZ13ZSIN\",\"HG98HCFL\"],[255488,\"HG98HCFL\",3674],[\"OZ13ZSIN\",\"HG98HCFL\"],[14673,\"HG98HCFL\",3754],[864512,\"FU1D57HA\",3819],[451611,\"OZ13ZSIN\",3899],[\"4SBAAFIP\",\"E35YW0BM\"],[451611,\"HG98HCFL\",3941],[250537,\"HG98HCFL\",4027],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[286490,\"FU1D57HA\",4046],[608514,\"HG98HCFL\",4094],[827431,\"XWO403P7\",4107],[99144,\"HG98HCFL\",4136],[\"GQINA28A\",\"HG98HCFL\"],[657832,\"OZ13ZSIN\",4150],[827431,\"HG98HCFL\",4214],[\"OZ13ZSIN\",\"FU1D57HA\"],[658842,\"OZ13ZSIN\",4236],[52933,\"4SBAAFIP\",4325],[801142,\"HG98HCFL\",4413],[52933,\"E35YW0BM\",4460],[331712,\"OZ13ZSIN\",4522],[658842,\"NTNXSB47\",4615],[293734,\"OZ13ZSIN\",4665],[293734,\"HG98HCFL\",4735],[917903,\"OZ13ZSIN\",4772],[119860,\"OZ13ZSIN\",4775],[\"OZ13ZSIN\",\"HG98HCFL\"],[657832,\"E35YW0BM\",4850],[415861,\"NJB0V6ZO\",4881],[\"OZ13ZSIN\",\"FU1D57HA\"],[917903,\"HG98HCFL\",4892],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[415861,\"HG98HCFL\",4919],[\"OZ13ZSIN\",\"HG98HCFL\"],[331712,\"OGVA50NO\",4979],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[119860,\"HG98HCFL\",5034],[469875,\"OZ13ZSIN\",5053],[407362,\"XT14GVGK\",5073],[469875,\"HG98HCFL\",5126],[407362,\"HG98HCFL\",5175],[324747,\"OZ13ZSIN\",5236],[315560,\"OZ13ZSIN\",5333],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[317815,\"OZ13ZSIN\",5339],[906872,\"OZ13ZSIN\",5349],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[404251,\"OZ13ZSIN\",5375],[324747,\"HG98HCFL\",5474],[882572,\"OZ13ZSIN\",5524],[\"OZ13ZSIN\",\"HG98HCFL\"],[758501,\"OZ13ZSIN\",5561],[404251,\"FU1D57HA\",5617],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[315560,\"HG98HCFL\",5651],[758501,\"HG98HCFL\",5673],[141090,\"OZ13ZSIN\",5768],[882572,\"FU1D57HA\",5827],[906872,\"HG98HCFL\",5872],[141090,\"HG98HCFL\",5940],[\"OZ13ZSIN\",\"FU1D57HA\"],[317815,\"HG98HCFL\",5996],[436252,\"OZ13ZSIN\",6027],[\"OZ13ZSIN\",\"E35YW0BM\"],[436252,\"HG98HCFL\",6084],[\"OZ13ZSIN\",\"NTNXSB47\"],[652912,\"NJB0V6ZO\",6155],[652912,\"HG98HCFL\",6169],[269825,\"NJB0V6ZO\",6173],[831024,\"OZ13ZSIN\",6267],[831024,\"FU1D57HA\",6317],[269825,\"FU1D57HA\",6318],[794093,\"OZ13ZSIN\",6406],[\"OZ13ZSIN\",\"HG98HCFL\"],[794093,\"FU1D57HA\",6429],[798558,\"OZ13ZSIN\",6497],[798558,\"E35YW0BM\",6500],[271136,\"NJB0V6ZO\",6582],[\"OZ13ZSIN\",\"HG98HCFL\"],[608446,\"OZ13ZSIN\",6662],[608446,\"FU1D57HA\",6760],[986152,\"OZ13ZSIN\",6799],[986152,\"NTNXSB47\",6825],[271136,\"HG98HCFL\",6911],[\"OZ13ZSIN\",\"FU1D57HA\"],[341349,\"OZ13ZSIN\",6995],[595955,\"OZ13ZSIN\",7039],[58242,\"H9OKZANW\",7071],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"4SBAAFIP\",\"E35YW0BM\"],[134319,\"OZ13ZSIN\",7119],[595955,\"FU1D57HA\",7161],[\"OZ13ZSIN\",\"HG98HCFL\"],[266781,\"OZ13ZSIN\",7208],[\"OZ13ZSIN\",\"FU1D57HA\"],[266781,\"FU1D57HA\",7298],[\"OZ13ZSIN\",\"NTNXSB47\"],[935757,\"OZ13ZSIN\",7300],[517277,\"OZ13ZSIN\",7376],[58242,\"HG98HCFL\",7459],[\"OZ13ZSIN\",\"HG98HCFL\"],[288203,\"OZ13ZSIN\",7512],[293244,\"T25R11PB\",7580],[517277,\"HG98HCFL\",7588],[293244,\"FU1D57HA\",7649],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[480741,\"OZ13ZSIN\",7748],[288203,\"CWJHORPF\",7845],[935757,\"NTNXSB47\",7940],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[341349,\"HG98HCFL\",7952],[870607,\"ST6XEPDA\",7986],[\"OZ13ZSIN\",\"CWJHORPF\"],[468450,\"6QKM8CM8\",8063],[262669,\"OZ13ZSIN\",8152],[\"OZ13ZSIN\",\"FU1D57HA\"],[103929,\"OZ13ZSIN\",8167],[415331,\"X8W3R0P7\",8215],[134319,\"E35YW0BM\",8226],[415331,\"FU1D57HA\",8240],[468450,\"HG98HCFL\",8263],[394949,\"XOK1HH1Y\",8313],[\"OZ13ZSIN\",\"HG98HCFL\"],[394949,\"FU1D57HA\",8402],[67177,\"GQINA28A\",8451],[67177,\"HG98HCFL\",8521],[796191,\"QJHWOKDQ\",8545],[\"I0Y75MZQ\",\"FU1D57HA\"],[\"H9OKZANW\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[940010,\"OZ13ZSIN\",8583],[940010,\"VL50N6D1\",8613],[21260,\"WGOD5SD4\",8683],[746866,\"NJB0V6ZO\",8732],[47896,\"OZ13ZSIN\",8802],[480741,\"CWJHORPF\",8839],[\"NJB0V6ZO\",\"HG98HCFL\"],[310852,\"XT82S77E\",8858],[796001,\"OZ13ZSIN\",8860],[\"OZ13ZSIN\",\"NTNXSB47\"],[103929,\"FU1D57HA\",8957],[739455,\"OZ13ZSIN\",8980],[\"XWO403P7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"VL50N6D1\"],[734337,\"OZ13ZSIN\",8989],[686615,\"4SBAAFIP\",9086],[21260,\"HG98HCFL\",9130],[\"OZ13ZSIN\",\"CWJHORPF\"],[217165,\"1XW6HVBY\",9228],[689774,\"OZ13ZSIN\",9313],[870607,\"NTNXSB47\",9319],[248471,\"OZ13ZSIN\",9376],[262669,\"E35YW0BM\",9427],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[20582,\"OZ13ZSIN\",9484],[310852,\"LBYS94AD\",9535],[746866,\"FU1D57HA\",9540],[689774,\"FU1D57HA\",9594],[796191,\"HG98HCFL\",9635],[\"OZ13ZSIN\",\"FU1D57HA\"],[734337,\"HG98HCFL\",9683],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[982523,\"XWO403P7\",9689],[\"OZ13ZSIN\",\"OGVA50NO\"],[982523,\"HG98HCFL\",9786],[796001,\"FU1D57HA\",9869],[248471,\"FU1D57HA\",9942],[187843,\"OZ13ZSIN\",10035],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"H9OKZANW\",\"HG98HCFL\"],[217165,\"HG98HCFL\",10100],[739455,\"HG98HCFL\",10171],[187843,\"HG98HCFL\",10226],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[20582,\"E35YW0BM\",10322],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"SAIV20VG\",10342],[\"OZ13ZSIN\",\"FU1D57HA\"],[686615,\"HG98HCFL\",10396],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"CAWYGMWL\",10402],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[800300,\"OZ13ZSIN\",10472],[\"OZ13ZSIN\",\"HG98HCFL\"],[632035,\"NTNXSB47\",10485],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[800300,\"HG98HCFL\",10545],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[545686,\"FU1D57HA\",10581],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[47896,\"NTNXSB47\",10588],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[788823,\"83OEBTCQ\",10599],[\"CAWYGMWL\",\"NTNXSB47\"],[365416,\"OZ13ZSIN\",10690],[610273,\"OZ13ZSIN\",10757],[988219,\"FWUZEALC\",10767],[\"XT14GVGK\",\"HG98HCFL\"],[910256,\"OZ13ZSIN\",10797],[\"OZ13ZSIN\",\"CWJHORPF\"],[610273,\"FU1D57HA\",10848],[\"OZ13ZSIN\",\"FU1D57HA\"],[910256,\"HMJCZQ0K\",10920],[\"OZ13ZSIN\",\"NTNXSB47\"],[988219,\"HG98HCFL\",10930],[365416,\"HG98HCFL\",10972],[219722,\"OZ13ZSIN\",11033],[295336,\"ITA0GE26\",11107],[219722,\"R62MQ4FI\",11131],[295336,\"FU1D57HA\",11140],[788823,\"0BIIAVNU\",11199],[620927,\"T25R11PB\",11274],[620927,\"FU1D57HA\",11371],[630168,\"OZ13ZSIN\",11448],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[112534,\"OZ13ZSIN\",11449],[573142,\"OZ13ZSIN\",11546],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[454282,\"NJB0V6ZO\",11576],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[454282,\"HG98HCFL\",11643],[444090,\"6QKM8CM8\",11698],[630168,\"Y43BFD6U\",11717],[185093,\"1XW6HVBY\",11723],[217806,\"4SBAAFIP\",11814],[\"XOK1HH1Y\",\"FU1D57HA\"],[573142,\"FU1D57HA\",11874],[661431,\"UT8S3IM6\",11907],[335406,\"OZ13ZSIN\",11942],[\"T25R11PB\",\"FU1D57HA\"],[444090,\"HG98HCFL\",11995],[896969,\"QJHWOKDQ\",12032],[950584,\"NJB0V6ZO\",12097],[570450,\"NJB0V6ZO\",12128],[896969,\"HG98HCFL\",12146],[71637,\"4SBAAFIP\",12202],[923844,\"OZ13ZSIN\",12277],[\"NJB0V6ZO\",\"HG98HCFL\"],[374491,\"OZ13ZSIN\",12300],[333698,\"1XW6HVBY\",12343],[323202,\"4SBAAFIP\",12369],[489161,\"OZ13ZSIN\",12419],[489161,\"BMN7MUED\",12446],[177905,\"XOK1HH1Y\",12483],[\"GQINA28A\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[185093,\"FU1D57HA\",12520],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"OZ13ZSIN\",12538],[765285,\"OZ13ZSIN\",12554],[\"OZ13ZSIN\",\"VL50N6D1\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[80760,\"XOK1HH1Y\",12613],[570450,\"R47UH9EC\",12643],[777227,\"OZ13ZSIN\",12717],[30391,\"XQ8MRL86\",12743],[923844,\"NTNXSB47\",12843],[\"OZ13ZSIN\",\"HG98HCFL\"],[177905,\"HG98HCFL\",12901],[374491,\"2Z3A0H6F\",12957],[950584,\"7IO8ET8F\",13035],[\"1XW6HVBY\",\"HG98HCFL\"],[636717,\"WY85FIVE\",13122],[661431,\"L6KOAIR1\",13154],[80760,\"XIUOFK2Y\",13215],[\"OZ13ZSIN\",\"HG98HCFL\"],[428110,\"4SBAAFIP\",13262],[\"H9OKZANW\",\"HG98HCFL\"],[\"QJHWOKDQ\",\"HG98HCFL\"],[\"83OEBTCQ\",\"0BIIAVNU\"],[502345,\"1MOLNL46\",13324],[112534,\"HG98HCFL\",13393],[\"OZ13ZSIN\",\"HG98HCFL\"],[25332,\"OZ13ZSIN\",13487],[240072,\"OZ13ZSIN\",13504],[649981,\"ITA0GE26\",13603],[363027,\"NJB0V6ZO\",13627],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[733972,\"FU1D57HA\",13724],[961598,\"ST6XEPDA\",13810],[75634,\"ZWJJHOU3\",13877],[807547,\"OZ13ZSIN\",13900],[\"OZ13ZSIN\",\"FU1D57HA\"],[71637,\"HG98HCFL\",13998],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[300645,\"OZ13ZSIN\",14033],[849654,\"OZ13ZSIN\",14128],[701073,\"GQINA28A\",14209],[288997,\"WGOD5SD4\",14252],[7101,\"OZ13ZSIN\",14258],[143698,\"SH04ZH5G\",14355],[849654,\"HG98HCFL\",14395],[300645,\"RBRIS3JS\",14484],[171052,\"OZ13ZSIN\",14576],[214567,\"NJB0V6ZO\",14592],[961598,\"JYTPXJK9\",14646],[132966,\"4SR0921V\",14665],[822925,\"4SBAAFIP\",14742],[333698,\"HG98HCFL\",14835],[\"OZ13ZSIN\",\"HG98HCFL\"],[822925,\"E35YW0BM\",14920],[777227,\"HG98HCFL\",15017],[123308,\"OZ13ZSIN\",15095],[598091,\"6QKM8CM8\",15150],[363027,\"HG98HCFL\",15160],[912565,\"OZ13ZSIN\",15202],[93990,\"1XW6HVBY\",15291],[\"OZ13ZSIN\",\"2VVKO5AZ\"],[25332,\"FU1D57HA\",15332],[143698,\"HG98HCFL\",15380],[502345,\"DYLQ657K\",15429],[171052,\"HG98HCFL\",15436],[\"1XW6HVBY\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[217806,\"FU1D57HA\",15469],[487305,\"5D5SUJ4Q\",15499],[44397,\"6QKM8CM8\",15536],[601607,\"XOK1HH1Y\",15566],[30391,\"HG98HCFL\",15586],[\"OZ13ZSIN\",\"OGVA50NO\"],[765285,\"IX7LS60B\",15641],[788097,\"T25R11PB\",15730],[300198,\"6TED6G4E\",15774],[529964,\"OZ13ZSIN\",15793],[803049,\"IEQICIHL\",15826],[\"OZ13ZSIN\",\"HG98HCFL\"],[7101,\"DKN9PRYJ\",15869],[\"T25R11PB\",\"FU1D57HA\"],[761575,\"D5TNGKU7\",15885],[93990,\"HG98HCFL\",15894],[323202,\"HG98HCFL\",15898],[\"NJB0V6ZO\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"OZ13ZSIN\",15990],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"OGVA50NO\"],[213297,\"OZ13ZSIN\",16034],[300198,\"HG98HCFL\",16105],[912565,\"HG98HCFL\",16175],[806824,\"NJB0V6ZO\",16274],[417297,\"OZ13ZSIN\",16334],[\"XQ8MRL86\",\"HG98HCFL\"],[\"NJB0V6ZO\",\"HG98HCFL\"],[690271,\"GQINA28A\",16427],[540402,\"OZ13ZSIN\",16500],[807547,\"FU1D57HA\",16504],[335406,\"HG98HCFL\",16539],[417297,\"HG98HCFL\",16618],[192719,\"QB05LSRK\",16711],[255839,\"OZ13ZSIN\",16755],[\"OZ13ZSIN\",\"BMN7MUED\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[711297,\"OZ13ZSIN\",16810],[\"OZ13ZSIN\",\"CWJHORPF\"],[711297,\"HG98HCFL\",16899],[211279,\"VL2TL1NM\",16907],[\"XT14GVGK\",\"HG98HCFL\"],[\"XWO403P7\",\"HG98HCFL\"],[213297,\"FU1D57HA\",16964],[44397,\"7JHO6FK0\",17021],[\"4SBAAFIP\",\"HG98HCFL\"],[75634,\"H4UTDCR8\",17075],[996616,\"JYLXUII8\",17167],[775204,\"ZZLR3YVJ\",17215],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[211106,\"6TED6G4E\",17217],[649981,\"HG98HCFL\",17236],[775204,\"HG98HCFL\",17246],[806824,\"HG98HCFL\",17313],[214567,\"GWJB6BU5\",17411],[487305,\"FU1D57HA\",17496],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[237574,\"GA4KQD8H\",17572],[863199,\"OZ13ZSIN\",17616],[921800,\"OZ13ZSIN\",17693],[415592,\"NJB0V6ZO\",17784],[788097,\"FU1D57HA\",17844],[79918,\"ZR7QN32O\",17930],[240072,\"HG98HCFL\",17938],[\"OZ13ZSIN\",\"HG98HCFL\"],[253649,\"OZ13ZSIN\",17981],[545511,\"OZ13ZSIN\",18005],[237574,\"FU1D57HA\",18089],[\"OZ13ZSIN\",\"NTNXSB47\"],[255839,\"HG98HCFL\",18169],[701073,\"HJXEGP9U\",18269],[598091,\"FU1D57HA\",18287],[\"OZ13ZSIN\",\"HG98HCFL\"],[540402,\"HG98HCFL\",18349],[887853,\"GA4KQD8H\",18417],[\"XT82S77E\",\"LBYS94AD\"],[863199,\"HG98HCFL\",18484],[\"OZ13ZSIN\",\"HG98HCFL\"],[127768,\"OZ13ZSIN\",18571],[872173,\"OZ13ZSIN\",18579],[\"OZ13ZSIN\",\"HG98HCFL\"],[872173,\"UB4KML0J\",18638],[428110,\"HG98HCFL\",18720],[\"ITA0GE26\",\"HG98HCFL\"],[\"4SBAAFIP\",\"HG98HCFL\"],[85526,\"OZ13ZSIN\",18803],[123308,\"HG98HCFL\",18872],[273723,\"FJVIO218\",18884],[\"OZ13ZSIN\",\"FU1D57HA\"],[716950,\"OZ13ZSIN\",18916],[436026,\"OZ13ZSIN\",18922],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[127768,\"FU1D57HA\",18931],[646079,\"IMDG88XX\",18944],[784931,\"OZ13ZSIN\",19001],[\"OZ13ZSIN\",\"OGVA50NO\"],[\"OZ13ZSIN\",\"H4UTDCR8\"],[803049,\"RPKD08C6\",19041],[627595,\"MBY9ZG7D\",19129],[386653,\"BMX2AIY5\",19179],[\"OZ13ZSIN\",\"CWJHORPF\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[211106,\"HG98HCFL\",19251],[855448,\"OZ13ZSIN\",19300],[733785,\"SPVKZTIP\",19344],[\"XOK1HH1Y\",\"HG98HCFL\"],[761575,\"HG98HCFL\",19444],[\"OZ13ZSIN\",\"HG98HCFL\"],[132966,\"H4UTDCR8\",19503],[948005,\"OZ13ZSIN\",19520],[14408,\"OZ13ZSIN\",19594],[\"I0Y75MZQ\",\"FU1D57HA\"],[85526,\"NTNXSB47\",19687],[211403,\"OZ13ZSIN\",19761],[677411,\"OZ13ZSIN\",19852],[192719,\"HG98HCFL\",19905],[887853,\"HG98HCFL\",19975],[455474,\"OZ13ZSIN\",20002],[601607,\"FU1D57HA\",20077],[14408,\"HG98HCFL\",20150],[\"OZ13ZSIN\",\"DKN9PRYJ\"],[\"OZ13ZSIN\",\"CWJHORPF\"],[253649,\"1QLZUAXZ\",20166],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[548975,\"OZ13ZSIN\",20232],[386653,\"1QLZUAXZ\",20277],[415592,\"HG98HCFL\",20318],[716950,\"3ZJ18VKA\",20384],[84268,\"OZ13ZSIN\",20392],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[55374,\"4SBAAFIP\",20416],[851948,\"OZ13ZSIN\",20503],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"OZ13ZSIN\",20513],[615192,\"OZ13ZSIN\",20551],[851948,\"HG98HCFL\",20631],[211403,\"HG98HCFL\",20668],[677411,\"OGVA50NO\",20715],[55374,\"FU1D57HA\",20749],[457056,\"OZ13ZSIN\",20799],[\"XOK1HH1Y\",\"FU1D57HA\"],[548975,\"HG98HCFL\",20836],[41381,\"MY3O8OQI\",20908],[950414,\"OZ13ZSIN\",20971],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[873337,\"OZ13ZSIN\",21038],[\"5D5SUJ4Q\",\"FU1D57HA\"],[273723,\"FU1D57HA\",21053],[726970,\"OZ13ZSIN\",21070],[\"OZ13ZSIN\",\"HG98HCFL\"],[211279,\"HG98HCFL\",21127],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"RBRIS3JS\"],[\"4SBAAFIP\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"E35YW0BM\"],[276902,\"4T1TBZX5\",21160],[\"OZ13ZSIN\",\"HG98HCFL\"],[183959,\"OZ13ZSIN\",21209],[488167,\"OZ13ZSIN\",21250],[\"OZ13ZSIN\",\"HG98HCFL\"],[166180,\"OZ13ZSIN\",21323],[\"FJVIO218\",\"FU1D57HA\"],[636717,\"UB4KML0J\",21366],[\"OZ13ZSIN\",\"FU1D57HA\"],[161041,\"DLUQBV4V\",21413],[\"OZ13ZSIN\",\"FU1D57HA\"],[528132,\"LUCPET9G\",21476],[206116,\"0MOLP3NC\",21551],[183959,\"XPM6JMBR\",21562],[\"OZ13ZSIN\",\"HG98HCFL\"],[553646,\"BMX2AIY5\",21661],[\"OZ13ZSIN\",\"DLUQBV4V\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"SH04ZH5G\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"R62MQ4FI\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[724508,\"C00L36RI\",21665],[950414,\"FU1D57HA\",21721],[102566,\"NJB0V6ZO\",21819],[690271,\"HG98HCFL\",21829],[\"OZ13ZSIN\",\"HG98HCFL\"],[386570,\"OZ13ZSIN\",21870],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[733785,\"FU1D57HA\",21931],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"ZWJJHOU3\",\"H4UTDCR8\"],[493080,\"OZ13ZSIN\",21957],[\"OZ13ZSIN\",\"RBRIS3JS\"],[476818,\"NJB0V6ZO\",22018],[\"OZ13ZSIN\",\"HG98HCFL\"],[646079,\"VMT100K8\",22076],[873337,\"E35YW0BM\",22080],[529964,\"FU1D57HA\",22162],[41381,\"FU1D57HA\",22233],[\"1XW6HVBY\",\"HG98HCFL\"],[\"IMDG88XX\",\"VMT100K8\"],[724508,\"JYTPXJK9\",22301],[\"OZ13ZSIN\",\"FU1D57HA\"],[276768,\"OZ13ZSIN\",22339],[654375,\"1XW6HVBY\",22349],[276768,\"X1H2W3W0\",22438],[\"OZ13ZSIN\",\"UB4KML0J\"],[855448,\"KSOIJA62\",22533],[493080,\"FU1D57HA\",22554],[726970,\"E35YW0BM\",22603],[\"4SR0921V\",\"H4UTDCR8\"],[79918,\"R62MQ4FI\",22640],[659224,\"OZ13ZSIN\",22739],[436026,\"L6KOAIR1\",22770],[288997,\"E35YW0BM\",22850],[\"SAIV20VG\",\"FU1D57HA\"],[553646,\"FU1D57HA\",22946],[659224,\"NTNXSB47\",22957],[615192,\"HG98HCFL\",23056],[\"OZ13ZSIN\",\"E35YW0BM\"],[730441,\"1XW6HVBY\",23129],[55790,\"OZ13ZSIN\",23179],[524967,\"OZ13ZSIN\",23189],[44097,\"2GRLB4CN\",23280],[784931,\"E35YW0BM\",23343],[525825,\"OZ13ZSIN\",23384],[315479,\"XQ8MRL86\",23386],[537074,\"OZ13ZSIN\",23437],[\"XT82S77E\",\"LBYS94AD\"],[524967,\"7JIXF9D1\",23496],[559244,\"OZ13ZSIN\",23569],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[872522,\"FJVIO218\",23579],[160528,\"DE386QWN\",23602],[\"4SBAAFIP\",\"HG98HCFL\"],[832697,\"OZ13ZSIN\",23696],[439436,\"NJB0V6ZO\",23749],[559244,\"MJZC0DI0\",23811],[38958,\"4SBAAFIP\",23863],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[327722,\"OZ13ZSIN\",23901],[243726,\"OZ13ZSIN\",23955],[38958,\"WUIGDE36\",24007],[832697,\"4IBLBVYU\",24058],[626392,\"QK3YTSXO\",24064],[640646,\"OZ13ZSIN\",24084],[476818,\"R5XHXCAN\",24129],[13070,\"NJB0V6ZO\",24190],[\"VL2TL1NM\",\"HG98HCFL\"],[633159,\"GQYWQW84\",24235],[528132,\"MPBZFLN9\",24236],[668517,\"OZ13ZSIN\",24307],[627595,\"HG98HCFL\",24343],[\"OZ13ZSIN\",\"HG98HCFL\"],[438428,\"PQOMFBOJ\",24350],[386570,\"FU1D57HA\",24413],[668517,\"7JHO6FK0\",24482],[561608,\"2IVTIGII\",24575],[539280,\"ITA0GE26\",24660],[160528,\"7IO8ET8F\",24668],[\"T25R11PB\",\"FU1D57HA\"],[626392,\"FU1D57HA\",24755],[\"4SBAAFIP\",\"WUIGDE36\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"5D5SUJ4Q\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[251034,\"4SBAAFIP\",24786],[968259,\"OZ13ZSIN\",24870],[640646,\"I9H1UDG4\",24892],[361979,\"OZ13ZSIN\",24945],[806004,\"WPM57THK\",25006],[488167,\"VL50N6D1\",25009],[\"XT82S77E\",\"LBYS94AD\"],[\"OZ13ZSIN\",\"IX7LS60B\"],[\"XQ8MRL86\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HMJCZQ0K\"],[\"I0Y75MZQ\",\"FU1D57HA\"],[787728,\"OZ13ZSIN\",25084],[95528,\"OZ13ZSIN\",25154],[825321,\"4SBAAFIP\",25200],[\"OZ13ZSIN\",\"HG98HCFL\"],[968259,\"HG98HCFL\",25234],[\"NJB0V6ZO\",\"HG98HCFL\"],[537074,\"2Z3A0H6F\",25283],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"1QLZUAXZ\"],[430837,\"ZOA7MKHB\",25342],[588541,\"OZ13ZSIN\",25380],[\"OZ13ZSIN\",\"HG98HCFL\"],[276902,\"FU1D57HA\",25448],[787728,\"BMN7MUED\",25495],[590184,\"KFRF7AEZ\",25577],[\"LUCPET9G\",\"MPBZFLN9\"],[510551,\"OZ13ZSIN\",25597],[806004,\"HG98HCFL\",25608],[925378,\"T25R11PB\",25614],[27187,\"NJB0V6ZO\",25651],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"DE386QWN\",25682],[525825,\"IX7LS60B\",25695],[876351,\"1XW6HVBY\",25761],[225487,\"SPVKZTIP\",25783],[159468,\"OZ13ZSIN\",25784],[785370,\"BMX2AIY5\",25819],[159468,\"FU1D57HA\",25847],[822091,\"1XW6HVBY\",25911],[142228,\"OZ13ZSIN\",25962],[\"OZ13ZSIN\",\"HG98HCFL\"],[516749,\"HG98HCFL\",25997],[6026,\"WPM57THK\",26000],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"J1X7TLQD\",26041],[42555,\"D5TNGKU7\",26042],[921331,\"XOK1HH1Y\",26066],[95528,\"GWVJKDKT\",26130],[361979,\"CWWVVCGZ\",26183],[747281,\"OZ13ZSIN\",26197],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"NJB0V6ZO\",\"7IO8ET8F\"],[590184,\"FY86VG9O\",26248],[443593,\"6TED6G4E\",26254],[921331,\"IVDGXU4R\",26354],[184691,\"XOK1HH1Y\",26394],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[\"D5TNGKU7\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[997488,\"OZ13ZSIN\",26468],[161852,\"OZ13ZSIN\",26476],[42555,\"HG98HCFL\",26505],[948005,\"88RO58CG\",26517],[499506,\"ITA0GE26\",26545],[\"OZ13ZSIN\",\"FU1D57HA\"],[654375,\"FU1D57HA\",26593],[999272,\"OZ13ZSIN\",26641],[\"OZ13ZSIN\",\"FU1D57HA\"],[788492,\"OZ13ZSIN\",26738],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"4SBAAFIP\",\"E35YW0BM\"],[327722,\"HG98HCFL\",26780],[499506,\"GWVJKDKT\",26878],[825321,\"HG98HCFL\",26973],[\"CAWYGMWL\",\"NTNXSB47\"],[606855,\"C00L36RI\",26996],[498054,\"OZ13ZSIN\",27025],[455474,\"7JHO6FK0\",27070],[911613,\"OZ13ZSIN\",27170],[693354,\"O77WFMCI\",27225],[\"OZ13ZSIN\",\"HG98HCFL\"],[483609,\"G2LO9U87\",27250],[\"D5TNGKU7\",\"HG98HCFL\"],[914704,\"OZ13ZSIN\",27252],[835356,\"OZ13ZSIN\",27277],[\"XOK1HH1Y\",\"HG98HCFL\"],[243726,\"2Z3A0H6F\",27330],[788492,\"HG98HCFL\",27409],[\"FJVIO218\",\"FU1D57HA\"],[730441,\"HG98HCFL\",27465],[418199,\"OZ13ZSIN\",27557],[\"NJB0V6ZO\",\"HG98HCFL\"],[416184,\"X8W3R0P7\",27576],[177447,\"GQINA28A\",27661],[27187,\"Q6L1ZD92\",27684],[53005,\"MY3O8OQI\",27746],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[835356,\"HG98HCFL\",27775],[88784,\"NJB0V6ZO\",27865],[747281,\"HG98HCFL\",27921],[\"OZ13ZSIN\",\"HG98HCFL\"],[184691,\"CWWVVCGZ\",27974],[\"4SBAAFIP\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"FU1D57HA\"],[554716,\"OZ13ZSIN\",28020],[\"OZ13ZSIN\",\"HG98HCFL\"],[143005,\"FU1D57HA\",28107],[\"ZR7QN32O\",\"R62MQ4FI\"],[326091,\"XOK1HH1Y\",28151],[927316,\"OZ13ZSIN\",28193],[\"T25R11PB\",\"FU1D57HA\"],[499875,\"NJB0V6ZO\",28256],[590013,\"OZ13ZSIN\",28354],[62740,\"OZ13ZSIN\",28413],[876351,\"FU1D57HA\",28469],[749462,\"OZ13ZSIN\",28525],[\"5D5SUJ4Q\",\"FU1D57HA\"],[996616,\"OGVA50NO\",28553],[177447,\"CWWVVCGZ\",28572],[\"OZ13ZSIN\",\"FU1D57HA\"],[438428,\"L6KOAIR1\",28631],[693354,\"DLUQBV4V\",28663],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[880171,\"475J29EI\",28754],[588541,\"1YA7XTV9\",28760],[457056,\"HG98HCFL\",28762],[\"OZ13ZSIN\",\"VL50N6D1\"],[84268,\"HG98HCFL\",28792],[130492,\"IMDG88XX\",28832],[163069,\"FWUZEALC\",28840],[\"C00L36RI\",\"JYTPXJK9\"],[417559,\"BMX2AIY5\",28890],[\"OZ13ZSIN\",\"HG98HCFL\"],[914704,\"FU1D57HA\",28939],[55617,\"VL2TL1NM\",28974],[\"4SBAAFIP\",\"E35YW0BM\"],[911613,\"FU1D57HA\",29069],[880171,\"HG98HCFL\",29099],[\"OZ13ZSIN\",\"FU1D57HA\"],[117275,\"4SBAAFIP\",29174],[822091,\"FU1D57HA\",29206],[775394,\"XQ8MRL86\",29284],[917846,\"4SBAAFIP\",29288],[55790,\"0NYQFXYO\",29343],[\"83OEBTCQ\",\"0BIIAVNU\"],[416184,\"HG98HCFL\",29415],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"FJVIO218\",\"FU1D57HA\"],[228425,\"OZ13ZSIN\",29438],[\"CAWYGMWL\",\"NTNXSB47\"],[87834,\"OZ13ZSIN\",29442],[633159,\"WMTPA7JN\",29482],[322118,\"OZ13ZSIN\",29526],[\"1XW6HVBY\",\"FU1D57HA\"],[675060,\"K9D63ZZC\",29617],[225487,\"RPKD08C6\",29691],[708687,\"OZ13ZSIN\",29761],[836854,\"OZ13ZSIN\",29845],[\"6QKM8CM8\",\"HG98HCFL\"],[\"1XW6HVBY\",\"HG98HCFL\"],[299466,\"4SBAAFIP\",29860],[\"WGOD5SD4\",\"E35YW0BM\"],[\"X8W3R0P7\",\"FU1D57HA\"],[927316,\"HG98HCFL\",29938],[483609,\"HG98HCFL\",29995],[\"C00L36RI\",\"JYTPXJK9\"],[\"OZ13ZSIN\",\"L6KOAIR1\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"T25R11PB\",\"FU1D57HA\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[564919,\"HG98HCFL\",30054],[870611,\"72Q6VPM1\",30066],[754460,\"4SBAAFIP\",30086],[\"OZ13ZSIN\",\"E35YW0BM\"],[\"OZ13ZSIN\",\"HG98HCFL\"],[979711,\"OZ13ZSIN\",30112],[322118,\"EY70T3I1\",30197],[696824,\"ZWJJHOU3\",30263],[239811,\"WGOD5SD4\",30361],[\"OZ13ZSIN\",\"HG98HCFL\"],[\"475J29EI\",\"HG98HCFL\"],[963752,\"1XW6HVBY\",30399],[764562,\"OZ13ZSIN\",30480],[165422,\"XQ8MRL86\",30559],[282372,\"2MKY7B5Q\",30609],[554716,\"HG98HCFL\",30700],[925378,\"HG98HCFL\",30705],[836854,\"UB4KML0J\",30802],[\"OZ13ZSIN\",\"UB4KML0J\"],[\"OZ13ZSIN\",\"NTNXSB47\"],[328085,\"PYU6IFCW\",30865],[999272,\"NTNXSB47\",30884],[510551,\"HG98HCFL\",30903],[87834,\"HG98HCFL\",30918],[590013,\"HG98HCFL\",30950],[775394,\"MPBZFLN9\",30963],[701078,\"OZ13ZSIN\",31024],[561608,\"WIXJ6Z00\",31082],[\"OZ13ZSIN\",\"HG98HCFL\"],[328085,\"FU1D57HA\",31132],[165422,\"HG98HCFL\",31226],[997488,\"HG98HCFL\",31249],[785370,\"FY86VG9O\",31334],[186553,\"6GPMXUYZ\",31378],[282372,\"FU1D57HA\",31454],[88784,\"WMTPA7JN\",31484],[186637,\"973PO4KY\",31528],[62740,\"HG98HCFL\",31561],[206116,\"CWWVVCGZ\",31653],[525469,\"OZ13ZSIN\",31705],[\"OZ13ZSIN\",\"CWWVVCGZ\"],[109318,\"OZ13ZSIN\",31719],[954915,\"WS49LJP8\",31776],[\"OZ13ZSIN\",\"FU1D57HA\"],[166180,\"FU1D57HA\",31824],[\"OZ13ZSIN\",\"FU1D57HA\"],[\"MY3O8OQI\",\"FU1D57HA\"],[539280,\"YZ8LNY1V\",31843],[\"OZ13ZSIN\",\"UB4KML0J\"],[901923,\"OZ13ZSIN\",31865],[963752,\"VMT100K8\",31918],[239811,\"HG98HCFL\",31990]]` wtf is this testcase bro \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "i feel stupid that i opened ur comment. LoL ! it took forever to scroll down"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "resolved ? me also getting error in this test case"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The May badge was not an easy one! Guys let\\'s get this done!!!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Yay!"
                    },
                    {
                        "username": "omeraktepe",
                        "content": "There is a test case that does not meet assumptions. \nTest case 56: [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[45,\"Leyton\",4], [45,\"Waterloo\",15],[\"Leyton\",\"Waterloo\"],[45,\"Waterloo\",18],[\"Leyton\",\"Waterloo\"]] \n\nIt violetes followings: \n1. A customer can only be checked into one place at a time. \n2. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order. \n\nI am too lazy to report though :)"
                    },
                    {
                        "username": "zavojchevski",
                        "content": "I agree on this, restrictions should be well explained. "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "For those failing test case 51:\\n\"The description of the problem is really confusing. It should point out clearly that a customer can get in a station repeatedly.\"\\nCredit to xuawai for noticing this back in 2020."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Restrictions should be written stricter. Some strange cases which are valid:\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"A\",\"C\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"A\",5], [1,\"B\",7],[\"A\",\"B\"]]\n```\n\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@psionl0](/psionl0) \\'getAverageTime\\' arguments are invalid: "
                    },
                    {
                        "username": "psionl0",
                        "content": "All your test cases work on my code but it fails on Leet testcase 49. I also tried\n```\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"getAverageTime\"]\n[[],[1,\"A\",3], [1,\"B\",5], [1,\"C\",7],[\"B\",\"C\"],[\"A\",\"C\"]]\n``` \nbut that seems to be an invalid test case."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[@anwendeng](/anwendeng) My code works too, but it\\'s strange."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I have tested all of your test cases and my program passed!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using  2 tables  to store the info.\nUse hash tables for check-in and travel time info! \nThe programming is easier than a standard design for Hash set!\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Thanks for spoiling the answer for people in reallllllly big font so they don\\'t accidently try to come up with the answer themselves! Real nice of you."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "but bro trust me designing a hash set is highly asked interview problem ...\\nI recalled my concept of how we can store data in hashset..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "## **Don't raise your font at us!**"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/design-underground-system/solutions/3580430/easy-c-python-solutions-with-unordered-map-dict/"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Now people here in discuss section only comment to boost up there reputation."
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "This is an issue here and with almost all of these problems. Using vague or ambiguous names for parameters would never be allowed in enterprise software development. \\'id\\' ? id of what? Argument with name \\'t\\' is it time, train, turn? the code should be explanatory even without the description. Its also a prevalent issue in the editorials and provided solutions. \\n\\nThis is also an accessibility and inclusivity issue. When working on teams where not everyone speaks or has native proficiency in the same language using abbreviations or short hand becomes a huge problem. Leetcode should try and make it\\'s examples as near to what would be expected in a real workplace not a college math class."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me feel bad for jumping over the gates every time I lost my ticket on the way.\nSorry for creating stupid edge cases to handle for some devs somewhere"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Today is a special day for me as I will be getting my first badge of leetcode.\nThrough this one month of solving questions daily, the one thing that I have learnt is nothing matters- not even motivation if you don't have the habit of being consistent throughout the journey. \nI am looking forward to be more consistent.\nHappy coding fellow leetcoders!!!"
                    }
                ]
            },
            {
                "id": 1911864,
                "content": [
                    {
                        "username": "bhrtsnegi",
                        "content": "It can be done using Multidimensional Map but the things is how to make that mapping because in time and out time is also different for different id\\'s"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Uff not so difficult one finally! "
                    },
                    {
                        "username": "pthread",
                        "content": "For example, should average time from say A to B be equal to time from B to A?!? Or they are running on different tracks and A -> B might be different from B -> A?!?"
                    },
                    {
                        "username": "chickooo",
                        "content": "To be on a safe side, assume that the train returns from a different route"
                    },
                    {
                        "username": "t_khandaker",
                        "content": "Hello everyone,\\n\\nI have finally stucked up with too many wron answers for this precision issue as I could not find any difference from leetcode tools.\\n\\nI am just wondering if anyone have challenged it with C coding. Will appreciate the talent who can feel my hunger.\\n\\nPlease respond me if anyone curious...\\n\\n\\nThanks"
                    },
                    {
                        "username": "ChrisTrompf",
                        "content": "A bit late to the party, but you can check out my [c solution](https://leetcode.com/problems/design-underground-system/solutions/1980360/c-super-fast-c-hash-solution-beats-100/) if you\\'re still looking"
                    },
                    {
                        "username": "thatguycalledbruteforce",
                        "content": "I knew the solution within 2 mins. However, it took me 40 mins to submit successfully. Why? Cuz I'm soooo dumb, omg. I stored the station indices as \"StartStationEndStation\" instead of \"StartStation-EndStation\". 55th test case had stations like \"a\", \"aa\", \"b\", \"ab,  thereby making indices same for a->ab and aa->b. Therefore, please make sure you add a seperator between them. XD"
                    },
                    {
                        "username": "VMAtm",
                        "content": "```\\n[\"UndergroundSystem\", \"checkIn\", \"checkIn\", \"checkOut\", \"getAverageTime\", \"checkOut\", \"getAverageTime\"]\\n[[], [45, \"Leyton\", 3], [45, \"Leyton\", 4], [45, \"Waterloo\", 15], [\"Leyton\", \"Waterloo\"], [45, \"Waterloo\", 18], [\"Leyton\", \"Waterloo\"]]\\n```\\nHow it is possible that the same `id` = 45 is checked-in for 2 times in a row? It conflicts with the description:\\n```\\nA customer can only be checked into one place at a time.\\n```"
                    },
                    {
                        "username": "MokhtarSafir",
                        "content": "Makes no sens. I rewrote the whole solution to get the same result 52 / 56 test cases passed.\n\nThe output :\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\nThe expected:\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\n\nHow am i suppose to guess the error when there is no hint?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Please, look this thread https://leetcode.com/problems/design-underground-system/description/comments/1912175"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree, I think it makes perfect sense\nI understand and agree that it is frustrating when you get the wrong answer on a brute force test which gives you no information.\n\nHowever, let's back up a little bit. We're really taking for granted the fact that leetcode should hold our hand when we get mad at that. In a real world situation, nobody will have pre-made carefully designed testcases to illustrate all the potential pitfalls of your code. In an interview setting, it is also likely that their testcases might be al lot less helpful than leetcode's. In fact, they might very well ask you to write your testcases yourself! In a leetcode contest, you will always have some key testcases that are hidden, so you can;t see the exact reason why you failed and you have to figure it out yourself.\nBasically, in most practical or competitive settings, you won't have the help that you take for granted.\n\nIt is part of our required skillset to be able to anticipate the potential problems of our code and to design ourselves some testcases to validate it. So while I understand your frustration, take it as a challenge to practise a really really important practical skill: testing and debugging your code yourself without leetcode holding your hand to show you exactly what you are doing wrong.\n\nThat being said, once you understand the mistake you are making, you can suggest to leetcode a tescase that will help the next ones to understand their error if you wish to"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I just don\\'t get t his question ! is it hard for just me :) .......what am i missing for this question"
                    },
                    {
                        "username": "psionl0",
                        "content": "You want a list of traveling times between each pair of stations so you can calculate an average. The problem is that with as many as 10^4 stations, a station matrix is impracticable. As an alternative, you could concatenate the destination address and the source address of each mentioned pair of stations (deliminated by a comma) and use this as a key into a hash table."
                    },
                    {
                        "username": "Prat_2030",
                        "content": "Is it possible that there might be 2 passengers which might be travelling from same station and checking out at same station but with different average times?"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Yes. It may take Passenger Bob total time = 5 to go from Station A to Station B. Passenger Paul may take total time = 10 to go from A to B. The goal is to get the average time based on all trips from A to B. In this example, the average time would be 7.5."
                    },
                    {
                        "username": "psionl0",
                        "content": "Terrific! My code passes 48 out of 56 testcases. But on testcase 49, it says \"Wrong Answer\".\\n\\nYet if I compare the two answers side by side, they are identical - at least for how much of the answer they can display. The \"View all\" option doesn\\'t display the entire answer for a test case of this size."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Congrats!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) That did it! Here is my submission: https://leetcode.com/problems/design-underground-system/submissions/963512049/\\nToo late for the daily challenge points unfortunately but satisfying nonetheless. Especially when my run time beats 97.3% of all submissions."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Hurtful mistake in line 38 "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) https://leetcode.com/submissions/detail/961301097/\\nThis is my most recent submission. My first idea was to remove a passenger from the hashmap once they disembarked (add it back again if they take another trip) but that gave obscure \"use after free\" errors so I decided to leave the passenger in the hash map and modify the stationName and checkin time if the passenger took another trip."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) No, we don\\'t have such cases. Could you post some code of your solution, it helps to find a bug (in my thoughts, you have a some kind of collision in hashmap)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I saw that comment but it concerned the following case: ``[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`` But this should not throw up any surprises since A disembarked BEFORE boarding again. The average time is just (10+4)/2 = 7.\n\nDo we have to deal with cases like ``[[],[1,\"A\",1],[1,\"B\",10],[1,\"A\",5],[1,\"B\",20],[\"A\",\"B\"]]``? How about ``[],[1,\"A\",1],[1,\"A\",5],[1,\"B\",10],[1,\"B\",20],[\"A\",\"B\"]]``?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Why? Person 2 could arrive to station later, and checkout successfully, while system could be asked for average time in any moment. Also, in real world, you can get ticket to train A->B, take a car, return to A and get new ticket, for ex. A->C. It\\'s not a testcase situation just my thoughts about the problem (take it as hint).\\nThis comment helps me find out bug in my code (more obvious what is going on) https://leetcode.com/problems/design-underground-system/description/comments/1565016"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) If the data allows a person to board at two different stations without disembarking first then that would totally mess up the system and render trip times a matter of \"pick your number\"."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Consider this situation: A -> B, B -> A, A -> C. Or this situation: 1: A->B, 2: A->... (person 2 still in journey, while you could be asked about the average time)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) Found it. Thanks. (I would never have found that icon if I wasn\\'t told about it). FYI I found a couple of numbers that were different. Maybe there is a subtlety I haven\\'t noticed like a passenger checking in twice before checking out but the input is too large for me to dissect."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) It\\'s appears when you hovering mouse on output \\\\ expected view. The displayed text may overlap the icon, but it is there"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I don\\'t see a copy button. There is a \"diff\" word that I can click on but it doesn\\'t make all of the output available."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can use \"copy\" button located in top-right corner"
                    }
                ]
            },
            {
                "id": 1911453,
                "content": [
                    {
                        "username": "bhrtsnegi",
                        "content": "It can be done using Multidimensional Map but the things is how to make that mapping because in time and out time is also different for different id\\'s"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Uff not so difficult one finally! "
                    },
                    {
                        "username": "pthread",
                        "content": "For example, should average time from say A to B be equal to time from B to A?!? Or they are running on different tracks and A -> B might be different from B -> A?!?"
                    },
                    {
                        "username": "chickooo",
                        "content": "To be on a safe side, assume that the train returns from a different route"
                    },
                    {
                        "username": "t_khandaker",
                        "content": "Hello everyone,\\n\\nI have finally stucked up with too many wron answers for this precision issue as I could not find any difference from leetcode tools.\\n\\nI am just wondering if anyone have challenged it with C coding. Will appreciate the talent who can feel my hunger.\\n\\nPlease respond me if anyone curious...\\n\\n\\nThanks"
                    },
                    {
                        "username": "ChrisTrompf",
                        "content": "A bit late to the party, but you can check out my [c solution](https://leetcode.com/problems/design-underground-system/solutions/1980360/c-super-fast-c-hash-solution-beats-100/) if you\\'re still looking"
                    },
                    {
                        "username": "thatguycalledbruteforce",
                        "content": "I knew the solution within 2 mins. However, it took me 40 mins to submit successfully. Why? Cuz I'm soooo dumb, omg. I stored the station indices as \"StartStationEndStation\" instead of \"StartStation-EndStation\". 55th test case had stations like \"a\", \"aa\", \"b\", \"ab,  thereby making indices same for a->ab and aa->b. Therefore, please make sure you add a seperator between them. XD"
                    },
                    {
                        "username": "VMAtm",
                        "content": "```\\n[\"UndergroundSystem\", \"checkIn\", \"checkIn\", \"checkOut\", \"getAverageTime\", \"checkOut\", \"getAverageTime\"]\\n[[], [45, \"Leyton\", 3], [45, \"Leyton\", 4], [45, \"Waterloo\", 15], [\"Leyton\", \"Waterloo\"], [45, \"Waterloo\", 18], [\"Leyton\", \"Waterloo\"]]\\n```\\nHow it is possible that the same `id` = 45 is checked-in for 2 times in a row? It conflicts with the description:\\n```\\nA customer can only be checked into one place at a time.\\n```"
                    },
                    {
                        "username": "MokhtarSafir",
                        "content": "Makes no sens. I rewrote the whole solution to get the same result 52 / 56 test cases passed.\n\nThe output :\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\nThe expected:\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\n\nHow am i suppose to guess the error when there is no hint?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Please, look this thread https://leetcode.com/problems/design-underground-system/description/comments/1912175"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree, I think it makes perfect sense\nI understand and agree that it is frustrating when you get the wrong answer on a brute force test which gives you no information.\n\nHowever, let's back up a little bit. We're really taking for granted the fact that leetcode should hold our hand when we get mad at that. In a real world situation, nobody will have pre-made carefully designed testcases to illustrate all the potential pitfalls of your code. In an interview setting, it is also likely that their testcases might be al lot less helpful than leetcode's. In fact, they might very well ask you to write your testcases yourself! In a leetcode contest, you will always have some key testcases that are hidden, so you can;t see the exact reason why you failed and you have to figure it out yourself.\nBasically, in most practical or competitive settings, you won't have the help that you take for granted.\n\nIt is part of our required skillset to be able to anticipate the potential problems of our code and to design ourselves some testcases to validate it. So while I understand your frustration, take it as a challenge to practise a really really important practical skill: testing and debugging your code yourself without leetcode holding your hand to show you exactly what you are doing wrong.\n\nThat being said, once you understand the mistake you are making, you can suggest to leetcode a tescase that will help the next ones to understand their error if you wish to"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I just don\\'t get t his question ! is it hard for just me :) .......what am i missing for this question"
                    },
                    {
                        "username": "psionl0",
                        "content": "You want a list of traveling times between each pair of stations so you can calculate an average. The problem is that with as many as 10^4 stations, a station matrix is impracticable. As an alternative, you could concatenate the destination address and the source address of each mentioned pair of stations (deliminated by a comma) and use this as a key into a hash table."
                    },
                    {
                        "username": "Prat_2030",
                        "content": "Is it possible that there might be 2 passengers which might be travelling from same station and checking out at same station but with different average times?"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Yes. It may take Passenger Bob total time = 5 to go from Station A to Station B. Passenger Paul may take total time = 10 to go from A to B. The goal is to get the average time based on all trips from A to B. In this example, the average time would be 7.5."
                    },
                    {
                        "username": "psionl0",
                        "content": "Terrific! My code passes 48 out of 56 testcases. But on testcase 49, it says \"Wrong Answer\".\\n\\nYet if I compare the two answers side by side, they are identical - at least for how much of the answer they can display. The \"View all\" option doesn\\'t display the entire answer for a test case of this size."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Congrats!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) That did it! Here is my submission: https://leetcode.com/problems/design-underground-system/submissions/963512049/\\nToo late for the daily challenge points unfortunately but satisfying nonetheless. Especially when my run time beats 97.3% of all submissions."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Hurtful mistake in line 38 "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) https://leetcode.com/submissions/detail/961301097/\\nThis is my most recent submission. My first idea was to remove a passenger from the hashmap once they disembarked (add it back again if they take another trip) but that gave obscure \"use after free\" errors so I decided to leave the passenger in the hash map and modify the stationName and checkin time if the passenger took another trip."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) No, we don\\'t have such cases. Could you post some code of your solution, it helps to find a bug (in my thoughts, you have a some kind of collision in hashmap)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I saw that comment but it concerned the following case: ``[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`` But this should not throw up any surprises since A disembarked BEFORE boarding again. The average time is just (10+4)/2 = 7.\n\nDo we have to deal with cases like ``[[],[1,\"A\",1],[1,\"B\",10],[1,\"A\",5],[1,\"B\",20],[\"A\",\"B\"]]``? How about ``[],[1,\"A\",1],[1,\"A\",5],[1,\"B\",10],[1,\"B\",20],[\"A\",\"B\"]]``?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Why? Person 2 could arrive to station later, and checkout successfully, while system could be asked for average time in any moment. Also, in real world, you can get ticket to train A->B, take a car, return to A and get new ticket, for ex. A->C. It\\'s not a testcase situation just my thoughts about the problem (take it as hint).\\nThis comment helps me find out bug in my code (more obvious what is going on) https://leetcode.com/problems/design-underground-system/description/comments/1565016"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) If the data allows a person to board at two different stations without disembarking first then that would totally mess up the system and render trip times a matter of \"pick your number\"."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Consider this situation: A -> B, B -> A, A -> C. Or this situation: 1: A->B, 2: A->... (person 2 still in journey, while you could be asked about the average time)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) Found it. Thanks. (I would never have found that icon if I wasn\\'t told about it). FYI I found a couple of numbers that were different. Maybe there is a subtlety I haven\\'t noticed like a passenger checking in twice before checking out but the input is too large for me to dissect."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) It\\'s appears when you hovering mouse on output \\\\ expected view. The displayed text may overlap the icon, but it is there"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I don\\'t see a copy button. There is a \"diff\" word that I can click on but it doesn\\'t make all of the output available."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can use \"copy\" button located in top-right corner"
                    }
                ]
            },
            {
                "id": 1573581,
                "content": [
                    {
                        "username": "bhrtsnegi",
                        "content": "It can be done using Multidimensional Map but the things is how to make that mapping because in time and out time is also different for different id\\'s"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Uff not so difficult one finally! "
                    },
                    {
                        "username": "pthread",
                        "content": "For example, should average time from say A to B be equal to time from B to A?!? Or they are running on different tracks and A -> B might be different from B -> A?!?"
                    },
                    {
                        "username": "chickooo",
                        "content": "To be on a safe side, assume that the train returns from a different route"
                    },
                    {
                        "username": "t_khandaker",
                        "content": "Hello everyone,\\n\\nI have finally stucked up with too many wron answers for this precision issue as I could not find any difference from leetcode tools.\\n\\nI am just wondering if anyone have challenged it with C coding. Will appreciate the talent who can feel my hunger.\\n\\nPlease respond me if anyone curious...\\n\\n\\nThanks"
                    },
                    {
                        "username": "ChrisTrompf",
                        "content": "A bit late to the party, but you can check out my [c solution](https://leetcode.com/problems/design-underground-system/solutions/1980360/c-super-fast-c-hash-solution-beats-100/) if you\\'re still looking"
                    },
                    {
                        "username": "thatguycalledbruteforce",
                        "content": "I knew the solution within 2 mins. However, it took me 40 mins to submit successfully. Why? Cuz I'm soooo dumb, omg. I stored the station indices as \"StartStationEndStation\" instead of \"StartStation-EndStation\". 55th test case had stations like \"a\", \"aa\", \"b\", \"ab,  thereby making indices same for a->ab and aa->b. Therefore, please make sure you add a seperator between them. XD"
                    },
                    {
                        "username": "VMAtm",
                        "content": "```\\n[\"UndergroundSystem\", \"checkIn\", \"checkIn\", \"checkOut\", \"getAverageTime\", \"checkOut\", \"getAverageTime\"]\\n[[], [45, \"Leyton\", 3], [45, \"Leyton\", 4], [45, \"Waterloo\", 15], [\"Leyton\", \"Waterloo\"], [45, \"Waterloo\", 18], [\"Leyton\", \"Waterloo\"]]\\n```\\nHow it is possible that the same `id` = 45 is checked-in for 2 times in a row? It conflicts with the description:\\n```\\nA customer can only be checked into one place at a time.\\n```"
                    },
                    {
                        "username": "MokhtarSafir",
                        "content": "Makes no sens. I rewrote the whole solution to get the same result 52 / 56 test cases passed.\n\nThe output :\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\nThe expected:\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\n\nHow am i suppose to guess the error when there is no hint?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Please, look this thread https://leetcode.com/problems/design-underground-system/description/comments/1912175"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree, I think it makes perfect sense\nI understand and agree that it is frustrating when you get the wrong answer on a brute force test which gives you no information.\n\nHowever, let's back up a little bit. We're really taking for granted the fact that leetcode should hold our hand when we get mad at that. In a real world situation, nobody will have pre-made carefully designed testcases to illustrate all the potential pitfalls of your code. In an interview setting, it is also likely that their testcases might be al lot less helpful than leetcode's. In fact, they might very well ask you to write your testcases yourself! In a leetcode contest, you will always have some key testcases that are hidden, so you can;t see the exact reason why you failed and you have to figure it out yourself.\nBasically, in most practical or competitive settings, you won't have the help that you take for granted.\n\nIt is part of our required skillset to be able to anticipate the potential problems of our code and to design ourselves some testcases to validate it. So while I understand your frustration, take it as a challenge to practise a really really important practical skill: testing and debugging your code yourself without leetcode holding your hand to show you exactly what you are doing wrong.\n\nThat being said, once you understand the mistake you are making, you can suggest to leetcode a tescase that will help the next ones to understand their error if you wish to"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I just don\\'t get t his question ! is it hard for just me :) .......what am i missing for this question"
                    },
                    {
                        "username": "psionl0",
                        "content": "You want a list of traveling times between each pair of stations so you can calculate an average. The problem is that with as many as 10^4 stations, a station matrix is impracticable. As an alternative, you could concatenate the destination address and the source address of each mentioned pair of stations (deliminated by a comma) and use this as a key into a hash table."
                    },
                    {
                        "username": "Prat_2030",
                        "content": "Is it possible that there might be 2 passengers which might be travelling from same station and checking out at same station but with different average times?"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Yes. It may take Passenger Bob total time = 5 to go from Station A to Station B. Passenger Paul may take total time = 10 to go from A to B. The goal is to get the average time based on all trips from A to B. In this example, the average time would be 7.5."
                    },
                    {
                        "username": "psionl0",
                        "content": "Terrific! My code passes 48 out of 56 testcases. But on testcase 49, it says \"Wrong Answer\".\\n\\nYet if I compare the two answers side by side, they are identical - at least for how much of the answer they can display. The \"View all\" option doesn\\'t display the entire answer for a test case of this size."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Congrats!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) That did it! Here is my submission: https://leetcode.com/problems/design-underground-system/submissions/963512049/\\nToo late for the daily challenge points unfortunately but satisfying nonetheless. Especially when my run time beats 97.3% of all submissions."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Hurtful mistake in line 38 "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) https://leetcode.com/submissions/detail/961301097/\\nThis is my most recent submission. My first idea was to remove a passenger from the hashmap once they disembarked (add it back again if they take another trip) but that gave obscure \"use after free\" errors so I decided to leave the passenger in the hash map and modify the stationName and checkin time if the passenger took another trip."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) No, we don\\'t have such cases. Could you post some code of your solution, it helps to find a bug (in my thoughts, you have a some kind of collision in hashmap)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I saw that comment but it concerned the following case: ``[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`` But this should not throw up any surprises since A disembarked BEFORE boarding again. The average time is just (10+4)/2 = 7.\n\nDo we have to deal with cases like ``[[],[1,\"A\",1],[1,\"B\",10],[1,\"A\",5],[1,\"B\",20],[\"A\",\"B\"]]``? How about ``[],[1,\"A\",1],[1,\"A\",5],[1,\"B\",10],[1,\"B\",20],[\"A\",\"B\"]]``?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Why? Person 2 could arrive to station later, and checkout successfully, while system could be asked for average time in any moment. Also, in real world, you can get ticket to train A->B, take a car, return to A and get new ticket, for ex. A->C. It\\'s not a testcase situation just my thoughts about the problem (take it as hint).\\nThis comment helps me find out bug in my code (more obvious what is going on) https://leetcode.com/problems/design-underground-system/description/comments/1565016"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) If the data allows a person to board at two different stations without disembarking first then that would totally mess up the system and render trip times a matter of \"pick your number\"."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Consider this situation: A -> B, B -> A, A -> C. Or this situation: 1: A->B, 2: A->... (person 2 still in journey, while you could be asked about the average time)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) Found it. Thanks. (I would never have found that icon if I wasn\\'t told about it). FYI I found a couple of numbers that were different. Maybe there is a subtlety I haven\\'t noticed like a passenger checking in twice before checking out but the input is too large for me to dissect."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) It\\'s appears when you hovering mouse on output \\\\ expected view. The displayed text may overlap the icon, but it is there"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I don\\'t see a copy button. There is a \"diff\" word that I can click on but it doesn\\'t make all of the output available."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can use \"copy\" button located in top-right corner"
                    }
                ]
            },
            {
                "id": 1573572,
                "content": [
                    {
                        "username": "bhrtsnegi",
                        "content": "It can be done using Multidimensional Map but the things is how to make that mapping because in time and out time is also different for different id\\'s"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Uff not so difficult one finally! "
                    },
                    {
                        "username": "pthread",
                        "content": "For example, should average time from say A to B be equal to time from B to A?!? Or they are running on different tracks and A -> B might be different from B -> A?!?"
                    },
                    {
                        "username": "chickooo",
                        "content": "To be on a safe side, assume that the train returns from a different route"
                    },
                    {
                        "username": "t_khandaker",
                        "content": "Hello everyone,\\n\\nI have finally stucked up with too many wron answers for this precision issue as I could not find any difference from leetcode tools.\\n\\nI am just wondering if anyone have challenged it with C coding. Will appreciate the talent who can feel my hunger.\\n\\nPlease respond me if anyone curious...\\n\\n\\nThanks"
                    },
                    {
                        "username": "ChrisTrompf",
                        "content": "A bit late to the party, but you can check out my [c solution](https://leetcode.com/problems/design-underground-system/solutions/1980360/c-super-fast-c-hash-solution-beats-100/) if you\\'re still looking"
                    },
                    {
                        "username": "thatguycalledbruteforce",
                        "content": "I knew the solution within 2 mins. However, it took me 40 mins to submit successfully. Why? Cuz I'm soooo dumb, omg. I stored the station indices as \"StartStationEndStation\" instead of \"StartStation-EndStation\". 55th test case had stations like \"a\", \"aa\", \"b\", \"ab,  thereby making indices same for a->ab and aa->b. Therefore, please make sure you add a seperator between them. XD"
                    },
                    {
                        "username": "VMAtm",
                        "content": "```\\n[\"UndergroundSystem\", \"checkIn\", \"checkIn\", \"checkOut\", \"getAverageTime\", \"checkOut\", \"getAverageTime\"]\\n[[], [45, \"Leyton\", 3], [45, \"Leyton\", 4], [45, \"Waterloo\", 15], [\"Leyton\", \"Waterloo\"], [45, \"Waterloo\", 18], [\"Leyton\", \"Waterloo\"]]\\n```\\nHow it is possible that the same `id` = 45 is checked-in for 2 times in a row? It conflicts with the description:\\n```\\nA customer can only be checked into one place at a time.\\n```"
                    },
                    {
                        "username": "MokhtarSafir",
                        "content": "Makes no sens. I rewrote the whole solution to get the same result 52 / 56 test cases passed.\n\nThe output :\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\nThe expected:\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\n\nHow am i suppose to guess the error when there is no hint?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Please, look this thread https://leetcode.com/problems/design-underground-system/description/comments/1912175"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree, I think it makes perfect sense\nI understand and agree that it is frustrating when you get the wrong answer on a brute force test which gives you no information.\n\nHowever, let's back up a little bit. We're really taking for granted the fact that leetcode should hold our hand when we get mad at that. In a real world situation, nobody will have pre-made carefully designed testcases to illustrate all the potential pitfalls of your code. In an interview setting, it is also likely that their testcases might be al lot less helpful than leetcode's. In fact, they might very well ask you to write your testcases yourself! In a leetcode contest, you will always have some key testcases that are hidden, so you can;t see the exact reason why you failed and you have to figure it out yourself.\nBasically, in most practical or competitive settings, you won't have the help that you take for granted.\n\nIt is part of our required skillset to be able to anticipate the potential problems of our code and to design ourselves some testcases to validate it. So while I understand your frustration, take it as a challenge to practise a really really important practical skill: testing and debugging your code yourself without leetcode holding your hand to show you exactly what you are doing wrong.\n\nThat being said, once you understand the mistake you are making, you can suggest to leetcode a tescase that will help the next ones to understand their error if you wish to"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I just don\\'t get t his question ! is it hard for just me :) .......what am i missing for this question"
                    },
                    {
                        "username": "psionl0",
                        "content": "You want a list of traveling times between each pair of stations so you can calculate an average. The problem is that with as many as 10^4 stations, a station matrix is impracticable. As an alternative, you could concatenate the destination address and the source address of each mentioned pair of stations (deliminated by a comma) and use this as a key into a hash table."
                    },
                    {
                        "username": "Prat_2030",
                        "content": "Is it possible that there might be 2 passengers which might be travelling from same station and checking out at same station but with different average times?"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Yes. It may take Passenger Bob total time = 5 to go from Station A to Station B. Passenger Paul may take total time = 10 to go from A to B. The goal is to get the average time based on all trips from A to B. In this example, the average time would be 7.5."
                    },
                    {
                        "username": "psionl0",
                        "content": "Terrific! My code passes 48 out of 56 testcases. But on testcase 49, it says \"Wrong Answer\".\\n\\nYet if I compare the two answers side by side, they are identical - at least for how much of the answer they can display. The \"View all\" option doesn\\'t display the entire answer for a test case of this size."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Congrats!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) That did it! Here is my submission: https://leetcode.com/problems/design-underground-system/submissions/963512049/\\nToo late for the daily challenge points unfortunately but satisfying nonetheless. Especially when my run time beats 97.3% of all submissions."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Hurtful mistake in line 38 "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) https://leetcode.com/submissions/detail/961301097/\\nThis is my most recent submission. My first idea was to remove a passenger from the hashmap once they disembarked (add it back again if they take another trip) but that gave obscure \"use after free\" errors so I decided to leave the passenger in the hash map and modify the stationName and checkin time if the passenger took another trip."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) No, we don\\'t have such cases. Could you post some code of your solution, it helps to find a bug (in my thoughts, you have a some kind of collision in hashmap)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I saw that comment but it concerned the following case: ``[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`` But this should not throw up any surprises since A disembarked BEFORE boarding again. The average time is just (10+4)/2 = 7.\n\nDo we have to deal with cases like ``[[],[1,\"A\",1],[1,\"B\",10],[1,\"A\",5],[1,\"B\",20],[\"A\",\"B\"]]``? How about ``[],[1,\"A\",1],[1,\"A\",5],[1,\"B\",10],[1,\"B\",20],[\"A\",\"B\"]]``?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Why? Person 2 could arrive to station later, and checkout successfully, while system could be asked for average time in any moment. Also, in real world, you can get ticket to train A->B, take a car, return to A and get new ticket, for ex. A->C. It\\'s not a testcase situation just my thoughts about the problem (take it as hint).\\nThis comment helps me find out bug in my code (more obvious what is going on) https://leetcode.com/problems/design-underground-system/description/comments/1565016"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) If the data allows a person to board at two different stations without disembarking first then that would totally mess up the system and render trip times a matter of \"pick your number\"."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Consider this situation: A -> B, B -> A, A -> C. Or this situation: 1: A->B, 2: A->... (person 2 still in journey, while you could be asked about the average time)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) Found it. Thanks. (I would never have found that icon if I wasn\\'t told about it). FYI I found a couple of numbers that were different. Maybe there is a subtlety I haven\\'t noticed like a passenger checking in twice before checking out but the input is too large for me to dissect."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) It\\'s appears when you hovering mouse on output \\\\ expected view. The displayed text may overlap the icon, but it is there"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I don\\'t see a copy button. There is a \"diff\" word that I can click on but it doesn\\'t make all of the output available."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can use \"copy\" button located in top-right corner"
                    }
                ]
            },
            {
                "id": 1991485,
                "content": [
                    {
                        "username": "bhrtsnegi",
                        "content": "It can be done using Multidimensional Map but the things is how to make that mapping because in time and out time is also different for different id\\'s"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Uff not so difficult one finally! "
                    },
                    {
                        "username": "pthread",
                        "content": "For example, should average time from say A to B be equal to time from B to A?!? Or they are running on different tracks and A -> B might be different from B -> A?!?"
                    },
                    {
                        "username": "chickooo",
                        "content": "To be on a safe side, assume that the train returns from a different route"
                    },
                    {
                        "username": "t_khandaker",
                        "content": "Hello everyone,\\n\\nI have finally stucked up with too many wron answers for this precision issue as I could not find any difference from leetcode tools.\\n\\nI am just wondering if anyone have challenged it with C coding. Will appreciate the talent who can feel my hunger.\\n\\nPlease respond me if anyone curious...\\n\\n\\nThanks"
                    },
                    {
                        "username": "ChrisTrompf",
                        "content": "A bit late to the party, but you can check out my [c solution](https://leetcode.com/problems/design-underground-system/solutions/1980360/c-super-fast-c-hash-solution-beats-100/) if you\\'re still looking"
                    },
                    {
                        "username": "thatguycalledbruteforce",
                        "content": "I knew the solution within 2 mins. However, it took me 40 mins to submit successfully. Why? Cuz I'm soooo dumb, omg. I stored the station indices as \"StartStationEndStation\" instead of \"StartStation-EndStation\". 55th test case had stations like \"a\", \"aa\", \"b\", \"ab,  thereby making indices same for a->ab and aa->b. Therefore, please make sure you add a seperator between them. XD"
                    },
                    {
                        "username": "VMAtm",
                        "content": "```\\n[\"UndergroundSystem\", \"checkIn\", \"checkIn\", \"checkOut\", \"getAverageTime\", \"checkOut\", \"getAverageTime\"]\\n[[], [45, \"Leyton\", 3], [45, \"Leyton\", 4], [45, \"Waterloo\", 15], [\"Leyton\", \"Waterloo\"], [45, \"Waterloo\", 18], [\"Leyton\", \"Waterloo\"]]\\n```\\nHow it is possible that the same `id` = 45 is checked-in for 2 times in a row? It conflicts with the description:\\n```\\nA customer can only be checked into one place at a time.\\n```"
                    },
                    {
                        "username": "MokhtarSafir",
                        "content": "Makes no sens. I rewrote the whole solution to get the same result 52 / 56 test cases passed.\n\nThe output :\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\nThe expected:\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\n\nHow am i suppose to guess the error when there is no hint?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Please, look this thread https://leetcode.com/problems/design-underground-system/description/comments/1912175"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree, I think it makes perfect sense\nI understand and agree that it is frustrating when you get the wrong answer on a brute force test which gives you no information.\n\nHowever, let's back up a little bit. We're really taking for granted the fact that leetcode should hold our hand when we get mad at that. In a real world situation, nobody will have pre-made carefully designed testcases to illustrate all the potential pitfalls of your code. In an interview setting, it is also likely that their testcases might be al lot less helpful than leetcode's. In fact, they might very well ask you to write your testcases yourself! In a leetcode contest, you will always have some key testcases that are hidden, so you can;t see the exact reason why you failed and you have to figure it out yourself.\nBasically, in most practical or competitive settings, you won't have the help that you take for granted.\n\nIt is part of our required skillset to be able to anticipate the potential problems of our code and to design ourselves some testcases to validate it. So while I understand your frustration, take it as a challenge to practise a really really important practical skill: testing and debugging your code yourself without leetcode holding your hand to show you exactly what you are doing wrong.\n\nThat being said, once you understand the mistake you are making, you can suggest to leetcode a tescase that will help the next ones to understand their error if you wish to"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I just don\\'t get t his question ! is it hard for just me :) .......what am i missing for this question"
                    },
                    {
                        "username": "psionl0",
                        "content": "You want a list of traveling times between each pair of stations so you can calculate an average. The problem is that with as many as 10^4 stations, a station matrix is impracticable. As an alternative, you could concatenate the destination address and the source address of each mentioned pair of stations (deliminated by a comma) and use this as a key into a hash table."
                    },
                    {
                        "username": "Prat_2030",
                        "content": "Is it possible that there might be 2 passengers which might be travelling from same station and checking out at same station but with different average times?"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Yes. It may take Passenger Bob total time = 5 to go from Station A to Station B. Passenger Paul may take total time = 10 to go from A to B. The goal is to get the average time based on all trips from A to B. In this example, the average time would be 7.5."
                    },
                    {
                        "username": "psionl0",
                        "content": "Terrific! My code passes 48 out of 56 testcases. But on testcase 49, it says \"Wrong Answer\".\\n\\nYet if I compare the two answers side by side, they are identical - at least for how much of the answer they can display. The \"View all\" option doesn\\'t display the entire answer for a test case of this size."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Congrats!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) That did it! Here is my submission: https://leetcode.com/problems/design-underground-system/submissions/963512049/\\nToo late for the daily challenge points unfortunately but satisfying nonetheless. Especially when my run time beats 97.3% of all submissions."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Hurtful mistake in line 38 "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) https://leetcode.com/submissions/detail/961301097/\\nThis is my most recent submission. My first idea was to remove a passenger from the hashmap once they disembarked (add it back again if they take another trip) but that gave obscure \"use after free\" errors so I decided to leave the passenger in the hash map and modify the stationName and checkin time if the passenger took another trip."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) No, we don\\'t have such cases. Could you post some code of your solution, it helps to find a bug (in my thoughts, you have a some kind of collision in hashmap)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I saw that comment but it concerned the following case: ``[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`` But this should not throw up any surprises since A disembarked BEFORE boarding again. The average time is just (10+4)/2 = 7.\n\nDo we have to deal with cases like ``[[],[1,\"A\",1],[1,\"B\",10],[1,\"A\",5],[1,\"B\",20],[\"A\",\"B\"]]``? How about ``[],[1,\"A\",1],[1,\"A\",5],[1,\"B\",10],[1,\"B\",20],[\"A\",\"B\"]]``?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Why? Person 2 could arrive to station later, and checkout successfully, while system could be asked for average time in any moment. Also, in real world, you can get ticket to train A->B, take a car, return to A and get new ticket, for ex. A->C. It\\'s not a testcase situation just my thoughts about the problem (take it as hint).\\nThis comment helps me find out bug in my code (more obvious what is going on) https://leetcode.com/problems/design-underground-system/description/comments/1565016"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) If the data allows a person to board at two different stations without disembarking first then that would totally mess up the system and render trip times a matter of \"pick your number\"."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Consider this situation: A -> B, B -> A, A -> C. Or this situation: 1: A->B, 2: A->... (person 2 still in journey, while you could be asked about the average time)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) Found it. Thanks. (I would never have found that icon if I wasn\\'t told about it). FYI I found a couple of numbers that were different. Maybe there is a subtlety I haven\\'t noticed like a passenger checking in twice before checking out but the input is too large for me to dissect."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) It\\'s appears when you hovering mouse on output \\\\ expected view. The displayed text may overlap the icon, but it is there"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I don\\'t see a copy button. There is a \"diff\" word that I can click on but it doesn\\'t make all of the output available."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can use \"copy\" button located in top-right corner"
                    }
                ]
            },
            {
                "id": 1937422,
                "content": [
                    {
                        "username": "bhrtsnegi",
                        "content": "It can be done using Multidimensional Map but the things is how to make that mapping because in time and out time is also different for different id\\'s"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Uff not so difficult one finally! "
                    },
                    {
                        "username": "pthread",
                        "content": "For example, should average time from say A to B be equal to time from B to A?!? Or they are running on different tracks and A -> B might be different from B -> A?!?"
                    },
                    {
                        "username": "chickooo",
                        "content": "To be on a safe side, assume that the train returns from a different route"
                    },
                    {
                        "username": "t_khandaker",
                        "content": "Hello everyone,\\n\\nI have finally stucked up with too many wron answers for this precision issue as I could not find any difference from leetcode tools.\\n\\nI am just wondering if anyone have challenged it with C coding. Will appreciate the talent who can feel my hunger.\\n\\nPlease respond me if anyone curious...\\n\\n\\nThanks"
                    },
                    {
                        "username": "ChrisTrompf",
                        "content": "A bit late to the party, but you can check out my [c solution](https://leetcode.com/problems/design-underground-system/solutions/1980360/c-super-fast-c-hash-solution-beats-100/) if you\\'re still looking"
                    },
                    {
                        "username": "thatguycalledbruteforce",
                        "content": "I knew the solution within 2 mins. However, it took me 40 mins to submit successfully. Why? Cuz I'm soooo dumb, omg. I stored the station indices as \"StartStationEndStation\" instead of \"StartStation-EndStation\". 55th test case had stations like \"a\", \"aa\", \"b\", \"ab,  thereby making indices same for a->ab and aa->b. Therefore, please make sure you add a seperator between them. XD"
                    },
                    {
                        "username": "VMAtm",
                        "content": "```\\n[\"UndergroundSystem\", \"checkIn\", \"checkIn\", \"checkOut\", \"getAverageTime\", \"checkOut\", \"getAverageTime\"]\\n[[], [45, \"Leyton\", 3], [45, \"Leyton\", 4], [45, \"Waterloo\", 15], [\"Leyton\", \"Waterloo\"], [45, \"Waterloo\", 18], [\"Leyton\", \"Waterloo\"]]\\n```\\nHow it is possible that the same `id` = 45 is checked-in for 2 times in a row? It conflicts with the description:\\n```\\nA customer can only be checked into one place at a time.\\n```"
                    },
                    {
                        "username": "MokhtarSafir",
                        "content": "Makes no sens. I rewrote the whole solution to get the same result 52 / 56 test cases passed.\n\nThe output :\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\nThe expected:\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\n\nHow am i suppose to guess the error when there is no hint?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Please, look this thread https://leetcode.com/problems/design-underground-system/description/comments/1912175"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree, I think it makes perfect sense\nI understand and agree that it is frustrating when you get the wrong answer on a brute force test which gives you no information.\n\nHowever, let's back up a little bit. We're really taking for granted the fact that leetcode should hold our hand when we get mad at that. In a real world situation, nobody will have pre-made carefully designed testcases to illustrate all the potential pitfalls of your code. In an interview setting, it is also likely that their testcases might be al lot less helpful than leetcode's. In fact, they might very well ask you to write your testcases yourself! In a leetcode contest, you will always have some key testcases that are hidden, so you can;t see the exact reason why you failed and you have to figure it out yourself.\nBasically, in most practical or competitive settings, you won't have the help that you take for granted.\n\nIt is part of our required skillset to be able to anticipate the potential problems of our code and to design ourselves some testcases to validate it. So while I understand your frustration, take it as a challenge to practise a really really important practical skill: testing and debugging your code yourself without leetcode holding your hand to show you exactly what you are doing wrong.\n\nThat being said, once you understand the mistake you are making, you can suggest to leetcode a tescase that will help the next ones to understand their error if you wish to"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I just don\\'t get t his question ! is it hard for just me :) .......what am i missing for this question"
                    },
                    {
                        "username": "psionl0",
                        "content": "You want a list of traveling times between each pair of stations so you can calculate an average. The problem is that with as many as 10^4 stations, a station matrix is impracticable. As an alternative, you could concatenate the destination address and the source address of each mentioned pair of stations (deliminated by a comma) and use this as a key into a hash table."
                    },
                    {
                        "username": "Prat_2030",
                        "content": "Is it possible that there might be 2 passengers which might be travelling from same station and checking out at same station but with different average times?"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Yes. It may take Passenger Bob total time = 5 to go from Station A to Station B. Passenger Paul may take total time = 10 to go from A to B. The goal is to get the average time based on all trips from A to B. In this example, the average time would be 7.5."
                    },
                    {
                        "username": "psionl0",
                        "content": "Terrific! My code passes 48 out of 56 testcases. But on testcase 49, it says \"Wrong Answer\".\\n\\nYet if I compare the two answers side by side, they are identical - at least for how much of the answer they can display. The \"View all\" option doesn\\'t display the entire answer for a test case of this size."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Congrats!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) That did it! Here is my submission: https://leetcode.com/problems/design-underground-system/submissions/963512049/\\nToo late for the daily challenge points unfortunately but satisfying nonetheless. Especially when my run time beats 97.3% of all submissions."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Hurtful mistake in line 38 "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) https://leetcode.com/submissions/detail/961301097/\\nThis is my most recent submission. My first idea was to remove a passenger from the hashmap once they disembarked (add it back again if they take another trip) but that gave obscure \"use after free\" errors so I decided to leave the passenger in the hash map and modify the stationName and checkin time if the passenger took another trip."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) No, we don\\'t have such cases. Could you post some code of your solution, it helps to find a bug (in my thoughts, you have a some kind of collision in hashmap)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I saw that comment but it concerned the following case: ``[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`` But this should not throw up any surprises since A disembarked BEFORE boarding again. The average time is just (10+4)/2 = 7.\n\nDo we have to deal with cases like ``[[],[1,\"A\",1],[1,\"B\",10],[1,\"A\",5],[1,\"B\",20],[\"A\",\"B\"]]``? How about ``[],[1,\"A\",1],[1,\"A\",5],[1,\"B\",10],[1,\"B\",20],[\"A\",\"B\"]]``?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Why? Person 2 could arrive to station later, and checkout successfully, while system could be asked for average time in any moment. Also, in real world, you can get ticket to train A->B, take a car, return to A and get new ticket, for ex. A->C. It\\'s not a testcase situation just my thoughts about the problem (take it as hint).\\nThis comment helps me find out bug in my code (more obvious what is going on) https://leetcode.com/problems/design-underground-system/description/comments/1565016"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) If the data allows a person to board at two different stations without disembarking first then that would totally mess up the system and render trip times a matter of \"pick your number\"."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Consider this situation: A -> B, B -> A, A -> C. Or this situation: 1: A->B, 2: A->... (person 2 still in journey, while you could be asked about the average time)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) Found it. Thanks. (I would never have found that icon if I wasn\\'t told about it). FYI I found a couple of numbers that were different. Maybe there is a subtlety I haven\\'t noticed like a passenger checking in twice before checking out but the input is too large for me to dissect."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) It\\'s appears when you hovering mouse on output \\\\ expected view. The displayed text may overlap the icon, but it is there"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I don\\'t see a copy button. There is a \"diff\" word that I can click on but it doesn\\'t make all of the output available."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can use \"copy\" button located in top-right corner"
                    }
                ]
            },
            {
                "id": 1913527,
                "content": [
                    {
                        "username": "bhrtsnegi",
                        "content": "It can be done using Multidimensional Map but the things is how to make that mapping because in time and out time is also different for different id\\'s"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Uff not so difficult one finally! "
                    },
                    {
                        "username": "pthread",
                        "content": "For example, should average time from say A to B be equal to time from B to A?!? Or they are running on different tracks and A -> B might be different from B -> A?!?"
                    },
                    {
                        "username": "chickooo",
                        "content": "To be on a safe side, assume that the train returns from a different route"
                    },
                    {
                        "username": "t_khandaker",
                        "content": "Hello everyone,\\n\\nI have finally stucked up with too many wron answers for this precision issue as I could not find any difference from leetcode tools.\\n\\nI am just wondering if anyone have challenged it with C coding. Will appreciate the talent who can feel my hunger.\\n\\nPlease respond me if anyone curious...\\n\\n\\nThanks"
                    },
                    {
                        "username": "ChrisTrompf",
                        "content": "A bit late to the party, but you can check out my [c solution](https://leetcode.com/problems/design-underground-system/solutions/1980360/c-super-fast-c-hash-solution-beats-100/) if you\\'re still looking"
                    },
                    {
                        "username": "thatguycalledbruteforce",
                        "content": "I knew the solution within 2 mins. However, it took me 40 mins to submit successfully. Why? Cuz I'm soooo dumb, omg. I stored the station indices as \"StartStationEndStation\" instead of \"StartStation-EndStation\". 55th test case had stations like \"a\", \"aa\", \"b\", \"ab,  thereby making indices same for a->ab and aa->b. Therefore, please make sure you add a seperator between them. XD"
                    },
                    {
                        "username": "VMAtm",
                        "content": "```\\n[\"UndergroundSystem\", \"checkIn\", \"checkIn\", \"checkOut\", \"getAverageTime\", \"checkOut\", \"getAverageTime\"]\\n[[], [45, \"Leyton\", 3], [45, \"Leyton\", 4], [45, \"Waterloo\", 15], [\"Leyton\", \"Waterloo\"], [45, \"Waterloo\", 18], [\"Leyton\", \"Waterloo\"]]\\n```\\nHow it is possible that the same `id` = 45 is checked-in for 2 times in a row? It conflicts with the description:\\n```\\nA customer can only be checked into one place at a time.\\n```"
                    },
                    {
                        "username": "MokhtarSafir",
                        "content": "Makes no sens. I rewrote the whole solution to get the same result 52 / 56 test cases passed.\n\nThe output :\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\nThe expected:\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\n\nHow am i suppose to guess the error when there is no hint?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Please, look this thread https://leetcode.com/problems/design-underground-system/description/comments/1912175"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree, I think it makes perfect sense\nI understand and agree that it is frustrating when you get the wrong answer on a brute force test which gives you no information.\n\nHowever, let's back up a little bit. We're really taking for granted the fact that leetcode should hold our hand when we get mad at that. In a real world situation, nobody will have pre-made carefully designed testcases to illustrate all the potential pitfalls of your code. In an interview setting, it is also likely that their testcases might be al lot less helpful than leetcode's. In fact, they might very well ask you to write your testcases yourself! In a leetcode contest, you will always have some key testcases that are hidden, so you can;t see the exact reason why you failed and you have to figure it out yourself.\nBasically, in most practical or competitive settings, you won't have the help that you take for granted.\n\nIt is part of our required skillset to be able to anticipate the potential problems of our code and to design ourselves some testcases to validate it. So while I understand your frustration, take it as a challenge to practise a really really important practical skill: testing and debugging your code yourself without leetcode holding your hand to show you exactly what you are doing wrong.\n\nThat being said, once you understand the mistake you are making, you can suggest to leetcode a tescase that will help the next ones to understand their error if you wish to"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I just don\\'t get t his question ! is it hard for just me :) .......what am i missing for this question"
                    },
                    {
                        "username": "psionl0",
                        "content": "You want a list of traveling times between each pair of stations so you can calculate an average. The problem is that with as many as 10^4 stations, a station matrix is impracticable. As an alternative, you could concatenate the destination address and the source address of each mentioned pair of stations (deliminated by a comma) and use this as a key into a hash table."
                    },
                    {
                        "username": "Prat_2030",
                        "content": "Is it possible that there might be 2 passengers which might be travelling from same station and checking out at same station but with different average times?"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Yes. It may take Passenger Bob total time = 5 to go from Station A to Station B. Passenger Paul may take total time = 10 to go from A to B. The goal is to get the average time based on all trips from A to B. In this example, the average time would be 7.5."
                    },
                    {
                        "username": "psionl0",
                        "content": "Terrific! My code passes 48 out of 56 testcases. But on testcase 49, it says \"Wrong Answer\".\\n\\nYet if I compare the two answers side by side, they are identical - at least for how much of the answer they can display. The \"View all\" option doesn\\'t display the entire answer for a test case of this size."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Congrats!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) That did it! Here is my submission: https://leetcode.com/problems/design-underground-system/submissions/963512049/\\nToo late for the daily challenge points unfortunately but satisfying nonetheless. Especially when my run time beats 97.3% of all submissions."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Hurtful mistake in line 38 "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) https://leetcode.com/submissions/detail/961301097/\\nThis is my most recent submission. My first idea was to remove a passenger from the hashmap once they disembarked (add it back again if they take another trip) but that gave obscure \"use after free\" errors so I decided to leave the passenger in the hash map and modify the stationName and checkin time if the passenger took another trip."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) No, we don\\'t have such cases. Could you post some code of your solution, it helps to find a bug (in my thoughts, you have a some kind of collision in hashmap)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I saw that comment but it concerned the following case: ``[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`` But this should not throw up any surprises since A disembarked BEFORE boarding again. The average time is just (10+4)/2 = 7.\n\nDo we have to deal with cases like ``[[],[1,\"A\",1],[1,\"B\",10],[1,\"A\",5],[1,\"B\",20],[\"A\",\"B\"]]``? How about ``[],[1,\"A\",1],[1,\"A\",5],[1,\"B\",10],[1,\"B\",20],[\"A\",\"B\"]]``?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Why? Person 2 could arrive to station later, and checkout successfully, while system could be asked for average time in any moment. Also, in real world, you can get ticket to train A->B, take a car, return to A and get new ticket, for ex. A->C. It\\'s not a testcase situation just my thoughts about the problem (take it as hint).\\nThis comment helps me find out bug in my code (more obvious what is going on) https://leetcode.com/problems/design-underground-system/description/comments/1565016"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) If the data allows a person to board at two different stations without disembarking first then that would totally mess up the system and render trip times a matter of \"pick your number\"."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Consider this situation: A -> B, B -> A, A -> C. Or this situation: 1: A->B, 2: A->... (person 2 still in journey, while you could be asked about the average time)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) Found it. Thanks. (I would never have found that icon if I wasn\\'t told about it). FYI I found a couple of numbers that were different. Maybe there is a subtlety I haven\\'t noticed like a passenger checking in twice before checking out but the input is too large for me to dissect."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) It\\'s appears when you hovering mouse on output \\\\ expected view. The displayed text may overlap the icon, but it is there"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I don\\'t see a copy button. There is a \"diff\" word that I can click on but it doesn\\'t make all of the output available."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can use \"copy\" button located in top-right corner"
                    }
                ]
            },
            {
                "id": 1912443,
                "content": [
                    {
                        "username": "bhrtsnegi",
                        "content": "It can be done using Multidimensional Map but the things is how to make that mapping because in time and out time is also different for different id\\'s"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Uff not so difficult one finally! "
                    },
                    {
                        "username": "pthread",
                        "content": "For example, should average time from say A to B be equal to time from B to A?!? Or they are running on different tracks and A -> B might be different from B -> A?!?"
                    },
                    {
                        "username": "chickooo",
                        "content": "To be on a safe side, assume that the train returns from a different route"
                    },
                    {
                        "username": "t_khandaker",
                        "content": "Hello everyone,\\n\\nI have finally stucked up with too many wron answers for this precision issue as I could not find any difference from leetcode tools.\\n\\nI am just wondering if anyone have challenged it with C coding. Will appreciate the talent who can feel my hunger.\\n\\nPlease respond me if anyone curious...\\n\\n\\nThanks"
                    },
                    {
                        "username": "ChrisTrompf",
                        "content": "A bit late to the party, but you can check out my [c solution](https://leetcode.com/problems/design-underground-system/solutions/1980360/c-super-fast-c-hash-solution-beats-100/) if you\\'re still looking"
                    },
                    {
                        "username": "thatguycalledbruteforce",
                        "content": "I knew the solution within 2 mins. However, it took me 40 mins to submit successfully. Why? Cuz I'm soooo dumb, omg. I stored the station indices as \"StartStationEndStation\" instead of \"StartStation-EndStation\". 55th test case had stations like \"a\", \"aa\", \"b\", \"ab,  thereby making indices same for a->ab and aa->b. Therefore, please make sure you add a seperator between them. XD"
                    },
                    {
                        "username": "VMAtm",
                        "content": "```\\n[\"UndergroundSystem\", \"checkIn\", \"checkIn\", \"checkOut\", \"getAverageTime\", \"checkOut\", \"getAverageTime\"]\\n[[], [45, \"Leyton\", 3], [45, \"Leyton\", 4], [45, \"Waterloo\", 15], [\"Leyton\", \"Waterloo\"], [45, \"Waterloo\", 18], [\"Leyton\", \"Waterloo\"]]\\n```\\nHow it is possible that the same `id` = 45 is checked-in for 2 times in a row? It conflicts with the description:\\n```\\nA customer can only be checked into one place at a time.\\n```"
                    },
                    {
                        "username": "MokhtarSafir",
                        "content": "Makes no sens. I rewrote the whole solution to get the same result 52 / 56 test cases passed.\n\nThe output :\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\nThe expected:\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\n\nHow am i suppose to guess the error when there is no hint?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Please, look this thread https://leetcode.com/problems/design-underground-system/description/comments/1912175"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree, I think it makes perfect sense\nI understand and agree that it is frustrating when you get the wrong answer on a brute force test which gives you no information.\n\nHowever, let's back up a little bit. We're really taking for granted the fact that leetcode should hold our hand when we get mad at that. In a real world situation, nobody will have pre-made carefully designed testcases to illustrate all the potential pitfalls of your code. In an interview setting, it is also likely that their testcases might be al lot less helpful than leetcode's. In fact, they might very well ask you to write your testcases yourself! In a leetcode contest, you will always have some key testcases that are hidden, so you can;t see the exact reason why you failed and you have to figure it out yourself.\nBasically, in most practical or competitive settings, you won't have the help that you take for granted.\n\nIt is part of our required skillset to be able to anticipate the potential problems of our code and to design ourselves some testcases to validate it. So while I understand your frustration, take it as a challenge to practise a really really important practical skill: testing and debugging your code yourself without leetcode holding your hand to show you exactly what you are doing wrong.\n\nThat being said, once you understand the mistake you are making, you can suggest to leetcode a tescase that will help the next ones to understand their error if you wish to"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I just don\\'t get t his question ! is it hard for just me :) .......what am i missing for this question"
                    },
                    {
                        "username": "psionl0",
                        "content": "You want a list of traveling times between each pair of stations so you can calculate an average. The problem is that with as many as 10^4 stations, a station matrix is impracticable. As an alternative, you could concatenate the destination address and the source address of each mentioned pair of stations (deliminated by a comma) and use this as a key into a hash table."
                    },
                    {
                        "username": "Prat_2030",
                        "content": "Is it possible that there might be 2 passengers which might be travelling from same station and checking out at same station but with different average times?"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Yes. It may take Passenger Bob total time = 5 to go from Station A to Station B. Passenger Paul may take total time = 10 to go from A to B. The goal is to get the average time based on all trips from A to B. In this example, the average time would be 7.5."
                    },
                    {
                        "username": "psionl0",
                        "content": "Terrific! My code passes 48 out of 56 testcases. But on testcase 49, it says \"Wrong Answer\".\\n\\nYet if I compare the two answers side by side, they are identical - at least for how much of the answer they can display. The \"View all\" option doesn\\'t display the entire answer for a test case of this size."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Congrats!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) That did it! Here is my submission: https://leetcode.com/problems/design-underground-system/submissions/963512049/\\nToo late for the daily challenge points unfortunately but satisfying nonetheless. Especially when my run time beats 97.3% of all submissions."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Hurtful mistake in line 38 "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) https://leetcode.com/submissions/detail/961301097/\\nThis is my most recent submission. My first idea was to remove a passenger from the hashmap once they disembarked (add it back again if they take another trip) but that gave obscure \"use after free\" errors so I decided to leave the passenger in the hash map and modify the stationName and checkin time if the passenger took another trip."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) No, we don\\'t have such cases. Could you post some code of your solution, it helps to find a bug (in my thoughts, you have a some kind of collision in hashmap)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I saw that comment but it concerned the following case: ``[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`` But this should not throw up any surprises since A disembarked BEFORE boarding again. The average time is just (10+4)/2 = 7.\n\nDo we have to deal with cases like ``[[],[1,\"A\",1],[1,\"B\",10],[1,\"A\",5],[1,\"B\",20],[\"A\",\"B\"]]``? How about ``[],[1,\"A\",1],[1,\"A\",5],[1,\"B\",10],[1,\"B\",20],[\"A\",\"B\"]]``?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Why? Person 2 could arrive to station later, and checkout successfully, while system could be asked for average time in any moment. Also, in real world, you can get ticket to train A->B, take a car, return to A and get new ticket, for ex. A->C. It\\'s not a testcase situation just my thoughts about the problem (take it as hint).\\nThis comment helps me find out bug in my code (more obvious what is going on) https://leetcode.com/problems/design-underground-system/description/comments/1565016"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) If the data allows a person to board at two different stations without disembarking first then that would totally mess up the system and render trip times a matter of \"pick your number\"."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Consider this situation: A -> B, B -> A, A -> C. Or this situation: 1: A->B, 2: A->... (person 2 still in journey, while you could be asked about the average time)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) Found it. Thanks. (I would never have found that icon if I wasn\\'t told about it). FYI I found a couple of numbers that were different. Maybe there is a subtlety I haven\\'t noticed like a passenger checking in twice before checking out but the input is too large for me to dissect."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) It\\'s appears when you hovering mouse on output \\\\ expected view. The displayed text may overlap the icon, but it is there"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I don\\'t see a copy button. There is a \"diff\" word that I can click on but it doesn\\'t make all of the output available."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can use \"copy\" button located in top-right corner"
                    }
                ]
            },
            {
                "id": 1912251,
                "content": [
                    {
                        "username": "bhrtsnegi",
                        "content": "It can be done using Multidimensional Map but the things is how to make that mapping because in time and out time is also different for different id\\'s"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Uff not so difficult one finally! "
                    },
                    {
                        "username": "pthread",
                        "content": "For example, should average time from say A to B be equal to time from B to A?!? Or they are running on different tracks and A -> B might be different from B -> A?!?"
                    },
                    {
                        "username": "chickooo",
                        "content": "To be on a safe side, assume that the train returns from a different route"
                    },
                    {
                        "username": "t_khandaker",
                        "content": "Hello everyone,\\n\\nI have finally stucked up with too many wron answers for this precision issue as I could not find any difference from leetcode tools.\\n\\nI am just wondering if anyone have challenged it with C coding. Will appreciate the talent who can feel my hunger.\\n\\nPlease respond me if anyone curious...\\n\\n\\nThanks"
                    },
                    {
                        "username": "ChrisTrompf",
                        "content": "A bit late to the party, but you can check out my [c solution](https://leetcode.com/problems/design-underground-system/solutions/1980360/c-super-fast-c-hash-solution-beats-100/) if you\\'re still looking"
                    },
                    {
                        "username": "thatguycalledbruteforce",
                        "content": "I knew the solution within 2 mins. However, it took me 40 mins to submit successfully. Why? Cuz I'm soooo dumb, omg. I stored the station indices as \"StartStationEndStation\" instead of \"StartStation-EndStation\". 55th test case had stations like \"a\", \"aa\", \"b\", \"ab,  thereby making indices same for a->ab and aa->b. Therefore, please make sure you add a seperator between them. XD"
                    },
                    {
                        "username": "VMAtm",
                        "content": "```\\n[\"UndergroundSystem\", \"checkIn\", \"checkIn\", \"checkOut\", \"getAverageTime\", \"checkOut\", \"getAverageTime\"]\\n[[], [45, \"Leyton\", 3], [45, \"Leyton\", 4], [45, \"Waterloo\", 15], [\"Leyton\", \"Waterloo\"], [45, \"Waterloo\", 18], [\"Leyton\", \"Waterloo\"]]\\n```\\nHow it is possible that the same `id` = 45 is checked-in for 2 times in a row? It conflicts with the description:\\n```\\nA customer can only be checked into one place at a time.\\n```"
                    },
                    {
                        "username": "MokhtarSafir",
                        "content": "Makes no sens. I rewrote the whole solution to get the same result 52 / 56 test cases passed.\n\nThe output :\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\nThe expected:\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\n\nHow am i suppose to guess the error when there is no hint?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Please, look this thread https://leetcode.com/problems/design-underground-system/description/comments/1912175"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree, I think it makes perfect sense\nI understand and agree that it is frustrating when you get the wrong answer on a brute force test which gives you no information.\n\nHowever, let's back up a little bit. We're really taking for granted the fact that leetcode should hold our hand when we get mad at that. In a real world situation, nobody will have pre-made carefully designed testcases to illustrate all the potential pitfalls of your code. In an interview setting, it is also likely that their testcases might be al lot less helpful than leetcode's. In fact, they might very well ask you to write your testcases yourself! In a leetcode contest, you will always have some key testcases that are hidden, so you can;t see the exact reason why you failed and you have to figure it out yourself.\nBasically, in most practical or competitive settings, you won't have the help that you take for granted.\n\nIt is part of our required skillset to be able to anticipate the potential problems of our code and to design ourselves some testcases to validate it. So while I understand your frustration, take it as a challenge to practise a really really important practical skill: testing and debugging your code yourself without leetcode holding your hand to show you exactly what you are doing wrong.\n\nThat being said, once you understand the mistake you are making, you can suggest to leetcode a tescase that will help the next ones to understand their error if you wish to"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I just don\\'t get t his question ! is it hard for just me :) .......what am i missing for this question"
                    },
                    {
                        "username": "psionl0",
                        "content": "You want a list of traveling times between each pair of stations so you can calculate an average. The problem is that with as many as 10^4 stations, a station matrix is impracticable. As an alternative, you could concatenate the destination address and the source address of each mentioned pair of stations (deliminated by a comma) and use this as a key into a hash table."
                    },
                    {
                        "username": "Prat_2030",
                        "content": "Is it possible that there might be 2 passengers which might be travelling from same station and checking out at same station but with different average times?"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Yes. It may take Passenger Bob total time = 5 to go from Station A to Station B. Passenger Paul may take total time = 10 to go from A to B. The goal is to get the average time based on all trips from A to B. In this example, the average time would be 7.5."
                    },
                    {
                        "username": "psionl0",
                        "content": "Terrific! My code passes 48 out of 56 testcases. But on testcase 49, it says \"Wrong Answer\".\\n\\nYet if I compare the two answers side by side, they are identical - at least for how much of the answer they can display. The \"View all\" option doesn\\'t display the entire answer for a test case of this size."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Congrats!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) That did it! Here is my submission: https://leetcode.com/problems/design-underground-system/submissions/963512049/\\nToo late for the daily challenge points unfortunately but satisfying nonetheless. Especially when my run time beats 97.3% of all submissions."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Hurtful mistake in line 38 "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) https://leetcode.com/submissions/detail/961301097/\\nThis is my most recent submission. My first idea was to remove a passenger from the hashmap once they disembarked (add it back again if they take another trip) but that gave obscure \"use after free\" errors so I decided to leave the passenger in the hash map and modify the stationName and checkin time if the passenger took another trip."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) No, we don\\'t have such cases. Could you post some code of your solution, it helps to find a bug (in my thoughts, you have a some kind of collision in hashmap)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I saw that comment but it concerned the following case: ``[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`` But this should not throw up any surprises since A disembarked BEFORE boarding again. The average time is just (10+4)/2 = 7.\n\nDo we have to deal with cases like ``[[],[1,\"A\",1],[1,\"B\",10],[1,\"A\",5],[1,\"B\",20],[\"A\",\"B\"]]``? How about ``[],[1,\"A\",1],[1,\"A\",5],[1,\"B\",10],[1,\"B\",20],[\"A\",\"B\"]]``?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Why? Person 2 could arrive to station later, and checkout successfully, while system could be asked for average time in any moment. Also, in real world, you can get ticket to train A->B, take a car, return to A and get new ticket, for ex. A->C. It\\'s not a testcase situation just my thoughts about the problem (take it as hint).\\nThis comment helps me find out bug in my code (more obvious what is going on) https://leetcode.com/problems/design-underground-system/description/comments/1565016"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) If the data allows a person to board at two different stations without disembarking first then that would totally mess up the system and render trip times a matter of \"pick your number\"."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Consider this situation: A -> B, B -> A, A -> C. Or this situation: 1: A->B, 2: A->... (person 2 still in journey, while you could be asked about the average time)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) Found it. Thanks. (I would never have found that icon if I wasn\\'t told about it). FYI I found a couple of numbers that were different. Maybe there is a subtlety I haven\\'t noticed like a passenger checking in twice before checking out but the input is too large for me to dissect."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) It\\'s appears when you hovering mouse on output \\\\ expected view. The displayed text may overlap the icon, but it is there"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I don\\'t see a copy button. There is a \"diff\" word that I can click on but it doesn\\'t make all of the output available."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can use \"copy\" button located in top-right corner"
                    }
                ]
            },
            {
                "id": 1912175,
                "content": [
                    {
                        "username": "bhrtsnegi",
                        "content": "It can be done using Multidimensional Map but the things is how to make that mapping because in time and out time is also different for different id\\'s"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Uff not so difficult one finally! "
                    },
                    {
                        "username": "pthread",
                        "content": "For example, should average time from say A to B be equal to time from B to A?!? Or they are running on different tracks and A -> B might be different from B -> A?!?"
                    },
                    {
                        "username": "chickooo",
                        "content": "To be on a safe side, assume that the train returns from a different route"
                    },
                    {
                        "username": "t_khandaker",
                        "content": "Hello everyone,\\n\\nI have finally stucked up with too many wron answers for this precision issue as I could not find any difference from leetcode tools.\\n\\nI am just wondering if anyone have challenged it with C coding. Will appreciate the talent who can feel my hunger.\\n\\nPlease respond me if anyone curious...\\n\\n\\nThanks"
                    },
                    {
                        "username": "ChrisTrompf",
                        "content": "A bit late to the party, but you can check out my [c solution](https://leetcode.com/problems/design-underground-system/solutions/1980360/c-super-fast-c-hash-solution-beats-100/) if you\\'re still looking"
                    },
                    {
                        "username": "thatguycalledbruteforce",
                        "content": "I knew the solution within 2 mins. However, it took me 40 mins to submit successfully. Why? Cuz I'm soooo dumb, omg. I stored the station indices as \"StartStationEndStation\" instead of \"StartStation-EndStation\". 55th test case had stations like \"a\", \"aa\", \"b\", \"ab,  thereby making indices same for a->ab and aa->b. Therefore, please make sure you add a seperator between them. XD"
                    },
                    {
                        "username": "VMAtm",
                        "content": "```\\n[\"UndergroundSystem\", \"checkIn\", \"checkIn\", \"checkOut\", \"getAverageTime\", \"checkOut\", \"getAverageTime\"]\\n[[], [45, \"Leyton\", 3], [45, \"Leyton\", 4], [45, \"Waterloo\", 15], [\"Leyton\", \"Waterloo\"], [45, \"Waterloo\", 18], [\"Leyton\", \"Waterloo\"]]\\n```\\nHow it is possible that the same `id` = 45 is checked-in for 2 times in a row? It conflicts with the description:\\n```\\nA customer can only be checked into one place at a time.\\n```"
                    },
                    {
                        "username": "MokhtarSafir",
                        "content": "Makes no sens. I rewrote the whole solution to get the same result 52 / 56 test cases passed.\n\nThe output :\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\nThe expected:\n[null,null,null,null,null,null,null,83.00000,null,110.50000,129.00000,null,89.33333,89.33333,129.00000,null,null,89.33333,null,null,null,102.50000,null,null,null,null,95.50000,null,null,null,null,69.66667,null,69.66667,84.50000,null,null,13.00000,84.50000,69.66667,69.66667,13.00000,69.66667,null,null,80.00000,null,null,null,null,null,null,null,null,272.00000,78.20000,69.66667,null,null,null,null,80.00000,null,null,null,null,null,103.37500,null,78.20000,null,null,null,156.00000,null,null,null,null,null,null,null,null,null,null,null,null,390.00000,390.00000,null,null,null,null,null,135.11111,null,135.11111,null,135.11111,null,null,null,305.90909,null,374.91667,null,402.92308,null,null,null,688.00000,null,null,303.00000,96.00000,null,null,null,null,310.00000,null,null,384.72727,null,null,null,null,null,null,null,null,null,null,569.26316,null,null,384.72727,null,237.50000,411.50000,null,546.80000,null,80.00000,546.80000,6.00000,null,null,null,null,null,null,null,310.00000,237.50000,null,nu...\n\n\nHow am i suppose to guess the error when there is no hint?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Please, look this thread https://leetcode.com/problems/design-underground-system/description/comments/1912175"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree, I think it makes perfect sense\nI understand and agree that it is frustrating when you get the wrong answer on a brute force test which gives you no information.\n\nHowever, let's back up a little bit. We're really taking for granted the fact that leetcode should hold our hand when we get mad at that. In a real world situation, nobody will have pre-made carefully designed testcases to illustrate all the potential pitfalls of your code. In an interview setting, it is also likely that their testcases might be al lot less helpful than leetcode's. In fact, they might very well ask you to write your testcases yourself! In a leetcode contest, you will always have some key testcases that are hidden, so you can;t see the exact reason why you failed and you have to figure it out yourself.\nBasically, in most practical or competitive settings, you won't have the help that you take for granted.\n\nIt is part of our required skillset to be able to anticipate the potential problems of our code and to design ourselves some testcases to validate it. So while I understand your frustration, take it as a challenge to practise a really really important practical skill: testing and debugging your code yourself without leetcode holding your hand to show you exactly what you are doing wrong.\n\nThat being said, once you understand the mistake you are making, you can suggest to leetcode a tescase that will help the next ones to understand their error if you wish to"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I just don\\'t get t his question ! is it hard for just me :) .......what am i missing for this question"
                    },
                    {
                        "username": "psionl0",
                        "content": "You want a list of traveling times between each pair of stations so you can calculate an average. The problem is that with as many as 10^4 stations, a station matrix is impracticable. As an alternative, you could concatenate the destination address and the source address of each mentioned pair of stations (deliminated by a comma) and use this as a key into a hash table."
                    },
                    {
                        "username": "Prat_2030",
                        "content": "Is it possible that there might be 2 passengers which might be travelling from same station and checking out at same station but with different average times?"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Yes. It may take Passenger Bob total time = 5 to go from Station A to Station B. Passenger Paul may take total time = 10 to go from A to B. The goal is to get the average time based on all trips from A to B. In this example, the average time would be 7.5."
                    },
                    {
                        "username": "psionl0",
                        "content": "Terrific! My code passes 48 out of 56 testcases. But on testcase 49, it says \"Wrong Answer\".\\n\\nYet if I compare the two answers side by side, they are identical - at least for how much of the answer they can display. The \"View all\" option doesn\\'t display the entire answer for a test case of this size."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Congrats!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) That did it! Here is my submission: https://leetcode.com/problems/design-underground-system/submissions/963512049/\\nToo late for the daily challenge points unfortunately but satisfying nonetheless. Especially when my run time beats 97.3% of all submissions."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Hurtful mistake in line 38 "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) https://leetcode.com/submissions/detail/961301097/\\nThis is my most recent submission. My first idea was to remove a passenger from the hashmap once they disembarked (add it back again if they take another trip) but that gave obscure \"use after free\" errors so I decided to leave the passenger in the hash map and modify the stationName and checkin time if the passenger took another trip."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) No, we don\\'t have such cases. Could you post some code of your solution, it helps to find a bug (in my thoughts, you have a some kind of collision in hashmap)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I saw that comment but it concerned the following case: ``[[],[1,\"A\",1],[1,\"B\",5],[1,\"A\",10],[1,\"B\",20],[\"A\",\"B\"]]`` But this should not throw up any surprises since A disembarked BEFORE boarding again. The average time is just (10+4)/2 = 7.\n\nDo we have to deal with cases like ``[[],[1,\"A\",1],[1,\"B\",10],[1,\"A\",5],[1,\"B\",20],[\"A\",\"B\"]]``? How about ``[],[1,\"A\",1],[1,\"A\",5],[1,\"B\",10],[1,\"B\",20],[\"A\",\"B\"]]``?"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Why? Person 2 could arrive to station later, and checkout successfully, while system could be asked for average time in any moment. Also, in real world, you can get ticket to train A->B, take a car, return to A and get new ticket, for ex. A->C. It\\'s not a testcase situation just my thoughts about the problem (take it as hint).\\nThis comment helps me find out bug in my code (more obvious what is going on) https://leetcode.com/problems/design-underground-system/description/comments/1565016"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) If the data allows a person to board at two different stations without disembarking first then that would totally mess up the system and render trip times a matter of \"pick your number\"."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) Consider this situation: A -> B, B -> A, A -> C. Or this situation: 1: A->B, 2: A->... (person 2 still in journey, while you could be asked about the average time)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) Found it. Thanks. (I would never have found that icon if I wasn\\'t told about it). FYI I found a couple of numbers that were different. Maybe there is a subtlety I haven\\'t noticed like a passenger checking in twice before checking out but the input is too large for me to dissect."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "[@psionl0](/psionl0) It\\'s appears when you hovering mouse on output \\\\ expected view. The displayed text may overlap the icon, but it is there"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Xabchinsk](/Xabchinsk) I don\\'t see a copy button. There is a \"diff\" word that I can click on but it doesn\\'t make all of the output available."
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can use \"copy\" button located in top-right corner"
                    }
                ]
            },
            {
                "id": 1912159,
                "content": [
                    {
                        "username": "gbiems",
                        "content": "Like a few other people here, I\\'m failing on test case 52/56. It\\'s a long test case so difficult to break down and analyze.\\n\\nOne thing I was thinking about - is this a graph problem? Like, if I travel from A-B from time stamp 9 to 11 and then from B to C from 13 to 15, do I need to calculate that travel time was 4 hours, not 6 hours?"
                    },
                    {
                        "username": "gbiems",
                        "content": "Actually, probably not, the problem does state that it is direct travel time (every now and then the stated directions aren\\'t reflected in the test cases, but I doubt that\\'s the case here). "
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "For an \"Underground\" system, the travel time from `A -> B` SHOULD BE equal to `B -> A`. It\\'s seemed quite logical to me, but the question assumes different histories for travel time calculation between two stations. I find it weird and nausiating."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "got my first batch \\uD83E\\uDD29"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "51/56 test cases passed!!\nGiving wrong answer\ncan anyone please tell where am i doing it wrong??!!\n\nunordered_map<int,pair<string,int>>m1;\nunordered_map<string,vector<pair<int,int>>>m2;\n\n    UndergroundSystem() \n    {\n\n    }\n    \n    void checkIn(int id, string stationName, int t) \n    {\nm1[id]={stationName,t};\n\n    }\n    \n    void checkOut(int id, string stationName, int t) \n    {\n       m2[stationName].push_back({id,t});\n\n    }\n    \n    double getAverageTime(string startStation, string endStation) \n    {\n        double ans=0;\n        int cnt=0;\n      for(auto it:m2[endStation])\n      {\n          if(m1[it.first].first==startStation)\n          {\n       int x=m1[it.first].second;\n       ans+=it.second-x;\n       cnt++;\n\n          }\n\n      }\n      return ans/cnt;"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Possible Case : When a customer travels multiple times , say` ``A``` goes from ```t = 3``` to ```t = 5```.  Again ```A``` travels from ```t=7``` to ```t=10``` to the same place. Your map would have accounted only the last trip. "
                    },
                    {
                        "username": "maantos",
                        "content": "Shouldnt we check wheter user is already checkedIn? At least thats is how I undestand the description (\"A customer can only be checked into one place at a time.\"). Correct me if im missing somethings. "
                    },
                    {
                        "username": "xxossoo96",
                        "content": "seems like DB schema design"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "kinda sad to be missing just 5 days this month. already bought all 3 time travels too :("
                    },
                    {
                        "username": "Joshua-Shin",
                        "content": "Please let me know why my code is incorrect...\\nNo TLE. Just Wrong Answer..\\n49 / 56 tc passed..\\n\\n````\\r\\nclass UndergroundSystem {\\npublic:\\n    map<string, int> stationToId; // stationName -> stationId\\n    vector<pair<int, int>> in[1000001]; // in[stationId] : {customerId, t};\\n    vector<pair<int, int>> out[1000001]; // out[stationId] : {customerId, t};\\n    int unused = 1;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        in[stationId].push_back({id, t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        out[stationId].push_back({id, t});\\n    }\\n    int findCheckOutTime(string endStation, int customerId, int inTime) {\\n        for(auto p: out[stationToId[endStation]]) {\\n            if(p.first != customerId) continue;\\n            if(inTime >= p.second) continue;\\n            return p.second;\\n        }\\n        return -1;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        long long totalTime = 0;\\n        int totalCnt = 0;\\n        int stationId = stationToId[startStation];\\n        for(auto p: in[stationId]) {\\n            int outTime = findCheckOutTime(endStation, p.first, p.second);\\n            if(outTime != -1) {\\n                totalTime += (long long)(outTime - p.second);\\n                totalCnt++;\\n            }\\n        }\\n        return (double)totalTime / totalCnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vedantalim",
                        "content": "why a design question everyday?\\n"
                    },
                    {
                        "username": "pavan_247",
                        "content": "class UndergroundSystem {\\n    HashMap<String,Integer> st=new HashMap<>();\\n    HashMap<Integer,HashMap<String,Integer>> ds=new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double count=0,sum=0;\\n       for (Map.Entry<Integer, HashMap<String, Integer>> entry : ds.entrySet()) {\\n           HashMap<String,Integer> new1=entry.getValue();\\n           if(new1.containsKey(startStation) && new1.containsKey(endStation)){\\n           sum+=new1.get(endStation)-new1.get(startStation);\\n           count++;\\n           }\\n            \\n       }\\n        return sum/count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */       \\n\\nit is passed 51/56 test case why not remaining can anyone explain the what is the wrong with my code\\n"
                    }
                ]
            },
            {
                "id": 1912127,
                "content": [
                    {
                        "username": "gbiems",
                        "content": "Like a few other people here, I\\'m failing on test case 52/56. It\\'s a long test case so difficult to break down and analyze.\\n\\nOne thing I was thinking about - is this a graph problem? Like, if I travel from A-B from time stamp 9 to 11 and then from B to C from 13 to 15, do I need to calculate that travel time was 4 hours, not 6 hours?"
                    },
                    {
                        "username": "gbiems",
                        "content": "Actually, probably not, the problem does state that it is direct travel time (every now and then the stated directions aren\\'t reflected in the test cases, but I doubt that\\'s the case here). "
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "For an \"Underground\" system, the travel time from `A -> B` SHOULD BE equal to `B -> A`. It\\'s seemed quite logical to me, but the question assumes different histories for travel time calculation between two stations. I find it weird and nausiating."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "got my first batch \\uD83E\\uDD29"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "51/56 test cases passed!!\nGiving wrong answer\ncan anyone please tell where am i doing it wrong??!!\n\nunordered_map<int,pair<string,int>>m1;\nunordered_map<string,vector<pair<int,int>>>m2;\n\n    UndergroundSystem() \n    {\n\n    }\n    \n    void checkIn(int id, string stationName, int t) \n    {\nm1[id]={stationName,t};\n\n    }\n    \n    void checkOut(int id, string stationName, int t) \n    {\n       m2[stationName].push_back({id,t});\n\n    }\n    \n    double getAverageTime(string startStation, string endStation) \n    {\n        double ans=0;\n        int cnt=0;\n      for(auto it:m2[endStation])\n      {\n          if(m1[it.first].first==startStation)\n          {\n       int x=m1[it.first].second;\n       ans+=it.second-x;\n       cnt++;\n\n          }\n\n      }\n      return ans/cnt;"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Possible Case : When a customer travels multiple times , say` ``A``` goes from ```t = 3``` to ```t = 5```.  Again ```A``` travels from ```t=7``` to ```t=10``` to the same place. Your map would have accounted only the last trip. "
                    },
                    {
                        "username": "maantos",
                        "content": "Shouldnt we check wheter user is already checkedIn? At least thats is how I undestand the description (\"A customer can only be checked into one place at a time.\"). Correct me if im missing somethings. "
                    },
                    {
                        "username": "xxossoo96",
                        "content": "seems like DB schema design"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "kinda sad to be missing just 5 days this month. already bought all 3 time travels too :("
                    },
                    {
                        "username": "Joshua-Shin",
                        "content": "Please let me know why my code is incorrect...\\nNo TLE. Just Wrong Answer..\\n49 / 56 tc passed..\\n\\n````\\r\\nclass UndergroundSystem {\\npublic:\\n    map<string, int> stationToId; // stationName -> stationId\\n    vector<pair<int, int>> in[1000001]; // in[stationId] : {customerId, t};\\n    vector<pair<int, int>> out[1000001]; // out[stationId] : {customerId, t};\\n    int unused = 1;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        in[stationId].push_back({id, t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        out[stationId].push_back({id, t});\\n    }\\n    int findCheckOutTime(string endStation, int customerId, int inTime) {\\n        for(auto p: out[stationToId[endStation]]) {\\n            if(p.first != customerId) continue;\\n            if(inTime >= p.second) continue;\\n            return p.second;\\n        }\\n        return -1;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        long long totalTime = 0;\\n        int totalCnt = 0;\\n        int stationId = stationToId[startStation];\\n        for(auto p: in[stationId]) {\\n            int outTime = findCheckOutTime(endStation, p.first, p.second);\\n            if(outTime != -1) {\\n                totalTime += (long long)(outTime - p.second);\\n                totalCnt++;\\n            }\\n        }\\n        return (double)totalTime / totalCnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vedantalim",
                        "content": "why a design question everyday?\\n"
                    },
                    {
                        "username": "pavan_247",
                        "content": "class UndergroundSystem {\\n    HashMap<String,Integer> st=new HashMap<>();\\n    HashMap<Integer,HashMap<String,Integer>> ds=new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double count=0,sum=0;\\n       for (Map.Entry<Integer, HashMap<String, Integer>> entry : ds.entrySet()) {\\n           HashMap<String,Integer> new1=entry.getValue();\\n           if(new1.containsKey(startStation) && new1.containsKey(endStation)){\\n           sum+=new1.get(endStation)-new1.get(startStation);\\n           count++;\\n           }\\n            \\n       }\\n        return sum/count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */       \\n\\nit is passed 51/56 test case why not remaining can anyone explain the what is the wrong with my code\\n"
                    }
                ]
            },
            {
                "id": 1912098,
                "content": [
                    {
                        "username": "gbiems",
                        "content": "Like a few other people here, I\\'m failing on test case 52/56. It\\'s a long test case so difficult to break down and analyze.\\n\\nOne thing I was thinking about - is this a graph problem? Like, if I travel from A-B from time stamp 9 to 11 and then from B to C from 13 to 15, do I need to calculate that travel time was 4 hours, not 6 hours?"
                    },
                    {
                        "username": "gbiems",
                        "content": "Actually, probably not, the problem does state that it is direct travel time (every now and then the stated directions aren\\'t reflected in the test cases, but I doubt that\\'s the case here). "
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "For an \"Underground\" system, the travel time from `A -> B` SHOULD BE equal to `B -> A`. It\\'s seemed quite logical to me, but the question assumes different histories for travel time calculation between two stations. I find it weird and nausiating."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "got my first batch \\uD83E\\uDD29"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "51/56 test cases passed!!\nGiving wrong answer\ncan anyone please tell where am i doing it wrong??!!\n\nunordered_map<int,pair<string,int>>m1;\nunordered_map<string,vector<pair<int,int>>>m2;\n\n    UndergroundSystem() \n    {\n\n    }\n    \n    void checkIn(int id, string stationName, int t) \n    {\nm1[id]={stationName,t};\n\n    }\n    \n    void checkOut(int id, string stationName, int t) \n    {\n       m2[stationName].push_back({id,t});\n\n    }\n    \n    double getAverageTime(string startStation, string endStation) \n    {\n        double ans=0;\n        int cnt=0;\n      for(auto it:m2[endStation])\n      {\n          if(m1[it.first].first==startStation)\n          {\n       int x=m1[it.first].second;\n       ans+=it.second-x;\n       cnt++;\n\n          }\n\n      }\n      return ans/cnt;"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Possible Case : When a customer travels multiple times , say` ``A``` goes from ```t = 3``` to ```t = 5```.  Again ```A``` travels from ```t=7``` to ```t=10``` to the same place. Your map would have accounted only the last trip. "
                    },
                    {
                        "username": "maantos",
                        "content": "Shouldnt we check wheter user is already checkedIn? At least thats is how I undestand the description (\"A customer can only be checked into one place at a time.\"). Correct me if im missing somethings. "
                    },
                    {
                        "username": "xxossoo96",
                        "content": "seems like DB schema design"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "kinda sad to be missing just 5 days this month. already bought all 3 time travels too :("
                    },
                    {
                        "username": "Joshua-Shin",
                        "content": "Please let me know why my code is incorrect...\\nNo TLE. Just Wrong Answer..\\n49 / 56 tc passed..\\n\\n````\\r\\nclass UndergroundSystem {\\npublic:\\n    map<string, int> stationToId; // stationName -> stationId\\n    vector<pair<int, int>> in[1000001]; // in[stationId] : {customerId, t};\\n    vector<pair<int, int>> out[1000001]; // out[stationId] : {customerId, t};\\n    int unused = 1;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        in[stationId].push_back({id, t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        out[stationId].push_back({id, t});\\n    }\\n    int findCheckOutTime(string endStation, int customerId, int inTime) {\\n        for(auto p: out[stationToId[endStation]]) {\\n            if(p.first != customerId) continue;\\n            if(inTime >= p.second) continue;\\n            return p.second;\\n        }\\n        return -1;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        long long totalTime = 0;\\n        int totalCnt = 0;\\n        int stationId = stationToId[startStation];\\n        for(auto p: in[stationId]) {\\n            int outTime = findCheckOutTime(endStation, p.first, p.second);\\n            if(outTime != -1) {\\n                totalTime += (long long)(outTime - p.second);\\n                totalCnt++;\\n            }\\n        }\\n        return (double)totalTime / totalCnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vedantalim",
                        "content": "why a design question everyday?\\n"
                    },
                    {
                        "username": "pavan_247",
                        "content": "class UndergroundSystem {\\n    HashMap<String,Integer> st=new HashMap<>();\\n    HashMap<Integer,HashMap<String,Integer>> ds=new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double count=0,sum=0;\\n       for (Map.Entry<Integer, HashMap<String, Integer>> entry : ds.entrySet()) {\\n           HashMap<String,Integer> new1=entry.getValue();\\n           if(new1.containsKey(startStation) && new1.containsKey(endStation)){\\n           sum+=new1.get(endStation)-new1.get(startStation);\\n           count++;\\n           }\\n            \\n       }\\n        return sum/count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */       \\n\\nit is passed 51/56 test case why not remaining can anyone explain the what is the wrong with my code\\n"
                    }
                ]
            },
            {
                "id": 1912091,
                "content": [
                    {
                        "username": "gbiems",
                        "content": "Like a few other people here, I\\'m failing on test case 52/56. It\\'s a long test case so difficult to break down and analyze.\\n\\nOne thing I was thinking about - is this a graph problem? Like, if I travel from A-B from time stamp 9 to 11 and then from B to C from 13 to 15, do I need to calculate that travel time was 4 hours, not 6 hours?"
                    },
                    {
                        "username": "gbiems",
                        "content": "Actually, probably not, the problem does state that it is direct travel time (every now and then the stated directions aren\\'t reflected in the test cases, but I doubt that\\'s the case here). "
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "For an \"Underground\" system, the travel time from `A -> B` SHOULD BE equal to `B -> A`. It\\'s seemed quite logical to me, but the question assumes different histories for travel time calculation between two stations. I find it weird and nausiating."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "got my first batch \\uD83E\\uDD29"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "51/56 test cases passed!!\nGiving wrong answer\ncan anyone please tell where am i doing it wrong??!!\n\nunordered_map<int,pair<string,int>>m1;\nunordered_map<string,vector<pair<int,int>>>m2;\n\n    UndergroundSystem() \n    {\n\n    }\n    \n    void checkIn(int id, string stationName, int t) \n    {\nm1[id]={stationName,t};\n\n    }\n    \n    void checkOut(int id, string stationName, int t) \n    {\n       m2[stationName].push_back({id,t});\n\n    }\n    \n    double getAverageTime(string startStation, string endStation) \n    {\n        double ans=0;\n        int cnt=0;\n      for(auto it:m2[endStation])\n      {\n          if(m1[it.first].first==startStation)\n          {\n       int x=m1[it.first].second;\n       ans+=it.second-x;\n       cnt++;\n\n          }\n\n      }\n      return ans/cnt;"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Possible Case : When a customer travels multiple times , say` ``A``` goes from ```t = 3``` to ```t = 5```.  Again ```A``` travels from ```t=7``` to ```t=10``` to the same place. Your map would have accounted only the last trip. "
                    },
                    {
                        "username": "maantos",
                        "content": "Shouldnt we check wheter user is already checkedIn? At least thats is how I undestand the description (\"A customer can only be checked into one place at a time.\"). Correct me if im missing somethings. "
                    },
                    {
                        "username": "xxossoo96",
                        "content": "seems like DB schema design"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "kinda sad to be missing just 5 days this month. already bought all 3 time travels too :("
                    },
                    {
                        "username": "Joshua-Shin",
                        "content": "Please let me know why my code is incorrect...\\nNo TLE. Just Wrong Answer..\\n49 / 56 tc passed..\\n\\n````\\r\\nclass UndergroundSystem {\\npublic:\\n    map<string, int> stationToId; // stationName -> stationId\\n    vector<pair<int, int>> in[1000001]; // in[stationId] : {customerId, t};\\n    vector<pair<int, int>> out[1000001]; // out[stationId] : {customerId, t};\\n    int unused = 1;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        in[stationId].push_back({id, t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        out[stationId].push_back({id, t});\\n    }\\n    int findCheckOutTime(string endStation, int customerId, int inTime) {\\n        for(auto p: out[stationToId[endStation]]) {\\n            if(p.first != customerId) continue;\\n            if(inTime >= p.second) continue;\\n            return p.second;\\n        }\\n        return -1;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        long long totalTime = 0;\\n        int totalCnt = 0;\\n        int stationId = stationToId[startStation];\\n        for(auto p: in[stationId]) {\\n            int outTime = findCheckOutTime(endStation, p.first, p.second);\\n            if(outTime != -1) {\\n                totalTime += (long long)(outTime - p.second);\\n                totalCnt++;\\n            }\\n        }\\n        return (double)totalTime / totalCnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vedantalim",
                        "content": "why a design question everyday?\\n"
                    },
                    {
                        "username": "pavan_247",
                        "content": "class UndergroundSystem {\\n    HashMap<String,Integer> st=new HashMap<>();\\n    HashMap<Integer,HashMap<String,Integer>> ds=new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double count=0,sum=0;\\n       for (Map.Entry<Integer, HashMap<String, Integer>> entry : ds.entrySet()) {\\n           HashMap<String,Integer> new1=entry.getValue();\\n           if(new1.containsKey(startStation) && new1.containsKey(endStation)){\\n           sum+=new1.get(endStation)-new1.get(startStation);\\n           count++;\\n           }\\n            \\n       }\\n        return sum/count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */       \\n\\nit is passed 51/56 test case why not remaining can anyone explain the what is the wrong with my code\\n"
                    }
                ]
            },
            {
                "id": 1912044,
                "content": [
                    {
                        "username": "gbiems",
                        "content": "Like a few other people here, I\\'m failing on test case 52/56. It\\'s a long test case so difficult to break down and analyze.\\n\\nOne thing I was thinking about - is this a graph problem? Like, if I travel from A-B from time stamp 9 to 11 and then from B to C from 13 to 15, do I need to calculate that travel time was 4 hours, not 6 hours?"
                    },
                    {
                        "username": "gbiems",
                        "content": "Actually, probably not, the problem does state that it is direct travel time (every now and then the stated directions aren\\'t reflected in the test cases, but I doubt that\\'s the case here). "
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "For an \"Underground\" system, the travel time from `A -> B` SHOULD BE equal to `B -> A`. It\\'s seemed quite logical to me, but the question assumes different histories for travel time calculation between two stations. I find it weird and nausiating."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "got my first batch \\uD83E\\uDD29"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "51/56 test cases passed!!\nGiving wrong answer\ncan anyone please tell where am i doing it wrong??!!\n\nunordered_map<int,pair<string,int>>m1;\nunordered_map<string,vector<pair<int,int>>>m2;\n\n    UndergroundSystem() \n    {\n\n    }\n    \n    void checkIn(int id, string stationName, int t) \n    {\nm1[id]={stationName,t};\n\n    }\n    \n    void checkOut(int id, string stationName, int t) \n    {\n       m2[stationName].push_back({id,t});\n\n    }\n    \n    double getAverageTime(string startStation, string endStation) \n    {\n        double ans=0;\n        int cnt=0;\n      for(auto it:m2[endStation])\n      {\n          if(m1[it.first].first==startStation)\n          {\n       int x=m1[it.first].second;\n       ans+=it.second-x;\n       cnt++;\n\n          }\n\n      }\n      return ans/cnt;"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Possible Case : When a customer travels multiple times , say` ``A``` goes from ```t = 3``` to ```t = 5```.  Again ```A``` travels from ```t=7``` to ```t=10``` to the same place. Your map would have accounted only the last trip. "
                    },
                    {
                        "username": "maantos",
                        "content": "Shouldnt we check wheter user is already checkedIn? At least thats is how I undestand the description (\"A customer can only be checked into one place at a time.\"). Correct me if im missing somethings. "
                    },
                    {
                        "username": "xxossoo96",
                        "content": "seems like DB schema design"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "kinda sad to be missing just 5 days this month. already bought all 3 time travels too :("
                    },
                    {
                        "username": "Joshua-Shin",
                        "content": "Please let me know why my code is incorrect...\\nNo TLE. Just Wrong Answer..\\n49 / 56 tc passed..\\n\\n````\\r\\nclass UndergroundSystem {\\npublic:\\n    map<string, int> stationToId; // stationName -> stationId\\n    vector<pair<int, int>> in[1000001]; // in[stationId] : {customerId, t};\\n    vector<pair<int, int>> out[1000001]; // out[stationId] : {customerId, t};\\n    int unused = 1;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        in[stationId].push_back({id, t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        out[stationId].push_back({id, t});\\n    }\\n    int findCheckOutTime(string endStation, int customerId, int inTime) {\\n        for(auto p: out[stationToId[endStation]]) {\\n            if(p.first != customerId) continue;\\n            if(inTime >= p.second) continue;\\n            return p.second;\\n        }\\n        return -1;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        long long totalTime = 0;\\n        int totalCnt = 0;\\n        int stationId = stationToId[startStation];\\n        for(auto p: in[stationId]) {\\n            int outTime = findCheckOutTime(endStation, p.first, p.second);\\n            if(outTime != -1) {\\n                totalTime += (long long)(outTime - p.second);\\n                totalCnt++;\\n            }\\n        }\\n        return (double)totalTime / totalCnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vedantalim",
                        "content": "why a design question everyday?\\n"
                    },
                    {
                        "username": "pavan_247",
                        "content": "class UndergroundSystem {\\n    HashMap<String,Integer> st=new HashMap<>();\\n    HashMap<Integer,HashMap<String,Integer>> ds=new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double count=0,sum=0;\\n       for (Map.Entry<Integer, HashMap<String, Integer>> entry : ds.entrySet()) {\\n           HashMap<String,Integer> new1=entry.getValue();\\n           if(new1.containsKey(startStation) && new1.containsKey(endStation)){\\n           sum+=new1.get(endStation)-new1.get(startStation);\\n           count++;\\n           }\\n            \\n       }\\n        return sum/count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */       \\n\\nit is passed 51/56 test case why not remaining can anyone explain the what is the wrong with my code\\n"
                    }
                ]
            },
            {
                "id": 1912036,
                "content": [
                    {
                        "username": "gbiems",
                        "content": "Like a few other people here, I\\'m failing on test case 52/56. It\\'s a long test case so difficult to break down and analyze.\\n\\nOne thing I was thinking about - is this a graph problem? Like, if I travel from A-B from time stamp 9 to 11 and then from B to C from 13 to 15, do I need to calculate that travel time was 4 hours, not 6 hours?"
                    },
                    {
                        "username": "gbiems",
                        "content": "Actually, probably not, the problem does state that it is direct travel time (every now and then the stated directions aren\\'t reflected in the test cases, but I doubt that\\'s the case here). "
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "For an \"Underground\" system, the travel time from `A -> B` SHOULD BE equal to `B -> A`. It\\'s seemed quite logical to me, but the question assumes different histories for travel time calculation between two stations. I find it weird and nausiating."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "got my first batch \\uD83E\\uDD29"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "51/56 test cases passed!!\nGiving wrong answer\ncan anyone please tell where am i doing it wrong??!!\n\nunordered_map<int,pair<string,int>>m1;\nunordered_map<string,vector<pair<int,int>>>m2;\n\n    UndergroundSystem() \n    {\n\n    }\n    \n    void checkIn(int id, string stationName, int t) \n    {\nm1[id]={stationName,t};\n\n    }\n    \n    void checkOut(int id, string stationName, int t) \n    {\n       m2[stationName].push_back({id,t});\n\n    }\n    \n    double getAverageTime(string startStation, string endStation) \n    {\n        double ans=0;\n        int cnt=0;\n      for(auto it:m2[endStation])\n      {\n          if(m1[it.first].first==startStation)\n          {\n       int x=m1[it.first].second;\n       ans+=it.second-x;\n       cnt++;\n\n          }\n\n      }\n      return ans/cnt;"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Possible Case : When a customer travels multiple times , say` ``A``` goes from ```t = 3``` to ```t = 5```.  Again ```A``` travels from ```t=7``` to ```t=10``` to the same place. Your map would have accounted only the last trip. "
                    },
                    {
                        "username": "maantos",
                        "content": "Shouldnt we check wheter user is already checkedIn? At least thats is how I undestand the description (\"A customer can only be checked into one place at a time.\"). Correct me if im missing somethings. "
                    },
                    {
                        "username": "xxossoo96",
                        "content": "seems like DB schema design"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "kinda sad to be missing just 5 days this month. already bought all 3 time travels too :("
                    },
                    {
                        "username": "Joshua-Shin",
                        "content": "Please let me know why my code is incorrect...\\nNo TLE. Just Wrong Answer..\\n49 / 56 tc passed..\\n\\n````\\r\\nclass UndergroundSystem {\\npublic:\\n    map<string, int> stationToId; // stationName -> stationId\\n    vector<pair<int, int>> in[1000001]; // in[stationId] : {customerId, t};\\n    vector<pair<int, int>> out[1000001]; // out[stationId] : {customerId, t};\\n    int unused = 1;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        in[stationId].push_back({id, t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        out[stationId].push_back({id, t});\\n    }\\n    int findCheckOutTime(string endStation, int customerId, int inTime) {\\n        for(auto p: out[stationToId[endStation]]) {\\n            if(p.first != customerId) continue;\\n            if(inTime >= p.second) continue;\\n            return p.second;\\n        }\\n        return -1;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        long long totalTime = 0;\\n        int totalCnt = 0;\\n        int stationId = stationToId[startStation];\\n        for(auto p: in[stationId]) {\\n            int outTime = findCheckOutTime(endStation, p.first, p.second);\\n            if(outTime != -1) {\\n                totalTime += (long long)(outTime - p.second);\\n                totalCnt++;\\n            }\\n        }\\n        return (double)totalTime / totalCnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vedantalim",
                        "content": "why a design question everyday?\\n"
                    },
                    {
                        "username": "pavan_247",
                        "content": "class UndergroundSystem {\\n    HashMap<String,Integer> st=new HashMap<>();\\n    HashMap<Integer,HashMap<String,Integer>> ds=new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double count=0,sum=0;\\n       for (Map.Entry<Integer, HashMap<String, Integer>> entry : ds.entrySet()) {\\n           HashMap<String,Integer> new1=entry.getValue();\\n           if(new1.containsKey(startStation) && new1.containsKey(endStation)){\\n           sum+=new1.get(endStation)-new1.get(startStation);\\n           count++;\\n           }\\n            \\n       }\\n        return sum/count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */       \\n\\nit is passed 51/56 test case why not remaining can anyone explain the what is the wrong with my code\\n"
                    }
                ]
            },
            {
                "id": 1911982,
                "content": [
                    {
                        "username": "gbiems",
                        "content": "Like a few other people here, I\\'m failing on test case 52/56. It\\'s a long test case so difficult to break down and analyze.\\n\\nOne thing I was thinking about - is this a graph problem? Like, if I travel from A-B from time stamp 9 to 11 and then from B to C from 13 to 15, do I need to calculate that travel time was 4 hours, not 6 hours?"
                    },
                    {
                        "username": "gbiems",
                        "content": "Actually, probably not, the problem does state that it is direct travel time (every now and then the stated directions aren\\'t reflected in the test cases, but I doubt that\\'s the case here). "
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "For an \"Underground\" system, the travel time from `A -> B` SHOULD BE equal to `B -> A`. It\\'s seemed quite logical to me, but the question assumes different histories for travel time calculation between two stations. I find it weird and nausiating."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "got my first batch \\uD83E\\uDD29"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "51/56 test cases passed!!\nGiving wrong answer\ncan anyone please tell where am i doing it wrong??!!\n\nunordered_map<int,pair<string,int>>m1;\nunordered_map<string,vector<pair<int,int>>>m2;\n\n    UndergroundSystem() \n    {\n\n    }\n    \n    void checkIn(int id, string stationName, int t) \n    {\nm1[id]={stationName,t};\n\n    }\n    \n    void checkOut(int id, string stationName, int t) \n    {\n       m2[stationName].push_back({id,t});\n\n    }\n    \n    double getAverageTime(string startStation, string endStation) \n    {\n        double ans=0;\n        int cnt=0;\n      for(auto it:m2[endStation])\n      {\n          if(m1[it.first].first==startStation)\n          {\n       int x=m1[it.first].second;\n       ans+=it.second-x;\n       cnt++;\n\n          }\n\n      }\n      return ans/cnt;"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Possible Case : When a customer travels multiple times , say` ``A``` goes from ```t = 3``` to ```t = 5```.  Again ```A``` travels from ```t=7``` to ```t=10``` to the same place. Your map would have accounted only the last trip. "
                    },
                    {
                        "username": "maantos",
                        "content": "Shouldnt we check wheter user is already checkedIn? At least thats is how I undestand the description (\"A customer can only be checked into one place at a time.\"). Correct me if im missing somethings. "
                    },
                    {
                        "username": "xxossoo96",
                        "content": "seems like DB schema design"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "kinda sad to be missing just 5 days this month. already bought all 3 time travels too :("
                    },
                    {
                        "username": "Joshua-Shin",
                        "content": "Please let me know why my code is incorrect...\\nNo TLE. Just Wrong Answer..\\n49 / 56 tc passed..\\n\\n````\\r\\nclass UndergroundSystem {\\npublic:\\n    map<string, int> stationToId; // stationName -> stationId\\n    vector<pair<int, int>> in[1000001]; // in[stationId] : {customerId, t};\\n    vector<pair<int, int>> out[1000001]; // out[stationId] : {customerId, t};\\n    int unused = 1;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        in[stationId].push_back({id, t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        out[stationId].push_back({id, t});\\n    }\\n    int findCheckOutTime(string endStation, int customerId, int inTime) {\\n        for(auto p: out[stationToId[endStation]]) {\\n            if(p.first != customerId) continue;\\n            if(inTime >= p.second) continue;\\n            return p.second;\\n        }\\n        return -1;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        long long totalTime = 0;\\n        int totalCnt = 0;\\n        int stationId = stationToId[startStation];\\n        for(auto p: in[stationId]) {\\n            int outTime = findCheckOutTime(endStation, p.first, p.second);\\n            if(outTime != -1) {\\n                totalTime += (long long)(outTime - p.second);\\n                totalCnt++;\\n            }\\n        }\\n        return (double)totalTime / totalCnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vedantalim",
                        "content": "why a design question everyday?\\n"
                    },
                    {
                        "username": "pavan_247",
                        "content": "class UndergroundSystem {\\n    HashMap<String,Integer> st=new HashMap<>();\\n    HashMap<Integer,HashMap<String,Integer>> ds=new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double count=0,sum=0;\\n       for (Map.Entry<Integer, HashMap<String, Integer>> entry : ds.entrySet()) {\\n           HashMap<String,Integer> new1=entry.getValue();\\n           if(new1.containsKey(startStation) && new1.containsKey(endStation)){\\n           sum+=new1.get(endStation)-new1.get(startStation);\\n           count++;\\n           }\\n            \\n       }\\n        return sum/count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */       \\n\\nit is passed 51/56 test case why not remaining can anyone explain the what is the wrong with my code\\n"
                    }
                ]
            },
            {
                "id": 1911979,
                "content": [
                    {
                        "username": "gbiems",
                        "content": "Like a few other people here, I\\'m failing on test case 52/56. It\\'s a long test case so difficult to break down and analyze.\\n\\nOne thing I was thinking about - is this a graph problem? Like, if I travel from A-B from time stamp 9 to 11 and then from B to C from 13 to 15, do I need to calculate that travel time was 4 hours, not 6 hours?"
                    },
                    {
                        "username": "gbiems",
                        "content": "Actually, probably not, the problem does state that it is direct travel time (every now and then the stated directions aren\\'t reflected in the test cases, but I doubt that\\'s the case here). "
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "For an \"Underground\" system, the travel time from `A -> B` SHOULD BE equal to `B -> A`. It\\'s seemed quite logical to me, but the question assumes different histories for travel time calculation between two stations. I find it weird and nausiating."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "got my first batch \\uD83E\\uDD29"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "51/56 test cases passed!!\nGiving wrong answer\ncan anyone please tell where am i doing it wrong??!!\n\nunordered_map<int,pair<string,int>>m1;\nunordered_map<string,vector<pair<int,int>>>m2;\n\n    UndergroundSystem() \n    {\n\n    }\n    \n    void checkIn(int id, string stationName, int t) \n    {\nm1[id]={stationName,t};\n\n    }\n    \n    void checkOut(int id, string stationName, int t) \n    {\n       m2[stationName].push_back({id,t});\n\n    }\n    \n    double getAverageTime(string startStation, string endStation) \n    {\n        double ans=0;\n        int cnt=0;\n      for(auto it:m2[endStation])\n      {\n          if(m1[it.first].first==startStation)\n          {\n       int x=m1[it.first].second;\n       ans+=it.second-x;\n       cnt++;\n\n          }\n\n      }\n      return ans/cnt;"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Possible Case : When a customer travels multiple times , say` ``A``` goes from ```t = 3``` to ```t = 5```.  Again ```A``` travels from ```t=7``` to ```t=10``` to the same place. Your map would have accounted only the last trip. "
                    },
                    {
                        "username": "maantos",
                        "content": "Shouldnt we check wheter user is already checkedIn? At least thats is how I undestand the description (\"A customer can only be checked into one place at a time.\"). Correct me if im missing somethings. "
                    },
                    {
                        "username": "xxossoo96",
                        "content": "seems like DB schema design"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "kinda sad to be missing just 5 days this month. already bought all 3 time travels too :("
                    },
                    {
                        "username": "Joshua-Shin",
                        "content": "Please let me know why my code is incorrect...\\nNo TLE. Just Wrong Answer..\\n49 / 56 tc passed..\\n\\n````\\r\\nclass UndergroundSystem {\\npublic:\\n    map<string, int> stationToId; // stationName -> stationId\\n    vector<pair<int, int>> in[1000001]; // in[stationId] : {customerId, t};\\n    vector<pair<int, int>> out[1000001]; // out[stationId] : {customerId, t};\\n    int unused = 1;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        in[stationId].push_back({id, t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        out[stationId].push_back({id, t});\\n    }\\n    int findCheckOutTime(string endStation, int customerId, int inTime) {\\n        for(auto p: out[stationToId[endStation]]) {\\n            if(p.first != customerId) continue;\\n            if(inTime >= p.second) continue;\\n            return p.second;\\n        }\\n        return -1;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        long long totalTime = 0;\\n        int totalCnt = 0;\\n        int stationId = stationToId[startStation];\\n        for(auto p: in[stationId]) {\\n            int outTime = findCheckOutTime(endStation, p.first, p.second);\\n            if(outTime != -1) {\\n                totalTime += (long long)(outTime - p.second);\\n                totalCnt++;\\n            }\\n        }\\n        return (double)totalTime / totalCnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vedantalim",
                        "content": "why a design question everyday?\\n"
                    },
                    {
                        "username": "pavan_247",
                        "content": "class UndergroundSystem {\\n    HashMap<String,Integer> st=new HashMap<>();\\n    HashMap<Integer,HashMap<String,Integer>> ds=new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double count=0,sum=0;\\n       for (Map.Entry<Integer, HashMap<String, Integer>> entry : ds.entrySet()) {\\n           HashMap<String,Integer> new1=entry.getValue();\\n           if(new1.containsKey(startStation) && new1.containsKey(endStation)){\\n           sum+=new1.get(endStation)-new1.get(startStation);\\n           count++;\\n           }\\n            \\n       }\\n        return sum/count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */       \\n\\nit is passed 51/56 test case why not remaining can anyone explain the what is the wrong with my code\\n"
                    }
                ]
            },
            {
                "id": 1911943,
                "content": [
                    {
                        "username": "gbiems",
                        "content": "Like a few other people here, I\\'m failing on test case 52/56. It\\'s a long test case so difficult to break down and analyze.\\n\\nOne thing I was thinking about - is this a graph problem? Like, if I travel from A-B from time stamp 9 to 11 and then from B to C from 13 to 15, do I need to calculate that travel time was 4 hours, not 6 hours?"
                    },
                    {
                        "username": "gbiems",
                        "content": "Actually, probably not, the problem does state that it is direct travel time (every now and then the stated directions aren\\'t reflected in the test cases, but I doubt that\\'s the case here). "
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "For an \"Underground\" system, the travel time from `A -> B` SHOULD BE equal to `B -> A`. It\\'s seemed quite logical to me, but the question assumes different histories for travel time calculation between two stations. I find it weird and nausiating."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "got my first batch \\uD83E\\uDD29"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "51/56 test cases passed!!\nGiving wrong answer\ncan anyone please tell where am i doing it wrong??!!\n\nunordered_map<int,pair<string,int>>m1;\nunordered_map<string,vector<pair<int,int>>>m2;\n\n    UndergroundSystem() \n    {\n\n    }\n    \n    void checkIn(int id, string stationName, int t) \n    {\nm1[id]={stationName,t};\n\n    }\n    \n    void checkOut(int id, string stationName, int t) \n    {\n       m2[stationName].push_back({id,t});\n\n    }\n    \n    double getAverageTime(string startStation, string endStation) \n    {\n        double ans=0;\n        int cnt=0;\n      for(auto it:m2[endStation])\n      {\n          if(m1[it.first].first==startStation)\n          {\n       int x=m1[it.first].second;\n       ans+=it.second-x;\n       cnt++;\n\n          }\n\n      }\n      return ans/cnt;"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Possible Case : When a customer travels multiple times , say` ``A``` goes from ```t = 3``` to ```t = 5```.  Again ```A``` travels from ```t=7``` to ```t=10``` to the same place. Your map would have accounted only the last trip. "
                    },
                    {
                        "username": "maantos",
                        "content": "Shouldnt we check wheter user is already checkedIn? At least thats is how I undestand the description (\"A customer can only be checked into one place at a time.\"). Correct me if im missing somethings. "
                    },
                    {
                        "username": "xxossoo96",
                        "content": "seems like DB schema design"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "kinda sad to be missing just 5 days this month. already bought all 3 time travels too :("
                    },
                    {
                        "username": "Joshua-Shin",
                        "content": "Please let me know why my code is incorrect...\\nNo TLE. Just Wrong Answer..\\n49 / 56 tc passed..\\n\\n````\\r\\nclass UndergroundSystem {\\npublic:\\n    map<string, int> stationToId; // stationName -> stationId\\n    vector<pair<int, int>> in[1000001]; // in[stationId] : {customerId, t};\\n    vector<pair<int, int>> out[1000001]; // out[stationId] : {customerId, t};\\n    int unused = 1;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        in[stationId].push_back({id, t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        out[stationId].push_back({id, t});\\n    }\\n    int findCheckOutTime(string endStation, int customerId, int inTime) {\\n        for(auto p: out[stationToId[endStation]]) {\\n            if(p.first != customerId) continue;\\n            if(inTime >= p.second) continue;\\n            return p.second;\\n        }\\n        return -1;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        long long totalTime = 0;\\n        int totalCnt = 0;\\n        int stationId = stationToId[startStation];\\n        for(auto p: in[stationId]) {\\n            int outTime = findCheckOutTime(endStation, p.first, p.second);\\n            if(outTime != -1) {\\n                totalTime += (long long)(outTime - p.second);\\n                totalCnt++;\\n            }\\n        }\\n        return (double)totalTime / totalCnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vedantalim",
                        "content": "why a design question everyday?\\n"
                    },
                    {
                        "username": "pavan_247",
                        "content": "class UndergroundSystem {\\n    HashMap<String,Integer> st=new HashMap<>();\\n    HashMap<Integer,HashMap<String,Integer>> ds=new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double count=0,sum=0;\\n       for (Map.Entry<Integer, HashMap<String, Integer>> entry : ds.entrySet()) {\\n           HashMap<String,Integer> new1=entry.getValue();\\n           if(new1.containsKey(startStation) && new1.containsKey(endStation)){\\n           sum+=new1.get(endStation)-new1.get(startStation);\\n           count++;\\n           }\\n            \\n       }\\n        return sum/count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */       \\n\\nit is passed 51/56 test case why not remaining can anyone explain the what is the wrong with my code\\n"
                    }
                ]
            },
            {
                "id": 1911860,
                "content": [
                    {
                        "username": "gbiems",
                        "content": "Like a few other people here, I\\'m failing on test case 52/56. It\\'s a long test case so difficult to break down and analyze.\\n\\nOne thing I was thinking about - is this a graph problem? Like, if I travel from A-B from time stamp 9 to 11 and then from B to C from 13 to 15, do I need to calculate that travel time was 4 hours, not 6 hours?"
                    },
                    {
                        "username": "gbiems",
                        "content": "Actually, probably not, the problem does state that it is direct travel time (every now and then the stated directions aren\\'t reflected in the test cases, but I doubt that\\'s the case here). "
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "For an \"Underground\" system, the travel time from `A -> B` SHOULD BE equal to `B -> A`. It\\'s seemed quite logical to me, but the question assumes different histories for travel time calculation between two stations. I find it weird and nausiating."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "got my first batch \\uD83E\\uDD29"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "51/56 test cases passed!!\nGiving wrong answer\ncan anyone please tell where am i doing it wrong??!!\n\nunordered_map<int,pair<string,int>>m1;\nunordered_map<string,vector<pair<int,int>>>m2;\n\n    UndergroundSystem() \n    {\n\n    }\n    \n    void checkIn(int id, string stationName, int t) \n    {\nm1[id]={stationName,t};\n\n    }\n    \n    void checkOut(int id, string stationName, int t) \n    {\n       m2[stationName].push_back({id,t});\n\n    }\n    \n    double getAverageTime(string startStation, string endStation) \n    {\n        double ans=0;\n        int cnt=0;\n      for(auto it:m2[endStation])\n      {\n          if(m1[it.first].first==startStation)\n          {\n       int x=m1[it.first].second;\n       ans+=it.second-x;\n       cnt++;\n\n          }\n\n      }\n      return ans/cnt;"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Possible Case : When a customer travels multiple times , say` ``A``` goes from ```t = 3``` to ```t = 5```.  Again ```A``` travels from ```t=7``` to ```t=10``` to the same place. Your map would have accounted only the last trip. "
                    },
                    {
                        "username": "maantos",
                        "content": "Shouldnt we check wheter user is already checkedIn? At least thats is how I undestand the description (\"A customer can only be checked into one place at a time.\"). Correct me if im missing somethings. "
                    },
                    {
                        "username": "xxossoo96",
                        "content": "seems like DB schema design"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "kinda sad to be missing just 5 days this month. already bought all 3 time travels too :("
                    },
                    {
                        "username": "Joshua-Shin",
                        "content": "Please let me know why my code is incorrect...\\nNo TLE. Just Wrong Answer..\\n49 / 56 tc passed..\\n\\n````\\r\\nclass UndergroundSystem {\\npublic:\\n    map<string, int> stationToId; // stationName -> stationId\\n    vector<pair<int, int>> in[1000001]; // in[stationId] : {customerId, t};\\n    vector<pair<int, int>> out[1000001]; // out[stationId] : {customerId, t};\\n    int unused = 1;\\n\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        in[stationId].push_back({id, t});\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        if(stationToId.find(stationName) == stationToId.end()) {\\n            stationToId[stationName] = unused++;\\n        }\\n        int stationId = stationToId[stationName];\\n        out[stationId].push_back({id, t});\\n    }\\n    int findCheckOutTime(string endStation, int customerId, int inTime) {\\n        for(auto p: out[stationToId[endStation]]) {\\n            if(p.first != customerId) continue;\\n            if(inTime >= p.second) continue;\\n            return p.second;\\n        }\\n        return -1;\\n    }\\n    double getAverageTime(string startStation, string endStation) {\\n        long long totalTime = 0;\\n        int totalCnt = 0;\\n        int stationId = stationToId[startStation];\\n        for(auto p: in[stationId]) {\\n            int outTime = findCheckOutTime(endStation, p.first, p.second);\\n            if(outTime != -1) {\\n                totalTime += (long long)(outTime - p.second);\\n                totalCnt++;\\n            }\\n        }\\n        return (double)totalTime / totalCnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vedantalim",
                        "content": "why a design question everyday?\\n"
                    },
                    {
                        "username": "pavan_247",
                        "content": "class UndergroundSystem {\\n    HashMap<String,Integer> st=new HashMap<>();\\n    HashMap<Integer,HashMap<String,Integer>> ds=new HashMap<>();\\n    public UndergroundSystem() {\\n        \\n    }\\n    \\n    public void checkIn(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public void checkOut(int id, String stationName, int t) {\\n       if(!ds.containsKey(id)){\\n           HashMap<String,Integer> stex=new HashMap<>();\\n           stex.put(stationName,t);\\n           ds.put(id,stex);\\n       }\\n       else{\\n           ds.get(id).put(stationName,t);\\n       }\\n    }\\n    \\n    public double getAverageTime(String startStation, String endStation) {\\n        double count=0,sum=0;\\n       for (Map.Entry<Integer, HashMap<String, Integer>> entry : ds.entrySet()) {\\n           HashMap<String,Integer> new1=entry.getValue();\\n           if(new1.containsKey(startStation) && new1.containsKey(endStation)){\\n           sum+=new1.get(endStation)-new1.get(startStation);\\n           count++;\\n           }\\n            \\n       }\\n        return sum/count;\\n    }\\n}\\n\\n/**\\n * Your UndergroundSystem object will be instantiated and called as such:\\n * UndergroundSystem obj = new UndergroundSystem();\\n * obj.checkIn(id,stationName,t);\\n * obj.checkOut(id,stationName,t);\\n * double param_3 = obj.getAverageTime(startStation,endStation);\\n */       \\n\\nit is passed 51/56 test case why not remaining can anyone explain the what is the wrong with my code\\n"
                    }
                ]
            },
            {
                "id": 1911850,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "AshokRajeev",
                        "content": "Point : Distance from A -> B and B -> A may be different."
                    },
                    {
                        "username": "Putul77",
                        "content": "Can anyone help me to find the bug in this code?\\nclass UndergroundSystem {\\npublic:\\n    typedef tuple<string,int> t;\\n    unordered_map<int,pair<t,t>> mp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id].first={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto [a,b]=mp[id].first;\\n        mp[id].second={stationName,t-b};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum=0.0;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            auto [a,b]=it.second.first;\\n            auto [c,d]=it.second.second;\\n            if(a==startStation&&c==endStation)\\n            {\\n                count++;\\n                sum+=d;\\n            }\\n        }\\n        return (double)sum/count;\\n    }\\n};"
                    },
                    {
                        "username": "user5400vw",
                        "content": "in the case a rider makes multiple trips, mp[id] will be overridden."
                    },
                    {
                        "username": "gaurav621",
                        "content": "Looks like LC decided this week for System Design "
                    },
                    {
                        "username": "Jateq",
                        "content": "triple design in the end, insane!\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I love it, but too easy. They should let this kind of problems to the weekends LOL"
                    },
                    {
                        "username": "_SID_",
                        "content": "When you read it first time it looks tricky...when you try to solve it...it\\'s easy "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "<h1>Design Week!</h1>"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "For anyone else running into issues on Java, it may be the case you are using == for string comparisons which is a reference comparison. It was the problem for me. Use .equals() instead!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s been 3 consecutive days of designing**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is it just me or are the \"design a class\" questions quite a bit easier?"
                    }
                ]
            },
            {
                "id": 1911830,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "AshokRajeev",
                        "content": "Point : Distance from A -> B and B -> A may be different."
                    },
                    {
                        "username": "Putul77",
                        "content": "Can anyone help me to find the bug in this code?\\nclass UndergroundSystem {\\npublic:\\n    typedef tuple<string,int> t;\\n    unordered_map<int,pair<t,t>> mp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id].first={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto [a,b]=mp[id].first;\\n        mp[id].second={stationName,t-b};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum=0.0;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            auto [a,b]=it.second.first;\\n            auto [c,d]=it.second.second;\\n            if(a==startStation&&c==endStation)\\n            {\\n                count++;\\n                sum+=d;\\n            }\\n        }\\n        return (double)sum/count;\\n    }\\n};"
                    },
                    {
                        "username": "user5400vw",
                        "content": "in the case a rider makes multiple trips, mp[id] will be overridden."
                    },
                    {
                        "username": "gaurav621",
                        "content": "Looks like LC decided this week for System Design "
                    },
                    {
                        "username": "Jateq",
                        "content": "triple design in the end, insane!\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I love it, but too easy. They should let this kind of problems to the weekends LOL"
                    },
                    {
                        "username": "_SID_",
                        "content": "When you read it first time it looks tricky...when you try to solve it...it\\'s easy "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "<h1>Design Week!</h1>"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "For anyone else running into issues on Java, it may be the case you are using == for string comparisons which is a reference comparison. It was the problem for me. Use .equals() instead!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s been 3 consecutive days of designing**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is it just me or are the \"design a class\" questions quite a bit easier?"
                    }
                ]
            },
            {
                "id": 1911745,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "AshokRajeev",
                        "content": "Point : Distance from A -> B and B -> A may be different."
                    },
                    {
                        "username": "Putul77",
                        "content": "Can anyone help me to find the bug in this code?\\nclass UndergroundSystem {\\npublic:\\n    typedef tuple<string,int> t;\\n    unordered_map<int,pair<t,t>> mp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id].first={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto [a,b]=mp[id].first;\\n        mp[id].second={stationName,t-b};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum=0.0;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            auto [a,b]=it.second.first;\\n            auto [c,d]=it.second.second;\\n            if(a==startStation&&c==endStation)\\n            {\\n                count++;\\n                sum+=d;\\n            }\\n        }\\n        return (double)sum/count;\\n    }\\n};"
                    },
                    {
                        "username": "user5400vw",
                        "content": "in the case a rider makes multiple trips, mp[id] will be overridden."
                    },
                    {
                        "username": "gaurav621",
                        "content": "Looks like LC decided this week for System Design "
                    },
                    {
                        "username": "Jateq",
                        "content": "triple design in the end, insane!\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I love it, but too easy. They should let this kind of problems to the weekends LOL"
                    },
                    {
                        "username": "_SID_",
                        "content": "When you read it first time it looks tricky...when you try to solve it...it\\'s easy "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "<h1>Design Week!</h1>"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "For anyone else running into issues on Java, it may be the case you are using == for string comparisons which is a reference comparison. It was the problem for me. Use .equals() instead!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s been 3 consecutive days of designing**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is it just me or are the \"design a class\" questions quite a bit easier?"
                    }
                ]
            },
            {
                "id": 1911736,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "AshokRajeev",
                        "content": "Point : Distance from A -> B and B -> A may be different."
                    },
                    {
                        "username": "Putul77",
                        "content": "Can anyone help me to find the bug in this code?\\nclass UndergroundSystem {\\npublic:\\n    typedef tuple<string,int> t;\\n    unordered_map<int,pair<t,t>> mp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id].first={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto [a,b]=mp[id].first;\\n        mp[id].second={stationName,t-b};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum=0.0;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            auto [a,b]=it.second.first;\\n            auto [c,d]=it.second.second;\\n            if(a==startStation&&c==endStation)\\n            {\\n                count++;\\n                sum+=d;\\n            }\\n        }\\n        return (double)sum/count;\\n    }\\n};"
                    },
                    {
                        "username": "user5400vw",
                        "content": "in the case a rider makes multiple trips, mp[id] will be overridden."
                    },
                    {
                        "username": "gaurav621",
                        "content": "Looks like LC decided this week for System Design "
                    },
                    {
                        "username": "Jateq",
                        "content": "triple design in the end, insane!\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I love it, but too easy. They should let this kind of problems to the weekends LOL"
                    },
                    {
                        "username": "_SID_",
                        "content": "When you read it first time it looks tricky...when you try to solve it...it\\'s easy "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "<h1>Design Week!</h1>"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "For anyone else running into issues on Java, it may be the case you are using == for string comparisons which is a reference comparison. It was the problem for me. Use .equals() instead!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s been 3 consecutive days of designing**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is it just me or are the \"design a class\" questions quite a bit easier?"
                    }
                ]
            },
            {
                "id": 1911729,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "AshokRajeev",
                        "content": "Point : Distance from A -> B and B -> A may be different."
                    },
                    {
                        "username": "Putul77",
                        "content": "Can anyone help me to find the bug in this code?\\nclass UndergroundSystem {\\npublic:\\n    typedef tuple<string,int> t;\\n    unordered_map<int,pair<t,t>> mp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id].first={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto [a,b]=mp[id].first;\\n        mp[id].second={stationName,t-b};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum=0.0;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            auto [a,b]=it.second.first;\\n            auto [c,d]=it.second.second;\\n            if(a==startStation&&c==endStation)\\n            {\\n                count++;\\n                sum+=d;\\n            }\\n        }\\n        return (double)sum/count;\\n    }\\n};"
                    },
                    {
                        "username": "user5400vw",
                        "content": "in the case a rider makes multiple trips, mp[id] will be overridden."
                    },
                    {
                        "username": "gaurav621",
                        "content": "Looks like LC decided this week for System Design "
                    },
                    {
                        "username": "Jateq",
                        "content": "triple design in the end, insane!\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I love it, but too easy. They should let this kind of problems to the weekends LOL"
                    },
                    {
                        "username": "_SID_",
                        "content": "When you read it first time it looks tricky...when you try to solve it...it\\'s easy "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "<h1>Design Week!</h1>"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "For anyone else running into issues on Java, it may be the case you are using == for string comparisons which is a reference comparison. It was the problem for me. Use .equals() instead!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s been 3 consecutive days of designing**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is it just me or are the \"design a class\" questions quite a bit easier?"
                    }
                ]
            },
            {
                "id": 1911712,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "AshokRajeev",
                        "content": "Point : Distance from A -> B and B -> A may be different."
                    },
                    {
                        "username": "Putul77",
                        "content": "Can anyone help me to find the bug in this code?\\nclass UndergroundSystem {\\npublic:\\n    typedef tuple<string,int> t;\\n    unordered_map<int,pair<t,t>> mp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id].first={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto [a,b]=mp[id].first;\\n        mp[id].second={stationName,t-b};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum=0.0;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            auto [a,b]=it.second.first;\\n            auto [c,d]=it.second.second;\\n            if(a==startStation&&c==endStation)\\n            {\\n                count++;\\n                sum+=d;\\n            }\\n        }\\n        return (double)sum/count;\\n    }\\n};"
                    },
                    {
                        "username": "user5400vw",
                        "content": "in the case a rider makes multiple trips, mp[id] will be overridden."
                    },
                    {
                        "username": "gaurav621",
                        "content": "Looks like LC decided this week for System Design "
                    },
                    {
                        "username": "Jateq",
                        "content": "triple design in the end, insane!\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I love it, but too easy. They should let this kind of problems to the weekends LOL"
                    },
                    {
                        "username": "_SID_",
                        "content": "When you read it first time it looks tricky...when you try to solve it...it\\'s easy "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "<h1>Design Week!</h1>"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "For anyone else running into issues on Java, it may be the case you are using == for string comparisons which is a reference comparison. It was the problem for me. Use .equals() instead!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s been 3 consecutive days of designing**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is it just me or are the \"design a class\" questions quite a bit easier?"
                    }
                ]
            },
            {
                "id": 1911688,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "AshokRajeev",
                        "content": "Point : Distance from A -> B and B -> A may be different."
                    },
                    {
                        "username": "Putul77",
                        "content": "Can anyone help me to find the bug in this code?\\nclass UndergroundSystem {\\npublic:\\n    typedef tuple<string,int> t;\\n    unordered_map<int,pair<t,t>> mp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id].first={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto [a,b]=mp[id].first;\\n        mp[id].second={stationName,t-b};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum=0.0;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            auto [a,b]=it.second.first;\\n            auto [c,d]=it.second.second;\\n            if(a==startStation&&c==endStation)\\n            {\\n                count++;\\n                sum+=d;\\n            }\\n        }\\n        return (double)sum/count;\\n    }\\n};"
                    },
                    {
                        "username": "user5400vw",
                        "content": "in the case a rider makes multiple trips, mp[id] will be overridden."
                    },
                    {
                        "username": "gaurav621",
                        "content": "Looks like LC decided this week for System Design "
                    },
                    {
                        "username": "Jateq",
                        "content": "triple design in the end, insane!\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I love it, but too easy. They should let this kind of problems to the weekends LOL"
                    },
                    {
                        "username": "_SID_",
                        "content": "When you read it first time it looks tricky...when you try to solve it...it\\'s easy "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "<h1>Design Week!</h1>"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "For anyone else running into issues on Java, it may be the case you are using == for string comparisons which is a reference comparison. It was the problem for me. Use .equals() instead!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s been 3 consecutive days of designing**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is it just me or are the \"design a class\" questions quite a bit easier?"
                    }
                ]
            },
            {
                "id": 1911661,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "AshokRajeev",
                        "content": "Point : Distance from A -> B and B -> A may be different."
                    },
                    {
                        "username": "Putul77",
                        "content": "Can anyone help me to find the bug in this code?\\nclass UndergroundSystem {\\npublic:\\n    typedef tuple<string,int> t;\\n    unordered_map<int,pair<t,t>> mp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id].first={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto [a,b]=mp[id].first;\\n        mp[id].second={stationName,t-b};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum=0.0;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            auto [a,b]=it.second.first;\\n            auto [c,d]=it.second.second;\\n            if(a==startStation&&c==endStation)\\n            {\\n                count++;\\n                sum+=d;\\n            }\\n        }\\n        return (double)sum/count;\\n    }\\n};"
                    },
                    {
                        "username": "user5400vw",
                        "content": "in the case a rider makes multiple trips, mp[id] will be overridden."
                    },
                    {
                        "username": "gaurav621",
                        "content": "Looks like LC decided this week for System Design "
                    },
                    {
                        "username": "Jateq",
                        "content": "triple design in the end, insane!\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I love it, but too easy. They should let this kind of problems to the weekends LOL"
                    },
                    {
                        "username": "_SID_",
                        "content": "When you read it first time it looks tricky...when you try to solve it...it\\'s easy "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "<h1>Design Week!</h1>"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "For anyone else running into issues on Java, it may be the case you are using == for string comparisons which is a reference comparison. It was the problem for me. Use .equals() instead!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s been 3 consecutive days of designing**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is it just me or are the \"design a class\" questions quite a bit easier?"
                    }
                ]
            },
            {
                "id": 1911598,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "AshokRajeev",
                        "content": "Point : Distance from A -> B and B -> A may be different."
                    },
                    {
                        "username": "Putul77",
                        "content": "Can anyone help me to find the bug in this code?\\nclass UndergroundSystem {\\npublic:\\n    typedef tuple<string,int> t;\\n    unordered_map<int,pair<t,t>> mp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id].first={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto [a,b]=mp[id].first;\\n        mp[id].second={stationName,t-b};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum=0.0;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            auto [a,b]=it.second.first;\\n            auto [c,d]=it.second.second;\\n            if(a==startStation&&c==endStation)\\n            {\\n                count++;\\n                sum+=d;\\n            }\\n        }\\n        return (double)sum/count;\\n    }\\n};"
                    },
                    {
                        "username": "user5400vw",
                        "content": "in the case a rider makes multiple trips, mp[id] will be overridden."
                    },
                    {
                        "username": "gaurav621",
                        "content": "Looks like LC decided this week for System Design "
                    },
                    {
                        "username": "Jateq",
                        "content": "triple design in the end, insane!\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I love it, but too easy. They should let this kind of problems to the weekends LOL"
                    },
                    {
                        "username": "_SID_",
                        "content": "When you read it first time it looks tricky...when you try to solve it...it\\'s easy "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "<h1>Design Week!</h1>"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "For anyone else running into issues on Java, it may be the case you are using == for string comparisons which is a reference comparison. It was the problem for me. Use .equals() instead!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s been 3 consecutive days of designing**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is it just me or are the \"design a class\" questions quite a bit easier?"
                    }
                ]
            },
            {
                "id": 1911557,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "AshokRajeev",
                        "content": "Point : Distance from A -> B and B -> A may be different."
                    },
                    {
                        "username": "Putul77",
                        "content": "Can anyone help me to find the bug in this code?\\nclass UndergroundSystem {\\npublic:\\n    typedef tuple<string,int> t;\\n    unordered_map<int,pair<t,t>> mp;\\n    UndergroundSystem() {\\n        \\n    }\\n    \\n    void checkIn(int id, string stationName, int t) {\\n        mp[id].first={stationName,t};\\n    }\\n    \\n    void checkOut(int id, string stationName, int t) {\\n        auto [a,b]=mp[id].first;\\n        mp[id].second={stationName,t-b};\\n    }\\n    \\n    double getAverageTime(string startStation, string endStation) {\\n        double sum=0.0;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            auto [a,b]=it.second.first;\\n            auto [c,d]=it.second.second;\\n            if(a==startStation&&c==endStation)\\n            {\\n                count++;\\n                sum+=d;\\n            }\\n        }\\n        return (double)sum/count;\\n    }\\n};"
                    },
                    {
                        "username": "user5400vw",
                        "content": "in the case a rider makes multiple trips, mp[id] will be overridden."
                    },
                    {
                        "username": "gaurav621",
                        "content": "Looks like LC decided this week for System Design "
                    },
                    {
                        "username": "Jateq",
                        "content": "triple design in the end, insane!\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "I love it, but too easy. They should let this kind of problems to the weekends LOL"
                    },
                    {
                        "username": "_SID_",
                        "content": "When you read it first time it looks tricky...when you try to solve it...it\\'s easy "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "<h1>Design Week!</h1>"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "For anyone else running into issues on Java, it may be the case you are using == for string comparisons which is a reference comparison. It was the problem for me. Use .equals() instead!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s been 3 consecutive days of designing**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is it just me or are the \"design a class\" questions quite a bit easier?"
                    }
                ]
            }
        ]
    }
]