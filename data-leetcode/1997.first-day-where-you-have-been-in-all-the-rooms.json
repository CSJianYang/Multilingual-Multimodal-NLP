[
    {
        "title": "Push Dominoes",
        "question_content": "There are n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\nYou are given a string dominoes representing the initial state where:\n\n\tdominoes[i] = 'L', if the ith domino has been pushed to the left,\n\tdominoes[i] = 'R', if the ith domino has been pushed to the right, and\n\tdominoes[i] = '.', if the ith domino has not been pushed.\n\nReturn a string representing the final state.\n&nbsp;\nExample 1:\n\nInput: dominoes = \"RR.L\"\nOutput: \"RR.L\"\nExplanation: The first domino expends no additional force on the second domino.\n\nExample 2:\n\nInput: dominoes = \".L.R...LR..L..\"\nOutput: \"LL.RR.LLRRLL..\"\n\n&nbsp;\nConstraints:\n\n\tn == dominoes.length\n\t1 <= n <= 105\n\tdominoes[i] is either 'L', 'R', or '.'.",
        "solutions": [
            {
                "id": 132332,
                "title": "java-c-python-two-pointers",
                "content": "# **Intuition**:\\nWhether be pushed or not, depend on the shortest distance to \\'L\\' and \\'R\\'.\\nAlso the direction matters.\\nBase on this idea, you can do the same thing inspired by this problem.\\nhttps://leetcode.com/problems/shortest-distance-to-a-character/discuss/125788/\\n\\nHere is another idea is focus on only \\'L\\' and \\'R\\'.\\n<br>\\n\\n# **Complexity**:\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public String pushDominoes(String d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d.charAt(j) == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res.append(d.charAt(i));\\n            if (d.charAt(i) == d.charAt(j))\\n                for (int k = 0; k < middle; k++)\\n                    res.append(d.charAt(i));\\n            else if (d.charAt(i) == \\'L\\' && d.charAt(j) == \\'R\\')\\n                for (int k = 0; k < middle; k++)\\n                    res.append(\\'.\\');\\n            else {\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'R\\');\\n                if (middle % 2 == 1)\\n                    res.append(\\'.\\');\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'L\\');\\n            }\\n            i = j;\\n        }\\n        return res.toString();\\n    }\\n```\\n**C++:**\\n```cpp\\n    string pushDominoes(string d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        string res = \"\";\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d[j] == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res += d[i];\\n            if (d[i] == d[j])\\n                res += string(middle, d[i]);\\n            else if (d[i] == \\'L\\' && d[j] == \\'R\\')\\n                res += string(middle, \\'.\\');\\n            else\\n                res += string(middle / 2, \\'R\\') + string(middle % 2, \\'.\\') + string(middle / 2, \\'L\\');\\n            i = j;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def pushDominoes(self, d):\\n        d = \\'L\\' + d + \\'R\\'\\n        res = \"\"\\n        i = 0\\n        for j in range(1, len(d)):\\n            if d[j] == \\'.\\':\\n                continue\\n            middle = j - i - 1\\n            if i:\\n                res += d[i]\\n            if d[i] == d[j]:\\n                res += d[i] * middle\\n            elif d[i] == \\'L\\' and d[j] == \\'R\\':\\n                res += \\'.\\' * middle\\n            else:\\n                res += \\'R\\' * (middle / 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle / 2)\\n            i = j\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public String pushDominoes(String d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d.charAt(j) == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res.append(d.charAt(i));\\n            if (d.charAt(i) == d.charAt(j))\\n                for (int k = 0; k < middle; k++)\\n                    res.append(d.charAt(i));\\n            else if (d.charAt(i) == \\'L\\' && d.charAt(j) == \\'R\\')\\n                for (int k = 0; k < middle; k++)\\n                    res.append(\\'.\\');\\n            else {\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'R\\');\\n                if (middle % 2 == 1)\\n                    res.append(\\'.\\');\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'L\\');\\n            }\\n            i = j;\\n        }\\n        return res.toString();\\n    }\\n```\n```cpp\\n    string pushDominoes(string d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        string res = \"\";\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d[j] == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res += d[i];\\n            if (d[i] == d[j])\\n                res += string(middle, d[i]);\\n            else if (d[i] == \\'L\\' && d[j] == \\'R\\')\\n                res += string(middle, \\'.\\');\\n            else\\n                res += string(middle / 2, \\'R\\') + string(middle % 2, \\'.\\') + string(middle / 2, \\'L\\');\\n            i = j;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def pushDominoes(self, d):\\n        d = \\'L\\' + d + \\'R\\'\\n        res = \"\"\\n        i = 0\\n        for j in range(1, len(d)):\\n            if d[j] == \\'.\\':\\n                continue\\n            middle = j - i - 1\\n            if i:\\n                res += d[i]\\n            if d[i] == d[j]:\\n                res += d[i] * middle\\n            elif d[i] == \\'L\\' and d[j] == \\'R\\':\\n                res += \\'.\\' * middle\\n            else:\\n                res += \\'R\\' * (middle / 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle / 2)\\n            i = j\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2628923,
                "title": "c-two-pointer-diagram-related-problems",
                "content": "**Approach**\\n1. If we encounter `.` in string, we move forward to next index.\\n2. If we encounter `L` in string, we see if index of right is -1, we make all the left index `L` until we see any other `L`.\\n2. If we encounter `L` in string and there is some previous `R` index, then we simultaneously change string from left and right side till two pointers reach each other. After that `right` moves back to `-1`.\\n3. If we encounter `R` in string, we see if the index of `R` is not -1, we make all the indices upto that index `R`.\\n\\n**Diagram Explanation**\\n\\n![image](https://assets.leetcode.com/users/images/ffb493fa-7b64-4859-8aa0-e2cf78d5a2bf_1664247243.6077156.png)\\n\\n![image](https://assets.leetcode.com/users/images/11608e78-545d-435f-afb1-d824948f13d9_1664247249.2657273.png)\\n\\n**Explanation of steps** \\nIn **step 8**, we encountered `L`, so first thing we check if index of previous `right` is not `-1`. Here `right` is `3`, so we started making `R` from index 4 onwards  and simultaneously started making `L` from index `7` in backward direction. We will stop if left and right pointer arrives at same point. After than, we send right to -1 until we find another `R` in string.\\n\\n**C++ Code**\\n\\n```cpp\\nstring pushDominoes(string s) {\\n    int N = s.size(), right = -1;\\n    for (int i = 0; i < N; ++i) {\\n        if (s[i] == \\'L\\') {\\n            if (right == -1) { \\n                // Step 2\\n                for (int j = i - 1; j >= 0 && s[j] == \\'.\\'; --j) {\\n                  s[j] = \\'L\\';  \\n                } \\n            } else {\\n                // Step 8\\n                for (int j = right + 1, k = i - 1; j < k; ++j, --k) {\\n                    s[j] = \\'R\\';\\n                    s[k] = \\'L\\';\\n                } \\n                right = -1;\\n            }\\n        } else if (s[i] == \\'R\\') {\\n            if (right != -1) {\\n                for (int j = right + 1; j < i; ++j) s[j] = \\'R\\';\\n            }\\n            right = i;\\n        }\\n    }\\n    if (right != -1) {\\n        for (int j = right + 1; j < N; ++j) s[j] = \\'R\\';\\n    }\\n    return s;\\n}\\n```\\n\\n**Related Problems - Two Pointer**\\n[1. Two Sum ](https://leetcode.com/problems/two-sum/)\\n[2. Container With Most Water ](https://leetcode.com/problems/container-with-most-water/)\\n[3. 3Sum ](https://leetcode.com/problems/3sum/)\\n[4. Minimum Window Substring ](https://leetcode.com/problems/minimum-window-substring/)\\n[5. Remove Duplicates from Sorted List ](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)\\n[6. Reorder List ](https://leetcode.com/problems/reorder-list/)\\n[7. Maximum Product Subarray ](https://leetcode.com/problems/maximum-product-subarray/)\\n[8. Palindrome Linked List ](https://leetcode.com/problems/palindrome-linked-list/)\\n[9. Subarray Product Less Than K ](https://leetcode.com/problems/subarray-product-less-than-k/)\\n[10. Backspace String Compare ](https://leetcode.com/problems/backspace-string-compare/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nstring pushDominoes(string s) {\\n    int N = s.size(), right = -1;\\n    for (int i = 0; i < N; ++i) {\\n        if (s[i] == \\'L\\') {\\n            if (right == -1) { \\n                // Step 2\\n                for (int j = i - 1; j >= 0 && s[j] == \\'.\\'; --j) {\\n                  s[j] = \\'L\\';  \\n                } \\n            } else {\\n                // Step 8\\n                for (int j = right + 1, k = i - 1; j < k; ++j, --k) {\\n                    s[j] = \\'R\\';\\n                    s[k] = \\'L\\';\\n                } \\n                right = -1;\\n            }\\n        } else if (s[i] == \\'R\\') {\\n            if (right != -1) {\\n                for (int j = right + 1; j < i; ++j) s[j] = \\'R\\';\\n            }\\n            right = i;\\n        }\\n    }\\n    if (right != -1) {\\n        for (int j = right + 1; j < N; ++j) s[j] = \\'R\\';\\n    }\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352339,
                "title": "c-simple-and-clean-easy-to-understand-o-n-solution-with-detailed-explanation",
                "content": "**Explanation:**\\nFirst, we iterate the dominoes twice.\\n1. From left to right, we want to check which dominoes might be falling to the right side.\\n\\tSo every time we see a \\'R\\' we know that the next dominoes will maybe fall right, so we save in the \\'right\\' vector the distance from the previous \\'R\\'. (Until we reach a \\'L\\').\\n2. From right to left, we do the same for the left side.\\nExample:\\nLet\\'s use the second example from the question - \".L.R...LR..L..\".\\nThe \\'right\\' array will look like this: [0,0,0,0,1,2,3,0,0,1,2,0,0,0]\\nThe \\'left\\' array will look like this: [1,0,0,0,3,2,1,0,0,2,1,0,0,0]\\n\\nNext step is to compare \\'right and \\'left\\'.\\nFor each i:\\n1. If both are 0 - we just copy what we had in dominoes.\\n2. If right[i] is 0 but left[i] is not, it means this domino falls to the left, and vice versa.\\n3. if they are both equal, which means that we have balance of the forces and we stay vertical.\\n4. If we have to different values in right[i] and left[i], we find the minimum which means that it\\'s closer.\\n\\n**If you like it, please upvote!\\nHave any comments? I\\'d love to hear!**\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132482,
                "title": "java-one-pass-in-place-13ms",
                "content": "Keep track of last seen \\'L\\' and \\'R\\' as indices (variables L and R).\\n1. If you see \\'R\\' and R > L, you have R....R, turn everything to \\'R\\'.\\n2. If you see \\'R\\' and R < L, you have L...R and you don\\'t need to do anything.\\n3. If you see \\'L\\' and L > R, you have L....L, turn everything to \\'L\\'.\\n4. if you see \\'L\\' and L < R, you have R....L, have to pointers from both sides, lo and hi, turn a[lo]=\\'R\\' and a[hi] = \\'L\\', increment lo, decrement hi, make sure you do nothing when lo=hi\\n5. Watch out for edge cases. Note i<=dominoes.length(), this is to deal with L.. Also note L and R are initialized to -1, not 0.\\n```java\\npublic String pushDominoes(String dominoes) {\\n        char[] a = dominoes.toCharArray();\\n        for (int i = 0, L = -1, R = -1; i <= dominoes.length(); i++)\\n            if (i == a.length || a[i] == \\'R\\') {\\n                if (R > L)//R..R, turn all to R\\n                    while (R < i)\\n                        a[R++] = \\'R\\';\\n                R = i;\\n            } else if (a[i] == \\'L\\')\\n                if (L > R || R == -1)//L..L, turn all to L\\n                    while (++L < i)\\n                        a[L] = \\'L\\';\\n                else { //R...L\\n                    L = i;\\n                    for (int lo = R + 1, hi = L - 1; lo < hi; ) {//one in the middle stays \\'.\\'\\n                        a[lo++] = \\'R\\';\\n                        a[hi--] = \\'L\\';\\n                    }\\n                }\\n        return new String(a);\\n    }",
                "solutionTags": [],
                "code": "Keep track of last seen \\'L\\' and \\'R\\' as indices (variables L and R).\\n1. If you see \\'R\\' and R > L, you have R....R, turn everything to \\'R\\'.\\n2. If you see \\'R\\' and R < L, you have L...R and you don\\'t need to do anything.\\n3. If you see \\'L\\' and L > R, you have L....L, turn everything to \\'L\\'.\\n4. if you see \\'L\\' and L < R, you have R....L, have to pointers from both sides, lo and hi, turn a[lo]=\\'R\\' and a[hi] = \\'L\\', increment lo, decrement hi, make sure you do nothing when lo=hi\\n5. Watch out for edge cases. Note i<=dominoes.length(), this is to deal with L.. Also note L and R are initialized to -1, not 0.\\n```java\\npublic String pushDominoes(String dominoes) {\\n        char[] a = dominoes.toCharArray();\\n        for (int i = 0, L = -1, R = -1; i <= dominoes.length(); i++)\\n            if (i == a.length || a[i] == \\'R\\') {\\n                if (R > L)//R..R, turn all to R\\n                    while (R < i)\\n                        a[R++] = \\'R\\';\\n                R = i;\\n            } else if (a[i] == \\'L\\')\\n                if (L > R || R == -1)//L..L, turn all to L\\n                    while (++L < i)\\n                        a[L] = \\'L\\';\\n                else { //R...L\\n                    L = i;\\n                    for (int lo = R + 1, hi = L - 1; lo < hi; ) {//one in the middle stays \\'.\\'\\n                        a[lo++] = \\'R\\';\\n                        a[hi--] = \\'L\\';\\n                    }\\n                }\\n        return new String(a);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2628891,
                "title": "python3-7-lines-with-explanation-t-m-100-98",
                "content": "```\\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```\\n\\n[https://leetcode.com/submissions/detail/664004716/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132330,
                "title": "funny-idea-but-passed-within-time-limit-python",
                "content": "I think the code is self-explanatory: just imaging what would happen in each turn.\\n```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        while(True):\\n            new = dominoes.replace(\\'R.L\\', \\'S\\')\\n            new = new.replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            if new == dominoes:\\n                break\\n            else:\\n                dominoes = new\\n        return dominoes.replace(\\'S\\', \\'R.L\\')\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        while(True):\\n            new = dominoes.replace(\\'R.L\\', \\'S\\')\\n            new = new.replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            if new == dominoes:\\n                break\\n            else:\\n                dominoes = new\\n        return dominoes.replace(\\'S\\', \\'R.L\\')\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 787845,
                "title": "o-n-c-easy-solution-90",
                "content": "This is a beautiful solution, which took me some time to think. This solution is very easy to understand with the O(N) solution. \\nI have used the 2-pointer technique to solve this question.\\n**Code Implementation:**\\nLet us consider the Eg. \" . L . R . . . L R . . L . . \"\\nSo, we will iterate the string twice,\\nIn first iteration, we iterate from left to right, Therefore, when we encounter \\'R\\',  that means it will make the next domino fall towards right (If it was a \\' . \\').\\nLet us use an array to store the count of dominoes which may fall towards right,\\nAfter first Iteration, the \\'r\\' array will be \\n .  L  .  R  .  .  .  L R  .  .  L  .  . \\n0  0 0 0  1 2 3 0 0  1 2 0  0 0\\n\\nNow, in our second iteration, we travel the string from right to left, therefore, we mark all the \\' . \\'s if they have a tendency to fall towards left\\n .  L  .  R  .  .  .  L R  .  .  L  .  . \\n1  0 0 0  3 2 1 0 0  2 1 0  0 0\\n\\nSo, now, we have 2 arrays and we can compare them to get the effective direction of fall.\\nThe conditions are, \\n* If a domino doesnt fall towards Left (l[i] == 0), but falls towards Right (r[i] > 0) then it has only one direction hence it will fall towards Right, and vice versa.\\n* If we notice that both l[i] && r[i] are zero then that means it was already assigned a direction which we can get from the input string.\\n* If l[i] && r[i] have same non zero value for L and R, that means it has it its neighbouring domino falling towards it, that means it won\\'t fall, hence we will assign \\' . \\' to this.\\n* And the last case is, if l[i] > r[i] and both are non zero, then we assign the direction R(minimum value of l[i] and r[i] get the direction.)\\n\\nHappy Coding!\\n\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n    }\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int> l(n, 0), r(n, 0);\\n        char prev = \\'.\\';\\n        int count = 1;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'R\\'){\\n                prev = \\'R\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'L\\') prev = \\'L\\';\\n            if(prev == \\'R\\' && s[i] == \\'.\\') r[i] = count++;\\n        }\\n        prev = \\'.\\';\\n        count = 1;\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i] == \\'L\\'){\\n                prev = \\'L\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'R\\') prev = \\'R\\';\\n            if(prev == \\'L\\' && s[i] == \\'.\\') l[i] = count++;\\n        }\\n        string ans = \"\";\\n        for(int i=0; i<n; i++){\\n            if(!l[i] && !r[i]) ans += s[i];\\n            else if(!l[i]) ans += \\'R\\';\\n            else if(!r[i]) ans += \\'L\\';\\n            else if(l[i] == r[i]) ans += \\'.\\';\\n            else if(l[i] > r[i]) ans += \\'R\\';\\n            else ans += \\'L\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n    }\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int> l(n, 0), r(n, 0);\\n        char prev = \\'.\\';\\n        int count = 1;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'R\\'){\\n                prev = \\'R\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'L\\') prev = \\'L\\';\\n            if(prev == \\'R\\' && s[i] == \\'.\\') r[i] = count++;\\n        }\\n        prev = \\'.\\';\\n        count = 1;\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i] == \\'L\\'){\\n                prev = \\'L\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'R\\') prev = \\'R\\';\\n            if(prev == \\'L\\' && s[i] == \\'.\\') l[i] = count++;\\n        }\\n        string ans = \"\";\\n        for(int i=0; i<n; i++){\\n            if(!l[i] && !r[i]) ans += s[i];\\n            else if(!l[i]) ans += \\'R\\';\\n            else if(!r[i]) ans += \\'L\\';\\n            else if(l[i] == r[i]) ans += \\'.\\';\\n            else if(l[i] > r[i]) ans += \\'R\\';\\n            else ans += \\'L\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 132682,
                "title": "python-o-n-solution-go-through-array-twice",
                "content": "First pass, from left to right, only count distance of current index to previous \\'R\\'. Save all distance in dist array\\nSecond pass, from right to left, count distance of current index to previous \\'L\\'. If lDist < rDist (dist[i]), current cell should be \\'L\\', if lDist == rDist, current cell should be \\'.\\' \\n```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        lst = list(dominoes)\\n        dist = [0] * len(dominoes)\\n        rDist = None\\n        for i, val in enumerate(lst):\\n            if val == \\'R\\':\\n                rDist = 0\\n            elif val == \\'L\\':\\n                rDist = None\\n            elif rDist != None:\\n                rDist += 1\\n                dist[i] = rDist\\n                lst[i] = \\'R\\'\\n        lDist = None\\n        for i in range(len(lst) - 1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                lDist = 0\\n            elif dominoes[i] == \\'R\\':\\n                lDist = None\\n            elif lDist != None:\\n                lDist += 1\\n                if lDist < dist[i] or lst[i] == \\'.\\':\\n                    lst[i] = \\'L\\'\\n                elif lDist == dist[i]:\\n                    lst[i] = \\'.\\'\\n        return \\'\\'.join(lst)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        lst = list(dominoes)\\n        dist = [0] * len(dominoes)\\n        rDist = None\\n        for i, val in enumerate(lst):\\n            if val == \\'R\\':\\n                rDist = 0\\n            elif val == \\'L\\':\\n                rDist = None\\n            elif rDist != None:\\n                rDist += 1\\n                dist[i] = rDist\\n                lst[i] = \\'R\\'\\n        lDist = None\\n        for i in range(len(lst) - 1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                lDist = 0\\n            elif dominoes[i] == \\'R\\':\\n                lDist = None\\n            elif lDist != None:\\n                lDist += 1\\n                if lDist < dist[i] or lst[i] == \\'.\\':\\n                    lst[i] = \\'L\\'\\n                elif lDist == dist[i]:\\n                    lst[i] = \\'.\\'\\n        return \\'\\'.join(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352252,
                "title": "python-simulate-process-explained",
                "content": "Let us iterate through our string and keep two pointers: for positions where values not equal to `.` and the go one after another. Pointers `prev, i` can point to symbols `L` or `R` and we can have `4` different options:\\n\\n1. `L...L`, in this case, we need to fill everything with `L`\\n2. `R...R`, in this case, we need to fill everything with `R`\\n3. `L...R`, we need to keep it as it is\\n4. `R...L`, then we need to fill first half with `R` and second with `L`, handling odd and even cases.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space is `O(n)` as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def pushDominoes(self, D):\\n        D = \"L\" + D + \"R\"\\n        n, prev, ans = len(D), 0, \"\"\\n        for i in range(1, n):\\n            diff = i - prev - 1\\n            if D[i] == \".\": continue\\n            \\n            if D[i] == D[prev]:\\n                ans += D[i]*diff     \\n            elif D[i] == \"L\" and D[prev] == \"R\":\\n                m, d = divmod(diff, 2)\\n                ans += \"R\"*m + \".\"*d + \"L\"*m\\n            else:\\n                ans += \".\"*diff\\n                \\n            ans += D[i]\\n            prev = i\\n        \\n        return ans[:-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def pushDominoes(self, D):\\n        D = \"L\" + D + \"R\"\\n        n, prev, ans = len(D), 0, \"\"\\n        for i in range(1, n):\\n            diff = i - prev - 1\\n            if D[i] == \".\": continue\\n            \\n            if D[i] == D[prev]:\\n                ans += D[i]*diff     \\n            elif D[i] == \"L\" and D[prev] == \"R\":\\n                m, d = divmod(diff, 2)\\n                ans += \"R\"*m + \".\"*d + \"L\"*m\\n            else:\\n                ans += \".\"*diff\\n                \\n            ans += D[i]\\n            prev = i\\n        \\n        return ans[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347029,
                "title": "c-o-n-easy-to-write-may-the-force-be-with-you",
                "content": "We just need to consider the two closest non-period characters. \\n`left_r_dis[i]` is the smallest distance between `dominoes[i]` and its left `R`.\\n`right_l_dis[i]` is the smallest distance between `dominoes[i]` and its right `L`.\\n```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left_r_dis(n + 1, 0);\\n        vector<int> right_l_dis(n + 1, 0);\\n        int r_pos = n + 1;\\n        for (int i = 0; i < n; ++i) {\\n            if (dominoes[i] == \\'R\\') {\\n                r_pos = i;\\n            }\\n            else if (dominoes[i] == \\'L\\') {\\n                r_pos = n + 1;\\n            }\\n            left_r_dis[i] = r_pos == n + 1 ? n + 1 : i - r_pos;\\n        }\\n        int l_pos = -1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (dominoes[i] == \\'L\\') {\\n                l_pos = i;\\n            }\\n            else if (dominoes[i] == \\'R\\') {\\n                l_pos = -1;\\n            }\\n            right_l_dis[i] = l_pos == -1 ? n + 1 : l_pos - i;\\n        }\\n        \\n        string result = dominoes;\\n        for (int i = 0; i < n; ++i) {\\n            if (left_r_dis[i] < right_l_dis[i]) result[i] = \\'R\\';\\n            else if (left_r_dis[i] > right_l_dis[i]) result[i] = \\'L\\';\\n            //else\\n        }\\n\\n        return result;\\n    } \\n};\\n```\\n\\n// It is quite like the problem [Leetcode] container with most water.\\nThey are all first consider one element in the array.",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left_r_dis(n + 1, 0);\\n        vector<int> right_l_dis(n + 1, 0);\\n        int r_pos = n + 1;\\n        for (int i = 0; i < n; ++i) {\\n            if (dominoes[i] == \\'R\\') {\\n                r_pos = i;\\n            }\\n            else if (dominoes[i] == \\'L\\') {\\n                r_pos = n + 1;\\n            }\\n            left_r_dis[i] = r_pos == n + 1 ? n + 1 : i - r_pos;\\n        }\\n        int l_pos = -1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (dominoes[i] == \\'L\\') {\\n                l_pos = i;\\n            }\\n            else if (dominoes[i] == \\'R\\') {\\n                l_pos = -1;\\n            }\\n            right_l_dis[i] = l_pos == -1 ? n + 1 : l_pos - i;\\n        }\\n        \\n        string result = dominoes;\\n        for (int i = 0; i < n; ++i) {\\n            if (left_r_dis[i] < right_l_dis[i]) result[i] = \\'R\\';\\n            else if (left_r_dis[i] > right_l_dis[i]) result[i] = \\'L\\';\\n            //else\\n        }\\n\\n        return result;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630335,
                "title": "4-cases-stupidly-simple",
                "content": "**So, there are 4 cases:**\\n* **LL:** everything in between will be \\'L\\' |  **<-L . . . <-L**\\n* **RR:** everything in between will be \\'R\\' |  **R-> . . . R->** \\n* **LR:** everything in between will be \\'.\\' | **<-L . . . R->**\\n* **RL:**  they will `meet in the middle` |  **R-> . . . <-L**\\n*[ in case of RL, if the count of \\'.\\'s was odd, the middle element will be `\\'.\\'` ]*\\n\\n**Code:**\\n\\n    StringBuilder sb = new StringBuilder();\\n    public String pushDominoes(String dominoes) {\\n        int count = 0; char last = \\'L\\';\\n        for(char ch : dominoes.toCharArray()){\\n            if(ch!=\\'.\\'){\\n\\t\\t\\t\\tif(ch==last) add(count, last);             // case LL & RR\\n\\t\\t\\t\\telse if(last==\\'L\\') add(count, \\'.\\');  // case LR\\n\\t\\t\\t\\telse {                                     // case RL\\n\\t\\t\\t\\t\\tadd(count/2, \\'R\\');\\n\\t\\t\\t\\t\\tif(count%2!=0) sb.append(\\'.\\');\\n\\t\\t\\t\\t\\tadd(count/2, \\'L\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t\\tlast = ch; count = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse count++;\\n        }\\n        add(count, last==\\'R\\'?\\'R\\':\\'.\\');  // for trailing \\'.\\'s\\n        return sb.toString();\\n    }\\n    \\n    void add(int count, char ch){  // append \\'ch\\' to sb \\'count\\' times\\n        for(int i=0; i<count; i++) sb.append(ch);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "**So, there are 4 cases:**\\n* **LL:** everything in between will be \\'L\\' |  **<-L . . . <-L**\\n* **RR:** everything in between will be \\'R\\' |  **R-> . . . R->** \\n* **LR:** everything in between will be \\'.\\' | **<-L . . . R->**\\n* **RL:**  they will `meet in the middle` |  **R-> . . . <-L**\\n*[ in case of RL, if the count of \\'.\\'s was odd, the middle element will be `\\'.\\'` ]*\\n\\n**Code:**\\n\\n    StringBuilder sb = new StringBuilder();\\n    public String pushDominoes(String dominoes) {\\n        int count = 0; char last = \\'L\\';\\n        for(char ch : dominoes.toCharArray()){\\n            if(ch!=\\'.\\'){\\n\\t\\t\\t\\tif(ch==last) add(count, last);             // case LL & RR\\n\\t\\t\\t\\telse if(last==\\'L\\') add(count, \\'.\\');  // case LR\\n\\t\\t\\t\\telse {                                     // case RL\\n\\t\\t\\t\\t\\tadd(count/2, \\'R\\');\\n\\t\\t\\t\\t\\tif(count%2!=0) sb.append(\\'.\\');\\n\\t\\t\\t\\t\\tadd(count/2, \\'L\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t\\tlast = ch; count = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse count++;\\n        }\\n        add(count, last==\\'R\\'?\\'R\\':\\'.\\');  // for trailing \\'.\\'s\\n        return sb.toString();\\n    }\\n    \\n    void add(int count, char ch){  // append \\'ch\\' to sb \\'count\\' times\\n        for(int i=0; i<count; i++) sb.append(ch);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1352325,
                "title": "push-dominoes-2-approaches-easy-understanding",
                "content": "# Approach #1: Adjacent Symbols\\nBetween *every group* of vertical dominoes ( `\\'.\\'` ), we have up to two non-vertical dominoes bordering this group. Since additional dominoes outside this group do not affect the outcome, we can analyze these situations individually: *there are 9 of them* (as the border could be empty). \\nAnd, if we border the dominoes by `\\'L\\'` and `\\'R\\'`, there are only 4 cases. \\nWe\\'ll write new letters between these symbols depending on each case.\\n\\n**Algorithm**\\n* If we have say `\"A....B\"`, where A = B, then we should write `\"AAAAAA\"`.\\n* If we have `\"R....L\"`, then we will write `\"RRRLLL\"`, or `\"RRR.LLL\"` if we have an odd number of dots. If the initial symbols are at positions `i` and `j`, we can check our distance `k-i` and `j-k` to decide at position k whether to write `\\'L\\'`, `\\'R\\'`, or `\\'.\\'`.\\n* If we have `\"L....R\"` we don\\'t do anything. We can `skip` this case.\\n\\n**Solution In Java** *(Let Me Know in the comments if you want the code in C++)*\\n```\\n public String pushDominoes(String dominoes) {\\n        int N = dominoes.length();\\n        int[] indexes = new int[N+2];\\n        char[] symbols = new char[N+2];\\n        int len = 1;\\n        indexes[0] = -1;\\n        symbols[0] = \\'L\\';\\n\\n        for (int i = 0; i < N; ++i)\\n            if (dominoes.charAt(i) != \\'.\\') {\\n                indexes[len] = i;\\n                symbols[len++] = dominoes.charAt(i);\\n            }\\n\\n        indexes[len] = N;\\n        symbols[len++] = \\'R\\';\\n\\n        char[] ans = dominoes.toCharArray();\\n        for (int index = 0; index < len - 1; ++index) {\\n            int i = indexes[index], j = indexes[index+1];\\n            char x = symbols[index], y = symbols[index+1];\\n            char write;\\n            if (x == y) {\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = x;\\n            } else if (x > y) { // RL\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = k-i == j-k ? \\'.\\' : k-i < j-k ? \\'R\\' : \\'L\\';\\n            }\\n        }\\n\\n        return String.valueOf(ans);\\n    }\\n```\\n\\n# Approach #2: Calculate Force\\nWe can calculate the net force applied on every domino. The forces we care about are how close a domino is to a leftward `R\\'`, and to a rightward `\\'L\\'`: the closer we are, the stronger the force.\\n\\n**Algorithm**\\n1. Scanning from left to right, our force decays by 1 every iteration, and resets to `N` if we meet an `\\'R\\'`, so that `force[i]` is *higher* (than `force[j]`) if and only if `dominoes[i]` is closer (looking leftward) to `\\'R\\'` (than `dominoes[j]`).\\n2. Similarly, scanning from right to left, we can find the force going rightward (closeness to `\\'L\\'`).\\n3. For some domino `answer[i]`, if the forces are equal, then the answer is `\\'.\\'`. Otherwise, the answer is implied by whichever force is stronger.\\n\\n**Solution In Java** *(Let Me Know in the comments if you want the code in C++)*\\n```\\npublic String pushDominoes(String S) {\\n        char[] A = S.toCharArray();\\n        int N = A.length;\\n        int[] forces = new int[N];\\n\\n        int force = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (A[i] == \\'R\\') force = N;\\n            else if (A[i] == \\'L\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n\\n        force = 0;\\n        for (int i = N-1; i >= 0; --i) {\\n            if (A[i] == \\'L\\') force = N;\\n            else if (A[i] == \\'R\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int f: forces)\\n            ans.append(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        return ans.toString();\\n    }\\n```\\n\\n**Solution In C++**\\n```\\nclass Solution {\\n\\tpublic: \\n\\t\\tString pushDominoes(String S) {\\n\\t\\tstring res = \"\" ;\\n\\t\\tint n = S.length( ) , f = 0 ;\\n\\t\\tint ans[n] ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            ans[i] = 0 ;\\n        }\\n\\t\\tfor(int i=0;i < n;i++)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = n ;\\n\\t\\t\\telse if(S[i]==\\'L\\') \\n\\t\\t\\t\\tf = 0 ;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1)>0 ? (f - 1) : 0 ;\\n\\t\\t\\tans[i] += f ;\\n\\t\\t}\\n\\t\\tf = 0 ;\\n\\t\\tfor(int i = n - 1 ; i >= 0 ; i--)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'L\\')\\n\\t\\t\\t\\tf = n;\\n\\t\\t\\telse if(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = 0;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1) > 0 ? (f-1) : 0 ;\\n\\t\\t\\tans[i] -= f ;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0 ; i < n ; i++) \\n\\t\\t\\tres += ans[i] < 0 ? \"L\" : ans[i] > 0 ?\"R\":\".\";\\n\\t\\treturn res ;\\n}\\n```\\nDo let me know any other approaches that come to your mind!",
                "solutionTags": [],
                "code": "```\\n public String pushDominoes(String dominoes) {\\n        int N = dominoes.length();\\n        int[] indexes = new int[N+2];\\n        char[] symbols = new char[N+2];\\n        int len = 1;\\n        indexes[0] = -1;\\n        symbols[0] = \\'L\\';\\n\\n        for (int i = 0; i < N; ++i)\\n            if (dominoes.charAt(i) != \\'.\\') {\\n                indexes[len] = i;\\n                symbols[len++] = dominoes.charAt(i);\\n            }\\n\\n        indexes[len] = N;\\n        symbols[len++] = \\'R\\';\\n\\n        char[] ans = dominoes.toCharArray();\\n        for (int index = 0; index < len - 1; ++index) {\\n            int i = indexes[index], j = indexes[index+1];\\n            char x = symbols[index], y = symbols[index+1];\\n            char write;\\n            if (x == y) {\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = x;\\n            } else if (x > y) { // RL\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = k-i == j-k ? \\'.\\' : k-i < j-k ? \\'R\\' : \\'L\\';\\n            }\\n        }\\n\\n        return String.valueOf(ans);\\n    }\\n```\n```\\npublic String pushDominoes(String S) {\\n        char[] A = S.toCharArray();\\n        int N = A.length;\\n        int[] forces = new int[N];\\n\\n        int force = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (A[i] == \\'R\\') force = N;\\n            else if (A[i] == \\'L\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n\\n        force = 0;\\n        for (int i = N-1; i >= 0; --i) {\\n            if (A[i] == \\'L\\') force = N;\\n            else if (A[i] == \\'R\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int f: forces)\\n            ans.append(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        return ans.toString();\\n    }\\n```\n```\\nclass Solution {\\n\\tpublic: \\n\\t\\tString pushDominoes(String S) {\\n\\t\\tstring res = \"\" ;\\n\\t\\tint n = S.length( ) , f = 0 ;\\n\\t\\tint ans[n] ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            ans[i] = 0 ;\\n        }\\n\\t\\tfor(int i=0;i < n;i++)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = n ;\\n\\t\\t\\telse if(S[i]==\\'L\\') \\n\\t\\t\\t\\tf = 0 ;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1)>0 ? (f - 1) : 0 ;\\n\\t\\t\\tans[i] += f ;\\n\\t\\t}\\n\\t\\tf = 0 ;\\n\\t\\tfor(int i = n - 1 ; i >= 0 ; i--)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'L\\')\\n\\t\\t\\t\\tf = n;\\n\\t\\t\\telse if(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = 0;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1) > 0 ? (f-1) : 0 ;\\n\\t\\t\\tans[i] -= f ;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0 ; i < n ; i++) \\n\\t\\t\\tres += ans[i] < 0 ? \"L\" : ans[i] > 0 ?\"R\":\".\";\\n\\t\\treturn res ;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119158,
                "title": "java-easy-solution",
                "content": "**Idea:**\\nusing two pointer left and right\\nthere are **4 Possible Cases** that left and right are Pointing to : \\n1.  **L  and. L** (all in between dominos will fall on left side) So mark all dominos to L from left to right \\n2. **L and R** (left pointer will fall to left and right to right so dominos in between will be as they were before) \\n3.  **R and L** (from left side dominos will start falling to right and from right side dominos will fall down to left )\\n4.  **R and R** (all in b/w dominos will fall in right side) So mark all dominos to R from left to right\\n\\nyou have someIdea now . Code will give you more clearity.\\n\\n**Complexity :**\\n```\\nTime : O(n)\\nSpace: O(n)\\n```\\n\\n```\\n    public String pushDominoes(String dominoes) {\\n        \\n        char[] arr=new char[dominoes.length()+2];\\n        arr[0]=\\'L\\';\\n        arr[arr.length-1]=\\'R\\';\\n        for(int i=1;i<arr.length-1;i++){\\n            arr[i]=dominoes.charAt(i-1);\\n        }\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(j!=arr.length){\\n            while(arr[j]==\\'.\\') j++;\\n            \\n            if(arr[i]==\\'L\\' && arr[j]==\\'L\\'){\\n                while(i!=j){\\n                    arr[i]=\\'L\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'L\\' && arr[j]==\\'R\\'){\\n                 i=j;\\n                 j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'R\\'){\\n                while(i!=j){\\n                    arr[i]=\\'R\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'L\\'){\\n                 int temp1=i+1;\\n                 int temp2=j-1;\\n                 while(temp1<temp2){\\n                     arr[temp1]=\\'R\\';\\n                     arr[temp2]=\\'L\\';\\n                     temp1++;\\n                     temp2--;\\n                 }\\n                i=j;\\n                j++;\\n            }\\n        }\\n        \\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(i=1;i<arr.length-1;i++){\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n```\\nPlease **UPVOTE** if found it helpful:)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nTime : O(n)\\nSpace: O(n)\\n```\n```\\n    public String pushDominoes(String dominoes) {\\n        \\n        char[] arr=new char[dominoes.length()+2];\\n        arr[0]=\\'L\\';\\n        arr[arr.length-1]=\\'R\\';\\n        for(int i=1;i<arr.length-1;i++){\\n            arr[i]=dominoes.charAt(i-1);\\n        }\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(j!=arr.length){\\n            while(arr[j]==\\'.\\') j++;\\n            \\n            if(arr[i]==\\'L\\' && arr[j]==\\'L\\'){\\n                while(i!=j){\\n                    arr[i]=\\'L\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'L\\' && arr[j]==\\'R\\'){\\n                 i=j;\\n                 j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'R\\'){\\n                while(i!=j){\\n                    arr[i]=\\'R\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'L\\'){\\n                 int temp1=i+1;\\n                 int temp2=j-1;\\n                 while(temp1<temp2){\\n                     arr[temp1]=\\'R\\';\\n                     arr[temp2]=\\'L\\';\\n                     temp1++;\\n                     temp2--;\\n                 }\\n                i=j;\\n                j++;\\n            }\\n        }\\n        \\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(i=1;i<arr.length-1;i++){\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132520,
                "title": "java-one-pass-no-extra-storage-detailed-explanation",
                "content": "    class Solution {\\n        public String pushDominoes(String dominoes) {\\n            // algorithm 2018/05/20: playing with a few samples, it is easy to find the rule\\n            // if there is NO dot (meaning every domino is pushed), then the final state is the initial state\\n            //   for example, all \"LLL\" => \"LLL\", all \"RRR\" => \"RRR\",\\n            //                mixed \"LLLRR\" => \"LLLRR\" (falling domino having no effect on already-fallen domino)\\n            // if there is only ONE dot, we have a few possibilities:\\n            //   \"L.R\" => \"L.R\", \"R.L\" => \"R.L\" (center-one standing), \"L.L\" => \"LLL\", \"R.R\" => \"RRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L..R\" => \"L..R\", \"R..L\" => \"RRLL\" (center-one standing), \"L..L\" => \"LLLL\", \"R..R\" => \"RRRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L...R\" => \"L...R\", \"R...L\" => \"RR.LL\" (center-one standing), \"L...L\" => \"LLLLL\", \"R...R\" => \"RRRRR\"\\n            // Therefore the rule is:\\n            // for each region of dots (a substring \"P....Q\"), check its left and right\\n            //   if left is \"L\" and right is \"R\", the substring remains as is;\\n            //   if left is \"R\" and right is \"L\", the substring is converted into either \"RRRLLL\" or \"RR.LL\"\\n            //   if left and right are the same, the substring is converted into either \"RRRRR\" or \"LLLLL\"\\n\\n            assert (null != dominoes);\\n            // place a sentinel \"L\" + dominoes + \"R\", as this does not impact the final outcome\\n            dominoes = \"L\" + dominoes + \"R\";\\n\\n            // stringbuilder to hold the result\\n            StringBuilder builder = new StringBuilder();\\n\\n            // scan the string and split it into multiple groups, |groupStart, groupEnd| ... |groupStart, groupEnd| ...\\n            // \\'groupStart\\' and \\'groupEnd\\' designates a number of chars solely with \\'L\\' or \\'R\\'\\n            int strLen = dominoes.length();\\n            int groupStart = 0;\\n            int index = 0;      //\\n            while (index < strLen) {\\n                while (index < strLen && \\'.\\' != dominoes.charAt(index)) {\\n                    index++;\\n                }\\n                int groupEnd = index - 1;\\n                char leftCharForDotRegion = dominoes.charAt(groupEnd);\\n\\n                // copy this part of susbtring as is (no DOT in the middle)\\n                builder.append(dominoes.substring(groupStart, groupEnd + 1));\\n\\n                // either we reach the end of the string or we find a dot\\n                if (index == strLen) {\\n                    // final section with only \\'L\\'s and \\'R\\'s\\n                    break;\\n                }\\n\\n                // now we meet a DOT; scan until we meet the next \"L\" or \"R\"\\n                while (\\'.\\' == dominoes.charAt(index)) {\\n                    index++;        // we have the sentinel \"R\", so this will not reach the end of string\\n                }\\n                char rightCharForDotRegion = dominoes.charAt(index);\\n\\n                if (leftCharForDotRegion == rightCharForDotRegion) {\\n                    // replace dot with the same char\\n                    for (int count = 0; count < index - groupEnd - 1; count++) {\\n                        builder.append(leftCharForDotRegion);\\n                    }\\n                } else if (\\'L\\' == leftCharForDotRegion) {\\n                    // rightChar is \\'R\\', then keep the dots as it\\n                    for (int count = 0; count < index - groupEnd - 1; count++) {\\n                        builder.append(\\'.\\');\\n                    }\\n                } else {\\n                    // leftChar is \\'R\\' and right char is \\'L\\', we either have a SINGLE dot in the middle, or not dot\\n                    int countDots = index - groupEnd - 1;\\n                    // half R\\n                    for (int count = 0; count < countDots / 2; count++) {\\n                        builder.append(\\'R\\');\\n                    }\\n                    if (1 == countDots % 2) {\\n                        // center dot\\n                        builder.append(\\'.\\');\\n                    }\\n                    // half L\\n                    for (int count = 0; count < countDots / 2; count++) {\\n                        builder.append(\\'L\\');\\n                    }\\n                }\\n\\n                // now scan next group\\n                groupStart = index;\\n\\n            }\\n\\n            String result = builder.toString();\\n            return result.substring(1, strLen - 1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String pushDominoes(String dominoes) {\\n            // algorithm 2018/05/20: playing with a few samples, it is easy to find the rule\\n            // if there is NO dot (meaning every domino is pushed), then the final state is the initial state\\n            //   for example, all \"LLL\" => \"LLL\", all \"RRR\" => \"RRR\",\\n            //                mixed \"LLLRR\" => \"LLLRR\" (falling domino having no effect on already-fallen domino)\\n            // if there is only ONE dot, we have a few possibilities:\\n            //   \"L.R\" => \"L.R\", \"R.L\" => \"R.L\" (center-one standing), \"L.L\" => \"LLL\", \"R.R\" => \"RRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L..R\" => \"L..R\", \"R..L\" => \"RRLL\" (center-one standing), \"L..L\" => \"LLLL\", \"R..R\" => \"RRRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L...R\" => \"L...R\", \"R...L\" => \"RR.LL\" (center-one standing), \"L...L\" => \"LLLLL\", \"R...R\" => \"RRRRR\"\\n            // Therefore the rule is:\\n            // for each region of dots (a substring \"P....Q\"), check its left and right\\n            //   if left is \"L\" and right is \"R\", the substring remains as is;\\n            //   if left is \"R\" and right is \"L\", the substring is converted into either \"RRRLLL\" or \"RR.LL\"\\n            //   if left and right are the same, the substring is converted into either \"RRRRR\" or \"LLLLL\"\\n\\n            assert (null != dominoes);\\n            // place a sentinel \"L\" + dominoes + \"R\", as this does not impact the final outcome\\n            dominoes = \"L\" + dominoes + \"R\";\\n\\n            // stringbuilder to hold the result\\n            StringBuilder builder = new StringBuilder();\\n\\n            // scan the string and split it into multiple groups, |groupStart, groupEnd| ... |groupStart, groupEnd| ...\\n            // \\'groupStart\\' and \\'groupEnd\\' designates a number of chars solely with \\'L\\' or \\'R\\'\\n            int strLen = dominoes.length();\\n            int groupStart = 0;\\n            int index = 0;      //\\n            while (index < strLen) {\\n                while (index < strLen && \\'.\\' != dominoes.charAt(index)) {\\n                    index++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2628946,
                "title": "java-easy-solution-with-comments-89-faster-code-stringbuilder",
                "content": "\\t\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629157,
                "title": "c-2-pointers-short-simple",
                "content": "***DO UPVOTE IF IT HELPS !!!!!!***\\t\\n\\n\\t\\n\\tstring pushDominoes(string s) {\\n        \\n        int n = s.size();\\n        int r=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'L\\'){                                 \\n                if(r==-1){                                  //s[i]==\\'L\\' && r==-1\\n                    for(int j=i-1;j>=0 && s[j]==\\'.\\';j--){   //update all dominoes to left beginning from j=i-1 to j>=0\\n                        s[j]=\\'L\\';\\n                    }\\n                }\\n                else{                                      //s[i]==\\'L\\' && r!=-1\\n                    for(int j=r+1,k=i-1;j<k;j++,k--){      //update all dominoes lying between k=r+1 and j=i-1\\n                        s[j]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                    }\\n                    r=-1;        //important step update r = -1\\n                }\\n            }\\n            else if(s[i]==\\'R\\'){                            //s[i]==\\'R\\' && r!=-1\\n                if(r!=-1){                                 //update all dominoes lying right to j=r+1 till i\\n                    for(int j=r+1;j<i;j++){\\n                        s[j]=\\'R\\';\\n                    }\\n                }\\n                r=i;             //update r since r is found\\n            }\\n        }\\n        \\n        if(r!=-1){                     //if you have traversed complete string and r!=-1, then update all dominoes\\n            for(int j=r+1;j<n;j++) {   //beginning from r+1 to n to \\'R\\'\\n                s[j]=\\'R\\';\\n            }\\n        }\\n        \\n        return s;   \\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!!***\\t\\n\\n\\t\\n\\tstring pushDominoes(string s) {\\n        \\n        int n = s.size();\\n        int r=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'L\\'){                                 \\n                if(r==-1){                                  //s[i]==\\'L\\' && r==-1\\n                    for(int j=i-1;j>=0 && s[j]==\\'.\\';j--){   //update all dominoes to left beginning from j=i-1 to j>=0\\n                        s[j]=\\'L\\';\\n                    }\\n                }\\n                else{                                      //s[i]==\\'L\\' && r!=-1\\n                    for(int j=r+1,k=i-1;j<k;j++,k--){      //update all dominoes lying between k=r+1 and j=i-1\\n                        s[j]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                    }\\n                    r=-1;        //important step update r = -1\\n                }\\n            }\\n            else if(s[i]==\\'R\\'){                            //s[i]==\\'R\\' && r!=-1\\n                if(r!=-1){                                 //update all dominoes lying right to j=r+1 till i\\n                    for(int j=r+1;j<i;j++){\\n                        s[j]=\\'R\\';\\n                    }\\n                }\\n                r=i;             //update r since r is found\\n            }\\n        }\\n        \\n        if(r!=-1){                     //if you have traversed complete string and r!=-1, then update all dominoes\\n            for(int j=r+1;j<n;j++) {   //beginning from r+1 to n to \\'R\\'\\n                s[j]=\\'R\\';\\n            }\\n        }\\n        \\n        return s;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1352251,
                "title": "python-java-one-pass-time-complexity-of-o-n-in-constant-space",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = \"\" #Used to store final result.\\n        i=0\\n        while(i<len(dominoes)):\\n            #if charAt(i) is \\'L\\' or \\'R\\', just place append the same in res.\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                res+=dominoes[i]\\n                i+=1\\n            else:# dominoes[i]==\\'.\\':\\n                #if charAt(i) is \\'.\\' and previous is Right pushed then, we have to count the\\n\\t\\t\\t\\t#number of \\'.\\' (dots) and see what is at the other end of dot. \\n                if i>0 and dominoes[i-1]==\\'R\\':\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count of number of \\'.\\'(dots)\\n                    #if the other end is last index or if dominoe at other end is right pushed then\\n\\t\\t\\t\\t\\t#there is nothing to cancel the right pushed force of first dominoes and so all\\n\\t\\t\\t\\t\\t#\\'.\\'(dots) will be rightly pushed\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'R\\'*countDots\\n                    else:#if other end is \\'L\\' i.e, left pushed\\n                    #first half will be rightly pushed and second half is leftly pushed and\\n\\t\\t\\t\\t\\t#if count is odd, then force on middle one gets cancelled\\n                        res+=\\'R\\'*(countDots//2) + \\'.\\'*(countDots-2*(countDots//2)) + \\'L\\'*(countDots//2)\\n                    i=j\\n                else: #if the start of string is \\'.\\'(dot) or previous is not rightly pushed\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count the number of dots\\n                    \\n                    #if the other end is last index or if dominoe at other end is right pushed\\n\\t\\t\\t\\t\\t#then there is no force at all on stating indexes. So, all will remains \\'.\\'\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'.\\'*countDots\\n                    #if other end is left pushed, the all the starting will be pushed left\\n                    else:\\n                        res+=\\'L\\'*countDots\\n                    i=j\\n        \\n        return res\\n```\\n\\n\\n\\nJava solution of above Code:\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        String res = \"\", intermediate=\"\", intermediateDots=\"\";\\n        int i = 0, j;\\n        int length = dominoes.length();\\n        while(i<length){\\n            char ch = dominoes.charAt(i);\\n            if (ch==\\'L\\' || ch==\\'R\\')\\n            {   res += Character.toString(ch);\\n                i++;}\\n            else{\\n                if(i>0 && dominoes.charAt(i-1)==\\'R\\'){\\n                    j=i;\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediate+=\"R\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediate;\\n                    else\\n                        res += \"R\".repeat(count/2) + \".\".repeat(count-2*(count/2)) + \"L\".repeat(count/2);\\n                    i=j;\\n                }\\n                else{\\n                    j=i;\\n                    intermediateDots=\"\";\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediateDots+=\".\";\\n                        intermediate+=\"L\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediateDots;\\n                    else\\n                        res += intermediate;\\n                    i=j;\\n                }\\n            }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = \"\" #Used to store final result.\\n        i=0\\n        while(i<len(dominoes)):\\n            #if charAt(i) is \\'L\\' or \\'R\\', just place append the same in res.\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                res+=dominoes[i]\\n                i+=1\\n            else:# dominoes[i]==\\'.\\':\\n                #if charAt(i) is \\'.\\' and previous is Right pushed then, we have to count the\\n\\t\\t\\t\\t#number of \\'.\\' (dots) and see what is at the other end of dot. \\n                if i>0 and dominoes[i-1]==\\'R\\':\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count of number of \\'.\\'(dots)\\n                    #if the other end is last index or if dominoe at other end is right pushed then\\n\\t\\t\\t\\t\\t#there is nothing to cancel the right pushed force of first dominoes and so all\\n\\t\\t\\t\\t\\t#\\'.\\'(dots) will be rightly pushed\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'R\\'*countDots\\n                    else:#if other end is \\'L\\' i.e, left pushed\\n                    #first half will be rightly pushed and second half is leftly pushed and\\n\\t\\t\\t\\t\\t#if count is odd, then force on middle one gets cancelled\\n                        res+=\\'R\\'*(countDots//2) + \\'.\\'*(countDots-2*(countDots//2)) + \\'L\\'*(countDots//2)\\n                    i=j\\n                else: #if the start of string is \\'.\\'(dot) or previous is not rightly pushed\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count the number of dots\\n                    \\n                    #if the other end is last index or if dominoe at other end is right pushed\\n\\t\\t\\t\\t\\t#then there is no force at all on stating indexes. So, all will remains \\'.\\'\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'.\\'*countDots\\n                    #if other end is left pushed, the all the starting will be pushed left\\n                    else:\\n                        res+=\\'L\\'*countDots\\n                    i=j\\n        \\n        return res\\n```\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        String res = \"\", intermediate=\"\", intermediateDots=\"\";\\n        int i = 0, j;\\n        int length = dominoes.length();\\n        while(i<length){\\n            char ch = dominoes.charAt(i);\\n            if (ch==\\'L\\' || ch==\\'R\\')\\n            {   res += Character.toString(ch);\\n                i++;}\\n            else{\\n                if(i>0 && dominoes.charAt(i-1)==\\'R\\'){\\n                    j=i;\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediate+=\"R\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediate;\\n                    else\\n                        res += \"R\".repeat(count/2) + \".\".repeat(count-2*(count/2)) + \"L\".repeat(count/2);\\n                    i=j;\\n                }\\n                else{\\n                    j=i;\\n                    intermediateDots=\"\";\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediateDots+=\".\";\\n                        intermediate+=\"L\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediateDots;\\n                    else\\n                        res += intermediate;\\n                    i=j;\\n                }\\n            }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858300,
                "title": "javascript-2-pointers",
                "content": "```\\nvar pushDominoes = function(dominoes) {\\n    let l=0, r=1;\\n    const arr = (\"L\"+dominoes+\"R\").split(\"\");\\n    while(l<arr.length-1){\\n        while(arr[r]==\\'.\\') \\n            r++;\\n        if(arr[l]==arr[r]) \\n            for(let i=l+1; i<r; i++) \\n                arr[i]=arr[l];\\n        if(arr[l]>arr[r]) \\n            for(let i=1; i<=(r-l-1)/2; i++){\\n                arr[l+i] = \\'R\\';\\n                arr[r-i] = \\'L\\';\\n            }   \\n        l=r++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pushDominoes = function(dominoes) {\\n    let l=0, r=1;\\n    const arr = (\"L\"+dominoes+\"R\").split(\"\");\\n    while(l<arr.length-1){\\n        while(arr[r]==\\'.\\') \\n            r++;\\n        if(arr[l]==arr[r]) \\n            for(let i=l+1; i<r; i++) \\n                arr[i]=arr[l];\\n        if(arr[l]>arr[r]) \\n            for(let i=1; i<=(r-l-1)/2; i++){\\n                arr[l+i] = \\'R\\';\\n                arr[r-i] = \\'L\\';\\n            }   \\n        l=r++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466596,
                "title": "intuitive-python-solution-sliding-window-0-n",
                "content": "A lot of the other python solutions are a bit hard to wrap your mind around. This one felt fairly intuitive, it has a few parts:\\n\\nwe will use a sliding window approach, where we attempt to create a window that needs to be \"filled\" with appropriate values. Some examples of these windows are:\\n\"L...R\" -> \"L...R\"\\n\"R...L\" -> \"RR.LL\"\\n\"....L\" -> \"LLLLL\"\\n\"R....\" -> \"RRRRR\"\\n\\nWith those examples in mind, there are really only a few cases we need to deal with. They are:\\n\\n\\t1. we create a window that needs to be filled. If this is the case, there are a few things to consider:\\n\\t\\t- the window is of the form \"R...L\" -> fill while LO and HI pointers move toward each other\\n\\t\\t- the window is of the form \"....L\" -> fill totally with L\\n\\t\\t- the window is of the form \"R....\" -> fill totally with R\\n\\n\\t2. we create a window that has no change. (EX. \"L....R\", or \"....R\", or \"L....\")\\n\\n\\ndefining a do_fill function to fill our dominoes array keeps the main method concise. Also, LO and HI values are copied into the do_fill function, so we don\\'t have to reset them in our main while loop.\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        lo, hi = 0, 0\\n        d = list(dominoes)\\n        chk = {\"L\", \"R\"}\\n        while hi < len(d):\\n\\t\\t   #window needs to be filled or we might have a postfix like \"R....\", so fill it\\n            if d[hi] in chk or hi == len(d)-1:\\n                self.do_fill(lo, hi, d)\\n                lo=hi\\n            hi+=1\\n            \\n        return \"\".join(d)\\n    \\n    def do_fill(self, lo, hi, d):\\n        if d[hi] == \"L\":\\n            if d[lo] == \"R\":\\n\\t\\t\\t    #window is Rs from the left and Ls from the right\\n                while lo < hi:\\n                    d[lo] = \"R\"\\n                    d[hi] = \"L\"\\n                    lo+=1\\n                    hi-=1\\n            else:\\n\\t\\t\\t   #window is completely L\\n                while lo <= hi:\\n                    d[lo] = \"L\"\\n                    lo+=1                 \\n        elif d[lo] == \"R\":\\n\\t\\t\\t\\t#window is completely R\\n                while lo <= hi:\\n                    d[lo] = \"R\"\\n                    lo+=1  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        lo, hi = 0, 0\\n        d = list(dominoes)\\n        chk = {\"L\", \"R\"}\\n        while hi < len(d):\\n\\t\\t   #window needs to be filled or we might have a postfix like \"R....\", so fill it\\n            if d[hi] in chk or hi == len(d)-1:\\n                self.do_fill(lo, hi, d)\\n                lo=hi\\n            hi+=1\\n            \\n        return \"\".join(d)\\n    \\n    def do_fill(self, lo, hi, d):\\n        if d[hi] == \"L\":\\n            if d[lo] == \"R\":\\n\\t\\t\\t    #window is Rs from the left and Ls from the right\\n                while lo < hi:\\n                    d[lo] = \"R\"\\n                    d[hi] = \"L\"\\n                    lo+=1\\n                    hi-=1\\n            else:\\n\\t\\t\\t   #window is completely L\\n                while lo <= hi:\\n                    d[lo] = \"L\"\\n                    lo+=1                 \\n        elif d[lo] == \"R\":\\n\\t\\t\\t\\t#window is completely R\\n                while lo <= hi:\\n                    d[lo] = \"R\"\\n                    lo+=1  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352147,
                "title": "fastest-o-n-solution-c-well-explained",
                "content": "1. Just keep a track of nearest left in left array and nearest right in right array\\n2. The one which is smaller will have more influence on that point \\n3. If both are equal it implies no  change to that domino\\n```\\nstring pushDominoes(string dominoes) {\\n\\n\\tint n=dominoes.size();\\n\\tvector<int> left(n);\\n\\tvector<int> right(n);\\n\\n\\tint k=-1;\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tif(dominoes[i]==\\'R\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tright[i]=k;\\n\\t}\\n\\n\\t for(int i=n-1;i>=0;i--){\\n\\t\\tif(dominoes[i]==\\'L\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tleft[i]=k;\\n\\t}\\n\\tstring ans=\"\";\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t  if(left[i]==-1 && right[i]==-1)\\n\\t\\t  ans.push_back(\\'.\\');\\n\\t  else if(left[i]==-1)  \\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]==-1)  \\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]<left[i])\\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]>left[i])\\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]==left[i])\\n\\t\\t  ans.push_back(\\'.\\');  \\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\nIf this solution helps, Do Upvote !",
                "solutionTags": [],
                "code": "```\\nstring pushDominoes(string dominoes) {\\n\\n\\tint n=dominoes.size();\\n\\tvector<int> left(n);\\n\\tvector<int> right(n);\\n\\n\\tint k=-1;\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tif(dominoes[i]==\\'R\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tright[i]=k;\\n\\t}\\n\\n\\t for(int i=n-1;i>=0;i--){\\n\\t\\tif(dominoes[i]==\\'L\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tleft[i]=k;\\n\\t}\\n\\tstring ans=\"\";\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t  if(left[i]==-1 && right[i]==-1)\\n\\t\\t  ans.push_back(\\'.\\');\\n\\t  else if(left[i]==-1)  \\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]==-1)  \\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]<left[i])\\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]>left[i])\\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]==left[i])\\n\\t\\t  ans.push_back(\\'.\\');  \\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1562258,
                "title": "simple-java-soltuion-using-bfs",
                "content": "class Solution {\\n    \\n\\tpublic String pushDominoes(String dominoes) {\\n        char[] res = new char[dominoes.length()];\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for(int i = 0 ; i < dominoes.length() ; i++){\\n            if(dominoes.charAt(i) != \\'.\\') \\n                queue.add(i);\\n            res[i] = dominoes.charAt(i);\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            \\n            Map<Integer , Character> map = new HashMap<>();\\n            \\n            while(size-- > 0){\\n                int index = queue.poll();\\n                if(res[index] != \\'.\\'){\\n                    if(res[index] == \\'L\\'){\\n                        if(index - 1 >= 0 && res[index - 1] == \\'.\\'){\\n                            if(map.containsKey(index - 1)) \\n                                map.remove(index - 1);\\n                            else{\\n                                map.put(index - 1 , \\'L\\');\\n                                queue.add(index - 1);\\n                            }\\n                        }\\n                    }else{\\n                        if(index + 1 < res.length && res[index + 1] == \\'.\\'){\\n                            if(map.containsKey(index + 1)) \\n                                map.remove(index + 1);\\n                            else{\\n                                map.put(index + 1 , \\'R\\');\\n                                queue.add(index + 1);\\n                            } \\n                        }\\n                    }\\n                }\\n            }\\n            \\n            for(int key : map.keySet())\\n                res[key] = map.get(key); \\n            \\n        }\\n        \\n        return String.valueOf(res);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    \\n\\tpublic String pushDominoes(String dominoes) {\\n        char[] res = new char[dominoes.length()];\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for(int i = 0 ; i < dominoes.length() ; i++){\\n            if(dominoes.charAt(i) != \\'.\\') \\n                queue.add(i);\\n            res[i] = dominoes.charAt(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 132929,
                "title": "naive-bfs-easy-to-understand-and-could-be-used-as-first-solution",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] arr = new char[dominoes.length()];\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        Queue<Integer> leftQ = new LinkedList<>();\\n        Queue<Integer> rightQ = new LinkedList<>();\\n        Arrays.fill(left, Integer.MAX_VALUE);\\n        Arrays.fill(right, Integer.MAX_VALUE);\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'L\\') {\\n                leftQ.offer(i);\\n                left[i] = 0;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\') {\\n                rightQ.offer(i);\\n                right[i] = 0;\\n            }\\n        }\\n        int step = 0;\\n        while (leftQ.size() > 0 || rightQ.size() > 0) {\\n            step++;\\n            int leftSize = leftQ.size();\\n            while (leftSize > 0) {\\n                leftSize--;\\n                int pos = leftQ.poll();\\n                if (pos > 0 && left[pos - 1] == Integer.MAX_VALUE && dominoes.charAt(pos - 1) != \\'R\\') {\\n                    leftQ.offer(pos - 1);\\n                    left[pos - 1] = step;\\n                }\\n            }\\n            int rightSize = rightQ.size();\\n            while (rightSize > 0) {\\n                rightSize--;\\n                int pos = rightQ.poll();\\n                if (pos + 1< dominoes.length() && right[pos + 1] == Integer.MAX_VALUE && dominoes.charAt(pos + 1) != \\'L\\') {\\n                    rightQ.offer(pos + 1);\\n                    right[pos + 1] = step;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (left[i] - right[i] == 0) {\\n                arr[i] = \\'.\\';\\n            }\\n            else if (left[i] - right[i] > 0) {\\n                arr[i] = \\'R\\';\\n            }\\n            else {\\n                arr[i] = \\'L\\';\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] arr = new char[dominoes.length()];\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        Queue<Integer> leftQ = new LinkedList<>();\\n        Queue<Integer> rightQ = new LinkedList<>();\\n        Arrays.fill(left, Integer.MAX_VALUE);\\n        Arrays.fill(right, Integer.MAX_VALUE);\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'L\\') {\\n                leftQ.offer(i);\\n                left[i] = 0;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\') {\\n                rightQ.offer(i);\\n                right[i] = 0;\\n            }\\n        }\\n        int step = 0;\\n        while (leftQ.size() > 0 || rightQ.size() > 0) {\\n            step++;\\n            int leftSize = leftQ.size();\\n            while (leftSize > 0) {\\n                leftSize--;\\n                int pos = leftQ.poll();\\n                if (pos > 0 && left[pos - 1] == Integer.MAX_VALUE && dominoes.charAt(pos - 1) != \\'R\\') {\\n                    leftQ.offer(pos - 1);\\n                    left[pos - 1] = step;\\n                }\\n            }\\n            int rightSize = rightQ.size();\\n            while (rightSize > 0) {\\n                rightSize--;\\n                int pos = rightQ.poll();\\n                if (pos + 1< dominoes.length() && right[pos + 1] == Integer.MAX_VALUE && dominoes.charAt(pos + 1) != \\'L\\') {\\n                    rightQ.offer(pos + 1);\\n                    right[pos + 1] = step;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (left[i] - right[i] == 0) {\\n                arr[i] = \\'.\\';\\n            }\\n            else if (left[i] - right[i] > 0) {\\n                arr[i] = \\'R\\';\\n            }\\n            else {\\n                arr[i] = \\'L\\';\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629708,
                "title": "simple-python3-solution-99-faster-using-stringreplacement-explained",
                "content": "## ***UPVOTE*** if it is helpful\\n``` \\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628701,
                "title": "easy-to-understand-dp-solution-explained-line-by-line-o-n",
                "content": "The problem becomes very easy to understand once we look from the point of view of any dominoe. Consider any stable dominoe at time 0. If there exists a dominoe to its right that has been tilted to the left at time 0- let\\'s say at a distance of A, our current dominoe will be tilted to the left at time A in absence of any other force from the left. Now suppose, if there exists a dominoe to the left that has been tilted to the right at time 0- let\\'s say at a distance of B, our current dominoe will be tilted to the right at time B. Now the dominoe faces 2 opposing forces at time A & time B. There are 3 scenarios:-\\n\\n- **A==B :** In this case the dominoe will face opposing forces exactly at same time and hence won\\'t move in either direction.\\n- **A < B :** The dominoe will face a force from the right pushing it to the left much before any force comes from the left pushing it to the right. Hence it will tilt to the left.\\n- **A > B :** By similar reasoning as above the dominoe will tilt to the right.\\n\\nSo during the implementation, we just need to maintain two vectors - L & R, denoting the earliest time at which any i\\'th dominoe will face a force to the left and right respectively. If a dominoe will never face a force to the left, L[i] = INT_MAX (denoting infinity) and similarly if the dominoe never faces a force to the right, R[i] = INT_MAX.\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tvector<int> L(n,INT_MAX);\\n\\t\\t\\tvector<int> R(n,INT_MAX);\\n\\t\\t\\t\\n\\t\\t\\t//Initialize L vector\\n\\t\\t\\tif(s[n-1]==\\'L\\')\\n\\t\\t\\t\\tL[n-1]=0;\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'R\\')\\n\\t\\t\\t\\t\\tcontinue;    // This is because if there exists any dominoe to the right pushing to the left,\\n\\t\\t\\t\\t\\t\\t      \\t// our current (i\\'th) dominoe cancels it with a right force of its own\\n\\t\\t\\t\\tif(s[i]==\\'L\\')\\n\\t\\t\\t\\t\\tL[i]=0;\\n\\t\\t\\t\\telse if(L[i+1]!=INT_MAX)\\n\\t\\t\\t\\t\\tL[i]=1+L[i+1];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//Initialize R vector\\n\\t\\t\\tif(s[0]==\\'R\\')\\n\\t\\t\\t\\tR[0]=0;\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'L\\')\\n\\t\\t\\t\\t\\tcontinue;   // This is because if there exists any dominoe to the left pushing to the right,\\n\\t\\t\\t\\t\\t      \\t  // our current (i\\'th) dominoe cancels it with a left force of its own\\n\\t\\t\\t\\tif(s[i]==\\'R\\')\\n\\t\\t\\t\\t\\tR[i]=0;\\n\\t\\t\\t\\telse if(R[i-1]!=INT_MAX)\\n\\t\\t\\t\\t\\tR[i]=1+R[i-1];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// Now start looking from the point of view of every dominoe\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(L[i]==R[i])    // The dominoe faces both forces at equal times, or never faces a force from either side (i.e. L[i]=R[i]=INT_MAX)\\n\\t\\t\\t\\t\\tans+=\".\";\\n\\t\\t\\t\\telse if(L[i]<R[i])  // Left force reaches the dominoe earlier\\n\\t\\t\\t\\t\\tans+=\"L\";\\n\\t\\t\\t\\telse              // Right force reaches the dominoe earlier\\n\\t\\t\\t\\t\\tans+=\"R\";\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tvector<int> L(n,INT_MAX);\\n\\t\\t\\tvector<int> R(n,INT_MAX);\\n\\t\\t\\t\\n\\t\\t\\t//Initialize L vector\\n\\t\\t\\tif(s[n-1]==\\'L\\')\\n\\t\\t\\t\\tL[n-1]=0;\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'R\\')\\n\\t\\t\\t\\t\\tcontinue;    // This is because if there exists any dominoe to the right pushing to the left,\\n\\t\\t\\t\\t\\t\\t      \\t// our current (i\\'th) dominoe cancels it with a right force of its own\\n\\t\\t\\t\\tif(s[i]==\\'L\\')\\n\\t\\t\\t\\t\\tL[i]=0;\\n\\t\\t\\t\\telse if(L[i+1]!=INT_MAX)\\n\\t\\t\\t\\t\\tL[i]=1+L[i+1];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 753346,
                "title": "c-o-n-solution-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n = d.size();\\n        d=\"L\"+d+\"R\";\\n        int l=0,r=1,p1,p2;\\n        while(l<=(n+1) && r<=(n+1)){\\n            while(d[r]==\\'.\\'){\\n                r++;\\n            }\\n            if(d[l]==\\'R\\' && d[r]==\\'L\\'){\\n                p1=l+1,p2=r-1;\\n                while(p1<p2){\\n                    d[p1]=\\'R\\'; d[p2]=\\'L\\'; p1++; p2--;\\n                }\\n            }else if(d[l]==\\'L\\' && d[r]==\\'L\\'){\\n                p2=r-1;\\n                while(p2>l){\\n                    d[p2]=\\'L\\'; p2--;\\n                }\\n            }else if(d[l]==\\'R\\' && d[r]==\\'R\\'){\\n                p1=l+1;\\n                while(p1<r){\\n                    d[p1]=\\'R\\'; p1++;\\n                }\\n            }\\n            l=r;\\n            r++;\\n        }\\n        return d.substr(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n = d.size();\\n        d=\"L\"+d+\"R\";\\n        int l=0,r=1,p1,p2;\\n        while(l<=(n+1) && r<=(n+1)){\\n            while(d[r]==\\'.\\'){\\n                r++;\\n            }\\n            if(d[l]==\\'R\\' && d[r]==\\'L\\'){\\n                p1=l+1,p2=r-1;\\n                while(p1<p2){\\n                    d[p1]=\\'R\\'; d[p2]=\\'L\\'; p1++; p2--;\\n                }\\n            }else if(d[l]==\\'L\\' && d[r]==\\'L\\'){\\n                p2=r-1;\\n                while(p2>l){\\n                    d[p2]=\\'L\\'; p2--;\\n                }\\n            }else if(d[l]==\\'R\\' && d[r]==\\'R\\'){\\n                p1=l+1;\\n                while(p1<r){\\n                    d[p1]=\\'R\\'; p1++;\\n                }\\n            }\\n            l=r;\\n            r++;\\n        }\\n        return d.substr(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628679,
                "title": "daily-leetcoding-challenge-september-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/push-dominoes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Adjacent Symbols [Accepted]\n\n  \n**Approach 2:** Calculate Force [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/push-dominoes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1884399,
                "title": "c-87-faster-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int binarysearch(vector<int>&l,int pos)\\n    {\\n        int e=l.size()-1,s=0,index=-1;\\n        while(s<=e)\\n        {\\n            int mid=s+(e-s)/2;\\n            if(l[mid]>pos)\\n            {\\n                index=mid;\\n                e=mid-1;\\n            }else s=mid+1;\\n        }\\n        return index;\\n    }\\n    string pushDominoes(string s) \\n    {\\n        vector<int>l,r;\\n        int n=s.size(),i=0;\\n        bool ch=false;\\n\\t\\t//storing positions of l and r\\n        for(int i=0;i<n;i++)\\n        {     \\n            if(s[i]==\\'R\\')\\n            {\\n                if(ch)r[r.size()-1]=i;\\n                else r.push_back(i);\\n                ch=true;\\n            }else if(s[i]==\\'L\\')\\n            {\\n                l.push_back(i);\\n                ch=false;\\n            }\\n        }\\n        \\n        for(i=0;i<r.size();i++)\\n        {\\n            int index=binarysearch(l,r[i]);\\n            if(index==-1)break;\\n            // cout<<r[i]<<\" \"<<l[index]<<endl;\\n            int mid=l[index]-r[i]-1;\\n            mid/=2;\\n            if(mid==0)continue;\\n            int ss=r[i]+1,e=l[index]-1,c=mid;\\n            \\n            while(c--)\\n            {\\n                s[ss++]=\\'R\\';\\n            }\\n            \\n            c=mid;\\n            while(c--)\\n            {\\n                s[e--]=\\'L\\';\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\' )\\n            {\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'R\\' && (s[i+1]==\\'R\\' || s[i+1]==\\'.\\'))   {\\n                    s[i++]=\\'R\\';\\n                }\\n                // cout<<i<<endl;\\n                if(i-1>=0 && i==n-1 && s[i-1]==\\'R\\')s[i]=\\'R\\';\\n                int j=i;\\n                while(i-1>=0 && i+1<=n && s[i+1]==\\'L\\' && s[i-1]!=\\'R\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'L\\' && s[i+1]==\\'L\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                if(i==0 && s[i+1]==\\'L\\')s[i]=\\'L\\';\\n                i=j;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binarysearch(vector<int>&l,int pos)\\n    {\\n        int e=l.size()-1,s=0,index=-1;\\n        while(s<=e)\\n        {\\n            int mid=s+(e-s)/2;\\n            if(l[mid]>pos)\\n            {\\n                index=mid;\\n                e=mid-1;\\n            }else s=mid+1;\\n        }\\n        return index;\\n    }\\n    string pushDominoes(string s) \\n    {\\n        vector<int>l,r;\\n        int n=s.size(),i=0;\\n        bool ch=false;\\n\\t\\t//storing positions of l and r\\n        for(int i=0;i<n;i++)\\n        {     \\n            if(s[i]==\\'R\\')\\n            {\\n                if(ch)r[r.size()-1]=i;\\n                else r.push_back(i);\\n                ch=true;\\n            }else if(s[i]==\\'L\\')\\n            {\\n                l.push_back(i);\\n                ch=false;\\n            }\\n        }\\n        \\n        for(i=0;i<r.size();i++)\\n        {\\n            int index=binarysearch(l,r[i]);\\n            if(index==-1)break;\\n            // cout<<r[i]<<\" \"<<l[index]<<endl;\\n            int mid=l[index]-r[i]-1;\\n            mid/=2;\\n            if(mid==0)continue;\\n            int ss=r[i]+1,e=l[index]-1,c=mid;\\n            \\n            while(c--)\\n            {\\n                s[ss++]=\\'R\\';\\n            }\\n            \\n            c=mid;\\n            while(c--)\\n            {\\n                s[e--]=\\'L\\';\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\' )\\n            {\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'R\\' && (s[i+1]==\\'R\\' || s[i+1]==\\'.\\'))   {\\n                    s[i++]=\\'R\\';\\n                }\\n                // cout<<i<<endl;\\n                if(i-1>=0 && i==n-1 && s[i-1]==\\'R\\')s[i]=\\'R\\';\\n                int j=i;\\n                while(i-1>=0 && i+1<=n && s[i+1]==\\'L\\' && s[i-1]!=\\'R\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'L\\' && s[i+1]==\\'L\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                if(i==0 && s[i+1]==\\'L\\')s[i]=\\'L\\';\\n                i=j;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2632337,
                "title": "c-simulate-each-second",
                "content": "Busy day, didn\\'t have time to think of more than one approach of solving this problem.\\n\\n### Approach 1: simulate each second (78ms ~40%)\\n\\nThe intiution is the simulate second after second of the falling dominos. We start out with the dominios that are not standing straight and then we use the current state to compute the next state. This needs to happen in one go. Only at the end of a second we make the current state equal to the newly computed state. For long strings copying the state feels expensive. A variation might be to keep track in a vector which dominos we need to change and modify them before the next round.\\n\\n```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            string next = ds;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        // ... are we pushing the last one or isn\\'t the next one over leaning against it?\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            next[i + 1] = \\'R\\';\\n                            q.push(i + 1);\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            next[i - 1] = \\'L\\';\\n                            q.push(i - 1);\\n                        }\\n                    }\\n                }\\n            }\\n            // Take over the state for the next second.\\n            swap(ds, next);\\n        }\\n        return ds;\\n    }\\n```\\n\\nKeep track of the modifications in a extra vector only seems to make it slightly faster (72ms):\\n\\n```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            vector<pair<int, char>> mod;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            mod.push_back({i + 1, \\'R\\'});\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            mod.push_back({i - 1, \\'L\\'});\\n                        }\\n                    }\\n                }\\n            }\\n            // Apply the change for the next round.\\n            for (auto [i, ch] : mod) {\\n                ds[i] = ch;\\n                q.push(i);\\n            }\\n        }\\n        return ds;\\n    }\\n```\\n\\n\\n**Complexity Analysis**\\n  * Ain\\'t no time for that. :)\\n\\n_As always: Feedback, questions, and comments are welcome, and consider leaving a like (aka upvote) before you leave._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**\\n",
                "solutionTags": [],
                "code": "```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            string next = ds;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        // ... are we pushing the last one or isn\\'t the next one over leaning against it?\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            next[i + 1] = \\'R\\';\\n                            q.push(i + 1);\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            next[i - 1] = \\'L\\';\\n                            q.push(i - 1);\\n                        }\\n                    }\\n                }\\n            }\\n            // Take over the state for the next second.\\n            swap(ds, next);\\n        }\\n        return ds;\\n    }\\n```\n```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            vector<pair<int, char>> mod;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            mod.push_back({i + 1, \\'R\\'});\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            mod.push_back({i - 1, \\'L\\'});\\n                        }\\n                    }\\n                }\\n            }\\n            // Apply the change for the next round.\\n            for (auto [i, ch] : mod) {\\n                ds[i] = ch;\\n                q.push(i);\\n            }\\n        }\\n        return ds;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631190,
                "title": "java-commented-all-cases",
                "content": "```\\n/*\\n\\n    \"L.L.R...LR..L..R\"\\n    four orientations possible\\n      (1)      [L...L] -> all [LLLLL]\\n      \\n      (2)      [R...L] -> two cases even or odd numbers of spaces between them\\n               case I  (even)  -> first half [RRR]\\n                                  second half [LLL]\\n               case II  (odd)  -> first half [RR] \\n                                  middle piece will stand [.] \\n                                  second half [LL]\\n      (3)      [L...R] -> no change between [L...R]\\n      (4)      [R...R] -> all [RRRRR]\\n\\t  \\n*/\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        //  adding \"L\" and \"R\" on left and right (respectively) will not cause any change\\n        dominoes = \"L\" + dominoes + \"R\";\\n        char[] a = dominoes.toCharArray();\\n        int l = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            while (a[i] == \\'.\\') {\\n                //  skip all the dominoes that are not initially pushed\\n                i++;\\n            }\\n            //  four cases possible\\n            if (a[l] == \\'L\\' && a[i] == \\'L\\') {\\n                while (l != i) a[l++] = \\'L\\';\\n            } else if(a[l] == \\'R\\' && a[i] == \\'L\\') {\\n                //  two cases of even number of non pushed dominoes or odd \\n                //  both cases are handled in the while loop\\n                int oi = i;    //  saving original i\\n\\t\\t\\t\\twhile (l < i) {\\n                    a[l++] = \\'R\\';\\n                    a[i--] = \\'L\\';\\n                }\\n                i = oi;\\n            } else if(a[l] == \\'L\\' && a[i] == \\'R\\') {\\n                //  no change inside the [L...R] pair\\n            } else if(a[l] == \\'R\\' && a[i] == \\'R\\') {\\n                while (l != i) a[l++] = \\'R\\';\\n            }\\n            l = i;\\n        }\\n\\t\\t// removing the initial changes we made\\n        return (new String(a)).substring(1, a.length - 1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String pushDominoes(String dominoes) {\\n        //  adding \"L\" and \"R\" on left and right (respectively) will not cause any change\\n        dominoes = \"L\" + dominoes + \"R\";\\n        char[] a = dominoes.toCharArray();\\n        int l = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            while (a[i] == \\'.\\') {\\n                //  skip all the dominoes that are not initially pushed\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2356371,
                "title": "easy-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=size(s);\\n        queue<pair<int,char>>q;//queue to store the index and character at that index\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'L\\' or s[i]==\\'R\\') //pushing all the L and R into our queue\\n                q.push({i,s[i]});\\n        }\\n        vector<pair<int,char>>temp;//a temp vector \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto top=q.front();\\n                q.pop();\\n                int index=top.first;\\n                char ch=top.second;\\n                \\n                if(ch==\\'L\\')//if we encounter an L from queue\\n                {\\n                    if(index-2>=0 and s[index-2]==\\'R\\') continue;//to chck for condition .R.LL\\n                    if(index-1>=0 and s[index-1]==\\'.\\'){\\n                        q.push({index-1,\\'L\\'});\\n                        temp.push_back({index-1,\\'L\\'});\\n                    }\\n                }\\n                else if(ch==\\'R\\')\\n                {\\n                    if(index+2<n and s[index+2]==\\'L\\') continue;//to chck for condition .R.L...\\n                    if(index+1<n and s[index+1]==\\'.\\'){\\n                        q.push({index+1,\\'R\\'});\\n                        temp.push_back({index+1,\\'R\\'});\\n                    }\\n                }\\n            }\\n            for( auto i:temp)//after a level of BFS is done update the original string \\n            {\\n                pair<int,char>&p=i;\\n                s[p.first]=p.second;\\n            }\\n        }\\n        return s;//return the new string\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=size(s);\\n        queue<pair<int,char>>q;//queue to store the index and character at that index\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'L\\' or s[i]==\\'R\\') //pushing all the L and R into our queue\\n                q.push({i,s[i]});\\n        }\\n        vector<pair<int,char>>temp;//a temp vector \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto top=q.front();\\n                q.pop();\\n                int index=top.first;\\n                char ch=top.second;\\n                \\n                if(ch==\\'L\\')//if we encounter an L from queue\\n                {\\n                    if(index-2>=0 and s[index-2]==\\'R\\') continue;//to chck for condition .R.LL\\n                    if(index-1>=0 and s[index-1]==\\'.\\'){\\n                        q.push({index-1,\\'L\\'});\\n                        temp.push_back({index-1,\\'L\\'});\\n                    }\\n                }\\n                else if(ch==\\'R\\')\\n                {\\n                    if(index+2<n and s[index+2]==\\'L\\') continue;//to chck for condition .R.L...\\n                    if(index+1<n and s[index+1]==\\'.\\'){\\n                        q.push({index+1,\\'R\\'});\\n                        temp.push_back({index+1,\\'R\\'});\\n                    }\\n                }\\n            }\\n            for( auto i:temp)//after a level of BFS is done update the original string \\n            {\\n                pair<int,char>&p=i;\\n                s[p.first]=p.second;\\n            }\\n        }\\n        return s;//return the new string\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630271,
                "title": "c-o-n-time-and-space-solution-commented-code-for-more-understanding",
                "content": "We just need to check the distance of L from the right side of current dominoes[i] and distance of R from the left side of current dominoes[i] and take the minimum of the two. \\nCommented Code for better Understanding. Please Upvote if it helped! \\uD83D\\uDE03\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int>distanceOfL(n, 0), distanceofR(n, 0);\\n    // we traverse from left to right as only the R which are in the left position will affect any dominoes[i] == \\'.\\'\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\'){\\n                distanceofR[i] = 0;\\n            }\\n            // we are checking this because if dominoes[i] == \\'L\\', then we need to cut off the affect of the R \\n\\t\\t\\t//which was present on the left side of the current dominoes[i]\\n            else if(dominoes[i] == \\'L\\'){\\n                distanceofR[i] = 1e9;\\n            }\\n            else{\\n                if(i > 0 && distanceofR[i - 1] != 1e9){\\n                    distanceofR[i] = distanceofR[i - 1] + 1;\\n                }\\n                else{\\n                     distanceofR[i] = 1e9;\\n                }\\n            }\\n        }\\n        // we are traversing from right as only the L which are in right position will affect any dominoes[i] == \\'.\\'\\n        for(int i = n - 1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\'){\\n                distanceOfL[i] = 0;\\n            }\\n             // we are checking this because if dominoes[i] == R\\', then we need to cut off the affect of the L\\n\\t\\t\\t //which was present on the right side of the current dominoes[i]\\n            else if(dominoes[i] == \\'R\\'){\\n                distanceOfL[i] = 1e9;\\n            }\\n            else{\\n                if(i < n - 1 && distanceOfL[i + 1] != 1e9){\\n                    distanceOfL[i] = distanceOfL[i + 1] + 1;\\n                }\\n                else{\\n                    distanceOfL[i] = 1e9;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(distanceOfL[i] < distanceofR[i]){\\n                dominoes[i] = \\'L\\';\\n            }\\n            else if(distanceofR[i] < distanceOfL[i]){\\n                dominoes[i] = \\'R\\';\\n            }\\n           // When distanceofR[i] == distanceOfL[i], dominoes[i] will be \\'.\\' \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int>distanceOfL(n, 0), distanceofR(n, 0);\\n    // we traverse from left to right as only the R which are in the left position will affect any dominoes[i] == \\'.\\'\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\'){\\n                distanceofR[i] = 0;\\n            }\\n            // we are checking this because if dominoes[i] == \\'L\\', then we need to cut off the affect of the R \\n\\t\\t\\t//which was present on the left side of the current dominoes[i]\\n            else if(dominoes[i] == \\'L\\'){\\n                distanceofR[i] = 1e9;\\n            }\\n            else{\\n                if(i > 0 && distanceofR[i - 1] != 1e9){\\n                    distanceofR[i] = distanceofR[i - 1] + 1;\\n                }\\n                else{\\n                     distanceofR[i] = 1e9;\\n                }\\n            }\\n        }\\n        // we are traversing from right as only the L which are in right position will affect any dominoes[i] == \\'.\\'\\n        for(int i = n - 1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\'){\\n                distanceOfL[i] = 0;\\n            }\\n             // we are checking this because if dominoes[i] == R\\', then we need to cut off the affect of the L\\n\\t\\t\\t //which was present on the right side of the current dominoes[i]\\n            else if(dominoes[i] == \\'R\\'){\\n                distanceOfL[i] = 1e9;\\n            }\\n            else{\\n                if(i < n - 1 && distanceOfL[i + 1] != 1e9){\\n                    distanceOfL[i] = distanceOfL[i + 1] + 1;\\n                }\\n                else{\\n                    distanceOfL[i] = 1e9;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(distanceOfL[i] < distanceofR[i]){\\n                dominoes[i] = \\'L\\';\\n            }\\n            else if(distanceofR[i] < distanceOfL[i]){\\n                dominoes[i] = \\'R\\';\\n            }\\n           // When distanceofR[i] == distanceOfL[i], dominoes[i] will be \\'.\\' \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630182,
                "title": "c-easy-solution-using-if-else",
                "content": "* Make a vector of pair (V) of char and int which **contains** the **characters L and R** with respective indices\\n* make two variables previdx and prevchar ans assign them the first occourence of L or R i.e. **prevchar=v[0].first  , previdx=v[0].second**\\n* traverse in v from index 1\\n* Now Total there are **4 conditions** \\n1.  **prevchar==\\'L\\' and currchar==\\'L\\'** \\n2.  **prevchar==\\'L\\' and currchar==\\'R\\'**\\n3.  **prevchar==\\'R\\' and currchar==\\'R\\'**\\n4.  **prevchar==\\'R\\' and currchar==\\'L\\'**\\n\\n* **Case 1: prevchar==\\'L\\' and currchar==\\'L\\'**\\n Do ans+=\\'L\\' from previdx+1 to curridx\\n* **Case 2: prevchar==\\'L\\' and currchar==\\'R\\'**\\n Do ans+=dominoes[i] from previdx+1 to curridx \\n * **Case 3: prevchar==\\'R\\' and currchar==\\'R\\'**\\n Do ans+=\\'R\\' from previdx+1 to curridx \\n  * **Case 4: prevchar==\\'R\\' and currchar==\\'L\\'**\\n Now in this case find the length of string from previdx to curridx i.e.**len=(curridx-previdx+1)**\\n**If len is odd** \\n  do **ans+=\\'R\\'** from previdx to mid-1 \\n ans+=\\'.\\'\\n and do **ans+=\\'L\\'** from mid+1 to curridx\\n else \\n  do **ans+=\\'R\\'** from previdx to mid\\n and do **ans+=\\'L\\'** from mid+1 to curridx\\n \\n Lastly check if curr idx is less than n-1 then check the prevchar if it is L then append **\\'.\\'** upto n-1 \\n and if it is R then append **\\'R\\'** upto n-1\\n\\n**Time Complexity: O(N)\\nSpace Complexity: O(N)\\nCode**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<pair<char,int>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]!=\\'.\\')\\n                v.push_back({dominoes[i],i});\\n        }\\n        if(v.size()==0) return dominoes;\\n        string ans=\"\";\\n        int tmp=v[0].second;\\n            tmp++;\\n        char prevchar;\\n        int previdx=v[0].second;\\n        if(v[0].first==\\'L\\')\\n        {\\n            while(tmp--)\\n            ans+=\\'L\\';\\n            prevchar=\\'L\\';\\n        }\\n        else\\n        {\\n            tmp--;\\n            while(tmp--)\\n            ans+=\\'.\\';\\n            ans+=\\'R\\';\\n            prevchar=\\'R\\';\\n        }\\n        for(int i=1;i<v.size();i++)\\n        {\\n            char currchar=v[i].first;\\n            int curridx=v[i].second;\\n            \\n            if(prevchar==\\'L\\' && currchar==\\'L\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else if(prevchar==\\'L\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=dominoes[j];\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'L\\')\\n            {\\n                int len=curridx-previdx+1;\\n                int mid=(previdx+curridx)/2;\\n                if(len&1)\\n                {\\n                    for(int j=previdx+1;j<mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                else \\n                {\\n                    \\n                    for(int j=previdx+1;j<=mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    // ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                \\n            }\\n            \\n            previdx=curridx;\\n            prevchar=currchar;\\n        }\\n        if(previdx<n-1)\\n        {\\n            if(prevchar==\\'L\\')\\n            {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'.\\';\\n                }\\n            }\\n            else {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<pair<char,int>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]!=\\'.\\')\\n                v.push_back({dominoes[i],i});\\n        }\\n        if(v.size()==0) return dominoes;\\n        string ans=\"\";\\n        int tmp=v[0].second;\\n            tmp++;\\n        char prevchar;\\n        int previdx=v[0].second;\\n        if(v[0].first==\\'L\\')\\n        {\\n            while(tmp--)\\n            ans+=\\'L\\';\\n            prevchar=\\'L\\';\\n        }\\n        else\\n        {\\n            tmp--;\\n            while(tmp--)\\n            ans+=\\'.\\';\\n            ans+=\\'R\\';\\n            prevchar=\\'R\\';\\n        }\\n        for(int i=1;i<v.size();i++)\\n        {\\n            char currchar=v[i].first;\\n            int curridx=v[i].second;\\n            \\n            if(prevchar==\\'L\\' && currchar==\\'L\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else if(prevchar==\\'L\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=dominoes[j];\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'L\\')\\n            {\\n                int len=curridx-previdx+1;\\n                int mid=(previdx+curridx)/2;\\n                if(len&1)\\n                {\\n                    for(int j=previdx+1;j<mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                else \\n                {\\n                    \\n                    for(int j=previdx+1;j<=mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    // ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                \\n            }\\n            \\n            previdx=curridx;\\n            prevchar=currchar;\\n        }\\n        if(previdx<n-1)\\n        {\\n            if(prevchar==\\'L\\')\\n            {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'.\\';\\n                }\\n            }\\n            else {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629832,
                "title": "easy-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = \\'L\\' + dominoes + \\'R\\'\\n        res = []\\n        left = 0\\n        \\n        for right in range(1, len(dominoes)):\\n            if dominoes[right] == \\'.\\': \\n                continue\\n                \\n            middle = right - left - 1\\n            if left: \\n                res.append(dominoes[left])\\n            if dominoes[left] == dominoes[right]: \\n                res.append(dominoes[left] * middle)\\n            elif dominoes[left] == \\'L\\' and dominoes[right] == \\'R\\':\\n                res.append(\\'.\\' * middle)\\n            else: \\n                res.append(\\'R\\' * (middle // 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle // 2))\\n            left = right\\n            \\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = \\'L\\' + dominoes + \\'R\\'\\n        res = []\\n        left = 0\\n        \\n        for right in range(1, len(dominoes)):\\n            if dominoes[right] == \\'.\\': \\n                continue\\n                \\n            middle = right - left - 1\\n            if left: \\n                res.append(dominoes[left])\\n            if dominoes[left] == dominoes[right]: \\n                res.append(dominoes[left] * middle)\\n            elif dominoes[left] == \\'L\\' and dominoes[right] == \\'R\\':\\n                res.append(\\'.\\' * middle)\\n            else: \\n                res.append(\\'R\\' * (middle // 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle // 2))\\n            left = right\\n            \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629079,
                "title": "javascript-easy-solution-with-explanation-two-pointers-dynamic-programming",
                "content": "We are going to approach this problem by using dp Array \\n\\nLets take example \\nFrom the left of dominoes we are pushing towards Right and we are storing the index of the last right push if the left push is on the particular point we are putting the index as -1 and also if there are no right push as of now and we have \".\" means also we are considering -1.\\nGiven Input =>  \".L.R...LR..L..\"\\nAfter the left-side right push dpL => [ -1,-1,-1,3,3,3,3,-1,8,8,8,-1,-1,-1]\\n\\nAfter that we have to take the right-side left push we are keeping the \\'R\\' and \".\" as -1 and storing the index of the left push from the right side.\\nAfter the right-side-left-push dpR =>[1,1,-1,-1,7,7,7,7,-1,11,11,11,-1,-1]\\n\\nThen For finalizing result string we are doing followin checks\\n 1. if both the dp consist of -1 that means no push occured on the particular domino so we are adding \".\"\\n 2. Then are checking is any one of the dp having the push like its having any index other than -1. If dpR consist means that is left push vice versa for the dp L.\\n 3. Then if the both contains index we are calculating the nearest index and putting their value if both are equal we are adding \".\" \\n\\nPlease upvote this solution if you like this \\n\\n\\n```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(d) {\\n    let dpL = [];\\n    let dpR = [];\\n    for(let i =0;i<d.length;i++){\\n        if(d[i]===\\'R\\'){\\n            dpL[i] = i;\\n        } else if(d[i]===\\'L\\'){\\n            dpL[i] = -1;\\n        } else if(dpL[i]!=-1){\\n            dpL[i] = dpL[i-1]===undefined ? -1:dpL[i-1];\\n        }\\n        let j = d.length-i-1;\\n        if(d[j]===\\'L\\'){\\n            dpR[j] = j;\\n        } else if(d[j]===\\'R\\'){\\n            dpR[j] = -1;\\n        } else if(dpR[j]!=-1){\\n            dpR[j] = dpR[j+1]===undefined ? -1:dpR[j+1];\\n        }\\n    }\\n    let res = \\'\\';\\n    for(let i=0;i<d.length;i++){\\n\\t\\t// check 1\\n        if(dpR[i]==-1&dpL[i]==-1){\\n            res+=\".\"\\n            }\\n        else if(dpL[i]!==-1 && dpR[i]!==-1){\\n\\t\\t\\t//  check 3\\n            if(Math.abs(dpL[i]-i)===Math.abs(dpR[i]-i)){\\n                res+=\".\";\\n            }\\n            else if(Math.abs(dpL[i]-i)<Math.abs(dpR[i]-i)){\\n                res+=\\'R\\';\\n            }\\n            else{\\n                res+=\\'L\\';\\n            }\\n        }\\n        else{\\n\\t\\t\\t// check 2\\n            res+=dpL[i]===-1?\\'L\\':\\'R\\'\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(d) {\\n    let dpL = [];\\n    let dpR = [];\\n    for(let i =0;i<d.length;i++){\\n        if(d[i]===\\'R\\'){\\n            dpL[i] = i;\\n        } else if(d[i]===\\'L\\'){\\n            dpL[i] = -1;\\n        } else if(dpL[i]!=-1){\\n            dpL[i] = dpL[i-1]===undefined ? -1:dpL[i-1];\\n        }\\n        let j = d.length-i-1;\\n        if(d[j]===\\'L\\'){\\n            dpR[j] = j;\\n        } else if(d[j]===\\'R\\'){\\n            dpR[j] = -1;\\n        } else if(dpR[j]!=-1){\\n            dpR[j] = dpR[j+1]===undefined ? -1:dpR[j+1];\\n        }\\n    }\\n    let res = \\'\\';\\n    for(let i=0;i<d.length;i++){\\n\\t\\t// check 1\\n        if(dpR[i]==-1&dpL[i]==-1){\\n            res+=\".\"\\n            }\\n        else if(dpL[i]!==-1 && dpR[i]!==-1){\\n\\t\\t\\t//  check 3\\n            if(Math.abs(dpL[i]-i)===Math.abs(dpR[i]-i)){\\n                res+=\".\";\\n            }\\n            else if(Math.abs(dpL[i]-i)<Math.abs(dpR[i]-i)){\\n                res+=\\'R\\';\\n            }\\n            else{\\n                res+=\\'L\\';\\n            }\\n        }\\n        else{\\n\\t\\t\\t// check 2\\n            res+=dpL[i]===-1?\\'L\\':\\'R\\'\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629066,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Two Pointers***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        \\n        int n = str.size();\\n        \\n        int left = 0;\\n        \\n        int right = 0;\\n        \\n        while(right < n)\\n        {\\n            if(str[right] == \\'.\\')\\n            {\\n                right++;\\n                \\n                continue;\\n            }\\n            \\n            if(str[right] == str[left] || (str[left] == \\'.\\' && str[right] == \\'L\\'))\\n            {\\n                int i = left;\\n                \\n                while(i < right)\\n                {\\n                    str[i] = str[right];\\n                    \\n                    i++;\\n                }\\n            }\\n            else if(str[left] == \\'R\\' && str[right] == \\'L\\')\\n            {\\n                int i = left;\\n                \\n                int j = right;\\n                \\n                while(i < j)\\n                {\\n                    str[i] = \\'R\\';\\n                    \\n                    str[j] = \\'L\\';\\n                    \\n                    i++;\\n                    \\n                    j--;\\n                }\\n            }\\n            \\n            // update pointers\\n            \\n            left = right;\\n            \\n            right++;\\n        }\\n        \\n        // if the last push is \\'R\\' then replace all the characters right to it with \\'R\\'\\n        \\n        if(str[left] == \\'R\\')\\n        {\\n            int i = left;\\n            \\n            while(i < n)\\n            {\\n                str[i] = \\'R\\';\\n                \\n                i++;\\n            }\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        \\n        int n = str.size();\\n        \\n        int left = 0;\\n        \\n        int right = 0;\\n        \\n        while(right < n)\\n        {\\n            if(str[right] == \\'.\\')\\n            {\\n                right++;\\n                \\n                continue;\\n            }\\n            \\n            if(str[right] == str[left] || (str[left] == \\'.\\' && str[right] == \\'L\\'))\\n            {\\n                int i = left;\\n                \\n                while(i < right)\\n                {\\n                    str[i] = str[right];\\n                    \\n                    i++;\\n                }\\n            }\\n            else if(str[left] == \\'R\\' && str[right] == \\'L\\')\\n            {\\n                int i = left;\\n                \\n                int j = right;\\n                \\n                while(i < j)\\n                {\\n                    str[i] = \\'R\\';\\n                    \\n                    str[j] = \\'L\\';\\n                    \\n                    i++;\\n                    \\n                    j--;\\n                }\\n            }\\n            \\n            // update pointers\\n            \\n            left = right;\\n            \\n            right++;\\n        }\\n        \\n        // if the last push is \\'R\\' then replace all the characters right to it with \\'R\\'\\n        \\n        if(str[left] == \\'R\\')\\n        {\\n            int i = left;\\n            \\n            while(i < n)\\n            {\\n                str[i] = \\'R\\';\\n                \\n                i++;\\n            }\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629055,
                "title": "easy-to-understand-javascript-solution-using-two-pointers",
                "content": "\\n&emsp;The problem requires us to see how it will end up if we let all the dominoes fall into the direction they are set, all at the same time. This may be doable in real life but computers can\\'t do this. We should come up of a solution that computers can execute... a methodological one.\\n<br />\\n**Using 2-Pointers:**\\n\\n&emsp;If we think about it, we only really care about how the dominoes standing vertically that\\'s sandwiched between the falling dominoes will react. To do this, we just need to see what will happen between the window of dominoes converging from left to right `\"R\"` and right to left `\"L\"`.\\n\\n&emsp;The code loops through the array of dominoes, checking the window requirement. Once it reaches there, it simulates what happens to the dominoes in the middle of falling dominoes. If it reaches a common point, it will ignored since force falling from the opposite direction will cancel out each other. Once it\\'s done, it will move on to another window until all of them have been checked. \\n\\n**Handling Corner Cases:**\\n\\n&emsp;Corner case happens when the first index has a vertical domino `\".\"` and one of the succeeding domino is falling from the left `\"L\"` or vice versa for the last index but the predecessor is falling from the right `\"R\"` \\n&emsp;*eg.* `\"(..L).RR...LL(R...)\"`\\n\\n&emsp;we temporarily append `\"L\"` to the first index and `\"R\"` to the last index to  handle the corner cases. This doesn\\'t change anything but it allows us to handle both cases in a single for loop.\\n<br>\\nTime Complexity: **O(n)**\\nSpace Compelxity: **O(n)**\\n\\n```javascript\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = \"L\" + dominoes + \"R\"; \\n    const arr = dominoes.split(\\'\\'), n = dominoes.length;\\n\\n    for (let l = 0, r = 1; r < n; r++) {\\n        if (arr[r] === \".\") continue;\\n\\n        if (arr[r] === \"L\" && arr[l] === \"R\")\\n            for (let i = l+1, j = r-1; j-i && i < j; i++, j--)\\n                arr[i] = \"R\", arr[j] = \"L\";\\n\\n        // handle both corner cases\\n        if (arr[l] === arr[r])\\n            for (let i = l; i < r; i++)\\n                arr[i] = arr[r];\\n\\n        l = r;\\n    }\\n\\n    return arr.slice(1, n-1).join(\\'\\');\\n};```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```javascript\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = \"L\" + dominoes + \"R\"; \\n    const arr = dominoes.split(\\'\\'), n = dominoes.length;\\n\\n    for (let l = 0, r = 1; r < n; r++) {\\n        if (arr[r] === \".\") continue;\\n\\n        if (arr[r] === \"L\" && arr[l] === \"R\")\\n            for (let i = l+1, j = r-1; j-i && i < j; i++, j--)\\n                arr[i] = \"R\", arr[j] = \"L\";\\n\\n        // handle both corner cases\\n        if (arr[l] === arr[r])\\n            for (let i = l; i < r; i++)\\n                arr[i] = arr[r];\\n\\n        l = r;\\n    }\\n\\n    return arr.slice(1, n-1).join(\\'\\');\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 348579,
                "title": "python-force-caculate",
                "content": "O(N)\\n```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        force = N = len(dominoes)\\n        tmp = 0\\n        ans = [0] * N\\n        for i in range(N):\\n            if dominoes[i] == \\'R\\':\\n                tmp = force\\n            if dominoes[i] == \\'L\\':\\n                tmp = 0\\n            ans[i] += max(tmp, 0)\\n            tmp -= 1\\n        tmp = 0\\n        for i in range(N-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                tmp = -force\\n            if dominoes[i] == \\'R\\':\\n                tmp = 0\\n            ans[i] += min(tmp, 0)\\n            tmp += 1\\n        return \\'\\'.join([ \\'R\\' if n>0 else \\'L\\' if n<0 else \\'.\\' for n in ans])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        force = N = len(dominoes)\\n        tmp = 0\\n        ans = [0] * N\\n        for i in range(N):\\n            if dominoes[i] == \\'R\\':\\n                tmp = force\\n            if dominoes[i] == \\'L\\':\\n                tmp = 0\\n            ans[i] += max(tmp, 0)\\n            tmp -= 1\\n        tmp = 0\\n        for i in range(N-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                tmp = -force\\n            if dominoes[i] == \\'R\\':\\n                tmp = 0\\n            ans[i] += min(tmp, 0)\\n            tmp += 1\\n        return \\'\\'.join([ \\'R\\' if n>0 else \\'L\\' if n<0 else \\'.\\' for n in ans])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2631203,
                "title": "python-iterative-bfs-solution-o-n-time-o-n-space",
                "content": "```\\n# * Iterative BFS Solution | O(n) Time | O(n) Space\\n# * n -> The length of dominoes string\\n\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes_list = list(dominoes)\\n        # * Start the BFS traversal.\\n        # * Push all the `L` and `R` into the queue for processing.\\n        queue = collections.deque(\\n            [(idx, d) for idx, d in enumerate(dominoes_list) if d != \".\"]\\n        )\\n\\n        while queue:\\n            cur_idx, cur_dominoe = queue.popleft()\\n            if cur_dominoe == \"L\" and cur_idx > 0 and dominoes_list[cur_idx - 1] == \".\":\\n                queue.append((cur_idx - 1, \"L\"))\\n                dominoes_list[cur_idx - 1] = \"L\"\\n\\n            elif (\\n                cur_dominoe == \"R\"\\n                and cur_idx + 1 < len(dominoes_list)\\n                and dominoes_list[cur_idx + 1] == \".\"\\n            ):\\n                if (\\n                    cur_idx + 2 < len(dominoes_list)\\n                    and dominoes_list[cur_idx + 2] == \"L\"\\n                ):\\n                    queue.popleft()\\n\\n                else:\\n                    queue.append((cur_idx + 1, \"R\"))\\n                    dominoes_list[cur_idx + 1] = \"R\"\\n\\n        return \"\".join(dominoes_list)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n# * Iterative BFS Solution | O(n) Time | O(n) Space\\n# * n -> The length of dominoes string\\n\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes_list = list(dominoes)\\n        # * Start the BFS traversal.\\n        # * Push all the `L` and `R` into the queue for processing.\\n        queue = collections.deque(\\n            [(idx, d) for idx, d in enumerate(dominoes_list) if d != \".\"]\\n        )\\n\\n        while queue:\\n            cur_idx, cur_dominoe = queue.popleft()\\n            if cur_dominoe == \"L\" and cur_idx > 0 and dominoes_list[cur_idx - 1] == \".\":\\n                queue.append((cur_idx - 1, \"L\"))\\n                dominoes_list[cur_idx - 1] = \"L\"\\n\\n            elif (\\n                cur_dominoe == \"R\"\\n                and cur_idx + 1 < len(dominoes_list)\\n                and dominoes_list[cur_idx + 1] == \".\"\\n            ):\\n                if (\\n                    cur_idx + 2 < len(dominoes_list)\\n                    and dominoes_list[cur_idx + 2] == \"L\"\\n                ):\\n                    queue.popleft()\\n\\n                else:\\n                    queue.append((cur_idx + 1, \"R\"))\\n                    dominoes_list[cur_idx + 1] = \"R\"\\n\\n        return \"\".join(dominoes_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630107,
                "title": "using-two-pointer-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        string str=\"\";\\n        int i=0,j=n-1;\\n        //to strore the time duration when left effect will occur to that dominoe box\\n        vector<int> l(n,0);  \\n        //to strore the time duration when right effect will occur to that dominoe box\\n        vector<int> r(n,0);\\n        int prev=0,cnt=0;\\n        while(i<n)\\n        {\\n            if(dominoes[prev]==\\'R\\' && dominoes[i]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=i;\\n                cnt=0;\\n            }\\n            r[i]=cnt;\\n            i++;\\n        }\\n      \\n        cnt =0;\\n        prev=j;\\n        while(j>=0)\\n        {\\n            if(dominoes[prev]==\\'L\\' && dominoes[j]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=j;\\n                cnt=0;\\n            }\\n            l[j]=cnt;\\n            j--;\\n        }\\n           \\n        for(int i=0;i<n;i++)\\n        {\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]!=0){  \\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]==0){\\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]!=0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]==0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] == r[i] && dominoes[i]==\\'.\\'){\\n                dominoes[i]=\\'.\\';\\n            }\\n           \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        string str=\"\";\\n        int i=0,j=n-1;\\n        //to strore the time duration when left effect will occur to that dominoe box\\n        vector<int> l(n,0);  \\n        //to strore the time duration when right effect will occur to that dominoe box\\n        vector<int> r(n,0);\\n        int prev=0,cnt=0;\\n        while(i<n)\\n        {\\n            if(dominoes[prev]==\\'R\\' && dominoes[i]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=i;\\n                cnt=0;\\n            }\\n            r[i]=cnt;\\n            i++;\\n        }\\n      \\n        cnt =0;\\n        prev=j;\\n        while(j>=0)\\n        {\\n            if(dominoes[prev]==\\'L\\' && dominoes[j]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=j;\\n                cnt=0;\\n            }\\n            l[j]=cnt;\\n            j--;\\n        }\\n           \\n        for(int i=0;i<n;i++)\\n        {\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]!=0){  \\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]==0){\\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]!=0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]==0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] == r[i] && dominoes[i]==\\'.\\'){\\n                dominoes[i]=\\'.\\';\\n            }\\n           \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629684,
                "title": "c-2-pointer-simple-and-concise-code-commented",
                "content": "```\\nstring pushDominoes(string d) {\\n        int n = d.size(), i = 0, prev = 0;\\n        string ans(n, \\'.\\');//initialize ans with \\'.\\'s\\n        while(i<n){\\n            while(i<n && d[i] == \\'.\\')i++;\\n            if(i<n && d[i] == \\'L\\'){\\n                //if encountered an L first, then update from prev to this position all as \\'L\\'\\n                while(prev <= i)\\n                    ans[prev++] = \\'L\\';\\n                i++;\\n            }\\n            else if(i<n && d[i] == \\'R\\'){\\n                //if encountered an \\'R\\', then search for \\'L\\' on the right side\\n                while(i<n && d[i] == \\'R\\'){//to reduce redundancy, just traverse all the run of \\'R\\'s.\\n                    ans[i] = \\'R\\';//also keep on updating the \\'R\\' given in the original string\\n                    i++;\\n                }\\n                prev = i;\\n                while(i<n && d[i] == \\'.\\')i++;\\n                if((i<n && d[i] == \\'R\\') || i == n){\\n                    //we encountered another \\'R\\', or reached the end, so update all the \\'.\\'s to \\'R\\' as no collision\\n                    while(prev < i)\\n                        ans[prev++] = \\'R\\';\\n                }\\n                else if(i<n && d[i] == \\'L\\'){\\n                    int p1 = i-1;\\n                    //we encountered an \\'L\\', so using two pointers, update R and L, as long as the pointers don\\'t collide\\n                    while(prev < p1){\\n                        ans[prev++] = \\'R\\';\\n                        ans[p1--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            prev = i;\\n        }\\n        return  ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nstring pushDominoes(string d) {\\n        int n = d.size(), i = 0, prev = 0;\\n        string ans(n, \\'.\\');//initialize ans with \\'.\\'s\\n        while(i<n){\\n            while(i<n && d[i] == \\'.\\')i++;\\n            if(i<n && d[i] == \\'L\\'){\\n                //if encountered an L first, then update from prev to this position all as \\'L\\'\\n                while(prev <= i)\\n                    ans[prev++] = \\'L\\';\\n                i++;\\n            }\\n            else if(i<n && d[i] == \\'R\\'){\\n                //if encountered an \\'R\\', then search for \\'L\\' on the right side\\n                while(i<n && d[i] == \\'R\\'){//to reduce redundancy, just traverse all the run of \\'R\\'s.\\n                    ans[i] = \\'R\\';//also keep on updating the \\'R\\' given in the original string\\n                    i++;\\n                }\\n                prev = i;\\n                while(i<n && d[i] == \\'.\\')i++;\\n                if((i<n && d[i] == \\'R\\') || i == n){\\n                    //we encountered another \\'R\\', or reached the end, so update all the \\'.\\'s to \\'R\\' as no collision\\n                    while(prev < i)\\n                        ans[prev++] = \\'R\\';\\n                }\\n                else if(i<n && d[i] == \\'L\\'){\\n                    int p1 = i-1;\\n                    //we encountered an \\'L\\', so using two pointers, update R and L, as long as the pointers don\\'t collide\\n                    while(prev < p1){\\n                        ans[prev++] = \\'R\\';\\n                        ans[p1--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            prev = i;\\n        }\\n        return  ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629342,
                "title": "python-solution-o-n-comments",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        left=[0]*n\\n        right=[0]*n\\n        \\n        # traverse from left side \\n        # keep count of \\'R\\' occurennces\\n        count=0\\n        for i in range(n):\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                count=0\\n            left[i]=count\\n            if dominoes[i]==\\'R\\' or count!=0:\\n                count+=1\\n        \\n        # traverse from right side \\n        # keep count of \\'L\\' occurennces\\n        count=0\\n        for i in range(n-1, -1, -1):\\n            if dominoes[i]==\\'R\\' or dominoes[i]==\\'L\\':\\n                count=0\\n            right[i]=count\\n            if dominoes[i]==\\'L\\' or count!=0:\\n                count+=1\\n            \\n        # print(left)\\n        # print(right)\\n        \\n        # formulate ans based on occurence count of \\'L\\' and \\'R\\'\\n        ans=\\'\\'\\n        for i in range(n):\\n            if left[i]==right[i]:\\n                ans+=dominoes[i]\\n            else:\\n                if left[i]==0 and right[i]!=0:\\n                    ans+=\\'L\\'\\n                elif right[i]==0 and left[i]!=0:\\n                    ans+=\\'R\\'\\n                elif left[i]>right[i]:\\n                    ans+=\\'L\\'\\n                else:\\n                    ans+=\\'R\\'\\n        \\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        left=[0]*n\\n        right=[0]*n\\n        \\n        # traverse from left side \\n        # keep count of \\'R\\' occurennces\\n        count=0\\n        for i in range(n):\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                count=0\\n            left[i]=count\\n            if dominoes[i]==\\'R\\' or count!=0:\\n                count+=1\\n        \\n        # traverse from right side \\n        # keep count of \\'L\\' occurennces\\n        count=0\\n        for i in range(n-1, -1, -1):\\n            if dominoes[i]==\\'R\\' or dominoes[i]==\\'L\\':\\n                count=0\\n            right[i]=count\\n            if dominoes[i]==\\'L\\' or count!=0:\\n                count+=1\\n            \\n        # print(left)\\n        # print(right)\\n        \\n        # formulate ans based on occurence count of \\'L\\' and \\'R\\'\\n        ans=\\'\\'\\n        for i in range(n):\\n            if left[i]==right[i]:\\n                ans+=dominoes[i]\\n            else:\\n                if left[i]==0 and right[i]!=0:\\n                    ans+=\\'L\\'\\n                elif right[i]==0 and left[i]!=0:\\n                    ans+=\\'R\\'\\n                elif left[i]>right[i]:\\n                    ans+=\\'L\\'\\n                else:\\n                    ans+=\\'R\\'\\n        \\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629115,
                "title": "cpp-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        \\n        string ans = dom;\\n        queue<pair<int,char>>dq;\\n        \\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i] != \\'.\\')\\n            {\\n                dq.push({i,ans[i]});\\n            }\\n        }\\n        \\n        while(!dq.empty())\\n        {\\n            int i = dq.front().first;\\n            int d = dq.front().second;\\n            dq.pop();\\n            if(d == \\'L\\' and i > 0 and ans[i-1] == \\'.\\')\\n            {\\n                dq.push({i-1,\\'L\\'});\\n                ans[i-1] = \\'L\\';\\n            }\\n            else if(d == \\'R\\')\\n            {\\n                if(i+1 < ans.length() and ans[i+1] == \\'.\\')\\n                {\\n                    if(i+2 < ans.length() and ans[i+2] == \\'L\\')\\n                    {\\n                        dq.pop();\\n                    }\\n                    else{\\n                        dq.push({i+1,\\'R\\'});\\n                        ans[i+1] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        \\n        string ans = dom;\\n        queue<pair<int,char>>dq;\\n        \\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i] != \\'.\\')\\n            {\\n                dq.push({i,ans[i]});\\n            }\\n        }\\n        \\n        while(!dq.empty())\\n        {\\n            int i = dq.front().first;\\n            int d = dq.front().second;\\n            dq.pop();\\n            if(d == \\'L\\' and i > 0 and ans[i-1] == \\'.\\')\\n            {\\n                dq.push({i-1,\\'L\\'});\\n                ans[i-1] = \\'L\\';\\n            }\\n            else if(d == \\'R\\')\\n            {\\n                if(i+1 < ans.length() and ans[i+1] == \\'.\\')\\n                {\\n                    if(i+2 < ans.length() and ans[i+2] == \\'L\\')\\n                    {\\n                        dq.pop();\\n                    }\\n                    else{\\n                        dq.push({i+1,\\'R\\'});\\n                        ans[i+1] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628823,
                "title": "c-explaination-concise-code",
                "content": "**Observations**:\\nThe observations are for indices with **dominoes[i]==\\'.\\'**\\n1. the nearest dominoes on left and right determines the direction of fall\\n2. on the left side , if nearest domino is a \\'R\\' , then it is valid\\n3. On the right side , if nearest domino is a \\'L\\', then it  is valid\\n4.  If both sides have valid and different distance dominoes , min-dist domino decides the direction\\n5.  Else if a single side contains a valid domino , that directon decides\\n6.  In all other case the dominos[i] is unchanged\\n\\n**Time:O(n)**\\n**Space:O(n)**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n       int n=dominoes.size();\\n        \\n       vector<int> left(n,-1) , right(n);\\n       for(int i=0;i<n;i++){\\n           //nearest left domino\\n           if(dominoes[i] != \\'.\\') left[i] = i;\\n           else left[i] = (i-1 >= 0)?left[i-1]:-1;\\n           \\n           //nearest right domino\\n           if(dominoes[n-i-1] !=\\'.\\') right[n-i-1]=n-i-1;\\n           else right[n-i-1] = (n-i < n)?right[n-i]:n;\\n       }\\n        \\n        \\n       for(int i=0;i<n;i++){\\n           if(dominoes[i]!=\\'.\\') continue;\\n           \\n\\t\\t  //for invalid domino we use INT_MAX , so we can disacrd it while taking min\\n           int left_power = (left[i]==-1 or dominoes[left[i]]==\\'L\\')?INT_MAX:i-left[i];\\n           int right_power = (right[i]==n or dominoes[right[i]]==\\'R\\')?INT_MAX:right[i]-i;\\n           \\n           if(left_power != right_power){\\n               dominoes[i] = (left_power < right_power)?\\'R\\':\\'L\\';\\n           }\\n           \\n       }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n       int n=dominoes.size();\\n        \\n       vector<int> left(n,-1) , right(n);\\n       for(int i=0;i<n;i++){\\n           //nearest left domino\\n           if(dominoes[i] != \\'.\\') left[i] = i;\\n           else left[i] = (i-1 >= 0)?left[i-1]:-1;\\n           \\n           //nearest right domino\\n           if(dominoes[n-i-1] !=\\'.\\') right[n-i-1]=n-i-1;\\n           else right[n-i-1] = (n-i < n)?right[n-i]:n;\\n       }\\n        \\n        \\n       for(int i=0;i<n;i++){\\n           if(dominoes[i]!=\\'.\\') continue;\\n           \\n\\t\\t  //for invalid domino we use INT_MAX , so we can disacrd it while taking min\\n           int left_power = (left[i]==-1 or dominoes[left[i]]==\\'L\\')?INT_MAX:i-left[i];\\n           int right_power = (right[i]==n or dominoes[right[i]]==\\'R\\')?INT_MAX:right[i]-i;\\n           \\n           if(left_power != right_power){\\n               dominoes[i] = (left_power < right_power)?\\'R\\':\\'L\\';\\n           }\\n           \\n       }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628799,
                "title": "java-solution-easy-understanding-comments",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n      \\n        // ex: .L.R...LR..L..\\n        // create two arrays: one corresponding to left to right momentum and one for right to left momentum\\n        // left to right: if we are on a \\'.\\' and we see a \\'R\\' to the left of us, we need to add 1 to our current momentum\\n        // right to left: if we are on a \\'.\\' and we see a \\'L\\' to the right of us, we need to add 1 to our current momentum\\n\\t\\t// note:  array values are initially 0 at each index and the current momentum can be found by looking at the previous index\\n        // 0, 0, 0, 0, 1, 2, 3, 0, 0, 1, 2, 0, 0, 0 -> left to right (loop the dominoes string from left to right)\\n        // 1, 0, 0, 0, 3, 2, 1, 0, 0, 2, 1, 0, 0, 0 -> right to left (loop the dominoes string from right to left)\\n        \\n        // finally loop over the length of the arrays: \\n\\t\\t// if both arrays contain the same momentum value, keep the original character found in dominoes string\\n        // if one of the arrays contains a momentum of 0, choose the letter corresponding to the other array\\n        // both momentums are non zero values, choose the letter corresponding to the array of the smallest value\\n\\t\\t// note:  left to right array corresponds to setting the \\'R\\' character, the opposite is true for the right to left array\\n        \\n        StringBuilder result = new StringBuilder();\\n        int[] ltr = new int[dominoes.length()]; // momentum going from left to right\\n        int[] rtl = new int[dominoes.length()]; // momentum going from right to left\\n        \\n        // left to right momentum \\n        for (int i = 1; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i - 1) == \\'R\\' || ltr[i - 1] > 0)) {\\n                \\n                ltr[i] = ltr[i - 1] + 1;\\n            }\\n            \\n        }\\n        \\n        // right to left momentum\\n        for (int i = dominoes.length() - 2; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i + 1) == \\'L\\' || rtl[i + 1] > 0)) {\\n                \\n                rtl[i] = rtl[i + 1] + 1;\\n            }\\n        }\\n        \\n        \\n        // compute the result by looking at both arrays and taking the smallest momentum value that is non zero\\n        // note:  original value from dominoes will remain for equal momentums\\n        for(int i = 0; i < dominoes.length(); i++) {\\n            if (ltr[i] == rtl[i]) {\\n                result.append(dominoes.charAt(i));\\n            } else if (ltr[i] == 0 || rtl[i] == 0) {\\n                // take the non zero\\n                if (ltr[i] == 0) {\\n                    result.append(\"L\");\\n                } else {\\n                    result.append(\"R\");\\n                }\\n            } else {\\n                // take the smallest value\\n                if (ltr[i] < rtl[i]) {\\n                    result.append(\"R\");\\n                } else {\\n                    result.append(\"L\");\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n      \\n        // ex: .L.R...LR..L..\\n        // create two arrays: one corresponding to left to right momentum and one for right to left momentum\\n        // left to right: if we are on a \\'.\\' and we see a \\'R\\' to the left of us, we need to add 1 to our current momentum\\n        // right to left: if we are on a \\'.\\' and we see a \\'L\\' to the right of us, we need to add 1 to our current momentum\\n\\t\\t// note:  array values are initially 0 at each index and the current momentum can be found by looking at the previous index\\n        // 0, 0, 0, 0, 1, 2, 3, 0, 0, 1, 2, 0, 0, 0 -> left to right (loop the dominoes string from left to right)\\n        // 1, 0, 0, 0, 3, 2, 1, 0, 0, 2, 1, 0, 0, 0 -> right to left (loop the dominoes string from right to left)\\n        \\n        // finally loop over the length of the arrays: \\n\\t\\t// if both arrays contain the same momentum value, keep the original character found in dominoes string\\n        // if one of the arrays contains a momentum of 0, choose the letter corresponding to the other array\\n        // both momentums are non zero values, choose the letter corresponding to the array of the smallest value\\n\\t\\t// note:  left to right array corresponds to setting the \\'R\\' character, the opposite is true for the right to left array\\n        \\n        StringBuilder result = new StringBuilder();\\n        int[] ltr = new int[dominoes.length()]; // momentum going from left to right\\n        int[] rtl = new int[dominoes.length()]; // momentum going from right to left\\n        \\n        // left to right momentum \\n        for (int i = 1; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i - 1) == \\'R\\' || ltr[i - 1] > 0)) {\\n                \\n                ltr[i] = ltr[i - 1] + 1;\\n            }\\n            \\n        }\\n        \\n        // right to left momentum\\n        for (int i = dominoes.length() - 2; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i + 1) == \\'L\\' || rtl[i + 1] > 0)) {\\n                \\n                rtl[i] = rtl[i + 1] + 1;\\n            }\\n        }\\n        \\n        \\n        // compute the result by looking at both arrays and taking the smallest momentum value that is non zero\\n        // note:  original value from dominoes will remain for equal momentums\\n        for(int i = 0; i < dominoes.length(); i++) {\\n            if (ltr[i] == rtl[i]) {\\n                result.append(dominoes.charAt(i));\\n            } else if (ltr[i] == 0 || rtl[i] == 0) {\\n                // take the non zero\\n                if (ltr[i] == 0) {\\n                    result.append(\"L\");\\n                } else {\\n                    result.append(\"R\");\\n                }\\n            } else {\\n                // take the smallest value\\n                if (ltr[i] < rtl[i]) {\\n                    result.append(\"R\");\\n                } else {\\n                    result.append(\"L\");\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108778,
                "title": "c-simple-clean-and-well-commented-easy-to-understand-two-pointers",
                "content": "I have explained the code in the comments, easy to understand.\\n``` \\nclass Solution {\\npublic:\\n    //adding L and R at ends do not change the configuration\\n    //we have to divide the total string into parts, thats why adding L and R at ends for cases like ...L..R...\\n    //parts can be : L...L , R...R, L...R, R...L\\n    //L...L->all dots inside it will become L\\n    //R...R-> all dots inside it  will become R\\n    //L...R-> all dots remains unchanged\\n    //R...L->if dots are even then half R half L\\n    //else mid remains unchanged and one half R and other half L\\n    void solvefor(vector<char>&arr,int i,int j)\\n    {\\n        // i and j are pointer pointing to L or R in the parititon L/R...R/L\\n        //now check for all the 4 conditions\\n        \\n        //case 1 L....L , convert all to L \\n        if(arr[i]==\\'L\\' && arr[j]==\\'L\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'L\\';\\n            }\\n        }\\n        //case 2 R....R, convert all to R\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'R\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'R\\';\\n            }\\n        }\\n        \\n        //case 3 L...R, no change in middle;\\n        else if(arr[i]==\\'L\\' && arr[j]==\\'R\\')\\n        {\\n            //nothing to do\\n        }\\n        \\n        //case 4 R...L,check . are even or odd and do accordingly\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'L\\')\\n        {\\n            int diff=j-i;\\n            int mid=(j+i)/2;\\n            //case of odd dots, as positions are shifted\\n            if(diff%2==0)\\n            {\\n               for(int k=i+1;k<mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n            //case of even number of . so R....L converts to RRRLLL\\n            else\\n            {\\n                for(int k=i+1;k<=mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n        }\\n        \\n    }\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<char>arr(n+2);\\n        arr[0]=\\'L\\';\\n        arr[n+1]=\\'R\\';\\n        //L 1-String-n-2 R\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            arr[i]=dominoes[i-1];\\n            // cout<<arr[i];\\n        }\\n        \\n        int j=0;\\n        int k =1;\\n        //j->Lk->...L...R..LR..R -> K counts number of \\'.\\' and stops on L or R\\n        //in above case j will be at L and K will be at L so solve for L...L\\n        while(k<arr.size())\\n        {\\n            while(arr[k]==\\'.\\')\\n            {\\n                k++;\\n            }\\n            //solve only for cases like L...L , not for LL\\n            if(k-j>1)\\n            {\\n                solvefor(arr,j,k);\\n            }\\n            j=k;\\n            k++;\\n        }\\n        string ans=\"\";\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n}; \\n```\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    //adding L and R at ends do not change the configuration\\n    //we have to divide the total string into parts, thats why adding L and R at ends for cases like ...L..R...\\n    //parts can be : L...L , R...R, L...R, R...L\\n    //L...L->all dots inside it will become L\\n    //R...R-> all dots inside it  will become R\\n    //L...R-> all dots remains unchanged\\n    //R...L->if dots are even then half R half L\\n    //else mid remains unchanged and one half R and other half L\\n    void solvefor(vector<char>&arr,int i,int j)\\n    {\\n        // i and j are pointer pointing to L or R in the parititon L/R...R/L\\n        //now check for all the 4 conditions\\n        \\n        //case 1 L....L , convert all to L \\n        if(arr[i]==\\'L\\' && arr[j]==\\'L\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'L\\';\\n            }\\n        }\\n        //case 2 R....R, convert all to R\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'R\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'R\\';\\n            }\\n        }\\n        \\n        //case 3 L...R, no change in middle;\\n        else if(arr[i]==\\'L\\' && arr[j]==\\'R\\')\\n        {\\n            //nothing to do\\n        }\\n        \\n        //case 4 R...L,check . are even or odd and do accordingly\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'L\\')\\n        {\\n            int diff=j-i;\\n            int mid=(j+i)/2;\\n            //case of odd dots, as positions are shifted\\n            if(diff%2==0)\\n            {\\n               for(int k=i+1;k<mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n            //case of even number of . so R....L converts to RRRLLL\\n            else\\n            {\\n                for(int k=i+1;k<=mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n        }\\n        \\n    }\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<char>arr(n+2);\\n        arr[0]=\\'L\\';\\n        arr[n+1]=\\'R\\';\\n        //L 1-String-n-2 R\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            arr[i]=dominoes[i-1];\\n            // cout<<arr[i];\\n        }\\n        \\n        int j=0;\\n        int k =1;\\n        //j->Lk->...L...R..LR..R -> K counts number of \\'.\\' and stops on L or R\\n        //in above case j will be at L and K will be at L so solve for L...L\\n        while(k<arr.size())\\n        {\\n            while(arr[k]==\\'.\\')\\n            {\\n                k++;\\n            }\\n            //solve only for cases like L...L , not for LL\\n            if(k-j>1)\\n            {\\n                solvefor(arr,j,k);\\n            }\\n            j=k;\\n            k++;\\n        }\\n        string ans=\"\";\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "C++"
            },
            {
                "id": 1354390,
                "title": "c-3-approaches-commented-like-a-story-line-by-line-for-easy-understanding",
                "content": "```\\n//Approach-1 (O(n) time : Two Pointer Technique)\\n/*\\n\\tIn this approach, you just need to find sections like this\\n\\tX .   .   .   . X\\n\\ti                j\\n\\tWhere X can be \\'R\\' or \\'L\\' and in between there can be as many dots\\n\\tNow,\\n\\t- you know the length of mid part\\n\\t- If char[i] == char[j] == \\'R\\', means all go towards right (R)\\n\\t-  char[i]  == char[j] == \\'L\\', means all go towards Left (L)\\n\\t-  If char[i] = \\'L\\' and char[j] = \\'R\\', means middle part is not affected so the remain \\'.\\'\\n\\t-  If char[i] = \\'R\\' and char[j] = \\'L\\', then it will affect the middle part.\\n\\t   The middle_part/2 close to i will be affected by \\'R\\' and middle_part/2 close to j will be   \\n\\t   effected by \\'L\\'  and the last mid point (middle_part%2) will be unaffected due to equal  \\n\\t   force from left and right so it remains \\'.\\'\\n*/\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string s = \"L\" + dominoes + \"R\";\\n        int n    = s.length();\\n        string result = \"\";\\n        for(int i = 0, j = 1; j<n; j++) {\\n            if(s[j] == \\'.\\') continue;\\n            \\n            int midPartLength = j-i-1;\\n            if(i > 0)\\n                result.push_back(s[i]);\\n            \\n            if(s[i] == s[j])\\n                result += string(midPartLength, s[i]);\\n            else if(s[i] == \\'L\\' && s[j] == \\'R\\')\\n                result += string(midPartLength, \\'.\\');\\n            else\\n                result += string(midPartLength/2, \\'R\\') + string(midPartLength%2, \\'.\\') + string(midPartLength/2, \\'L\\');\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (O(n) time : Finding closest \\'L\\' and closest \\'R\\')\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> rightClosestL(n);\\n        vector<int> leftClosestR(n);\\n        \\n        //Moving right to left to find rightClosestL\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                rightClosestL[i] = i; //L starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                rightClosestL[i] = i < n-1 ? rightClosestL[i+1] : -1;\\n            else\\n                rightClosestL[i] = -1;\\n        }\\n        \\n        //Moving left to right to find leftClosestR\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                leftClosestR[i] = i; //R starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                leftClosestR[i] = i > 0 ? leftClosestR[i-1] : -1;\\n            else\\n                leftClosestR[i] = -1;\\n        }\\n        \\n        string result(n, \\' \\');\\n        \\n        for(int i = 0; i<n; i++) {\\n            int distRightL = abs(i-rightClosestL[i]); //distance from \\'R\\' towards my left direction\\n            int distLeftR  = abs(i-leftClosestR[i]);  //distance from \\'L\\' towards my right direction\\n            \\n            if(rightClosestL[i] == leftClosestR[i])\\n                result[i] = \\'.\\';\\n            else if(rightClosestL[i] == -1)  //No force from right direction towards left, so move R\\n                result[i] = \\'R\\';\\n            else if(leftClosestR[i] == -1)   //No force from left direction towards right, so move L\\n                result[i] = \\'L\\';\\n            else if(distLeftR == distRightL) //Equal force from left and right\\n                result[i] = \\'.\\';\\n            else\\n                result[i] = distRightL < distLeftR ? \\'L\\': \\'R\\'; //which ever force is greater (either from left by \\'R\\' or from right by \\'L\\') i.e. whichever is closer wins\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (O(n) time : Using Force Simulation)\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> forces(n);\\n        \\n        //Move from left to right and look for right force \\'R\\'\\n        int force = 0; //initially\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                force = n; //My max power towards Right starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'L\\')\\n                force = 0; //I can\\'t give force towards Right :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] = force;\\n        }\\n        \\n        //Move from right to left and look for left force \\'L\\'\\n        force = 0; //initially\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                force = n; //My max power towards Left starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'R\\')\\n                force = 0; //I can\\'t give force towards Left :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] -= force; //resultant force (that\\'s why I am subtracting)\\n        }\\n        \\n        //Now I will find resultant direction on each domino basis of resultant force on them\\n        string result(n ,\\' \\');\\n        for(int i = 0; i<n; i++) {\\n            if(forces[i] < 0)\\n                result[i] = \\'L\\';\\n            else if(forces[i] > 0)\\n                result[i] = \\'R\\';\\n            else\\n                result[i] = \\'.\\';\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (O(n) time : Two Pointer Technique)\\n/*\\n\\tIn this approach, you just need to find sections like this\\n\\tX .   .   .   . X\\n\\ti                j\\n\\tWhere X can be \\'R\\' or \\'L\\' and in between there can be as many dots\\n\\tNow,\\n\\t- you know the length of mid part\\n\\t- If char[i] == char[j] == \\'R\\', means all go towards right (R)\\n\\t-  char[i]  == char[j] == \\'L\\', means all go towards Left (L)\\n\\t-  If char[i] = \\'L\\' and char[j] = \\'R\\', means middle part is not affected so the remain \\'.\\'\\n\\t-  If char[i] = \\'R\\' and char[j] = \\'L\\', then it will affect the middle part.\\n\\t   The middle_part/2 close to i will be affected by \\'R\\' and middle_part/2 close to j will be   \\n\\t   effected by \\'L\\'  and the last mid point (middle_part%2) will be unaffected due to equal  \\n\\t   force from left and right so it remains \\'.\\'\\n*/\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string s = \"L\" + dominoes + \"R\";\\n        int n    = s.length();\\n        string result = \"\";\\n        for(int i = 0, j = 1; j<n; j++) {\\n            if(s[j] == \\'.\\') continue;\\n            \\n            int midPartLength = j-i-1;\\n            if(i > 0)\\n                result.push_back(s[i]);\\n            \\n            if(s[i] == s[j])\\n                result += string(midPartLength, s[i]);\\n            else if(s[i] == \\'L\\' && s[j] == \\'R\\')\\n                result += string(midPartLength, \\'.\\');\\n            else\\n                result += string(midPartLength/2, \\'R\\') + string(midPartLength%2, \\'.\\') + string(midPartLength/2, \\'L\\');\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (O(n) time : Finding closest \\'L\\' and closest \\'R\\')\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> rightClosestL(n);\\n        vector<int> leftClosestR(n);\\n        \\n        //Moving right to left to find rightClosestL\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                rightClosestL[i] = i; //L starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                rightClosestL[i] = i < n-1 ? rightClosestL[i+1] : -1;\\n            else\\n                rightClosestL[i] = -1;\\n        }\\n        \\n        //Moving left to right to find leftClosestR\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                leftClosestR[i] = i; //R starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                leftClosestR[i] = i > 0 ? leftClosestR[i-1] : -1;\\n            else\\n                leftClosestR[i] = -1;\\n        }\\n        \\n        string result(n, \\' \\');\\n        \\n        for(int i = 0; i<n; i++) {\\n            int distRightL = abs(i-rightClosestL[i]); //distance from \\'R\\' towards my left direction\\n            int distLeftR  = abs(i-leftClosestR[i]);  //distance from \\'L\\' towards my right direction\\n            \\n            if(rightClosestL[i] == leftClosestR[i])\\n                result[i] = \\'.\\';\\n            else if(rightClosestL[i] == -1)  //No force from right direction towards left, so move R\\n                result[i] = \\'R\\';\\n            else if(leftClosestR[i] == -1)   //No force from left direction towards right, so move L\\n                result[i] = \\'L\\';\\n            else if(distLeftR == distRightL) //Equal force from left and right\\n                result[i] = \\'.\\';\\n            else\\n                result[i] = distRightL < distLeftR ? \\'L\\': \\'R\\'; //which ever force is greater (either from left by \\'R\\' or from right by \\'L\\') i.e. whichever is closer wins\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-3 (O(n) time : Using Force Simulation)\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> forces(n);\\n        \\n        //Move from left to right and look for right force \\'R\\'\\n        int force = 0; //initially\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                force = n; //My max power towards Right starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'L\\')\\n                force = 0; //I can\\'t give force towards Right :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] = force;\\n        }\\n        \\n        //Move from right to left and look for left force \\'L\\'\\n        force = 0; //initially\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                force = n; //My max power towards Left starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'R\\')\\n                force = 0; //I can\\'t give force towards Left :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] -= force; //resultant force (that\\'s why I am subtracting)\\n        }\\n        \\n        //Now I will find resultant direction on each domino basis of resultant force on them\\n        string result(n ,\\' \\');\\n        for(int i = 0; i<n; i++) {\\n            if(forces[i] < 0)\\n                result[i] = \\'L\\';\\n            else if(forces[i] > 0)\\n                result[i] = \\'R\\';\\n            else\\n                result[i] = \\'.\\';\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352428,
                "title": "python-push-dominoes-really-simple-solution-o-n",
                "content": "Fully annotated code below but the idea behind it is:\\n - if we have no \\'collisions\\' then the dots in the middle will all be the same e.g. \\'L.....L\\' - all the dots will be \\'L\\', and vice versa for \\'R......R\\' all being \\'R\\'\\n - if we have a collision, then we attribute the dots in the middle evenly between \\'R\\' and \\'L\\' i.e. \\'R....L\\' becomes \\'RRRLLL\\'\\n - if we have a collision with an odd number of \\'.\\' then the middle element remains a \\'.\\'\\n - if we never have a collision e.g. \\'L....R\\' then we keep all the dots\\n\\nThe above allows us to walk through the array just once and add on what we need as we go.\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n\\t\\n        # init ans\\n        answer = \\'\\'\\n        # set up so we don\\'t need to worry about ends of loop\\n        dom = \\'L\\' + dominoes + \\'R\\'\\n        # trailing var of last non dot, to help us populate large swathes\\n        prev = 0\\n        for i in range(1, len(dom)):\\n            # if this element is a \\'.\\', then we don\\'t know what to do with it yet\\n            # so let\\'s just continue iterating on to the next element\\n            if dom[i] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\n            # if we are here then the current element is not a \\'.\\'\\n            # let\\'s update a var j to keep track of how many \\'.\\' we have passed\\n            j = i - prev - 1\\n\\t\\t\\t\\n            # now we add on the previous element to the answer\\n            # if still zero then we don\\'t add\\n            # this prevents adding on the \\'L\\' we added to dom\\n            # also this won\\'t get called for the final \\'R\\' we added as only prev\\n            if prev:\\n                answer += dom[prev]\\n\\t\\t\\t\\t\\n            # now let\\'s check if we have no conflict\\n            # e.g. if we had \\'L.....L\\' then we need to add on 5 L\\'s (also same for \\'R.....R\\')\\n            # the first \\'L\\' got appended in the above step of adding prev\\n            # and the next \\'L\\' will get appended in the next step\\n            if dom[prev] == dom[i]:\\n                answer += dom[prev]*j\\n\\t\\t\\t\\t\\n            # now what about the opposite\\n            # e.g. we have \\'L.....R\\' then we would never populate the middle\\n            # so we need to add on 5 \\'.\\'\\n            elif dom[prev] == \\'L\\' and dom[i] == \\'R\\':\\n                answer += \\'.\\'*j\\n\\t\\t\\t\\t\\n            # else we must be in a sitch where we have:\\n            # e.g. \\'R....L\\' and they collide\\n            # if we have an even number then we add on m/2 R then m/2 L\\n            # if we have an odd number then the middle element must be a \\'.\\'\\n            else:\\n                answer += \\'R\\'*(j//2) + \\'.\\'*(j%2) + \\'L\\'*(j//2)\\n\\t\\t\\t\\t\\n            # update our trailing var as this iteration the element was not \\'.\\'\\n            prev=i\\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n\\t\\n        # init ans\\n        answer = \\'\\'\\n        # set up so we don\\'t need to worry about ends of loop\\n        dom = \\'L\\' + dominoes + \\'R\\'\\n        # trailing var of last non dot, to help us populate large swathes\\n        prev = 0\\n        for i in range(1, len(dom)):\\n            # if this element is a \\'.\\', then we don\\'t know what to do with it yet\\n            # so let\\'s just continue iterating on to the next element\\n            if dom[i] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\n            # if we are here then the current element is not a \\'.\\'\\n            # let\\'s update a var j to keep track of how many \\'.\\' we have passed\\n            j = i - prev - 1\\n\\t\\t\\t\\n            # now we add on the previous element to the answer\\n            # if still zero then we don\\'t add\\n            # this prevents adding on the \\'L\\' we added to dom\\n            # also this won\\'t get called for the final \\'R\\' we added as only prev\\n            if prev:\\n                answer += dom[prev]\\n\\t\\t\\t\\t\\n            # now let\\'s check if we have no conflict\\n            # e.g. if we had \\'L.....L\\' then we need to add on 5 L\\'s (also same for \\'R.....R\\')\\n            # the first \\'L\\' got appended in the above step of adding prev\\n            # and the next \\'L\\' will get appended in the next step\\n            if dom[prev] == dom[i]:\\n                answer += dom[prev]*j\\n\\t\\t\\t\\t\\n            # now what about the opposite\\n            # e.g. we have \\'L.....R\\' then we would never populate the middle\\n            # so we need to add on 5 \\'.\\'\\n            elif dom[prev] == \\'L\\' and dom[i] == \\'R\\':\\n                answer += \\'.\\'*j\\n\\t\\t\\t\\t\\n            # else we must be in a sitch where we have:\\n            # e.g. \\'R....L\\' and they collide\\n            # if we have an even number then we add on m/2 R then m/2 L\\n            # if we have an odd number then the middle element must be a \\'.\\'\\n            else:\\n                answer += \\'R\\'*(j//2) + \\'.\\'*(j%2) + \\'L\\'*(j//2)\\n\\t\\t\\t\\t\\n            # update our trailing var as this iteration the element was not \\'.\\'\\n            prev=i\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083991,
                "title": "java-solution-two-pointers-beat-99",
                "content": "```\\n// Time complexity: O(N)\\n// Space complexity: O(N), where N is the length of input string\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // ask whether dominoes could be null\\n        final int N = dominoes.length();\\n        if (N <= 1) return dominoes;\\n        char[] res = dominoes.toCharArray();\\n        int i = 0;\\n        while (i < N) {\\n            if (res[i] == \\'.\\') {\\n                i++;\\n            } else if (res[i] == \\'L\\') {  // push left\\n                int j = i-1;\\n                while (j >= 0 && res[j] == \\'.\\') {\\n                    res[j--] = \\'L\\';\\n                }\\n                i++;\\n            } else { // res[i] == \\'R\\'\\n                int j = i+1;\\n                while (j < N && res[j] == \\'.\\') { // try to find \\'R\\' or \\'L\\' in the right side\\n                    j++;\\n                }\\n                if (j < N && res[j] == \\'L\\') { // if found \\'L\\', push left and right\\n                    for (int l = i+1, r = j-1; l < r; l++, r--) {\\n                        res[l] = \\'R\\';\\n                        res[r] = \\'L\\';\\n                    }\\n                    i = j + 1;\\n                } else {  // if no \\'L\\', push right\\n                    while (i < j) {\\n                        res[i++] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        return String.valueOf(res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity: O(N)\\n// Space complexity: O(N), where N is the length of input string\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // ask whether dominoes could be null\\n        final int N = dominoes.length();\\n        if (N <= 1) return dominoes;\\n        char[] res = dominoes.toCharArray();\\n        int i = 0;\\n        while (i < N) {\\n            if (res[i] == \\'.\\') {\\n                i++;\\n            } else if (res[i] == \\'L\\') {  // push left\\n                int j = i-1;\\n                while (j >= 0 && res[j] == \\'.\\') {\\n                    res[j--] = \\'L\\';\\n                }\\n                i++;\\n            } else { // res[i] == \\'R\\'\\n                int j = i+1;\\n                while (j < N && res[j] == \\'.\\') { // try to find \\'R\\' or \\'L\\' in the right side\\n                    j++;\\n                }\\n                if (j < N && res[j] == \\'L\\') { // if found \\'L\\', push left and right\\n                    for (int l = i+1, r = j-1; l < r; l++, r--) {\\n                        res[l] = \\'R\\';\\n                        res[r] = \\'L\\';\\n                    }\\n                    i = j + 1;\\n                } else {  // if no \\'L\\', push right\\n                    while (i < j) {\\n                        res[i++] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        return String.valueOf(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767282,
                "title": "c-brutally-nested-o-n-solution-98",
                "content": "This is essentially solution 1 of the editorial, just written in C++\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int start = 0;\\n        int l = 0;\\n        string ans = s;\\n        for(int i=0; i<s.size(); i++) {\\n            if (l == 0 && s[i] == \\'.\\') {\\n                start = i;\\n                l++;\\n            } else if ( l > 0 && s[i] == \\'.\\') {\\n                l++;\\n            } else if (s[i] != \\'.\\' && l > 0) {\\n                if (start == 0) {\\n                    if (s[start+l] == \\'L\\') for(int i=start; i<start+l; i++) s[i] = \\'L\\';\\n                } else {\\n                    if (s[start-1] == s[start+l]) {\\n                        for(int i=start; i<start+l; i++) s[i] = s[start-1];\\n                    }\\n                    else {\\n                        if (l&1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>start + l/2; i--) s[i] =\\'L\\';\\n                        }else if ((l&1)^1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<=start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>=start + l/2; i--) s[i] =\\'L\\';\\n                        }\\n                    }\\n                }\\n                l = 0;\\n                start = -1;\\n            }\\n        }\\n        // last part\\n        if (l > 0) {\\n            if (start != 0 && s[start-1] == \\'R\\') {\\n                for(int i=start; i<start + l; i++) {\\n                    s[i] = \\'R\\';\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int start = 0;\\n        int l = 0;\\n        string ans = s;\\n        for(int i=0; i<s.size(); i++) {\\n            if (l == 0 && s[i] == \\'.\\') {\\n                start = i;\\n                l++;\\n            } else if ( l > 0 && s[i] == \\'.\\') {\\n                l++;\\n            } else if (s[i] != \\'.\\' && l > 0) {\\n                if (start == 0) {\\n                    if (s[start+l] == \\'L\\') for(int i=start; i<start+l; i++) s[i] = \\'L\\';\\n                } else {\\n                    if (s[start-1] == s[start+l]) {\\n                        for(int i=start; i<start+l; i++) s[i] = s[start-1];\\n                    }\\n                    else {\\n                        if (l&1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>start + l/2; i--) s[i] =\\'L\\';\\n                        }else if ((l&1)^1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<=start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>=start + l/2; i--) s[i] =\\'L\\';\\n                        }\\n                    }\\n                }\\n                l = 0;\\n                start = -1;\\n            }\\n        }\\n        // last part\\n        if (l > 0) {\\n            if (start != 0 && s[start-1] == \\'R\\') {\\n                for(int i=start; i<start + l; i++) {\\n                    s[i] = \\'R\\';\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558273,
                "title": "two-pointers-c-30ms-solution",
                "content": "# Intuition\\n1) Can not use stack considering the testcase when one Domino is falling towards **Right** and one Domino is falling towards **Left**. Here we need to move half of the dominos fall Right and half fall Left in between these two dominos.\\n2) Whereas, rest of the dominos either continously fall Left or Right.\\n3) Using two pointers can handle all type of testcases\\n\\n\\n# Approach\\n1) The dominos group can be divided as:\\n   a) **. L**\\n   b) **. R**\\n   c) **L .**\\n   d) **R .**\\n   e) **L R**\\n   f) **R L**\\n   g) **L L**\\n   h) **R R**\\n2) The case where half of the in-between dominos fall left and half right comes under -> **R L** group.\\n3) Other groups can be handled in a **monotonous** way.\\n4) By using **two pointers**, we observe if the **current index** (j) is R or L, if it is R then we observe the **previous index** (i) which shows the group(from the above group table) the pointers i & j refer to.\\n5) So, if the pair **{ i, j }** belongs to:\\n a) **. L** - run a loop from i to j and fill with \\'L\\'\\n b) **. R** - do nothing ( even if vertical dominos are in-between)\\n c) **L .** - do nothing ( even if vertical dominos are in-between)\\n d) **R .** - run a loop from i to j and fill with \\'R\\'\\n e) **L R** - do nothing ( even if vertical dominos are in-between)\\n f) **R L** - calculate the distance between i and j to first distribute half indices to \\'R\\' and then half indices to \\'L\\'. If there is odd no. of spaces available, we need to skip the middle domino as it is self-balanced.\\n g) **L L** - run a loop from i to j and fill with \\'L\\'\\n h) **R R** - run a loop from i to j and fill with \\'R\\'\\n\\n# Complexity\\n- Time complexity:\\n **O(n+k) ~ O(n)**\\n where **n** is for traversing the string and **k** is for traversing to fill substrings with \\'L\\' and \\'R\\'\\n\\n- Space complexity:\\n**O(1)** - Since no additional space is required to store\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        int i=0,j=0,n=dom.size();\\n        while(i<n){\\n            int j=i;\\n            int solA = -1, solB = -1, solC = -1, solD = -1;\\n            while(j<n){\\n                if(dom[j]==\\'L\\'){\\n                    if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'.\\' || dom[i]==\\'L\\'){\\n                        // L to be inserted to the left till i\\n                        solA = 1;\\n                        break;\\n                    }\\n                    else{\\n                        // half R and half L to be inserted\\n                        solC = 1;\\n                        break;\\n                    }\\n                }\\n                else if(dom[j]==\\'R\\'){\\n                     if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'R\\'){\\n                        // fill R from i to j\\n                        solB = 1;\\n                        // cout<<i<<\" \"<<j<<endl;\\n                        break;\\n                    }\\n                    // move i to curr pos of j\\n                    i=j;\\n                    break;\\n                }\\n                else if(j==n-1 && dom[j]==\\'.\\'){\\n                    if(dom[i]==\\'R\\'){\\n                        solD=1;\\n                        break;\\n                    }\\n                }\\n                j++;\\n            }\\n            // cout<<endl;\\n            if(solA==1){\\n                // inserting L\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'L\\';\\n            }\\n            if(solB==1){\\n                // inserting R\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'R\\';\\n            }\\n            if(solC==1){\\n                int k=i+(j-i-1)/2;\\n                for(int z=i;z<=k && z<n;z++) dom[z]=\\'R\\';\\n                for(int z=j;z>=(j-k+i) && z>0;z--) dom[z]=\\'L\\';\\n            }\\n            if(solD==1){\\n                for(int z=i;z<n;z++) dom[z]=\\'R\\';\\n            }\\n            i=j;\\n        }\\n        return dom;\\n    }\\n};\\n```\\n\\nDo upvote the solution, if understood the solution \\uD83D\\uDE0A\\nDo comment if finding difficult to understand any step.",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        int i=0,j=0,n=dom.size();\\n        while(i<n){\\n            int j=i;\\n            int solA = -1, solB = -1, solC = -1, solD = -1;\\n            while(j<n){\\n                if(dom[j]==\\'L\\'){\\n                    if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'.\\' || dom[i]==\\'L\\'){\\n                        // L to be inserted to the left till i\\n                        solA = 1;\\n                        break;\\n                    }\\n                    else{\\n                        // half R and half L to be inserted\\n                        solC = 1;\\n                        break;\\n                    }\\n                }\\n                else if(dom[j]==\\'R\\'){\\n                     if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'R\\'){\\n                        // fill R from i to j\\n                        solB = 1;\\n                        // cout<<i<<\" \"<<j<<endl;\\n                        break;\\n                    }\\n                    // move i to curr pos of j\\n                    i=j;\\n                    break;\\n                }\\n                else if(j==n-1 && dom[j]==\\'.\\'){\\n                    if(dom[i]==\\'R\\'){\\n                        solD=1;\\n                        break;\\n                    }\\n                }\\n                j++;\\n            }\\n            // cout<<endl;\\n            if(solA==1){\\n                // inserting L\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'L\\';\\n            }\\n            if(solB==1){\\n                // inserting R\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'R\\';\\n            }\\n            if(solC==1){\\n                int k=i+(j-i-1)/2;\\n                for(int z=i;z<=k && z<n;z++) dom[z]=\\'R\\';\\n                for(int z=j;z>=(j-k+i) && z>0;z--) dom[z]=\\'L\\';\\n            }\\n            if(solD==1){\\n                for(int z=i;z<n;z++) dom[z]=\\'R\\';\\n            }\\n            i=j;\\n        }\\n        return dom;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2795580,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630796,
                "title": "easy-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<dominoes.size();i++) {\\n            if(dominoes[i]==\\'L\\')\\n                q.push({0,i});\\n            else if(dominoes[i]==\\'R\\')\\n                q.push({2,i});\\n        }\\n        while(!q.empty()) {\\n            int size=q.size();\\n            unordered_map<int,char> um;\\n            for(int i=0;i<size;i++) {\\n                int side=q.front().first;\\n                int idx=q.front().second;\\n                q.pop();\\n                if(side==0 && idx-1>=0) {\\n                    if(dominoes[idx-1]==\\'.\\') {\\n                        if(um.find(idx-1)!=um.end())\\n                            um[idx-1]=\\'.\\';\\n                        else {\\n                            um[idx-1]=\\'L\\';\\n                            q.push({0,idx-1});\\n                        }\\n                    }\\n                } else if(side==2 && idx+1<=dominoes.size()-1) {\\n                    if(dominoes[idx+1]==\\'.\\') {\\n                        if(um.find(idx+1)!=um.end())\\n                            um[idx+1]=\\'.\\';\\n                        else {\\n                            um[idx+1]=\\'R\\';\\n                            q.push({2,idx+1});\\n                        }\\n                    }\\n                }\\n            }\\n            for(auto x:um)\\n                dominoes[x.first]=x.second;\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<dominoes.size();i++) {\\n            if(dominoes[i]==\\'L\\')\\n                q.push({0,i});\\n            else if(dominoes[i]==\\'R\\')\\n                q.push({2,i});\\n        }\\n        while(!q.empty()) {\\n            int size=q.size();\\n            unordered_map<int,char> um;\\n            for(int i=0;i<size;i++) {\\n                int side=q.front().first;\\n                int idx=q.front().second;\\n                q.pop();\\n                if(side==0 && idx-1>=0) {\\n                    if(dominoes[idx-1]==\\'.\\') {\\n                        if(um.find(idx-1)!=um.end())\\n                            um[idx-1]=\\'.\\';\\n                        else {\\n                            um[idx-1]=\\'L\\';\\n                            q.push({0,idx-1});\\n                        }\\n                    }\\n                } else if(side==2 && idx+1<=dominoes.size()-1) {\\n                    if(dominoes[idx+1]==\\'.\\') {\\n                        if(um.find(idx+1)!=um.end())\\n                            um[idx+1]=\\'.\\';\\n                        else {\\n                            um[idx+1]=\\'R\\';\\n                            q.push({2,idx+1});\\n                        }\\n                    }\\n                }\\n            }\\n            for(auto x:um)\\n                dominoes[x.first]=x.second;\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630519,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int>time(n, 0);\\n        bool prev{false};\\n        for(int i = n - 1; i >= 0; i--){\\n            if(prev){\\n                if(s[i] == \\'.\\'){\\n                    time[i] = time[i+1] + 1;\\n                    s[i] = \\'L\\';\\n                }\\n                else if(s[i] == \\'R\\'){\\n                    prev = false;\\n                }\\n            }\\n            else{\\n                if(s[i] == \\'L\\'){\\n                    prev = true;\\n                }\\n            }\\n        }\\n        prev = false;\\n        for(int i = 0; i < n; i++){\\n            if(prev){\\n                if(s[i] == \\'.\\'){\\n                    s[i] = \\'R\\';\\n                    time[i] = time[i-1] + 1;\\n                }\\n                else if(s[i] == \\'L\\'){\\n                    if(time[i-1] + 1 == time[i]){\\n                        s[i] = \\'.\\';\\n                        prev = false;\\n                    }\\n                    else{\\n                        if(time[i-1] + 1 < time[i]){\\n                            s[i] = \\'R\\';\\n                            time[i] = time[i-1] + 1;\\n                        }\\n                        else{\\n                            prev = false;\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n                if(s[i] == \\'R\\'){\\n                    prev = true;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int>time(n, 0);\\n        bool prev{false}",
                "codeTag": "Java"
            },
            {
                "id": 2630428,
                "title": "easy-to-understand-o-n-o-n-solution-very-intuitive-solution",
                "content": "**Approach:**\\nSo what we need to do is just focus on the dominoes which are standing upright i.e. \\' . \\' Now if we are at a upright domino we need to know how far is a domino towards left which was pushed right and how far is a domnio which was pushed to the left. We can do this for every domino but this makes our work easier as we can just store the required distances in two arrays.\\n\\nLet\\'s see how the algorithm works\\n\\nFirst we walk from left to right\\n* If we find a domino which is pushed towards Left \\' L \\' we know this can never affect the dominoes on right so we mark our flag as false\\n* If we find a domino which is pushed towards right \\'R\\' we know this can affect the dominoes on the right side and thus we start a fresh count from zero.\\n* If we find a domino which is upright we change its value to count only if there was a Right earlier to it which is indicated by flag variable.\\n\\nSimilarly we walk from right to left and make a similar array.\\n\\nFinally we move from left to right and if we find an upright domino we check the distance of left and right domino and which ever is less we change our values accordingly.\\n\\nThe key point to note here is that only the values of the upright dominoes will change and thus we update our left and right arrays only at those positions.\\n\\n\\n\\nThe left and right are initialised with INT_MAX so as to account for unavalaibitiy of the required push.\\n\\nC++ code:\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n,INT_MAX);\\n        int count = 0;\\n        bool flag = false;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    left[i]=count;\\n                }\\n            }\\n        }\\n        vector<int> right(n,INT_MAX);\\n        flag = false;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    right[i]=count;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                if(left[i]<right[i])\\n                    dominoes[i]=\\'R\\';\\n                else if(left[i]>right[i])\\n                    dominoes[i]=\\'L\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```\\n\\nIf you reached till here please upvote this solution",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n,INT_MAX);\\n        int count = 0;\\n        bool flag = false;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    left[i]=count;\\n                }\\n            }\\n        }\\n        vector<int> right(n,INT_MAX);\\n        flag = false;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    right[i]=count;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                if(left[i]<right[i])\\n                    dominoes[i]=\\'R\\';\\n                else if(left[i]>right[i])\\n                    dominoes[i]=\\'L\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630312,
                "title": "tc-sc-o-n-c-easy-solution",
                "content": "```\\n//TC=O(N)\\n//SC=O(N)\\n\\nclass Solution {\\npublic:\\n    void helper(vector<char> &arr, int j, int k){ // there are 4 conditions as follows\\n        if(arr[j]==\\'L\\' && arr[k]==\\'L\\') \\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'L\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'R\\')\\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'R\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'L\\')\\n            while(j!=k && j<k){\\n                arr[j++]=\\'R\\', arr[k--]=\\'L\\';\\n            }\\n        else j=k++;\\n    }\\n\\t\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        \\n\\t\\tvector<char> arr(n+2); //create a vector of size n+2 and make the 1st and last element \\'L\\' and \\'R\\' respectively\\n        arr[0] = \\'L\\';\\n        arr[n+1] = \\'R\\';\\n        \\n        for (int i=1; i < arr.size()-1; i++) //make elements from index 1 to second last index of vector as string characters \\n            arr[i]=dominoes[i - 1];\\n        \\n        int j=0;// keep 2 pointers j and k to find \\'L\\' and \\'R\\' in the vector\\n        int k=1;\\n        \\n        while (k < arr.size()){\\n            while(arr[k] == \\'.\\')\\n                k++;\\n            helper(arr, j, k);// call the helper function to modify the vector\\n            j=k++;\\n        }\\n\\t\\t\\n        string str=\"\";// after the vector is modified add indexes 1 to second last element of vector in a string and return it\\n        for(int i=1; i<arr.size()-1; i++){\\n            str+=arr[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//TC=O(N)\\n//SC=O(N)\\n\\nclass Solution {\\npublic:\\n    void helper(vector<char> &arr, int j, int k){ // there are 4 conditions as follows\\n        if(arr[j]==\\'L\\' && arr[k]==\\'L\\') \\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'L\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'R\\')\\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'R\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'L\\')\\n            while(j!=k && j<k){\\n                arr[j++]=\\'R\\', arr[k--]=\\'L\\';\\n            }\\n        else j=k++;\\n    }\\n\\t\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        \\n\\t\\tvector<char> arr(n+2); //create a vector of size n+2 and make the 1st and last element \\'L\\' and \\'R\\' respectively\\n        arr[0] = \\'L\\';\\n        arr[n+1] = \\'R\\';\\n        \\n        for (int i=1; i < arr.size()-1; i++) //make elements from index 1 to second last index of vector as string characters \\n            arr[i]=dominoes[i - 1];\\n        \\n        int j=0;// keep 2 pointers j and k to find \\'L\\' and \\'R\\' in the vector\\n        int k=1;\\n        \\n        while (k < arr.size()){\\n            while(arr[k] == \\'.\\')\\n                k++;\\n            helper(arr, j, k);// call the helper function to modify the vector\\n            j=k++;\\n        }\\n\\t\\t\\n        string str=\"\";// after the vector is modified add indexes 1 to second last element of vector in a string and return it\\n        for(int i=1; i<arr.size()-1; i++){\\n            str+=arr[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630169,
                "title": "may-the-force-be-with-you-easy-short-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size(); \\n        vector<pair<int,int>> dp(n,{0,0});\\n        // first domino to be dropped towards right , will be from left start!\\n       // beacuse all other dominoes next inline would depend on it!\\n        for(int i=0; i<n; i++) {\\n             if(s[i] == \\'R\\') {\\n                  dp[i].second = 1;\\n             }else if(s[i] == \\'.\\' && i) {\\n                  dp[i].second = dp[i-1].second ? 1 + dp[i-1].second : 0;\\n             }\\n        }\\n        // first domino to be dropped towards left , will be from far right!\\n       // because all other dominoes next inline would depend on it!\\n        for(int i=n-1; i>=0; i--) {\\n              if(s[i] == \\'L\\') {\\n                   dp[i].first = 1;\\n              }else if(s[i] == \\'.\\' && i+1<n) {\\n                   dp[i].first = dp[i+1].first ? 1 + dp[i+1].first : 0;\\n              }\\n        }\\n        for(int i=0; i<n; i++) {\\n             if(dp[i].second == 0 || dp[i].first == 0) {\\n                  s[i] = dp[i].second ? \\'R\\' : dp[i].first ? \\'L\\' : \\'.\\';  // current force direction!\\n             }else if(dp[i].first < dp[i].second) {\\n                  s[i] = \\'L\\';   // if left has a force near than right direction!\\n             }else if(dp[i].second < dp[i].first) {\\n                  s[i] = \\'R\\';  // if right has a force near than left direction!\\n             }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size(); \\n        vector<pair<int,int>> dp(n,{0,0});\\n        // first domino to be dropped towards right , will be from left start!\\n       // beacuse all other dominoes next inline would depend on it!\\n        for(int i=0; i<n; i++) {\\n             if(s[i] == \\'R\\') {\\n                  dp[i].second = 1;\\n             }else if(s[i] == \\'.\\' && i) {\\n                  dp[i].second = dp[i-1].second ? 1 + dp[i-1].second : 0;\\n             }\\n        }\\n        // first domino to be dropped towards left , will be from far right!\\n       // because all other dominoes next inline would depend on it!\\n        for(int i=n-1; i>=0; i--) {\\n              if(s[i] == \\'L\\') {\\n                   dp[i].first = 1;\\n              }else if(s[i] == \\'.\\' && i+1<n) {\\n                   dp[i].first = dp[i+1].first ? 1 + dp[i+1].first : 0;\\n              }\\n        }\\n        for(int i=0; i<n; i++) {\\n             if(dp[i].second == 0 || dp[i].first == 0) {\\n                  s[i] = dp[i].second ? \\'R\\' : dp[i].first ? \\'L\\' : \\'.\\';  // current force direction!\\n             }else if(dp[i].first < dp[i].second) {\\n                  s[i] = \\'L\\';   // if left has a force near than right direction!\\n             }else if(dp[i].second < dp[i].first) {\\n                  s[i] = \\'R\\';  // if right has a force near than left direction!\\n             }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629854,
                "title": "o-n-easy-solution-to-be-noted",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n=dominoes.length(),i,j=Integer.MIN_VALUE;\\n        char dom[]=dominoes.toCharArray(), res[]=new char[n];\\n        boolean r = false,l=true;\\n        for(i=0;i<n;i++){\\n            res[i]=dom[i];\\n            if(dom[i]==\\'L\\'){\\n                if(l){ \\n                    fill(j,i,res,0,-1);\\n                    if(j>=0) res[j]=\\'L\\';\\n                }\\n                else fill(j,i,res,1,-1);\\n                l=true;\\n                j=i;\\n            }else if(dom[i]==\\'R\\' || i==n-1){\\n                if(!l){\\n                    fill(j,i,res,1,0);\\n                    res[i]=\\'R\\';\\n                }\\n                j=i;\\n                l=false;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    void fill(int j, int i, char[] res, int incrj, int incri){\\n        for(;j<i && i>=0;j+=incrj,i+=incri){\\n            if(j>=0) res[j]=\\'R\\';\\n            res[i]=\\'L\\';\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n=dominoes.length(),i,j=Integer.MIN_VALUE;\\n        char dom[]=dominoes.toCharArray(), res[]=new char[n];\\n        boolean r = false,l=true;\\n        for(i=0;i<n;i++){\\n            res[i]=dom[i];\\n            if(dom[i]==\\'L\\'){\\n                if(l){ \\n                    fill(j,i,res,0,-1);\\n                    if(j>=0) res[j]=\\'L\\';\\n                }\\n                else fill(j,i,res,1,-1);\\n                l=true;\\n                j=i;\\n            }else if(dom[i]==\\'R\\' || i==n-1){\\n                if(!l){\\n                    fill(j,i,res,1,0);\\n                    res[i]=\\'R\\';\\n                }\\n                j=i;\\n                l=false;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    void fill(int j, int i, char[] res, int incrj, int incri){\\n        for(;j<i && i>=0;j+=incrj,i+=incri){\\n            if(j>=0) res[j]=\\'R\\';\\n            res[i]=\\'L\\';\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629294,
                "title": "python3-multi-source-bfs",
                "content": "I know that a lot of great solutions have been discussed in the discussion, but I want to share mine as well -- a multi-source BFS solution.\\n\\nThe idea is pretty straightforward, we first add all position where the initial forces happen (i.e. add all \"L\" and \"R\"), and then does BFS.\\n\\nNotice that we need to take special care of collisions, so we need to modify BFS a littile bit. Here is my solution.\\n\\nSpace Complexity: O(N) because each position will only be added to the queue or to the collision dictionary once.\\nTime Complexity: O(N) because we loop through each element once.\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        ans = [\\'.\\' for _ in range(len(dominoes))]\\n\\n        queue = deque()\\n        for i, d in enumerate(dominoes):\\n            if d == \\'L\\' or d == \\'R\\':\\n                queue.append((i, d))\\n            ans[i] = d\\n        \\n        while queue:\\n            size = len(queue)\\n            collision = defaultdict(list)\\n            for _ in range(size):\\n                i, d = queue.popleft()\\n                if d == \\'L\\' and i - 1 >= 0 and ans[i - 1] == \\'.\\':\\n                    collision[i - 1].append(\\'L\\')\\n                elif d == \\'R\\' and i + 1 < len(ans) and ans[i + 1] == \\'.\\':\\n                    collision[i + 1].append(\\'R\\')\\n            for pos in collision:\\n                if len(collision[pos]) == 2:\\n                    ans[pos] = \\'.\\'\\n                else:\\n                    ans[pos] = collision[pos][0]\\n                    queue.append((pos, collision[pos][0]))\\n                \\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        ans = [\\'.\\' for _ in range(len(dominoes))]\\n\\n        queue = deque()\\n        for i, d in enumerate(dominoes):\\n            if d == \\'L\\' or d == \\'R\\':\\n                queue.append((i, d))\\n            ans[i] = d\\n        \\n        while queue:\\n            size = len(queue)\\n            collision = defaultdict(list)\\n            for _ in range(size):\\n                i, d = queue.popleft()\\n                if d == \\'L\\' and i - 1 >= 0 and ans[i - 1] == \\'.\\':\\n                    collision[i - 1].append(\\'L\\')\\n                elif d == \\'R\\' and i + 1 < len(ans) and ans[i + 1] == \\'.\\':\\n                    collision[i + 1].append(\\'R\\')\\n            for pos in collision:\\n                if len(collision[pos]) == 2:\\n                    ans[pos] = \\'.\\'\\n                else:\\n                    ans[pos] = collision[pos][0]\\n                    queue.append((pos, collision[pos][0]))\\n                \\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629285,
                "title": "java-using-two-dp-array",
                "content": "DP solution is not best for this question but i just want to share my idea\\nFirst we creat two dp array, in the right dp ,\\nIf at Index i we have \\'L\\' then dp[i] = 0;\\nIf at Index i we have \\'R\\' then dp[i] = 1;\\nIf at Index i we have \\'.\\' then if dp[i - 1] is postive , dp[i] = dp[i - 1] + 1, else dp[i] = 0;\\nwe do the same thing with the left dp\\nnow we have two dp array, so we can get the answer we want.\\n```\\n.   L .  R  .  .  .  L  R  .  .  L  .  .\\n0  0  0  1  2  3  4  0  1  2  3  0  0  0             right\\n-2 -1 0  0 -4 -3 -2 -1  0 -3 -2 -1  0  0             left\\n```\\nbut we still have two case here.\\ncase 1 Either left or right is 0\\n\\t\\tso, if left[i] + right[i] < 0 is left, > 0 is right\\ncase 2 Neither left nor right is 0\\n\\t\\tin this case, if left[i] + right[i] < 0 means close to right beacse we start from 1 and we have 2 3 4 5 6 the smaller the number, the closer the distance. so it is R\\n\\t\\t if left[i] + right[i] > 0 it is L\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        for (int i = 0; i < left.length; i++) {\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                right[i] = 1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == 0) continue;\\n                if (right[i - 1] > 0) {\\n                    right[i] = right[i - 1] + 1;\\n                }\\n                continue;\\n            }\\n        }\\n        for (int i = right.length - 1; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                left[i] = -1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == right.length - 1) continue;\\n                if (left[i + 1] < 0) {\\n                    left[i] = left[i + 1] - 1;\\n                }\\n                continue;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < left.length; i++) {\\n            if (left[i] + right[i] == 0) {\\n                sb.append(\\'.\\');\\n            }else if (left[i] == 0 || right[i] == 0){\\n                if (left[i] + right[i] < 0) {\\n                    sb.append(\\'L\\');\\n                }else {\\n                    sb.append(\\'R\\');\\n                }\\n            }else if (left[i] + right[i] < 0) {\\n                sb.append(\\'R\\');\\n            }else {\\n                sb.append(\\'L\\');\\n            }\\n            System.out.print(left[i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n.   L .  R  .  .  .  L  R  .  .  L  .  .\\n0  0  0  1  2  3  4  0  1  2  3  0  0  0             right\\n-2 -1 0  0 -4 -3 -2 -1  0 -3 -2 -1  0  0             left\\n```\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        for (int i = 0; i < left.length; i++) {\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                right[i] = 1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == 0) continue;\\n                if (right[i - 1] > 0) {\\n                    right[i] = right[i - 1] + 1;\\n                }\\n                continue;\\n            }\\n        }\\n        for (int i = right.length - 1; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                left[i] = -1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == right.length - 1) continue;\\n                if (left[i + 1] < 0) {\\n                    left[i] = left[i + 1] - 1;\\n                }\\n                continue;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < left.length; i++) {\\n            if (left[i] + right[i] == 0) {\\n                sb.append(\\'.\\');\\n            }else if (left[i] == 0 || right[i] == 0){\\n                if (left[i] + right[i] < 0) {\\n                    sb.append(\\'L\\');\\n                }else {\\n                    sb.append(\\'R\\');\\n                }\\n            }else if (left[i] + right[i] < 0) {\\n                sb.append(\\'R\\');\\n            }else {\\n                sb.append(\\'L\\');\\n            }\\n            System.out.print(left[i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629222,
                "title": "two-pointers-approach-c-space-less-than-80-submission",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Divided into following cases\\n    // L..R -> Stable\\n    // R..L -> Compart (equal no of rights and lefts)\\n    // L..L -> Leftwards\\n    // R..R -> Rightwards\\n    // ..R  -> Left part stable\\n    // ..L  -> Leftwards\\n    // L..  -> Right part stable\\n    // R..  -> Rightwards\\n    \\n    string pushDominoes(string dominoes) {\\n        string res;\\n        \\n        int l = 0;\\n        int r;\\n        \\n        int n = dominoes.size();\\n        \\n        int len;\\n        \\n        // Left is initiated with 0\\n        // Traversing the string with r\\n        \\n        for(r=0; r<n; r++){\\n            char curr = dominoes[r];\\n            \\n            if(curr == \\'L\\'){\\n                // can be a compart, left\\n                \\n                if(dominoes[l] == \\'R\\'){\\n                    // compart\\n                    res.push_back(\\'R\\');\\n                    len = r-l-1;\\n                    \\n                    int adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'R\\');\\n\\n                    if(len%2 == 1)\\n                        res.push_back(\\'.\\');\\n                    \\n                    adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'L\\');\\n                }else{\\n                    // left side\\n                    // both LL and .L\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'L\\');\\n                }\\n                \\n                l = r;\\n            }else if(curr == \\'R\\'){\\n                if(dominoes[l] == \\'L\\'){\\n                    // stable\\n                    res.push_back(\\'L\\');\\n                    len = r-l-1;\\n                    \\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }else if(dominoes[l] == \\'R\\'){\\n                    // right side\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'R\\');\\n                }else{\\n                    // . and R\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }\\n                \\n                l = r;\\n            }else\\n                continue;\\n        }\\n        \\n        \\n        // considering the last pair of l and r\\n        char curr = dominoes[l];\\n        r = n-1;\\n        \\n        len = r-l+1;\\n        \\n        if(curr == \\'R\\'){\\n            // Rightwards\\n            while(len--)\\n                res.push_back(\\'R\\');\\n        }else{ // L and . case\\n            for(int i=l; i<n; i++)\\n                res.push_back(dominoes[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Divided into following cases\\n    // L..R -> Stable\\n    // R..L -> Compart (equal no of rights and lefts)\\n    // L..L -> Leftwards\\n    // R..R -> Rightwards\\n    // ..R  -> Left part stable\\n    // ..L  -> Leftwards\\n    // L..  -> Right part stable\\n    // R..  -> Rightwards\\n    \\n    string pushDominoes(string dominoes) {\\n        string res;\\n        \\n        int l = 0;\\n        int r;\\n        \\n        int n = dominoes.size();\\n        \\n        int len;\\n        \\n        // Left is initiated with 0\\n        // Traversing the string with r\\n        \\n        for(r=0; r<n; r++){\\n            char curr = dominoes[r];\\n            \\n            if(curr == \\'L\\'){\\n                // can be a compart, left\\n                \\n                if(dominoes[l] == \\'R\\'){\\n                    // compart\\n                    res.push_back(\\'R\\');\\n                    len = r-l-1;\\n                    \\n                    int adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'R\\');\\n\\n                    if(len%2 == 1)\\n                        res.push_back(\\'.\\');\\n                    \\n                    adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'L\\');\\n                }else{\\n                    // left side\\n                    // both LL and .L\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'L\\');\\n                }\\n                \\n                l = r;\\n            }else if(curr == \\'R\\'){\\n                if(dominoes[l] == \\'L\\'){\\n                    // stable\\n                    res.push_back(\\'L\\');\\n                    len = r-l-1;\\n                    \\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }else if(dominoes[l] == \\'R\\'){\\n                    // right side\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'R\\');\\n                }else{\\n                    // . and R\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }\\n                \\n                l = r;\\n            }else\\n                continue;\\n        }\\n        \\n        \\n        // considering the last pair of l and r\\n        char curr = dominoes[l];\\n        r = n-1;\\n        \\n        len = r-l+1;\\n        \\n        if(curr == \\'R\\'){\\n            // Rightwards\\n            while(len--)\\n                res.push_back(\\'R\\');\\n        }else{ // L and . case\\n            for(int i=l; i<n; i++)\\n                res.push_back(dominoes[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628809,
                "title": "javascript-solution",
                "content": "```\\nvar pushDominoes = function(dominoes) {\\n    let start=0; \\n    let end=1;\\n    const arr = (\"L\"+ dominoes +\"R\").split(\"\");\\n    while(start < arr.length-1){\\n        while(arr[end]==\\'.\\') \\n            end++;\\n        if(arr[start] == arr[end]) \\n            for(let i= start+1; i<end; i++) {\\n                arr[i]=arr[start];   \\n            }\\n        if(arr[start]>arr[end]) \\n            for(let i=1; i<=(end-start-1)/2; i++){\\n                arr[start+i] = \\'R\\';\\n                arr[end-i] = \\'L\\';\\n            }   \\n        start=end++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar pushDominoes = function(dominoes) {\\n    let start=0; \\n    let end=1;\\n    const arr = (\"L\"+ dominoes +\"R\").split(\"\");\\n    while(start < arr.length-1){\\n        while(arr[end]==\\'.\\') \\n            end++;\\n        if(arr[start] == arr[end]) \\n            for(let i= start+1; i<end; i++) {\\n                arr[i]=arr[start];   \\n            }\\n        if(arr[start]>arr[end]) \\n            for(let i=1; i<=(end-start-1)/2; i++){\\n                arr[start+i] = \\'R\\';\\n                arr[end-i] = \\'L\\';\\n            }   \\n        start=end++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2628772,
                "title": "java-simple-easy-to-understand-using-array-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length();\\n        char[] arr = s.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && arr[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = arr[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        arr[l]=\\'R\\';\\n                        arr[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        arr[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        arr[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length();\\n        char[] arr = s.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && arr[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = arr[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        arr[l]=\\'R\\';\\n                        arr[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        arr[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        arr[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053804,
                "title": "simple-ruby-string-replace-in-one-line",
                "content": "One line solution:\\n```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = dominoes.gsub(\\'R.L\\', \\'|\\').gsub(\\'.L\\', \\'LL\\').gsub(\\'R.\\', \\'RR\\').gsub(\\'|\\', \\'R.L\\') }\\nend\\n```\\n\\nCan also write in much more readable form:\\n```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = execute(dominoes) }\\nend\\n\\ndef execute(dominoes)\\n    dominoes\\n    .gsub(\\'R.L\\', \\'|\\')\\n    .gsub(\\'.L\\', \\'LL\\')\\n    .gsub(\\'R.\\', \\'RR\\')\\n    .gsub(\\'|\\', \\'R.L\\')\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = dominoes.gsub(\\'R.L\\', \\'|\\').gsub(\\'.L\\', \\'LL\\').gsub(\\'R.\\', \\'RR\\').gsub(\\'|\\', \\'R.L\\') }\\nend\\n```\n```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = execute(dominoes) }\\nend\\n\\ndef execute(dominoes)\\n    dominoes\\n    .gsub(\\'R.L\\', \\'|\\')\\n    .gsub(\\'.L\\', \\'LL\\')\\n    .gsub(\\'R.\\', \\'RR\\')\\n    .gsub(\\'|\\', \\'R.L\\')\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2012322,
                "title": "simple-replace-function-python",
                "content": "```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        while True:\\n            new= dominoes.replace(\\'R.L\\',\\'S\\').replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            \\n            if new==dominoes:\\n                break\\n            else:\\n                dominoes=new\\n        return dominoes.replace(\\'S\\',\\'R.L\\')\\n```",
                "solutionTags": [],
                "code": "```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        while True:\\n            new= dominoes.replace(\\'R.L\\',\\'S\\').replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            \\n            if new==dominoes:\\n                break\\n            else:\\n                dominoes=new\\n        return dominoes.replace(\\'S\\',\\'R.L\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2001558,
                "title": "simple-c-solution-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n       int n = dom.length(); \\n       queue<pair<char,int>> q;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(dom[i]!=\\'.\\')q.push({dom[i],i});\\n       }\\n       while(q.empty()==false)\\n       {\\n           char ch = q.front().first;\\n           int ind = q.front().second;\\n           q.pop();\\n           if(ch==\\'L\\')\\n           {\\n               if(ind-1>=0 && dom[ind-1]==\\'.\\')\\n               {\\n                  dom[ind-1] = \\'L\\';\\n                  q.push({\\'L\\',ind-1}); \\n               }\\n           }\\n           else if(ch==\\'R\\')\\n           {\\n               if(ind+1<n && dom[ind+1]==\\'.\\')\\n               {\\n                   if(ind+2<n && dom[ind+2]==\\'L\\')\\n                       q.pop();\\n                   else{\\n                       dom[ind+1]=\\'R\\';\\n                       q.push({\\'R\\',ind+1});\\n                   }\\n               }\\n           }\\n       }\\n       return dom; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n       int n = dom.length(); \\n       queue<pair<char,int>> q;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(dom[i]!=\\'.\\')q.push({dom[i],i});\\n       }\\n       while(q.empty()==false)\\n       {\\n           char ch = q.front().first;\\n           int ind = q.front().second;\\n           q.pop();\\n           if(ch==\\'L\\')\\n           {\\n               if(ind-1>=0 && dom[ind-1]==\\'.\\')\\n               {\\n                  dom[ind-1] = \\'L\\';\\n                  q.push({\\'L\\',ind-1}); \\n               }\\n           }\\n           else if(ch==\\'R\\')\\n           {\\n               if(ind+1<n && dom[ind+1]==\\'.\\')\\n               {\\n                   if(ind+2<n && dom[ind+2]==\\'L\\')\\n                       q.pop();\\n                   else{\\n                       dom[ind+1]=\\'R\\';\\n                       q.push({\\'R\\',ind+1});\\n                   }\\n               }\\n           }\\n       }\\n       return dom; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905096,
                "title": "weeb-explains-python-c-2-pointers-solution",
                "content": "![image](https://assets.leetcode.com/users/images/60c692dc-d9bc-4592-bbb6-98c134b94042_1648868037.2552137.png)\\n\\nWe have 2 edge cases\\n**1st edge case**\\nif the first char is a \".\\', i.e dominoes[i] == \\'.\\', then its either :\\nAll the \\'.\\' becomes \\'L\\' **if our second pointer is \\'L\\'**\\n**or**\\nAll the \\'.\\' remain as \\'.\\' **if our second pointer is \\'R\\'**\\ni.e. lets say we have dominoes = \\'.....L\\'\\nresult = \\'LLLLLL\\'\\n**or**\\ni.e. lets say we have dominoes= \\'.....R\\'\\nresult = \\'.....R\\'\\n\\n**2nd edge case**\\nif the last char is a \".\\', i.e dominoes[len(arr)-1] == \\'.\\', then its either :\\nAll the \\'.\\' becomes \\'R\\' **if our second pointer is \\'R\\'**\\n**or**\\nAll the \\'.\\' remain as \\'.\\' **if our second pointer is \\'L\\'**\\ni.e. lets say we have dominoes = \\'R.....\\'\\nresult = \\'RRRRRR\\'\\n**or**\\ni.e. lets say we have dominoes= \\'L.....\\'\\nresult = \\'L.....\\'\\n\\nNow that the 2 edge cases are handled, it is **guaranteed** that our pointer will start and end with either an \\'L\\' or \\'R\\'\\nWith that, there are another **4 more possibilities of arrangements** which are **RR, LL, RL, LR**\\n**1st arragement : RR**\\n-All elements within RR will become \\'R\\'\\ni.e. dominoes = \"R.....R\"\\nresult = \"RRRRRR\"\\n**2nd arragement : LL**\\n-All elements within LL will become \\'L\\'\\ni.e. dominoes = \"L.....L\"\\nresult = \"LLLLLL\"\\n**3rd arragement : RL**\\n-half of the elements within RL will become \\'R\\', another half will become \\'L\\'\\nhowever, there are **2 cases to handle within this subproblem**, if we have **even** number of \\'.\\' within RL\\ni.e dominoes = \"R....L\"\\nresult = \"RRRLLL\"\\nelse, if we have **odd** number of \\'.\\' within RL\\ni.e. dominoes = \"R.....L\"\\nresult = \"RRR.LLL\" (the midpoint should remain as a \\'.\\')\\n**4th arragement : LR**\\nNo change within the elements of LR\\ni.e. dominoes = \"L.....R\"\\nresult = \"L.....R\"\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tvector<char> arr(dominoes.begin(), dominoes.end());\\n\\t\\t\\tint low = 0, high = arr.size()-1;\\n\\n\\t\\t\\tif (arr[low] == \\'.\\'){\\n\\t\\t\\t\\tfor (int i = 0; i < arr.size(); i++){\\n\\t\\t\\t\\t\\tif (arr[i] == \\'R\\'){\\n\\t\\t\\t\\t\\t\\tlow = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (arr[i] == \\'L\\'){\\n\\t\\t\\t\\t\\t\\tfor (int j = 0; j < i; j++) arr[j] = \\'L\\';\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}      \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (arr[high] == \\'.\\')\\n\\t\\t\\t\\tfor (int i = arr.size()-1; i > -1; i--){\\n\\t\\t\\t\\t\\tif (arr[i] == \\'L\\'){\\n\\t\\t\\t\\t\\t\\thigh = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (arr[i] == \\'R\\'){\\n\\t\\t\\t\\t\\t\\tfor (int j=i; j<arr.size();j++) arr[j] = \\'R\\';\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tint i = low;\\n\\t\\t\\tfor (int j = low+1; j<high+1; j++){\\n\\t\\t\\t\\tif (arr[i] == \\'R\\' && arr[j] == \\'L\\'){\\n\\t\\t\\t\\t\\tint mid = (i+j)/2;\\n\\t\\t\\t\\t\\tint temp = j;\\n\\t\\t\\t\\t\\twhile (i != j){\\n\\t\\t\\t\\t\\t\\tif (i >= temp){\\n\\t\\t\\t\\t\\t\\t\\ti = j;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tarr[i] = \\'R\\';\\n\\t\\t\\t\\t\\t\\tarr[temp] = \\'L\\';\\n\\n\\t\\t\\t\\t\\t\\ttemp--;\\n\\t\\t\\t\\t\\t\\ti++;   \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (arr[i] == \\'R\\' && arr[j] == \\'R\\'){\\n\\t\\t\\t\\t\\twhile (i != j){\\n\\t\\t\\t\\t\\t\\tarr[i] = \\'R\\';\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (arr[i] == \\'L\\' && arr[j] == \\'L\\'){\\n\\t\\t\\t\\t\\twhile (i != j){\\n\\t\\t\\t\\t\\t\\tarr[i] = \\'L\\';\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (arr[i] == \\'L\\' && arr[j] == \\'R\\') i = j;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring result = \"\";\\n\\n\\t\\t\\tfor (int i = 0; i < arr.size(); i++) result += arr[i];\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};\\n\\n**Python** \\n\\t\\n\\tclass Solution:\\n    def pushDominoes(self, string: str) -> str:\\n        low, high = 0, len(string) - 1\\n        string = list(string)\\n        \\n        if string[low] == \".\":\\n            for i in range(len(string)):\\n                if string[i] == \"R\": \\n                    low = i\\n                    break\\n                \\n                if string[i] == \"L\":\\n                    for j in range(i):\\n                        string[j] = \"L\"\\n                    break\\n                    \\n        if string[high] == \".\":\\n            for i in range(len(string)-1,-1,-1):\\n                if string[i] == \"L\": \\n                    high = i\\n                    break\\n                \\n                if string[i] == \"R\":\\n                    for j in range(i, len(string)):\\n                        string[j] = \"R\"\\n                    break\\n        \\n        i = low\\n        for j in range(low+1, high+1):\\n            if string[i] == \"R\" and string[j] == \"L\":\\n                mid = (i+j) //2 \\n                temp = j\\n                while i != j:\\n                    if i >= temp:\\n                        i = j\\n                        break\\n                    \\n                    string[i] = \"R\"\\n                    string[temp] = \"L\"\\n                    \\n                    temp-=1\\n                    i+=1\\n            \\n            if string[i] == \"R\" and string[j] == \"R\":\\n                while i != j:\\n                    string[i] = \"R\"\\n                    i+=1\\n            \\n            if string[i] == \"L\" and string[j] == \"L\":\\n                while i != j:\\n                    string[i] = \"L\"\\n                    i+=1\\n                \\n            if string[i] == \"L\" and string[j] == \"R\":\\n                i = j\\n    \\n        return \"\".join(string)\\n\\nBruh, take a break, watch some anime instead\\nCheck out **\\u738B\\u69D8\\u30E9\\u30F3\\u30AD\\u30F3\\u30B0 (Ranking of Kings)**\\n\\n# Episodes: 23\\n# Genres: Adventure, Fantasy\\n\\nThis anime is amazing, watch it.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tvector<char> arr(dominoes.begin(), dominoes.end());\\n\\t\\t\\tint low = 0, high = arr.size()-1;\\n\\n\\t\\t\\tif (arr[low] == \\'.\\'){\\n\\t\\t\\t\\tfor (int i = 0; i < arr.size(); i++){\\n\\t\\t\\t\\t\\tif (arr[i] == \\'R\\'){\\n\\t\\t\\t\\t\\t\\tlow = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1667195,
                "title": "6-lines-c-linq-o-n",
                "content": "It isn\\'t a good code. But it\\'s quite short.\\n\\n```\\npublic class Solution \\n{\\n    private IEnumerable<int> DistTo(IEnumerable<char> dominoes, char R, char L) \\n    {\\n        int dist = Int32.MaxValue / 2;\\n        return dominoes\\n                .Select(domino => domino == R ? dist = 0 : (domino == L ? dist = Int32.MaxValue / 2 : ++dist))\\n                .Select(x => x < Int32.MaxValue / 2 ? x : Int32.MaxValue / 2);\\n    }\\n    \\n    public string PushDominoes(string dominoes)\\n        => String.Concat(DistTo(dominoes, \\'R\\', \\'L\\').Zip(DistTo(dominoes.Reverse(), \\'L\\', \\'R\\').Reverse(),\\n                                                        (r, l) => r < l ? \\'R\\' : (r > l ? \\'L\\' : \\'.\\')));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    private IEnumerable<int> DistTo(IEnumerable<char> dominoes, char R, char L) \\n    {\\n        int dist = Int32.MaxValue / 2;\\n        return dominoes\\n                .Select(domino => domino == R ? dist = 0 : (domino == L ? dist = Int32.MaxValue / 2 : ++dist))\\n                .Select(x => x < Int32.MaxValue / 2 ? x : Int32.MaxValue / 2);\\n    }\\n    \\n    public string PushDominoes(string dominoes)\\n        => String.Concat(DistTo(dominoes, \\'R\\', \\'L\\').Zip(DistTo(dominoes.Reverse(), \\'L\\', \\'R\\').Reverse(),\\n                                                        (r, l) => r < l ? \\'R\\' : (r > l ? \\'L\\' : \\'.\\')));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354237,
                "title": "c-easy-two-pointers-explained",
                "content": "The idea here is to use two pointer approach.\\nWe need to insert \\'L\\' in the beginning to make the process easier.\\ninitially i is pointing to beginning \\'L\\'. \\nj = i+1, continue incrementing j as long as dominoes[i]=\\'.\\' \\nAs soon we encounter \\'L\\' or \\'R\\', we stop.\\nHere are 4 possibilities:\\n1. i=\\'L\\' and j=\\'L\\' --> we fill all the characters between i and j with \\'L\\'\\n2. i=\\'R\\' and j=\\'R\\' --> we fill all the characters between i and j with \\'R\\'.\\n3. i=\\'L\\' and j=\\'R\\' --> we don\\'t do anything. All characters remain as it is.\\n4. i=\\'R\\' and j=\\'L\\' --> Here we need to fill the characters with \\'R\\' and \\'L\\' both. We calculate mid point between j-1 and i index and fill the characters as shown below.\\n\\nLastly, if j==size, that means we reached end, then check if dominoes[i]==\\'R\\' --> fill all characters till end with \\'R\\'.\\nAdjust pointers i and j. We already processed characters till j. so now i=j.\\n```\\n string pushDominoes(string dominoes) {\\n        int i, j,k, size, mid, count=0;\\n        string result;\\n        result = dominoes;\\n        dominoes.insert(dominoes.begin()+0, \\'L\\');\\n        size = dominoes.size();\\n        for(i=0; i<size-1; )\\n        {\\n           j=i+1;\\n            while(j<size && dominoes[j]==\\'.\\')\\n                j++;\\n            if(j<size)\\n            {\\n                if(dominoes[i]==\\'R\\' && dominoes[j]==\\'L\\')\\n                {\\n                    mid = ((j-1)-i)/2;\\n                    for(k=1; k<=mid; k++)\\n                    {\\n                        dominoes[i+k] = dominoes[i];\\n                        dominoes[j-k] = dominoes[j];\\n                    }\\n                }\\n                else if(dominoes[i]==\\'L\\' && dominoes[j]==\\'L\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k]=\\'L\\';\\n                }\\n                else if(dominoes[i]==\\'R\\' && dominoes[j]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            else\\n            {\\n                if(dominoes[i]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            i=j;\\n        }\\n        dominoes.erase(dominoes.begin()+0);\\n        return dominoes;\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n string pushDominoes(string dominoes) {\\n        int i, j,k, size, mid, count=0;\\n        string result;\\n        result = dominoes;\\n        dominoes.insert(dominoes.begin()+0, \\'L\\');\\n        size = dominoes.size();\\n        for(i=0; i<size-1; )\\n        {\\n           j=i+1;\\n            while(j<size && dominoes[j]==\\'.\\')\\n                j++;\\n            if(j<size)\\n            {\\n                if(dominoes[i]==\\'R\\' && dominoes[j]==\\'L\\')\\n                {\\n                    mid = ((j-1)-i)/2;\\n                    for(k=1; k<=mid; k++)\\n                    {\\n                        dominoes[i+k] = dominoes[i];\\n                        dominoes[j-k] = dominoes[j];\\n                    }\\n                }\\n                else if(dominoes[i]==\\'L\\' && dominoes[j]==\\'L\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k]=\\'L\\';\\n                }\\n                else if(dominoes[i]==\\'R\\' && dominoes[j]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            else\\n            {\\n                if(dominoes[i]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            i=j;\\n        }\\n        dominoes.erase(dominoes.begin()+0);\\n        return dominoes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1353683,
                "title": "c-easy-clean-solution",
                "content": "**Solution I:**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        if(s.size() == 1)\\n            return s;\\n        string fans = \"\";\\n        while(1){\\n            string ans = \"\";\\n            for(int i = 0; i < s.size(); i++){\\n                if(i == 0){\\n                    if(s[i] == \\'.\\' and s[i + 1] == \\'L\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n                else if(i == s.size() - 1){\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\') ans += s[i - 1];\\n                    else ans += s[i];\\n                }\\n                else{\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\' and s[i + 1] != \\'L\\') ans += s[i - 1];\\n                    else if(s[i] == \\'.\\' and s[i + 1] == \\'L\\' and s[i - 1] != \\'R\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n            }\\n            s = ans;\\n            if(s == fans) break;\\n            else fans = s; \\n        }\\n        return fans;\\n    }\\n};\\n```\\n\\n**Solution II:**\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        ll n = s.size();\\n        if(n == 1)\\n            return s;\\n        vector<ll> r(n), l(n);\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'R\\') r[i] = 1;\\n            else if(s[i] == \\'.\\' and i > 0){\\n                if(r[i - 1] != INT_MAX) r[i] = r[i - 1] + 1;\\n                else r[i] = INT_MAX;\\n            }\\n            else r[i] = INT_MAX;     \\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(s[i] == \\'L\\') l[i] = 1;\\n            else if(s[i] == \\'.\\' and i < n - 1){\\n                if(l[i + 1] != INT_MAX) l[i] = l[i + 1] + 1;\\n                else l[i] = INT_MAX;\\n            }\\n            else l[i] = INT_MAX;\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'.\\'){\\n                if(l[i] == r[i]) ans += \\'.\\';\\n                else if(l[i] < r[i]) ans += \\'L\\';\\n                else if(l[i] > r[i]) ans += \\'R\\';\\n            }\\n            else ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        if(s.size() == 1)\\n            return s;\\n        string fans = \"\";\\n        while(1){\\n            string ans = \"\";\\n            for(int i = 0; i < s.size(); i++){\\n                if(i == 0){\\n                    if(s[i] == \\'.\\' and s[i + 1] == \\'L\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n                else if(i == s.size() - 1){\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\') ans += s[i - 1];\\n                    else ans += s[i];\\n                }\\n                else{\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\' and s[i + 1] != \\'L\\') ans += s[i - 1];\\n                    else if(s[i] == \\'.\\' and s[i + 1] == \\'L\\' and s[i - 1] != \\'R\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n            }\\n            s = ans;\\n            if(s == fans) break;\\n            else fans = s; \\n        }\\n        return fans;\\n    }\\n};\\n```\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        ll n = s.size();\\n        if(n == 1)\\n            return s;\\n        vector<ll> r(n), l(n);\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'R\\') r[i] = 1;\\n            else if(s[i] == \\'.\\' and i > 0){\\n                if(r[i - 1] != INT_MAX) r[i] = r[i - 1] + 1;\\n                else r[i] = INT_MAX;\\n            }\\n            else r[i] = INT_MAX;     \\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(s[i] == \\'L\\') l[i] = 1;\\n            else if(s[i] == \\'.\\' and i < n - 1){\\n                if(l[i + 1] != INT_MAX) l[i] = l[i + 1] + 1;\\n                else l[i] = INT_MAX;\\n            }\\n            else l[i] = INT_MAX;\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'.\\'){\\n                if(l[i] == r[i]) ans += \\'.\\';\\n                else if(l[i] < r[i]) ans += \\'L\\';\\n                else if(l[i] > r[i]) ans += \\'R\\';\\n            }\\n            else ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352429,
                "title": "simple-bfs-solution-c",
                "content": "**if you don\\'t like my solution please comment ,, do not downvote**\\n```\\n\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n     \\n        queue<int> q; //for storing the indexes\\n        \\n        for(int i=0;i<dominoes.size();i++){\\n            if(dominoes[i]==\\'L\\' || dominoes[i]==\\'R\\'){\\n                q.push(i);\\n            }\\n        }\\n        \\n        string ans = dominoes; // for keeping track of the changes\\n        \\n        while(!q.empty()){\\n            \\n            int s = q.size();\\n            \\n            for(int i=0;i<s;i++){\\n                \\n                auto p = q.front();\\n                q.pop();\\n                \\n                if(p-1>=0 && dominoes[p]==\\'L\\' && dominoes[p-1]==\\'.\\'){\\n                    \\n                    if(p-2>=0 && (dominoes[p-2]==\\'.\\' || dominoes[p-2]==\\'L\\')){\\n                        ans[p-1] = \\'L\\';\\n                        q.push(p-1);    \\n                    }\\n                    \\n                    if(p-2<0){\\n                        ans[p-1] = \\'L\\';\\n                    }\\n                    \\n                }\\n                \\n                if(p+1<dominoes.size() && dominoes[p]==\\'R\\' && dominoes[p+1]==\\'.\\'){\\n                    \\n                    if(p+2<dominoes.size() && (dominoes[p+2]==\\'.\\' || dominoes[p+2]==\\'R\\'))\\n                    {\\n                      ans[p+1] = \\'R\\';\\n                    q.push(p+1);\\n  \\n                    }         \\n                    if(p+2>=dominoes.size()){\\n                        ans[p+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            dominoes = ans; // after t = 1 in the next time stamp we will have the updated string\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n     \\n        queue<int> q; //for storing the indexes\\n        \\n        for(int i=0;i<dominoes.size();i++){\\n            if(dominoes[i]==\\'L\\' || dominoes[i]==\\'R\\'){\\n                q.push(i);\\n            }\\n        }\\n        \\n        string ans = dominoes; // for keeping track of the changes\\n        \\n        while(!q.empty()){\\n            \\n            int s = q.size();\\n            \\n            for(int i=0;i<s;i++){\\n                \\n                auto p = q.front();\\n                q.pop();\\n                \\n                if(p-1>=0 && dominoes[p]==\\'L\\' && dominoes[p-1]==\\'.\\'){\\n                    \\n                    if(p-2>=0 && (dominoes[p-2]==\\'.\\' || dominoes[p-2]==\\'L\\')){\\n                        ans[p-1] = \\'L\\';\\n                        q.push(p-1);    \\n                    }\\n                    \\n                    if(p-2<0){\\n                        ans[p-1] = \\'L\\';\\n                    }\\n                    \\n                }\\n                \\n                if(p+1<dominoes.size() && dominoes[p]==\\'R\\' && dominoes[p+1]==\\'.\\'){\\n                    \\n                    if(p+2<dominoes.size() && (dominoes[p+2]==\\'.\\' || dominoes[p+2]==\\'R\\'))\\n                    {\\n                      ans[p+1] = \\'R\\';\\n                    q.push(p+1);\\n  \\n                    }         \\n                    if(p+2>=dominoes.size()){\\n                        ans[p+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            dominoes = ans; // after t = 1 in the next time stamp we will have the updated string\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201805,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        if(n <= 1)return dominoes;\\n        /* index is storing the index of every l and r\\n        we are making it of n+2 size beacuse we can have all char as r and L in dominoes and +2 becuase we are\\n        inserting L in front and R in end of string, they won\\'t make any difference but they can b used to\\n        handel these cases\\n       \\n       case:1 - (<-) L......L(<-) or (->)R....R(->) when the exert force on only on same side then all the  standing\\n\\t                  dominoes will fall in the direction same as we are exerting force. so it can be written  as LLLLL or   RRRRR.    \\n        case:2 - (<-)L.....R(->) can be neglected beacuse they won\\'t make any chang in dominoes between them.\\n        \\n        case:3 - (->)R......L(<-) so this is the case we need to care about, so in this we can further have two \\n                    two cases i). even number of (.) so first half dominoes will fall in right and second half \\n                    will fall in left and when they both meet they will be like //\\\\\\\\\\n                    second case ii). odd number of dots .  so, the mid will stand tall as both from left and \\n                    right we are exerting force and due to that it will stand tall ex, //|\\\\\\\\ */\\n        \\n        int[] index = new int[n+2];\\n        char[] symbol = new char[n+2];\\n        int len = 1;\\n        index[0] = -1;\\n        symbol[0] = \\'L\\';\\n        \\n        for(int i = 0 ; i < n; i++){\\n            if(dominoes.charAt(i) != \\'.\\'){\\n                index[len] = i;\\n                symbol[len++] = dominoes.charAt(i);\\n            }\\n        }\\n        index[len] = n;\\n        symbol[len++] = \\'R\\';\\n        \\n        char[] ans = dominoes.toCharArray();\\n        for(int k = 0; k < len-1; k++){\\n            int i = index[k] , j = index[k+1];\\n            char x = symbol[k] , y = symbol[k+1];\\n            \\n            if(x == y){\\n                // case 1\\n                for(int a = i+1; a<j; a++){\\n                    ans[a] = x;\\n                }  //case 2 will be ignored as it can\\'t make any change in stability of dominoes.\\n            }else if(x > y){\\n                //case 3\\n                for(int a = i+1; a < j ; a++){\\n                    ans[a] = a-i == j-a ? \\'.\\' : a-i < j-a ? \\'R\\' : \\'L\\';\\n                }\\n            }\\n        }\\n        return String.valueOf(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        if(n <= 1)return dominoes;\\n        /* index is storing the index of every l and r\\n        we are making it of n+2 size beacuse we can have all char as r and L in dominoes and +2 becuase we are\\n        inserting L in front and R in end of string, they won\\'t make any difference but they can b used to\\n        handel these cases\\n       \\n       case:1 - (<-) L......L(<-) or (->)R....R(->) when the exert force on only on same side then all the  standing\\n\\t                  dominoes will fall in the direction same as we are exerting force. so it can be written  as LLLLL or   RRRRR.    \\n        case:2 - (<-)L.....R(->) can be neglected beacuse they won\\'t make any chang in dominoes between them.\\n        \\n        case:3 - (->)R......L(<-) so this is the case we need to care about, so in this we can further have two \\n                    two cases i). even number of (.) so first half dominoes will fall in right and second half \\n                    will fall in left and when they both meet they will be like //\\\\\\\\\\n                    second case ii). odd number of dots .  so, the mid will stand tall as both from left and \\n                    right we are exerting force and due to that it will stand tall ex, //|\\\\\\\\ */\\n        \\n        int[] index = new int[n+2];\\n        char[] symbol = new char[n+2];\\n        int len = 1;\\n        index[0] = -1;\\n        symbol[0] = \\'L\\';\\n        \\n        for(int i = 0 ; i < n; i++){\\n            if(dominoes.charAt(i) != \\'.\\'){\\n                index[len] = i;\\n                symbol[len++] = dominoes.charAt(i);\\n            }\\n        }\\n        index[len] = n;\\n        symbol[len++] = \\'R\\';\\n        \\n        char[] ans = dominoes.toCharArray();\\n        for(int k = 0; k < len-1; k++){\\n            int i = index[k] , j = index[k+1];\\n            char x = symbol[k] , y = symbol[k+1];\\n            \\n            if(x == y){\\n                // case 1\\n                for(int a = i+1; a<j; a++){\\n                    ans[a] = x;\\n                }  //case 2 will be ignored as it can\\'t make any change in stability of dominoes.\\n            }else if(x > y){\\n                //case 3\\n                for(int a = i+1; a < j ; a++){\\n                    ans[a] = a-i == j-a ? \\'.\\' : a-i < j-a ? \\'R\\' : \\'L\\';\\n                }\\n            }\\n        }\\n        return String.valueOf(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201268,
                "title": "c-easy-one-pass-solution-using-stack",
                "content": "First of all, we see that the their are four possible combinatoins with L and R.\\n1) We encounter a L after another L\\n2) We encounter a R after an L\\n3) We encounter a L after an R\\n4) We encounter a R after another R.\\n\\nNow, of these four case, only case where there is chance of a middle element is case 3.\\nBut let me break it down case by case for you.\\n\\ncase 1 : ...L...L \\n\\tIn such case we can easily say that while going left from current point we can simply mark everthing as L until we reach the start of string or encounter the other L. whichever occurs first.\\n\\ncase 2: ....L...R... \\n\\tIn such case, we don\\'t need to do anything and simply update the values in L and R var that we use to store the position of last encounter L or R. As case 1 will make everything before L as L and case 4 will handle the dots after R. \\n\\ncase 3: ...R...L.. \\n\\tNow this one requires us to do a bit. We use a two pointer approach and take i=postion of last encounterd R and j= position of current L and do a loop while(i<j) with incrementing i and making the dots R and decrementing J and making the dots L.\\n\\nCase 4: \\n\\tA bit similar to case 1, the only catch is unlike L, since we don\\'t directly start updating all the values to \\'R\\' as soon as we encounter R, we start from the previous positon of R and make everything \\'R\\' between the two Rs. Then update the value of positon of last encountered R. \\nFor this reason, once we have iterated everything, we need to check if the top element in the stack is R, if yes, run a loop to make everything after that a R until the end of the string.\\n\\nIn all these cases, we push the encountered L or R into the stack after doing the operation.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int l=-1;//to strore the position of last encountered L\\n        int r=-1;// to store the position of last encountered R\\n        int n= dominoes.size();\\n   \\n       \\n        stack<char> s;\\n        for(int i=0; i<n;i++)\\n        {  \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                 l=i;\\n\\n                if(s.empty()||s.top()!=\\'R\\')//case 1 (and case 3 since there is nothing to be done in case 3)\\n                {\\n                   i--;//so that the next loop runs as dominoes[i] is \\'L\\'\\n                    while(i>=0&&dominoes[i]!=\\'L\\')\\n                    {\\n                        dominoes[i]=\\'L\\';i--;\\n                    }\\n                }\\n                else \\n                { \\n                    for(int i=r,j=l;i<j;i++,j--)//case 3\\n                    {\\n                        dominoes[i]=\\'R\\';\\n                        dominoes[j]=\\'L\\';\\n                    }\\n                }\\n                s.push(\\'L\\');\\n                i=l;\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            { \\n                if(!s.empty()&&s.top()==\\'R\\')\\n                    while(r<=i)\\n                    {\\n                        dominoes[r]=\\'R\\';\\n                        r++;\\n                    }\\n                r=i;\\n                s.push(\\'R\\');\\n            } \\n                \\n            \\n        }\\n        if(!s.empty()&&s.top()==\\'R\\')\\n            while(r<n)\\n                {  \\n                dominoes[r]=\\'R\\';\\n                    r++;\\n                }\\n        \\n        return dominoes;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int l=-1;//to strore the position of last encountered L\\n        int r=-1;// to store the position of last encountered R\\n        int n= dominoes.size();\\n   \\n       \\n        stack<char> s;\\n        for(int i=0; i<n;i++)\\n        {  \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                 l=i;\\n\\n                if(s.empty()||s.top()!=\\'R\\')//case 1 (and case 3 since there is nothing to be done in case 3)\\n                {\\n                   i--;//so that the next loop runs as dominoes[i] is \\'L\\'\\n                    while(i>=0&&dominoes[i]!=\\'L\\')\\n                    {\\n                        dominoes[i]=\\'L\\';i--;\\n                    }\\n                }\\n                else \\n                { \\n                    for(int i=r,j=l;i<j;i++,j--)//case 3\\n                    {\\n                        dominoes[i]=\\'R\\';\\n                        dominoes[j]=\\'L\\';\\n                    }\\n                }\\n                s.push(\\'L\\');\\n                i=l;\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            { \\n                if(!s.empty()&&s.top()==\\'R\\')\\n                    while(r<=i)\\n                    {\\n                        dominoes[r]=\\'R\\';\\n                        r++;\\n                    }\\n                r=i;\\n                s.push(\\'R\\');\\n            } \\n                \\n            \\n        }\\n        if(!s.empty()&&s.top()==\\'R\\')\\n            while(r<n)\\n                {  \\n                dominoes[r]=\\'R\\';\\n                    r++;\\n                }\\n        \\n        return dominoes;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004197,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        s = \"L\" + dominoes + \"R\"\\n\\n        p, q = 0, 1\\n        res = \"\"\\n        \\n        while q < len(s):\\n            if s[q] != \".\":\\n                if s[p] == s[q]:\\n                    res += s[p] * (q - p )\\n                    \\n                elif s[p] == \\'R\\' and s[q] == \\'L\\':\\n                    m = (p + q) // 2\\n                    if (p + q) % 2 == 0: \\n                        res += s[p] * (m - p)  + \\'.\\' +  s[q] * ( q - m - 1)\\n                    else:\\n                        res += s[p] * (m - p + 1) + s[q] * (q - m - 1)\\n                else:\\n                    res += s[p] + \\'.\\' * (q - p - 1)\\n                \\n                p = q \\n                \\n            q += 1\\n        \\n        return res[1:]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        s = \"L\" + dominoes + \"R\"\\n\\n        p, q = 0, 1\\n        res = \"\"\\n        \\n        while q < len(s):\\n            if s[q] != \".\":\\n                if s[p] == s[q]:\\n                    res += s[p] * (q - p )\\n                    \\n                elif s[p] == \\'R\\' and s[q] == \\'L\\':\\n                    m = (p + q) // 2\\n                    if (p + q) % 2 == 0: \\n                        res += s[p] * (m - p)  + \\'.\\' +  s[q] * ( q - m - 1)\\n                    else:\\n                        res += s[p] * (m - p + 1) + s[q] * (q - m - 1)\\n                else:\\n                    res += s[p] + \\'.\\' * (q - p - 1)\\n                \\n                p = q \\n                \\n            q += 1\\n        \\n        return res[1:]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 993392,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n, INT_MAX), right(n, INT_MAX);\\n        \\n        for (int i = 0, r = -1, l = -1; i < n; ++i) {\\n            // Right fall\\n            if (dominoes[i] == \\'R\\') r = i;\\n            if (dominoes[i] == \\'L\\') r = -1;\\n            if (dominoes[i] == \\'.\\' && r != -1) right[i] = i - r;\\n            \\n            // Left fall\\n            if (dominoes[n-i-1] == \\'L\\') l = n-i-1;\\n            if (dominoes[n-i-1] == \\'R\\') l = -1;\\n            if (dominoes[n-i-1] == \\'.\\' && l != -1) left[n-i-1] = l-n+i+1;\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n            if (left[i] != right[i] && dominoes[i] == \\'.\\')\\n                dominoes[i] = left[i] < right[i] ? \\'L\\' : \\'R\\';\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n, INT_MAX), right(n, INT_MAX);\\n        \\n        for (int i = 0, r = -1, l = -1; i < n; ++i) {\\n            // Right fall\\n            if (dominoes[i] == \\'R\\') r = i;\\n            if (dominoes[i] == \\'L\\') r = -1;\\n            if (dominoes[i] == \\'.\\' && r != -1) right[i] = i - r;\\n            \\n            // Left fall\\n            if (dominoes[n-i-1] == \\'L\\') l = n-i-1;\\n            if (dominoes[n-i-1] == \\'R\\') l = -1;\\n            if (dominoes[n-i-1] == \\'.\\' && l != -1) left[n-i-1] = l-n+i+1;\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n            if (left[i] != right[i] && dominoes[i] == \\'.\\')\\n                dominoes[i] = left[i] < right[i] ? \\'L\\' : \\'R\\';\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833768,
                "title": "c-two-passes-o-n",
                "content": "```\\nclass Solution {\\npublic:\\nstring pushDominoes(string dominoes) \\n    {\\n        vector<int> nums(dominoes.size());\\n        for(int i = 1; i < dominoes.size(); i++) \\n        {\\n            if(dominoes[i] == \\'.\\' && dominoes[i - 1] == \\'R\\')\\n            {\\n                nums[i] = nums[i - 1] + 1;\\n                dominoes[i] = \\'R\\';\\n            }\\n        }\\n\\n        for(int i  = dominoes.size() - 2; i >= 0; i--)\\n        {\\n            if(dominoes[i + 1] == \\'L\\')\\n            {\\n                if(dominoes[i] != \\'R\\')\\n                    dominoes[i] = \\'L\\';\\n                else\\n                {\\n                    int cnt = 1;\\n                    while(cnt < nums[i])\\n                    {\\n                        cnt++;\\n                        dominoes[i] = \\'L\\';\\n                        i--;\\n                    }\\n\\n                    if(nums[i] == cnt)\\n                        dominoes[i] = \\'.\\';\\n\\n                    while(nums[i]) i--;\\n                }\\n            }\\n            \\n        }\\n\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nstring pushDominoes(string dominoes) \\n    {\\n        vector<int> nums(dominoes.size());\\n        for(int i = 1; i < dominoes.size(); i++) \\n        {\\n            if(dominoes[i] == \\'.\\' && dominoes[i - 1] == \\'R\\')\\n            {\\n                nums[i] = nums[i - 1] + 1;\\n                dominoes[i] = \\'R\\';\\n            }\\n        }\\n\\n        for(int i  = dominoes.size() - 2; i >= 0; i--)\\n        {\\n            if(dominoes[i + 1] == \\'L\\')\\n            {\\n                if(dominoes[i] != \\'R\\')\\n                    dominoes[i] = \\'L\\';\\n                else\\n                {\\n                    int cnt = 1;\\n                    while(cnt < nums[i])\\n                    {\\n                        cnt++;\\n                        dominoes[i] = \\'L\\';\\n                        i--;\\n                    }\\n\\n                    if(nums[i] == cnt)\\n                        dominoes[i] = \\'.\\';\\n\\n                    while(nums[i]) i--;\\n                }\\n            }\\n            \\n        }\\n\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473226,
                "title": "go-o-n-4ms100",
                "content": "```go\\nfunc pushDominoes(dominoes string) string {\\n\\tdominoesInByteSlice := []byte(dominoes)\\n\\tlastIsRight := false\\n\\tlastIndex := 0\\n\\tfor i := 0; i < len(dominoesInByteSlice); i++ {\\n\\t\\tswitch dominoesInByteSlice[i] {\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tcount := (i - lastIndex + 1) / 2 - 1\\n\\t\\t\\t\\tfor m := lastIndex+1; m < lastIndex+1+count; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor m := i-1; m > i-1-count; m-- {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = false\\n\\t\\t\\tlastIndex = i+1\\n\\t\\tcase \\'R\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = true\\n\\t\\t\\tlastIndex = i\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif lastIsRight {\\n\\t\\tfor m := lastIndex; m < len(dominoesInByteSlice); m++ {\\n\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn string(dominoesInByteSlice)\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc pushDominoes(dominoes string) string {\\n\\tdominoesInByteSlice := []byte(dominoes)\\n\\tlastIsRight := false\\n\\tlastIndex := 0\\n\\tfor i := 0; i < len(dominoesInByteSlice); i++ {\\n\\t\\tswitch dominoesInByteSlice[i] {\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tcount := (i - lastIndex + 1) / 2 - 1\\n\\t\\t\\t\\tfor m := lastIndex+1; m < lastIndex+1+count; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor m := i-1; m > i-1-count; m-- {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = false\\n\\t\\t\\tlastIndex = i+1\\n\\t\\tcase \\'R\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = true\\n\\t\\t\\tlastIndex = i\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif lastIsRight {\\n\\t\\tfor m := lastIndex; m < len(dominoesInByteSlice); m++ {\\n\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn string(dominoesInByteSlice)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132932,
                "title": "c-2-pass-scan-o-2n-13ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        const int n = dominoes.size();\\n        vector<int> vt(n);\\n        for(int i = 1; i < n; ++i){\\n            if(dominoes[i-1] == \\'R\\' && dominoes[i] == \\'.\\'){\\n                dominoes[i] = \\'R\\';\\n                vt[i] = vt[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i = n-2, nt; i >= 0; --i){\\n            if(dominoes[i+1] == \\'L\\'){\\n                nt = vt[i+1] + 1;\\n                if(dominoes[i] == \\'.\\' || vt[i] > nt){\\n                    dominoes[i] = \\'L\\';\\n                    vt[i] = nt;\\n                }\\n                else if(dominoes[i] == \\'R\\' && vt[i] == nt){ // recover\\n                    dominoes[i] = \\'.\\';\\n                }\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n\\nint iobooster = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        const int n = dominoes.size();\\n        vector<int> vt(n);\\n        for(int i = 1; i < n; ++i){\\n            if(dominoes[i-1] == \\'R\\' && dominoes[i] == \\'.\\'){\\n                dominoes[i] = \\'R\\';\\n                vt[i] = vt[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i = n-2, nt; i >= 0; --i){\\n            if(dominoes[i+1] == \\'L\\'){\\n                nt = vt[i+1] + 1;\\n                if(dominoes[i] == \\'.\\' || vt[i] > nt){\\n                    dominoes[i] = \\'L\\';\\n                    vt[i] = nt;\\n                }\\n                else if(dominoes[i] == \\'R\\' && vt[i] == nt){ // recover\\n                    dominoes[i] = \\'.\\';\\n                }\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n\\nint iobooster = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132499,
                "title": "c-4-lines-o-n-n-simulation",
                "content": "We simulate falling dominos turn-by-turn. We need a copy of the string (```s```) to make modifications so all dominos are pushed \"simultaneously\". At the end of each turn, we return the result if there are no more changes (```s == ds```).\\n\\nEach turn we run through all dominos. The ```if``` statement checks if the previous (```i - 1``` for L) or next (```i + 1``` for R) domino can be pushed: it\\'s standing and there is no domino before/after it pushing in the opposite direction.\\n```\\nstring pushDominoes(string ds) {\\n  for (string s = ds; ; s = ds) {\\n    for (auto i = 0, d = s[i] == \\'L\\' ? -1 : 1; i < s.size(); d = s[++i] == \\'L\\' ? -1 : 1)\\n      if (s[i] != \\'.\\' && i + d >= 0 && i + d < s.size() && s[i + d] == \\'.\\' &&\\n        (i + d * 2 < 0 || i + d * 2 >= s.size() || s[i + d * 2] != (s[i] == \\'L\\' ? \\'R\\' : \\'L\\'))) ds[i + d] = s[i];\\n    if (s == ds) return s;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```s```\n```s == ds```\n```if```\n```i - 1```\n```i + 1```\n```\\nstring pushDominoes(string ds) {\\n  for (string s = ds; ; s = ds) {\\n    for (auto i = 0, d = s[i] == \\'L\\' ? -1 : 1; i < s.size(); d = s[++i] == \\'L\\' ? -1 : 1)\\n      if (s[i] != \\'.\\' && i + d >= 0 && i + d < s.size() && s[i + d] == \\'.\\' &&\\n        (i + d * 2 < 0 || i + d * 2 >= s.size() || s[i + d * 2] != (s[i] == \\'L\\' ? \\'R\\' : \\'L\\'))) ds[i + d] = s[i];\\n    if (s == ds) return s;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132371,
                "title": "python-3-passes-simple-solution-using-dictionaries-228-ms",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes):\\n        res, l, r , pre_l, pre_r = \"\", {}, {}, None, None,\\n        for i, s in enumerate(dominoes):\\n            if s == \".\" and pre_r != None: r[i] = i - pre_r\\n            elif s == \"R\": pre_r = i\\n            elif s == \"L\": pre_r = None\\n        for i in range(len(dominoes) - 1, -1, -1):\\n            if dominoes[i] == \".\" and pre_l != None: l[i] = pre_l - i\\n            elif dominoes[i] == \"L\": pre_l = i\\n            elif dominoes[i] == \"R\": pre_l = None\\n        for i, s in enumerate(dominoes):\\n            if s == \"L\" or s == \"R\": res += s\\n            elif i in l and i in r:\\n                if l[i] < r[i]: res += \"L\"\\n                elif r[i] < l[i]: res += \"R\"\\n                else: res += s\\n            elif i in l: res += \"L\"\\n            elif i in r: res += \"R\"\\n            else: res += s\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes):\\n        res, l, r , pre_l, pre_r = \"\", {}, {}, None, None,\\n        for i, s in enumerate(dominoes):\\n            if s == \".\" and pre_r != None: r[i] = i - pre_r\\n            elif s == \"R\": pre_r = i\\n            elif s == \"L\": pre_r = None\\n        for i in range(len(dominoes) - 1, -1, -1):\\n            if dominoes[i] == \".\" and pre_l != None: l[i] = pre_l - i\\n            elif dominoes[i] == \"L\": pre_l = i\\n            elif dominoes[i] == \"R\": pre_l = None\\n        for i, s in enumerate(dominoes):\\n            if s == \"L\" or s == \"R\": res += s\\n            elif i in l and i in r:\\n                if l[i] < r[i]: res += \"L\"\\n                elif r[i] < l[i]: res += \"R\"\\n                else: res += s\\n            elif i in l: res += \"L\"\\n            elif i in r: res += \"R\"\\n            else: res += s\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820586,
                "title": "brute-force-with-storing-critical-points-with-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n         int n  = dominoes.size();\\n         vector<pair<char,int>> v;\\n            for(int i=0;i<n;i++){\\n                    if(dominoes[i] == \\'R\\') v.push_back({\\'R\\',i});\\n                    else if(dominoes[i] == \\'L\\') v.push_back({\\'L\\',i});\\n            }\\n           if(v.size() == 0) return dominoes;\\n             if(v[0].first == \\'L\\'){\\n                     for(int j = 0;j<=v[0].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n            for(int i=0;i<v.size()-1;i++){\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'L\\'){\\n                        int k = v[i+1].second - v[i].second-1;\\n                        for(int j=0;j<k/2;j++){\\n                            dominoes[v[i].second + j + 1] = \\'R\\';\\n                        } \\n                        for(int j = k/2+1;j<=k;j++){\\n                            dominoes[v[i].second + j] = \\'L\\';\\n                        }\\n                       \\n                        if(k%2!=0) dominoes[v[i].second + (k+1)/2] = \\'.\\';\\n                 }\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'R\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'R\\';\\n                 }\\n                 if(v[i].first == \\'L\\' && v[i+1].first == \\'L\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n                 \\n            }\\n            if(v[v.size() - 1].first == \\'R\\'){\\n                for(int j=v[v.size()-1].second;j<n;j++) dominoes[j] = \\'R\\';\\n            }\\n            return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n         int n  = dominoes.size();\\n         vector<pair<char,int>> v;\\n            for(int i=0;i<n;i++){\\n                    if(dominoes[i] == \\'R\\') v.push_back({\\'R\\',i});\\n                    else if(dominoes[i] == \\'L\\') v.push_back({\\'L\\',i});\\n            }\\n           if(v.size() == 0) return dominoes;\\n             if(v[0].first == \\'L\\'){\\n                     for(int j = 0;j<=v[0].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n            for(int i=0;i<v.size()-1;i++){\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'L\\'){\\n                        int k = v[i+1].second - v[i].second-1;\\n                        for(int j=0;j<k/2;j++){\\n                            dominoes[v[i].second + j + 1] = \\'R\\';\\n                        } \\n                        for(int j = k/2+1;j<=k;j++){\\n                            dominoes[v[i].second + j] = \\'L\\';\\n                        }\\n                       \\n                        if(k%2!=0) dominoes[v[i].second + (k+1)/2] = \\'.\\';\\n                 }\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'R\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'R\\';\\n                 }\\n                 if(v[i].first == \\'L\\' && v[i+1].first == \\'L\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n                 \\n            }\\n            if(v[v.size() - 1].first == \\'R\\'){\\n                for(int j=v[v.size()-1].second;j<n;j++) dominoes[j] = \\'R\\';\\n            }\\n            return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489355,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans=s;\\n        int n=ans.size(),r=-1;\\n        for(int i=0; i<n; i++) {\\n            if(s[i]==\\'L\\' && r==-1) {\\n                for(int l=i-1; l>=0 && s[l]==\\'.\\'; l--) {\\n                    ans[l]=\\'L\\';\\n                }\\n            }\\n            else if(s[i]==\\'R\\') {\\n                while(r!=-1 && r<i)\\n                    ans[r++]=\\'R\\';\\n                r=i;\\n            }\\n            else if(s[i]==\\'L\\') {\\n                int l=i;\\n                while(r<l) {\\n                    ans[r++]=\\'R\\';\\n                    ans[l--]=\\'L\\';\\n                }\\n                r=-1;\\n            }\\n        }\\n        while(r!=-1 && r<n)\\n            ans[r++]=\\'R\\';\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = list(dominoes)\\n        n = len(arr)\\n        l = r = -1\\n        for i, c in enumerate(arr):\\n            if c is \\'.\\':\\n                continue\\n            if c is \\'L\\':\\n                if l >= r:\\n                    while l < i:\\n                        l += 1\\n                        arr[l] = \\'L\\'\\n                else:\\n                    l = i\\n                    lo, hi = r + 1, l - 1\\n                    while lo < hi:\\n                        arr[lo] = \\'R\\'\\n                        arr[hi] = \\'L\\'\\n                        lo += 1\\n                        hi -= 1\\n            else:\\n                if r > l:\\n                    while r < i:\\n                        arr[r] = \\'R\\'\\n                        r += 1\\n                else:\\n                    r = i\\n        if r > l:\\n            while r < n:\\n                arr[r] = \\'R\\'\\n                r += 1\\n        \\n        return \\'\\'.join(arr)\\n```\\n\\n```Java []\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] dos = dominoes.toCharArray();\\n        int left = \\'L\\';\\n        int i = 0;\\n        while(i<dos.length){\\n            if(dos[i] == \\'.\\'){\\n                int j = i;\\n                while(j<dos.length && dos[j] == \\'.\\'){\\n                    j++;\\n                }\\n                int right = j>=dos.length? \\'R\\': dos[j];\\n                if(right == left){\\n                    while(i < j){\\n                        dos[i++] = (char)right;\\n                    }\\n                }else if(right == \\'R\\'){\\n                    i = j-1;\\n                }else{\\n                    j--;\\n                    while(i < j){\\n                        dos[i++] = (char)left;\\n                        dos[j--] = (char)right;\\n                    }\\n                }\\n                left = right;\\n            }else{\\n                left = dos[i];\\n            }\\n            i++;\\n        }\\n        return new String(dos);\\n    }\\n    public String pushDominoes1(String dominoes) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] dos = dominoes.toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        int lastRight = -1;\\n        int lastLeft = -1;\\n\\n        for(int i = 0; i<dos.length;){\\n            if(dos[i] == \\'R\\'){\\n                while(i<dos.length && dos[i] != \\'L\\'){\\n                    stack.push(\\'R\\');\\n                    if(dos[i] == \\'R\\'){\\n                        lastRight = i;\\n                    }\\n                    i++;\\n                }\\n            }else if(dos[i] == \\'L\\'){\\n                int numOfPop = 0;\\n                if(lastLeft == -1 && lastRight == -1){\\n                    numOfPop = i;\\n                }else{\\n                    numOfPop = lastLeft > lastRight? (i- lastLeft):(i-lastRight)/2;\\n                }\\n                int count = numOfPop;\\n                while(count > 0){\\n                    stack.pop();\\n                    count--;\\n                }\\n                if(lastRight != -1 && lastRight > lastLeft && (i-lastRight)%2 == 0 && numOfPop >= 1) {\\n                    stack.push(\\'.\\');\\n                    numOfPop--;\\n                }\\n                while(count < numOfPop){\\n                    stack.push(\\'L\\');\\n                    count++;\\n                }\\n                stack.push(\\'L\\');\\n                lastLeft = i;\\n                i++;\\n            }else{\\n                stack.push(dos[i]);\\n                i++;\\n            }\\n        }\\n        while(!stack.isEmpty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans=s;\\n        int n=ans.size(),r=-1;\\n        for(int i=0; i<n; i++) {\\n            if(s[i]==\\'L\\' && r==-1) {\\n                for(int l=i-1; l>=0 && s[l]==\\'.\\'; l--) {\\n                    ans[l]=\\'L\\';\\n                }\\n            }\\n            else if(s[i]==\\'R\\') {\\n                while(r!=-1 && r<i)\\n                    ans[r++]=\\'R\\';\\n                r=i;\\n            }\\n            else if(s[i]==\\'L\\') {\\n                int l=i;\\n                while(r<l) {\\n                    ans[r++]=\\'R\\';\\n                    ans[l--]=\\'L\\';\\n                }\\n                r=-1;\\n            }\\n        }\\n        while(r!=-1 && r<n)\\n            ans[r++]=\\'R\\';\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = list(dominoes)\\n        n = len(arr)\\n        l = r = -1\\n        for i, c in enumerate(arr):\\n            if c is \\'.\\':\\n                continue\\n            if c is \\'L\\':\\n                if l >= r:\\n                    while l < i:\\n                        l += 1\\n                        arr[l] = \\'L\\'\\n                else:\\n                    l = i\\n                    lo, hi = r + 1, l - 1\\n                    while lo < hi:\\n                        arr[lo] = \\'R\\'\\n                        arr[hi] = \\'L\\'\\n                        lo += 1\\n                        hi -= 1\\n            else:\\n                if r > l:\\n                    while r < i:\\n                        arr[r] = \\'R\\'\\n                        r += 1\\n                else:\\n                    r = i\\n        if r > l:\\n            while r < n:\\n                arr[r] = \\'R\\'\\n                r += 1\\n        \\n        return \\'\\'.join(arr)\\n```\n```Java []\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] dos = dominoes.toCharArray();\\n        int left = \\'L\\';\\n        int i = 0;\\n        while(i<dos.length){\\n            if(dos[i] == \\'.\\'){\\n                int j = i;\\n                while(j<dos.length && dos[j] == \\'.\\'){\\n                    j++;\\n                }\\n                int right = j>=dos.length? \\'R\\': dos[j];\\n                if(right == left){\\n                    while(i < j){\\n                        dos[i++] = (char)right;\\n                    }\\n                }else if(right == \\'R\\'){\\n                    i = j-1;\\n                }else{\\n                    j--;\\n                    while(i < j){\\n                        dos[i++] = (char)left;\\n                        dos[j--] = (char)right;\\n                    }\\n                }\\n                left = right;\\n            }else{\\n                left = dos[i];\\n            }\\n            i++;\\n        }\\n        return new String(dos);\\n    }\\n    public String pushDominoes1(String dominoes) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] dos = dominoes.toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        int lastRight = -1;\\n        int lastLeft = -1;\\n\\n        for(int i = 0; i<dos.length;){\\n            if(dos[i] == \\'R\\'){\\n                while(i<dos.length && dos[i] != \\'L\\'){\\n                    stack.push(\\'R\\');\\n                    if(dos[i] == \\'R\\'){\\n                        lastRight = i;\\n                    }\\n                    i++;\\n                }\\n            }else if(dos[i] == \\'L\\'){\\n                int numOfPop = 0;\\n                if(lastLeft == -1 && lastRight == -1){\\n                    numOfPop = i;\\n                }else{\\n                    numOfPop = lastLeft > lastRight? (i- lastLeft):(i-lastRight)/2;\\n                }\\n                int count = numOfPop;\\n                while(count > 0){\\n                    stack.pop();\\n                    count--;\\n                }\\n                if(lastRight != -1 && lastRight > lastLeft && (i-lastRight)%2 == 0 && numOfPop >= 1) {\\n                    stack.push(\\'.\\');\\n                    numOfPop--;\\n                }\\n                while(count < numOfPop){\\n                    stack.push(\\'L\\');\\n                    count++;\\n                }\\n                stack.push(\\'L\\');\\n                lastLeft = i;\\n                i++;\\n            }else{\\n                stack.push(dos[i]);\\n                i++;\\n            }\\n        }\\n        while(!stack.isEmpty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184854,
                "title": "java-o-n-time",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private void replace(char[] d, char c, int a, int b){\\n        while(a < b){\\n            d[a++] = c;\\n        }\\n    }\\n    public String pushDominoes(String dominoes) {\\n        char[] d = dominoes.toCharArray();\\n        int prev = -1;\\n        for(int a = 0; a < d.length; a++){\\n            if(d[a] == \\'L\\'){\\n                if(prev == -1 || d[prev] == \\'L\\'){\\n                    replace(d, \\'L\\', prev + 1, a);\\n                }else{\\n                    int diff = a - prev;\\n                    int mid = prev + diff / 2;\\n                    replace(d, \\'R\\', prev + 1, mid + (diff % 2 == 1 ? 1 : 0));\\n                    replace(d, \\'L\\', mid + 1, a);\\n                }\\n                prev = a;\\n            }else if(d[a] == \\'R\\'){\\n                if(prev != -1 && d[prev] == \\'R\\'){\\n                   replace(d, \\'R\\', prev, a);\\n                }\\n                prev = a;\\n            }\\n        }\\n        if(prev != -1 && d[prev] == \\'R\\') replace(d, \\'R\\', prev + 1, d.length);\\n        return String.valueOf(d);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    private void replace(char[] d, char c, int a, int b){\\n        while(a < b){\\n            d[a++] = c;\\n        }\\n    }\\n    public String pushDominoes(String dominoes) {\\n        char[] d = dominoes.toCharArray();\\n        int prev = -1;\\n        for(int a = 0; a < d.length; a++){\\n            if(d[a] == \\'L\\'){\\n                if(prev == -1 || d[prev] == \\'L\\'){\\n                    replace(d, \\'L\\', prev + 1, a);\\n                }else{\\n                    int diff = a - prev;\\n                    int mid = prev + diff / 2;\\n                    replace(d, \\'R\\', prev + 1, mid + (diff % 2 == 1 ? 1 : 0));\\n                    replace(d, \\'L\\', mid + 1, a);\\n                }\\n                prev = a;\\n            }else if(d[a] == \\'R\\'){\\n                if(prev != -1 && d[prev] == \\'R\\'){\\n                   replace(d, \\'R\\', prev, a);\\n                }\\n                prev = a;\\n            }\\n        }\\n        if(prev != -1 && d[prev] == \\'R\\') replace(d, \\'R\\', prev + 1, d.length);\\n        return String.valueOf(d);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973911,
                "title": "my-2-pointers-java-code",
                "content": "The code surely looks big but if you do a dry run on the example test case 2, you\\'ll realize that the logic is actually quite simple and easy to understand\\n\\n```\\nclass Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length(), start=0, end=0;\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while(end<n && s.charAt(end) == \\'.\\') end++;\\n        \\n\\t\\t/// to take care of inputs starting with \\'.\\', like \"...LRRL.LLRRL\"\\n        if(end<n && s.charAt(start)==\\'.\\'){\\n            if(s.charAt(end) == \\'L\\'){\\n                for(int i=start; i<end; i++) sb.setCharAt(i, \\'L\\');\\n            }\\n            start = end;\\n        }\\n        \\n        while(end<n){\\n            if(s.charAt(end)==\\'.\\'){\\n                end++;\\n                continue;\\n            }\\n            \\n            else if(s.charAt(start) == \\'L\\' && s.charAt(end) == \\'R\\') start = end;\\n            \\n            else if(s.charAt(start) == \\'R\\' && s.charAt(end) == \\'L\\'){\\n                int len = (end-start-1);\\n                int size = len;\\n                size /= 2;\\n                \\n                for(int i=start; i<=(start+size); i++){\\n                    sb.setCharAt(i, \\'R\\');\\n                }\\n                if(len % 2 == 0) for(int i=(start+size+1); i<end; i++) sb.setCharAt(i, \\'L\\'); /// \"R..L\" -> \"RRLL\"\\n                else for(int i=(start+size+2); i<end; i++) sb.setCharAt(i, \\'L\\'); /// \"R...L\" -> \"RR.LL\",\\n                \\n                start = end;\\n            }\\n            \\n            else if(s.charAt(start) == s.charAt(end)){\\n                for(int i=start+1; i<end; i++) sb.setCharAt(i, sb.charAt(start));\\n                start = end;\\n            }\\n            \\n            end++;\\n        }\\n        \\n\\t\\t/// to take care of inputs ending with \\'.\\', like \"LRRL..RR..R...\"\\n        if(end == n && s.charAt(end-1)==\\'.\\'){\\n            if(s.charAt(start) == \\'R\\'){\\n                for(int i=start+1; i<end; i++) sb.setCharAt(i, \\'R\\');\\n                start = end;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length(), start=0, end=0;\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while(end<n && s.charAt(end) == \\'.\\') end++;\\n        \\n\\t\\t/// to take care of inputs starting with \\'.\\', like \"...LRRL.LLRRL\"\\n        if(end<n && s.charAt(start)==\\'.\\'){\\n            if(s.charAt(end) == \\'L\\'){\\n                for(int i=start; i<end; i++) sb.setCharAt(i, \\'L\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2930080,
                "title": "swift-fast-solution-o-n-o-1",
                "content": "# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\n    func pushDominoes(_ dominoes: String) -> String {\\n        var dominoes = Array(dominoes)\\n        var L = 0\\n        var R = 0\\n        \\n        for i in 0..<dominoes.count where dominoes[i] == \".\" {\\n            L = i - 1\\n            R = i + 1\\n            \\n            while L >= 0 && dominoes[L] == \".\" {\\n                L -= 1\\n            }\\n            \\n            while R < dominoes.count && dominoes[R] == \".\" {\\n                R += 1\\n            }\\n            \\n            if L == -1 {\\n                L = 0\\n            }\\n            \\n            if R == dominoes.count {\\n                R = dominoes.count - 1\\n            }\\n            \\n            switch (dominoes[L], dominoes[R]) {\\n            case (\".\", \"L\"), (\"L\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"L\"\\n                    L += 1\\n                }\\n            case (\"R\", \"R\"), (\"R\", \".\"):\\n                while L < R {\\n                    dominoes[R] = \"R\"\\n                    R -= 1\\n                }\\n            case (\"R\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"R\"\\n                    L += 1\\n                    dominoes[R] = \"L\"\\n                    R -= 1\\n                }\\n            default:\\n                break\\n            }\\n        }\\n        return String(dominoes)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func pushDominoes(_ dominoes: String) -> String {\\n        var dominoes = Array(dominoes)\\n        var L = 0\\n        var R = 0\\n        \\n        for i in 0..<dominoes.count where dominoes[i] == \".\" {\\n            L = i - 1\\n            R = i + 1\\n            \\n            while L >= 0 && dominoes[L] == \".\" {\\n                L -= 1\\n            }\\n            \\n            while R < dominoes.count && dominoes[R] == \".\" {\\n                R += 1\\n            }\\n            \\n            if L == -1 {\\n                L = 0\\n            }\\n            \\n            if R == dominoes.count {\\n                R = dominoes.count - 1\\n            }\\n            \\n            switch (dominoes[L], dominoes[R]) {\\n            case (\".\", \"L\"), (\"L\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"L\"\\n                    L += 1\\n                }\\n            case (\"R\", \"R\"), (\"R\", \".\"):\\n                while L < R {\\n                    dominoes[R] = \"R\"\\n                    R -= 1\\n                }\\n            case (\"R\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"R\"\\n                    L += 1\\n                    dominoes[R] = \"L\"\\n                    R -= 1\\n                }\\n            default:\\n                break\\n            }\\n        }\\n        return String(dominoes)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707417,
                "title": "c-o-n-space-o-n-time-complexity",
                "content": "Just Kep track of where the nearest Left and Right domino was. If left was near then it will fall towards left. Similarly for right. If both are equally near then it will be balanced condition.\\n\\n\\n```\\n string pushDominoes(string dominoes) \\n    {\\n        int sl=dominoes.length();\\n        string ans=dominoes;\\n        int left[sl];\\n        int right[sl];\\n        int r=INT_MIN,l=INT_MIN;\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                right[i]=r;\\n                if(r!=INT_MIN){r--;}\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                right[i]=1e5;\\n                r=1e5-1;\\n            }\\n            else\\n            {\\n                r=INT_MIN;\\n                right[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=sl-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                left[i]=l;\\n                if(l!=INT_MIN){l--;}\\n            }\\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                left[i]=1e5;\\n                l=1e5-1;\\n            }\\n            else\\n            {\\n                l=INT_MIN;\\n                left[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(left[i]>right[i]){ans[i]=\\'L\\';}\\n            else if(left[i]<right[i]){ans[i]=\\'R\\';}\\n            else{ans[i]=\\'.\\';}\\n        }\\n        return ans;  \\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "Just Kep track of where the nearest Left and Right domino was. If left was near then it will fall towards left. Similarly for right. If both are equally near then it will be balanced condition.\\n\\n\\n```\\n string pushDominoes(string dominoes) \\n    {\\n        int sl=dominoes.length();\\n        string ans=dominoes;\\n        int left[sl];\\n        int right[sl];\\n        int r=INT_MIN,l=INT_MIN;\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                right[i]=r;\\n                if(r!=INT_MIN){r--;}\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                right[i]=1e5;\\n                r=1e5-1;\\n            }\\n            else\\n            {\\n                r=INT_MIN;\\n                right[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=sl-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                left[i]=l;\\n                if(l!=INT_MIN){l--;}\\n            }\\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                left[i]=1e5;\\n                l=1e5-1;\\n            }\\n            else\\n            {\\n                l=INT_MIN;\\n                left[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(left[i]>right[i]){ans[i]=\\'L\\';}\\n            else if(left[i]<right[i]){ans[i]=\\'R\\';}\\n            else{ans[i]=\\'.\\';}\\n        }\\n        return ans;  \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2633178,
                "title": "simple-do-as-said-brute-force-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        vector<pair<int, int>> vec;\\n        bool r = false;\\n        int l = -1;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(r==true && l!=-1 && dominoes[i]==\\'L\\')\\n            {\\n                vec.push_back({l, i});\\n                r = false;\\n                l=-1;\\n            }\\n            \\n            if(dominoes[i]==\\'R\\')\\n            {\\n                if(r==true && l!=-1)\\n                {\\n                    while(l<i)\\n                    {\\n                        dominoes[l]=\\'R\\';\\n                        l++;\\n                    }\\n                }\\n                r = true;\\n                l = i;\\n            }\\n        }\\n        \\n        bool rr= false;\\n        int ll = -1;\\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(rr==true && ll!=-1 && dominoes[i]==\\'R\\')\\n            {\\n                //vec.push_back({l, i});\\n                rr = false;\\n                ll = -1;\\n            }\\n            \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                if(rr==true && ll!=-1)\\n                {\\n                    while(ll>i)\\n                    {\\n                        dominoes[ll]=\\'L\\';\\n                        ll--;\\n                    }\\n                }\\n                rr = true;\\n                ll = i;\\n            }\\n        }\\n        \\n        for(auto i:vec)\\n        {\\n            while(i.first<i.second)\\n            {\\n                dominoes[i.first]=\\'R\\';\\n                dominoes[i.second]=\\'L\\';\\n                i.first++;\\n                i.second--;\\n            }\\n        }\\n        \\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                int k=i;\\n                while(k>=0)\\n                {\\n                    dominoes[k]=\\'L\\';\\n                    k--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                int k=i;\\n                while(k<dominoes.size())\\n                {\\n                    dominoes[k]=\\'R\\';\\n                    k++;\\n                }\\n                break;\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        vector<pair<int, int>> vec;\\n        bool r = false;\\n        int l = -1;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(r==true && l!=-1 && dominoes[i]==\\'L\\')\\n            {\\n                vec.push_back({l, i});\\n                r = false;\\n                l=-1;\\n            }\\n            \\n            if(dominoes[i]==\\'R\\')\\n            {\\n                if(r==true && l!=-1)\\n                {\\n                    while(l<i)\\n                    {\\n                        dominoes[l]=\\'R\\';\\n                        l++;\\n                    }\\n                }\\n                r = true;\\n                l = i;\\n            }\\n        }\\n        \\n        bool rr= false;\\n        int ll = -1;\\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(rr==true && ll!=-1 && dominoes[i]==\\'R\\')\\n            {\\n                //vec.push_back({l, i});\\n                rr = false;\\n                ll = -1;\\n            }\\n            \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                if(rr==true && ll!=-1)\\n                {\\n                    while(ll>i)\\n                    {\\n                        dominoes[ll]=\\'L\\';\\n                        ll--;\\n                    }\\n                }\\n                rr = true;\\n                ll = i;\\n            }\\n        }\\n        \\n        for(auto i:vec)\\n        {\\n            while(i.first<i.second)\\n            {\\n                dominoes[i.first]=\\'R\\';\\n                dominoes[i.second]=\\'L\\';\\n                i.first++;\\n                i.second--;\\n            }\\n        }\\n        \\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                int k=i;\\n                while(k>=0)\\n                {\\n                    dominoes[k]=\\'L\\';\\n                    k--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                int k=i;\\n                while(k<dominoes.size())\\n                {\\n                    dominoes[k]=\\'R\\';\\n                    k++;\\n                }\\n                break;\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632491,
                "title": "time-based-simulation-queue",
                "content": "```\\nclass Solution {\\n\\t//just for debugging\\n    void  print(unordered_map<int,char> &mp) {\\n        if (mp.size() < 1) {\\n            return;\\n        }\\n        cout<<\"\\\\n\";\\n        unordered_map<int, char>:: iterator it;\\n        for(it = mp.begin(); it != mp.end(); it++) {\\n            cout<<\"[\"<<it->first<<\" \"<<it->second<<\"],\";\\n        }\\n        \\n    }\\npublic:\\n    \\n    string pushDominoes(string dominoes) {\\n        queue<int> q;\\n        for(int i = 0; i < dominoes.size(); i++) {\\n            if (dominoes[i] == \\'R\\' || dominoes[i] == \\'L\\') {\\n                q.push(i);\\n            }\\n        }\\n        /*\\n\\t\\t* every iteration of while loop is one second simulated. In that one second we will exert force on neighbour dominoe\\n\\t\\t* A Map is used to track what force is exerted on a specific neigbour\\n\\t\\t* if in that particular second we have opposing force acting on the neigbour then object would remain stand still \\n\\t\\t*/\\n\\t\\twhile (q.size() > 0) {\\n            int curSize = q.size();\\n            unordered_map<int, char> mp;    \\n            unordered_map<int, char>:: iterator it;   //int represent index of neigbour and char represent force acting on it in next second\\n            \\n            for (int i = 0; i < curSize; i++) {\\n                int pos = q.front(); q.pop();\\n               \\n      \\n                if (dominoes[pos] == \\'R\\' && (pos < dominoes.size() - 1) && dominoes[pos+1] == \\'.\\') {\\n                    it = mp.find(pos + 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'L\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                if (dominoes[pos] == \\'L\\' && pos > 0 && dominoes[pos - 1] == \\'.\\') {\\n                    it = mp.find(pos - 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'R\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos-1] = \\'L\\';\\n                    }\\n                }\\n            }\\n            //print(mp);\\n\\t\\t\\t// This step we will setup for simulating the next second;\\n            for (it = mp.begin(); it != mp.end(); it++) {\\n                    dominoes[it->first] = it->second;\\n                    q.push(it->first);\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n\\t//just for debugging\\n    void  print(unordered_map<int,char> &mp) {\\n        if (mp.size() < 1) {\\n            return;\\n        }\\n        cout<<\"\\\\n\";\\n        unordered_map<int, char>:: iterator it;\\n        for(it = mp.begin(); it != mp.end(); it++) {\\n            cout<<\"[\"<<it->first<<\" \"<<it->second<<\"],\";\\n        }\\n        \\n    }\\npublic:\\n    \\n    string pushDominoes(string dominoes) {\\n        queue<int> q;\\n        for(int i = 0; i < dominoes.size(); i++) {\\n            if (dominoes[i] == \\'R\\' || dominoes[i] == \\'L\\') {\\n                q.push(i);\\n            }\\n        }\\n        /*\\n\\t\\t* every iteration of while loop is one second simulated. In that one second we will exert force on neighbour dominoe\\n\\t\\t* A Map is used to track what force is exerted on a specific neigbour\\n\\t\\t* if in that particular second we have opposing force acting on the neigbour then object would remain stand still \\n\\t\\t*/\\n\\t\\twhile (q.size() > 0) {\\n            int curSize = q.size();\\n            unordered_map<int, char> mp;    \\n            unordered_map<int, char>:: iterator it;   //int represent index of neigbour and char represent force acting on it in next second\\n            \\n            for (int i = 0; i < curSize; i++) {\\n                int pos = q.front(); q.pop();\\n               \\n      \\n                if (dominoes[pos] == \\'R\\' && (pos < dominoes.size() - 1) && dominoes[pos+1] == \\'.\\') {\\n                    it = mp.find(pos + 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'L\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                if (dominoes[pos] == \\'L\\' && pos > 0 && dominoes[pos - 1] == \\'.\\') {\\n                    it = mp.find(pos - 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'R\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos-1] = \\'L\\';\\n                    }\\n                }\\n            }\\n            //print(mp);\\n\\t\\t\\t// This step we will setup for simulating the next second;\\n            for (it = mp.begin(); it != mp.end(); it++) {\\n                    dominoes[it->first] = it->second;\\n                    q.push(it->first);\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2632464,
                "title": "faster-than-85-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/1ccbc1d8-c069-4b46-8e49-90a26f47424f_1664316389.9166017.png)\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = list(dominoes) #convert string to list\\n        i = last_point = 0 #set start point and last point which ready to being \\'L\\'\\n            \\n        while i < len(dominoes): #start cycle\\n            if dominoes[i] == \\'.\\': #go next if . in place\\n                i += 1\\n            elif dominoes[i] == \\'L\\': #if this, fill all \\'.\\' between last_point and i-1 and go next (last_point <= i forever)\\n                for j in range(last_point, i):\\n                    dominoes[j] = \\'L\\'\\n                i += 1\\n                last_point = i\\n            else: #if we in \\'R\\', check two ways: 1. it\\'s to (end or next \\'R\\') or (next \\'L\\')\\n                j = i + 1\\n                while j < len(dominoes) and dominoes[j] == \\'.\\': #check ways there\\n                    j += 1\\n                    \\n                if j == len(dominoes) or dominoes[j] == \\'R\\': #first way: fill all \\'.\\' the \\'R\\' and set next last_point after end this way\\n                    last_r = j\\n                    last_point = j + 1\\n                else: #second way: fill only half of all \\'.\\' and if count \\'.\\' is odd save 1 \\'.\\' for latter\\n                    last_r = i + 1 + (j - i - 1) // 2\\n                    last_point = j - (j - i - 1) // 2\\n                    \\n                for k in range(i+1, last_r): #filling \\'R\\' there\\n                        dominoes[k] = \\'R\\'\\n\\n                i = j #jump to next step\\n                \\n        return \\'\\'.join(dominoes) #return answer\\n\\n```\\n\\nP.S. Sry for my eng. It\\'s my first solution with comments)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = list(dominoes) #convert string to list\\n        i = last_point = 0 #set start point and last point which ready to being \\'L\\'\\n            \\n        while i < len(dominoes): #start cycle\\n            if dominoes[i] == \\'.\\': #go next if . in place\\n                i += 1\\n            elif dominoes[i] == \\'L\\': #if this, fill all \\'.\\' between last_point and i-1 and go next (last_point <= i forever)\\n                for j in range(last_point, i):\\n                    dominoes[j] = \\'L\\'\\n                i += 1\\n                last_point = i\\n            else: #if we in \\'R\\', check two ways: 1. it\\'s to (end or next \\'R\\') or (next \\'L\\')\\n                j = i + 1\\n                while j < len(dominoes) and dominoes[j] == \\'.\\': #check ways there\\n                    j += 1\\n                    \\n                if j == len(dominoes) or dominoes[j] == \\'R\\': #first way: fill all \\'.\\' the \\'R\\' and set next last_point after end this way\\n                    last_r = j\\n                    last_point = j + 1\\n                else: #second way: fill only half of all \\'.\\' and if count \\'.\\' is odd save 1 \\'.\\' for latter\\n                    last_r = i + 1 + (j - i - 1) // 2\\n                    last_point = j - (j - i - 1) // 2\\n                    \\n                for k in range(i+1, last_r): #filling \\'R\\' there\\n                        dominoes[k] = \\'R\\'\\n\\n                i = j #jump to next step\\n                \\n        return \\'\\'.join(dominoes) #return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632350,
                "title": "c-o-n-best-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=s.size();\\n        vector<int> right(n),left(n);\\n        int r=-1,l=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')r=i;\\n            else if(s[i]==\\'L\\')r=-1;\\n            right[i]=r;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'L\\')l=i;\\n            else if(s[i]==\\'R\\')l=-1;\\n            left[i]=l;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\')\\n            {\\n                if(right[i]==-1 && left[i]==-1)\\n                    continue;\\n                if(right[i]==-1 && left[i]!=-1)s[i]=\\'L\\';\\n                else if(left[i]==-1 && right[i]!=-1)s[i]=\\'R\\';\\n                else\\n                {\\n                    if(left[i]-i<i-right[i]) s[i]=\\'L\\';\\n                    else if(i-right[i]<left[i]-i)s[i]=\\'R\\';\\n                    \\n                }\\n               \\n            }\\n        }\\n        return s;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=s.size();\\n        vector<int> right(n),left(n);\\n        int r=-1,l=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')r=i;\\n            else if(s[i]==\\'L\\')r=-1;\\n            right[i]=r;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'L\\')l=i;\\n            else if(s[i]==\\'R\\')l=-1;\\n            left[i]=l;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\')\\n            {\\n                if(right[i]==-1 && left[i]==-1)\\n                    continue;\\n                if(right[i]==-1 && left[i]!=-1)s[i]=\\'L\\';\\n                else if(left[i]==-1 && right[i]!=-1)s[i]=\\'R\\';\\n                else\\n                {\\n                    if(left[i]-i<i-right[i]) s[i]=\\'L\\';\\n                    else if(i-right[i]<left[i]-i)s[i]=\\'R\\';\\n                    \\n                }\\n               \\n            }\\n        }\\n        return s;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632144,
                "title": "o-1-space-o-n-time-c-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    void cg(string& s,char c,int st,int ed){\\n        for(int i=st;i<=ed;i++)\\n            s[i] = c;\\n    }\\n    \\n    string pushDominoes(string dm) {\\n        int n = dm.size();\\n        int st = 0;\\n        char a,b;\\n        int ok = 0;\\n        while(ok<n && dm[ok]==\\'.\\')\\n            ok++;\\n        \\n        if(ok==n)\\n            return dm;\\n            \\n        if(dm[ok]==\\'L\\'){\\n            for(int i=0;i<=ok;i++)\\n                dm[i]=\\'L\\';\\n        }\\n        \\n        \\n        a = dm[ok];\\n        st = ok;\\n        for(int i=ok+1;i<n;i++){\\n            \\n            while(i<n && dm[i]==\\'.\\')\\n                i++;\\n            \\n            if(i==n)\\n                i = n - 1;\\n            \\n            b = dm[i];\\n                \\n            if(a==\\'L\\' && b==\\'L\\')\\n                cg(dm,\\'L\\',st,i);\\n            else if(a==\\'R\\' && b==\\'R\\')\\n                cg(dm,\\'R\\',st,i);\\n            else if(a==\\'R\\' && b==\\'L\\'){\\n                int u = st,v =i;\\n                while(u<v)\\n                    dm[v--] = \\'L\\',dm[u++] = \\'R\\';\\n                \\n            }\\n            \\n            st = i;\\n            a = b;\\n        }\\n        \\n        int lst = n-1;\\n        char k;\\n        while(lst>=0){\\n            if(dm[lst]==\\'L\\' || dm[lst]==\\'R\\'){\\n                k = dm[lst];break;\\n            }\\n            lst--;\\n        }\\n        if(lst>=0 && k==\\'R\\')\\n            while(lst<n)\\n                dm[lst++] = k; \\n            \\n        return dm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void cg(string& s,char c,int st,int ed){\\n        for(int i=st;i<=ed;i++)\\n            s[i] = c;\\n    }\\n    \\n    string pushDominoes(string dm) {\\n        int n = dm.size();\\n        int st = 0;\\n        char a,b;\\n        int ok = 0;\\n        while(ok<n && dm[ok]==\\'.\\')\\n            ok++;\\n        \\n        if(ok==n)\\n            return dm;\\n            \\n        if(dm[ok]==\\'L\\'){\\n            for(int i=0;i<=ok;i++)\\n                dm[i]=\\'L\\';\\n        }\\n        \\n        \\n        a = dm[ok];\\n        st = ok;\\n        for(int i=ok+1;i<n;i++){\\n            \\n            while(i<n && dm[i]==\\'.\\')\\n                i++;\\n            \\n            if(i==n)\\n                i = n - 1;\\n            \\n            b = dm[i];\\n                \\n            if(a==\\'L\\' && b==\\'L\\')\\n                cg(dm,\\'L\\',st,i);\\n            else if(a==\\'R\\' && b==\\'R\\')\\n                cg(dm,\\'R\\',st,i);\\n            else if(a==\\'R\\' && b==\\'L\\'){\\n                int u = st,v =i;\\n                while(u<v)\\n                    dm[v--] = \\'L\\',dm[u++] = \\'R\\';\\n                \\n            }\\n            \\n            st = i;\\n            a = b;\\n        }\\n        \\n        int lst = n-1;\\n        char k;\\n        while(lst>=0){\\n            if(dm[lst]==\\'L\\' || dm[lst]==\\'R\\'){\\n                k = dm[lst];break;\\n            }\\n            lst--;\\n        }\\n        if(lst>=0 && k==\\'R\\')\\n            while(lst<n)\\n                dm[lst++] = k; \\n            \\n        return dm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632054,
                "title": "javascript-solution-sc-o-1-two-pointers",
                "content": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = dominoes.split(\\'\\');\\n    let l = 0, r = 0;\\n    while(r < dominoes.length){\\n        if(dominoes[r] === \\'L\\') while(l <= r) dominoes[l++] = \\'L\\';\\n        else if(dominoes[r] === \\'R\\'){\\n            l = r;\\n            let f = 0;\\n            r++;\\n            while(r < dominoes.length) {\\n                if(dominoes[r] === \\'R\\') {\\n                    f = 1;\\n                    break;\\n                }\\n                if(dominoes[r] === \\'L\\') break;\\n                r++;\\n            }\\n            if(r === dominoes.length || f === 1) {\\n                while(l < r) dominoes[l++] = \\'R\\';\\n                r--;\\n            }\\n            else {\\n                let dif = (r - l - 1) / 2 | 0;\\n                for(let i = 1; i <= dif; i++){\\n                    dominoes[l + i] = \\'R\\';\\n                    dominoes[r - i] = \\'L\\';\\n                }\\n                l = r + 1;\\n            }\\n        }\\n        r++;\\n    }\\n    return dominoes.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = dominoes.split(\\'\\');\\n    let l = 0, r = 0;\\n    while(r < dominoes.length){\\n        if(dominoes[r] === \\'L\\') while(l <= r) dominoes[l++] = \\'L\\';\\n        else if(dominoes[r] === \\'R\\'){\\n            l = r;\\n            let f = 0;\\n            r++;\\n            while(r < dominoes.length) {\\n                if(dominoes[r] === \\'R\\') {\\n                    f = 1;\\n                    break;\\n                }\\n                if(dominoes[r] === \\'L\\') break;\\n                r++;\\n            }\\n            if(r === dominoes.length || f === 1) {\\n                while(l < r) dominoes[l++] = \\'R\\';\\n                r--;\\n            }\\n            else {\\n                let dif = (r - l - 1) / 2 | 0;\\n                for(let i = 1; i <= dif; i++){\\n                    dominoes[l + i] = \\'R\\';\\n                    dominoes[r - i] = \\'L\\';\\n                }\\n                l = r + 1;\\n            }\\n        }\\n        r++;\\n    }\\n    return dominoes.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631948,
                "title": "javascript-solution-use-string-prototype-replaceall",
                "content": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nfunction pushDominoes(dominoes) {\\n    while (true) {\\n        const newDominoes = dominoes.replaceAll(`R.L`, `_`).replaceAll(`.L`, `LL`).replaceAll(`R.`, `RR`).replaceAll(`_`, `R.L`);\\n        if (newDominoes === dominoes)\\n            return newDominoes;\\n        else dominoes = newDominoes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nfunction pushDominoes(dominoes) {\\n    while (true) {\\n        const newDominoes = dominoes.replaceAll(`R.L`, `_`).replaceAll(`.L`, `LL`).replaceAll(`R.`, `RR`).replaceAll(`_`, `R.L`);\\n        if (newDominoes === dominoes)\\n            return newDominoes;\\n        else dominoes = newDominoes;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631874,
                "title": "c-naive-approach-multiple-passes",
                "content": "Easy to understand, must upvote!\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        string finalDominoes(n, \\'#\\'), leftApplied = dominoes, rightApplied = dominoes;\\n        for(int i = n-1; i > 0; i--) {\\n            if(leftApplied[i] == \\'L\\' and leftApplied[i-1] == \\'.\\')\\n                leftApplied[i-1] = \\'L\\';\\n        }\\n        for(int i = 0; i < n-1; i++) {\\n            if(rightApplied[i] == \\'R\\' and rightApplied[i+1] == \\'.\\')\\n                rightApplied[i+1] = \\'R\\';\\n        }\\n        queue<int> windows; int windowCount = 0; \\n        for(int i = 0; i < n; i++) {\\n            if(leftApplied[i] == rightApplied[i])\\n                finalDominoes[i] = leftApplied[i];\\n            else if(leftApplied[i] == \\'.\\')\\n                finalDominoes[i] = rightApplied[i];\\n            else if(rightApplied[i] == \\'.\\')\\n                finalDominoes[i] = leftApplied[i];\\n            else {\\n                windowCount += 1; continue;\\n            }\\n            if(windowCount)\\n                windows.push(windowCount); \\n            windowCount = 0;\\n        }\\n        char prev = \\'\\\\0\\';\\n        for(int i = 0; i < n; i++) {\\n            if(finalDominoes[i] == \\'#\\') {\\n                int len = windows.front(); windows.pop();\\n                if(len == 1) {\\n                    finalDominoes[i] = \\'.\\';\\n                } else {\\n                    int j = i;\\n                    while(j < i + (len/2)) {    \\n                        finalDominoes[j] = prev;\\n                        j += 1;\\n                    }\\n                    if(len & 1) {\\n                        finalDominoes[j] = \\'.\\'; j += 1;\\n                    }\\n                    char remaining = (prev == \\'L\\')? \\'R\\': \\'L\\';\\n                    while(finalDominoes[j] == \\'#\\') {\\n                        finalDominoes[j] = remaining;\\n                        j += 1;\\n                    }\\n                    i = j-1;\\n                }\\n            }\\n            prev = finalDominoes[i];\\n        }\\n        return finalDominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        string finalDominoes(n, \\'#\\'), leftApplied = dominoes, rightApplied = dominoes;\\n        for(int i = n-1; i > 0; i--) {\\n            if(leftApplied[i] == \\'L\\' and leftApplied[i-1] == \\'.\\')\\n                leftApplied[i-1] = \\'L\\';\\n        }\\n        for(int i = 0; i < n-1; i++) {\\n            if(rightApplied[i] == \\'R\\' and rightApplied[i+1] == \\'.\\')\\n                rightApplied[i+1] = \\'R\\';\\n        }\\n        queue<int> windows; int windowCount = 0; \\n        for(int i = 0; i < n; i++) {\\n            if(leftApplied[i] == rightApplied[i])\\n                finalDominoes[i] = leftApplied[i];\\n            else if(leftApplied[i] == \\'.\\')\\n                finalDominoes[i] = rightApplied[i];\\n            else if(rightApplied[i] == \\'.\\')\\n                finalDominoes[i] = leftApplied[i];\\n            else {\\n                windowCount += 1; continue;\\n            }\\n            if(windowCount)\\n                windows.push(windowCount); \\n            windowCount = 0;\\n        }\\n        char prev = \\'\\\\0\\';\\n        for(int i = 0; i < n; i++) {\\n            if(finalDominoes[i] == \\'#\\') {\\n                int len = windows.front(); windows.pop();\\n                if(len == 1) {\\n                    finalDominoes[i] = \\'.\\';\\n                } else {\\n                    int j = i;\\n                    while(j < i + (len/2)) {    \\n                        finalDominoes[j] = prev;\\n                        j += 1;\\n                    }\\n                    if(len & 1) {\\n                        finalDominoes[j] = \\'.\\'; j += 1;\\n                    }\\n                    char remaining = (prev == \\'L\\')? \\'R\\': \\'L\\';\\n                    while(finalDominoes[j] == \\'#\\') {\\n                        finalDominoes[j] = remaining;\\n                        j += 1;\\n                    }\\n                    i = j-1;\\n                }\\n            }\\n            prev = finalDominoes[i];\\n        }\\n        return finalDominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631842,
                "title": "simple-java-solution-greedy-single-pass-solution",
                "content": "```\\n//if you found my solution usefull please upvote it\\nclass Solution \\n{\\n    public String pushDominoes(String dominoes) \\n    {\\n        StringBuilder ans=new StringBuilder(\"\");\\n        int i=0;\\n        while(i<dominoes.length())\\n        {\\n            char ch=dominoes.charAt(i);\\n            if(ch==\\'.\\')\\n            {\\n                int j=i+1;\\n                while(j<dominoes.length() && dominoes.charAt(j)!=\\'L\\' && dominoes.charAt(j)!=\\'R\\') j++;\\n                if(j<dominoes.length() && dominoes.charAt(j)==\\'L\\' )\\n                {\\n                    for(int k=i;k<=j;k++)  ans.append(\"L\");\\n                    i=j+1;\\n                }\\n                else if(j<dominoes.length() && dominoes.charAt(j)==\\'R\\')\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\".\");\\n                    i=j;\\n                }\\n                else if(j>=dominoes.length())\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\".\");\\n                    i=j;\\n                }\\n            }\\n            else if(ch==\\'R\\')\\n            {\\n                int j=i+1;\\n                while(j<dominoes.length() && dominoes.charAt(j)!=\\'L\\' && dominoes.charAt(j)!=\\'R\\') j++;\\n                if(j<dominoes.length() && dominoes.charAt(j)==\\'R\\')\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\"R\");\\n                    i=j;\\n                }\\n                else if(j<dominoes.length() && dominoes.charAt(j)==\\'L\\')\\n                {\\n                    int len=j-i+1;\\n                if(len%2==0)\\n                {\\n                    int half=len/2;\\n                    for(int k=0;k<half;k++)  ans.append(\"R\");\\n                    for(int k=0;k<half;k++)  ans.append(\"L\");\\n                }\\n                else\\n                {\\n                    int half=((len+1)/2)-1;\\n                    for(int k=0;k<half;k++)  ans.append(\"R\");\\n                    ans.append(\".\");\\n                    for(int k=0;k<half;k++)  ans.append(\"L\");\\n                }\\n                i=j+1;\\n                }\\n                else if(j>=dominoes.length())\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\"R\");\\n                    i=j;\\n                }\\n            }\\n            else if(ch==\\'L\\') \\n            {\\n                ans.append(\"L\");\\n                i++;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public String pushDominoes(String dominoes) \\n    {\\n        StringBuilder ans=new StringBuilder(\"\");\\n        int i=0;\\n        while(i<dominoes.length())\\n        {\\n            char ch=dominoes.charAt(i);\\n            if(ch==\\'.\\')\\n            {\\n                int j=i+1;\\n                while(j<dominoes.length() && dominoes.charAt(j)!=\\'L\\' && dominoes.charAt(j)!=\\'R\\') j++;\\n                if(j<dominoes.length() && dominoes.charAt(j)==\\'L\\' )\\n                {\\n                    for(int k=i;k<=j;k++)  ans.append(\"L\");\\n                    i=j+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2631809,
                "title": "python-one-liner",
                "content": "```\\n# 47.90% 30.84% (53.51% 30.84%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\'))\\n\\n```\\n\\n**Upd:**\\nTranslating \\'X\\' back to \\'R.L\\' only at last step - when no moves left.\\n\\n```\\n# 78.84% 36.51% (77.67% 33.26%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\'))\\n\\n```\\n\\n**Details:**\\n```\\n# 94.42% 34.42% (95.58% 34.42%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\ttest = dominoes.replace(\\'R.L\\', \\'X\\') # hiding edge case \\'R.L\\' with \\'X\\'\\n\\ttest = test.replace(\\'.L\\', \\'LL\\')     # falling left\\n\\ttest = test.replace(\\'R.\\', \\'RR\\')     # falling right\\n\\tif test != dominoes:                # falls happened\\n\\t\\treturn self.pushDominoes(test)  # continue pushing dominoes\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') # no falls - translating \\'X\\' back and returning final result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# 47.90% 30.84% (53.51% 30.84%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\'))\\n\\n```\n```\\n# 78.84% 36.51% (77.67% 33.26%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\'))\\n\\n```\n```\\n# 94.42% 34.42% (95.58% 34.42%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\ttest = dominoes.replace(\\'R.L\\', \\'X\\') # hiding edge case \\'R.L\\' with \\'X\\'\\n\\ttest = test.replace(\\'.L\\', \\'LL\\')     # falling left\\n\\ttest = test.replace(\\'R.\\', \\'RR\\')     # falling right\\n\\tif test != dominoes:                # falls happened\\n\\t\\treturn self.pushDominoes(test)  # continue pushing dominoes\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') # no falls - translating \\'X\\' back and returning final result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2631620,
                "title": "92-faster-89-less-memory-c-o-1-space-o-n-time",
                "content": "We only have to consider the interval with all ```\\'.\\'```, and handle all the cases for the same.\\nBranching in the helper function, can be evidently, a bit more clean, but the algorithm works just fine.\\nPlease upvote if you find the solution helpful.\\n***Thank You!!***\\n```\\nclass Solution {\\npublic:\\n    void func(string& s, int &last, int &idx, int &n) {\\n        if(last == -1 and idx == n) return;\\n        else if(last == -1) {\\n            if(s[idx] == \\'L\\') {\\n                for(int i=0;i<idx;i++) s[i] = \\'L\\';\\n            }\\n        }\\n        else if(idx == n) {\\n            if(s[last] == \\'R\\') {\\n                for(int i = last +1;i<n;i++) s[i] =\\'R\\';\\n            }\\n        }\\n        else {\\n            if(s[last] == \\'R\\' and s[idx] == \\'L\\') {\\n                int no_dom = idx - last - 1;\\n                for(int len = 1, i = last + 1; len <= (no_dom>>1);len++, i++)\\n                    s[i] = \\'R\\';\\n                for(int len = 1, i = idx - 1; len <= (no_dom>>1);len++, i--)\\n                    s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'R\\' and s[idx] == \\'R\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'R\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'L\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'R\\') {\\n                return;\\n            }\\n        }\\n    }\\n    string pushDominoes(string s) {\\n        int n = s.size(), idx = 0, last_left = -1;\\n        while(idx < n and s[idx] == \\'.\\') idx++;\\n        while(idx < n) {\\n            func(s, last_left, idx, n);\\n            while(idx < n and s[idx] - \\'.\\') idx++;\\n            last_left = idx - 1;\\n            while(idx < n and s[idx] == \\'.\\') idx++;\\n        }\\n        func(s, last_left, idx, n);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\'.\\'```\n```\\nclass Solution {\\npublic:\\n    void func(string& s, int &last, int &idx, int &n) {\\n        if(last == -1 and idx == n) return;\\n        else if(last == -1) {\\n            if(s[idx] == \\'L\\') {\\n                for(int i=0;i<idx;i++) s[i] = \\'L\\';\\n            }\\n        }\\n        else if(idx == n) {\\n            if(s[last] == \\'R\\') {\\n                for(int i = last +1;i<n;i++) s[i] =\\'R\\';\\n            }\\n        }\\n        else {\\n            if(s[last] == \\'R\\' and s[idx] == \\'L\\') {\\n                int no_dom = idx - last - 1;\\n                for(int len = 1, i = last + 1; len <= (no_dom>>1);len++, i++)\\n                    s[i] = \\'R\\';\\n                for(int len = 1, i = idx - 1; len <= (no_dom>>1);len++, i--)\\n                    s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'R\\' and s[idx] == \\'R\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'R\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'L\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'R\\') {\\n                return;\\n            }\\n        }\\n    }\\n    string pushDominoes(string s) {\\n        int n = s.size(), idx = 0, last_left = -1;\\n        while(idx < n and s[idx] == \\'.\\') idx++;\\n        while(idx < n) {\\n            func(s, last_left, idx, n);\\n            while(idx < n and s[idx] - \\'.\\') idx++;\\n            last_left = idx - 1;\\n            while(idx < n and s[idx] == \\'.\\') idx++;\\n        }\\n        func(s, last_left, idx, n);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631314,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n = len(dominoes)\\n        \\n        right_force = [0] * n\\n        \\n        for i in range(n):\\n            if dominoes[i] == \\'R\\':\\n                right_force[i] = n\\n            elif dominoes[i] == \\'L\\':\\n                right_force[i] = 0\\n            else:\\n                if(i-1 >= 0):\\n                    right_force[i] = max(right_force[i-1]-1, 0)\\n\\n        left_force = [0] * n\\n        \\n        for i in range(n-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                left_force[i] = n\\n            elif dominoes[i] == \\'R\\':\\n                left_force[i] = 0\\n            else:\\n                if(i+1 < n):\\n                    left_force[i] = max(left_force[i+1]-1, 0)\\n    \\n        return \\'\\'.join(\\'.\\' if right_force[i] == left_force[i] else \\'R\\' if right_force[i] > left_force[i] else \\'L\\' for i in range(n))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n = len(dominoes)\\n        \\n        right_force = [0] * n\\n        \\n        for i in range(n):\\n            if dominoes[i] == \\'R\\':\\n                right_force[i] = n\\n            elif dominoes[i] == \\'L\\':\\n                right_force[i] = 0\\n            else:\\n                if(i-1 >= 0):\\n                    right_force[i] = max(right_force[i-1]-1, 0)\\n\\n        left_force = [0] * n\\n        \\n        for i in range(n-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                left_force[i] = n\\n            elif dominoes[i] == \\'R\\':\\n                left_force[i] = 0\\n            else:\\n                if(i+1 < n):\\n                    left_force[i] = max(left_force[i+1]-1, 0)\\n    \\n        return \\'\\'.join(\\'.\\' if right_force[i] == left_force[i] else \\'R\\' if right_force[i] > left_force[i] else \\'L\\' for i in range(n))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631291,
                "title": "c-fastest-submission-crisp-and-clear-dp",
                "content": "TC: O(N + N) -->~ = O(N)\\nSC: O(N)\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        int n=str.size();\\n        vector<int>arr(n);\\n        string ans=str;\\n        \\n        int right_force=0;\\n        for(int i=0;i<n;i++){\\n            if(str[i]==\\'L\\')\\n                right_force=0;\\n            if(str[i]==\\'R\\')\\n                right_force=1;\\n            if(str[i]==\\'.\\' && right_force>0)\\n                right_force++;\\n            arr[i]=right_force;\\n        }\\n       \\n        int left_force=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(str[i]==\\'R\\') left_force=0;\\n            if(str[i]==\\'L\\') left_force=1;\\n            if(str[i]==\\'.\\')\\n            {\\n                if(left_force>0)\\n                    left_force++;\\n                \\n                if(arr[i]==0 && left_force>0)\\n                    ans[i]=\\'L\\';\\n                else if(arr[i]>0 && left_force==0)\\n                    ans[i]=\\'R\\';\\n                \\n                //force from both direction\\n                else if(arr[i]<left_force)\\n                    ans[i]=\\'R\\';\\n                else if(arr[i]>left_force) \\n                    ans[i]=\\'L\\';\\n                \\n                // equilibrium condition arr[i] == left_force \\n                else\\n                    ans[i]=\\'.\\';  // no change\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        int n=str.size();\\n        vector<int>arr(n);\\n        string ans=str;\\n        \\n        int right_force=0;\\n        for(int i=0;i<n;i++){\\n            if(str[i]==\\'L\\')\\n                right_force=0;\\n            if(str[i]==\\'R\\')\\n                right_force=1;\\n            if(str[i]==\\'.\\' && right_force>0)\\n                right_force++;\\n            arr[i]=right_force;\\n        }\\n       \\n        int left_force=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(str[i]==\\'R\\') left_force=0;\\n            if(str[i]==\\'L\\') left_force=1;\\n            if(str[i]==\\'.\\')\\n            {\\n                if(left_force>0)\\n                    left_force++;\\n                \\n                if(arr[i]==0 && left_force>0)\\n                    ans[i]=\\'L\\';\\n                else if(arr[i]>0 && left_force==0)\\n                    ans[i]=\\'R\\';\\n                \\n                //force from both direction\\n                else if(arr[i]<left_force)\\n                    ans[i]=\\'R\\';\\n                else if(arr[i]>left_force) \\n                    ans[i]=\\'L\\';\\n                \\n                // equilibrium condition arr[i] == left_force \\n                else\\n                    ans[i]=\\'.\\';  // no change\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631285,
                "title": "58ms-cpp-fast-code",
                "content": "Calculating time to fall and returning net fall time.\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> l(d.size(),-1);\\n        vector<int> r(d.size(),-1);\\n        int set = 0;\\n        int lset = 0;\\n        for(int i=0,j=d.size()-1;i<d.size();i++,j--) {\\n            if(d[i] == \\'.\\') {\\n                if(set == 0) l[i] = 0;\\n                else {\\n                    l[i] = set;\\n                    set++;\\n                }\\n            } else if(d[i] == \\'R\\') {\\n                set = 1;\\n                l[i] = INT_MAX;\\n            } else if(d[i] == \\'L\\') {\\n                set = 0;\\n                l[i] = INT_MAX;\\n            }\\n            if(d[j] == \\'.\\') {\\n                if(lset == 0) r[j] = 0;\\n                else {\\n                    r[j] = lset;\\n                    lset--;\\n                }\\n            } else if(d[j] == \\'R\\') {\\n                lset = 0;\\n                r[j] = INT_MAX;\\n            } else if(d[j] == \\'L\\') {\\n                lset = -1;\\n                r[j] = INT_MAX;\\n            }\\n        }\\n        string temp=\"\";\\n        for(int i=0;i<d.size();i++) {\\n            if(l[i] == 0 || r[i] == 0) {\\n                int res = (l[i]+r[i])*(-1);\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            } else if(l[i] == INT_MAX || r[i]==INT_MAX) {\\n                temp+=d[i];\\n            } else {\\n                int res = l[i]+r[i];\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> l(d.size(),-1);\\n        vector<int> r(d.size(),-1);\\n        int set = 0;\\n        int lset = 0;\\n        for(int i=0,j=d.size()-1;i<d.size();i++,j--) {\\n            if(d[i] == \\'.\\') {\\n                if(set == 0) l[i] = 0;\\n                else {\\n                    l[i] = set;\\n                    set++;\\n                }\\n            } else if(d[i] == \\'R\\') {\\n                set = 1;\\n                l[i] = INT_MAX;\\n            } else if(d[i] == \\'L\\') {\\n                set = 0;\\n                l[i] = INT_MAX;\\n            }\\n            if(d[j] == \\'.\\') {\\n                if(lset == 0) r[j] = 0;\\n                else {\\n                    r[j] = lset;\\n                    lset--;\\n                }\\n            } else if(d[j] == \\'R\\') {\\n                lset = 0;\\n                r[j] = INT_MAX;\\n            } else if(d[j] == \\'L\\') {\\n                lset = -1;\\n                r[j] = INT_MAX;\\n            }\\n        }\\n        string temp=\"\";\\n        for(int i=0;i<d.size();i++) {\\n            if(l[i] == 0 || r[i] == 0) {\\n                int res = (l[i]+r[i])*(-1);\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            } else if(l[i] == INT_MAX || r[i]==INT_MAX) {\\n                temp+=d[i];\\n            } else {\\n                int res = l[i]+r[i];\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631133,
                "title": "c-solution-using-pointer",
                "content": "\\t\\t*********please upvote if you like **********\\n\\t\\t\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n   \\n    static void solve(vector<char> &v,int j,int k){\\n       if(v[j]==\\'L\\'&&v[k]==\\'L\\'){\\n           for(int i=j+1;i<k;i++){\\n               v[i]=\\'L\\';\\n           }\\n           \\n       }else if(v[j]==\\'R\\'&&v[k]==\\'R\\'){\\n            for(int i=j+1;i<k;i++){\\n               v[i]=\\'R\\';\\n           }\\n           \\n       }\\n        else if(v[j]==\\'L\\'&&v[k]==\\'R\\'){\\n\\t\\t\\t//                  do nothing\\n        }\\n        else{\\n            int diff=k-j;\\n            int mid=(j+k)/2;\\n            if(diff%2!=0){\\n               for(int i=j+1;i<=mid;i++){\\n                  v[i]=\\'R\\'; \\n               }\\n                for(int i=mid+1;i<k;i++){\\n                  v[i]=\\'L\\'; \\n               }\\n                \\n                \\n            }\\n            else{\\n                 for(int i=j+1;i<mid;i++){\\n                  v[i]=\\'R\\'; \\n               }\\n                 for(int i=mid+1;i<k;i++){\\n                  v[i]=\\'L\\'; \\n               }    \\n            }\\n            \\n        }\\n    }\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n     vector<char>v(n+2);\\n        v[0]=\\'L\\';\\n        v[n+1]=\\'R\\';\\n        for(int i=1;i<v.size()-1;i++){\\n            v[i]=dominoes[i-1]; \\n        }\\n        int j=0,k=1;\\n        while(k<v.size()){\\n            while(v[k]==\\'.\\'){\\n                k++;\\n            }\\n            if(k-j>1)\\n            solve(v,j,k);\\n            j=k;\\n            k++;\\n        }\\n        string ans=\"\";\\n        for(int i=1;i<v.size()-1;i++){\\n            ans+=v[i];\\n        }\\n        \\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n   \\n    static void solve(vector<char> &v,int j,int k){\\n       if(v[j]==\\'L\\'&&v[k]==\\'L\\'){\\n           for(int i=j+1;i<k;i++){\\n               v[i]=\\'L\\';\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2630914,
                "title": "cpp-easy-to-understand",
                "content": "# \\t*please upvote if  this solution helped you*\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tans += dominoes[0];\\n\\t\\t\\tint n = dominoes.size();\\n\\t\\t\\tpair<char,int>prev = {dominoes[0],0};\\n\\t\\t\\tfor(int i =1;i<n;i++){\\n\\t\\t\\t\\tans += dominoes[i]; \\n\\t\\t\\t\\tif(prev.first == \\'.\\' && dominoes[i] == \\'.\\') continue;\\n\\n\\t\\t\\t\\tif(prev.first == dominoes[i] ){\\n\\t\\t\\t\\t\\tfor(int j = prev.second+1;j<i;j++){\\n\\t\\t\\t\\t\\t\\tans[j] = dominoes[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\telse if(prev.first == \\'.\\' && dominoes[i] == \\'L\\'){\\n\\t\\t\\t\\t\\tfor(int j = prev.second;j<i;j++){\\n\\t\\t\\t\\t\\t\\tans[j] = \\'L\\';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t else if(prev.first == \\'R\\' && dominoes[i] == \\'L\\'){\\n\\t\\t\\t\\t\\tint prev_idx = prev.second;\\n\\t\\t\\t\\t\\tprev_idx++;\\n\\t\\t\\t\\t\\tint curr_idx = i;\\n\\t\\t\\t\\t\\tcurr_idx--;\\n\\t\\t\\t\\t\\twhile(prev_idx < curr_idx){\\n\\t\\t\\t\\t\\t\\tans[prev_idx] = \\'R\\';\\n\\t\\t\\t\\t\\t\\tans[curr_idx] = \\'L\\';\\n\\t\\t\\t\\t\\t\\tprev_idx++;\\n\\t\\t\\t\\t\\t\\tcurr_idx--;\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\t\\tif(dominoes[i] != \\'.\\') prev = {dominoes[i],i};\\n\\n\\t\\t\\t}\\n\\t\\t\\tif(prev.first == \\'R\\'){\\n\\t\\t\\t\\tfor(int i = prev.second;i<n;i++){\\n\\t\\t\\t\\t\\tans[i] = \\'R\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tans += dominoes[0];\\n\\t\\t\\tint n = dominoes.size();\\n\\t\\t\\tpair<char,int>prev = {dominoes[0],0}",
                "codeTag": "Java"
            },
            {
                "id": 2630889,
                "title": "easy",
                "content": "```\\nclass Solution {\\n    public:\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int>L(n,INT_MAX);\\n        vector<int>R(n,INT_MAX);\\n        if(s[n-1]==\\'L\\')L[n-1]=0;\\n        for (int i = n-2; i >=0; i--)\\n        {\\n            if(s[i]==\\'R\\')\\n            continue;\\n            if(s[i]==\\'L\\')L[i]=0;\\n            else if(s[i]==\\'R\\')L[i]=INT_MAX;\\n            else L[i]=L[i+1]+1;\\n        }\\n\\n        if (s[0]==\\'R\\')R[0]=0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            if(s[i]==\\'L\\')\\n            continue;\\n            if(s[i]==\\'R\\')R[i]=0;\\n            else if(s[i]==\\'L\\')R[i]=INT_MAX;\\n            else R[i]=R[i-1]+1;\\n        }\\n\\n        string ans=\"\";\\n        for (int i = 0; i < n; i++)\\n        {\\n            if(L[i]==R[i])ans+=\\'.\\';\\n            else if(L[i]<R[i])ans+=\\'L\\';\\n            else ans+=\\'R\\';\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int>L(n,INT_MAX);\\n        vector<int>R(n,INT_MAX);\\n        if(s[n-1]==\\'L\\')L[n-1]=0;\\n        for (int i = n-2; i >=0; i--)\\n        {\\n            if(s[i]==\\'R\\')\\n            continue;\\n            if(s[i]==\\'L\\')L[i]=0;\\n            else if(s[i]==\\'R\\')L[i]=INT_MAX;\\n            else L[i]=L[i+1]+1;\\n        }\\n\\n        if (s[0]==\\'R\\')R[0]=0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            if(s[i]==\\'L\\')\\n            continue;\\n            if(s[i]==\\'R\\')R[i]=0;\\n            else if(s[i]==\\'L\\')R[i]=INT_MAX;\\n            else R[i]=R[i-1]+1;\\n        }\\n\\n        string ans=\"\";\\n        for (int i = 0; i < n; i++)\\n        {\\n            if(L[i]==R[i])ans+=\\'.\\';\\n            else if(L[i]<R[i])ans+=\\'L\\';\\n            else ans+=\\'R\\';\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630840,
                "title": "java-two-approaches",
                "content": "### Please Upvote !!! **(\\u25E0\\u203F\\u25E0)**\\n##### Approach 1:\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] arr = new char[n + 2];\\n        arr[0] = \\'L\\'; arr[n + 1] = \\'R\\';\\n\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            arr[i] = dominoes.charAt(i - 1);\\n        }\\n\\n        int i = 0, j = 1;\\n\\n        while (j < arr.length) {\\n            while (arr[j] == \\'.\\') j++;\\n            if (j - i > 1) helper(arr, i, j);\\n            i = j++;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int idx = 1; idx < arr.length - 1; idx++) {\\n            ans.append(arr[idx]);\\n        }\\n\\n        return ans.toString();\\n    }\\n\\n    public void helper(char[] arr, int i, int j) {\\n        // case 1\\n        if (arr[i] == \\'L\\' && arr[j] == \\'L\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'L\\';\\n            }\\n        }\\n\\n        // case 2\\n        else if (arr[i] == \\'R\\' && arr[j] == \\'R\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'R\\';\\n            }\\n        }\\n\\n        // case 3\\n        else if (arr[i] == \\'L\\' && arr[j] == \\'R\\') {\\n            // do nothing\\n        }\\n\\n        // case 4\\n        // arr[i] == \\'R\\' && arr[j] == \\'L\\'\\n        else {\\n            int l = i + 1, r = j - 1;\\n            while (l < r) {\\n                arr[l++] = \\'R\\';\\n                arr[r--] = \\'L\\';\\n            }\\n        }\\n    }\\n}\\n\\n// TC: O(n) + O(n * n) + O(n);\\n// SC: O(n)\\n```\\n\\n##### Approach 2:\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n\\n        int[] left = new int[n];\\n        int nearestLeftIdx = -1;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'L\\') nearestLeftIdx = i;\\n            else if (c == \\'R\\') nearestLeftIdx = -1;\\n            left[i] = nearestLeftIdx;\\n        }\\n\\n        int[] right = new int[n];\\n        int nearestRightIdx = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'R\\') nearestRightIdx = i;\\n            else if (c == \\'L\\') nearestRightIdx = -1;\\n            right[i] = nearestRightIdx;\\n        }\\n\\n        char[] ans = new char[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (dominoes.charAt(i) == \\'.\\') {\\n                int nearestLeft = left[i];\\n                int nearestRight = right[i];\\n\\n                int leftDiff = (nearestLeft == -1) ? Integer.MAX_VALUE : Math.abs(nearestLeft - i);\\n                int rightDiff = (nearestRight == -1) ? Integer.MAX_VALUE : Math.abs(nearestRight - i);\\n\\n                if (leftDiff == rightDiff) ans[i] = \\'.\\';\\n                else if (leftDiff < rightDiff) ans[i] = \\'L\\';\\n                else ans[i] = \\'R\\';  // leftDiff > rightDiff\\n            }\\n\\n            else ans[i] = dominoes.charAt(i);\\n        }\\n\\n        return new String(ans);\\n    }\\n}\\n\\n// TC: O(n + O(n) + O(n) => O(n)\\n// SC: O(n) + O(n) => O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] arr = new char[n + 2];\\n        arr[0] = \\'L\\'; arr[n + 1] = \\'R\\';\\n\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            arr[i] = dominoes.charAt(i - 1);\\n        }\\n\\n        int i = 0, j = 1;\\n\\n        while (j < arr.length) {\\n            while (arr[j] == \\'.\\') j++;\\n            if (j - i > 1) helper(arr, i, j);\\n            i = j++;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int idx = 1; idx < arr.length - 1; idx++) {\\n            ans.append(arr[idx]);\\n        }\\n\\n        return ans.toString();\\n    }\\n\\n    public void helper(char[] arr, int i, int j) {\\n        // case 1\\n        if (arr[i] == \\'L\\' && arr[j] == \\'L\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'L\\';\\n            }\\n        }\\n\\n        // case 2\\n        else if (arr[i] == \\'R\\' && arr[j] == \\'R\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'R\\';\\n            }\\n        }\\n\\n        // case 3\\n        else if (arr[i] == \\'L\\' && arr[j] == \\'R\\') {\\n            // do nothing\\n        }\\n\\n        // case 4\\n        // arr[i] == \\'R\\' && arr[j] == \\'L\\'\\n        else {\\n            int l = i + 1, r = j - 1;\\n            while (l < r) {\\n                arr[l++] = \\'R\\';\\n                arr[r--] = \\'L\\';\\n            }\\n        }\\n    }\\n}\\n\\n// TC: O(n) + O(n * n) + O(n);\\n// SC: O(n)\\n```\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n\\n        int[] left = new int[n];\\n        int nearestLeftIdx = -1;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'L\\') nearestLeftIdx = i;\\n            else if (c == \\'R\\') nearestLeftIdx = -1;\\n            left[i] = nearestLeftIdx;\\n        }\\n\\n        int[] right = new int[n];\\n        int nearestRightIdx = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'R\\') nearestRightIdx = i;\\n            else if (c == \\'L\\') nearestRightIdx = -1;\\n            right[i] = nearestRightIdx;\\n        }\\n\\n        char[] ans = new char[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (dominoes.charAt(i) == \\'.\\') {\\n                int nearestLeft = left[i];\\n                int nearestRight = right[i];\\n\\n                int leftDiff = (nearestLeft == -1) ? Integer.MAX_VALUE : Math.abs(nearestLeft - i);\\n                int rightDiff = (nearestRight == -1) ? Integer.MAX_VALUE : Math.abs(nearestRight - i);\\n\\n                if (leftDiff == rightDiff) ans[i] = \\'.\\';\\n                else if (leftDiff < rightDiff) ans[i] = \\'L\\';\\n                else ans[i] = \\'R\\';  // leftDiff > rightDiff\\n            }\\n\\n            else ans[i] = dominoes.charAt(i);\\n        }\\n\\n        return new String(ans);\\n    }\\n}\\n\\n// TC: O(n + O(n) + O(n) => O(n)\\n// SC: O(n) + O(n) => O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630601,
                "title": "this-java-solution-beats-90-96-of-java-submissions",
                "content": "**Upvote if you\\'re not greedy)))**\\n```\\nclass Solution {\\n    private char[] result;\\n\\n    public String pushDominoes(String dominoes) {\\n        int len = dominoes.length();\\n        result = dominoes.toCharArray();\\n        for (int i = 0; i < len; i++) {\\n            char temp = dominoes.charAt(i);\\n            if (temp == \\'.\\') {\\n                int left = i;\\n                while (i < len && dominoes.charAt(i) == \\'.\\') {\\n                    i++;\\n                }\\n                int right = i - 1;\\n                char rChar = right == len - 1 ? \\'.\\' : dominoes.charAt(right + 1);\\n                char lChar = left == 0 ? \\'.\\' : dominoes.charAt(left - 1);\\n                if (lChar != \\'R\\' && rChar == \\'L\\') {\\n                    fillSubstringBy(left, right, \\'L\\');\\n                } else if (rChar != \\'L\\' && lChar == \\'R\\') {\\n                    fillSubstringBy(left, right, \\'R\\');\\n                } else if (lChar == \\'R\\') {\\n                    fillSubstring(left, right);\\n                }\\n            }\\n        }\\n        return new String(result);\\n    }\\n\\n    private void fillSubstring(int left, int right) {\\n        while (right > left) {\\n            result[right--] = \\'L\\';\\n            result[left++] = \\'R\\';\\n        }\\n    }\\n\\n    private void fillSubstringBy(int left, int right, char c) {\\n        for (int i = left; i <= right; i++) {\\n            result[i] = c;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    private char[] result;\\n\\n    public String pushDominoes(String dominoes) {\\n        int len = dominoes.length();\\n        result = dominoes.toCharArray();\\n        for (int i = 0; i < len; i++) {\\n            char temp = dominoes.charAt(i);\\n            if (temp == \\'.\\') {\\n                int left = i;\\n                while (i < len && dominoes.charAt(i) == \\'.\\') {\\n                    i++;\\n                }\\n                int right = i - 1;\\n                char rChar = right == len - 1 ? \\'.\\' : dominoes.charAt(right + 1);\\n                char lChar = left == 0 ? \\'.\\' : dominoes.charAt(left - 1);\\n                if (lChar != \\'R\\' && rChar == \\'L\\') {\\n                    fillSubstringBy(left, right, \\'L\\');\\n                } else if (rChar != \\'L\\' && lChar == \\'R\\') {\\n                    fillSubstringBy(left, right, \\'R\\');\\n                } else if (lChar == \\'R\\') {\\n                    fillSubstring(left, right);\\n                }\\n            }\\n        }\\n        return new String(result);\\n    }\\n\\n    private void fillSubstring(int left, int right) {\\n        while (right > left) {\\n            result[right--] = \\'L\\';\\n            result[left++] = \\'R\\';\\n        }\\n    }\\n\\n    private void fillSubstringBy(int left, int right, char c) {\\n        for (int i = left; i <= right; i++) {\\n            result[i] = c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630599,
                "title": "c-efficent-o-n-time-o-1-space-solution-18ms",
                "content": "Testing the various corner cases is a challenge, but a essentially I grouped the string into substrings [left, right] where _right_ is the index of the next action (\\'R\\' or \\'L\\') and _left_ maybe an action.\\n\\nDepending on the which state, the return can be `memset` for quick performance;\\n|dominoes[left]|dominoes[right]|result|\\n|---|---|---|\\n|`R`|`R`|Everything between _left_ and _right_ gets filled with `R` and _left_ is set to _right_|\\n|`.`|`R`|Everything upto _right_ gets filled with `.` and _left_ is set to _right_|\\n|`L`|`R`|Everything after _left_ upto _right_ gets filled with `.` and _left_ is set to _right_|\\n|`R`|`L`|They will meet in the middle. Fill first half with `R` then add a `.` if the gap between them is odd, before filling the rest with `L`|\\n|`.` or `L`|`L`|Fill _left_ to _right_ with `L` and set _left_ to just after _right_|\\n\\nThere is some bonus, corner cases to do with the start and end, but not too much trouble. The resulting code is not a pretty as I would like, but runs fast;\\n\\n```c\\nchar * pushDominoes(char * dominoes) {\\n\\tsize_t len = strlen(dominoes);\\n\\tchar* const ret = malloc(len + 1);\\n\\tret[len] = \\'\\\\0\\';\\n\\n\\tint left = 0;\\n\\twhile (left < len) {\\n\\t\\t/* Find the next interesting action */\\n\\t\\tint right = left + 1;\\n\\t\\twhile (right < len && \\'.\\' == dominoes[right]) {\\n\\t\\t\\t++right;\\n\\t\\t}\\n\\t\\tif (right == len) { /* No other movements found before the end */\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tbreak;\\n\\t\\t} else if (\\'R\\' == dominoes[right]) {\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tleft = right;\\n\\t\\t} else if (\\'L\\' == dominoes[right]) { /* Dominoes will be toppling left */\\n\\t\\t\\tint pos = left;\\n\\t\\t\\tif (\\'R\\' == dominoes[left]) { /* Dominoes will be toppling right too */\\n\\t\\t\\t\\tint half = (right - left + 1) / 2;\\n\\t\\t\\t\\tmemset(&ret[pos], \\'R\\', half);\\n\\t\\t\\t\\tpos += half;\\n\\t\\t\\t\\tif (0 == (right - left) % 2) { /* Is there a domino in the middle */\\n\\t\\t\\t\\t\\tret[pos++] = \\'.\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmemset(&ret[pos], \\'L\\', right - pos + 1);\\n\\t\\t\\tleft = right + 1;    \\n\\t  }\\n  }\\n  return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\nchar * pushDominoes(char * dominoes) {\\n\\tsize_t len = strlen(dominoes);\\n\\tchar* const ret = malloc(len + 1);\\n\\tret[len] = \\'\\\\0\\';\\n\\n\\tint left = 0;\\n\\twhile (left < len) {\\n\\t\\t/* Find the next interesting action */\\n\\t\\tint right = left + 1;\\n\\t\\twhile (right < len && \\'.\\' == dominoes[right]) {\\n\\t\\t\\t++right;\\n\\t\\t}\\n\\t\\tif (right == len) { /* No other movements found before the end */\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tbreak;\\n\\t\\t} else if (\\'R\\' == dominoes[right]) {\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tleft = right;\\n\\t\\t} else if (\\'L\\' == dominoes[right]) { /* Dominoes will be toppling left */\\n\\t\\t\\tint pos = left;\\n\\t\\t\\tif (\\'R\\' == dominoes[left]) { /* Dominoes will be toppling right too */\\n\\t\\t\\t\\tint half = (right - left + 1) / 2;\\n\\t\\t\\t\\tmemset(&ret[pos], \\'R\\', half);\\n\\t\\t\\t\\tpos += half;\\n\\t\\t\\t\\tif (0 == (right - left) % 2) { /* Is there a domino in the middle */\\n\\t\\t\\t\\t\\tret[pos++] = \\'.\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmemset(&ret[pos], \\'L\\', right - pos + 1);\\n\\t\\t\\tleft = right + 1;    \\n\\t  }\\n  }\\n  return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630536,
                "title": "javascript-queue-tc-o-n-sc-o-n",
                "content": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    const dom = dominoes.split(\\'\\');\\n    const n = dom.length;\\n    let queue = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (dom[i] !== \\'.\\') {\\n            queue.push([i, dom[i]]);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        const next = [];\\n        \\n        for (let idx = 0; idx < queue.length; idx++) {\\n            const [i, d] = queue[idx];\\n            if (d === \\'L\\' && i > 0 && dom[i - 1] === \\'.\\') {\\n                next.push([i - 1, \\'L\\']);\\n                dom[i - 1] = \\'L\\';\\n            } else if (d === \\'R\\' && i + 1 < n && dom[i + 1] === \\'.\\') {\\n                if (i + 2 < n && dom[i + 2] === \\'L\\') {\\n                    idx++;\\n                } else {\\n                    next.push([i + 1, \\'R\\']);\\n                    dom[i + 1] = \\'R\\';\\n                }\\n            }\\n        }\\n        \\n        queue = next;\\n    }\\n    \\n    return dom.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    const dom = dominoes.split(\\'\\');\\n    const n = dom.length;\\n    let queue = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (dom[i] !== \\'.\\') {\\n            queue.push([i, dom[i]]);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        const next = [];\\n        \\n        for (let idx = 0; idx < queue.length; idx++) {\\n            const [i, d] = queue[idx];\\n            if (d === \\'L\\' && i > 0 && dom[i - 1] === \\'.\\') {\\n                next.push([i - 1, \\'L\\']);\\n                dom[i - 1] = \\'L\\';\\n            } else if (d === \\'R\\' && i + 1 < n && dom[i + 1] === \\'.\\') {\\n                if (i + 2 < n && dom[i + 2] === \\'L\\') {\\n                    idx++;\\n                } else {\\n                    next.push([i + 1, \\'R\\']);\\n                    dom[i + 1] = \\'R\\';\\n                }\\n            }\\n        }\\n        \\n        queue = next;\\n    }\\n    \\n    return dom.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630439,
                "title": "python-neetcode-queue-traversal",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        \\n        q=deque()\\n        dominoes=list(dominoes)\\n        for a,i in enumerate(dominoes):\\n            if i==\"L\"or i==\"R\":\\n                q.append((i,a))\\n                \\n        # print(q)\\n                \\n        while(q):\\n            val,ind=q.popleft()\\n            \\n            if val==\"R\" and ind+1<len(dominoes) and dominoes[ind+1]==\".\":\\n                if q and q[0][0]==\"L\" and ind+2==q[0][1]:\\n                    q.popleft()\\n                else:\\n                    dominoes[ind+1]=\"R\"\\n                    q.append((\"R\",ind+1))\\n                    \\n                    \\n            elif val==\"L\" and ind>0 and dominoes[ind-1]==\".\":\\n                dominoes[ind-1]=\"L\"\\n                q.append((\"L\",ind-1))\\n                \\n        return \"\".join(dominoes)\\n                \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        \\n        q=deque()\\n        dominoes=list(dominoes)\\n        for a,i in enumerate(dominoes):\\n            if i==\"L\"or i==\"R\":\\n                q.append((i,a))\\n                \\n        # print(q)\\n                \\n        while(q):\\n            val,ind=q.popleft()\\n            \\n            if val==\"R\" and ind+1<len(dominoes) and dominoes[ind+1]==\".\":\\n                if q and q[0][0]==\"L\" and ind+2==q[0][1]:\\n                    q.popleft()\\n                else:\\n                    dominoes[ind+1]=\"R\"\\n                    q.append((\"R\",ind+1))\\n                    \\n                    \\n            elif val==\"L\" and ind>0 and dominoes[ind-1]==\".\":\\n                dominoes[ind-1]=\"L\"\\n                q.append((\"L\",ind-1))\\n                \\n        return \"\".join(dominoes)\\n                \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630357,
                "title": "c-very-easy-solution-tc-o-n",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string d) {\\n\\t\\t\\tint right=-1;\\n\\t\\t\\tstring s=\"\";\\n\\t\\t\\tvector<pair<int,int>>v;\\n\\t\\t\\tfor(int i=0;i<d.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ts+=\\'.\\';\\n\\t\\t\\t\\tif(d[i]==\\'R\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(right!=-1 && d[i]==\\'L\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back({right,i});\\n\\t\\t\\t\\t\\tfor(int j=right;j<=i;j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\td[j]=\\'-\\';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tright=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// In vector of pair we store the indexes which are right and immediate left after right \\n\\t\\t\\t// we store vector members and in between them with \\'-\\' sign to differentiate them \\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint a=v[i].first,b=v[i].second;\\n\\t\\t\\t\\t//cout<<a<<\" \"<<b<<endl;\\n\\t\\t\\t\\twhile(a<b)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts[a]=\\'R\\';\\n\\t\\t\\t\\t\\ts[b]=\\'L\\';\\n\\t\\t\\t\\t\\ta++;\\n\\t\\t\\t\\t\\tb--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// we store the positions of vector members in the another string\\n\\t\\t\\tfor(int i=0;i<d.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(d[i]==\\'R\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint x=i;\\n\\t\\t\\t\\t\\twhile(x<d.size() && d[x]!=\\'-\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts[x]=\\'R\\';\\n\\t\\t\\t\\t\\t\\tx++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ti=x;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// traverse from right whichever comes right goes to right before the vector members\\n\\t\\t\\tfor(int i=d.size()-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(d[i]==\\'L\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint x=i;\\n\\t\\t\\t\\t\\twhile(x>=0 && d[x]!=\\'-\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts[x]=\\'L\\';\\n\\t\\t\\t\\t\\t\\tx--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ti=x;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t    // traverse from left whichever comes left goes to left before the vector members\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string d) {\\n\\t\\t\\tint right=-1;\\n\\t\\t\\tstring s=\"\";\\n\\t\\t\\tvector<pair<int,int>>v;\\n\\t\\t\\tfor(int i=0;i<d.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ts+=\\'.\\';\\n\\t\\t\\t\\tif(d[i]==\\'R\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright=i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2630300,
                "title": "c-simple-array-question",
                "content": "\"\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        \\n        string ans;\\n        int n=dominoes.size();\\n        int left[n],right[n];\\n        int cnt=1;\\n        int i=0;\\n        while(i<n){\\n            if(cnt==1 && dominoes[i]==\\'.\\')left[i]=0;\\n            else{\\n                if(dominoes[i]==\\'R\\'){\\n                    left[i]=cnt;\\n                    cnt=2;\\n                }else if(dominoes[i]==\\'.\\'){\\n                    left[i]=cnt;\\n                    cnt++;\\n                }else{\\n                    left[i]=0;\\n                    cnt=1;\\n                }\\n            }\\n            i++;\\n        }\\n        i=n-1;\\n        cnt=1;\\n        while(i>=0){\\n            if(cnt==1 && dominoes[i]==\\'.\\')right[i]=0;\\n            else{\\n               if(dominoes[i]==\\'L\\'){\\n                    right[i]=cnt;\\n                    cnt=2;\\n                }else if(dominoes[i]==\\'.\\'){\\n                    right[i]=cnt;\\n                    cnt++;\\n                }else{\\n                    right[i]=0;\\n                    cnt=1;\\n                }\\n            }\\n            i--;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(left[i]==0 && right[i]!=0)ans+=\\'L\\';\\n            else if(left[i]!=0 && right[i]==0)ans+=\\'R\\';\\n            else if(left[i]==0 && right[i]==0 || (left[i]==right[i]))ans+=dominoes[i];\\n            else if(left[i]!=0 && right[i]!=0 && (left[i]!=right[i])){\\n                if(left[i]>right[i])ans+=\\'L\\';\\n                else ans+=\\'R\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\"",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        \\n        string ans;\\n        int n=dominoes.size();\\n        int left[n],right[n];\\n        int cnt=1;\\n        int i=0;\\n        while(i<n){\\n            if(cnt==1 && dominoes[i]==\\'.\\')left[i]=0;\\n            else{\\n                if(dominoes[i]==\\'R\\'){\\n                    left[i]=cnt;\\n                    cnt=2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2630288,
                "title": "c-faster-than-99-31-two-pointer-detailed-explanation",
                "content": "Maintain two pointers **start** and **end**, and there are four cases:\\n**1. start = \\'L\\' & end = \\'R\\':** \\n* In this case, the dominoes in between these will not fall\\n* Ex: **L....R** , ans = **L....R**\\n\\n**2. start = \\'R\\' & end = \\'L\\'**\\n* In this case, the dominoes in between will fall in such a way that:\\n\\t* Dominoes near \\'R\\' will fall toward right\\n\\t* Dominoes near \\'L\\' will fall toward left\\n\\t* If there is a middle domino, it doesn\\'t fall as the forces are balanced\\n\\t* Ex1: **R..L**, ans = **RRLL**\\n\\t* Ex2: **R...L**, ans = **RR.LL**\\n\\n**3. start = \\'L & end = \\'L\\'**\\n* In this case, all the dominoes in between will fall toward left, due to the force from end domino\\n* Ex: **L...L**, ans = **LLLLL**\\n\\t\\n**4. start = \\'R\\' & end = \\'R\\'**\\n* In this case, all the dominoes in between will fall toward right, due to the force from start domino\\n* Ex: **R...R**, ans = **RRRRR**\\n\\n**Note:** Consider there is a \\'L\\' domino in the beginning and a \\'R\\' domino in the ending (adding these will not affect the answer, and it is easy for maintaining pointers. Take a few examples and you\\'ll understand this)\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n\\t\\t// Adding a domino at the end\\n        dominoes.push_back(\\'R\\');\\n\\t\\t\\n\\t\\t// Consider, there is a \\'L\\' domino at the begin\\n        int startInd = -1;\\n        char start = \\'L\\';\\n            \\n        for(int i=0; i<dominoes.size(); i++){\\n            int endInd = i;\\n            char end = dominoes[i];\\n\\t\\t\\t\\n            if(end == \\'.\\'){\\n                continue;\\n            }\\n            \\n            if(start == \\'L\\' && end == \\'R\\'){\\n                // Do nothing\\n            }\\n            else if(start == \\'R\\' && end == \\'L\\'){\\n                int len = endInd-startInd+1;\\n                int l = startInd+1, r = endInd-1;\\n                while(l<=r){\\n\\t\\t\\t\\t\\t// Middle domino\\n                    if(l == r){\\n                        dominoes[l++] = \\'.\\';\\n                    }\\n                    else{\\n                        dominoes[l++] = \\'R\\';\\n                        dominoes[r--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(start == \\'L\\' && end == \\'L\\'){\\n                int ind = endInd-1;\\n                while(ind > startInd){\\n                    dominoes[ind--] = \\'L\\';\\n                }\\n            }\\n            else{\\n                int ind = startInd+1;\\n                while(ind < endInd){\\n                    dominoes[ind++] = \\'R\\';\\n                }\\n            }\\n            start = end;\\n            startInd = endInd;\\n        }\\n        \\n\\t\\t// Removing the domino added at the end\\n        dominoes.pop_back();\\n        return dominoes;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n\\t\\t// Adding a domino at the end\\n        dominoes.push_back(\\'R\\');\\n\\t\\t\\n\\t\\t// Consider, there is a \\'L\\' domino at the begin\\n        int startInd = -1;\\n        char start = \\'L\\';\\n            \\n        for(int i=0; i<dominoes.size(); i++){\\n            int endInd = i;\\n            char end = dominoes[i];\\n\\t\\t\\t\\n            if(end == \\'.\\'){\\n                continue;\\n            }\\n            \\n            if(start == \\'L\\' && end == \\'R\\'){\\n                // Do nothing\\n            }\\n            else if(start == \\'R\\' && end == \\'L\\'){\\n                int len = endInd-startInd+1;\\n                int l = startInd+1, r = endInd-1;\\n                while(l<=r){\\n\\t\\t\\t\\t\\t// Middle domino\\n                    if(l == r){\\n                        dominoes[l++] = \\'.\\';\\n                    }\\n                    else{\\n                        dominoes[l++] = \\'R\\';\\n                        dominoes[r--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(start == \\'L\\' && end == \\'L\\'){\\n                int ind = endInd-1;\\n                while(ind > startInd){\\n                    dominoes[ind--] = \\'L\\';\\n                }\\n            }\\n            else{\\n                int ind = startInd+1;\\n                while(ind < endInd){\\n                    dominoes[ind++] = \\'R\\';\\n                }\\n            }\\n            start = end;\\n            startInd = endInd;\\n        }\\n        \\n\\t\\t// Removing the domino added at the end\\n        dominoes.pop_back();\\n        return dominoes;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2630188,
                "title": "golang-with-two-pointers-and-comments-description",
                "content": "![image](https://assets.leetcode.com/users/images/a7d8cda3-80ac-441e-9f9a-3f5d5e8b6501_1664273362.031908.png)\\nthough it meets timelimit often, but still can pass\\nfailing testcase:\\nhttps://leetcode.com/submissions/detail/809710021/testcase/\\n\\n```\\nfunc pushDominoes(dominoes string) string {\\n    // if len is 0 or 1 nothing can be changed, return input\\n    if len(dominoes) <= 1 || !strings.ContainsRune(dominoes, \\'.\\'){\\n        return dominoes\\n    }\\n    \\n    left := 0\\n    // looking for first non-\".\" character\\n    right, lc := nextChar(dominoes)\\n    if right < 0 { // if not found, return input\\n        return dominoes\\n    }\\n    \\n    if lc == \"L\" { // if first \"L\", all on the left should be \"L\"\\n        dominoes = strings.Replace(dominoes, \".\", \"L\", right)\\n    } \\n    \\n    res := dominoes[:right+1] // copy part till first non-\".\" with needed replacement\\n    // fmt.Println(\"res before = \", res)\\n\\n    rc := lc\\n    finish := true // flag to understand if we still have what to repeat, can be replaced with check of \"res\" length\\n    for finish{\\n        finish = false\\n        lc = rc\\n        left += right+1\\n        // fmt.Println(\"dominoes[left:] = \", dominoes[left:])\\n        right, rc = nextChar(dominoes[left:])\\n        if right < 0 && lc == \"L\" { // if last char was \"L\" the rest is \".\" without changes\\n            res += strings.Repeat(\".\", len(dominoes) - left)\\n            // fmt.Println(\"break L\")\\n            break\\n        } else if right < 0 && lc == \"R\" { // if last char was \"R\" the rest is \"R\" \\n            // fmt.Println(\"break R\")\\n            res += strings.Repeat(\"R\", len(dominoes) - left)\\n            break\\n        } else if rc == lc { // if same like \"L..L\" or \"R..R\", all between should be same\\n            // fmt.Println(\"replaced same\")\\n            res += strings.Repeat(rc, right+1)\\n            // fmt.Println(\"res after replaced same = \", res)\\n            finish = true\\n        } else if lc == \"R\" && rc == \"L\"  { // if kind of \"R..L\", then half \"R\" and half \"L\" => \"RRLL\"\\n            half := right / 2\\n            res += strings.Repeat(lc, half)\\n            if right % 2 == 1 { // if odd, then middle isn\\'t changed: \"R...L\" => \"RR.LL\"\\n                res += \".\"\\n            }\\n            res += strings.Repeat(rc, half+1) // additionally copy right \"L\"\\n            // fmt.Println(\"replaced halfs\")\\n            finish = true\\n        } else { //in case of \"L..R\" copy with no changes\\n            res += dominoes[left:left+right+1]\\n            // fmt.Println(\"copy with no changes between L and R\")\\n            // fmt.Println(\"res after copy with no changes = \", res)\\n            finish = true\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc nextChar(s string)(int, string){\\n    leftL := strings.IndexByte(s,\\'L\\')\\n    leftR := strings.IndexByte(s,\\'R\\')\\n    if leftL>=0 && leftL < leftR || leftL>=0 && leftR<0{\\n        // fmt.Println(\"next = \", leftL,string(s[leftL]))\\n        return leftL,string(s[leftL])\\n    } else if leftR>=0 {\\n        // fmt.Println(\"next = \", leftR,string(s[leftR]))\\n            return leftR,string(s[leftR])\\n    } else {\\n        // fmt.Println(\"next = \", -1, \"\")\\n        return -1,\"\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pushDominoes(dominoes string) string {\\n    // if len is 0 or 1 nothing can be changed, return input\\n    if len(dominoes) <= 1 || !strings.ContainsRune(dominoes, \\'.\\'){\\n        return dominoes\\n    }\\n    \\n    left := 0\\n    // looking for first non-\".\" character\\n    right, lc := nextChar(dominoes)\\n    if right < 0 { // if not found, return input\\n        return dominoes\\n    }\\n    \\n    if lc == \"L\" { // if first \"L\", all on the left should be \"L\"\\n        dominoes = strings.Replace(dominoes, \".\", \"L\", right)\\n    } \\n    \\n    res := dominoes[:right+1] // copy part till first non-\".\" with needed replacement\\n    // fmt.Println(\"res before = \", res)\\n\\n    rc := lc\\n    finish := true // flag to understand if we still have what to repeat, can be replaced with check of \"res\" length\\n    for finish{\\n        finish = false\\n        lc = rc\\n        left += right+1\\n        // fmt.Println(\"dominoes[left:] = \", dominoes[left:])\\n        right, rc = nextChar(dominoes[left:])\\n        if right < 0 && lc == \"L\" { // if last char was \"L\" the rest is \".\" without changes\\n            res += strings.Repeat(\".\", len(dominoes) - left)\\n            // fmt.Println(\"break L\")\\n            break\\n        } else if right < 0 && lc == \"R\" { // if last char was \"R\" the rest is \"R\" \\n            // fmt.Println(\"break R\")\\n            res += strings.Repeat(\"R\", len(dominoes) - left)\\n            break\\n        } else if rc == lc { // if same like \"L..L\" or \"R..R\", all between should be same\\n            // fmt.Println(\"replaced same\")\\n            res += strings.Repeat(rc, right+1)\\n            // fmt.Println(\"res after replaced same = \", res)\\n            finish = true\\n        } else if lc == \"R\" && rc == \"L\"  { // if kind of \"R..L\", then half \"R\" and half \"L\" => \"RRLL\"\\n            half := right / 2\\n            res += strings.Repeat(lc, half)\\n            if right % 2 == 1 { // if odd, then middle isn\\'t changed: \"R...L\" => \"RR.LL\"\\n                res += \".\"\\n            }\\n            res += strings.Repeat(rc, half+1) // additionally copy right \"L\"\\n            // fmt.Println(\"replaced halfs\")\\n            finish = true\\n        } else { //in case of \"L..R\" copy with no changes\\n            res += dominoes[left:left+right+1]\\n            // fmt.Println(\"copy with no changes between L and R\")\\n            // fmt.Println(\"res after copy with no changes = \", res)\\n            finish = true\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc nextChar(s string)(int, string){\\n    leftL := strings.IndexByte(s,\\'L\\')\\n    leftR := strings.IndexByte(s,\\'R\\')\\n    if leftL>=0 && leftL < leftR || leftL>=0 && leftR<0{\\n        // fmt.Println(\"next = \", leftL,string(s[leftL]))\\n        return leftL,string(s[leftL])\\n    } else if leftR>=0 {\\n        // fmt.Println(\"next = \", leftR,string(s[leftR]))\\n            return leftR,string(s[leftR])\\n    } else {\\n        // fmt.Println(\"next = \", -1, \"\")\\n        return -1,\"\"\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630158,
                "title": "golang-two-pointers",
                "content": "```\\nfunc pushDominoes(dominoes string) string {\\n    arr := make([]byte, len(dominoes)+2)\\n    N := len(arr)\\n    arr[0] = \\'L\\'\\n    arr[N-1] = \\'R\\'\\n    for i := 0; i < len(dominoes); i++ {\\n        arr[i+1] = dominoes[i]\\n    }\\n    \\n    start := 0\\n    for end := 0; end < N; end++ {\\n        if arr[end] != \\'.\\' {\\n            convert(arr, start, end)\\n            start = end\\n        }\\n    }\\n    \\n    return string(arr[1:N-1])\\n}\\n\\nfunc convert(arr []byte, start, end int) {\\n    if arr[start] == arr[end] {\\n        // Case of L...L or R....R\\n        for i := start+1; i < end; i++ {\\n            arr[i] = arr[start]\\n        }\\n    } else if arr[start] == \\'R\\' && arr[end] == \\'L\\' {\\n        // Case of R...L\\n        for i := start+1; i < end; i++ {\\n            if i-start < end-i {\\n                arr[i] = arr[start]\\n            } else if i-start > end-i {\\n                arr[i] = arr[end]\\n            } /* else {\\n                // If i is equal distance from start and end, leave it \\'.\\'\\n            } */\\n        }\\n    } /* else {\\n        // Case of L...R\\n        // Nothing needs to be done\\n    } */\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pushDominoes(dominoes string) string {\\n    arr := make([]byte, len(dominoes)+2)\\n    N := len(arr)\\n    arr[0] = \\'L\\'\\n    arr[N-1] = \\'R\\'\\n    for i := 0; i < len(dominoes); i++ {\\n        arr[i+1] = dominoes[i]\\n    }\\n    \\n    start := 0\\n    for end := 0; end < N; end++ {\\n        if arr[end] != \\'.\\' {\\n            convert(arr, start, end)\\n            start = end\\n        }\\n    }\\n    \\n    return string(arr[1:N-1])\\n}\\n\\nfunc convert(arr []byte, start, end int) {\\n    if arr[start] == arr[end] {\\n        // Case of L...L or R....R\\n        for i := start+1; i < end; i++ {\\n            arr[i] = arr[start]\\n        }\\n    } else if arr[start] == \\'R\\' && arr[end] == \\'L\\' {\\n        // Case of R...L\\n        for i := start+1; i < end; i++ {\\n            if i-start < end-i {\\n                arr[i] = arr[start]\\n            } else if i-start > end-i {\\n                arr[i] = arr[end]\\n            } /* else {\\n                // If i is equal distance from start and end, leave it \\'.\\'\\n            } */\\n        }\\n    } /* else {\\n        // Case of L...R\\n        // Nothing needs to be done\\n    } */\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630084,
                "title": "topic-just-for-creating-link-for-my-friend",
                "content": "```\\nvar pushDominoes = function(dominoes) {\\n  const arr = dominoes.split(\"\");\\n  \\n  let currStart = 0;\\n  let pushedToRight = false;\\n  \\n  for (let i=0; i < arr.length; i++) {\\n    if (arr[i] === \"L\" && !pushedToRight) {\\n      for (let j = currStart; j < i; j++) {\\n        arr[j] = \"L\";\\n      }\\n      currStart = i + 1;\\n    } else if (arr[i] === \"L\" && pushedToRight) {\\n      const qnty = i - currStart - 1;\\n      if (qnty % 2 ) {\\n        for (let j=currStart+1; j<currStart+Math.round(qnty/2); j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-Math.round(qnty/2); j--) {\\n          arr[j] = \"L\";\\n        }\\n      } else {\\n        for (let j=currStart+1; j<currStart+qnty/2+1; j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-qnty/2-1; j--) {\\n          arr[j] = \"L\";\\n        }\\n      }\\n      currStart = i + 1;\\n      pushedToRight = false;\\n    } else if (arr[i] === \"R\") {\\n      if (pushedToRight) {\\n        for (let j=currStart; j<i; j++) {\\n          arr[j] = \"R\";\\n        }\\n      }\\n      pushedToRight = true;\\n      currStart = i;\\n    } else {\\n      if (i === arr.length-1 && pushedToRight) {\\n        for (let j=currStart+1; j<arr.length; j++) {\\n          arr[j] = \"R\"\\n        }\\n      }\\n    }\\n  }\\n  return arr.join(\"\");\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar pushDominoes = function(dominoes) {\\n  const arr = dominoes.split(\"\");\\n  \\n  let currStart = 0;\\n  let pushedToRight = false;\\n  \\n  for (let i=0; i < arr.length; i++) {\\n    if (arr[i] === \"L\" && !pushedToRight) {\\n      for (let j = currStart; j < i; j++) {\\n        arr[j] = \"L\";\\n      }\\n      currStart = i + 1;\\n    } else if (arr[i] === \"L\" && pushedToRight) {\\n      const qnty = i - currStart - 1;\\n      if (qnty % 2 ) {\\n        for (let j=currStart+1; j<currStart+Math.round(qnty/2); j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-Math.round(qnty/2); j--) {\\n          arr[j] = \"L\";\\n        }\\n      } else {\\n        for (let j=currStart+1; j<currStart+qnty/2+1; j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-qnty/2-1; j--) {\\n          arr[j] = \"L\";\\n        }\\n      }\\n      currStart = i + 1;\\n      pushedToRight = false;\\n    } else if (arr[i] === \"R\") {\\n      if (pushedToRight) {\\n        for (let j=currStart; j<i; j++) {\\n          arr[j] = \"R\";\\n        }\\n      }\\n      pushedToRight = true;\\n      currStart = i;\\n    } else {\\n      if (i === arr.length-1 && pushedToRight) {\\n        for (let j=currStart+1; j<arr.length; j++) {\\n          arr[j] = \"R\"\\n        }\\n      }\\n    }\\n  }\\n  return arr.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629925,
                "title": "easy-to-understand-beginners-approach",
                "content": "Check the commented example inside code for better understanding. 1st iteration from left to right is for right push only and 2nd iteration from right to left is for left push only.\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> t1;\\n        vector<int> t2;\\n        int c1=1;\\n        int c2=1;\\n        int n = d.length();\\n        int i=0;\\n        while(i<n)\\n        {\\n            c1=1;\\n            if(d[i]==\\'R\\')\\n            {\\n                t1.push_back(0);\\n                while(i+1<n && d[i+1]==\\'.\\'){\\n                    t1.push_back(c1);\\n                    c1++;\\n                    i++;\\n                }\\n            }\\n            else{\\n                t1.push_back(0);\\n            }\\n            i++;\\n        }\\n        i = n-1;\\n        while(i>=0)\\n        {\\n            c2= 1;\\n            if(d[i]==\\'L\\')\\n            {\\n                t2.push_back(0);\\n                while(i-1>=0 && d[i-1]==\\'.\\'){\\n                    t2.push_back(c2);\\n                    c2++;\\n                    i--;\\n                }\\n            }\\n            else{\\n                t2.push_back(0);\\n            }\\n            i--;\\n        }\\n        reverse(t2.begin(),t2.end());\\n        string ans = \"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(t1[i]==t2[i] && t1[i]!=0){\\n                ans+=\\'.\\';\\n            }\\n            else if(t1[i]<t2[i]){\\n                if(t1[i]==0)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n                else{\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(t1[i]>t2[i]){\\n                if(t2[i]==0)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n                else{\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else{\\n                ans+=d[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// . L . R 1R 2R 3R L R 1R 2R L . .\\n// L L . R 3L 2L 1L L R 2L 1L L . . \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> t1;\\n        vector<int> t2;\\n        int c1=1;\\n        int c2=1;\\n        int n = d.length();\\n        int i=0;\\n        while(i<n)\\n        {\\n            c1=1;\\n            if(d[i]==\\'R\\')\\n            {\\n                t1.push_back(0);\\n                while(i+1<n && d[i+1]==\\'.\\'){\\n                    t1.push_back(c1);\\n                    c1++;\\n                    i++;\\n                }\\n            }\\n            else{\\n                t1.push_back(0);\\n            }\\n            i++;\\n        }\\n        i = n-1;\\n        while(i>=0)\\n        {\\n            c2= 1;\\n            if(d[i]==\\'L\\')\\n            {\\n                t2.push_back(0);\\n                while(i-1>=0 && d[i-1]==\\'.\\'){\\n                    t2.push_back(c2);\\n                    c2++;\\n                    i--;\\n                }\\n            }\\n            else{\\n                t2.push_back(0);\\n            }\\n            i--;\\n        }\\n        reverse(t2.begin(),t2.end());\\n        string ans = \"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(t1[i]==t2[i] && t1[i]!=0){\\n                ans+=\\'.\\';\\n            }\\n            else if(t1[i]<t2[i]){\\n                if(t1[i]==0)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n                else{\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(t1[i]>t2[i]){\\n                if(t2[i]==0)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n                else{\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else{\\n                ans+=d[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// . L . R 1R 2R 3R L R 1R 2R L . .\\n// L L . R 3L 2L 1L L R 2L 1L L . . \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629886,
                "title": "go-dynamic-programming",
                "content": "```\\nfunc fall(l, c, r rune) rune {\\n\\tif c == \\'.\\' {\\n\\t\\tif l == \\'R\\' && r == \\'L\\' {\\n\\t\\t\\treturn \\'.\\'\\n\\t\\t}\\n\\t\\tif l == \\'R\\' {\\n\\t\\t\\treturn \\'R\\'\\n\\t\\t}\\n\\t\\tif r == \\'L\\' {\\n\\t\\t\\treturn \\'L\\'\\n\\t\\t}\\n\\t}\\n\\treturn c\\n}\\n\\nfunc pushIteration(dominoes string) string {\\n\\tresult := make([]rune, len(dominoes))\\n\\tif len(dominoes) == 1 {\\n\\t\\treturn dominoes\\n\\t}\\n\\tdominoesR := []rune(dominoes)\\n\\tfor i := 0; i < len(dominoesR); i++ {\\n\\t\\tswitch i {\\n\\t\\tcase 0:\\n\\t\\t\\tresult[i] = fall(\\'.\\', dominoesR[i], dominoesR[i+1])\\n\\t\\tcase len(dominoes) - 1:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], \\'.\\')\\n\\t\\tdefault:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], dominoesR[i+1])\\n\\t\\t}\\n\\t}\\n\\treturn string(result)\\n}\\n\\nfunc pushDominoes(dominoes string) string {\\n\\tpreviousIteration := pushIteration(dominoes)\\n\\tfor previousIteration != dominoes {\\n\\t\\tpreviousIteration = dominoes\\n\\t\\tdominoes = pushIteration(dominoes)\\n\\t}\\n\\treturn dominoes\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc fall(l, c, r rune) rune {\\n\\tif c == \\'.\\' {\\n\\t\\tif l == \\'R\\' && r == \\'L\\' {\\n\\t\\t\\treturn \\'.\\'\\n\\t\\t}\\n\\t\\tif l == \\'R\\' {\\n\\t\\t\\treturn \\'R\\'\\n\\t\\t}\\n\\t\\tif r == \\'L\\' {\\n\\t\\t\\treturn \\'L\\'\\n\\t\\t}\\n\\t}\\n\\treturn c\\n}\\n\\nfunc pushIteration(dominoes string) string {\\n\\tresult := make([]rune, len(dominoes))\\n\\tif len(dominoes) == 1 {\\n\\t\\treturn dominoes\\n\\t}\\n\\tdominoesR := []rune(dominoes)\\n\\tfor i := 0; i < len(dominoesR); i++ {\\n\\t\\tswitch i {\\n\\t\\tcase 0:\\n\\t\\t\\tresult[i] = fall(\\'.\\', dominoesR[i], dominoesR[i+1])\\n\\t\\tcase len(dominoes) - 1:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], \\'.\\')\\n\\t\\tdefault:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], dominoesR[i+1])\\n\\t\\t}\\n\\t}\\n\\treturn string(result)\\n}\\n\\nfunc pushDominoes(dominoes string) string {\\n\\tpreviousIteration := pushIteration(dominoes)\\n\\tfor previousIteration != dominoes {\\n\\t\\tpreviousIteration = dominoes\\n\\t\\tdominoes = pushIteration(dominoes)\\n\\t}\\n\\treturn dominoes\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629872,
                "title": "o-n-time",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        st=\".\"\\n        ct=0\\n        arr=[]\\n        for a in dominoes:\\n            if(a==\".\"):\\n                ct+=1\\n            elif(a==\"R\"):\\n                arr.append(st+str(ct))\\n                st=\"R\"\\n                ct=1\\n            elif(a==\"L\"):\\n                if(st==\"R\"):\\n                    ct+=1\\n                    arr.append(\"R\"+str(ct//2))\\n                    arr.append(\".\"+str(ct%2))\\n                    arr.append(\"L\"+str(ct//2))\\n                elif(st==\".\"):\\n                    arr.append(\"L\"+str(ct+1))\\n                ct=0\\n                st=\".\"\\n        arr.append(st+str(ct))\\n        # print(arr)\\n        ans=\"\"\\n        for a in arr:\\n            ans+=a[0]*int(a[1:])\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        st=\".\"\\n        ct=0\\n        arr=[]\\n        for a in dominoes:\\n            if(a==\".\"):\\n                ct+=1\\n            elif(a==\"R\"):\\n                arr.append(st+str(ct))\\n                st=\"R\"\\n                ct=1\\n            elif(a==\"L\"):\\n                if(st==\"R\"):\\n                    ct+=1\\n                    arr.append(\"R\"+str(ct//2))\\n                    arr.append(\".\"+str(ct%2))\\n                    arr.append(\"L\"+str(ct//2))\\n                elif(st==\".\"):\\n                    arr.append(\"L\"+str(ct+1))\\n                ct=0\\n                st=\".\"\\n        arr.append(st+str(ct))\\n        # print(arr)\\n        ans=\"\"\\n        for a in arr:\\n            ans+=a[0]*int(a[1:])\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629585,
                "title": "c-easy-momentum-physics-solution-o-n",
                "content": "**basically we give each domino a force vector which show how much force is applied in which direction. if value its negative its falling left and vice versa**\\n**its like equating all forces in mechanism**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        \\n        vector<int> values(d.size(),0);\\n        for(int i=0;i<d.size();i++){\\n           if (d[i] == \\'R\\')\\n        {\\n           \\n            int val = d.size();\\n            values[i]=d.size()+1;\\n            int j = i + 1;\\n            while (j<d.size() && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val--;\\n                j++;\\n            }\\n        }\\n        if (d[i] == \\'L\\')\\n        {\\n            int val = -d.size();\\n            values[i] += (val-1);\\n            int j = i - 1;\\n\\n            while (j>=0 && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val++;\\n                j--;\\n            }\\n        }\\n        }\\n        for(int i=0;i<d.size();i++){\\n            if(values[i]<0){\\n                d[i]=\\'L\\';\\n            }\\n            else if(values[i]>0){\\n                d[i]=\\'R\\';\\n            }\\n            else{\\n                d[i]=\\'.\\';\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        \\n        vector<int> values(d.size(),0);\\n        for(int i=0;i<d.size();i++){\\n           if (d[i] == \\'R\\')\\n        {\\n           \\n            int val = d.size();\\n            values[i]=d.size()+1;\\n            int j = i + 1;\\n            while (j<d.size() && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val--;\\n                j++;\\n            }\\n        }\\n        if (d[i] == \\'L\\')\\n        {\\n            int val = -d.size();\\n            values[i] += (val-1);\\n            int j = i - 1;\\n\\n            while (j>=0 && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val++;\\n                j--;\\n            }\\n        }\\n        }\\n        for(int i=0;i<d.size();i++){\\n            if(values[i]<0){\\n                d[i]=\\'L\\';\\n            }\\n            else if(values[i]>0){\\n                d[i]=\\'R\\';\\n            }\\n            else{\\n                d[i]=\\'.\\';\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629493,
                "title": "c-easy-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int force = 0;\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\') force = n;\\n            else if(dominoes[i] == \\'L\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n        force = 0;\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\') force = n;\\n            else if(dominoes[i] == \\'R\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n        string ans;\\n        for(auto f : forces){\\n            ans.push_back(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int force = 0;\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\') force = n;\\n            else if(dominoes[i] == \\'L\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n        force = 0;\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\') force = n;\\n            else if(dominoes[i] == \\'R\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n        string ans;\\n        for(auto f : forces){\\n            ans.push_back(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629448,
                "title": "simple-c-solution-force-calculation-clean-code-o-n-2-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int> force(n,0);\\n        \\n        int f=0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'R\\') f = n;\\n            else if(s[i] == \\'L\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] += f;\\n        }\\n        \\n        f=0;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(s[i] == \\'L\\') f = n;\\n            else if(s[i] == \\'R\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] -= f;\\n        }\\n        \\n        s = \"\";\\n        for(int f : force) {\\n            if(f == 0) s+=\\'.\\';\\n            else if(f > 0) s+=\\'R\\';\\n            else s+=\\'L\\';\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int> force(n,0);\\n        \\n        int f=0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'R\\') f = n;\\n            else if(s[i] == \\'L\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] += f;\\n        }\\n        \\n        f=0;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(s[i] == \\'L\\') f = n;\\n            else if(s[i] == \\'R\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] -= f;\\n        }\\n        \\n        s = \"\";\\n        for(int f : force) {\\n            if(f == 0) s+=\\'.\\';\\n            else if(f > 0) s+=\\'R\\';\\n            else s+=\\'L\\';\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629446,
                "title": "2-way-traversal-solution-in-tc-o-n",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        dominoes=list(dominoes)\\n        flag=0\\n        for i in range(n-1,-1,-1):\\n            if dominoes[i]==\"L\":\\n                ct=1\\n                flag=1\\n            elif dominoes[i]==\".\" and flag==1:\\n                dominoes[i]=ct\\n                ct+=1\\n            elif dominoes[i]==\"R\":\\n                flag=0\\n            else:\\n                dominoes[i]=0\\n        flagr=0\\n        for i in range(n):\\n            if dominoes[i]==\"R\":\\n                ctr=1\\n                flagr=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)<abs(dominoes[i]) or dominoes[i]==\".\":\\n                dominoes[i]=\"R\"\\n                ctr+=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)==abs(dominoes[i]):\\n                dominoes[i]=\".\"\\n            elif flagr==1 and dominoes[i]==0:\\n                dominoes[i]=\"R\"\\n            elif dominoes[i]==\"L\":\\n                flagr=0\\n            elif dominoes[i]==0:\\n                dominoes[i]=\".\"\\n            else:\\n                dominoes[i]=\"L\"\\n        return \"\".join(dominoes)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        dominoes=list(dominoes)\\n        flag=0\\n        for i in range(n-1,-1,-1):\\n            if dominoes[i]==\"L\":\\n                ct=1\\n                flag=1\\n            elif dominoes[i]==\".\" and flag==1:\\n                dominoes[i]=ct\\n                ct+=1\\n            elif dominoes[i]==\"R\":\\n                flag=0\\n            else:\\n                dominoes[i]=0\\n        flagr=0\\n        for i in range(n):\\n            if dominoes[i]==\"R\":\\n                ctr=1\\n                flagr=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)<abs(dominoes[i]) or dominoes[i]==\".\":\\n                dominoes[i]=\"R\"\\n                ctr+=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)==abs(dominoes[i]):\\n                dominoes[i]=\".\"\\n            elif flagr==1 and dominoes[i]==0:\\n                dominoes[i]=\"R\"\\n            elif dominoes[i]==\"L\":\\n                flagr=0\\n            elif dominoes[i]==0:\\n                dominoes[i]=\".\"\\n            else:\\n                dominoes[i]=\"L\"\\n        return \"\".join(dominoes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629354,
                "title": "c-2-pointer-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int temp = 0;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            if(dominoes[i] == \\'R\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'L\\')\\n                temp = 0;\\n            else\\n                temp = max(temp - 1, 0);\\n            forces[i] += temp;\\n        }\\n        temp = 0;\\n        for(int i = n - 1;i >= 0; i--)\\n        {\\n            if(dominoes[i] == \\'L\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'R\\')\\n                temp = 0;\\n            else \\n                temp = max(temp - 1, 0);\\n            forces[i] -= temp;\\n        }\\n        string ans = \"\";\\n        for(int i = 0 ; i < forces.size(); i++)\\n        {\\n            if(forces[i] > 0)\\n                ans += \\'R\\';\\n            else if(forces[i] < 0)\\n                ans += \\'L\\';\\n            else \\n                ans += \\'.\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int temp = 0;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            if(dominoes[i] == \\'R\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'L\\')\\n                temp = 0;\\n            else\\n                temp = max(temp - 1, 0);\\n            forces[i] += temp;\\n        }\\n        temp = 0;\\n        for(int i = n - 1;i >= 0; i--)\\n        {\\n            if(dominoes[i] == \\'L\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'R\\')\\n                temp = 0;\\n            else \\n                temp = max(temp - 1, 0);\\n            forces[i] -= temp;\\n        }\\n        string ans = \"\";\\n        for(int i = 0 ; i < forces.size(); i++)\\n        {\\n            if(forces[i] > 0)\\n                ans += \\'R\\';\\n            else if(forces[i] < 0)\\n                ans += \\'L\\';\\n            else \\n                ans += \\'.\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629351,
                "title": "find-positions-of-r-l-easy-explanation",
                "content": "considerd the string \\n\\n\".L.R...LR..L..\"\\n\\nIf an R is followed by L then they will fall toward themselve\\nif an R is not followed by L then it will fall toward right (all domino after that index)\\nif an L is not backed by R then it wall fall toward left  (all domino before that index)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans = \"\";\\n        vector<int> left; // store \\'L\\' index \\n        vector<int> right; // store \\'R\\' index\\n        vector<pair<int,int>> lr; // store R....L type index\\n         \\n        for(int i = 0;i<s.length();i++)\\n        {\\n                if(s[i] == \\'L\\') // L is not backed by and R\\n                        left.push_back(i);\\n                else if(s[i] == \\'R\\') // Here two condition exist, may be L is present after this or not present\\n                {\\n                   int x = i;    \\n                   int j = i;    \\n                   bool flag = false;     \\n                   for( j = i+1;j<s.length();j++)\\n                     if(s[j] ==\\'L\\') // If L is present then a pair is found\\n                     {\\n                             flag = true;\\n                             lr.push_back({x,j});\\n                             break;\\n                     }\\n                     else if(s[j] == \\'R\\') // If R is present after R then store in right index\\n                     {\\n                             right.push_back(x);\\n                             x = j;\\n                     }\\n                     if(!flag) right.push_back(x);  \\n                     i = j;       \\n                }\\n        }\\n        \\n        \\n        for(auto &[a,b] : lr) // Fire deal with R.....L type substring\\n        {\\n                int x = (a+b)/2;\\n                if((b-a+1)%2 != 0){\\n                for(int i = a;i<x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';\\n                }\\n                else\\n                {\\n                for(int i = a;i<=x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';        \\n                }\\n        }\\n     \\n        \\n        for(int i = 0;i<left.size();i++) // Dealing with \\'L\\' type substring\\n        {\\n                int j = left[i]-1;\\n                while(j >= 0 && s[j] == \\'.\\')\\n                        s[j--] = \\'L\\';\\n        }\\n         \\n        for(int i = right.size()-1;i>=0;i--) // Dealing with \\'R\\' type substring\\n        {\\n               int j = right[i]+1;\\n               while(j <s.size() && s[j] == \\'.\\')\\n                        s[j++] = \\'R\\'; \\n        }\\n        \\n\\n            \\n            \\n            \\n            return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans = \"\";\\n        vector<int> left; // store \\'L\\' index \\n        vector<int> right; // store \\'R\\' index\\n        vector<pair<int,int>> lr; // store R....L type index\\n         \\n        for(int i = 0;i<s.length();i++)\\n        {\\n                if(s[i] == \\'L\\') // L is not backed by and R\\n                        left.push_back(i);\\n                else if(s[i] == \\'R\\') // Here two condition exist, may be L is present after this or not present\\n                {\\n                   int x = i;    \\n                   int j = i;    \\n                   bool flag = false;     \\n                   for( j = i+1;j<s.length();j++)\\n                     if(s[j] ==\\'L\\') // If L is present then a pair is found\\n                     {\\n                             flag = true;\\n                             lr.push_back({x,j});\\n                             break;\\n                     }\\n                     else if(s[j] == \\'R\\') // If R is present after R then store in right index\\n                     {\\n                             right.push_back(x);\\n                             x = j;\\n                     }\\n                     if(!flag) right.push_back(x);  \\n                     i = j;       \\n                }\\n        }\\n        \\n        \\n        for(auto &[a,b] : lr) // Fire deal with R.....L type substring\\n        {\\n                int x = (a+b)/2;\\n                if((b-a+1)%2 != 0){\\n                for(int i = a;i<x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';\\n                }\\n                else\\n                {\\n                for(int i = a;i<=x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';        \\n                }\\n        }\\n     \\n        \\n        for(int i = 0;i<left.size();i++) // Dealing with \\'L\\' type substring\\n        {\\n                int j = left[i]-1;\\n                while(j >= 0 && s[j] == \\'.\\')\\n                        s[j--] = \\'L\\';\\n        }\\n         \\n        for(int i = right.size()-1;i>=0;i--) // Dealing with \\'R\\' type substring\\n        {\\n               int j = right[i]+1;\\n               while(j <s.size() && s[j] == \\'.\\')\\n                        s[j++] = \\'R\\'; \\n        }\\n        \\n\\n            \\n            \\n            \\n            return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629263,
                "title": "java-easy-to-understand-well-commented-left-and-right-array-calculating-force",
                "content": "\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // will calculate the force on every domino in this \\n        //+ve force means domino would fall right and -ve force means domino would fall left\\n        \\n        int n = dominoes.length(); //length of dominoes array and max. force that can be applied on any domino\\n        //calculate right force | +Ve force\\n        int force = 0;\\n        int[] forces = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(dominoes.charAt(i) == \\'R\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'L\\'){\\n                force = 0;\\n            }\\n            forces[i] = force;\\n            if(force == 0) continue;\\n            force--;\\n        }\\n        \\n        //calculate left force | -Ve force\\n        force = 0;  // starting force would be zero\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes.charAt(i) == \\'L\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'R\\'){\\n                force = 0;\\n            }\\n            forces[i] -= force; \\n            if(force == 0) continue;\\n            force--; //less neg force overtime\\n        }\\n        \\n        //calculating total force and making answer acc. to that\\n        //if total force is +ve then domino will fall right => \\'R\\'\\n        //if total force is -ve then domino will fall left => \\'L\\'\\n        //else it will stand still => \\'.\\'\\n        char[] ans = new char[n];\\n        int index = 0;\\n        \\n        for(int totalForce: forces){\\n            char current = \\'.\\';\\n            if(totalForce > 0){\\n                current = \\'R\\';\\n            } else if(totalForce < 0){\\n                current = \\'L\\';\\n            }\\n            \\n            ans[index] = current;\\n            index++;\\n        }\\n        \\n        \\n        return new String(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // will calculate the force on every domino in this \\n        //+ve force means domino would fall right and -ve force means domino would fall left\\n        \\n        int n = dominoes.length(); //length of dominoes array and max. force that can be applied on any domino\\n        //calculate right force | +Ve force\\n        int force = 0;\\n        int[] forces = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(dominoes.charAt(i) == \\'R\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'L\\'){\\n                force = 0;\\n            }\\n            forces[i] = force;\\n            if(force == 0) continue;\\n            force--;\\n        }\\n        \\n        //calculate left force | -Ve force\\n        force = 0;  // starting force would be zero\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes.charAt(i) == \\'L\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'R\\'){\\n                force = 0;\\n            }\\n            forces[i] -= force; \\n            if(force == 0) continue;\\n            force--; //less neg force overtime\\n        }\\n        \\n        //calculating total force and making answer acc. to that\\n        //if total force is +ve then domino will fall right => \\'R\\'\\n        //if total force is -ve then domino will fall left => \\'L\\'\\n        //else it will stand still => \\'.\\'\\n        char[] ans = new char[n];\\n        int index = 0;\\n        \\n        for(int totalForce: forces){\\n            char current = \\'.\\';\\n            if(totalForce > 0){\\n                current = \\'R\\';\\n            } else if(totalForce < 0){\\n                current = \\'L\\';\\n            }\\n            \\n            ans[index] = current;\\n            index++;\\n        }\\n        \\n        \\n        return new String(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629224,
                "title": "using-two-pointer",
                "content": "\\n```\\nstring pushDominoes(string s) {\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')\\n            {\\n                int j=i+1;\\n                while(j<n && s[j]==\\'.\\')\\n                    j++;\\n                //if(j==i+1) continue;\\n                if(j==n)\\n                {\\n                    i++;\\n                    while(i<n){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                }\\n                else if(s[j]==\\'L\\')\\n                {\\n                    int k=j;\\n                    i++;k--;\\n                    while(i<k)\\n                    {\\n                        s[i]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                        i++;\\n                        k--;\\n                    }\\n                    i=j;\\n                }\\n                else\\n                {\\n                    while(i<j){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                    i--;\\n                }\\n                    \\n            }\\n            else if(s[i]==\\'L\\')\\n            {\\n\\n                int j=i;\\n                while(j-1>0 && s[j-1]==\\'.\\' && s[j-2]!=\\'R\\')\\n                {\\n                    s[j-1]=\\'L\\';\\n                    j--;\\n                }\\n                 if(j-1==0 && s[j-1]==\\'.\\')\\n                  s[j-1]=\\'L\\';\\n                    \\n            }\\n        }\\n        return s;\\n    }",
                "solutionTags": [
                    "Two Pointers",
                    "String"
                ],
                "code": "\\n```\\nstring pushDominoes(string s) {\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')\\n            {\\n                int j=i+1;\\n                while(j<n && s[j]==\\'.\\')\\n                    j++;\\n                //if(j==i+1) continue;\\n                if(j==n)\\n                {\\n                    i++;\\n                    while(i<n){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                }\\n                else if(s[j]==\\'L\\')\\n                {\\n                    int k=j;\\n                    i++;k--;\\n                    while(i<k)\\n                    {\\n                        s[i]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                        i++;\\n                        k--;\\n                    }\\n                    i=j;\\n                }\\n                else\\n                {\\n                    while(i<j){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                    i--;\\n                }\\n                    \\n            }\\n            else if(s[i]==\\'L\\')\\n            {\\n\\n                int j=i;\\n                while(j-1>0 && s[j-1]==\\'.\\' && s[j-2]!=\\'R\\')\\n                {\\n                    s[j-1]=\\'L\\';\\n                    j--;\\n                }\\n                 if(j-1==0 && s[j-1]==\\'.\\')\\n                  s[j-1]=\\'L\\';\\n                    \\n            }\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2629148,
                "title": "simple-python-solution-using-queue",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        domino=list(dominoes)\\n        q=deque()\\n        for i,d in enumerate(domino):\\n            if d!=\".\":\\n                q.append((i,d))\\n        while q:\\n            i,d=q.popleft()\\n            if d==\"L\" and i>0 and domino[i-1]==\".\":\\n                q.append((i-1,\"L\"))\\n                domino[i-1]=\"L\"\\n            elif d==\"R\":\\n                if i+1<len(domino) and domino[i+1]==\".\":\\n                    if i+2<len(domino) and domino[i+2]==\"L\":\\n                        q.popleft()\\n                    else:\\n                        q.append((i+1,\"R\"))\\n                        domino[i+1]=\"R\"\\n        return \\'\\'.join(map(str,domino))\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        domino=list(dominoes)\\n        q=deque()\\n        for i,d in enumerate(domino):\\n            if d!=\".\":\\n                q.append((i,d))\\n        while q:\\n            i,d=q.popleft()\\n            if d==\"L\" and i>0 and domino[i-1]==\".\":\\n                q.append((i-1,\"L\"))\\n                domino[i-1]=\"L\"\\n            elif d==\"R\":\\n                if i+1<len(domino) and domino[i+1]==\".\":\\n                    if i+2<len(domino) and domino[i+2]==\"L\":\\n                        q.popleft()\\n                    else:\\n                        q.append((i+1,\"R\"))\\n                        domino[i+1]=\"R\"\\n        return \\'\\'.join(map(str,domino))\\n",
                "codeTag": "Java"
            },
            {
                "id": 2629088,
                "title": "c-o-n-complexity-explained-using-comments",
                "content": "```\\n/* Lets take example2 to understand the concept\\n                             \". L . R . . . L R . . L . .\"\\n\\t\\tFirstly we\\'ll do prefix count of how many will fall towards right and left.\\n\\t\\tWe\\'ll maintain 2 vectors right and left.\\n\\t\\t\\n\\t\\tFor right vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from left to right\\n\\t\\t2) If dominoes[i] == \\'L\\' then it won\\'t fall towards right so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'R\\' then it will fall towards right only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"R R . R\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'R\\' as a starting point of dominoes which will fall towards right\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 1st index so we\\'ll increment value by 1. As this will also fall on right only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on left as some dominoes maybe\\n\\t\\t\\tfalling on left. That we\\'ll consider once we find all the indexes with respect to \\'R\\' dominoes.\\n\\t\\t\\t\\n\\t\\tSimilarly, For left vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from right to left\\n\\t\\t2) If dominoes[i] == \\'R\\' then it won\\'t fall towards left so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'L\\' then it will fall towards left only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"L L . L\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'L\\' as a starting point of dominoes which will fall towards left\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 3rd index so we\\'ll increment value by 1. As this will also fall on left only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on right as some dominoes maybe\\n\\t\\t\\tfalling on right. That we\\'ll consider once we find all the indexes with respect to \\'L\\' dominoes.\\n\\t\\t\\t\\n\\t\\tNow, coming back to example2. Here, we\\'ll firstly find right and left vector.\\n\\t\\tAfterwards we\\'ll perform some operations.\\n\\t\\t                                \". L . R . . . L R . . L . .\"\\n\\t\\t\\t\\t\\t\\t\\t\\t right - 0 0 0 1 2 3 4 0 1 2 3 0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  left - 2 1 0 0 4 3 2 1 0 3 2 1 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t1) Now, if left[i]==0 && right[i]==0, it means it\\'ll be stable So, we\\'ll append \\'.\\' in ans.\\n\\t\\t2) Again, if either is non-zero and another is 0 then it\\'ll fall in favor of non-zero direction\\n\\t\\t3) And if both are non-zero then it\\'ll fall in favor of that direction which have a minimum\\n\\t\\t   value at that particular index. And if both have equal values then it\\'ll remain stable.\\n\\t\\t   Example - if right[i]=2 and left[i]=3 then it\\'ll fall towards right because all dominoes are\\n\\t\\t   simultaneously falling, so domino of this particular index will fall to that direction\\n\\t\\t   in which it has minimum value.\\n*/\\nstring pushDominoes(string s) {\\n        int n=s.length(), cnt=1;\\n        vector<int> left(n), right(n);\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'R\\')\\n                cnt=1, right[i]=cnt++;\\n            else if((i==0 && s[i]==\\'.\\')||s[i]==\\'L\\')\\n                right[i]=0, cnt=1;\\n            else if(i!=0 && s[i]==\\'.\\' && right[i-1]!=0)\\n                right[i]=cnt++;\\n            else\\n                right[i]=0;\\n        }\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'L\\')\\n                cnt=1, left[i]=cnt++;\\n            else if((i==n-1 && s[i]==\\'.\\')||s[i]==\\'R\\')\\n                left[i]=0, cnt=1;\\n            else if(i!=n-1 && s[i]==\\'.\\' && left[i+1]!=0)\\n                left[i]=cnt++;\\n            else\\n                left[i]=0;\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            if(left[i]!=0 && right[i]==0)\\n                ans+=\"L\";\\n            else if(left[i]==0 && right[i]!=0)\\n                ans+=\"R\";\\n            else if(left[i]==0 && right[i]==0)\\n                ans+=\".\";\\n            else {\\n                if(left[i]<right[i])\\n                    ans+=\"L\";\\n                else if(right[i]<left[i])\\n                    ans+=\"R\";\\n                else\\n                    ans+=\".\";\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t/* I tried my best to deliver explanation. I hope it helped you to understand, if you face any issue please do\\n\\task in comments. Thanks!! */",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/* Lets take example2 to understand the concept\\n                             \". L . R . . . L R . . L . .\"\\n\\t\\tFirstly we\\'ll do prefix count of how many will fall towards right and left.\\n\\t\\tWe\\'ll maintain 2 vectors right and left.\\n\\t\\t\\n\\t\\tFor right vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from left to right\\n\\t\\t2) If dominoes[i] == \\'L\\' then it won\\'t fall towards right so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'R\\' then it will fall towards right only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"R R . R\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'R\\' as a starting point of dominoes which will fall towards right\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 1st index so we\\'ll increment value by 1. As this will also fall on right only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on left as some dominoes maybe\\n\\t\\t\\tfalling on left. That we\\'ll consider once we find all the indexes with respect to \\'R\\' dominoes.\\n\\t\\t\\t\\n\\t\\tSimilarly, For left vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from right to left\\n\\t\\t2) If dominoes[i] == \\'R\\' then it won\\'t fall towards left so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'L\\' then it will fall towards left only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"L L . L\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'L\\' as a starting point of dominoes which will fall towards left\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 3rd index so we\\'ll increment value by 1. As this will also fall on left only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on right as some dominoes maybe\\n\\t\\t\\tfalling on right. That we\\'ll consider once we find all the indexes with respect to \\'L\\' dominoes.\\n\\t\\t\\t\\n\\t\\tNow, coming back to example2. Here, we\\'ll firstly find right and left vector.\\n\\t\\tAfterwards we\\'ll perform some operations.\\n\\t\\t                                \". L . R . . . L R . . L . .\"\\n\\t\\t\\t\\t\\t\\t\\t\\t right - 0 0 0 1 2 3 4 0 1 2 3 0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  left - 2 1 0 0 4 3 2 1 0 3 2 1 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t1) Now, if left[i]==0 && right[i]==0, it means it\\'ll be stable So, we\\'ll append \\'.\\' in ans.\\n\\t\\t2) Again, if either is non-zero and another is 0 then it\\'ll fall in favor of non-zero direction\\n\\t\\t3) And if both are non-zero then it\\'ll fall in favor of that direction which have a minimum\\n\\t\\t   value at that particular index. And if both have equal values then it\\'ll remain stable.\\n\\t\\t   Example - if right[i]=2 and left[i]=3 then it\\'ll fall towards right because all dominoes are\\n\\t\\t   simultaneously falling, so domino of this particular index will fall to that direction\\n\\t\\t   in which it has minimum value.\\n*/\\nstring pushDominoes(string s) {\\n        int n=s.length(), cnt=1;\\n        vector<int> left(n), right(n);\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'R\\')\\n                cnt=1, right[i]=cnt++;\\n            else if((i==0 && s[i]==\\'.\\')||s[i]==\\'L\\')\\n                right[i]=0, cnt=1;\\n            else if(i!=0 && s[i]==\\'.\\' && right[i-1]!=0)\\n                right[i]=cnt++;\\n            else\\n                right[i]=0;\\n        }\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'L\\')\\n                cnt=1, left[i]=cnt++;\\n            else if((i==n-1 && s[i]==\\'.\\')||s[i]==\\'R\\')\\n                left[i]=0, cnt=1;\\n            else if(i!=n-1 && s[i]==\\'.\\' && left[i+1]!=0)\\n                left[i]=cnt++;\\n            else\\n                left[i]=0;\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            if(left[i]!=0 && right[i]==0)\\n                ans+=\"L\";\\n            else if(left[i]==0 && right[i]!=0)\\n                ans+=\"R\";\\n            else if(left[i]==0 && right[i]==0)\\n                ans+=\".\";\\n            else {\\n                if(left[i]<right[i])\\n                    ans+=\"L\";\\n                else if(right[i]<left[i])\\n                    ans+=\"R\";\\n                else\\n                    ans+=\".\";\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t/* I tried my best to deliver explanation. I hope it helped you to understand, if you face any issue please do\\n\\task in comments. Thanks!! */",
                "codeTag": "Unknown"
            },
            {
                "id": 2629078,
                "title": "python3-o-n-pythonic-two-pointers",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = list(\\'L\\' + dominoes + \\'R\\')\\n        l, r = 0, 1\\n        while r < len(res):\\n            if res[r] == \\'.\\':\\n                r += 1\\n                continue\\n            elif res[r] == \\'L\\' and res[l] == \\'R\\':\\n                h = (r - l - 1) // 2\\n                res[l+1:l+1+h] = [\\'R\\'] * h\\n                res[r-h:r] = [\\'L\\'] * h\\n            elif res[l] == res[r]:\\n                res[l+1:r] = [res[l]] * (r - l - 1)\\n            l, r = r, r + 1\\n        return \\'\\'.join(res[1:-1])        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = list(\\'L\\' + dominoes + \\'R\\')\\n        l, r = 0, 1\\n        while r < len(res):\\n            if res[r] == \\'.\\':\\n                r += 1\\n                continue\\n            elif res[r] == \\'L\\' and res[l] == \\'R\\':\\n                h = (r - l - 1) // 2\\n                res[l+1:l+1+h] = [\\'R\\'] * h\\n                res[r-h:r] = [\\'L\\'] * h\\n            elif res[l] == res[r]:\\n                res[l+1:r] = [res[l]] * (r - l - 1)\\n            l, r = r, r + 1\\n        return \\'\\'.join(res[1:-1])        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628947,
                "title": "c-bfs",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    string pushDominoes(string& dominoes) {\\n        \\n        int n = dominoes.size();\\n        vector<int> l( n, INT_MAX );\\n        vector<int> r( n, INT_MAX );\\n        \\n        queue< int > qr;\\n        queue< int > ql;\\n        \\n        for( int i=0; i<dominoes.size() ;i++ ){\\n            if( dominoes[i] == \\'R\\' ){\\n                r[i] = 0;\\n                qr.push(i);\\n            }\\n            else if( dominoes[i] == \\'L\\' ){\\n                l[i] = 0;\\n                ql.push(i);\\n            }\\n        }\\n        while( !ql.empty() ){\\n            int i = ql.front();\\n            ql.pop();\\n            \\n            if( i > 0 && dominoes[i-1] == \\'.\\' && 1+l[i] < l[i-1] ){\\n                l[i-1] = 1 + l[i];\\n                ql.push(i-1);\\n            }\\n        }\\n        while( !qr.empty() ){\\n            int i = qr.front();\\n            qr.pop();\\n            \\n            if( i < n-1 && dominoes[i+1] == \\'.\\' && 1 + r[i] < r[i+1] ){\\n                r[i+1] = 1 + r[i];\\n                qr.push(i+1);\\n            }\\n        }\\n        \\n        for( int i =0; i<n ;i++ ){\\n            if( l[i] < r[i] ){\\n                dominoes[i] = \\'L\\';\\n            }\\n            else if( l[i] == r[i] ){\\n                dominoes[i] = \\'.\\';\\n            }\\n            else{\\n                dominoes[i] = \\'R\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    string pushDominoes(string& dominoes) {\\n        \\n        int n = dominoes.size();\\n        vector<int> l( n, INT_MAX );\\n        vector<int> r( n, INT_MAX );\\n        \\n        queue< int > qr;\\n        queue< int > ql;\\n        \\n        for( int i=0; i<dominoes.size() ;i++ ){\\n            if( dominoes[i] == \\'R\\' ){\\n                r[i] = 0;\\n                qr.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2628922,
                "title": "simulation-in-a-while-loop",
                "content": "Not sure if it is a good solution, but my approach is just do simulation.\\nThe simulation is in the while loop, every time a push do only one forward unitl there is no pushes. like the description said\\n\\n\"each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\"\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes : str) -> str:\\n        dom = list(dominoes)\\n        ls, rs = set(), set()\\n        for i, c in enumerate(dom):\\n            if c==\\'L\\':ls.add(i)\\n            elif c==\\'R\\':rs.add(i)\\n        \\n        while ls or rs:            \\n            newls = set()\\n            for i in ls:\\n                if i-1>=0 and dom[i-1]==\\'.\\':\\n                    if (i-2) in rs:\\n                        rs.remove(i-2)\\n                    else:\\n                        dom[i-1]=\"L\"\\n                        newls.add(i-1)\\n            \\n            newrs = set()\\n            for i in rs:\\n                if i+1<len(dom) and dom[i+1]==\".\":\\n                    dom[i+1]=\"R\"\\n                    newrs.add(i+1)\\n            ls = newls\\n            rs = newrs\\n                \\n        return \"\".join(dom)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes : str) -> str:\\n        dom = list(dominoes)\\n        ls, rs = set(), set()\\n        for i, c in enumerate(dom):\\n            if c==\\'L\\':ls.add(i)\\n            elif c==\\'R\\':rs.add(i)\\n        \\n        while ls or rs:            \\n            newls = set()\\n            for i in ls:\\n                if i-1>=0 and dom[i-1]==\\'.\\':\\n                    if (i-2) in rs:\\n                        rs.remove(i-2)\\n                    else:\\n                        dom[i-1]=\"L\"\\n                        newls.add(i-1)\\n            \\n            newrs = set()\\n            for i in rs:\\n                if i+1<len(dom) and dom[i+1]==\".\":\\n                    dom[i+1]=\"R\"\\n                    newrs.add(i+1)\\n            ls = newls\\n            rs = newrs\\n                \\n        return \"\".join(dom)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628893,
                "title": "c-solution",
                "content": "1. There are just three condition `[L...R],[R..L],[L...L]` we need to care about \\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s,int left=-1,int right = -1) {\\n        for(int i= 0; i <= s.size(); ++i) {\\n            if(i == s.size() or s[i] == \\'R\\'){ // [R..L]\\n              if (right != left)for(int j = right; j < i; s[j++] = \\'R\\');\\n              right = i;\\n            }else if(s[i] == \\'L\\'){\\n                if (left == right) for(int j = left + 1; j < i; s[j++] = \\'L\\');//[L...L]\\n                else //[R...L]\\n                   for(int low = right + 1, high = i - 1;low < high;s[low++] = \\'R\\', s[high--] = \\'L\\');\\n                 left = right = i;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s,int left=-1,int right = -1) {\\n        for(int i= 0; i <= s.size(); ++i) {\\n            if(i == s.size() or s[i] == \\'R\\'){ // [R..L]\\n              if (right != left)for(int j = right; j < i; s[j++] = \\'R\\');\\n              right = i;\\n            }else if(s[i] == \\'L\\'){\\n                if (left == right) for(int j = left + 1; j < i; s[j++] = \\'L\\');//[L...L]\\n                else //[R...L]\\n                   for(int low = right + 1, high = i - 1;low < high;s[low++] = \\'R\\', s[high--] = \\'L\\');\\n                 left = right = i;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628850,
                "title": "java-solution-100-faster-and-easy-code",
                "content": "```\\nclass Solution {\\n  public String pushDominoes(String dominoes) {\\n    char[] s = dominoes.toCharArray();\\n    int L = -1;\\n    int R = -1;\\n\\n    for (int i = 0; i <= dominoes.length(); ++i)\\n      if (i == dominoes.length() || s[i] == \\'R\\') {\\n        if (L < R)\\n          while (R < i)\\n            s[R++] = \\'R\\';\\n        R = i;\\n      } else if (s[i] == \\'L\\') {\\n        if (R < L || L == -1 && R == -1) {\\n          if (L == -1 && R == -1)\\n            ++L;\\n          while (L < i)\\n            s[L++] = \\'L\\';\\n        } else {\\n          int l = R + 1;\\n          int r = i - 1;\\n          while (l < r) {\\n            s[l++] = \\'R\\';\\n            s[r--] = \\'L\\';\\n          }\\n        }\\n        L = i;\\n      }\\n\\n    return new String(s);\\n  }\\n}\\n```\\n// If you like the solution pls upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public String pushDominoes(String dominoes) {\\n    char[] s = dominoes.toCharArray();\\n    int L = -1;\\n    int R = -1;\\n\\n    for (int i = 0; i <= dominoes.length(); ++i)\\n      if (i == dominoes.length() || s[i] == \\'R\\') {\\n        if (L < R)\\n          while (R < i)\\n            s[R++] = \\'R\\';\\n        R = i;\\n      } else if (s[i] == \\'L\\') {\\n        if (R < L || L == -1 && R == -1) {\\n          if (L == -1 && R == -1)\\n            ++L;\\n          while (L < i)\\n            s[L++] = \\'L\\';\\n        } else {\\n          int l = R + 1;\\n          int r = i - 1;\\n          while (l < r) {\\n            s[l++] = \\'R\\';\\n            s[r--] = \\'L\\';\\n          }\\n        }\\n        L = i;\\n      }\\n\\n    return new String(s);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628717,
                "title": "java-easy-solution-easy-to-understand-100-faster-push-dominoes",
                "content": "## Upvote the solution if you liked it \\uD83D\\uDC4D\\n\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] dArray = dominoes.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && dArray[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = dArray[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        dArray[l]=\\'R\\';\\n                        dArray[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        dArray[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        dArray[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(dArray);\\n    }\\n}\\n```\\n\\n### If you liked the solution and it worked for you then please upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] dArray = dominoes.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && dArray[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = dArray[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        dArray[l]=\\'R\\';\\n                        dArray[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        dArray[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        dArray[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(dArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573350,
                "title": "c-95-time-99-99-memory-tricky-two-pointer-explain-comments",
                "content": "The n^2 solution to this problem is easy but it was difficult for me to find a way to not do so much repeated work. I came up with this idea: \\nMaintain the position of the closest domino pointing RIGHT. If we encounter a left domino along the way, the position of the closest domino pointing right is INFINITY because the left cancels it out.\\n\\nLook for the closest domino pointing LEFT. We do this by iterating ahead of our current position. If there is a right domino along the way, the position of the closest domino opint left is INFINITY because the right cancels it out.\\nImportant: We only need to redo this step if closestLeft is BEHIND our current position, because if the closestLeft for i = 3 is index 9, it will also be the closest left for indices 4...8.\\n\\nNow we know the positions of our closest right and left dominos. So for any given \\'.\\', we just need to check the absolute distance from the closestLeft or closestRight domino and set it to that one. If they are equidistant, then we do not change the \\'.\\'.\\n\\n```\\n    string pushDominoes(string d) {\\n        const int INF = 10e5;\\n        int closestLeft = INF; // in front\\n        int closestRight = INF; // behind\\n        int j = 0;\\n        for(int i = 0; i < d.length(); i++){\\n            if(closestLeft <= i || (j <= i && closestLeft == INF)){ // find the closest left domino if it exists \\n                j = i;\\n                while(j < d.length()){ // dont redo calculation if closestleft is >= i because the answer remains the same\\n                        // do redo if closestleft <= i OR j <= i AND closestLeft = infinity\\n                        if(d[j] == \\'L\\'){\\n                            closestLeft = j;\\n                            break;\\n                        }\\n                        if(d[j] == \\'R\\'){\\n                            closestLeft = INF;\\n                            break;\\n                        }\\n                        j++;\\n                    }\\n            }\\n            if(closestLeft < i) closestLeft = INF; // closestLeft does not exist if it\\'s behind the domino because it can never push it\\n            \\n            if(d[i] == \\'R\\') closestRight = i; // do this before checking if it\\'s a \\'.\\' because it might mistakenly update it\\n            else if(d[i] == \\'L\\') closestRight = INF;\\n    \\n            if(d[i] == \\'.\\'){\\n                if(abs(closestLeft-i) < abs(closestRight-i)) d[i] = \\'L\\'; // left is closer in absolute distance so it will reach this domino first\\n                else if(abs(closestLeft-i) > abs(closestRight-i)) d[i] = \\'R\\'; // right is closer in absolute distance so it will reach this domino first \\n            }\\n        }\\n        return d;\\n    }",
                "solutionTags": [],
                "code": "The n^2 solution to this problem is easy but it was difficult for me to find a way to not do so much repeated work. I came up with this idea: \\nMaintain the position of the closest domino pointing RIGHT. If we encounter a left domino along the way, the position of the closest domino pointing right is INFINITY because the left cancels it out.\\n\\nLook for the closest domino pointing LEFT. We do this by iterating ahead of our current position. If there is a right domino along the way, the position of the closest domino opint left is INFINITY because the right cancels it out.\\nImportant: We only need to redo this step if closestLeft is BEHIND our current position, because if the closestLeft for i = 3 is index 9, it will also be the closest left for indices 4...8.\\n\\nNow we know the positions of our closest right and left dominos. So for any given \\'.\\', we just need to check the absolute distance from the closestLeft or closestRight domino and set it to that one. If they are equidistant, then we do not change the \\'.\\'.\\n\\n```\\n    string pushDominoes(string d) {\\n        const int INF = 10e5;\\n        int closestLeft = INF; // in front\\n        int closestRight = INF; // behind\\n        int j = 0;\\n        for(int i = 0; i < d.length(); i++){\\n            if(closestLeft <= i || (j <= i && closestLeft == INF)){ // find the closest left domino if it exists \\n                j = i;\\n                while(j < d.length()){ // dont redo calculation if closestleft is >= i because the answer remains the same\\n                        // do redo if closestleft <= i OR j <= i AND closestLeft = infinity\\n                        if(d[j] == \\'L\\'){\\n                            closestLeft = j;\\n                            break;\\n                        }\\n                        if(d[j] == \\'R\\'){\\n                            closestLeft = INF;\\n                            break;\\n                        }\\n                        j++;\\n                    }\\n            }\\n            if(closestLeft < i) closestLeft = INF; // closestLeft does not exist if it\\'s behind the domino because it can never push it\\n            \\n            if(d[i] == \\'R\\') closestRight = i; // do this before checking if it\\'s a \\'.\\' because it might mistakenly update it\\n            else if(d[i] == \\'L\\') closestRight = INF;\\n    \\n            if(d[i] == \\'.\\'){\\n                if(abs(closestLeft-i) < abs(closestRight-i)) d[i] = \\'L\\'; // left is closer in absolute distance so it will reach this domino first\\n                else if(abs(closestLeft-i) > abs(closestRight-i)) d[i] = \\'R\\'; // right is closer in absolute distance so it will reach this domino first \\n            }\\n        }\\n        return d;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2433602,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tstring pushDominoes(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tvector<int> l(n, 0), r;\\n\\t\\tint ct = 0;\\n\\t\\tfor (auto &e : s) {\\n\\t\\t\\tif (e == \\'R\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'L\\') ct = 0;\\n\\t\\t\\tr.push_back(ct);\\n\\t\\t}\\n\\t\\tfor (int i = n - 1; i >= 0; --i) {\\n\\t\\t\\tchar e = s[i];\\n\\t\\t\\tif (e == \\'L\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'R\\') ct = 0;\\n\\t\\t\\tl[i] = ct;\\n\\t\\t}\\n\\t\\tstring ans;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (s[i] == \\'.\\') {\\n\\t\\t\\t\\tif (l[i] == r[i]) ans.push_back(\\'.\\');\\n\\t\\t\\t\\telse if (l[i] == 0) ans.push_back(\\'R\\');\\n\\t\\t\\t\\telse if (r[i] == 0) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse if (l[i] < r[i]) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse  ans.push_back(\\'R\\');\\n\\t\\t\\t}\\n\\t\\t\\telse ans.push_back(s[i]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring pushDominoes(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tvector<int> l(n, 0), r;\\n\\t\\tint ct = 0;\\n\\t\\tfor (auto &e : s) {\\n\\t\\t\\tif (e == \\'R\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'L\\') ct = 0;\\n\\t\\t\\tr.push_back(ct);\\n\\t\\t}\\n\\t\\tfor (int i = n - 1; i >= 0; --i) {\\n\\t\\t\\tchar e = s[i];\\n\\t\\t\\tif (e == \\'L\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'R\\') ct = 0;\\n\\t\\t\\tl[i] = ct;\\n\\t\\t}\\n\\t\\tstring ans;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (s[i] == \\'.\\') {\\n\\t\\t\\t\\tif (l[i] == r[i]) ans.push_back(\\'.\\');\\n\\t\\t\\t\\telse if (l[i] == 0) ans.push_back(\\'R\\');\\n\\t\\t\\t\\telse if (r[i] == 0) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse if (l[i] < r[i]) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse  ans.push_back(\\'R\\');\\n\\t\\t\\t}\\n\\t\\t\\telse ans.push_back(s[i]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404263,
                "title": "prefix-suffix-method-c-easiest-ace-solution",
                "content": "**\\n##  **********``**\\n \\n \\n string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n      vector<int> pre(n, 0);\\n      vector<int> suff(n, 0);\\n      \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'){\\n                for(int j=i+1; j<n; j++){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else pre[j]=pre[j-1]+1;\\n                }\\n            }\\n           \\n        }\\n        \\n          for(int i=n-1; i>=0; i--){\\n            if(dominoes[i]==\\'L\\'){\\n                for(int j=i-1; j>=0; j--){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else suff[j]=suff[j+1]+1;\\n                }\\n            }\\n           \\n        } \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\') continue;\\n          if((pre[i]==0&&suff[i]==0)||pre[i]==suff[i]) continue;\\n            \\n            if(pre[i]!=0&&suff[i]!=0){\\n                if(pre[i]>suff[i]) dominoes[i]=\\'L\\';\\n                if(pre[i]<suff[i]) dominoes[i]=\\'R\\';\\n                else continue;\\n            }\\n            else{\\n                \\n              if(pre[i]==0) dominoes[i]=\\'L\\';\\n                else{\\n                    dominoes[i]=\\'R\\';\\n                }\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "**\\n##  **********``**\\n \\n \\n string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n      vector<int> pre(n, 0);\\n      vector<int> suff(n, 0);\\n      \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'){\\n                for(int j=i+1; j<n; j++){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else pre[j]=pre[j-1]+1;\\n                }\\n            }\\n           \\n        }\\n        \\n          for(int i=n-1; i>=0; i--){\\n            if(dominoes[i]==\\'L\\'){\\n                for(int j=i-1; j>=0; j--){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else suff[j]=suff[j+1]+1;\\n                }\\n            }\\n           \\n        } \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\') continue;\\n          if((pre[i]==0&&suff[i]==0)||pre[i]==suff[i]) continue;\\n            \\n            if(pre[i]!=0&&suff[i]!=0){\\n                if(pre[i]>suff[i]) dominoes[i]=\\'L\\';\\n                if(pre[i]<suff[i]) dominoes[i]=\\'R\\';\\n                else continue;\\n            }\\n            else{\\n                \\n              if(pre[i]==0) dominoes[i]=\\'L\\';\\n                else{\\n                    dominoes[i]=\\'R\\';\\n                }\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2394442,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dom: str) -> str:\\n        from collections import deque\\n        n = len(dom)\\n        d = set()\\n        q = deque()\\n        arr = [0 for i in range(n)]\\n        for i in range(n):\\n            if dom[i] == \"L\":\\n                arr[i] = -1\\n                d.add(i)\\n                q.append((i,\"L\"))\\n            if dom[i] == \"R\":\\n                arr[i] = 1\\n                d.add(i)\\n                q.append((i,\"R\"))\\n        while q:\\n            t1 = set()\\n            for _ in range(len(q)):\\n                t = q.popleft()\\n                if t[1] == \"L\":\\n                    if t[0]-1 >= 0 and t[0]-1 not in d:\\n                        t1.add(t[0]-1)\\n                        arr[t[0]-1] -= 1\\n                else:\\n                    if t[0]+1 < n and t[0]+1 not in d:\\n                        t1.add(t[0]+1)\\n                        arr[t[0]+1] += 1\\n            for val in t1:\\n                d.add(val)\\n                if arr[val] > 0:\\n                    q.append((val,\"R\"))\\n                elif arr[val]<0:\\n                    q.append((val,\"L\"))\\n        ans = \"\"\\n        for val in arr:\\n            if val<0:\\n                ans += \"L\"\\n            elif val>0:\\n                ans += \"R\"\\n            else:\\n                ans += \".\"\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dom: str) -> str:\\n        from collections import deque\\n        n = len(dom)\\n        d = set()\\n        q = deque()\\n        arr = [0 for i in range(n)]\\n        for i in range(n):\\n            if dom[i] == \"L\":\\n                arr[i] = -1\\n                d.add(i)\\n                q.append((i,\"L\"))\\n            if dom[i] == \"R\":\\n                arr[i] = 1\\n                d.add(i)\\n                q.append((i,\"R\"))\\n        while q:\\n            t1 = set()\\n            for _ in range(len(q)):\\n                t = q.popleft()\\n                if t[1] == \"L\":\\n                    if t[0]-1 >= 0 and t[0]-1 not in d:\\n                        t1.add(t[0]-1)\\n                        arr[t[0]-1] -= 1\\n                else:\\n                    if t[0]+1 < n and t[0]+1 not in d:\\n                        t1.add(t[0]+1)\\n                        arr[t[0]+1] += 1\\n            for val in t1:\\n                d.add(val)\\n                if arr[val] > 0:\\n                    q.append((val,\"R\"))\\n                elif arr[val]<0:\\n                    q.append((val,\"L\"))\\n        ans = \"\"\\n        for val in arr:\\n            if val<0:\\n                ans += \"L\"\\n            elif val>0:\\n                ans += \"R\"\\n            else:\\n                ans += \".\"\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375230,
                "title": "c-easy-and-understanding-solution",
                "content": "```\\npublic class Solution {\\n    public string PushDominoes(string dominoes) {\\n        char[] elements = dominoes.ToCharArray();\\n        int length = elements.Length;\\n        int[] forces = new int[length];\\n        \\n        int force = 0;\\n        for(int i = 0; i < length; i++) {\\n            if(elements[i] == \\'R\\') {\\n                force = length;\\n            } else if(elements[i] == \\'L\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] += force;\\n        }\\n        \\n        force = 0;\\n        for(int i = length - 1; i >= 0; i--) {\\n            if(elements[i] == \\'L\\') {\\n                force = length;\\n            } else if(elements[i] == \\'R\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] -= force;\\n        }\\n        \\n        StringBuilder builder = new StringBuilder();\\n        foreach(int f in forces) {\\n            if(f > 0) {\\n                builder.Append(\\'R\\');\\n            } else if(f < 0) {\\n                builder.Append(\\'L\\');\\n            } else {\\n                builder.Append(\\'.\\');\\n            }\\n        }\\n        \\n        return builder.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string PushDominoes(string dominoes) {\\n        char[] elements = dominoes.ToCharArray();\\n        int length = elements.Length;\\n        int[] forces = new int[length];\\n        \\n        int force = 0;\\n        for(int i = 0; i < length; i++) {\\n            if(elements[i] == \\'R\\') {\\n                force = length;\\n            } else if(elements[i] == \\'L\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] += force;\\n        }\\n        \\n        force = 0;\\n        for(int i = length - 1; i >= 0; i--) {\\n            if(elements[i] == \\'L\\') {\\n                force = length;\\n            } else if(elements[i] == \\'R\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] -= force;\\n        }\\n        \\n        StringBuilder builder = new StringBuilder();\\n        foreach(int f in forces) {\\n            if(f > 0) {\\n                builder.Append(\\'R\\');\\n            } else if(f < 0) {\\n                builder.Append(\\'L\\');\\n            } else {\\n                builder.Append(\\'.\\');\\n            }\\n        }\\n        \\n        return builder.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315751,
                "title": "c-easy-to-understand-shitty-code-two-pointers-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n=d.size();\\n        int i=0;\\n        int j=0;\\n        string s(n,\\'.\\');\\n        if(d==s)\\n        return d;\\n        while(j<n)\\n        {\\n            if(d[j]==\\'.\\')\\n            {\\n                i=j;\\n                while(j<n&&d[j]==\\'.\\')\\n                {\\n                    j++;\\n                }\\n        \\n                if(i==0)\\n                {\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else if(j==n)\\n                {\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    if(d[j]==\\'L\\'&&d[i-1]==\\'R\\')\\n                    {\\n                        int len=j-(i-1)+1;\\n                        if(len%2==0)\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            }\\n                        }\\n                        else\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            } \\n                        }\\n                    }\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            j++;\\n        }\\n        return d;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n=d.size();\\n        int i=0;\\n        int j=0;\\n        string s(n,\\'.\\');\\n        if(d==s)\\n        return d;\\n        while(j<n)\\n        {\\n            if(d[j]==\\'.\\')\\n            {\\n                i=j;\\n                while(j<n&&d[j]==\\'.\\')\\n                {\\n                    j++;\\n                }\\n        \\n                if(i==0)\\n                {\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else if(j==n)\\n                {\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    if(d[j]==\\'L\\'&&d[i-1]==\\'R\\')\\n                    {\\n                        int len=j-(i-1)+1;\\n                        if(len%2==0)\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            }\\n                        }\\n                        else\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            } \\n                        }\\n                    }\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            j++;\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241066,
                "title": "easy-to-understand-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        //now what to do\\n        queue<int> q;\\n        for(int i=0;i<d.size();i++)\\n            if(d[i]!=\\'.\\')q.push(i);\\n        \\n        //last updated\\n        while(!q.empty())\\n        {\\n            int size=q.size(),last=-2;\\n            while(size--)\\n            {\\n                char dir=d[q.front()];\\n                int nxt=(dir==\\'L\\')?q.front()-1:q.front()+1;\\n                q.pop();\\n                if(last==nxt&&dir!=d[nxt])//then update to .\\n                    d[nxt]=\\'.\\';\\n                else if(nxt>=0&&nxt<d.size()&&d[nxt]==\\'.\\')//then only we will update\\n                {\\n                    d[nxt]=dir;\\n                    q.push(nxt);\\n                    last=nxt;\\n                }\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        //now what to do\\n        queue<int> q;\\n        for(int i=0;i<d.size();i++)\\n            if(d[i]!=\\'.\\')q.push(i);\\n        \\n        //last updated\\n        while(!q.empty())\\n        {\\n            int size=q.size(),last=-2;\\n            while(size--)\\n            {\\n                char dir=d[q.front()];\\n                int nxt=(dir==\\'L\\')?q.front()-1:q.front()+1;\\n                q.pop();\\n                if(last==nxt&&dir!=d[nxt])//then update to .\\n                    d[nxt]=\\'.\\';\\n                else if(nxt>=0&&nxt<d.size()&&d[nxt]==\\'.\\')//then only we will update\\n                {\\n                    d[nxt]=dir;\\n                    q.push(nxt);\\n                    last=nxt;\\n                }\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988884,
                "title": "simple-multi-source-bfs-with-python",
                "content": "This problem has simple graph-based formulation. Let\\'s consider dominoes to be vertices where every pair of adjecent dominoes are connected with an edge. In such graph spread of falling dominoes can be viewed as breadth-first-search from multiple sources. The sources here are \\'L\\' or \\'R\\' - pushed dominoes.\\nAs we know, breadth-first-search explores all nodes at the present depth prior to moving on to the nodes at the next depth level. Extra memory used for queue (deque in Python), which is needed to keep track of the nodes that were encountered but not yet explored.\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        qq = deque() # BFS candidate queue\\n        mp = {\\'L\\': -1, \\'R\\': 1} # Define mapping from the letter to the search direction\\n        was = [0 for _ in range(len(dominoes))] # To mark visited nodes with depths\\n        res = list(dominoes)\\n        # Add to queue nodes with \\'L\\' or \\'R\\' as a sources\\n        for i, x in enumerate(dominoes): \\n            if x != \\'.\\':\\n                qq.append((i, 1, x))\\n                was[i] = -1\\n\\t\\t# BFS\\n        while qq: \\n            idx, depth, direction = qq.popleft()\\n            if idx < 0 or idx >= len(res): # Check whether the borders are exceeded\\n                continue\\n            if was[idx] == depth: # Check if this node is pushed from both sides\\n                res[idx] = \\'.\\'\\n            elif was[idx] <= 0: # Check if this node haven\\'t been visited\\n                was[idx] = depth\\n                qq.append((idx + mp[direction], depth + 1, direction))\\n                res[idx] = direction\\n        return \\'\\'.join(res)\\n```\\nThis solution has O(n) time complexity because each node is visited no more than 3 times (ones in for loop and at most twice in BFS). Also here we use O(n) extra memory for queue, depths and result.",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        qq = deque() # BFS candidate queue\\n        mp = {\\'L\\': -1, \\'R\\': 1} # Define mapping from the letter to the search direction\\n        was = [0 for _ in range(len(dominoes))] # To mark visited nodes with depths\\n        res = list(dominoes)\\n        # Add to queue nodes with \\'L\\' or \\'R\\' as a sources\\n        for i, x in enumerate(dominoes): \\n            if x != \\'.\\':\\n                qq.append((i, 1, x))\\n                was[i] = -1\\n\\t\\t# BFS\\n        while qq: \\n            idx, depth, direction = qq.popleft()\\n            if idx < 0 or idx >= len(res): # Check whether the borders are exceeded\\n                continue\\n            if was[idx] == depth: # Check if this node is pushed from both sides\\n                res[idx] = \\'.\\'\\n            elif was[idx] <= 0: # Check if this node haven\\'t been visited\\n                was[idx] = depth\\n                qq.append((idx + mp[direction], depth + 1, direction))\\n                res[idx] = direction\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932475,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] str = dominoes.toCharArray();\\n        int n = str.length;\\n        Queue<Pair> que = new LinkedList<>();\\n        for(int i = 0; i < n ; i++) \\n            if(str[i] != \\'.\\') que.add(new Pair(i, str[i]));\\n        \\n        while(!que.isEmpty()) {\\n            Pair rem = que.remove();\\n            if(rem.c == \\'L\\'){\\n                if(rem.i - 1 >= 0 && str[rem.i - 1] == \\'.\\') {\\n                    int nidx = rem.i - 1;\\n                    str[nidx] = \\'L\\';\\n                    que.add(new Pair(nidx, \\'L\\'));\\n                }\\n            } else {\\n                if(rem.i + 1 < n && str[rem.i + 1] == \\'.\\') {\\n                    if(rem.i + 2 < n && str[rem.i + 2] == \\'L\\') que.remove();\\n                    else {\\n                        int nidx = rem.i + 1;\\n                        str[nidx] = \\'R\\';\\n                        que.add(new Pair(nidx, \\'R\\'));\\n                    }\\n                }\\n            }\\n        }\\n        return new String(str);\\n    }\\n    \\n    class Pair {\\n        int i;\\n        char c;\\n        Pair(int i, char c) {\\n            this.i = i;\\n            this.c = c;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] str = dominoes.toCharArray();\\n        int n = str.length;\\n        Queue<Pair> que = new LinkedList<>();\\n        for(int i = 0; i < n ; i++) \\n            if(str[i] != \\'.\\') que.add(new Pair(i, str[i]));\\n        \\n        while(!que.isEmpty()) {\\n            Pair rem = que.remove();\\n            if(rem.c == \\'L\\'){\\n                if(rem.i - 1 >= 0 && str[rem.i - 1] == \\'.\\') {\\n                    int nidx = rem.i - 1;\\n                    str[nidx] = \\'L\\';\\n                    que.add(new Pair(nidx, \\'L\\'));\\n                }\\n            } else {\\n                if(rem.i + 1 < n && str[rem.i + 1] == \\'.\\') {\\n                    if(rem.i + 2 < n && str[rem.i + 2] == \\'L\\') que.remove();\\n                    else {\\n                        int nidx = rem.i + 1;\\n                        str[nidx] = \\'R\\';\\n                        que.add(new Pair(nidx, \\'R\\'));\\n                    }\\n                }\\n            }\\n        }\\n        return new String(str);\\n    }\\n    \\n    class Pair {\\n        int i;\\n        char c;\\n        Pair(int i, char c) {\\n            this.i = i;\\n            this.c = c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788135,
                "title": "java-easy-approach-with-comments",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String d) {\\n        int n = d.length();\\n        char[] arr = new char[n+2];//+2 as we will placed a dummy domino L on left and R on right\\n        arr[0] = \\'L\\';\\n        arr[arr.length-1] = \\'R\\';\\n        \\n        for(int i = 1; i < arr.length-1 ; i++){\\n            arr[i] = d.charAt(i-1);//as we put 1 and last so we start from 1 but char is at 0 so i-1    \\n        }\\n        \\n        int i = 0 , j = 1;//using two pointers we will find the posn for the pairs of dominoes\\n        while(j < arr.length){\\n            while(arr[j] == \\'.\\') \\n                j++;//till we found a L Or R move j ahead\\n            if(j - i > 1){\\n                solve(arr, i , j);//after finding it pass the index of it and its pair means i\\n            }\\n            i = j;//i will become j as its L|R\\n            j++;//and j againg will go in search for its pair\\n        }\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t//As first one was dummy just to make pairing and same for the last one so skip them in main ans\\n        for(int k = 1;k < arr.length-1; k++){\\n            sb.append(arr[k]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    \\n    private void solve(char[] arr , int i , int j){\\n        //#1 when there is L ... L then all in between will be L only \\\\\\\\\\\\\\\\\\\\\\n        if(arr[i] == \\'L\\' && arr[j] == \\'L\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'L\\';\\n            }\\n        }\\n        \\n        //#2 when there is R ... R then all in between will be R only /////\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'R\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'R\\';\\n            }\\n        }\\n        \\n        //#3 when there is L....R then both will not affect in bet as \\\\...../\\n        else if(arr[i] == \\'L\\' && arr[j] == \\'R\\'){\\n            //do nothing and chill\\n        }\\n        \\n        //#4 when there is R....L then two more cases as\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'L\\'){\\n            int diff = j - i;//the space in between those two\\n            int mid = (i + j) / 2;\\n            if(diff % 2 == 0){//if diff is even then R ... L r at 2and l at 6 then 6-2=4 so RR.LL //|\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k < mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k == mid){\\n                        //do nothing\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(diff % 2 != 0){//if diff is odd then R .... L r at 2and l at 7 then 7-2=5 so RRRLLL ///\\\\\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k <= mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String d) {\\n        int n = d.length();\\n        char[] arr = new char[n+2];//+2 as we will placed a dummy domino L on left and R on right\\n        arr[0] = \\'L\\';\\n        arr[arr.length-1] = \\'R\\';\\n        \\n        for(int i = 1; i < arr.length-1 ; i++){\\n            arr[i] = d.charAt(i-1);//as we put 1 and last so we start from 1 but char is at 0 so i-1    \\n        }\\n        \\n        int i = 0 , j = 1;//using two pointers we will find the posn for the pairs of dominoes\\n        while(j < arr.length){\\n            while(arr[j] == \\'.\\') \\n                j++;//till we found a L Or R move j ahead\\n            if(j - i > 1){\\n                solve(arr, i , j);//after finding it pass the index of it and its pair means i\\n            }\\n            i = j;//i will become j as its L|R\\n            j++;//and j againg will go in search for its pair\\n        }\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t//As first one was dummy just to make pairing and same for the last one so skip them in main ans\\n        for(int k = 1;k < arr.length-1; k++){\\n            sb.append(arr[k]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    \\n    private void solve(char[] arr , int i , int j){\\n        //#1 when there is L ... L then all in between will be L only \\\\\\\\\\\\\\\\\\\\\\n        if(arr[i] == \\'L\\' && arr[j] == \\'L\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'L\\';\\n            }\\n        }\\n        \\n        //#2 when there is R ... R then all in between will be R only /////\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'R\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'R\\';\\n            }\\n        }\\n        \\n        //#3 when there is L....R then both will not affect in bet as \\\\...../\\n        else if(arr[i] == \\'L\\' && arr[j] == \\'R\\'){\\n            //do nothing and chill\\n        }\\n        \\n        //#4 when there is R....L then two more cases as\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'L\\'){\\n            int diff = j - i;//the space in between those two\\n            int mid = (i + j) / 2;\\n            if(diff % 2 == 0){//if diff is even then R ... L r at 2and l at 6 then 6-2=4 so RR.LL //|\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k < mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k == mid){\\n                        //do nothing\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(diff % 2 != 0){//if diff is odd then R .... L r at 2and l at 7 then 7-2=5 so RRRLLL ///\\\\\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k <= mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787549,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] ch = dominoes.toCharArray();\\n        //pos, power, time\\n        int len = ch.length;\\n        //\\u4EE3\\u8868\\u53D7\\u529B\\u65F6\\u95F4\\n        int[] time = new int[len];\\n\\n        //\\u4EE3\\u8868\\u6700\\u65B0\\u72B6\\u6001\\n        // char[] update = new char[len];\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n\\n        for(int i = 0; i < len; i ++){\\n            if(ch[i] == \\'.\\')\\n                continue;\\n            int dir = (ch[i] == \\'L\\') ? -1 : 1;\\n            queue.offer(new int[]{i, dir, 1});\\n            time[i] = 1;\\n        }\\n\\n        while(! queue.isEmpty()){\\n            //\\u6BCF\\u4E00\\u8F6E--> \\u4E00\\u4E2A\\u65F6\\u95F4\\u70B9time\\n            int[] info = queue.poll();\\n            int pos = info[0];\\n            int dir = info[1];\\n            int hour = info[2];\\n\\n            int npos = pos + dir;\\n            if((ch[pos] == \\'.\\') || npos < 0 || npos > len - 1)\\n               continue;\\n\\n            //\\u5224\\u65AD\\u662F\\u5426\\u9996\\u6B21\\u53D7\\u529B\\n            if(time[npos] == 0){\\n                time[npos] = hour + 1;\\n                ch[npos] = ((dir == -1) ? \\'L\\' : \\'R\\');\\n                queue.offer(new int[]{npos, dir, hour + 1});\\n            }else if(time[npos] == hour + 1){\\n                ch[npos] = \\'.\\';\\n            }\\n            \\n        }\\n\\n        // return new String(update);\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] ch = dominoes.toCharArray();\\n        //pos, power, time\\n        int len = ch.length;\\n        //\\u4EE3\\u8868\\u53D7\\u529B\\u65F6\\u95F4\\n        int[] time = new int[len];\\n\\n        //\\u4EE3\\u8868\\u6700\\u65B0\\u72B6\\u6001\\n        // char[] update = new char[len];\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n\\n        for(int i = 0; i < len; i ++){\\n            if(ch[i] == \\'.\\')\\n                continue;\\n            int dir = (ch[i] == \\'L\\') ? -1 : 1;\\n            queue.offer(new int[]{i, dir, 1});\\n            time[i] = 1;\\n        }\\n\\n        while(! queue.isEmpty()){\\n            //\\u6BCF\\u4E00\\u8F6E--> \\u4E00\\u4E2A\\u65F6\\u95F4\\u70B9time\\n            int[] info = queue.poll();\\n            int pos = info[0];\\n            int dir = info[1];\\n            int hour = info[2];\\n\\n            int npos = pos + dir;\\n            if((ch[pos] == \\'.\\') || npos < 0 || npos > len - 1)\\n               continue;\\n\\n            //\\u5224\\u65AD\\u662F\\u5426\\u9996\\u6B21\\u53D7\\u529B\\n            if(time[npos] == 0){\\n                time[npos] = hour + 1;\\n                ch[npos] = ((dir == -1) ? \\'L\\' : \\'R\\');\\n                queue.offer(new int[]{npos, dir, hour + 1});\\n            }else if(time[npos] == hour + 1){\\n                ch[npos] = \\'.\\';\\n            }\\n            \\n        }\\n\\n        // return new String(update);\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772330,
                "title": "c-bfs-dp-o-n",
                "content": "**Idea**\\nFinal state of a domino depends upon the time of `left` and `right` force applied on it.\\n* if time of left force <time of right force, then state of that domino will be `L`\\n* if time of left force >time of right force, then state of that domino will be `R`\\n* if time of left force = time of right force **(balanced state)**, then state of that domino will be `.`\\n\\nThis can be done using bfs.\\n**Time complexity**: O(n) , **Space complexity**: O(n)\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        vector<bool> vis(s.size(),0); // to track the processed indices\\n        vector<int> left(s.size(),INT_MAX);  // to store time of left force on index i\\n        vector<int> right(s.size(),INT_MAX);  // to store time of right force on index i\\n        queue<int> q;  // to store the under process indices\\n        \\n        for(int i = 0; i<s.size();++i){  // initialize all the initial state of\\n            if(s[i]==\\'L\\'){               //  left and right with time 0\\n               q.push(i); vis[i] = 1; left[i] = 0;\\n            }\\n            if(s[i]==\\'R\\'){\\n               q.push(i); vis[i] = 1; right[i] = 0;\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int t = q.size();\\n            while(t--){\\n                int i = q.front(); q.pop();\\n                if(left[i]<right[i]){\\n                    s[i]=\\'L\\'; \\n                    if(i-1>=0){  // state \\'L\\' will always push its previous index to left\\n                        left[i-1]=min(left[i]+1,left[i-1]);  // store the min time of left force\\n                        if(vis[i-1]==0){\\n                            vis[i-1]=1; q.push(i-1);\\n                        }\\n                    }\\n                }\\n                else if(right[i]<left[i]){ \\n                    s[i]=\\'R\\';\\n                    if(i+1<s.size()){   // state \\'R\\' will always push its next index to right\\n                        right[i+1] = min(right[i]+1,right[i+1]);   // store the min time of right force\\n                        if(vis[i+1]==0){\\n                            vis[i+1]=1; q.push(i+1);\\n                        }\\n                    }\\n                }\\n                else s[i]=\\'.\\';\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        vector<bool> vis(s.size(),0); // to track the processed indices\\n        vector<int> left(s.size(),INT_MAX);  // to store time of left force on index i\\n        vector<int> right(s.size(),INT_MAX);  // to store time of right force on index i\\n        queue<int> q;  // to store the under process indices\\n        \\n        for(int i = 0; i<s.size();++i){  // initialize all the initial state of\\n            if(s[i]==\\'L\\'){               //  left and right with time 0\\n               q.push(i); vis[i] = 1; left[i] = 0;\\n            }\\n            if(s[i]==\\'R\\'){\\n               q.push(i); vis[i] = 1; right[i] = 0;\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int t = q.size();\\n            while(t--){\\n                int i = q.front(); q.pop();\\n                if(left[i]<right[i]){\\n                    s[i]=\\'L\\'; \\n                    if(i-1>=0){  // state \\'L\\' will always push its previous index to left\\n                        left[i-1]=min(left[i]+1,left[i-1]);  // store the min time of left force\\n                        if(vis[i-1]==0){\\n                            vis[i-1]=1; q.push(i-1);\\n                        }\\n                    }\\n                }\\n                else if(right[i]<left[i]){ \\n                    s[i]=\\'R\\';\\n                    if(i+1<s.size()){   // state \\'R\\' will always push its next index to right\\n                        right[i+1] = min(right[i]+1,right[i+1]);   // store the min time of right force\\n                        if(vis[i+1]==0){\\n                            vis[i+1]=1; q.push(i+1);\\n                        }\\n                    }\\n                }\\n                else s[i]=\\'.\\';\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706706,
                "title": "python-o-n-with-detailed-comments-explaining",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = [[position, 1] for position in dominoes] #form = [[falling direction, seconds needed to fall]]\\n            #R means its already falling to right \\n            #L means its already falling to left\\n            #r means its standing still but the dominoe next to it is potentially falling to right\\n            #we need r because when there is dominoes falling from left this r may be changed to L or .\\n            #it will be changed to . if the dominoe falling to L is as far from it as the domnoe falling to right\\n            #it will be changed to L if the dominoe falling to L is closer to it than the one falling to right\\n            #by closer we mean it takes less seconds\\n            #the array we are keeping stores seconds needed for each dominoe to fall to a direction\\n            #in the case of . the seconds are trash meaning we don\\'t really care about them\\n            #in the end we change all dominoes with r to R\\n            #NOTE: this code may be simplified but i am lazy to simplify it :P\\n\\t\\t\\t\\n        for right in range(0,len(dominoes) - 1):\\n            next_direction, next_seconds = arr[right + 1]\\n            curr_direction, curr_seconds = arr[right]\\n            if curr_direction in (\"R\", \"r\") and next_direction == \".\":\\n                arr[right + 1] = [\\'r\\', curr_seconds + 1]\\n        \\n        for left in range(len(dominoes) - 1, 0, -1):\\n            next_direction, next_seconds = arr[left - 1]\\n            curr_direction, curr_seconds = arr[left]\\n            if curr_direction in (\"L\", \\'l\\'):\\n                if next_direction == \\'.\\':\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 < next_seconds:\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 == next_seconds:\\n                    arr[left - 1] = [\\'.\\', 1]\\n        res = \\'\\'\\n        for i in range(0,len(arr)):\\n            direction = arr[i][0]\\n            if direction == \"r\":\\n                res += \"R\"\\n            else:\\n                res += direction\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = [[position, 1] for position in dominoes] #form = [[falling direction, seconds needed to fall]]\\n            #R means its already falling to right \\n            #L means its already falling to left\\n            #r means its standing still but the dominoe next to it is potentially falling to right\\n            #we need r because when there is dominoes falling from left this r may be changed to L or .\\n            #it will be changed to . if the dominoe falling to L is as far from it as the domnoe falling to right\\n            #it will be changed to L if the dominoe falling to L is closer to it than the one falling to right\\n            #by closer we mean it takes less seconds\\n            #the array we are keeping stores seconds needed for each dominoe to fall to a direction\\n            #in the case of . the seconds are trash meaning we don\\'t really care about them\\n            #in the end we change all dominoes with r to R\\n            #NOTE: this code may be simplified but i am lazy to simplify it :P\\n\\t\\t\\t\\n        for right in range(0,len(dominoes) - 1):\\n            next_direction, next_seconds = arr[right + 1]\\n            curr_direction, curr_seconds = arr[right]\\n            if curr_direction in (\"R\", \"r\") and next_direction == \".\":\\n                arr[right + 1] = [\\'r\\', curr_seconds + 1]\\n        \\n        for left in range(len(dominoes) - 1, 0, -1):\\n            next_direction, next_seconds = arr[left - 1]\\n            curr_direction, curr_seconds = arr[left]\\n            if curr_direction in (\"L\", \\'l\\'):\\n                if next_direction == \\'.\\':\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 < next_seconds:\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 == next_seconds:\\n                    arr[left - 1] = [\\'.\\', 1]\\n        res = \\'\\'\\n        for i in range(0,len(arr)):\\n            direction = arr[i][0]\\n            if direction == \"r\":\\n                res += \"R\"\\n            else:\\n                res += direction\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656430,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        //method 2 based on distance\\n        int n=dominoes.size();\\n        vector<int> right(n,INT_MAX),left(n,INT_MAX);\\n        \\n        //fill right\\n        if(dominoes[0]==\\'R\\') right[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\') continue;\\n            else if(dominoes[i]==\\'R\\') right[i]=0;\\n            else if(right[i-1]!=INT_MAX) right[i]=right[i-1]+1;\\n            else right[i]=INT_MAX;\\n        }\\n        //fill left\\n        if(dominoes[n-1]==\\'L\\') left[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\') continue;\\n            else if(dominoes[i]==\\'L\\') left[i]=0;\\n            else if(left[i+1]!=INT_MAX) left[i]=left[i+1]+1;\\n            else left[i]=INT_MAX;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]!=right[i])\\n            {\\n                dominoes[i]=left[i]<right[i]?\\'L\\':\\'R\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        //method 2 based on distance\\n        int n=dominoes.size();\\n        vector<int> right(n,INT_MAX),left(n,INT_MAX);\\n        \\n        //fill right\\n        if(dominoes[0]==\\'R\\') right[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\') continue;\\n            else if(dominoes[i]==\\'R\\') right[i]=0;\\n            else if(right[i-1]!=INT_MAX) right[i]=right[i-1]+1;\\n            else right[i]=INT_MAX;\\n        }\\n        //fill left\\n        if(dominoes[n-1]==\\'L\\') left[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\') continue;\\n            else if(dominoes[i]==\\'L\\') left[i]=0;\\n            else if(left[i+1]!=INT_MAX) left[i]=left[i+1]+1;\\n            else left[i]=INT_MAX;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]!=right[i])\\n            {\\n                dominoes[i]=left[i]<right[i]?\\'L\\':\\'R\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415904,
                "title": "easy-c-faster-than-97-algorithm",
                "content": "Algorithm:\\n\\nOnly four cases:\\n\\nAny character can be between\\n1. \"L\" and \"L\"  --> All in betweens would be \"L\" too.\\n2. \"L\" and \"R\"  --> All from [L, R] would remain as it is(no effect)\\n3. \"R\" and \"L\" --> would depend either the number of dots between are even or odd, iff even then half R\\'s would come and half L\\'s would come, iff odd then half R\\'s followed by a dot and half L\\'s. (I have taken one less L than half because it would be taken care of in one of other 3 cases).\\n4. \"R\" and \"R\"  --> All in betweens would be \"R\" too.\\n\\n\\texcept for those which are in beginning or end, for those explicitly add one \"L\" at beginnig and one \"R\" at end, because they are not gonna make any difference and we won\\'t need to handle that case explicitly.\\n\\tFinally remove first char and last char which we added and return the string.\\n\\t\\n\\tCode: \\n\\t\\n\\t\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n    string pushDominoes(string dominoes) {\\n        string helper = \"L\" + dominoes + \"R\";\\n        int lo = 0, hi = 1;\\n        string ans = \"\";\\n        while(hi <= helper.length()){\\n            bool flag = true;\\n            while(helper[hi] == \\'.\\'){\\n                hi++;\\n                if(hi == helper.length()){\\n                    break;\\n                }\\n            }\\n            if(hi == helper.length()){\\n                break;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'L\\'){\\n                while(lo < hi){\\n                    ans += \\'L\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += helper[lo];\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += \\'R\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'L\\'){\\n                int count = 0;\\n                while(lo <= hi){\\n                    count++;\\n                    lo++;\\n                }\\n                flag = false;\\n                if(count % 2 == 0){\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                } else {\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    ans += \\'.\\';\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                }\\n                lo--;\\n                hi++;\\n            }\\n        }\\n        \\n        return ans.substr(1, ans.length()-1); \\n        \\n    }\\n\\t};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\n\\tpublic:\\n    string pushDominoes(string dominoes) {\\n        string helper = \"L\" + dominoes + \"R\";\\n        int lo = 0, hi = 1;\\n        string ans = \"\";\\n        while(hi <= helper.length()){\\n            bool flag = true;\\n            while(helper[hi] == \\'.\\'){\\n                hi++;\\n                if(hi == helper.length()){\\n                    break;\\n                }\\n            }\\n            if(hi == helper.length()){\\n                break;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'L\\'){\\n                while(lo < hi){\\n                    ans += \\'L\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += helper[lo];\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += \\'R\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'L\\'){\\n                int count = 0;\\n                while(lo <= hi){\\n                    count++;\\n                    lo++;\\n                }\\n                flag = false;\\n                if(count % 2 == 0){\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                } else {\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    ans += \\'.\\';\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                }\\n                lo--;\\n                hi++;\\n            }\\n        }\\n        \\n        return ans.substr(1, ans.length()-1); \\n        \\n    }\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380406,
                "title": "solved-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string mainstr=dominoes;\\n        int n=dominoes.length();\\n        queue<int>q;\\n        for(int i=0;i<dominoes.length();i++)\\n        {  \\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\')\\n            {q.push(i);}\\n        }\\n        \\n        while(!q.empty())\\n        {\\n           \\n            int size=q.size();\\n            string str=mainstr;\\n            while(size)\\n            {\\n                size--;\\n                int ind=q.front();\\n                q.pop();\\n               if(mainstr[ind]==\\'L\\')\\n               {\\n                   int index=ind-1;\\n                   if(index>=0&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index-1<0||mainstr[index-1]!=\\'R\\'){str[index]=\\'L\\';q.push(index);}\\n                       \\n                   }\\n                       \\n               }\\n            else\\n            {\\n                 int index=ind+1;\\n                   if(index<n&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index+1>=n||mainstr[index+1]!=\\'L\\'){str[index]=\\'R\\';q.push(index);}\\n                       \\n                   }\\n            }\\n                \\n              \\n                \\n            }\\n            mainstr=str;\\n        }\\n        return mainstr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string mainstr=dominoes;\\n        int n=dominoes.length();\\n        queue<int>q;\\n        for(int i=0;i<dominoes.length();i++)\\n        {  \\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\')\\n            {q.push(i);}\\n        }\\n        \\n        while(!q.empty())\\n        {\\n           \\n            int size=q.size();\\n            string str=mainstr;\\n            while(size)\\n            {\\n                size--;\\n                int ind=q.front();\\n                q.pop();\\n               if(mainstr[ind]==\\'L\\')\\n               {\\n                   int index=ind-1;\\n                   if(index>=0&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index-1<0||mainstr[index-1]!=\\'R\\'){str[index]=\\'L\\';q.push(index);}\\n                       \\n                   }\\n                       \\n               }\\n            else\\n            {\\n                 int index=ind+1;\\n                   if(index<n&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index+1>=n||mainstr[index+1]!=\\'L\\'){str[index]=\\'R\\';q.push(index);}\\n                       \\n                   }\\n            }\\n                \\n              \\n                \\n            }\\n            mainstr=str;\\n        }\\n        return mainstr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356829,
                "title": "c-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int N = dominoes.size();\\n        queue<int> todo;\\n        vector<int> fallLevel(N, -1);\\n        // Get currently falling dominoes\\n        for (int i = 0; i < N; i++) {\\n            if (dominoes[i] != \\'.\\') {\\n                todo.push(i); // { index, fall level }\\n                fallLevel[i] = 0; // { fall level }\\n            }\\n        }\\n        \\n        while (!todo.empty()) {\\n            int curIndex = todo.front();\\n            todo.pop();\\n            if (dominoes[curIndex] == \\'L\\') {\\n                if (isStatic(curIndex - 1, N, dominoes)) {\\n                    todo.push( curIndex - 1 );\\n                    dominoes[curIndex - 1] = \\'L\\';\\n                    fallLevel[curIndex - 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n            else if (dominoes[curIndex] == \\'R\\') {\\n                if (isStatic(curIndex + 1, N, dominoes)) {\\n                    todo.push( curIndex + 1 );\\n                    dominoes[curIndex + 1] = \\'R\\';\\n                    fallLevel[curIndex + 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n        }\\n        \\n        // Last pass for middle dominoes\\n        for (int i = 1; i < N - 1; i++) {\\n            if (fallLevel[i - 1] == fallLevel[i + 1] && fallLevel[i] != 0 && dominoes[i - 1] != dominoes[i + 1]) {\\n                dominoes[i] = \\'.\\';\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n    \\n    bool isStatic(int index, int &N, string &dominoes) {\\n        if (index < 0 || index >= N || dominoes[index] != \\'.\\') {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int N = dominoes.size();\\n        queue<int> todo;\\n        vector<int> fallLevel(N, -1);\\n        // Get currently falling dominoes\\n        for (int i = 0; i < N; i++) {\\n            if (dominoes[i] != \\'.\\') {\\n                todo.push(i); // { index, fall level }\\n                fallLevel[i] = 0; // { fall level }\\n            }\\n        }\\n        \\n        while (!todo.empty()) {\\n            int curIndex = todo.front();\\n            todo.pop();\\n            if (dominoes[curIndex] == \\'L\\') {\\n                if (isStatic(curIndex - 1, N, dominoes)) {\\n                    todo.push( curIndex - 1 );\\n                    dominoes[curIndex - 1] = \\'L\\';\\n                    fallLevel[curIndex - 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n            else if (dominoes[curIndex] == \\'R\\') {\\n                if (isStatic(curIndex + 1, N, dominoes)) {\\n                    todo.push( curIndex + 1 );\\n                    dominoes[curIndex + 1] = \\'R\\';\\n                    fallLevel[curIndex + 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n        }\\n        \\n        // Last pass for middle dominoes\\n        for (int i = 1; i < N - 1; i++) {\\n            if (fallLevel[i - 1] == fallLevel[i + 1] && fallLevel[i] != 0 && dominoes[i - 1] != dominoes[i + 1]) {\\n                dominoes[i] = \\'.\\';\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n    \\n    bool isStatic(int index, int &N, string &dominoes) {\\n        if (index < 0 || index >= N || dominoes[index] != \\'.\\') {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354143,
                "title": "java-simple-and-easy-to-understand-solution-t-o-n-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1790122,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            },
            {
                "id": 1572223,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            },
            {
                "id": 2077061,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            },
            {
                "id": 2053538,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Vowels Permutation",
        "question_content": "<p>Given an integer <code>n</code>, your task is to count how many strings of length <code>n</code> can be formed under the following rules:</p>\n\n<ul>\n\t<li>Each character is a lower case vowel&nbsp;(<code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;u&#39;</code>)</li>\n\t<li>Each vowel&nbsp;<code>&#39;a&#39;</code> may only be followed by an <code>&#39;e&#39;</code>.</li>\n\t<li>Each vowel&nbsp;<code>&#39;e&#39;</code> may only be followed by an <code>&#39;a&#39;</code>&nbsp;or an <code>&#39;i&#39;</code>.</li>\n\t<li>Each vowel&nbsp;<code>&#39;i&#39;</code> <strong>may not</strong> be followed by another <code>&#39;i&#39;</code>.</li>\n\t<li>Each vowel&nbsp;<code>&#39;o&#39;</code> may only be followed by an <code>&#39;i&#39;</code> or a&nbsp;<code>&#39;u&#39;</code>.</li>\n\t<li>Each vowel&nbsp;<code>&#39;u&#39;</code> may only be followed by an <code>&#39;a&#39;.</code></li>\n</ul>\n\n<p>Since the answer&nbsp;may be too large,&nbsp;return it modulo <code>10^9 + 7.</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> All possible strings are: &quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; and &quot;u&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> All possible strings are: &quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; and &quot;ua&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:&nbsp;</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 68</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10^4</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 398222,
                "title": "detailed-explanation-using-graphs-with-pictures-o-n",
                "content": "# Intuition\\nLet us visualize this as a graph problem. From the above rules, we can create a directed graph where an edge between characters `first` and `second` imply that it is permissible to write `second` immediately after first. Hence, the question converts to, **Given a directed graph, how many paths of length `n` are there?** \\n\\n![image](https://assets.leetcode.com/users/just__a__visitor/image_1570334589.png)\\n\\nNow, Let us say that `dp[n][char]` denotes the number of directed paths of length `n` which end at a particular vertex `char`. Then, we know that the last vertex in our path was `char`. However, let\\'s focus on the last second vertex. It could have been any of the vertex which has a direct edge to `char`. Hence, if we can find the number of paths of length `n-1` ending at these vertices, then we can append `char` at the end of every path and we would have exhausted all possibilites.\\n\\nHence, `dp[n+1][x] = sum of all dp[n][y]` such that there is a directed edge from `y` to `x`. \\n\\n```cpp\\nclass Solution\\n{\\npublic:\\n    int countVowelPermutation(int n);\\n};\\n\\nint Solution :: countVowelPermutation(int n)\\n{\\n    vector<vector<long>> dp(n+1, vector<long>(5, 0));\\n    \\n    int MOD = 1e9 + 7;\\n    \\n    /* dp[i][j] denotes the number of valid strings of length i */\\n    \\n    for(int i = 0; i < 5; i++)\\n        dp[1][i] = 1;\\n    \\n    for(int i = 1; i < n; i++)\\n    {\\n        dp[i+1][0] = (dp[i][1] + dp[i][2] + dp[i][4]) %MOD;\\n        \\n        dp[i+1][1] = (dp[i][0] + dp[i][2]) % MOD;\\n        \\n        dp[i+1][2] = (dp[i][1] + dp[i][3]) % MOD;\\n        \\n        dp[i+1][3] = dp[i][2];\\n        \\n        dp[i+1][4] = (dp[i][2] + dp[i][3]) % MOD;\\n    }\\n    \\n    int res = 0;\\n    for(int i = 0; i < 5; i++)\\n        res = (res + dp[n][i]) % MOD;\\n    \\n    return res;\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution\\n{\\npublic:\\n    int countVowelPermutation(int n);\\n};\\n\\nint Solution :: countVowelPermutation(int n)\\n{\\n    vector<vector<long>> dp(n+1, vector<long>(5, 0));\\n    \\n    int MOD = 1e9 + 7;\\n    \\n    /* dp[i][j] denotes the number of valid strings of length i */\\n    \\n    for(int i = 0; i < 5; i++)\\n        dp[1][i] = 1;\\n    \\n    for(int i = 1; i < n; i++)\\n    {\\n        dp[i+1][0] = (dp[i][1] + dp[i][2] + dp[i][4]) %MOD;\\n        \\n        dp[i+1][1] = (dp[i][0] + dp[i][2]) % MOD;\\n        \\n        dp[i+1][2] = (dp[i][1] + dp[i][3]) % MOD;\\n        \\n        dp[i+1][3] = dp[i][2];\\n        \\n        dp[i+1][4] = (dp[i][2] + dp[i][3]) % MOD;\\n    }\\n    \\n    int res = 0;\\n    for(int i = 0; i < 5; i++)\\n        res = (res + dp[n][i]) % MOD;\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398286,
                "title": "simple-python-with-diagram",
                "content": "Each vowel allows some number of subsequent characters. These transitions are like a tree. This problem is asking, \"what\\'s the width of the tree with height *n*?\"\\n\\n![image](https://assets.leetcode.com/users/elliotp/image_1570334689.png)\\n\\nMy solution keeps track of the number of each vowel at a level in this tree. To calculate say \\'A\\', we calculate how many nodes in the previous level produce \\'A\\'. This is the number of \\'E\\', \\'I\\', and \\'U\\' nodes.\\n\\n```\\ndef count_vowel_permutations(n):\\n    a, e, i, o, u = 1, 1, 1, 1, 1\\n    for _ in range(n - 1):\\n        a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n    return (a + e + i + o + u) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\ndef count_vowel_permutations(n):\\n    a, e, i, o, u = 1, 1, 1, 1, 1\\n    for _ in range(n - 1):\\n        a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n    return (a + e + i + o + u) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2390275,
                "title": "c-clean-code-well-explained",
                "content": "Each vowel allows some number of subsequent characters. These transitions are like a tree. This problem is asking, \"what\\'s the width of the tree with height n?\"\\n\\n\\n![image](https://assets.leetcode.com/users/images/6423763e-0cb1-4ecd-af60-a979c08d01b7_1659839040.3599339.png)\\n\\nMy solution keeps track of the number of each vowel at a level in this tree. To calculate say \\'A\\', we calculate how many nodes in the previous level produce \\'A\\'. This is the number of \\'E\\', \\'I\\', and \\'U\\' nodes.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n         long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```\\n\\n**IF YOU LIKE MY SOLUTION THEN JUST PLEASE PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n         long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315039,
                "title": "optimization-from-brute-force-to-dp-to-o-1-time-solutions-explained",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe need to form a string of length `n` with vowels. We are also given some **initial rules or mappings** which tells us what character will come after the current character. We need to return the total number of different strings we can form.\\n\\nLet\\'s try to solve this problem starting with the brute-force appraoch. We can **start with any of the 5 vowels** and thereafter we have the choice to **choose next vowel depending on what\\'s allowed after the previous vowel** in the given mappings. The given mappings state what vowels are allowed after a given vowel -\\n\\n```\\nstart   =>  a / e / i / o / u   # start denotes 1st character of string which can be any vowel\\na       =>  e\\ne       =>  a / i\\ni       =>  a / e / o / u\\no       =>  i / u\\nu       =>  a\\n```\\n\\nSo, we will follow this approach. At each index, we will try choosing all vowels allowed after the previous one. The start will be denoted by `s` (any vowel is allowed after it).\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\npublic:\\n    int countVowelPermutation(int n) {\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        int ans = 0;\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            ans = (ans + solve(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>Alternate Concise Implementation</b></summary>\\n\\n---\\n\\nThis is just a bit more concise version of above code. The mappings are converted to from chars to integer as `a:0, e:1, i:2, o:3, u:4, s:5`.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5, int ans = 0) {\\n        if(!rem) return 1;\\n        for(auto c : mappings[prev])\\n            ans = (ans + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(5<sup>N</sup>)</code>\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n---\\n\\n</details>\\n</blockquote>\\n\\n\\n***Time Complexity :*** **<code>O(5<sup>N</sup>)</code>**, at each index we have maximum of 5 choices with us. There are total of `n` indices. Thus `5*5*5...N times` = <code>O(5<sup>N</sup>)</code>.\\n***Space Complexity :*** **`O(N)`**, required for recursive stack. Max recursive depth at any point will be `N`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Top-Down Recursive)***\\n\\nWe can observe does a lot of repeated calculations. The total number of possible strings when we know the previous character `prev` and remaining length `rem` will always be constant. So there\\'s no need to repeat the same calculation. We can store the calculated result  for a given state and reuse it in the future. Thus, we can optimize the solution using **dynamic programming**.\\n\\nWe will maintain a dp array of length `n+1` for each vowel. Here, *`dp[prev_vowel][rem]`* will denote the number of strings that can be formed when previous character was `prev_vowel` and number of characters still required is equal to `rem`. Each time, we will try all vowels possible at current index and explore the further path. We will store the calculated result in `dp[prev][rem]` and reuse it whenever required in future recursive calls.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\n    unordered_map<char, vector<int>> dp;\\npublic:\\n    int countVowelPermutation(int n) {\\n        dp[\\'s\\'] = dp[\\'a\\'] = dp[\\'e\\'] = dp[\\'i\\'] = dp[\\'o\\'] = dp[\\'u\\'] = vector<int>(n+1);\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        if(dp[prev][rem]) return dp[prev][rem];       // if result already calculated for current state, directly return it\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            dp[prev][rem] = (dp[prev][rem] + solve(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>\\u2714\\uFE0F Alternate Concise Implementation (Faster Runtime)</b></summary>\\n\\n---\\n\\nI used the previous solution for better readability. But this solution should give a lot better runtime than the previous implementation since we are avoiding the use of hashmap and thus reducing the constant factor signifincantly.\\n\\nThe mappings are converted to from chars to integer as `a:0, e:1, i:2, o:3, u:4, s:5`.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    int dp[6][20001]{};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5) {\\n        if(!rem) return 1;                        \\n        if(dp[prev][rem]) return dp[prev][rem];       \\n        for(auto c : mappings[prev])\\n            dp[prev][rem] = (dp[prev][rem] + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\\n\\n***Time Complexity :*** `O(N)`\\n***Space Complexity :*** `O(N)`\\n\\n---\\n---\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** **`O(N)`**, we will be calculating the total possible strings for a given vowels when `rem` characters are requried, only once. Thus, each vowel will make a max of `N` recursive calls. Hence the total time complexity becomes `O(5*N) = O(N)`\\n***Space Complexity :*** **`O(N)`**, `O(N)` space is required by recursive stack. Further, a total of `O(5*N)` space is used by `dp`. Thus the total space complexity becomes `O(N) + O(5*N) = O(N)`\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Bottom-Up Iterative)***\\n\\nWe can also solve this using iterative DP. Here we will start with the state for `n = 1` where we can form 1 string using each vowel at start. We will use the previous states to calculate the result for next. Here *`dp[k][i]`* will denote the number of possible strings of length `i` that end at vowel numbered - `k`. Here, I have just converted from vowel character mappings to integer mappings like -\\n```\\n0 (a)       =>  1\\n1 (e)       =>  0 / 2\\n2 (i)       =>  0 / 1 / 3 / 4\\n3 (o)       =>  2 / 4\\n4 (u)       =>  0\\n```\\n\\nEach time, we use the stored number of strings possible for length `i-1` to calculate for length `i`. We will use only those state for `dp[k]` from which it is allowed to use `k`th vowel at next position.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long dp[5][n+1], ans = 0;\\n        dp[0][1] = dp[1][1] = dp[2][1] = dp[3][1] = dp[4][1] = 1;\\n        for(int i = 2; i <= n; i++) {\\n            dp[0][i] =  dp[1][i-1];\\n            dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % MOD;\\n            dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % MOD;\\n            dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % MOD;\\n            dp[4][i] =  dp[0][i-1];\\n        }\\n        for(int i=0; i < 5; i++) \\n            ans = (ans + dp[i][n]) % MOD;\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Space-Optimized DP)***\\n\\nWe can observe that at any point of time we are only using the previous state of each `dp[i]`. So, we can don\\'t need to store all the states and further optimize the solution by storing only the state for previous length for each vowel.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Pre-compute DP)***\\n\\nJust precompute the answers for all `N` at the start and use the globally stored result for all test cases instead of repeating the calculation for each test case. Also since in this case the algorithm performs the same operations for any test cases, by definition, it is a constant time and space solution since it doesn\\'t depend on input :).\\n\\n```\\nint vowelPerms[20001];\\nauto _ = []{\\n    const int MOD = 1e9 + 7;\\n\\tlong a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n\\tvowelPerms[1] = 5;\\n\\tfor (int j = 2; j <= 20000; j++) {\\n\\t\\ta_new =  e;\\n\\t\\te_new = (a + i) % MOD;\\n\\t\\ti_new = (a + e + o + u) % MOD;\\n\\t\\to_new = (i + u) % MOD;\\n\\t\\tu_new =  a;\\n\\t\\ta = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n\\t\\tvowelPerms[j] = (a + e + i + o + u) % MOD;\\n\\t}\\n\\treturn true;\\n}();  // IIFE\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        return vowelPerms[n];\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(1)`**, time required by `countVowelPermutation()` doesn\\'t depend on input `n`. The pre-computation time complexity in this case is `O(MAX_N) = O(20000) = O(1)`. This solution would be more efficient than `Solution-IV` when there are multiple queries / test-cases that we need to solve for.\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nstart   =>  a / e / i / o / u   # start denotes 1st character of string which can be any vowel\\na       =>  e\\ne       =>  a / i\\ni       =>  a / e / o / u\\no       =>  i / u\\nu       =>  a\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\npublic:\\n    int countVowelPermutation(int n) {\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        int ans = 0;\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            ans = (ans + solve(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5, int ans = 0) {\\n        if(!rem) return 1;\\n        for(auto c : mappings[prev])\\n            ans = (ans + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\n    unordered_map<char, vector<int>> dp;\\npublic:\\n    int countVowelPermutation(int n) {\\n        dp[\\'s\\'] = dp[\\'a\\'] = dp[\\'e\\'] = dp[\\'i\\'] = dp[\\'o\\'] = dp[\\'u\\'] = vector<int>(n+1);\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        if(dp[prev][rem]) return dp[prev][rem];       // if result already calculated for current state, directly return it\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            dp[prev][rem] = (dp[prev][rem] + solve(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    int dp[6][20001]{};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5) {\\n        if(!rem) return 1;                        \\n        if(dp[prev][rem]) return dp[prev][rem];       \\n        for(auto c : mappings[prev])\\n            dp[prev][rem] = (dp[prev][rem] + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\n```\\n0 (a)       =>  1\\n1 (e)       =>  0 / 2\\n2 (i)       =>  0 / 1 / 3 / 4\\n3 (o)       =>  2 / 4\\n4 (u)       =>  0\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long dp[5][n+1], ans = 0;\\n        dp[0][1] = dp[1][1] = dp[2][1] = dp[3][1] = dp[4][1] = 1;\\n        for(int i = 2; i <= n; i++) {\\n            dp[0][i] =  dp[1][i-1];\\n            dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % MOD;\\n            dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % MOD;\\n            dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % MOD;\\n            dp[4][i] =  dp[0][i-1];\\n        }\\n        for(int i=0; i < 5; i++) \\n            ans = (ans + dp[i][n]) % MOD;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```\n```\\nint vowelPerms[20001];\\nauto _ = []{\\n    const int MOD = 1e9 + 7;\\n\\tlong a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n\\tvowelPerms[1] = 5;\\n\\tfor (int j = 2; j <= 20000; j++) {\\n\\t\\ta_new =  e;\\n\\t\\te_new = (a + i) % MOD;\\n\\t\\ti_new = (a + e + o + u) % MOD;\\n\\t\\to_new = (i + u) % MOD;\\n\\t\\tu_new =  a;\\n\\t\\ta = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n\\t\\tvowelPerms[j] = (a + e + i + o + u) % MOD;\\n\\t}\\n\\treturn true;\\n}();  // IIFE\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        return vowelPerms[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398173,
                "title": "c-bottom-up-recursive-dps-o-n-and-matrix-exponentiation-o-logn",
                "content": "**Observation**\\nThe question gives us a map of the vowels that can come after each vowel, we use this mapping to get the number of strings that\\ncan be formed by those \\'ending\\' vowels.\\n* `a` can only be added after `i`, `e` and `u`. Thus strings ending with `a` in the next step will be sum of strings ending with `i`, `u` and `e` in the current step.\\n* `e` can only be added after `a` and `i`. Thus strings ending with `e` in the next step will be sum of strings ending with `i` and `a` in the current step.\\n* `i` can only be added after `o` and `e`. Thus strings ending with `i` in the next step will be sum of strings ending with `o` and  `e` in the current step.\\n* `o` can only be added after `i`. Thus strings ending with `o` in the next step will be equal to strings ending with `i` in the current step.\\n* `u` can only be added after `i` and `o`. Thus strings ending with `u` in the next step will be equal to strings ending with `i` and `o` in the current step.\\n\\nWe do this for all the other vowels and repeat this N-1 times to get our answer.\\n\\n**Solution**\\n*Bottom-up:*\\nWith inversed relationships as explained above (Totally depends on how you imagine the subproblems/DP).\\n```\\nstatic vector<vector<int>> relation={{1,2,4},{0,2},{1,3},{2},{2,3}};  //Relationships(can be followed after) of each vowel with others\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) \\n    {\\n        int MOD=1e9+7;\\n        vector<long long> vowels(5,1),vowels_copy;      //When N=1 all vowels are used once to for 1 letter strings\\n        long long result=0;\\n        while(--n)\\n        {\\n            vowels_copy=vowels;\\n            for(int i=0;i<5;i++)                         //Characters \\'a\\' \\'e\\' \\'i\\' \\'o\\' \\'u\\'.\\n            {\\n                vowels[i]=0;\\n                for(int &r:relation[i])\\n                    vowels[i]+=vowels_copy[r],vowels[i]%=MOD;  //Add the strings that end with characters that can have \\'i\\' after them.\\n            }\\n        }\\n        for(long long &i:vowels)\\n            result+=i,result%=MOD;\\n        return result;\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(1)`\\nTime: `O(n)`\\n\\n*Top-Down (Recursive):*\\n```\\nstatic vector<vector<int>> relation={{1},{0,2},{0,1,3,4},{2,4},{0}};  //Relationships(followed by) of each vowel with others\\nclass Solution {\\npublic:\\n    int MOD=1e9+7;\\n    vector<vector<int>> memo;\\n    int dp(int n,int v)                         //\\'v\\' represents the vowel\\n    {\\n        if(n==1)\\n            return 1;\\n        if(memo[n][v]!=-1)\\n            return memo[n][v];\\n        memo[n][v]=0;\\n        for(int &i:relation[v])\\n            memo[n][v]+=dp(n-1,i),memo[n][v]%=MOD;\\n        return memo[n][v];\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        int result=0;\\n        memo.resize(n+1,vector<int>(5,-1));\\n        for(int i=0;i<5;i++)\\n            result+=dp(n,i),result%=MOD;\\n        return result;\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(n)`\\nTime: `O(n)`\\n\\n*Matrix Exponentiation:*\\nThis problem basically boils down to number of paths of length N in a directed graph.\\n```\\n//Matrix exponentiation.\\nclass Solution {\\npublic:\\n    int MOD=1e9+7;\\n    vector<vector<int>> Multiply(vector<vector<int>> &l,vector<vector<int>> &r) //Multiply two matrices applying MOD.\\n    {\\n        vector<vector<int>> result(l.size(),vector<int>(r[0].size(),0));\\n        for(int i=0;i<l.size();i++)\\n            for(int j=0;j<r[0].size();j++)\\n                for(int k=0;k<l[0].size();k++)\\n                    result[i][j]+=(long long)l[i][k]*r[k][j]%MOD,result[i][j]%=MOD;\\n        return result;\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        vector<vector<int>> M={ {0,1,0,0,0},      //Adjacency matrix of graph of the problem.\\n                                {1,0,1,0,0},\\n                                {1,1,0,1,1},\\n                                {0,0,1,0,1},\\n                                {1,0,0,0,0}},result(5,vector<int>(5));\\n        for(int i=0;i<5;i++)   //Create identity Matrix.\\n            result[i][i]=1;\\n        int sum=0;\\n        n--;\\n        while(n)    //log(n) Multiplication.\\n        {\\n            if(n&1)\\n                result=Multiply(M,result);\\n            n>>=1;\\n            M=Multiply(M,M);\\n        }\\n        for(vector<int> &i:result)          //Result holds M^(N-1).\\n            for(int &j:i)\\n                sum+=j,sum%=MOD;\\n        return sum;\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(1).`\\nTime: `O(logn).` Exponentiation.",
                "solutionTags": [],
                "code": "```\\nstatic vector<vector<int>> relation={{1,2,4},{0,2},{1,3},{2},{2,3}};  //Relationships(can be followed after) of each vowel with others\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) \\n    {\\n        int MOD=1e9+7;\\n        vector<long long> vowels(5,1),vowels_copy;      //When N=1 all vowels are used once to for 1 letter strings\\n        long long result=0;\\n        while(--n)\\n        {\\n            vowels_copy=vowels;\\n            for(int i=0;i<5;i++)                         //Characters \\'a\\' \\'e\\' \\'i\\' \\'o\\' \\'u\\'.\\n            {\\n                vowels[i]=0;\\n                for(int &r:relation[i])\\n                    vowels[i]+=vowels_copy[r],vowels[i]%=MOD;  //Add the strings that end with characters that can have \\'i\\' after them.\\n            }\\n        }\\n        for(long long &i:vowels)\\n            result+=i,result%=MOD;\\n        return result;\\n    }\\n};\\n```\n```\\nstatic vector<vector<int>> relation={{1},{0,2},{0,1,3,4},{2,4},{0}};  //Relationships(followed by) of each vowel with others\\nclass Solution {\\npublic:\\n    int MOD=1e9+7;\\n    vector<vector<int>> memo;\\n    int dp(int n,int v)                         //\\'v\\' represents the vowel\\n    {\\n        if(n==1)\\n            return 1;\\n        if(memo[n][v]!=-1)\\n            return memo[n][v];\\n        memo[n][v]=0;\\n        for(int &i:relation[v])\\n            memo[n][v]+=dp(n-1,i),memo[n][v]%=MOD;\\n        return memo[n][v];\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        int result=0;\\n        memo.resize(n+1,vector<int>(5,-1));\\n        for(int i=0;i<5;i++)\\n            result+=dp(n,i),result%=MOD;\\n        return result;\\n    }\\n};\\n```\n```\\n//Matrix exponentiation.\\nclass Solution {\\npublic:\\n    int MOD=1e9+7;\\n    vector<vector<int>> Multiply(vector<vector<int>> &l,vector<vector<int>> &r) //Multiply two matrices applying MOD.\\n    {\\n        vector<vector<int>> result(l.size(),vector<int>(r[0].size(),0));\\n        for(int i=0;i<l.size();i++)\\n            for(int j=0;j<r[0].size();j++)\\n                for(int k=0;k<l[0].size();k++)\\n                    result[i][j]+=(long long)l[i][k]*r[k][j]%MOD,result[i][j]%=MOD;\\n        return result;\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        vector<vector<int>> M={ {0,1,0,0,0},      //Adjacency matrix of graph of the problem.\\n                                {1,0,1,0,0},\\n                                {1,1,0,1,1},\\n                                {0,0,1,0,1},\\n                                {1,0,0,0,0}},result(5,vector<int>(5));\\n        for(int i=0;i<5;i++)   //Create identity Matrix.\\n            result[i][i]=1;\\n        int sum=0;\\n        n--;\\n        while(n)    //log(n) Multiplication.\\n        {\\n            if(n&1)\\n                result=Multiply(M,result);\\n            n>>=1;\\n            M=Multiply(M,M);\\n        }\\n        for(vector<int> &i:result)          //Result holds M^(N-1).\\n            for(int &j:i)\\n                sum+=j,sum%=MOD;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315113,
                "title": "c-java-python-top-down-dp-bottom-up-dp-picture-explain-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP or DFS with Memoization**\\n- Let dfs to try all possible result result. When we reach a valid possible way, return 1. Use memoization to cache the sub-problem result, so it doesn\\'t need compute again.\\n\\n<iframe src=\"https://leetcode.com/playground/M7T4Y2FE/shared\" frameBorder=\"0\" width=\"100%\" height=\"410\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bottom up DP**\\n- Convert the **Next relationship** into **Previous Relationship**, then do Bottom Up DP.\\n- Let `dp[i][j]` is number of valid permutation strings length `i` that ends at vowel `j`, where `1 <= i <= n`, `0 <= j <= 4`.\\n- When `i = 1`, there is 1 string using each vowel at start, so `dp[i][j] = 1`, for all j `0 <= j <= 4`.\\n- Iterate `i` from `2` to `n`, follow the rules to count the number of strings that end in each vowel.\\n- The answer is sum of `dp[n][j]`, for all j `0 <= j <= 4`.\\n- Since there is up to 2 dp states (previous state, current state), so we can just use `dp[5]` and `prevDP[5]` which can optimize space to `(1)`.\\n\\n![image](https://assets.leetcode.com/users/images/ff5632ef-3c7b-4d13-810a-5e113913ef90_1625392545.5214822.png)\\n\\n<iframe src=\"https://leetcode.com/playground/aT3aLG3n/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(1)`\\n\\n\\nIf you think this post is useful, I\\'m happy if you **give a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Top down DP or DFS with Memoization**\\n- Let dfs to try all possible result result. When we reach a valid possible way, return 1. Use memoization to cache the sub-problem result, so it doesn\\'t need compute again.\\n\\n<iframe src=\"https://leetcode.com/playground/M7T4Y2FE/shared\" frameBorder=\"0\" width=\"100%\" height=\"410\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bottom up DP**\\n- Convert the **Next relationship** into **Previous Relationship**, then do Bottom Up DP.\\n- Let `dp[i][j]` is number of valid permutation strings length `i` that ends at vowel `j`, where `1 <= i <= n`, `0 <= j <= 4`.\\n- When `i = 1`, there is 1 string using each vowel at start, so `dp[i][j] = 1`, for all j `0 <= j <= 4`.\\n- Iterate `i` from `2` to `n`, follow the rules to count the number of strings that end in each vowel.\\n- The answer is sum of `dp[n][j]`, for all j `0 <= j <= 4`.\\n- Since there is up to 2 dp states (previous state, current state), so we can just use `dp[5]` and `prevDP[5]` which can optimize space to `(1)`.\\n\\n![image](https://assets.leetcode.com/users/images/ff5632ef-3c7b-4d13-810a-5e113913ef90_1625392545.5214822.png)\\n\\n<iframe src=\"https://leetcode.com/playground/aT3aLG3n/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(1)`\\n\\n\\nIf you think this post is useful, I\\'m happy if you **give a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 1315077,
                "title": "python-2-solution-dp-and-matrix-power-explained",
                "content": "Let us reformulate problem statement: we can have the following cases:\\n1. If last letter is `a`, then previous letters can be `e, i, u`\\n2. If last letter is `e`, then previous letters can be `a, i`\\n3. If last letter is `i`, then previous letters can be `e, o`\\n4. If last letter is `o`, then previous letter can be only `i`\\n5. If last letter is `u`, then previous letters can be `i, o`.\\n\\nSo, we just keep 5 states for letters `a, e, i, o, u` and update it `n-1` times.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def countVowelPermutation(self, n):\\n        a, e, i, o, u, M = 1, 1, 1, 1, 1, 10**9 + 7\\n        for _ in range(n-1):\\n            a, e, i, o, u = (e + i + u)%M, (a + i)%M, (e + o)%M, i%M, (i + o)%M\\n        \\n        return (a + e + i + o + u)%M \\n```\\n\\n#### Solution 2\\nActually what we have in this problem is linear recurrent and it can be solved using power of matrices. Let `mat` be matrix of possible transitions, then what we need to do is just multiply starting vector `[1, 1, 1, 1, 1]` by this matrix `n-1` times, or which is equivalent for this problem is sum of elements of matrix `mat^{n-1}`.\\n\\n#### Complexity\\nTime complexity is `O(m^3*log n) = O(125 * log n)`, where `m` is order of our reccurence. It is `O(log n)` but with quite big constant so I prefer to make this more careful analysis. Space complexity is `O(m^2) = O(25)`.\\n\\n#### Code\\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n): \\n        def power(mat, n, M):\\n            result = np.eye(len(mat), dtype = int)\\n            while n > 0:\\n                if n%2: result = np.dot(mat, result) % M\\n                mat = np.dot(mat, mat) % M\\n                n //= 2\\n            return result\\n        \\n        M = 10**9 + 7\\n        mat = np.matrix([[0,1,0,0,0], [1,0,1,0,0], [1,1,0,1,1], [0,0,1,0,1], [1,0,0,0,0]])      \\n        return np.sum(power(mat, n-1, M)) % M\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def countVowelPermutation(self, n):\\n        a, e, i, o, u, M = 1, 1, 1, 1, 1, 10**9 + 7\\n        for _ in range(n-1):\\n            a, e, i, o, u = (e + i + u)%M, (a + i)%M, (e + o)%M, i%M, (i + o)%M\\n        \\n        return (a + e + i + o + u)%M \\n```\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n): \\n        def power(mat, n, M):\\n            result = np.eye(len(mat), dtype = int)\\n            while n > 0:\\n                if n%2: result = np.dot(mat, result) % M\\n                mat = np.dot(mat, mat) % M\\n                n //= 2\\n            return result\\n        \\n        M = 10**9 + 7\\n        mat = np.matrix([[0,1,0,0,0], [1,0,1,0,0], [1,1,0,1,1], [0,0,1,0,1], [1,0,0,0,0]])      \\n        return np.sum(power(mat, n-1, M)) % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398406,
                "title": "super-easy-to-understand-java-code",
                "content": "```\\n    public int countVowelPermutation(int n) {\\n        int MOD = 1000_000_007;\\n                \\n        long[][] dp = new long[n + 1][5]; // dp[i][j] := a string of length \\'i\\' ends with a vowel represented by index \\'j\\'\\n        \\n        // vowel & index mapping\\n        // a: 0\\n        // e: 1\\n        // i: 2\\n        // o: 3\\n        // u: 4\\n        \\n\\t\\t// Initialize dp\\n\\t\\t// \\'a\\': dp[1][0] = 1\\n\\t\\t// \\'e\\': dp[1][1] = 1\\n\\t\\t// \\'i\\': dp[1][2] = 1\\n\\t\\t// \\'o\\': dp[1][3] = 1\\n\\t\\t// \\'u\\': dp[1][4] = 1\\n        for(int i = 0; i < 5; i ++){\\n            dp[1][i] = 1; \\n        }\\n        \\n        // Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n        // Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n        // Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n        // Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n        // Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n        // === In other words: \\n        // \\'a\\' can be followed by {\\'e\\'}\\n        // \\'e\\' can be followed by {\\'a\\', \\'i\\'}\\n        // \\'i\\' can be followed by {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}\\n        // \\'o\\' can be followed by {\\'i\\', \\'u\\'}\\n        // \\'u\\' can be followed by {\\'a\\'}\\n        // === In other words:\\n        // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n        // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n        // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n        // \\'o\\' can follow {\\'i\\'}\\n        // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n        \\n        \\n\\t\\t// State transition\\n        for(int i = 2; i <= n; i ++){\\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % MOD; // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % MOD; // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % MOD; // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n            dp[i][3] = (dp[i - 1][2]) % MOD; // \\'o\\' can follow {\\'i\\'}\\n            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % MOD; // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n        }\\n        \\n        long count = 0;\\n        \\n        for(long d : dp[n]){\\n            count += d;\\n            count %= MOD;\\n        }\\n \\n        return (int) count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int countVowelPermutation(int n) {\\n        int MOD = 1000_000_007;\\n                \\n        long[][] dp = new long[n + 1][5]; // dp[i][j] := a string of length \\'i\\' ends with a vowel represented by index \\'j\\'\\n        \\n        // vowel & index mapping\\n        // a: 0\\n        // e: 1\\n        // i: 2\\n        // o: 3\\n        // u: 4\\n        \\n\\t\\t// Initialize dp\\n\\t\\t// \\'a\\': dp[1][0] = 1\\n\\t\\t// \\'e\\': dp[1][1] = 1\\n\\t\\t// \\'i\\': dp[1][2] = 1\\n\\t\\t// \\'o\\': dp[1][3] = 1\\n\\t\\t// \\'u\\': dp[1][4] = 1\\n        for(int i = 0; i < 5; i ++){\\n            dp[1][i] = 1; \\n        }\\n        \\n        // Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n        // Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n        // Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n        // Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n        // Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n        // === In other words: \\n        // \\'a\\' can be followed by {\\'e\\'}\\n        // \\'e\\' can be followed by {\\'a\\', \\'i\\'}\\n        // \\'i\\' can be followed by {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}\\n        // \\'o\\' can be followed by {\\'i\\', \\'u\\'}\\n        // \\'u\\' can be followed by {\\'a\\'}\\n        // === In other words:\\n        // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n        // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n        // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n        // \\'o\\' can follow {\\'i\\'}\\n        // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n        \\n        \\n\\t\\t// State transition\\n        for(int i = 2; i <= n; i ++){\\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % MOD; // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % MOD; // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % MOD; // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n            dp[i][3] = (dp[i - 1][2]) % MOD; // \\'o\\' can follow {\\'i\\'}\\n            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % MOD; // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n        }\\n        \\n        long count = 0;\\n        \\n        for(long d : dp[n]){\\n            count += d;\\n            count %= MOD;\\n        }\\n \\n        return (int) count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 398213,
                "title": "c-java-o-n-knight-dialer",
                "content": "# Intuition\\nIt sounds very similar to [935. Knight Dialer](https://leetcode.com/problems/knight-dialer/). Check out [my explanations](https://leetcode.com/problems/knight-dialer/discuss/189251/C%2B%2B-5-lines-DP) to that problem.\\n\\nThe idea here is to accumulate combinations that ends with a particular letter. We use an array to store counts for each letter. \\n\\nNow, for a string of size ```n + 1```, the combination that ends with \\'a\\', for example, will be the sum of combinations for letters \\'e\\', \\'i\\' and \\'u\\' for string of size ```n```.\\n\\n> Since we only need to know counts for size ```n``` to calculate counts for ```n + 1```, we can minimize our memory complexity by using two arrays. \\n### C++\\n> Note that I am using a two-dimensional vector ```v[2][5]``` to store counts. First dimension separates count for ```n``` and ```n + 1```. I am using modulo operation (```(n + 1) % 2``` and ```(n % 2)```) to virtually \"swap\" source and destination for every iteration.\\n```\\nint countVowelPermutation(int n) {\\n  // \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'\\n  vector<vector<int>> moves = { {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, { 0 } }, v(2, vector<int>(5, 1));\\n  while (--n > 0) {\\n    for (auto i = 0; i < 5; ++i)\\n      v[(n + 1) % 2][i] = accumulate(begin(moves[i]), end(moves[i]), 0,\\n        [&](int s, int j) {return (s + v[n % 2][j]) % 1000000007; });\\n  }\\n  return accumulate(begin(v[0]), end(v[0]), 0, [](int s, int n) { return (s + n) % 1000000007; });\\n}\\n```\\n### Java\\n```\\npublic int countVowelPermutation(int n) {\\n  int[][] moves = { {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, { 0 } };\\n  int[] v = { 1, 1, 1, 1, 1 };\\n  while (--n > 0) {\\n    int[] v1 = { 0, 0, 0, 0, 0 };\\n    for (int i = 0; i < 5; ++i) {\\n      for (int j : moves[i])\\n        v1[j] = (v1[j] + v[i]) % 1000000007;\\n    }\\n    v = v1;\\n  }\\n  return (int)(((long)v[0] + v[1] + v[2] + v[3] + v[4]) % 1000000007);\\n}\\n```\\n**Python 3**\\nTop-down, just for fun.\\n```python\\nclass Solution:\\n    follow = {\"a\": \"e\", \"e\": \"ai\", \"i\": \"aeuo\", \"u\": \"a\", \"o\": \"iu\", \"\": \"aeiuo\"}\\n    @cache\\n    def countVowelPermutation(self, n: int, last: chr = \"\") -> int:\\n        return (\\n            1\\n            if n == 0\\n            else sum(self.countVowelPermutation(n - 1, ch) for ch in self.follow[last])\\n            % 1000000007\\n        )\\n```\\n## Complexity Analysis\\nTime: O(n). For each iteration, we do 10 operations.\\nMemory: O(1).",
                "solutionTags": [],
                "code": "```n + 1```\n```n```\n```n```\n```n + 1```\n```v[2][5]```\n```n```\n```n + 1```\n```(n + 1) % 2```\n```(n % 2)```\n```\\nint countVowelPermutation(int n) {\\n  // \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'\\n  vector<vector<int>> moves = { {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, { 0 } }, v(2, vector<int>(5, 1));\\n  while (--n > 0) {\\n    for (auto i = 0; i < 5; ++i)\\n      v[(n + 1) % 2][i] = accumulate(begin(moves[i]), end(moves[i]), 0,\\n        [&](int s, int j) {return (s + v[n % 2][j]) % 1000000007; });\\n  }\\n  return accumulate(begin(v[0]), end(v[0]), 0, [](int s, int n) { return (s + n) % 1000000007; });\\n}\\n```\n```\\npublic int countVowelPermutation(int n) {\\n  int[][] moves = { {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, { 0 } };\\n  int[] v = { 1, 1, 1, 1, 1 };\\n  while (--n > 0) {\\n    int[] v1 = { 0, 0, 0, 0, 0 };\\n    for (int i = 0; i < 5; ++i) {\\n      for (int j : moves[i])\\n        v1[j] = (v1[j] + v[i]) % 1000000007;\\n    }\\n    v = v1;\\n  }\\n  return (int)(((long)v[0] + v[1] + v[2] + v[3] + v[4]) % 1000000007);\\n}\\n```\n```python\\nclass Solution:\\n    follow = {\"a\": \"e\", \"e\": \"ai\", \"i\": \"aeuo\", \"u\": \"a\", \"o\": \"iu\", \"\": \"aeiuo\"}\\n    @cache\\n    def countVowelPermutation(self, n: int, last: chr = \"\") -> int:\\n        return (\\n            1\\n            if n == 0\\n            else sum(self.countVowelPermutation(n - 1, ch) for ch in self.follow[last])\\n            % 1000000007\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398231,
                "title": "dynamic-programming-in-python-with-in-depth-explanation-and-diagrams",
                "content": "This question is probably more of a medium than a hard, however it is a great example of dynamic programming!\\n\\nFirstly, we can represent valid strings as a state machine using the information we\\'re given.\\n\\n![image](https://assets.leetcode.com/users/hai_dee/image_1570335214.png)\\n\\nIn order to count how many valid strings there are of length n, we need to use dynamic programming. One way of doing this is to start with strings of length 1, and then consider adding 1 letter at a time, until we have n letters.\\n\\nSo, we iterate from 1 to n, and at each step we determine how many strings of the current length could end with each letter, by extending the strings one size smaller.  With ```n=1```, there is exactly ```1``` option for each (the string containing only that letter).\\n\\nFor ```n = 2```, we now need to think about which letters the current letter we\\u2019re considering could have followed. For example, an \\u201Ca\\u201D is could appear after an \\u201Ce\\u201D, \\u201Ci\\u201D, or \\u201Cu\\u201D, but not after an \\u201Ca\\u201D or an \\u201Co\\u201D as the information we\\u2019re given forbids this. Therefore, the number of strings ending in an \\u201Ca\\u201D is the sum of all the strings whose previous letter was \\u201Ce\\u201D, \\u201Ci\\u201D, or \\u201Cu\\u201D.\\n\\nWe then need to look at our diagram above, to determine what letters each letter could have come out of (look at the arrows in the diagram in reverse to obtain this information).\\n\\n* ```\\u201Ca\\u201D``` can follow any of ```{\\u201Ce\\u201D, \\u201Ci\\u201D, \\u201Cu\\u201D}```.\\n* ```\\u201Ce\\u201D``` can follow any of ```{\\u201Ca\\u201D, \\u201Ci\\u201D}```.\\n* ```\\u201Ci\\u201D``` can follow any of ```{\\u201Ce\\u201D, \\u201Co\\u201D}```.\\n* ```\\u201Co\\u201D``` can follow ```{\\u201Ci\\u201D}```.\\n\\u201C ```\\u201Cu\\u201D``` can follow any of ```{\\u201Ci, \\u201Co\\u201D}```.\\n\\nThe following diagram shows the cells we\\u2019re adding for strings that end in \\u201Ca\\u201D of each size. For example, the number of length-5 strings that end in \\u201Ca\\u201D is the sum of all length-4 strings that end in \\u201Ce\\u201D (9), \\u201Ci\\u201D (7), and \\u201Cu\\u201D (5), which adds to 21.\\n\\n![image](https://assets.leetcode.com/users/hai_dee/image_1570334625.png)\\n\\n\\nIf we need to know how many strings are of length 7, we can add the 7th column ```77 + 65 + 45 + 25 + 37 = 249```. \\n\\n# Code in Python\\n\\nTo implement this in code, we simply need to build up the table shown above.  This code uses ```O(n)``` space for clarity, it is possible to optimise it to use ```O(1)``` space though.\\n\\n```py\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp_array = [[0] * 5 for _ in range(n + 1)]\\n        dp_array[1] = [1, 1, 1, 1, 1]\\n        for i in range(2, n + 1):\\n            # a is allowed to follow e, i, or u.\\n            dp_array[i][0] = dp_array[i - 1][1] + dp_array[i - 1][2] + dp_array[i - 1][4]\\n            # e is allowed to follow a or i.\\n            dp_array[i][1] = dp_array[i - 1][0] +  dp_array[i - 1][2]\\n            # i is allowed to follow e or o.\\n            dp_array[i][2] = dp_array[i - 1][1] + dp_array[i - 1][3]\\n            # o is allowed to follow i\\n            dp_array[i][3] = dp_array[i - 1][2]\\n            # u is allowed to follow i or o.\\n            dp_array[i][4] = dp_array[i - 1][2] + dp_array[i - 1][3]\\n        return sum(dp_array[n]) % ((10 ** 9) + 7)\\n````\\n# Cost of the algorithm\\n\\nThe cost of this algorithm is ```n * 5```, which in big-oh notation simplifies down to ```O(n)```. It uses ```O(n)``` space to hold the generated table.\\n\\nWe can easily optimise it to ```O(1)``` space by only keeping track of the previous column rather than all columns.\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```n=1```\n```1```\n```n = 2```\n```\\u201Ca\\u201D```\n```{\\u201Ce\\u201D, \\u201Ci\\u201D, \\u201Cu\\u201D}```\n```\\u201Ce\\u201D```\n```{\\u201Ca\\u201D, \\u201Ci\\u201D}```\n```\\u201Ci\\u201D```\n```{\\u201Ce\\u201D, \\u201Co\\u201D}```\n```\\u201Co\\u201D```\n```{\\u201Ci\\u201D}```\n```\\u201Cu\\u201D```\n```{\\u201Ci, \\u201Co\\u201D}```\n```77 + 65 + 45 + 25 + 37 = 249```\n```O(n)```\n```O(1)```\n```py\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp_array = [[0] * 5 for _ in range(n + 1)]\\n        dp_array[1] = [1, 1, 1, 1, 1]\\n        for i in range(2, n + 1):\\n            # a is allowed to follow e, i, or u.\\n            dp_array[i][0] = dp_array[i - 1][1] + dp_array[i - 1][2] + dp_array[i - 1][4]\\n            # e is allowed to follow a or i.\\n            dp_array[i][1] = dp_array[i - 1][0] +  dp_array[i - 1][2]\\n            # i is allowed to follow e or o.\\n            dp_array[i][2] = dp_array[i - 1][1] + dp_array[i - 1][3]\\n            # o is allowed to follow i\\n            dp_array[i][3] = dp_array[i - 1][2]\\n            # u is allowed to follow i or o.\\n            dp_array[i][4] = dp_array[i - 1][2] + dp_array[i - 1][3]\\n        return sum(dp_array[n]) % ((10 ** 9) + 7)\\n```\n```n * 5```\n```O(n)```\n```O(n)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1315044,
                "title": "count-vowels-permutation-optimization-from-brute-force-to-dp-to-o-1-time-solution-explained",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe need to form a string of length `n` with vowels. We are also given some **initial rules or mappings** which tells us what character will come after the current character. We need to return the total number of different strings we can form.\\n\\nLet\\'s try to solve this problem starting with the brute-force appraoch. We can **start with any of the 5 vowels** and thereafter we have the choice to **choose next vowel depending on what\\'s allowed after the previous vowel** in the given mappings. The given mappings state what vowels are allowed after a given vowel -\\n\\n```\\nstart   =>  a / e / i / o / u   # start denotes 1st character of string which can be any vowel\\na       =>  e\\ne       =>  a / i\\ni       =>  a / e / o / u\\no       =>  i / u\\nu       =>  a\\n```\\n\\nSo, we will follow this approach. At each index, we will try choosing all vowels allowed after the previous one. The start will be denoted by `s` (any vowel is allowed after it).\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\npublic:\\n    int countVowelPermutation(int n) {\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        int ans = 0;\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            ans = (ans + solve(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>Alternate Concise Implementation</b></summary>\\n\\n---\\n\\nThis is just a bit more concise version of above code. The mappings are converted to from chars to integer as `a:0, e:1, i:2, o:3, u:4, s:5`.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5, int ans = 0) {\\n        if(!rem) return 1;\\n        for(auto c : mappings[prev])\\n            ans = (ans + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(5<sup>N</sup>)</code>\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n---\\n\\n</details>\\n</blockquote>\\n\\n\\n***Time Complexity :*** **<code>O(5<sup>N</sup>)</code>**, at each index we have maximum of 5 choices with us. There are total of `n` indices. Thus `5*5*5...N times` = <code>O(5<sup>N</sup>)</code>.\\n***Space Complexity :*** **`O(N)`**, required for recursive stack. Max recursive depth at any point will be `N`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Top-Down Recursive)***\\n\\nWe can observe does a lot of repeated calculations. The total number of possible strings when we know the previous character `prev` and remaining length `rem` will always be constant. So there\\'s no need to repeat the same calculation. We can store the calculated result  for a given state and reuse it in the future. Thus, we can optimize the solution using **dynamic programming**.\\n\\nWe will maintain a dp array of length `n+1` for each vowel. Here, *`dp[prev_vowel][rem]`* will denote the number of strings that can be formed when previous character was `prev_vowel` and number of characters still required is equal to `rem`. Each time, we will try all vowels possible at current index and explore the further path. We will store the calculated result in `dp[prev][rem]` and reuse it whenever required in future recursive calls.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\n    unordered_map<char, vector<int>> dp;\\npublic:\\n    int countVowelPermutation(int n) {\\n        dp[\\'s\\'] = dp[\\'a\\'] = dp[\\'e\\'] = dp[\\'i\\'] = dp[\\'o\\'] = dp[\\'u\\'] = vector<int>(n+1);\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        if(dp[prev][rem]) return dp[prev][rem];       // if result already calculated for current state, directly return it\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            dp[prev][rem] = (dp[prev][rem] + solve(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>\\u2714\\uFE0F Alternate Concise Implementation (Faster Runtime)</b></summary>\\n\\n---\\n\\nI used the previous solution for better readability. But this solution should give a lot better runtime than the previous implementation since we are avoiding the use of hashmap and thus reducing the constant factor signifincantly.\\n\\nThe mappings are converted to from chars to integer as `a:0, e:1, i:2, o:3, u:4, s:5`.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    int dp[6][20001]{};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5) {\\n        if(!rem) return 1;                        \\n        if(dp[prev][rem]) return dp[prev][rem];       \\n        for(auto c : mappings[prev])\\n            dp[prev][rem] = (dp[prev][rem] + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\\n\\n***Time Complexity :*** `O(N)`\\n***Space Complexity :*** `O(N)`\\n\\n---\\n---\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** **`O(N)`**, we will be calculating the total possible strings for a given vowels when `rem` characters are requried, only once. Thus, each vowel will make a max of `N` recursive calls. Hence the total time complexity becomes `O(5*N) = O(N)`\\n***Space Complexity :*** **`O(N)`**, `O(N)` space is required by recursive stack. Further, a total of `O(5*N)` space is used by `dp`. Thus the total space complexity becomes `O(N) + O(5*N) = O(N)`\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Bottom-Up Iterative)***\\n\\nWe can also solve this using iterative DP. Here we will start with the state for `n = 1` where we can form 1 string using each vowel at start. We will use the previous states to calculate the result for next. Here *`dp[k][i]`* will denote the number of possible strings of length `i` that end at vowel numbered - `k`. Here, I have just converted from vowel character mappings to integer mappings like -\\n```\\n0 (a)       =>  1\\n1 (e)       =>  0 / 2\\n2 (i)       =>  0 / 1 / 3 / 4\\n3 (o)       =>  2 / 4\\n4 (u)       =>  0\\n```\\n\\nEach time, we use the stored number of strings possible for length `i-1` to calculate for length `i`. We will use only those state for `dp[k]` from which it is allowed to use `k`th vowel at next position.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long dp[5][n+1], ans = 0;\\n        dp[0][1] = dp[1][1] = dp[2][1] = dp[3][1] = dp[4][1] = 1;\\n        for(int i = 2; i <= n; i++) {\\n            dp[0][i] =  dp[1][i-1];\\n            dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % MOD;\\n            dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % MOD;\\n            dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % MOD;\\n            dp[4][i] =  dp[0][i-1];\\n        }\\n        for(int i=0; i < 5; i++) \\n            ans = (ans + dp[i][n]) % MOD;\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Space-Optimized DP)***\\n\\nWe can observe that at any point of time we are only using the previous state of each `dp[i]`. So, we can don\\'t need to store all the states and further optimize the solution by storing only the state for previous length for each vowel.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Pre-compute DP)***\\n\\nJust precompute the answers for all `N` at the start and use the globally stored result for all test cases instead of repeating the calculation for each test case. Also since in this case the algorithm performs the same operations for any test cases, by definition, it is a constant time and space solution since it doesn\\'t depend on input :).\\n\\n```\\nint vowelPerms[20001];\\nauto _ = []{\\n    const int MOD = 1e9 + 7;\\n\\tlong a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n\\tvowelPerms[1] = 5;\\n\\tfor (int j = 2; j <= 20000; j++) {\\n\\t\\ta_new =  e;\\n\\t\\te_new = (a + i) % MOD;\\n\\t\\ti_new = (a + e + o + u) % MOD;\\n\\t\\to_new = (i + u) % MOD;\\n\\t\\tu_new =  a;\\n\\t\\ta = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n\\t\\tvowelPerms[j] = (a + e + i + o + u) % MOD;\\n\\t}\\n\\treturn true;\\n}();  // IIFE\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        return vowelPerms[n];\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(1)`**, time required doesn\\'t depend on input.\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nstart   =>  a / e / i / o / u   # start denotes 1st character of string which can be any vowel\\na       =>  e\\ne       =>  a / i\\ni       =>  a / e / o / u\\no       =>  i / u\\nu       =>  a\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\npublic:\\n    int countVowelPermutation(int n) {\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        int ans = 0;\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            ans = (ans + solve(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5, int ans = 0) {\\n        if(!rem) return 1;\\n        for(auto c : mappings[prev])\\n            ans = (ans + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\n    unordered_map<char, vector<int>> dp;\\npublic:\\n    int countVowelPermutation(int n) {\\n        dp[\\'s\\'] = dp[\\'a\\'] = dp[\\'e\\'] = dp[\\'i\\'] = dp[\\'o\\'] = dp[\\'u\\'] = vector<int>(n+1);\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        if(dp[prev][rem]) return dp[prev][rem];       // if result already calculated for current state, directly return it\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            dp[prev][rem] = (dp[prev][rem] + solve(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    int dp[6][20001]{};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5) {\\n        if(!rem) return 1;                        \\n        if(dp[prev][rem]) return dp[prev][rem];       \\n        for(auto c : mappings[prev])\\n            dp[prev][rem] = (dp[prev][rem] + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\n```\\n0 (a)       =>  1\\n1 (e)       =>  0 / 2\\n2 (i)       =>  0 / 1 / 3 / 4\\n3 (o)       =>  2 / 4\\n4 (u)       =>  0\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long dp[5][n+1], ans = 0;\\n        dp[0][1] = dp[1][1] = dp[2][1] = dp[3][1] = dp[4][1] = 1;\\n        for(int i = 2; i <= n; i++) {\\n            dp[0][i] =  dp[1][i-1];\\n            dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % MOD;\\n            dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % MOD;\\n            dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % MOD;\\n            dp[4][i] =  dp[0][i-1];\\n        }\\n        for(int i=0; i < 5; i++) \\n            ans = (ans + dp[i][n]) % MOD;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```\n```\\nint vowelPerms[20001];\\nauto _ = []{\\n    const int MOD = 1e9 + 7;\\n\\tlong a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n\\tvowelPerms[1] = 5;\\n\\tfor (int j = 2; j <= 20000; j++) {\\n\\t\\ta_new =  e;\\n\\t\\te_new = (a + i) % MOD;\\n\\t\\ti_new = (a + e + o + u) % MOD;\\n\\t\\to_new = (i + u) % MOD;\\n\\t\\tu_new =  a;\\n\\t\\ta = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n\\t\\tvowelPerms[j] = (a + e + i + o + u) % MOD;\\n\\t}\\n\\treturn true;\\n}();  // IIFE\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        return vowelPerms[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391936,
                "title": "python-detailed-explanation-fast-than-91-less-than-93-dp-fast-math",
                "content": "**Appreciate if you could upvote this solution**\\n\\nMethod: `DP`\\nSince the maximum length of the words is `n` and there are total `5` vowels, we could create a `dp[n][5]` matrix first.\\nThus, dp[i][j] means the number of strings of length `i` that ends with the `j`-th vowel so `dp[i]` is the result for word with `n = i`\\n\\nBasically, the result of word with `n = i` is depending on the result of word with `n = i - 1` so it can be solved by dynamic programming.\\nTherefore, for each row `dp[i][j]` is depending on the row `dp[i - 1][j]`\\n```\\ncan only follow:\\n - a -> e, i and u\\n - e -> a and i\\n - i -> e and o\\n - o -> i\\n - u -> i and o\\n```\\nCode:\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        # dp[i][j] means the number of strings of length i that ends with the j-th vowel.\\n        dp = [[1] * 5] + [[0] * (5) for _ in range(n - 1)]\\n        moduler = math.pow(10, 9) + 7\\n        for i in range(1, n):\\n            # For vowel a\\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % moduler\\n            # For vowel e\\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % moduler\\n            # For vowel i\\n            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % moduler\\n            # For vowel o\\n            dp[i][3] = (dp[i - 1][2]) % moduler\\n            # For vowel u\\n            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % moduler\\n            \\n        return int(sum(dp[-1]) % moduler)\\n```\\n\\n**Time complexity**: `O(n)` \\n**Space complexity**: `O(n^2)` \\n\\n<br/>\\n\\nAs stated as above, for each row `dp[i][j]` is depending on the row `dp[i - 1][j]` only.\\nThus, we do need to store the row less than `i - 1` so the space complexity could be lower\\n\\nCode:\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        moduler = math.pow(10, 9) + 7\\n        a, e, i, o, u = [1] * 5\\n        for _ in range(n - 1):\\n            a, e, i, o, u = map(lambda x: x % moduler, [(e + i + u), (a + i), (e + o), (i), (i + o)])\\n        return int((a + e + i+ o + u) % moduler)\\n```\\n**Time complexity**: `O(n)` \\n**Space complexity**: `O(1)` \\n<br/>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ncan only follow:\\n - a -> e, i and u\\n - e -> a and i\\n - i -> e and o\\n - o -> i\\n - u -> i and o\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        # dp[i][j] means the number of strings of length i that ends with the j-th vowel.\\n        dp = [[1] * 5] + [[0] * (5) for _ in range(n - 1)]\\n        moduler = math.pow(10, 9) + 7\\n        for i in range(1, n):\\n            # For vowel a\\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % moduler\\n            # For vowel e\\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % moduler\\n            # For vowel i\\n            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % moduler\\n            # For vowel o\\n            dp[i][3] = (dp[i - 1][2]) % moduler\\n            # For vowel u\\n            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % moduler\\n            \\n        return int(sum(dp[-1]) % moduler)\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        moduler = math.pow(10, 9) + 7\\n        a, e, i, o, u = [1] * 5\\n        for _ in range(n - 1):\\n            a, e, i, o, u = map(lambda x: x % moduler, [(e + i + u), (a + i), (e + o), (i), (i + o)])\\n        return int((a + e + i+ o + u) % moduler)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391230,
                "title": "elegant-dp-solution-not-hard-should-be-easy-medium",
                "content": "## Approach\\nSeeing the question the first approach you would think of is DP to build up to a n character string. There are a few constraints on which character can come after the other. The below table represents the same. Also I have mapped the vowels to the numbers 0 to 4 for ease in implementation.\\n```text\\n a(0) - e            - 1\\n e(1) - a, i         - 0, 2\\n i(2) - a, e, o, u   - 0, 1, 3, 4\\n o(3) - i, u         - 2, 4\\n u(4) - a            - 0\\n```\\nThe above is mapping of \\'before - after\\'(character preceding to character succeding). For the dp we need the after - before mapping so we will reverse this. \\n**Note:** You can also solve it just using the \\'before - after\\', I found the \\'after - before\\' mapping more intuitive so used it.\\n\\n```text\\n 0 - 1, 2, 4\\n 1 - 0, 2\\n 2 - 1, 3\\n 3 - 2\\n 4 - 2, 3\\n```\\n\\nNow for the dp. We are going to use a 2D dp array, where `dp[i][j]` represents the number of strings where the last character, ie. the i<sup>th</sup> character is the j<sup>th</sup> vowel. As we saw above the j<sup>th</sup> vowel can have only certain characters preceding it. For example, when` j = 3`, which is the vowel `o`, the previous characters can only be one of `[2, 4]` which is the letters `[i, u]`. Hence,\\n```text\\n dp[i][j] = \\u2211(dp[i-1][k])  for all kth vowels which are permitted to precede the jth vowel\\n```\\n___\\n\\n## Implementation\\nWe store the above mapping in the array, `validPrev`. As mentioned above, note how we don\\'t have to use any characters instead we are using `a as 0, e as 1, i as 2, o as 3 and u as 4.`\\n```cpp\\n#define ll long long\\n#define mod (ll)((ll)(1e9) + 7)\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<ll>> dp(n, vector<ll> (5, 1));\\n        vector<vector<ll>> validPrev = {{1, 2, 4}, {0, 2}, {1, 3}, {2}, {2, 3}};\\n        for(int i = 1; i < n; ++i) {\\n            for(int j = 0; j < 5; ++j) {\\n                dp[i][j] = 0;\\n                for(auto k: validPrev[j])\\n                    dp[i][j] = (dp[i][j] + dp[i-1][k])%mod;\\n            }\\n        }\\n        ll ans = 0;\\n        for(auto n : dp.back()) ans = (ans + n)%mod;\\n        return ans;\\n    }\\n};\\n```\\n\\nWe can optimise the space usage above, since the current dp row only needs the last row for calculating the result.\\n```cpp\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<ll> last(5, 1), cur(5, 0);\\n        vector<vector<ll>> validPrev = {{1, 2, 4}, {0, 2}, {1, 3}, {2}, {2, 3}};\\n        for(int i = 1; i < n; ++i) {\\n            for(int j = 0; j < 5; ++j) \\n                for(auto k: validPrev[j])\\n                    cur[j] = (cur[j] + last[k])%mod;\\n            last = cur;\\n            cur = {0, 0, 0, 0, 0};\\n        }\\n        ll ans = 0;\\n        for(auto n : last) ans = (ans + n)%mod;\\n        return ans;\\n    }\\n};\\n```\\nIn general, whenever you can have a lot of ifs and elses in your code try replacing them with a relationship-map using arrays or hash maps and loop through the array or hash-map instead. Another example would be problems related to traversing a grid, like dfs, bfs or spiral matrix series. You will have a lot easier time implementing a shorter solution and make a lot less mistakes as well.\\n\\nDo leave a like if you found this post informative. Thank you for reading : )\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```text\\n a(0) - e            - 1\\n e(1) - a, i         - 0, 2\\n i(2) - a, e, o, u   - 0, 1, 3, 4\\n o(3) - i, u         - 2, 4\\n u(4) - a            - 0\\n```\n```text\\n 0 - 1, 2, 4\\n 1 - 0, 2\\n 2 - 1, 3\\n 3 - 2\\n 4 - 2, 3\\n```\n```text\\n dp[i][j] = \\u2211(dp[i-1][k])  for all kth vowels which are permitted to precede the jth vowel\\n```\n```cpp\\n#define ll long long\\n#define mod (ll)((ll)(1e9) + 7)\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<ll>> dp(n, vector<ll> (5, 1));\\n        vector<vector<ll>> validPrev = {{1, 2, 4}, {0, 2}, {1, 3}, {2}, {2, 3}};\\n        for(int i = 1; i < n; ++i) {\\n            for(int j = 0; j < 5; ++j) {\\n                dp[i][j] = 0;\\n                for(auto k: validPrev[j])\\n                    dp[i][j] = (dp[i][j] + dp[i-1][k])%mod;\\n            }\\n        }\\n        ll ans = 0;\\n        for(auto n : dp.back()) ans = (ans + n)%mod;\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<ll> last(5, 1), cur(5, 0);\\n        vector<vector<ll>> validPrev = {{1, 2, 4}, {0, 2}, {1, 3}, {2}, {2, 3}};\\n        for(int i = 1; i < n; ++i) {\\n            for(int j = 0; j < 5; ++j) \\n                for(auto k: validPrev[j])\\n                    cur[j] = (cur[j] + last[k])%mod;\\n            last = cur;\\n            cur = {0, 0, 0, 0, 0};\\n        }\\n        ll ans = 0;\\n        for(auto n : last) ans = (ans + n)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391146,
                "title": "c-recursive-dp-memoized-solution",
                "content": "**1. Recursive Brute Force Solution (Gives TLE)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int n, int i, char c){\\n        \\n        if(i==n) return 1;\\n        \\n        int count = 0;\\n        \\n        if(c==\\'a\\'){\\n\\t\\t// after a only e is allowed\\n            count += f(n, i+1, \\'e\\');\\n        }\\n        \\n        if(c==\\'e\\'){\\n\\t\\t// after e only a and i are allowed\\n            count += f(n, i+1, \\'a\\');\\n            count += f(n, i+1, \\'i\\');\\n        }\\n        if(c==\\'i\\'){\\n\\t\\t// after i except i everything is allowed\\n            count += f(n, i+1, \\'a\\');\\n            count += f(n, i+1, \\'e\\');\\n            count += f(n, i+1, \\'o\\');\\n            count += f(n, i+1, \\'u\\');\\n        }\\n        if(c==\\'o\\'){\\n\\t\\t// after o only i and u are allowed\\n            count += f(n, i+1, \\'i\\');\\n            count += f(n, i+1, \\'u\\');\\n        }\\n        \\n        if(c==\\'u\\'){\\n\\t\\t// after u only a is allowed\\n            count += f(n, i+1, \\'a\\');\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    int countVowelPermutation(int n) {\\n\\t\\n\\t\\t//call for each starting from each vowel after that for changing the character values our recursive call will take care of\\n        return f(n, 1, \\'a\\')  + f(n, 1, \\'e\\') + f(n, 1, \\'i\\') + f(n, 1, \\'o\\') + f(n, 1, \\'u\\'); \\n        \\n    }\\n};\\n```\\n\\n**2. DP Memoized Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int MOD=1e9+7;\\n\\n    long long int f(int n, int i, char c, vector<vector<int>> &dp, unordered_map<char, int> &mp){\\n        \\n        if(i==n) return 1;\\n        \\n        long long count = 0;\\n        \\n        if(dp[mp[c]][i]!=-1) return dp[mp[c]][i]%MOD;\\n        \\n        if(c==\\'a\\'){\\n\\t\\t// after a only e is allowed\\n            count += f(n, i+1, \\'e\\', dp, mp);\\n        }\\n        \\n        if(c==\\'e\\'){\\n\\t\\t// after e only a and i are allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n            count += f(n, i+1, \\'i\\', dp, mp);\\n        }\\n        if(c==\\'i\\'){\\n\\t\\t// after i everthing except i is allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n            count += f(n, i+1, \\'e\\', dp, mp);\\n            count += f(n, i+1, \\'o\\', dp, mp);\\n            count += f(n, i+1, \\'u\\', dp, mp);\\n        }\\n        if(c==\\'o\\'){\\n\\t\\t// after o only i and u are allowed\\n            count += f(n, i+1, \\'i\\', dp, mp);\\n            count += f(n, i+1, \\'u\\', dp, mp);\\n        }\\n        \\n        if(c==\\'u\\'){\\n\\t\\t// after u only a is allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n        }\\n        \\n        return dp[mp[c]][i] = count%MOD;\\n        \\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        \\n\\t\\t// map to convert char to int for using in dp vector for memoization purpose\\n        unordered_map<char, int> mp;\\n        mp[\\'a\\'] = 0;\\n        mp[\\'e\\'] = 1;\\n        mp[\\'i\\'] = 2;\\n        mp[\\'o\\'] = 3;\\n        mp[\\'u\\'] = 4;\\n        \\n        vector<vector<int>> dp(5, vector<int>(n+1, -1));\\n\\t\\t\\n\\t\\t\\t\\t//call for each starting from each vowel after that for changing the character values our recursive call will take care of\\n\\n        long long cnt = f(n, 1, \\'a\\', dp, mp) + f(n, 1, \\'e\\', dp, mp) + f(n, 1, \\'i\\', dp, mp) + f(n, 1, \\'o\\', dp, mp) + f(n, 1, \\'u\\', dp, mp); \\n        \\n        return cnt%MOD;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(int n, int i, char c){\\n        \\n        if(i==n) return 1;\\n        \\n        int count = 0;\\n        \\n        if(c==\\'a\\'){\\n\\t\\t// after a only e is allowed\\n            count += f(n, i+1, \\'e\\');\\n        }\\n        \\n        if(c==\\'e\\'){\\n\\t\\t// after e only a and i are allowed\\n            count += f(n, i+1, \\'a\\');\\n            count += f(n, i+1, \\'i\\');\\n        }\\n        if(c==\\'i\\'){\\n\\t\\t// after i except i everything is allowed\\n            count += f(n, i+1, \\'a\\');\\n            count += f(n, i+1, \\'e\\');\\n            count += f(n, i+1, \\'o\\');\\n            count += f(n, i+1, \\'u\\');\\n        }\\n        if(c==\\'o\\'){\\n\\t\\t// after o only i and u are allowed\\n            count += f(n, i+1, \\'i\\');\\n            count += f(n, i+1, \\'u\\');\\n        }\\n        \\n        if(c==\\'u\\'){\\n\\t\\t// after u only a is allowed\\n            count += f(n, i+1, \\'a\\');\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    int countVowelPermutation(int n) {\\n\\t\\n\\t\\t//call for each starting from each vowel after that for changing the character values our recursive call will take care of\\n        return f(n, 1, \\'a\\')  + f(n, 1, \\'e\\') + f(n, 1, \\'i\\') + f(n, 1, \\'o\\') + f(n, 1, \\'u\\'); \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int MOD=1e9+7;\\n\\n    long long int f(int n, int i, char c, vector<vector<int>> &dp, unordered_map<char, int> &mp){\\n        \\n        if(i==n) return 1;\\n        \\n        long long count = 0;\\n        \\n        if(dp[mp[c]][i]!=-1) return dp[mp[c]][i]%MOD;\\n        \\n        if(c==\\'a\\'){\\n\\t\\t// after a only e is allowed\\n            count += f(n, i+1, \\'e\\', dp, mp);\\n        }\\n        \\n        if(c==\\'e\\'){\\n\\t\\t// after e only a and i are allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n            count += f(n, i+1, \\'i\\', dp, mp);\\n        }\\n        if(c==\\'i\\'){\\n\\t\\t// after i everthing except i is allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n            count += f(n, i+1, \\'e\\', dp, mp);\\n            count += f(n, i+1, \\'o\\', dp, mp);\\n            count += f(n, i+1, \\'u\\', dp, mp);\\n        }\\n        if(c==\\'o\\'){\\n\\t\\t// after o only i and u are allowed\\n            count += f(n, i+1, \\'i\\', dp, mp);\\n            count += f(n, i+1, \\'u\\', dp, mp);\\n        }\\n        \\n        if(c==\\'u\\'){\\n\\t\\t// after u only a is allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n        }\\n        \\n        return dp[mp[c]][i] = count%MOD;\\n        \\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        \\n\\t\\t// map to convert char to int for using in dp vector for memoization purpose\\n        unordered_map<char, int> mp;\\n        mp[\\'a\\'] = 0;\\n        mp[\\'e\\'] = 1;\\n        mp[\\'i\\'] = 2;\\n        mp[\\'o\\'] = 3;\\n        mp[\\'u\\'] = 4;\\n        \\n        vector<vector<int>> dp(5, vector<int>(n+1, -1));\\n\\t\\t\\n\\t\\t\\t\\t//call for each starting from each vowel after that for changing the character values our recursive call will take care of\\n\\n        long long cnt = f(n, 1, \\'a\\', dp, mp) + f(n, 1, \\'e\\', dp, mp) + f(n, 1, \\'i\\', dp, mp) + f(n, 1, \\'o\\', dp, mp) + f(n, 1, \\'u\\', dp, mp); \\n        \\n        return cnt%MOD;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390729,
                "title": "java-easy-solution-with-explanation-dp",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    private long[][] dp;\\n    private int mod = (int)1e9 + 7;\\n    \\n    public int countVowelPermutation(int n) {\\n        dp = new long[6][n+1];\\n        if(n == 1) return 5;\\n        \\n        for(int i = 0; i < 5; i++)\\n            dp[i][0] = 1;       \\n\\t\\t\\t\\n        helper(n,\\'z\\');        \\n        return (int)dp[5][n];\\n    }\\n    \\n    private long helper(int n, char vowel)\\n    {\\n        long ans = 0;\\n        if(n == 0) return 1;\\n        \\n        if(vowel == \\'z\\') // we are using z for our convenience just to add Permutations of all Vowels\\n        {\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'e\\') + helper(n-1,\\'i\\') + helper(n-1,\\'o\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[5][n] = ans;\\n        }\\n        // from here as per our assumptions of Vowels we will make calls & store results\\n        else if(vowel == \\'a\\') // for Nth number we would store Result for \"a\" in dp[0][n]\\n        {\\n            if(dp[0][n] != 0) return dp[0][n];\\n            ans = (ans + helper(n-1,\\'e\\'))%mod;\\n            dp[0][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'e\\') // for Nth number we would store Result for \"e\" in dp[1][n]\\n        {\\n            if(dp[1][n] != 0) return dp[1][n];\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'i\\'))%mod;\\n            dp[1][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'i\\') // for Nth number we would store Result for \"i\" in dp[2][n]\\n        {\\n            if(dp[2][n] != 0) return dp[2][n];\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'e\\') + helper(n-1,\\'o\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[2][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'o\\') // for Nth number we would store Result for \"o\" in dp[3][n]\\n        {\\n            if(dp[3][n] != 0) return dp[3][n];\\n            ans = (ans + helper(n-1,\\'i\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[3][n] = ans;    \\n        }\\n           \\n        else // for Nth number we would store Result for \"u\" in dp[4][n]\\n        {\\n            if(dp[4][n] != 0) return dp[4][n];\\n            ans = (ans + helper(n-1,\\'a\\'))%mod;\\n            dp[4][n] = ans;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private long[][] dp;\\n    private int mod = (int)1e9 + 7;\\n    \\n    public int countVowelPermutation(int n) {\\n        dp = new long[6][n+1];\\n        if(n == 1) return 5;\\n        \\n        for(int i = 0; i < 5; i++)\\n            dp[i][0] = 1;       \\n\\t\\t\\t\\n        helper(n,\\'z\\');        \\n        return (int)dp[5][n];\\n    }\\n    \\n    private long helper(int n, char vowel)\\n    {\\n        long ans = 0;\\n        if(n == 0) return 1;\\n        \\n        if(vowel == \\'z\\') // we are using z for our convenience just to add Permutations of all Vowels\\n        {\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'e\\') + helper(n-1,\\'i\\') + helper(n-1,\\'o\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[5][n] = ans;\\n        }\\n        // from here as per our assumptions of Vowels we will make calls & store results\\n        else if(vowel == \\'a\\') // for Nth number we would store Result for \"a\" in dp[0][n]\\n        {\\n            if(dp[0][n] != 0) return dp[0][n];\\n            ans = (ans + helper(n-1,\\'e\\'))%mod;\\n            dp[0][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'e\\') // for Nth number we would store Result for \"e\" in dp[1][n]\\n        {\\n            if(dp[1][n] != 0) return dp[1][n];\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'i\\'))%mod;\\n            dp[1][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'i\\') // for Nth number we would store Result for \"i\" in dp[2][n]\\n        {\\n            if(dp[2][n] != 0) return dp[2][n];\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'e\\') + helper(n-1,\\'o\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[2][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'o\\') // for Nth number we would store Result for \"o\" in dp[3][n]\\n        {\\n            if(dp[3][n] != 0) return dp[3][n];\\n            ans = (ans + helper(n-1,\\'i\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[3][n] = ans;    \\n        }\\n           \\n        else // for Nth number we would store Result for \"u\" in dp[4][n]\\n        {\\n            if(dp[4][n] != 0) return dp[4][n];\\n            ans = (ans + helper(n-1,\\'a\\'))%mod;\\n            dp[4][n] = ans;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390336,
                "title": "python-two-solutions-one-programmer",
                "content": "**Solution**:\\nTop-down dp:\\nReduce the problem down to its sub-problem until n is 1. Return 1 when n is 1. Then, sum up counts returned by all sub-problems.\\n![image](https://assets.leetcode.com/users/images/5fc73e4f-e469-4b32-b230-b0bf19a0d8fc_1659841322.2767086.jpeg)\\n\\n    \\nBottom-up dp:\\nInitialize the counts of all vowels to 1. Iterate from 1 to n and add up the counts of vowels based on previous vowels counts.\\n![image](https://assets.leetcode.com/users/images/bba151cf-c1fa-4269-806d-13d3f1631e71_1659841327.3679676.jpeg)\\n\\n\\n**Complexity**:\\n    Time: O(n)\\n    Space: O(n) for top-down and O(1) for bottom-up\\n\\n```\\n# Top-down dp solution\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        # A mapper mapped characters to their next characters\\n        mapper = {\\n            \"\": [\"a\", \"e\", \"i\", \"o\", \"u\"],\\n            \"a\": \"e\",\\n            \"e\": [\"a\", \"i\"],\\n            \"i\": [\"a\", \"e\", \"o\", \"u\"],\\n            \"o\": [\"i\", \"u\"],\\n            \"u\": [\"a\"],\\n        }\\n\\n        @lru_cache(None)\\n        def dp(n, c):\\n\\n            # If n == 1, we have reach base case and thus, return 1\\n            if n == 1:\\n                return 1\\n\\n            # Initialize the total to 0\\n            total = 0\\n\\n            # Recursively solve sub-problems until n is reduced to 1\\n            for char in mapper[c]:\\n                total = (total + dp(n - 1, char)) % 1000000007\\n\\n            return total\\n\\n        # Add 1 to n since we started with empty string instead of recursively called dp on each vowel\\n        return dp(n + 1, \"\")\\n```\\n\\n```\\n# Bottom-up dp solution\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        # Initialize all vowels counts to 1\\n\\t\\t# This is n==1 case\\n        a, e, i, o, u = 1, 1, 1, 1, 1\\n\\n        # Iterate from 2 to n\\n        for _ in range(2, n + 1):\\n            a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n\\n        # Return the sum of all counts of all vowels\\n        return (a + e + i + o + u) % 1000000007\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Top-down dp solution\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        # A mapper mapped characters to their next characters\\n        mapper = {\\n            \"\": [\"a\", \"e\", \"i\", \"o\", \"u\"],\\n            \"a\": \"e\",\\n            \"e\": [\"a\", \"i\"],\\n            \"i\": [\"a\", \"e\", \"o\", \"u\"],\\n            \"o\": [\"i\", \"u\"],\\n            \"u\": [\"a\"],\\n        }\\n\\n        @lru_cache(None)\\n        def dp(n, c):\\n\\n            # If n == 1, we have reach base case and thus, return 1\\n            if n == 1:\\n                return 1\\n\\n            # Initialize the total to 0\\n            total = 0\\n\\n            # Recursively solve sub-problems until n is reduced to 1\\n            for char in mapper[c]:\\n                total = (total + dp(n - 1, char)) % 1000000007\\n\\n            return total\\n\\n        # Add 1 to n since we started with empty string instead of recursively called dp on each vowel\\n        return dp(n + 1, \"\")\\n```\n```\\n# Bottom-up dp solution\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        # Initialize all vowels counts to 1\\n\\t\\t# This is n==1 case\\n        a, e, i, o, u = 1, 1, 1, 1, 1\\n\\n        # Iterate from 2 to n\\n        for _ in range(2, n + 1):\\n            a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n\\n        # Return the sum of all counts of all vowels\\n        return (a + e + i + o + u) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315114,
                "title": "count-vowels-permutation-graph-dp-w-explanation",
                "content": "***\\u2705 Solution 1:(DFS Graph -- Accepted)***\\n***\\n**Approach:**\\n```\\n1) If we carefully observe the conditions, then we came to know that every vowel is connected to some other vowels,\\ni.e, there is some directed edges from one vowel to another.\\n2) Once we are able to come up with directed graph, then we can calculate number of permutations by considering\\neach vowel as the source vertex (i.e, the first Character in permutation) and then traversing the directed graph from \\nthe soure vertex.\\n\\nok, so what is the relation between the vowels,\\nLet\\'s see,\\nWe will map the vowels to numbers:\\n    a:0\\n    e:1\\n    i:2\\n    o:3\\n    u:4\\n\\nSo the directed graph becomes,\\n    a:{e}       or      0->{1}      \\n    e:{a,i}     or      1->{0,2}\\n    i:{a,e,o,u} or      2->{0,1,3,4}\\n    o:{i,u}     or      3->{2,4}\\n    u:{a}       or      4->{0}    \\n```\\n![image](https://assets.leetcode.com/users/images/002ca3a8-dc62-4d45-be85-85df7d8283d4_1625391110.6797729.png)\\n![image](https://assets.leetcode.com/users/images/6733b86d-9914-482f-b28c-d4a22e0a1b80_1625390283.8115134.png) \\n\\n\\n\\n***\\n**C++:**\\n```\\n/*\\nWe will map the vowels to numbers:\\n    a:0\\n    e:1\\n    i:2\\n    o:3\\n    u:4\\n\\nSo the directed graph becomes,\\n    a:{e}       or      0->{1}      \\n    e:{a,i}     or      1->{0,2}\\n    i:{a,e,o,u} or      2->{0,1,3,4}\\n    o:{i,u}     or      3->{2,4}\\n    u:{a}       or      4->{0}    \\n    \\n    \\n*/\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int dp[5][20002];\\n    int add(int a,int b)\\n    {\\n        return (a%mod + b%mod)%mod;\\n    }\\n//     Initialize the graph\\n    vector<vector<int>> graph = { {1}, {0,2}, {0,1,3,4}, {2,4}, {0}};\\n    \\n    int dfs(int src,int n)\\n    {\\n        if(n==1)\\n            return 1;\\n        if(dp[src][n] != -1)\\n            return dp[src][n];\\n        int res=0;\\n        for(auto child:graph[src])\\n            res = add(res, dfs(child,n-1));\\n        return dp[src][n] = res;\\n    }\\n    \\n    int countVowelPermutation(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = 0;\\n        for(int i=0;i<5;i++)\\n            ans = add(ans, dfs(i,n));\\n        return ans;\\n    }\\n};\\n```\\n\\n***\\u2705 Solution 2:(Top Down DP -- Accepted)***\\n***\\n**Approach:**\\n```\\n1) We will try to explore all the possibilities of forming permutation by following the conditions.\\n2) If we have n=3, at every index we can put either of the characters i.e, [a,e,i,o,u]\\n3) But while putting the character at a particular index we will check the character in previous position,\\nand compare it with the given condition,\\n4) If condition satisifies, only after that we will consider the current character at current index, \\nelse we will discard the character,\\n\\nTIME COMPLEXITY: O(N*6)~O(N)\\nSpace Complexity : O(N)\\n```\\n***\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    static const int mod = 1e9+7;\\n    int add(int a,int b)\\n    {\\n        return (a%mod + b%mod)%mod;\\n    }\\n    \\n    int charToIntIndex(char ch)\\n    {\\n        switch(ch)\\n        {\\n            case \\'a\\':\\n                return 0;\\n            case \\'e\\':\\n                return 1;\\n            case \\'i\\':\\n                return 2;\\n            case \\'o\\':\\n                return 3;\\n            case \\'u\\':\\n                return 4;\\n            case \\'#\\':\\n                return 5;\\n        }\\n        // we will never be hitting this case due to conditions mentioned in question.\\n        return 6;\\n    }\\n    int dp[20004][6];\\n    int go(int n,char prev=\\'#\\')\\n    {\\n        if(n==0)\\n            return 1;\\n        if(dp[n][charToIntIndex(prev)]!=-1)\\n            return dp[n][charToIntIndex(prev)];\\n        int res=0;\\n        for(char i:{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'})\\n        {\\n            if(prev==\\'#\\')\\n            {\\n                res=add(res,go(n-1,i));\\n            }\\n            else\\n            {\\n                if(prev==\\'a\\' and i==\\'e\\')\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'e\\' and (i==\\'a\\' or i==\\'i\\'))\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'i\\' and i!=\\'i\\')\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'o\\' and (i==\\'i\\' or i==\\'u\\'))\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'u\\' and i==\\'a\\')\\n                    res=add(res,go(n-1,i));\\n            }\\n        }\\n        return dp[n][charToIntIndex(prev)]=res;\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return go(n);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n1) If we carefully observe the conditions, then we came to know that every vowel is connected to some other vowels,\\ni.e, there is some directed edges from one vowel to another.\\n2) Once we are able to come up with directed graph, then we can calculate number of permutations by considering\\neach vowel as the source vertex (i.e, the first Character in permutation) and then traversing the directed graph from \\nthe soure vertex.\\n\\nok, so what is the relation between the vowels,\\nLet\\'s see,\\nWe will map the vowels to numbers:\\n    a:0\\n    e:1\\n    i:2\\n    o:3\\n    u:4\\n\\nSo the directed graph becomes,\\n    a:{e}       or      0->{1}      \\n    e:{a,i}     or      1->{0,2}\\n    i:{a,e,o,u} or      2->{0,1,3,4}\\n    o:{i,u}     or      3->{2,4}\\n    u:{a}       or      4->{0}    \\n```\n```\\n/*\\nWe will map the vowels to numbers:\\n    a:0\\n    e:1\\n    i:2\\n    o:3\\n    u:4\\n\\nSo the directed graph becomes,\\n    a:{e}       or      0->{1}      \\n    e:{a,i}     or      1->{0,2}\\n    i:{a,e,o,u} or      2->{0,1,3,4}\\n    o:{i,u}     or      3->{2,4}\\n    u:{a}       or      4->{0}    \\n    \\n    \\n*/\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int dp[5][20002];\\n    int add(int a,int b)\\n    {\\n        return (a%mod + b%mod)%mod;\\n    }\\n//     Initialize the graph\\n    vector<vector<int>> graph = { {1}, {0,2}, {0,1,3,4}, {2,4}, {0}};\\n    \\n    int dfs(int src,int n)\\n    {\\n        if(n==1)\\n            return 1;\\n        if(dp[src][n] != -1)\\n            return dp[src][n];\\n        int res=0;\\n        for(auto child:graph[src])\\n            res = add(res, dfs(child,n-1));\\n        return dp[src][n] = res;\\n    }\\n    \\n    int countVowelPermutation(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = 0;\\n        for(int i=0;i<5;i++)\\n            ans = add(ans, dfs(i,n));\\n        return ans;\\n    }\\n};\\n```\n```\\n1) We will try to explore all the possibilities of forming permutation by following the conditions.\\n2) If we have n=3, at every index we can put either of the characters i.e, [a,e,i,o,u]\\n3) But while putting the character at a particular index we will check the character in previous position,\\nand compare it with the given condition,\\n4) If condition satisifies, only after that we will consider the current character at current index, \\nelse we will discard the character,\\n\\nTIME COMPLEXITY: O(N*6)~O(N)\\nSpace Complexity : O(N)\\n```\n```\\nclass Solution {\\npublic:\\n    static const int mod = 1e9+7;\\n    int add(int a,int b)\\n    {\\n        return (a%mod + b%mod)%mod;\\n    }\\n    \\n    int charToIntIndex(char ch)\\n    {\\n        switch(ch)\\n        {\\n            case \\'a\\':\\n                return 0;\\n            case \\'e\\':\\n                return 1;\\n            case \\'i\\':\\n                return 2;\\n            case \\'o\\':\\n                return 3;\\n            case \\'u\\':\\n                return 4;\\n            case \\'#\\':\\n                return 5;\\n        }\\n        // we will never be hitting this case due to conditions mentioned in question.\\n        return 6;\\n    }\\n    int dp[20004][6];\\n    int go(int n,char prev=\\'#\\')\\n    {\\n        if(n==0)\\n            return 1;\\n        if(dp[n][charToIntIndex(prev)]!=-1)\\n            return dp[n][charToIntIndex(prev)];\\n        int res=0;\\n        for(char i:{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'})\\n        {\\n            if(prev==\\'#\\')\\n            {\\n                res=add(res,go(n-1,i));\\n            }\\n            else\\n            {\\n                if(prev==\\'a\\' and i==\\'e\\')\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'e\\' and (i==\\'a\\' or i==\\'i\\'))\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'i\\' and i!=\\'i\\')\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'o\\' and (i==\\'i\\' or i==\\'u\\'))\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'u\\' and i==\\'a\\')\\n                    res=add(res,go(n-1,i));\\n            }\\n        }\\n        return dp[n][charToIntIndex(prev)]=res;\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return go(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506516,
                "title": "c-o-n-time-o-1-space-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\tlong a=1,e=1,i=1,o=1,u=1;\\n\\t\\t\\tint mod=1e9+7;\\n\\t\\t\\tfor(int j=2;j<=n;j++){\\n\\t\\t\\t\\tlong A=(e+u+i)%mod;\\n\\t\\t\\t\\tlong E=(a+i)%mod;\\n\\t\\t\\t\\tlong I=(e+o)%mod;\\n\\t\\t\\t\\tlong O=i%mod;\\n\\t\\t\\t\\tlong U=(o+i)%mod;\\n\\t\\t\\t\\ta=A;\\n\\t\\t\\t\\te=E;\\n\\t\\t\\t\\ti=I;\\n\\t\\t\\t\\to=O;\\n\\t\\t\\t\\tu=U;\\n\\t\\t\\t}\\n\\t\\t\\treturn (a+e+i+o+u)%mod;\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\tlong a=1,e=1,i=1,o=1,u=1;\\n\\t\\t\\tint mod=1e9+7;\\n\\t\\t\\tfor(int j=2;j<=n;j++){\\n\\t\\t\\t\\tlong A=(e+u+i)%mod;\\n\\t\\t\\t\\tlong E=(a+i)%mod;\\n\\t\\t\\t\\tlong I=(e+o)%mod;\\n\\t\\t\\t\\tlong O=i%mod;\\n\\t\\t\\t\\tlong U=(o+i)%mod;\\n\\t\\t\\t\\ta=A;\\n\\t\\t\\t\\te=E;\\n\\t\\t\\t\\ti=I;\\n\\t\\t\\t\\to=O;\\n\\t\\t\\t\\tu=U;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2391945,
                "title": "java-simple-and-clean",
                "content": "**Explantion :**\\n\\nwe can create Lenght N strings from Length N-1 string by applying the defined rules to it.\\n\\nStrings that have ended in \"a\" can only create strings with \"e\" ending.\\nStrings that have ended in \"e\" can create strings ending with \"a\"  or \"i\"\\n.....\\n\\n\\nThis way we can say that at next step how many strings we would have that ends in each vowel.\\nWe keep a track of endings at each step and go to the next step till we find the desired length.\\n\\n\\nI hope this solution is helpful to you.\\n**I really appericate if you could give me an upvote.** <3\\n\\n**Solution :**\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[] vowels = new long[5];\\n        Arrays.fill(vowels, 1);\\n        int mod = (int) (Math.pow(10, 9) + 7);\\n        while (n > 1) {\\n            long[] temp = new long[5];\\n            temp[0] = (vowels[1] + vowels[2] + vowels[4]) % mod;\\n            temp[1] = vowels[0] + vowels[2] % mod;\\n            temp[2] = vowels[1] + vowels[3] % mod;\\n            temp[3] = vowels[2] % mod;\\n            temp[4] = vowels[2] + vowels[3] % mod;\\n            vowels = temp;\\n            n--;\\n        }\\n        return (int) ((vowels[0] + vowels[1] + vowels[2] + vowels[3] + vowels[4]) % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[] vowels = new long[5];\\n        Arrays.fill(vowels, 1);\\n        int mod = (int) (Math.pow(10, 9) + 7);\\n        while (n > 1) {\\n            long[] temp = new long[5];\\n            temp[0] = (vowels[1] + vowels[2] + vowels[4]) % mod;\\n            temp[1] = vowels[0] + vowels[2] % mod;\\n            temp[2] = vowels[1] + vowels[3] % mod;\\n            temp[3] = vowels[2] % mod;\\n            temp[4] = vowels[2] + vowels[3] % mod;\\n            vowels = temp;\\n            n--;\\n        }\\n        return (int) ((vowels[0] + vowels[1] + vowels[2] + vowels[3] + vowels[4]) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390614,
                "title": "c-easy-to-undestand-memoization-proper-explanantion",
                "content": "**Approach:-** This is the simple question based on the **dynamic programming memoization approch**.\\n-->This question is based on picking the vowels charecters by taking care of Previous taken charecter.\\n-->Based on the Previous taken chatecter value we will make decison for whhich value we will take this time ,according to given condition.\\n\\n-->Insted of taking charecter we will take values from 1 to 5,for charecter integral representation.\\n-->Dp state variable are Pre and count.\\n-->Pre will help us in taking care of previous taken value.\\n-->Count will keep count of the length of the string we have formed.\\n-->If count become n ,then this is the one of the way to form string.(Base condition of recursive function solve).\\n\\n**-->Time Complexity:- O(n*5).**\\n**-->Space Complexity:-O(n*6).**\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int Pre,int count,int &n,vector<vector<int>>&dp)\\n    {\\n        if(count==n)//Base Condition:- If count become n ,then this is the one of the way to form string.\\n            return 1;\\n        \\n        if(dp[count][Pre]!=-1) return dp[count][Pre]%mod;//Memoization\\n        int ans=0;\\n        for(int i=1;i<=5;i++)\\n        {\\n            if(Pre==1 && i==2) //If previous taken is a\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==2 && (i==1 || i==3)) //If previous is e\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==3 && i!=3) //If previous taken is i\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==4 && (i==3 || i==5)) //If previous taken is o\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==5 && i==1) //If previous taken is u.\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n        }\\n        return dp[count][Pre]=ans%mod; //store the value in Dp table.\\n    }\\n    int countVowelPermutation(int n) {\\n        \\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(6,-1)); //Dp table:- Initially all values is -1;\\n        for(int i=1;i<=5;i++)\\n        {\\n         ans= (ans%mod + solve(i,1,n,dp)%mod)%mod; //Call function solve for every vowel taking 1st place.\\n        }\\n        \\n        return ans%mod; // return ans;\\n    }\\n};\\n```\\nI**f you find it helpful . Please upvote.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int Pre,int count,int &n,vector<vector<int>>&dp)\\n    {\\n        if(count==n)//Base Condition:- If count become n ,then this is the one of the way to form string.\\n            return 1;\\n        \\n        if(dp[count][Pre]!=-1) return dp[count][Pre]%mod;//Memoization\\n        int ans=0;\\n        for(int i=1;i<=5;i++)\\n        {\\n            if(Pre==1 && i==2) //If previous taken is a\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==2 && (i==1 || i==3)) //If previous is e\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==3 && i!=3) //If previous taken is i\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==4 && (i==3 || i==5)) //If previous taken is o\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==5 && i==1) //If previous taken is u.\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n        }\\n        return dp[count][Pre]=ans%mod; //store the value in Dp table.\\n    }\\n    int countVowelPermutation(int n) {\\n        \\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(6,-1)); //Dp table:- Initially all values is -1;\\n        for(int i=1;i<=5;i++)\\n        {\\n         ans= (ans%mod + solve(i,1,n,dp)%mod)%mod; //Call function solve for every vowel taking 1st place.\\n        }\\n        \\n        return ans%mod; // return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398453,
                "title": "my-screencast",
                "content": "https://www.youtube.com/watch?v=-tyZnoKU7qs&feature=youtu.be",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=-tyZnoKU7qs&feature=youtu.be",
                "codeTag": "Unknown"
            },
            {
                "id": 2393137,
                "title": "simple-short-explained-solution",
                "content": "**YOU CAN WATCH THIS VIDEO FOR THE EXPLANATION**\\n\\nhttps://www.youtube.com/watch?v=EveRd84f8NM\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 870640,
                "title": "simple-100-faster-than-other-c-with-runtime-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        unsigned long long int a=1,e=1,i=1,o=1,u=1;\\n        unsigned long long int updated_a,updated_e,updated_i,updated_o,updated_u;\\n        for(int ind=2;ind<=n;ind++)\\n        {\\n            updated_a=(e);     // modulo dividing is to handle large values\\n            updated_e=(a+i)%1000000007;\\n            updated_i=(a+e+u+o)%1000000007;\\n            updated_o=(i+u)%1000000007;\\n            updated_u=(a);\\n         \\n            a=updated_a;                   //updating a,e,i,o,u value for each iteration\\n            e=updated_e;\\n            i=updated_i;\\n            o=updated_o;\\n            u=updated_u;\\n        }\\n        return (a+e+i+o+u)%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        unsigned long long int a=1,e=1,i=1,o=1,u=1;\\n        unsigned long long int updated_a,updated_e,updated_i,updated_o,updated_u;\\n        for(int ind=2;ind<=n;ind++)\\n        {\\n            updated_a=(e);     // modulo dividing is to handle large values\\n            updated_e=(a+i)%1000000007;\\n            updated_i=(a+e+u+o)%1000000007;\\n            updated_o=(i+u)%1000000007;\\n            updated_u=(a);\\n         \\n            a=updated_a;                   //updating a,e,i,o,u value for each iteration\\n            e=updated_e;\\n            i=updated_i;\\n            o=updated_o;\\n            u=updated_u;\\n        }\\n        return (a+e+i+o+u)%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398177,
                "title": "short-python-dp-solution",
                "content": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n        prevs = {\\'a\\':1, \\'e\\':1, \\'i\\':1, \\'o\\':1, \\'u\\':1}\\n        for i in range(1, n):\\n            cur = defaultdict(int)\\n            for prev, count in prevs.items():\\n                if prev == \\'a\\':\\n                    cur[\\'e\\'] += count\\n                elif prev == \\'e\\':\\n                    for nextch in [\\'a\\', \\'i\\']:\\n                        cur[nextch] += count\\n                elif prev == \\'i\\':\\n                    for nextch in [\\'a\\', \\'e\\', \\'o\\', \\'u\\']:\\n                        cur[nextch] += count \\n                elif prev == \\'o\\':\\n                    for nextch in [\\'i\\', \\'u\\']:\\n                        cur[nextch] += count\\n                elif prev == \\'u\\':\\n                    cur[\\'a\\'] += count\\n            prevs = cur\\n        return sum(prevs.values()) % 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n        prevs = {\\'a\\':1, \\'e\\':1, \\'i\\':1, \\'o\\':1, \\'u\\':1}\\n        for i in range(1, n):\\n            cur = defaultdict(int)\\n            for prev, count in prevs.items():\\n                if prev == \\'a\\':\\n                    cur[\\'e\\'] += count\\n                elif prev == \\'e\\':\\n                    for nextch in [\\'a\\', \\'i\\']:\\n                        cur[nextch] += count\\n                elif prev == \\'i\\':\\n                    for nextch in [\\'a\\', \\'e\\', \\'o\\', \\'u\\']:\\n                        cur[nextch] += count \\n                elif prev == \\'o\\':\\n                    for nextch in [\\'i\\', \\'u\\']:\\n                        cur[nextch] += count\\n                elif prev == \\'u\\':\\n                    cur[\\'a\\'] += count\\n            prevs = cur\\n        return sum(prevs.values()) % 1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 404441,
                "title": "why-not-binary-matrix-exponentiation",
                "content": "Indexing vowels such as `v = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}`, let\\'s say `a[i][j]` represents number of words of length `i` starting with the letter `v[j]`. The rule is \\n`a[i + 1] = M * a[i]`, where `*` means matrix multiplication, and\\n```\\nM = [0, 1, 0, 0, 0,\\n\\t1, 0, 1, 0, 0,\\n\\t1, 1, 0, 1, 1,\\n\\t0, 0, 1, 0, 1,\\n\\t1, 0, 0, 0, 0]\\n``` \\nas follows from the statement. So we need to multiply `M^{n - 1}` by the initial vector `a[1] = [1, 1, 1, 1, 1]` to get `a[n]` and then count its sum. Fast matrix exponentiation computes `M^{n - 1}` in `O(log n)` time complexity.\\n`log n < 15` in task constraints, and even with matrix multiplication in `5 ^ 3 = 125` , which is not a small constant, total algorithm is faster than any dynamic approach taking linear time complexity.",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nM = [0, 1, 0, 0, 0,\\n\\t1, 0, 1, 0, 0,\\n\\t1, 1, 0, 1, 1,\\n\\t0, 0, 1, 0, 1,\\n\\t1, 0, 0, 0, 0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 398224,
                "title": "easy-peasy-python-o-logn-matrix-rank",
                "content": "\\t\\nIn this question, first we create matrix which represents whether I can go from any vowel to any other vowel. Now, we know that rank of the matrix can tell in how many ways I can go from one vowel to the other vowels after n jumps.\\n\\nMore explanation here:\\nhttps://math.stackexchange.com/questions/1890620/finding-path-lengths-by-the-power-of-adjacency-matrix-of-an-undirected-graph\\n\\t\\n\\timport numpy as np\\n\\tclass Solution:\\n\\t\\tdef countVowelPermutation(self, n: int) -> int:        \\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tif n == 1: return 5\\n\\t\\t\\tM = np.matrix([[0, 1, 0, 0, 0], [1, 0, 1, 0, 0], [1,1,0,1,1], [0,0,1,0,1], [1,0,0,0,0]])\\n\\n\\t\\t\\tres = 1\\n\\t\\t\\tN = n - 1\\n\\t\\t\\twhile N > 0:\\n\\t\\t\\t\\tif N % 2: \\n\\t\\t\\t\\t\\tres = res * M % mod\\n\\n\\t\\t\\t\\tM = M * M % mod\\n\\n\\t\\t\\t\\tN //= 2\\n\\n\\t\\t\\treturn int(np.sum(res)) % mod",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "\\t\\nIn this question, first we create matrix which represents whether I can go from any vowel to any other vowel. Now, we know that rank of the matrix can tell in how many ways I can go from one vowel to the other vowels after n jumps.\\n\\nMore explanation here:\\nhttps://math.stackexchange.com/questions/1890620/finding-path-lengths-by-the-power-of-adjacency-matrix-of-an-undirected-graph\\n\\t\\n\\timport numpy as np\\n\\tclass Solution:\\n\\t\\tdef countVowelPermutation(self, n: int) -> int:        \\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tif n == 1: return 5\\n\\t\\t\\tM = np.matrix([[0, 1, 0, 0, 0], [1, 0, 1, 0, 0], [1,1,0,1,1], [0,0,1,0,1], [1,0,0,0,0]])\\n\\n\\t\\t\\tres = 1\\n\\t\\t\\tN = n - 1\\n\\t\\t\\twhile N > 0:\\n\\t\\t\\t\\tif N % 2: \\n\\t\\t\\t\\t\\tres = res * M % mod\\n\\n\\t\\t\\t\\tM = M * M % mod\\n\\n\\t\\t\\t\\tN //= 2\\n\\n\\t\\t\\treturn int(np.sum(res)) % mod",
                "codeTag": "Java"
            },
            {
                "id": 1314992,
                "title": "c-simple-and-short-solution-o-n-tc-o-1-sc-0ms-faster-than-100",
                "content": "We use variables to save the number of strings ending with that letter.\\nWe check the rules and see for each letter after which letter it can appear.\\nWe use the second variables because we have to update in parallel.\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390077,
                "title": "99-63-faster-python3-solution",
                "content": "![image](https://assets.leetcode.com/users/images/31b5b3f8-ce32-48c0-adda-2f0e6022f2c3_1659832065.6120718.png)\\n\\n**Success Details: **\\n*Runtime: 65 ms, faster than 99.63% of Python3 online submissions for Count Vowels Permutation.\\nMemory Usage: 14 MB, less than 80.85% of Python3 online submissions for Count Vowels Permutation.*\\n\\ncode: \\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        MOD =  pow(10,9) + 7\\n        def multiply(a, b):\\n            \\n            result = [ [0] * len(b[0]) for _ in range(len(a))]\\n#           This is just simple matrix multiplicaiton\\n            for i in range(len(a)):\\n                for j in range(len(b[0])):\\n                    for k in range(len(a[0])):\\n                        result[i][j] += (a[i][k] * b[k][j]) % MOD\\n                        result[i][j] %= MOD\\n            return result\\n        \\n        \\n        adjacency_matrix = [\\n            [0,1,0,0,0],\\n            [1,0,1,0,0],\\n            [1,1,0,1,1],\\n            [0,0,1,0,1],\\n            [1,0,0,0,0]\\n        ]\\n        \\n        result = [[0]*5 for _ in range(5)]\\n        for i in range(5):\\n            result[i][i] = 1\\n        \\n        s = 0\\n        n -= 1\\n        while n:\\n            if n & 1:\\n                result = multiply(adjacency_matrix,result)\\n            n >>= 1\\n            adjacency_matrix = multiply(adjacency_matrix,adjacency_matrix)\\n        \\n        for i in range(5):\\n            s += sum(result[i])\\n        \\n        return s % MOD \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        MOD =  pow(10,9) + 7\\n        def multiply(a, b):\\n            \\n            result = [ [0] * len(b[0]) for _ in range(len(a))]\\n#           This is just simple matrix multiplicaiton\\n            for i in range(len(a)):\\n                for j in range(len(b[0])):\\n                    for k in range(len(a[0])):\\n                        result[i][j] += (a[i][k] * b[k][j]) % MOD\\n                        result[i][j] %= MOD\\n            return result\\n        \\n        \\n        adjacency_matrix = [\\n            [0,1,0,0,0],\\n            [1,0,1,0,0],\\n            [1,1,0,1,1],\\n            [0,0,1,0,1],\\n            [1,0,0,0,0]\\n        ]\\n        \\n        result = [[0]*5 for _ in range(5)]\\n        for i in range(5):\\n            result[i][i] = 1\\n        \\n        s = 0\\n        n -= 1\\n        while n:\\n            if n & 1:\\n                result = multiply(adjacency_matrix,result)\\n            n >>= 1\\n            adjacency_matrix = multiply(adjacency_matrix,adjacency_matrix)\\n        \\n        for i in range(5):\\n            s += sum(result[i])\\n        \\n        return s % MOD \\n```",
                "codeTag": "Java"
            },
            {
                "id": 526467,
                "title": "python-o-1-aux-space-by-dp-70-w-comment",
                "content": "Python O(1) aux space by DP.\\n\\n---\\n\\n**Hint**:\\n\\nBuild a bottom-up dynamic programming with the **transition rule** defined in [description.](https://leetcode.com/problems/count-vowels-permutation/)\\n\\nEach character is a lower case vowel (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n\\nEach vowel \\'**a**\\' may only be followed by an \\'**e**\\'.\\n\\nEach vowel \\'**e**\\' may only be followed by an \\'**a**\\' or an \\'**i**\\'.\\n\\nEach vowel \\'**i**\\' may **not** be followed by another \\'**i**\\'.\\n\\nEach vowel \\'**o**\\' may only be followed by an \\'**i**\\' or a \\'**u**\\'.\\n\\nEach vowel \\'**u**\\' may only be followed by an \\'**a**\\'.\\n\\n---\\n\\n**Optimal substructure**:\\nNext permutation ending with \\'**a**\\' = current permutation ending with \\'**e**\\' + current permutation ending with \\'**i**\\' + current permutation ending with \\'**u**\\'.\\n\\nNext permutation ending with \\'**e**\\' = current permutation ending with \\'**a**\\' + current permutation ending with \\'**i**\\'.\\n\\nNext permutation ending with \\'**i**\\' = current permutation ending with \\'**e**\\' + current permutation ending with \\'**o**\\'.\\n\\nNext permutation ending with \\'**o**\\' = current permutation ending with \\'**i**\\'.\\n\\nNext permutation ending with \\'**u**\\' = current permutation ending with \\'**i**\\' + current permutation ending with \\'**o**\\'.\\n\\n---\\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        modulo = 10**9 + 7\\n        \\n        # initialization for length of permutation = 1\\n        (a, e, i, o, u) = (1, 1, 1, 1, 1)\\n        \\n        length_of_permutation = 2\\n        while length_of_permutation <= n:\\n            \\n            # update total method count by transition rule\\n            end_with_a = e + i + u\\n    \\n            end_with_e = a + i\\n\\n            end_with_i = e + o\\n           \\n            end_with_o = i\\n   \\n            end_with_u = i + o\\n\\t\\t\\t\\n\\t\\t\\t# update method count of ending with a e i o u\\n            (a, e, i, o, u) = (end_with_a, end_with_e, end_with_i, end_with_o, end_with_u )\\n            \\n        \\n            length_of_permutation += 1\\n        \\n\\n        return (a + e + i + o + u) % modulo\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        modulo = 10**9 + 7\\n        \\n        # initialization for length of permutation = 1\\n        (a, e, i, o, u) = (1, 1, 1, 1, 1)\\n        \\n        length_of_permutation = 2\\n        while length_of_permutation <= n:\\n            \\n            # update total method count by transition rule\\n            end_with_a = e + i + u\\n    \\n            end_with_e = a + i\\n\\n            end_with_i = e + o\\n           \\n            end_with_o = i\\n   \\n            end_with_u = i + o\\n\\t\\t\\t\\n\\t\\t\\t# update method count of ending with a e i o u\\n            (a, e, i, o, u) = (end_with_a, end_with_e, end_with_i, end_with_o, end_with_u )\\n            \\n        \\n            length_of_permutation += 1\\n        \\n\\n        return (a + e + i + o + u) % modulo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390060,
                "title": "c-top-down-dfs-dp-dry-compliant",
                "content": "Solved LIVE ON twitch.  Everyday 6pm PT. Except for saturdays (4pm PT).  Link in profile.\\n\\n\\n```\\nclass Solution {\\n    int MOD = 1e9+7;\\n    int dfs(int n, char last, vector<vector<int>>& memo) {\\n        if(n == 0) return 1;\\n        \\n        if(memo[n][last] != -1) return memo[n][last];\\n        int total = 0;\\n        if(last == \\'a\\') {\\n            total = (total + dfs(n-1, \\'e\\', memo)) % MOD ;\\n        } else if(last == \\'e\\') {\\n            total = (total + dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n        } else if(last == \\'i\\') {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'e\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'o\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        } else if(last == \\'o\\') {\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        } else if(last == \\'u\\') {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n        } else {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'e\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'o\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        }\\n        \\n        return memo[n][last] = total;\\n    }\\n    \\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> memo(n+1, vector<int>(130, -1));\\n        return dfs(n, \\'.\\', memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = 1e9+7;\\n    int dfs(int n, char last, vector<vector<int>>& memo) {\\n        if(n == 0) return 1;\\n        \\n        if(memo[n][last] != -1) return memo[n][last];\\n        int total = 0;\\n        if(last == \\'a\\') {\\n            total = (total + dfs(n-1, \\'e\\', memo)) % MOD ;\\n        } else if(last == \\'e\\') {\\n            total = (total + dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n        } else if(last == \\'i\\') {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'e\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'o\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        } else if(last == \\'o\\') {\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        } else if(last == \\'u\\') {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n        } else {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'e\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'o\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        }\\n        \\n        return memo[n][last] = total;\\n    }\\n    \\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> memo(n+1, vector<int>(130, -1));\\n        return dfs(n, \\'.\\', memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400370,
                "title": "java-dp-solution-recursive-iterative",
                "content": "Once you find how every vowel can be generated depending on existing vowels, it could be straightforward to get this formula:\\n\\n`a` = `e` + `i` + `u`\\n`e` = `a` + `i`\\n`i` = `e` + `o`\\n`o` = `i`\\n`u` = `i` + `o`\\n\\nGet new result based on previous step, which is a classic DP problem.\\n\\n**Recursive:**\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        long sum = 0;\\n        long[] v = new long[]{1, 1, 1, 1, 1}; // a-0, e-1, i-2, o-3, u-4\\n        for (long i : iterate(v, n - 1)) \\n            sum = (sum + i) % mod;\\n        return (int) sum;\\n    }\\n    \\n    public long[] iterate(long[] v, int n) {\\n        if (n == 0) return v;\\n        long[] v1 = new long[5];\\n        v1[0] = (v[1] + v[2] + v[4]) % mod;\\n        v1[1] = (v[0] + v[2]) % mod;\\n        v1[2] = (v[1] + v[3]) % mod;\\n        v1[3] = v[2];\\n        v1[4] = (v[2] + v[3]) % mod;\\n        return iterate(v1, n - 1);\\n    }\\n}\\n```\\n\\n**Iterative:**\\n```\\npublic int countVowelPermutation(int n) {\\n    int mod = 1000000007;\\n    long sum = 0;\\n    long[] v = new long[]{1, 1, 1, 1, 1}; // a-0, e-1, i-2, o-3, u-4\\n    for (int i = 1; i < n; i++) {\\n        long[] v1 = new long[5];\\n        v1[0] = (v[1] + v[2] + v[4]) % mod;\\n        v1[1] = (v[0] + v[2]) % mod;\\n        v1[2] = (v[1] + v[3]) % mod;\\n        v1[3] = v[2];\\n        v1[4] = (v[2] + v[3]) % mod;\\n        v = v1;\\n    }\\n    for (long i : v) \\n        sum = (sum + i) % mod;\\n    return (int) sum;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        long sum = 0;\\n        long[] v = new long[]{1, 1, 1, 1, 1}; // a-0, e-1, i-2, o-3, u-4\\n        for (long i : iterate(v, n - 1)) \\n            sum = (sum + i) % mod;\\n        return (int) sum;\\n    }\\n    \\n    public long[] iterate(long[] v, int n) {\\n        if (n == 0) return v;\\n        long[] v1 = new long[5];\\n        v1[0] = (v[1] + v[2] + v[4]) % mod;\\n        v1[1] = (v[0] + v[2]) % mod;\\n        v1[2] = (v[1] + v[3]) % mod;\\n        v1[3] = v[2];\\n        v1[4] = (v[2] + v[3]) % mod;\\n        return iterate(v1, n - 1);\\n    }\\n}\\n```\n```\\npublic int countVowelPermutation(int n) {\\n    int mod = 1000000007;\\n    long sum = 0;\\n    long[] v = new long[]{1, 1, 1, 1, 1}; // a-0, e-1, i-2, o-3, u-4\\n    for (int i = 1; i < n; i++) {\\n        long[] v1 = new long[5];\\n        v1[0] = (v[1] + v[2] + v[4]) % mod;\\n        v1[1] = (v[0] + v[2]) % mod;\\n        v1[2] = (v[1] + v[3]) % mod;\\n        v1[3] = v[2];\\n        v1[4] = (v[2] + v[3]) % mod;\\n        v = v1;\\n    }\\n    for (long i : v) \\n        sum = (sum + i) % mod;\\n    return (int) sum;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392315,
                "title": "python-o-n-tc-o-1-sc-faster-than-99",
                "content": "The problem should indeed be Easy-Mid, as there\\'s nothing difficult about it.\\n\\nYou have rules for letters following each other:\\n```\\na -> e\\ne -> [a, i]\\ni -> [a, e, o, u]\\no -> [i, u]\\nu -> [a]\\n```\\n\\nThis basically means that you can apply the DP approach, start with strings of length 1 (one possible permutation for each letter, five together), and then keep separate track of number of permutations for strings of length `l` depending on which letter they start. Finally, when `l` equals `n`, you just sum the separate permutations together, thus achieving the required result.\\n\\nOne key thing to note is that you don\\'t need to keep the whole DP array, as on each step you only refer to the previous step. So space complexity can be reduced to O(1).\\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = 1\\n        e = 1\\n        i = 1\\n        o = 1\\n        u = 1\\n        BIG_VAL = 1000000007\\n\\n        n -= 1\\n\\n        while n:\\n            new_a = e\\n            new_e = (a + i) % BIG_VAL\\n            new_i = (a + e + o + u) % BIG_VAL\\n            new_o = (i + u) % BIG_VAL\\n            new_u = a\\n\\n            a = new_a\\n            e = new_e\\n            i = new_i\\n            o = new_o\\n            u = new_u\\n\\n            n -= 1\\n        \\n        return (a + e + i + o + u) % BIG_VAL\\n```\\nPlease upvote the post if you found it useful \\uD83D\\uDE04",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\na -> e\\ne -> [a, i]\\ni -> [a, e, o, u]\\no -> [i, u]\\nu -> [a]\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = 1\\n        e = 1\\n        i = 1\\n        o = 1\\n        u = 1\\n        BIG_VAL = 1000000007\\n\\n        n -= 1\\n\\n        while n:\\n            new_a = e\\n            new_e = (a + i) % BIG_VAL\\n            new_i = (a + e + o + u) % BIG_VAL\\n            new_o = (i + u) % BIG_VAL\\n            new_u = a\\n\\n            a = new_a\\n            e = new_e\\n            i = new_i\\n            o = new_o\\n            u = new_u\\n\\n            n -= 1\\n        \\n        return (a + e + i + o + u) % BIG_VAL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391513,
                "title": "c-0ms-fast-than-100-no-dp-created-comments-added",
                "content": "Please upvote if you found it helpful :)\\n```\\nint countVowelPermutation(int n) {\\n\\tlong long int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1e9 + 7;\\n\\tfor (int k = 2; k <= n; k++) {\\n\\t\\t// these new variables store the prev values for each of the vowels\\n\\t\\tlong long int ta = a, ti = i, te = e, to = o, tu = u;\\n\\t\\t\\n\\t\\t// using the previous values of vowels, I get the new values of each increased length\\n\\t\\ta = te;\\n\\t\\te = ta + ti;\\n\\t\\ti = ta + te + to + tu;\\n\\t\\to = ti + tu;\\n\\t\\tu = ta;\\n\\t\\t\\n\\t\\t// to keep the range to not exceed 1e9+7, we do mod for each of the value \\n\\t\\ta %= mod, e %= mod, i %= mod, o %= mod, u %= mod;\\n\\t}\\n\\treturn (a + e + i + o + u) % mod;\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/7d8e65e4-42eb-42fc-af8e-f26f7b272b9a_1659853169.8933198.png)\\nLet me know if you need a detailed explanation on this.\\n",
                "solutionTags": [],
                "code": "```\\nint countVowelPermutation(int n) {\\n\\tlong long int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1e9 + 7;\\n\\tfor (int k = 2; k <= n; k++) {\\n\\t\\t// these new variables store the prev values for each of the vowels\\n\\t\\tlong long int ta = a, ti = i, te = e, to = o, tu = u;\\n\\t\\t\\n\\t\\t// using the previous values of vowels, I get the new values of each increased length\\n\\t\\ta = te;\\n\\t\\te = ta + ti;\\n\\t\\ti = ta + te + to + tu;\\n\\t\\to = ti + tu;\\n\\t\\tu = ta;\\n\\t\\t\\n\\t\\t// to keep the range to not exceed 1e9+7, we do mod for each of the value \\n\\t\\ta %= mod, e %= mod, i %= mod, o %= mod, u %= mod;\\n\\t}\\n\\treturn (a + e + i + o + u) % mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391126,
                "title": "count-vowels-permutation-using-dynamic-programming-tc-o-n-daily-leetcoding-day7-aug22",
                "content": "![image](https://assets.leetcode.com/users/images/6634c7a6-bc17-433b-a5d1-943ba14adc5d_1659849068.4076242.jpeg)\\n# **KeyPoint : We are making the string backwards.**\\n**Suppose we want to make a string of size k;\\nthen \\'a\\' can be added at with all the string of size (k-1) starting with \\'e\\';\\nsimilarly \\'e\\' with all string of size (k-1) starting with \\'a\\' and \\'i\\';\\nsimilarly \\'i\\' with \\'a\\',\\'e\\',\\'o\\',\\'u\\';\\nand \\'o\\' with \\'i\\' & \\'u\\'\\nand \\'u\\' with \\'a\\'**\\n\\n**Code Section:**\\n```\\nconst unsigned int m = 1000000007;\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n       if(n==1)\\n           return 5;\\n        \\n       vector<int> v(5,1);int ans=0;\\n       while(n-1)\\n       {\\n          vector<int> temp(5,0);\\n          for(int i=0;i<5;i++)\\n              temp[i]=v[i];\\n          \\n          v[4]=temp[0]%m;\\n          v[3]=(temp[2]%m+temp[4]%m)%m;\\n          v[2]=(temp[0]%m+temp[1]%m+temp[3]%m+temp[4]%m)%m;\\n          v[1]=(temp[0]%m+temp[2]%m)%m;\\n          v[0]=(temp[1]%m);\\n          n--;\\n          \\n          if(n-1==0)\\n              for(auto &x:v){\\n                  ans+=x%m;\\n                  ans%=m;\\n              }\\n\\n          \\n       }\\n       return ans%m;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n       if(n==1)\\n           return 5;\\n        \\n       vector<int> v(5,1);int ans=0;\\n       while(n-1)\\n       {\\n          vector<int> temp(5,0);\\n          for(int i=0;i<5;i++)\\n              temp[i]=v[i];\\n          \\n          v[4]=temp[0]%m;\\n          v[3]=(temp[2]%m+temp[4]%m)%m;\\n          v[2]=(temp[0]%m+temp[1]%m+temp[3]%m+temp[4]%m)%m;\\n          v[1]=(temp[0]%m+temp[2]%m)%m;\\n          v[0]=(temp[1]%m);\\n          n--;\\n          \\n          if(n-1==0)\\n              for(auto &x:v){\\n                  ans+=x%m;\\n                  ans%=m;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 2390017,
                "title": "daily-leetcoding-challenge-august-day-7",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/count-vowels-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up) with Optimized Space\n\n  \n**Approach 3:** Dynamic Programming (Top-down, Recursion)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/count-vowels-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 1:** Dynamic Programming (Bottom-up)\n**Approach 2:** Dynamic Programming (Bottom-up) with Optimized Space\n**Approach 3:** Dynamic Programming (Top-down, Recursion)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1315096,
                "title": "c-dp-solution-explained-100-time-98-space",
                "content": "The problem is tricky because it might tempt you to do some backtracking DFS magic, but given the possible size of `n`, you might not exactly be set for success with this approach.\\n\\nA better one comes from storing previous results - one from each letter: we will build our `dp` matrix in this guise, with the first index (the row one) representing the length of the current permutation minus `1` (since we will use a `0` indexed matrix) and the second one (the column) representing the last number in it (normalising the `\"aeiou\"` range into a `0 - 4` one), so for example `dp[7][3]` will represent all the permutations of `8` characters we can have terminating with the letter `o`.\\n\\nWe are then going to create a `dp` matrix with `n` rows and `5` columns and set the very first column values all to `1` (ie: using only one number, you can have only one combination).\\n\\nLooping `n - 1` times, we can iteratively compute all the other values, with the following approach, according to the specs:\\n* `prev` is always going to be the current index minus `1`;\\n* `\\'a\\'` can only follow `\\'e\\'`, `\\'i\\'` and `\\'u\\'`, so we will have that `dp[i][0] = moduloReduce(dp[prev][1] + dp[prev][2] + dp[prev][4])`;\\n* `\\'e\\'` can only follow `\\'a\\'`, and `\\'i\\'`, so we will have that `dp[i][1] = moduloReduce(dp[prev][0] + dp[prev][2])`;\\n* `\\'i\\'` can only follow `\\'e\\'`, and `\\'o\\'`, so we will have that `dp[i][2] = moduloReduce(dp[prev][1] + dp[prev][3])`;\\n* `\\'o\\'` can only follow `\\'i\\'`, so we will have that `dp[i][3] = dp[prev][2]` (notice we do not even need to call `moduloReduce` for this one);\\n* `\\'u\\'` can only follow `\\'i\\'` and `\\'o\\'`, so we will have that `dp[i][4] = moduloReduce(dp[prev][2] + dp[prev][3])`.\\n\\nNow, a few words on `moduloReduce`: this function takes a number `n` and while it is `>= modVal`, it just subtract this value from `n` - that is actually cheaper ([in this case](https://leetcode.com/problems/count-vowels-permutation/discuss/1315096/C++-DP-Solution-Explained-100-Time-~98-Space/997684)) than calling the modulo operator on it all the time!\\n\\nOnce done, we sum the partial results of the last column, again calling `moduloReduce` on said sum and we are done :)\\n\\nThe code:\\n\\n```cpp\\nstatic constexpr int modVal = 1000000007;\\n\\nclass Solution {\\n    long moduloReduce(long n) {\\n        while (n > modVal) n -= modVal;\\n        return n;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        long dp[n][5];\\n        // initialising dp\\n        for (int i = 0; i < 5; i++) dp[0][i] = 1;\\n        // computing all the following steps\\n        for (int i = 1, prev = 0; i < n; i++) {\\n            // case \\'a\\' - which can only follow \\'e\\', \\'i\\' and \\'u\\':\\n            dp[i][0] = moduloReduce(dp[prev][1] + dp[prev][2] + dp[prev][4]);\\n            // case \\'e\\' - which can only follow \\'a\\' and \\'i\\':\\n            dp[i][1] = moduloReduce(dp[prev][0] + dp[prev][2]);\\n            // case \\'i\\' - which can only follow \\'e\\' and \\'o\\':\\n            dp[i][2] = moduloReduce(dp[prev][1] + dp[prev][3]);\\n            // case \\'o\\' - which can only follow \\'i\\':\\n            dp[i][3] = dp[prev][2];\\n            // case \\'u\\' - which can only follow \\'i\\' and \\'o\\':\\n            dp[i][4] = moduloReduce(dp[prev][2] + dp[prev][3]);\\n            // updating prev\\n            prev = i;\\n        }\\n        return moduloReduce(dp[--n][0] + dp[n][1] + dp[n][2] + dp[n][3] + dp[n][4]);\\n    }\\n};\\n```\\n\\nBut, wait a moment: do we really need `n` rows in our matrix?\\n\\nProbably not, since we are always advancing to one row, using the previous one.\\n\\nThen we can refactor and save a lot more memory \\uD83C\\uDF89 :\\n\\n```cpp\\nstatic constexpr int modVal = 1000000007;\\n\\nclass Solution {\\n    long moduloReduce(long n) {\\n        while (n > modVal) n -= modVal;\\n        return n;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        long dp[2][5];\\n        int prev = 0;\\n        // initialising dp\\n        for (int i = 0; i < 5; i++) dp[0][i] = 1;\\n        // computing all the following steps\\n        for (int i = 1, curr = 1; i < n; i++) {\\n            // case \\'a\\' - which can only follow \\'e\\', \\'i\\' and \\'u\\':\\n            dp[curr][0] = moduloReduce(dp[prev][1] + dp[prev][2] + dp[prev][4]);\\n            // case \\'e\\' - which can only follow \\'a\\' and \\'i\\':\\n            dp[curr][1] = moduloReduce(dp[prev][0] + dp[prev][2]);\\n            // case \\'i\\' - which can only follow \\'e\\' and \\'o\\':\\n            dp[curr][2] = moduloReduce(dp[prev][1] + dp[prev][3]);\\n            // case \\'o\\' - which can only follow \\'i\\':\\n            dp[curr][3] = dp[prev][2];\\n            // case \\'u\\' - which can only follow \\'i\\' and \\'o\\':\\n            dp[curr][4] = moduloReduce(dp[prev][2] + dp[prev][3]);\\n            // updating prev and curr\\n            prev = curr;\\n            curr = !curr;\\n        }\\n        return moduloReduce(dp[prev][0] + dp[prev][1] + dp[prev][2] + dp[prev][3] + dp[prev][4]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```cpp\\nstatic constexpr int modVal = 1000000007;\\n\\nclass Solution {\\n    long moduloReduce(long n) {\\n        while (n > modVal) n -= modVal;\\n        return n;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        long dp[n][5];\\n        // initialising dp\\n        for (int i = 0; i < 5; i++) dp[0][i] = 1;\\n        // computing all the following steps\\n        for (int i = 1, prev = 0; i < n; i++) {\\n            // case \\'a\\' - which can only follow \\'e\\', \\'i\\' and \\'u\\':\\n            dp[i][0] = moduloReduce(dp[prev][1] + dp[prev][2] + dp[prev][4]);\\n            // case \\'e\\' - which can only follow \\'a\\' and \\'i\\':\\n            dp[i][1] = moduloReduce(dp[prev][0] + dp[prev][2]);\\n            // case \\'i\\' - which can only follow \\'e\\' and \\'o\\':\\n            dp[i][2] = moduloReduce(dp[prev][1] + dp[prev][3]);\\n            // case \\'o\\' - which can only follow \\'i\\':\\n            dp[i][3] = dp[prev][2];\\n            // case \\'u\\' - which can only follow \\'i\\' and \\'o\\':\\n            dp[i][4] = moduloReduce(dp[prev][2] + dp[prev][3]);\\n            // updating prev\\n            prev = i;\\n        }\\n        return moduloReduce(dp[--n][0] + dp[n][1] + dp[n][2] + dp[n][3] + dp[n][4]);\\n    }\\n};\\n```\n```cpp\\nstatic constexpr int modVal = 1000000007;\\n\\nclass Solution {\\n    long moduloReduce(long n) {\\n        while (n > modVal) n -= modVal;\\n        return n;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        long dp[2][5];\\n        int prev = 0;\\n        // initialising dp\\n        for (int i = 0; i < 5; i++) dp[0][i] = 1;\\n        // computing all the following steps\\n        for (int i = 1, curr = 1; i < n; i++) {\\n            // case \\'a\\' - which can only follow \\'e\\', \\'i\\' and \\'u\\':\\n            dp[curr][0] = moduloReduce(dp[prev][1] + dp[prev][2] + dp[prev][4]);\\n            // case \\'e\\' - which can only follow \\'a\\' and \\'i\\':\\n            dp[curr][1] = moduloReduce(dp[prev][0] + dp[prev][2]);\\n            // case \\'i\\' - which can only follow \\'e\\' and \\'o\\':\\n            dp[curr][2] = moduloReduce(dp[prev][1] + dp[prev][3]);\\n            // case \\'o\\' - which can only follow \\'i\\':\\n            dp[curr][3] = dp[prev][2];\\n            // case \\'u\\' - which can only follow \\'i\\' and \\'o\\':\\n            dp[curr][4] = moduloReduce(dp[prev][2] + dp[prev][3]);\\n            // updating prev and curr\\n            prev = curr;\\n            curr = !curr;\\n        }\\n        return moduloReduce(dp[prev][0] + dp[prev][1] + dp[prev][2] + dp[prev][3] + dp[prev][4]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150639,
                "title": "stupid-simple-python",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = e = i = o = u = 1\\n        for _ in range(n - 1):\\n            a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n        \\n        return  (a + e + i + o + u) % (10 ** 9 + 7)\\n```\\n80% faster and 95% less space than other python",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = e = i = o = u = 1\\n        for _ in range(n - 1):\\n            a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n        \\n        return  (a + e + i + o + u) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412036,
                "title": "python-simple-forward-dynamic-programming",
                "content": "```python\\ndef countVowelPermutation(self, n: int) -> int:\\n\\tMOD = 10**9 + 7\\n\\tvowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n\\tallowed_next = {\\n\\t\\t\\'a\\': [\\'e\\'],\\n\\t\\t\\'e\\': [\\'a\\', \\'i\\'],\\n\\t\\t\\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n\\t\\t\\'o\\': [\\'i\\', \\'u\\'],\\n\\t\\t\\'u\\': [\\'a\\']\\n\\t}       \\n\\t# dp[i][v] - number of possible strings of length i+1 (since we\\n\\t# start with i=0) that end with vowel v.\\n\\tdp = [collections.defaultdict(int) for i in range(n)]\\n\\tfor v in vowels:\\n\\t\\tdp[0][v] = 1\\n\\tfor i in range(n-1):\\n\\t\\tfor v in vowels:\\n\\t\\t\\tfor next_v in allowed_next[v]:\\n\\t\\t\\t\\tdp[i+1][next_v] = (dp[i+1][next_v] + dp[i][v])%MOD\\n\\treturn sum(dp[n-1].values())%MOD\\n```",
                "solutionTags": [],
                "code": "```python\\ndef countVowelPermutation(self, n: int) -> int:\\n\\tMOD = 10**9 + 7\\n\\tvowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n\\tallowed_next = {\\n\\t\\t\\'a\\': [\\'e\\'],\\n\\t\\t\\'e\\': [\\'a\\', \\'i\\'],\\n\\t\\t\\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n\\t\\t\\'o\\': [\\'i\\', \\'u\\'],\\n\\t\\t\\'u\\': [\\'a\\']\\n\\t}       \\n\\t# dp[i][v] - number of possible strings of length i+1 (since we\\n\\t# start with i=0) that end with vowel v.\\n\\tdp = [collections.defaultdict(int) for i in range(n)]\\n\\tfor v in vowels:\\n\\t\\tdp[0][v] = 1\\n\\tfor i in range(n-1):\\n\\t\\tfor v in vowels:\\n\\t\\t\\tfor next_v in allowed_next[v]:\\n\\t\\t\\t\\tdp[i+1][next_v] = (dp[i+1][next_v] + dp[i][v])%MOD\\n\\treturn sum(dp[n-1].values())%MOD\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 399280,
                "title": "super-easy-5-line-python-solution-o-n-time-o-1-space",
                "content": "borrow the idea from LC 70\\nthe number of strings of length n is only determined  by previous state (the number of each character in all the strings of length n-1)\\nnotice the rules, \\'a\\' will only follow after \\'e\\',\\'i\\',\\'u\\', so update `a = e+i+u`, same to all the vowels\\n```\\ndef countVowelPermutation(self, n: int) -> int:\\n\\ta,e,i,o,u = 1,1,1,1,1\\n\\t#store the number of each vowels\\n\\tfor _ in range(1,n):\\n\\t\\ta,e,i,o,u = e+i+u,a+i,e+o,i,i+o\\n\\treturn (a+e+i+o+u)% 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n\\ta,e,i,o,u = 1,1,1,1,1\\n\\t#store the number of each vowels\\n\\tfor _ in range(1,n):\\n\\t\\ta,e,i,o,u = e+i+u,a+i,e+o,i,i+o\\n\\treturn (a+e+i+o+u)% 1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2450820,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=EveRd84f8NM\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\nint countVowelPermutation(int n) {\\nlong a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\nlong a2, e2, i2, o2, u2;\\n\\n    for (int j = 2; j <= n; j++) {\\n        a2 = (e + i + u) % mod;\\n        e2 = (a + i) % mod;\\n        i2 = (e + o) % mod;\\n        o2 = i;\\n        u2 = (o + i) % mod;\\n        \\n        a = a2, e = e2, i = i2, o = o2, u = u2;\\n    }\\n    \\n    return (a + e + i + o + u) % mod;\\n}\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long [][] dp = new long[5][n+1];\\n        int mod=1000000007;\\n        for(int i=0;i<5;i++){\\n            dp[i][0]=0;\\n            dp[i][1]=1;\\n        }  \\n        for(int i=2;i<n+1;i++){\\n            dp[0][i]=(dp[1][i-1]+dp[2][i-1]+dp[4][i-1])%mod;   //for ending with \\'a\\'\\n            dp[1][i]=(dp[0][i-1]+dp[2][i-1])%mod;                     //for ending with \\'e\\'\\n            dp[2][i]=(dp[1][i-1]+dp[3][i-1])%mod;                 //for ending with \\'i\\'\\n            dp[3][i]=(dp[2][i-1])%mod;                       //for ending with \\'o\\'\\n            dp[4][i]=(dp[2][i-1]+dp[3][i-1])%mod;                   //for ending with \\'u\\'\\n        }  \\n        return (int)((dp[0][n]+dp[1][n]+dp[2][n]+dp[3][n]+dp[4][n])%mod);     //return sum  but in integer format\\n    }\\n}\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={\\'a\\':1,\\'e\\':1,\\'i\\':1,\\'o\\':1,\\'u\\':1}\\n        \\n        for i in range(n-1):\\n            dp1={}\\n            for c in \\'aeiou\\':\\n                if c==\\'a\\':\\n                    dp1[c]=dp[\\'e\\']\\n                elif c==\\'e\\':\\n                    dp1[c]=dp[\\'a\\']+dp[\\'i\\']\\n                elif c==\"i\":\\n                    dp1[c]=dp[\\'a\\']+dp[\\'e\\']+dp[\\'o\\']+dp[\\'u\\']\\n                elif c==\\'o\\':\\n                    dp1[c]=dp[\\'i\\']+dp[\\'u\\']\\n                elif c==\\'u\\':\\n                    dp1[c]=dp[\\'a\\']\\n                    \\n            dp=dp1\\n        mod=10**9+7    \\n        return sum(dp.values())%mod\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint countVowelPermutation(int n) {\\nlong a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\nlong a2, e2, i2, o2, u2;\\n\\n    for (int j = 2; j <= n; j++) {\\n        a2 = (e + i + u) % mod;\\n        e2 = (a + i) % mod;\\n        i2 = (e + o) % mod;\\n        o2 = i;\\n        u2 = (o + i) % mod;\\n        \\n        a = a2, e = e2, i = i2, o = o2, u = u2;\\n    }\\n    \\n    return (a + e + i + o + u) % mod;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long [][] dp = new long[5][n+1];\\n        int mod=1000000007;\\n        for(int i=0;i<5;i++){\\n            dp[i][0]=0;\\n            dp[i][1]=1;\\n        }  \\n        for(int i=2;i<n+1;i++){\\n            dp[0][i]=(dp[1][i-1]+dp[2][i-1]+dp[4][i-1])%mod;   //for ending with \\'a\\'\\n            dp[1][i]=(dp[0][i-1]+dp[2][i-1])%mod;                     //for ending with \\'e\\'\\n            dp[2][i]=(dp[1][i-1]+dp[3][i-1])%mod;                 //for ending with \\'i\\'\\n            dp[3][i]=(dp[2][i-1])%mod;                       //for ending with \\'o\\'\\n            dp[4][i]=(dp[2][i-1]+dp[3][i-1])%mod;                   //for ending with \\'u\\'\\n        }  \\n        return (int)((dp[0][n]+dp[1][n]+dp[2][n]+dp[3][n]+dp[4][n])%mod);     //return sum  but in integer format\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={\\'a\\':1,\\'e\\':1,\\'i\\':1,\\'o\\':1,\\'u\\':1}\\n        \\n        for i in range(n-1):\\n            dp1={}\\n            for c in \\'aeiou\\':\\n                if c==\\'a\\':\\n                    dp1[c]=dp[\\'e\\']\\n                elif c==\\'e\\':\\n                    dp1[c]=dp[\\'a\\']+dp[\\'i\\']\\n                elif c==\"i\":\\n                    dp1[c]=dp[\\'a\\']+dp[\\'e\\']+dp[\\'o\\']+dp[\\'u\\']\\n                elif c==\\'o\\':\\n                    dp1[c]=dp[\\'i\\']+dp[\\'u\\']\\n                elif c==\\'u\\':\\n                    dp1[c]=dp[\\'a\\']\\n                    \\n            dp=dp1\\n        mod=10**9+7    \\n        return sum(dp.values())%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430917,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=EveRd84f8NM\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n**C++**\\n```\\nclass Solution {\\npublic:\\nint countVowelPermutation(int n) {\\nlong a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\nlong a2, e2, i2, o2, u2;\\n\\n    for (int j = 2; j <= n; j++) {\\n        a2 = (e + i + u) % mod;\\n        e2 = (a + i) % mod;\\n        i2 = (e + o) % mod;\\n        o2 = i;\\n        u2 = (o + i) % mod;\\n        \\n        a = a2, e = e2, i = i2, o = o2, u = u2;\\n    }\\n    \\n    return (a + e + i + o + u) % mod;\\n}\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long [][] dp = new long[5][n+1];\\n        int mod=1000000007;\\n        for(int i=0;i<5;i++){\\n            dp[i][0]=0;\\n            dp[i][1]=1;\\n        }  \\n        for(int i=2;i<n+1;i++){\\n            dp[0][i]=(dp[1][i-1]+dp[2][i-1]+dp[4][i-1])%mod;   //for ending with \\'a\\'\\n            dp[1][i]=(dp[0][i-1]+dp[2][i-1])%mod;                     //for ending with \\'e\\'\\n            dp[2][i]=(dp[1][i-1]+dp[3][i-1])%mod;                 //for ending with \\'i\\'\\n            dp[3][i]=(dp[2][i-1])%mod;                       //for ending with \\'o\\'\\n            dp[4][i]=(dp[2][i-1]+dp[3][i-1])%mod;                   //for ending with \\'u\\'\\n        }  \\n        return (int)((dp[0][n]+dp[1][n]+dp[2][n]+dp[3][n]+dp[4][n])%mod);     //return sum  but in integer format\\n    }\\n}\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={\\'a\\':1,\\'e\\':1,\\'i\\':1,\\'o\\':1,\\'u\\':1}\\n        \\n        for i in range(n-1):\\n            dp1={}\\n            for c in \\'aeiou\\':\\n                if c==\\'a\\':\\n                    dp1[c]=dp[\\'e\\']\\n                elif c==\\'e\\':\\n                    dp1[c]=dp[\\'a\\']+dp[\\'i\\']\\n                elif c==\"i\":\\n                    dp1[c]=dp[\\'a\\']+dp[\\'e\\']+dp[\\'o\\']+dp[\\'u\\']\\n                elif c==\\'o\\':\\n                    dp1[c]=dp[\\'i\\']+dp[\\'u\\']\\n                elif c==\\'u\\':\\n                    dp1[c]=dp[\\'a\\']\\n                    \\n            dp=dp1\\n        mod=10**9+7    \\n        return sum(dp.values())%mod\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint countVowelPermutation(int n) {\\nlong a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\nlong a2, e2, i2, o2, u2;\\n\\n    for (int j = 2; j <= n; j++) {\\n        a2 = (e + i + u) % mod;\\n        e2 = (a + i) % mod;\\n        i2 = (e + o) % mod;\\n        o2 = i;\\n        u2 = (o + i) % mod;\\n        \\n        a = a2, e = e2, i = i2, o = o2, u = u2;\\n    }\\n    \\n    return (a + e + i + o + u) % mod;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long [][] dp = new long[5][n+1];\\n        int mod=1000000007;\\n        for(int i=0;i<5;i++){\\n            dp[i][0]=0;\\n            dp[i][1]=1;\\n        }  \\n        for(int i=2;i<n+1;i++){\\n            dp[0][i]=(dp[1][i-1]+dp[2][i-1]+dp[4][i-1])%mod;   //for ending with \\'a\\'\\n            dp[1][i]=(dp[0][i-1]+dp[2][i-1])%mod;                     //for ending with \\'e\\'\\n            dp[2][i]=(dp[1][i-1]+dp[3][i-1])%mod;                 //for ending with \\'i\\'\\n            dp[3][i]=(dp[2][i-1])%mod;                       //for ending with \\'o\\'\\n            dp[4][i]=(dp[2][i-1]+dp[3][i-1])%mod;                   //for ending with \\'u\\'\\n        }  \\n        return (int)((dp[0][n]+dp[1][n]+dp[2][n]+dp[3][n]+dp[4][n])%mod);     //return sum  but in integer format\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={\\'a\\':1,\\'e\\':1,\\'i\\':1,\\'o\\':1,\\'u\\':1}\\n        \\n        for i in range(n-1):\\n            dp1={}\\n            for c in \\'aeiou\\':\\n                if c==\\'a\\':\\n                    dp1[c]=dp[\\'e\\']\\n                elif c==\\'e\\':\\n                    dp1[c]=dp[\\'a\\']+dp[\\'i\\']\\n                elif c==\"i\":\\n                    dp1[c]=dp[\\'a\\']+dp[\\'e\\']+dp[\\'o\\']+dp[\\'u\\']\\n                elif c==\\'o\\':\\n                    dp1[c]=dp[\\'i\\']+dp[\\'u\\']\\n                elif c==\\'u\\':\\n                    dp1[c]=dp[\\'a\\']\\n                    \\n            dp=dp1\\n        mod=10**9+7    \\n        return sum(dp.values())%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391599,
                "title": "c-explained-without-dp",
                "content": "![image](https://assets.leetcode.com/users/images/eddd9e58-7224-47c6-8a3b-e426606a22a6_1659854627.9822836.jpeg)\\n```\\n\\n\\nUpvote for the effort <<<<<< if u understood \\n\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n       \\n        \\n        \\n        \\n       \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n            \\n            \\n            /* say for n==2\\n       a2=3;\\n       e2=2;\\n       i2=2;\\n       02=1;\\n       u2=2;\\n       now update all values and go for next iteration\\n       \\n       \\n       \\n         */\\n            \\n            \\n            \\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nUpvote for the effort <<<<<< if u understood \\n\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n       \\n        \\n        \\n        \\n       \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n            \\n            \\n            /* say for n==2\\n       a2=3;\\n       e2=2;\\n       i2=2;\\n       02=1;\\n       u2=2;\\n       now update all values and go for next iteration\\n       \\n       \\n       \\n         */\\n            \\n            \\n            \\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391014,
                "title": "c-easy-dp-solution-with-matrix-beats-100",
                "content": "```\\n\\t{\\n\\tconst int mod=1000000007;\\n\\tlong long int arr[n][5];\\n\\tfor(int i=0;i<5;i++)\\n\\t{\\n\\t\\tarr[0][i]=1;\\n\\t}\\n\\tfor(int i=1;i<n;i++)\\n\\t{\\n\\t\\tarr[i][0]=arr[i-1][1]+arr[i-1][2]+arr[i-1][4];\\n\\t\\tarr[i][0]%=mod;\\n\\t\\tarr[i][1]=arr[i-1][0]+arr[i-1][2];  \\n\\t\\tarr[i][1]%=mod;\\n\\t\\tarr[i][2]=arr[i-1][1]+arr[i-1][3];\\n\\t\\tarr[i][2]%=mod;\\n\\t\\tarr[i][3]=arr[i-1][2];\\n\\t\\tarr[i][3]%=mod;\\n\\t\\tarr[i][4]=arr[i-1][2]+arr[i-1][3];\\n\\t\\tarr[i][4]%=mod;\\n\\t}\\n\\tlong long int ans=0;\\n\\tfor(int i=0;i<5;i++)\\n\\t{\\n\\t\\tans+=arr[n-1][i];\\n\\t\\tans%=mod;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\n\\t{\\n\\tconst int mod=1000000007;\\n\\tlong long int arr[n][5];\\n\\tfor(int i=0;i<5;i++)\\n\\t{\\n\\t\\tarr[0][i]=1;\\n\\t}\\n\\tfor(int i=1;i<n;i++)\\n\\t{\\n\\t\\tarr[i][0]=arr[i-1][1]+arr[i-1][2]+arr[i-1][4];\\n\\t\\tarr[i][0]%=mod;\\n\\t\\tarr[i][1]=arr[i-1][0]+arr[i-1][2];  \\n\\t\\tarr[i][1]%=mod;\\n\\t\\tarr[i][2]=arr[i-1][1]+arr[i-1][3];\\n\\t\\tarr[i][2]%=mod;\\n\\t\\tarr[i][3]=arr[i-1][2];\\n\\t\\tarr[i][3]%=mod;\\n\\t\\tarr[i][4]=arr[i-1][2]+arr[i-1][3];\\n\\t\\tarr[i][4]%=mod;\\n\\t}\\n\\tlong long int ans=0;\\n\\tfor(int i=0;i<5;i++)\\n\\t{\\n\\t\\tans+=arr[n-1][i];\\n\\t\\tans%=mod;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315768,
                "title": "count-vowels-permutation-math-bottom-up-dp-w-explanation",
                "content": "The core idea is calculating the numbers of strings ended with each vowel recursively. Based on the problem, we can create a string of length `n+1` from a string of length `n`, so when we need to find the answer of the problem for input `n + 1`, we only need to know the answer for input `n`. Therefore, instead of using a table to save values from `1` to `n`, we compute in a bottom-up manner and use temporary variables to save memory. Below is the implementation of the idea (Runtime: 136ms, Memory Usage: 14.2MB)\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 1000000007\\n        j = 1\\n        A, E, I, O , U = 1, 1, 1, 1, 1 # base case for n = 1\\n        while j < n:\\n            prev_A, prev_E, prev_I, prev_O, prev_U = A, E, I, O, U\\n            A = prev_E + prev_I + prev_U\\n            E = prev_A + prev_I\\n            I = prev_E + prev_O\\n            O = prev_I\\n            U = prev_I + prev_O\\n            if A >= mod: A %= mod\\n            if E >= mod: E %= mod\\n            if I >= mod: I %= mod\\n            if O >= mod: O %= mod\\n            if U >= mod: U %= mod\\n            j += 1\\n        return (A + E + I + O + U) % mod\\n```\\nI went further to improve the solution using a little bit Math. Instead of breaking into 5 components, I tried to find a recursive formula to directly computed the answer. Suppose that `(x) = (x_1, x_2, ..., x_n)` is a sequence of answers for the problem. I would find the recursive equation for `(x)`. This can be done using the recursive relation we have from the previous solution, from which I got that `x_n = x_{n-1} + 2x_{n-2} - x_{n-3} + x_{n-4}`, and all I needed left was answers for `n = {1, 2, 3, 4}` and building up the solution in the similar way to the first solution. (Runtime: 88ms, Memory Usage: 14MB)\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 1000000007\\n        j = 4\\n        x = deque([5, 10, 19, 35])\\n        while j < n:\\n            x.append((x[3] + 2*x[2] - x[1] + x[0]) % mod)\\n            x.popleft()\\n            j += 1\\n        return x[n - 1] if n < 5 else x[-1]\\n```\\nThis is also my first post. Thank you for reading and please upvote if you like the solutions! Happy coding!",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 1000000007\\n        j = 1\\n        A, E, I, O , U = 1, 1, 1, 1, 1 # base case for n = 1\\n        while j < n:\\n            prev_A, prev_E, prev_I, prev_O, prev_U = A, E, I, O, U\\n            A = prev_E + prev_I + prev_U\\n            E = prev_A + prev_I\\n            I = prev_E + prev_O\\n            O = prev_I\\n            U = prev_I + prev_O\\n            if A >= mod: A %= mod\\n            if E >= mod: E %= mod\\n            if I >= mod: I %= mod\\n            if O >= mod: O %= mod\\n            if U >= mod: U %= mod\\n            j += 1\\n        return (A + E + I + O + U) % mod\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 1000000007\\n        j = 4\\n        x = deque([5, 10, 19, 35])\\n        while j < n:\\n            x.append((x[3] + 2*x[2] - x[1] + x[0]) % mod)\\n            x.popleft()\\n            j += 1\\n        return x[n - 1] if n < 5 else x[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527942,
                "title": "java-bottom-up-dp",
                "content": "```\\npublic int countVowelPermutation(int n) {\\n        int mod = (int) (1e9 + 7);\\n        if (n == 0) return 1;\\n        if (n == 1) return 5;\\n        long[][] dp = new long[n+1][5];\\n        for (int i = 0; i < 5; i++) {\\n            dp[1][i] = 1;\\n        }\\n\\t\\t// for i + 1, just add new char to the head of old string.\\n        for (int i = 1; i < n; i++) {\\n            dp[i+1][0] = (dp[i][1]) % mod; \\n            dp[i+1][1] = (dp[i][0] + dp[i][2]) % mod;\\n            dp[i+1][2] = (dp[i][0] + dp[i][1] + dp[i][3] + dp[i][4]) % mod;\\n            dp[i+1][3] = (dp[i][2] + dp[i][4]) % mod;\\n            dp[i+1][4] = (dp[i][0]) % mod;\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 5; i++) {\\n            res = (res +dp[n][i]) % mod;\\n        }\\n        return (int) res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countVowelPermutation(int n) {\\n        int mod = (int) (1e9 + 7);\\n        if (n == 0) return 1;\\n        if (n == 1) return 5;\\n        long[][] dp = new long[n+1][5];\\n        for (int i = 0; i < 5; i++) {\\n            dp[1][i] = 1;\\n        }\\n\\t\\t// for i + 1, just add new char to the head of old string.\\n        for (int i = 1; i < n; i++) {\\n            dp[i+1][0] = (dp[i][1]) % mod; \\n            dp[i+1][1] = (dp[i][0] + dp[i][2]) % mod;\\n            dp[i+1][2] = (dp[i][0] + dp[i][1] + dp[i][3] + dp[i][4]) % mod;\\n            dp[i+1][3] = (dp[i][2] + dp[i][4]) % mod;\\n            dp[i+1][4] = (dp[i][0]) % mod;\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 5; i++) {\\n            res = (res +dp[n][i]) % mod;\\n        }\\n        return (int) res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410448,
                "title": "python-4-liner-should-not-be-a-hard-problem",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a,e,i,o,u = 1,1,1,1,1\\n        for j in range(2, n+1):\\n            a,e,i,o,u = e+i+u, a+i,e+o, i, i+o\\n        return (a+e+i+o+u) % (10**9 +7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a,e,i,o,u = 1,1,1,1,1\\n        for j in range(2, n+1):\\n            a,e,i,o,u = e+i+u, a+i,e+o, i, i+o\\n        return (a+e+i+o+u) % (10**9 +7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566976,
                "title": "c-dp-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,int &n,vector<vector<int>> &dp,vector<vector<char>> &g,char c,int &mod){\\n    if(i>=n){\\n        // cout<<\" \"<<str<<\" \";\\n        return 1;\\n    }\\n    if(dp[i][c-\\'a\\'] != -1)return dp[i][c-\\'a\\'];\\n    int a = 0;\\n    for(auto &j: g[c-\\'a\\']){\\n        a = (a+solve(i+1,n,dp,g,j,mod))%mod;\\n    }\\n    return dp[i][c-\\'a\\'] = a;\\n}\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n,vector<int>(26,-1));\\n        vector<vector<char>> g(26);\\n        g[\\'b\\'-\\'a\\']  = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        g[\\'a\\'-\\'a\\'] = {\\'e\\'};\\n        g[\\'e\\'-\\'a\\'] = {\\'a\\',\\'i\\'};\\n        g[\\'i\\'-\\'a\\'] = {\\'a\\',\\'e\\',\\'o\\',\\'u\\'};\\n        g[\\'o\\'-\\'a\\'] = {\\'i\\',\\'u\\'};\\n        g[\\'u\\'-\\'a\\'] = {\\'a\\'};\\n        int mod = 1e9+7;\\n        return solve(0,n,dp,g,\\'b\\',mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,int &n,vector<vector<int>> &dp,vector<vector<char>> &g,char c,int &mod){\\n    if(i>=n){\\n        // cout<<\" \"<<str<<\" \";\\n        return 1;\\n    }\\n    if(dp[i][c-\\'a\\'] != -1)return dp[i][c-\\'a\\'];\\n    int a = 0;\\n    for(auto &j: g[c-\\'a\\']){\\n        a = (a+solve(i+1,n,dp,g,j,mod))%mod;\\n    }\\n    return dp[i][c-\\'a\\'] = a;\\n}\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n,vector<int>(26,-1));\\n        vector<vector<char>> g(26);\\n        g[\\'b\\'-\\'a\\']  = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        g[\\'a\\'-\\'a\\'] = {\\'e\\'};\\n        g[\\'e\\'-\\'a\\'] = {\\'a\\',\\'i\\'};\\n        g[\\'i\\'-\\'a\\'] = {\\'a\\',\\'e\\',\\'o\\',\\'u\\'};\\n        g[\\'o\\'-\\'a\\'] = {\\'i\\',\\'u\\'};\\n        g[\\'u\\'-\\'a\\'] = {\\'a\\'};\\n        int mod = 1e9+7;\\n        return solve(0,n,dp,g,\\'b\\',mod);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3040891,
                "title": "python-4-solutions-slowly-getting-better-thought-process-beats-99",
                "content": "# \\u2705 First approach : recursivity (Too slow)\\n\\n```\\noptions={\"a\":\"e\",\"e\":\"ai\",\"i\":\"aeou\",\"o\":\"iu\",\"u\":\"a\"}\\n\\nalphabet = \"aeiou\"\\n\\ndef count(s, n):\\n    if n==0:\\n        return 1\\n    return sum([count(options[c],n-1) for c in s])\\n    \\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        return count(alphabet,n)\\n```\\n\\nDespite its corectness, this implementation  is way too slow, let\\'s use dynamic programming\\n\\n---\\n\\n\\n---\\n\\n\\n# \\u2705 Second approach : dynamic programming (Beats 49%)\\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0 for _ in range(5)] for _ in range(n)]\\n        mat[0]=[1]*5\\n\\n        for i in range(1,n):\\n            mat[i][0] = mat[i-1][1] + mat[i-1][2] + mat[i-1][4]\\n            mat[i][1] = mat[i-1][0] + mat[i-1][2]\\n            mat[i][2] = mat[i-1][1] + mat[i-1][3]\\n            mat[i][3] = mat[i-1][2]\\n            mat[i][4] = mat[i-1][2] + mat[i-1][3]\\n\\n        return sum(mat[n-1]) % (10 **9 +7)\\n```\\n\\nWe see that the i_th line only depends of the i-1_th line, we can simplify the calculation and the space required using matrix exponentiation.\\n\\n---\\n\\n\\n---\\n\\n\\n# Third approach : linear algebra\\n\\nWe can reprenst the rules by this $5\\\\times 5$ matrix where there is a 1 at `i,j` if ith voyel can have jth voyell behind it\\n\\nfor example `u` can have `i` and `o` behind it so $a_{5,2}=a_{5,3}=1$\\n\\n$$A= \\\\begin{bmatrix} 0 & 1 & 1 & 0 & 1 \\\\\\\\ 1 & 0 & 1 & 0 & 0 \\\\\\\\ 0 & 1 & 0 & 1 & 0 \\\\\\\\ 0 & 0 & 1 & 0 & 0 \\\\\\\\ 0 & 0 & 1 & 1 & 0 \\\\end{bmatrix} $$\\n\\nThe answer is the sum of all the values of this matrix\\n\\n$A^n \\\\cdot X_0 = \\\\begin{bmatrix} 0 & 1 & 1 & 0 & 1 \\\\\\\\ 1 & 0 & 1 & 0 & 0 \\\\\\\\ 0 & 1 & 0 & 1 & 0 \\\\\\\\ 0 & 0 & 1 & 0 & 0 \\\\\\\\ 0 & 0 & 1 & 1 & 0 \\\\end{bmatrix}^n \\\\begin{bmatrix} 1 \\\\\\\\ 1 \\\\\\\\ 1 \\\\\\\\ 1 \\\\\\\\ 1 \\\\end{bmatrix}\\n$\\n\\nLet\\'s calculate it\\n\\n\\n```\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```\\n\\nThe results are wrong for n > 50. It must be an issue with int overflow or the moudlo.\\n\\n# \\u2705Last approach (Beats 99%)\\nUsing chat gpt as an assistant, I found a way to keep the values of the matrix not too high.\\nAI really is astonishing when used precisely.\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = np.array([[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]],dtype=int)\\n        result = np.eye(5,dtype=int)\\n        n-=1\\n        while n:\\n            if n % 2:\\n                result = np.dot(result, mat) % (10**9+7)\\n            mat = np.dot(mat, mat) % (10**9+7)\\n            n //= 2\\n        return np.sum(result) % (10**9+7)\\n```\\n\\nDo not hesitate to contact me if I made mistakes or if you have question ! \\uD83D\\uDE00\\n",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\noptions={\"a\":\"e\",\"e\":\"ai\",\"i\":\"aeou\",\"o\":\"iu\",\"u\":\"a\"}\\n\\nalphabet = \"aeiou\"\\n\\ndef count(s, n):\\n    if n==0:\\n        return 1\\n    return sum([count(options[c],n-1) for c in s])\\n    \\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        return count(alphabet,n)\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0 for _ in range(5)] for _ in range(n)]\\n        mat[0]=[1]*5\\n\\n        for i in range(1,n):\\n            mat[i][0] = mat[i-1][1] + mat[i-1][2] + mat[i-1][4]\\n            mat[i][1] = mat[i-1][0] + mat[i-1][2]\\n            mat[i][2] = mat[i-1][1] + mat[i-1][3]\\n            mat[i][3] = mat[i-1][2]\\n            mat[i][4] = mat[i-1][2] + mat[i-1][3]\\n\\n        return sum(mat[n-1]) % (10 **9 +7)\\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = np.array([[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]],dtype=int)\\n        result = np.eye(5,dtype=int)\\n        n-=1\\n        while n:\\n            if n % 2:\\n                result = np.dot(result, mat) % (10**9+7)\\n            mat = np.dot(mat, mat) % (10**9+7)\\n            n //= 2\\n        return np.sum(result) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393093,
                "title": "c-solution-with-easy-explanation",
                "content": "In the below solution, character \\'a\\' is denoted as 0, character \\'e\\' is denoted as 1, character \\'i\\' is denoted as 2, character \\'o\\' is denoted as 3, character \\'u\\' is denoted as 4.\\nSo whenever we add a character, we pass the corresponding number to the function which describes what character was inserted before, so that we can take the next decision.\\n```\\nclass Solution {\\npublic:\\n    char arr[5] = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    int dp[100000][5];  //This dp denotes the no of string of particular length ending \\n\\t//with particular vowel. For eg. dp[i][j] denotes the total no of string of length i \\n\\t//which ends with vowel j.\\n    int mod = 1e9 + 7;\\n    int find(int n, int i){\\n        if(n == 1)return 1;  //return when string size is 1\\n        if(dp[n][i] != -1)return dp[n][i];\\n        dp[n][i] = 0;\\n\\t\\tif(i == 0){ //when the last character of string is \\'a\\'   \\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 1))% mod;\\n        }\\n        else if(i == 1){    //when the last character of string is \\'e\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 2))% mod;\\n        }\\n\\t\\telse if(i == 2){   //when the last character of string is \\'i\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 1))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 3))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 4))% mod;\\n        }\\n\\t\\telse if(i == 3){     //when the last character of string is \\'o\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 2))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 4))% mod;\\n        }\\n        else{   //when the last character of string is \\'u\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n        }\\n        return dp[n][i];\\n    }\\n    int countVowelPermutation(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        int res = 0;\\n        for(int i=0; i<5; i++){\\n            res += find(n, i);  \\n            res = res%mod;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char arr[5] = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    int dp[100000][5];  //This dp denotes the no of string of particular length ending \\n\\t//with particular vowel. For eg. dp[i][j] denotes the total no of string of length i \\n\\t//which ends with vowel j.\\n    int mod = 1e9 + 7;\\n    int find(int n, int i){\\n        if(n == 1)return 1;  //return when string size is 1\\n        if(dp[n][i] != -1)return dp[n][i];\\n        dp[n][i] = 0;\\n\\t\\tif(i == 0){ //when the last character of string is \\'a\\'   \\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 1))% mod;\\n        }\\n        else if(i == 1){    //when the last character of string is \\'e\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 2))% mod;\\n        }\\n\\t\\telse if(i == 2){   //when the last character of string is \\'i\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 1))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 3))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 4))% mod;\\n        }\\n\\t\\telse if(i == 3){     //when the last character of string is \\'o\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 2))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 4))% mod;\\n        }\\n        else{   //when the last character of string is \\'u\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n        }\\n        return dp[n][i];\\n    }\\n    int countVowelPermutation(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        int res = 0;\\n        for(int i=0; i<5; i++){\\n            res += find(n, i);  \\n            res = res%mod;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393032,
                "title": "dp-using-striver-s-logic-recursive-and-memoization",
                "content": "Naive recursive sol:\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n        \\n    unordered_map<char, vector<char>> mappings {\\n        {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}},\\n        {\\'a\\', {\\'e\\'}},\\n        {\\'e\\', {\\'a\\', \\'i\\'}},\\n        {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}},\\n        {\\'o\\', {\\'i\\', \\'u\\'}},\\n        {\\'u\\', {\\'a\\'}}\\n    };\\n    public:\\n    \\n    int f(int idx, char prev)\\n    {\\n        if(idx == 0)\\n            return 1;\\n        \\n        int ans = 0;\\n        for(auto c: mappings.at(prev))\\n            ans = (ans + f(idx-1, c));\\n        \\n        return ans;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        return f(n, \\'s\\');\\n    }\\n};\\n```\\n\\nMemoization solution: the unordered map is replaced with a 2d vector mapping where key is now an index, so s==5\\na==4 and so on..\\nThis was done so handling of 2d DP array would be simple\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;   \\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    \\n    public:\\n    \\n    int f(int idx, int prev, vector<vector<int>> &dp)\\n    {\\n        if(idx == 0)\\n            return 1;\\n        \\n        if(dp[prev][idx] != -1)\\n           return dp[prev][idx];\\n        \\n        dp[prev][idx] = 0;\\n        for(auto c : mappings[prev])\\n            dp[prev][idx] = (dp[prev][idx] + f(idx - 1, c, dp)) % MOD;  \\n        \\n        return (dp[prev][idx]);\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(6, vector<int> (n+1, -1));\\n        int ans = f(n, 5, dp);\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you have any doubts, do mention them in comments!",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n        \\n    unordered_map<char, vector<char>> mappings {\\n        {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}},\\n        {\\'a\\', {\\'e\\'}},\\n        {\\'e\\', {\\'a\\', \\'i\\'}},\\n        {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}},\\n        {\\'o\\', {\\'i\\', \\'u\\'}},\\n        {\\'u\\', {\\'a\\'}}\\n    };\\n    public:\\n    \\n    int f(int idx, char prev)\\n    {\\n        if(idx == 0)\\n            return 1;\\n        \\n        int ans = 0;\\n        for(auto c: mappings.at(prev))\\n            ans = (ans + f(idx-1, c));\\n        \\n        return ans;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        return f(n, \\'s\\');\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;   \\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    \\n    public:\\n    \\n    int f(int idx, int prev, vector<vector<int>> &dp)\\n    {\\n        if(idx == 0)\\n            return 1;\\n        \\n        if(dp[prev][idx] != -1)\\n           return dp[prev][idx];\\n        \\n        dp[prev][idx] = 0;\\n        for(auto c : mappings[prev])\\n            dp[prev][idx] = (dp[prev][idx] + f(idx - 1, c, dp)) % MOD;  \\n        \\n        return (dp[prev][idx]);\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(6, vector<int> (n+1, -1));\\n        int ans = f(n, 5, dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392471,
                "title": "python-dp-explained-super-easy-to-understand",
                "content": "We need to generate some vowels permutations given the constraints.\\n\\nAt any point we take a decision of the character to fill next, and we have some `k` characters left to fill after the decision we made, until we get to length `n`.\\n\\nSo for example, `n=5`\\nWe could start the permutation with `\\'ae\\'` or `\\'ie\\'`\\n\\nNote that we need to fill 3 more characters, and the last character is the same, hence we have a recurring `subproblem`. Let\\'s use DP to avoid recalculating sub problems.\\n\\n`dp[i, c]` - is the number of valid permutations for string of length `i` with last character `c`\\n\\nThe final result would be the sum all permutations starting at any `vowel` with length `n`.\\n\\nOne more thing is that we create `vowel_transition` dictionary to assist us in valid transitions given the constraints.\\n\\n# Top-down\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        MOD = 10**9+7\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        vowel_transition = {\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        \\n        @lru_cache(None)\\n        def dp_memo(i, c):\\n            if i == 1: return 1\\n            return sum([dp_memo(i-1, vowel) for vowel in vowel_transition[c]])\\n        \\n        ans = 0\\n        for vowel in vowels: ans = (ans + dp_memo(n, vowel)) % MOD\\n        return ans\\n```\\n\\n# Bottom-up\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        MOD = 10**9+7\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        vowel_transition = {\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        \\n        # 26 columns for a to z characters easy access\\n        dp = [[0 for _ in range(26)] for _ in range(n + 1)]\\n        \\n        # base case\\n        for v in vowels: dp[1][ord(v) - ord(\\'a\\')] = 1\\n        \\n        \\n        for i in range(2, n+1):\\n            for vowel in vowels:\\n                ord_index = ord(vowel) - ord(\\'a\\')\\n                for prev_vowel in vowel_transition[vowel]:\\n                    dp[i][ord_index] = (dp[i][ord_index] + dp[i-1][ord(prev_vowel) - ord(\\'a\\')]) % MOD\\n            \\n            \\n        ans = 0\\n        for v in vowels: ans = (ans + dp[n][ord(v) - ord(\\'a\\')]) % MOD\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        MOD = 10**9+7\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        vowel_transition = {\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        \\n        @lru_cache(None)\\n        def dp_memo(i, c):\\n            if i == 1: return 1\\n            return sum([dp_memo(i-1, vowel) for vowel in vowel_transition[c]])\\n        \\n        ans = 0\\n        for vowel in vowels: ans = (ans + dp_memo(n, vowel)) % MOD\\n        return ans\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        MOD = 10**9+7\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        vowel_transition = {\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        \\n        # 26 columns for a to z characters easy access\\n        dp = [[0 for _ in range(26)] for _ in range(n + 1)]\\n        \\n        # base case\\n        for v in vowels: dp[1][ord(v) - ord(\\'a\\')] = 1\\n        \\n        \\n        for i in range(2, n+1):\\n            for vowel in vowels:\\n                ord_index = ord(vowel) - ord(\\'a\\')\\n                for prev_vowel in vowel_transition[vowel]:\\n                    dp[i][ord_index] = (dp[i][ord_index] + dp[i-1][ord(prev_vowel) - ord(\\'a\\')]) % MOD\\n            \\n            \\n        ans = 0\\n        for v in vowels: ans = (ans + dp[n][ord(v) - ord(\\'a\\')]) % MOD\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391251,
                "title": "c-solution-time-o-n-memory-o-1-easy-to-understand-dynamic-programming",
                "content": "```C#\\npublic class Solution {\\n    private static ulong _mod = 1000000007;\\n    public int CountVowelPermutation(int n) {\\n        ulong a = 1, e = 1, i = 1, o = 1, u = 1;\\n\\n        for (int iter = 1; iter < n; iter++) {\\n            ulong nextA = e + i + u, nextE = a + i, nextI = e + o, nextO = i, nextU = i + o;\\n            a = nextA % _mod;\\n            e = nextE % _mod;\\n            i = nextI % _mod;\\n            o = nextO % _mod;\\n            u = nextU % _mod;\\n        }\\n        \\n        return (int)((a + e + i + o + u) % _mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```C#\\npublic class Solution {\\n    private static ulong _mod = 1000000007;\\n    public int CountVowelPermutation(int n) {\\n        ulong a = 1, e = 1, i = 1, o = 1, u = 1;\\n\\n        for (int iter = 1; iter < n; iter++) {\\n            ulong nextA = e + i + u, nextE = a + i, nextI = e + o, nextO = i, nextU = i + o;\\n            a = nextA % _mod;\\n            e = nextE % _mod;\\n            i = nextI % _mod;\\n            o = nextO % _mod;\\n            u = nextU % _mod;\\n        }\\n        \\n        return (int)((a + e + i + o + u) % _mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390194,
                "title": "java-solution-using-tabulation-method-full-explained",
                "content": "The question here is pretty simple , and all we have to do is use the things exactly as they have said in the question.\\nThe question tells us the characters can be followed by how many and which characters , and we have to **tell the number of permutations we can make using that of length n.** For each character that is given , since it can only be followed by the mentioned characters all we have to do is **multiply the no. of options we have to the n-1 strings which end with that specific character.** To make matter simple , let us understand this concept using an example.\\nNow **let us take n = 2,** and take character *\\'a\\'* for now. Its mentioned that it can only be followed by *\\'e\\'* , hence we can multiply all the strings of n-1 length which end with *\\'a\\'* by 1 as we only have one option here.\\nFor character *\\'e\\'* , we can multiply the n-1 strings that end with *\\'e\\'* by 2 as we have two options that is *\\'a\\'* and *\\'i\\'*.\\nFor character *\\'i\\'*, similarly we can multiply by 4. and so on. \\nHere at each step , **in order to find the strings ending with a specific character for next call we can just add number of strings that are currently having the option to add that specific character.**\\nEg. **take n = 3,**\\nStrings ending with *\\'a\\'* -> (options to add at the end of previous string ) which is in this case is 3 -> (*e , i , u*) * (options we have i.e. 1 which is *\\'e\\'* ).\\nStrings ending with *\\'e\\'* ->(options to add at the end of previous string ) which is in this case is 2 -> (*a , i* ) * (options we have i.e. 2 which is *\\'a\\'* and *\\'i \\'* ).\\nStrings ending with *\\'i\\'* ->(options to add at the end of previous string ) which is in this case is 2 -> (*e, o*) * (options we have i.e. 4 which is *\\'a\\',\\'e\\',\\'o\\',\\'u\\'* ).\\nSimilarly for u and o. We can clearly get the answer 19 for n=3 from above calculation which is correct.\\nThe pattern here can be recognized quite easily and hence recursion can be used where base case will be when n==1 , as we can accomadate any single character only when we have length 1. But recursion will be not be optimal , hence we will use tabulation.\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        \\n\\t\\t// long dp of length n used to handle big test cases and using mod efficiently\\n        long []dp = new long[n];\\n        long mod = (long)1e9+7;\\n\\t\\t// base case\\n        long ia = 1,ie = 1,ii = 1,io = 1,iu = 1; \\n        dp[0] = 5;\\n        \\n        for( int i=1; i<n; i++ ){\\n\\t\\t\\t// simply calculating current strings of length i by using previous string and current options values\\n            long tot = ((ia*1) + (ie*2) + (ii*4) + (io*2) + (iu*1))%mod;\\n            \\n\\t\\t\\t// finding out new values of strings ending with a specific character by using previous values\\n            long na = (ie+ii+iu)%mod;\\n            long ne = (ia + ii)%mod;\\n            long ni = (ie + io)%mod;\\n            long no = ii%mod;\\n            long nu = (ii+io)%mod;\\n            \\n            \\n            ia = na;\\n            ie = ne;\\n            ii = ni;\\n            io = no;\\n            iu = nu;\\n            \\n\\t\\t\\t// assigning value to dp\\n            dp[i] = tot;\\n        }\\n        \\n        return (int)dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        \\n\\t\\t// long dp of length n used to handle big test cases and using mod efficiently\\n        long []dp = new long[n];\\n        long mod = (long)1e9+7;\\n\\t\\t// base case\\n        long ia = 1,ie = 1,ii = 1,io = 1,iu = 1; \\n        dp[0] = 5;\\n        \\n        for( int i=1; i<n; i++ ){\\n\\t\\t\\t// simply calculating current strings of length i by using previous string and current options values\\n            long tot = ((ia*1) + (ie*2) + (ii*4) + (io*2) + (iu*1))%mod;\\n            \\n\\t\\t\\t// finding out new values of strings ending with a specific character by using previous values\\n            long na = (ie+ii+iu)%mod;\\n            long ne = (ia + ii)%mod;\\n            long ni = (ie + io)%mod;\\n            long no = ii%mod;\\n            long nu = (ii+io)%mod;\\n            \\n            \\n            ia = na;\\n            ie = ne;\\n            ii = ni;\\n            io = no;\\n            iu = nu;\\n            \\n\\t\\t\\t// assigning value to dp\\n            dp[i] = tot;\\n        }\\n        \\n        return (int)dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390084,
                "title": "c-easy-to-understand-beating-98",
                "content": "class Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int64_t mod = (1\\'000\\'000\\'007);\\n        if (n == 1) return 5;\\n        int64_t a = 1, e = 1, i = 1, o = 1, u = 1;\\n        while (n > 1) {\\n            int64_t new_e  = (a + i ) % mod;\\n            int64_t new_a = (e + u + i) % mod;\\n            int64_t new_i = (e + o) % mod;\\n            int64_t new_o = i;\\n            int64_t new_u = (i + o) % mod;\\n            a = new_a, e = new_e, i = new_i, o = new_o, u = new_u;\\n            n--;\\n        }\\n        return (a + e + i + o + u) % mod;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int64_t mod = (1\\'000\\'000\\'007);\\n        if (n == 1) return 5;\\n        int64_t a = 1, e = 1, i = 1, o = 1, u = 1;\\n        while (n > 1) {\\n            int64_t new_e  = (a + i ) % mod;\\n            int64_t new_a = (e + u + i) % mod;\\n            int64_t new_i = (e + o) % mod;\\n            int64_t new_o = i;\\n            int64_t new_u = (i + o) % mod;\\n            a = new_a, e = new_e, i = new_i, o = new_o, u = new_u;\\n            n--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1509696,
                "title": "java-dp-recursion-memoization-scales-beyond-n-2-10-4",
                "content": "```\\nclass Solution {\\n    \\n    private static Map<String, Long> memoizedPermutations = new HashMap<>();\\n    private static int MOD = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        return (int) ((helper(n, \\'a\\') + helper(n, \\'e\\') + helper(n, \\'i\\') + helper(n, \\'o\\') + helper(n, \\'u\\')) % MOD);\\n    }\\n    \\n    private long helper(int n, char currentChar) {\\n        if (n == 1) return 1L;\\n        String key = String.valueOf(n) + String.valueOf(currentChar);\\n        long val = memoizedPermutations.getOrDefault(key, -1L);\\n        if (val != -1L) return val;\\n        switch (currentChar) {\\n            case \\'a\\':\\n                val = helper(n-1, \\'e\\');\\n                break;\\n            case \\'e\\':\\n                val = (helper(n-1, \\'a\\') + helper(n-1, \\'i\\'));\\n                break;\\n            case \\'i\\':\\n                val = (helper(n-1, \\'a\\') + helper(n-1, \\'e\\') + helper(n-1, \\'o\\') + helper(n-1, \\'u\\'));\\n                break;\\n            case \\'o\\':\\n                val = (helper(n-1, \\'i\\') + helper(n-1, \\'u\\'));\\n                break;\\n            case \\'u\\':\\n                val = (helper(n-1, \\'a\\'));\\n                break;\\n            default :\\n                // throw new IllegalArgumentException(\"Character can only be one of the vowels - \\'a\\', \\'e\\', \\'i\\', \\'o\\' and \\'u\\'.\");\\n                return 0;\\n        }\\n        memoizedPermutations.put(key, val % MOD);\\n        return val;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    private static Map<String, Long> memoizedPermutations = new HashMap<>();\\n    private static int MOD = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        return (int) ((helper(n, \\'a\\') + helper(n, \\'e\\') + helper(n, \\'i\\') + helper(n, \\'o\\') + helper(n, \\'u\\')) % MOD);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1476536,
                "title": "c-dp-explanation",
                "content": "Lets just write the cases which are acceptable\\n\\n```\\nae\\nea  ei\\nia  ie  io  iu\\noi  ou\\nua\\n```\\nTherefore, for any \\'a\\' we can have \\'e\\', \\'i\\', \\'u\\' as the predecessor. Lets write for each vowel\\n```\\na --> e  i  u             dp[i][0] = dp[i-1][1] + dp[i-1][2] + dp[i-1][4]\\ne --> i  a                dp[i][1] = dp[i-1][2] + dp[i-1][0]\\ni --> e  o                dp[i][2] = dp[i-1][1] + dp[i-1][3]\\no --> i                   dp[i][3] = dp[i-1][2]\\nu --> o  i                dp[i][4] = dp[i-1][3] + dp[i-1][2]\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<long long int> > dp(n, vector<long long int>(5,0));\\n        int mod = 1e9+7;\\n        \\n        for(int i=0;i<5;i++){\\n            dp[0][i]=1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            dp[i][0] = (dp[i-1][1] + dp[i-1][2] + dp[i-1][4])%mod;\\n            \\n            dp[i][1] = (dp[i-1][2] + dp[i-1][0])%mod;\\n            \\n            dp[i][2] = (dp[i-1][1] + dp[i-1][3])%mod;\\n            \\n            dp[i][3] = (dp[i-1][2])%mod;\\n            \\n            dp[i][4] = (dp[i-1][3] + dp[i-1][2])%mod;\\n        }\\n        \\n        long long int sum=0;\\n        \\n        for(int i=0;i<5;i++){\\n            sum+=dp[n-1][i];\\n            sum%=mod;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nae\\nea  ei\\nia  ie  io  iu\\noi  ou\\nua\\n```\n```\\na --> e  i  u             dp[i][0] = dp[i-1][1] + dp[i-1][2] + dp[i-1][4]\\ne --> i  a                dp[i][1] = dp[i-1][2] + dp[i-1][0]\\ni --> e  o                dp[i][2] = dp[i-1][1] + dp[i-1][3]\\no --> i                   dp[i][3] = dp[i-1][2]\\nu --> o  i                dp[i][4] = dp[i-1][3] + dp[i-1][2]\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<long long int> > dp(n, vector<long long int>(5,0));\\n        int mod = 1e9+7;\\n        \\n        for(int i=0;i<5;i++){\\n            dp[0][i]=1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            dp[i][0] = (dp[i-1][1] + dp[i-1][2] + dp[i-1][4])%mod;\\n            \\n            dp[i][1] = (dp[i-1][2] + dp[i-1][0])%mod;\\n            \\n            dp[i][2] = (dp[i-1][1] + dp[i-1][3])%mod;\\n            \\n            dp[i][3] = (dp[i-1][2])%mod;\\n            \\n            dp[i][4] = (dp[i-1][3] + dp[i-1][2])%mod;\\n        }\\n        \\n        long long int sum=0;\\n        \\n        for(int i=0;i<5;i++){\\n            sum+=dp[n-1][i];\\n            sum%=mod;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413566,
                "title": "explained-clean-o-n-dp-remaining-choices-depends-on-previous-choice",
                "content": "Each vowel has only specific vowels allowed in next position, we will make this mapping and call it `adj` \\n```\\n\\'a\\': [\\'e\\'],\\n\\'e\\': [\\'a\\', \\'i\\'],\\n\\'i\\':  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'],\\n\\'o\\': [\\'i\\', \\'u\\'],\\n\\'u\\': [\\'a\\']\\n```\\nI have to pick `N` chars\\n--> At the given moment, I have a choice of picking any char which is adjacent to previous ...\\n\\n## So what is the state/relation ?\\n\\n- Answer depends on `N` and `prev` \\n\\n```\\nDP(prev, N) = ? = ans\\nans = 0\\nfor vowel in adj[prev]:\\n  ans += DP(vowel, N - 1)\\n```\\n\\n## \\uD83D\\uDE01What about base case ?\\nOnly one possible way of length zero, `\\'\\'` \\n- i.e. empty string so..\\n- `if N == 0: return 1`\\n\\n\\n## What is our final answer ?\\nInitially we can pick any `vowel` \\n- let base case be represented as `prev = 0`\\nso `adj[0] = [ \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' ]`\\nand our final answer is `DP(prev=0, N)`\\n## yayy but why DP ?\\n- same state can be reached multiple times.... \\n\\t- overlapping subproblems \\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        self.adj = {\\n            \\'0\\': list(vowels),\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': list(vowels - {\\'i\\'}),\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        @functools.cache\\n        def ways(prev, n):\\n            if n == 0: return 1\\n            res = 0\\n            for cur in self.adj[prev]:\\n                res = (res + ways(cur,n-1)) % (10**9+7)\\n            return res\\n    \\n        return ways(\\'0\\', n)\\n    \\n    # LOG N is possible WOW https://leetcode.com/problems/count-vowels-permutation/discuss/398173/C%2B%2B-Bottom-up-Recursive-DPs-O(n)-and-Matrix-Exponentiation-O(logn)  \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\'a\\': [\\'e\\'],\\n\\'e\\': [\\'a\\', \\'i\\'],\\n\\'i\\':  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'],\\n\\'o\\': [\\'i\\', \\'u\\'],\\n\\'u\\': [\\'a\\']\\n```\n```\\nDP(prev, N) = ? = ans\\nans = 0\\nfor vowel in adj[prev]:\\n  ans += DP(vowel, N - 1)\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        self.adj = {\\n            \\'0\\': list(vowels),\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': list(vowels - {\\'i\\'}),\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        @functools.cache\\n        def ways(prev, n):\\n            if n == 0: return 1\\n            res = 0\\n            for cur in self.adj[prev]:\\n                res = (res + ways(cur,n-1)) % (10**9+7)\\n            return res\\n    \\n        return ways(\\'0\\', n)\\n    \\n    # LOG N is possible WOW https://leetcode.com/problems/count-vowels-permutation/discuss/398173/C%2B%2B-Bottom-up-Recursive-DPs-O(n)-and-Matrix-Exponentiation-O(logn)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316138,
                "title": "python-simple-and-short-solution-with-o-n-time-and-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod=1000000007\\n        a=e=i=o=u=1\\n        for _ in range(n-1):\\n            a, e, i, o, u=(e+i+u)%mod, (a+i)%mod, (e+o)%mod, i%mod, (i+o)%mod\\n        return (a+e+i+o+u)%mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod=1000000007\\n        a=e=i=o=u=1\\n        for _ in range(n-1):\\n            a, e, i, o, u=(e+i+u)%mod, (a+i)%mod, (e+o)%mod, i%mod, (i+o)%mod\\n        return (a+e+i+o+u)%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315743,
                "title": "rust-solution",
                "content": "```rust\\nconst MOD: u32 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn count_vowel_permutation(n: i32) -> i32 {\\n        ((1..n)\\n            .fold([1; 5], |v, _| {\\n                [\\n                    (v[1] + v[2] + v[4]) % MOD,\\n                    (v[0] + v[2]) % MOD,\\n                    (v[1] + v[3]) % MOD,\\n                    (v[2]) % MOD,\\n                    (v[2] + v[3]) % MOD,\\n                ]\\n            })\\n            .iter()\\n            .sum::<u32>()\\n            % MOD) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nconst MOD: u32 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn count_vowel_permutation(n: i32) -> i32 {\\n        ((1..n)\\n            .fold([1; 5], |v, _| {\\n                [\\n                    (v[1] + v[2] + v[4]) % MOD,\\n                    (v[0] + v[2]) % MOD,\\n                    (v[1] + v[3]) % MOD,\\n                    (v[2]) % MOD,\\n                    (v[2] + v[3]) % MOD,\\n                ]\\n            })\\n            .iter()\\n            .sum::<u32>()\\n            % MOD) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315444,
                "title": "c-matrix-exponentation-log-n-running-time",
                "content": "The following implementation would require the some prior knowledge in Matrix Exponentiation\\n\\nLet us map the vowels ```{a,e,i,o,u}  to numbers  {0,1,2,3,4}```. \\nThe dp transition looks like\\n```\\ndp[i][0]=dp[i-1][1]+dp[i-1][2]+dp[i-1][4]\\ndp[i][1]=dp[i-1][0]+dp[i-1][2]\\ndp[i][2]=dp[i-1][1]+dp[i-1][3]\\ndp[i][3]=dp[i-1][2]\\ndp[i][4]=dp[i-1][2]+dp[i-1][3]\\n```\\nRepresenting this above transition using matrix and using ``` dp[0]=dp[1]=dp[2]=dp[3]=dp[4]=1 initially ``` we can calculate ```path[i][j] for all i=[0,4] and all j=[0,4] after n iterations (where path[i][j] represents total strings which have character i after n iterations and we started with character j in the begining)``` in ``` log(n)``` time by using binary exponentiation\\n\\n\\nHere is the simple implementation of above approach \\n```\\n#define rep(i,n) for(int i=0;i<n;i++)\\n// Initialize a matrix construct\\nlong long m=1e9+7;\\nstruct Matrix{\\n    vector< vector<long long> >a=vector<vector<long long>>(5,vector<long long>(5,0));\\n    Matrix operator *(const Matrix& other){\\n        Matrix product;\\n        rep(i,5)rep(j,5)rep(k,5){\\n            product.a[i][k]=((product.a[i][k])+(a[i][j]) * (other.a[j][k]))%m;\\n                   }\\n        return product;\\n    }\\n};\\n// Function for binary exponentiation of matrices\\nMatrix binpow(Matrix a, long long b) {\\n    Matrix res;\\n    rep(i,5)res.a[i][i]=1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a ;\\n        a = a * a ;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        \\n        Matrix Transition;\\n        Transition.a[0][1]=1;\\n        Transition.a[0][2]=1;\\n        Transition.a[0][4]=1;\\n        \\n        Transition.a[1][0]=1;\\n        Transition.a[1][2]=1;\\n        \\n        Transition.a[2][1]=1;\\n        Transition.a[2][3]=1;\\n        \\n        Transition.a[3][2]=1;\\n        \\n        Transition.a[4][2]=1;\\n        Transition.a[4][3]=1;\\n        \\n        Matrix ans=binpow(Transition,n-1);\\n        long long sum=0;\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<5;j++){\\n                sum=(sum+ans.a[i][j])%m;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```{a,e,i,o,u}  to numbers  {0,1,2,3,4}```\n```\\ndp[i][0]=dp[i-1][1]+dp[i-1][2]+dp[i-1][4]\\ndp[i][1]=dp[i-1][0]+dp[i-1][2]\\ndp[i][2]=dp[i-1][1]+dp[i-1][3]\\ndp[i][3]=dp[i-1][2]\\ndp[i][4]=dp[i-1][2]+dp[i-1][3]\\n```\n``` dp[0]=dp[1]=dp[2]=dp[3]=dp[4]=1 initially ```\n```path[i][j] for all i=[0,4] and all j=[0,4] after n iterations (where path[i][j] represents total strings which have character i after n iterations and we started with character j in the begining)```\n``` log(n)```\n```\\n#define rep(i,n) for(int i=0;i<n;i++)\\n// Initialize a matrix construct\\nlong long m=1e9+7;\\nstruct Matrix{\\n    vector< vector<long long> >a=vector<vector<long long>>(5,vector<long long>(5,0));\\n    Matrix operator *(const Matrix& other){\\n        Matrix product;\\n        rep(i,5)rep(j,5)rep(k,5){\\n            product.a[i][k]=((product.a[i][k])+(a[i][j]) * (other.a[j][k]))%m;\\n                   }\\n        return product;\\n    }\\n};\\n// Function for binary exponentiation of matrices\\nMatrix binpow(Matrix a, long long b) {\\n    Matrix res;\\n    rep(i,5)res.a[i][i]=1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a ;\\n        a = a * a ;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        \\n        Matrix Transition;\\n        Transition.a[0][1]=1;\\n        Transition.a[0][2]=1;\\n        Transition.a[0][4]=1;\\n        \\n        Transition.a[1][0]=1;\\n        Transition.a[1][2]=1;\\n        \\n        Transition.a[2][1]=1;\\n        Transition.a[2][3]=1;\\n        \\n        Transition.a[3][2]=1;\\n        \\n        Transition.a[4][2]=1;\\n        Transition.a[4][3]=1;\\n        \\n        Matrix ans=binpow(Transition,n-1);\\n        long long sum=0;\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<5;j++){\\n                sum=(sum+ans.a[i][j])%m;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314945,
                "title": "go-dynamic-programming-o-n-time-0ms",
                "content": "```\\nfunc countVowelPermutation(n int) int {\\n    var mod int64 = 1000000007\\n    var a , e, i, o, u int64 = 1, 1, 1, 1, 1\\n    for p:=1;p<n; p++ {\\n        aNew := (e+i+u) % mod\\n        eNew := (a+i) % mod\\n        iNew := (e+o) % mod\\n        oNew := i % mod\\n        uNew := (i+o) % mod\\n        a, e,i,o,u = aNew, eNew, iNew, oNew, uNew\\n    }\\n    return int((a+e+i+o+u)%mod)\\n}",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc countVowelPermutation(n int) int {\\n    var mod int64 = 1000000007\\n    var a , e, i, o, u int64 = 1, 1, 1, 1, 1\\n    for p:=1;p<n; p++ {\\n        aNew := (e+i+u) % mod\\n        eNew := (a+i) % mod\\n        iNew := (e+o) % mod\\n        oNew := i % mod\\n        uNew := (i+o) % mod\\n        a, e,i,o,u = aNew, eNew, iNew, oNew, uNew\\n    }\\n    return int((a+e+i+o+u)%mod)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 450421,
                "title": "simple-dp-solution-java-with-comments",
                "content": "```\\n long[][] dp;\\n    int mod = ((int)Math.pow(10,9))+7;\\n    public int countVowelPermutation(int n) {\\n        dp = new long[n+1][5]; // 0-> a, 1->e, 2->i, 3->o,4->u\\n        for(int i=0;i<5;i++) { // if n==1 we can only have 1 type of each character.\\n            dp[1][i]=1;\\n        }\\n        int sum=0;\\n        for (int i=0;i<5;i++) {\\n            sum=(sum+util(n,i))%mod;\\n        }\\n        return sum;\\n    }\\n\\n    private int util(int n,int index) {\\n        if(dp[n][index]!=0) { // Number of ways when we have n count left and we are at the vowel with index i.\\n            return (int) dp[n][index];\\n        }\\n        long sum=0;\\n        switch(index) {\\n            case 0:// If \\'a\\' is the current char we can only have an \\'e\\' as the next char\\n                sum = (sum+util(n-1,1))%mod;\\n                break;\\n            case 1:// If \\'e\\' is the current char we can only have \\'a\\' & \\'i\\' as the next char\\n                sum = (sum+util(n-1,0)+util(n-1,2))%mod;//\\n                break;\\n            case 2:// If \\'i\\' is the current char we can have any character follow it except \\'i\\'\\n                sum = (sum+util(n-1,0)+util(n-1,1)+util(n-1,3)+util(n-1,4))%mod;\\n                break;\\n            case 3:// If \\'o\\' is the current char we can only have \\'i\\' & \\'u\\' as the next char\\n                sum = (sum+util(n-1,2)+util(n-1,4))%mod;\\n                break;\\n            case 4:// If \\'u\\' is the current char we can only have an \\'a\\' as the next char\\n                sum = (sum+util(n-1,0))%mod;\\n                break;\\n        }\\n\\n        dp[n][index]=sum;\\n        return (int) sum;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n long[][] dp;\\n    int mod = ((int)Math.pow(10,9))+7;\\n    public int countVowelPermutation(int n) {\\n        dp = new long[n+1][5]; // 0-> a, 1->e, 2->i, 3->o,4->u\\n        for(int i=0;i<5;i++) { // if n==1 we can only have 1 type of each character.\\n            dp[1][i]=1;\\n        }\\n        int sum=0;\\n        for (int i=0;i<5;i++) {\\n            sum=(sum+util(n,i))%mod;\\n        }\\n        return sum;\\n    }\\n\\n    private int util(int n,int index) {\\n        if(dp[n][index]!=0) { // Number of ways when we have n count left and we are at the vowel with index i.\\n            return (int) dp[n][index];\\n        }\\n        long sum=0;\\n        switch(index) {\\n            case 0:// If \\'a\\' is the current char we can only have an \\'e\\' as the next char\\n                sum = (sum+util(n-1,1))%mod;\\n                break;\\n            case 1:// If \\'e\\' is the current char we can only have \\'a\\' & \\'i\\' as the next char\\n                sum = (sum+util(n-1,0)+util(n-1,2))%mod;//\\n                break;\\n            case 2:// If \\'i\\' is the current char we can have any character follow it except \\'i\\'\\n                sum = (sum+util(n-1,0)+util(n-1,1)+util(n-1,3)+util(n-1,4))%mod;\\n                break;\\n            case 3:// If \\'o\\' is the current char we can only have \\'i\\' & \\'u\\' as the next char\\n                sum = (sum+util(n-1,2)+util(n-1,4))%mod;\\n                break;\\n            case 4:// If \\'u\\' is the current char we can only have an \\'a\\' as the next char\\n                sum = (sum+util(n-1,0))%mod;\\n                break;\\n        }\\n\\n        dp[n][index]=sum;\\n        return (int) sum;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399077,
                "title": "python-dfs-memoization",
                "content": "Memo[c, i] saved total number of vowel permutation which starts with character c and has a length of i+1.\\n\"$\" serves as the root of the vowels graph.\\n```\\ndef countVowelPermutation(n):\\n\\tgraph = {\\n\\t\\t\"$\":\"aeiou\",\\n\\t\\t\"a\":\"e\",\\n\\t\\t\"e\":\"ai\",\\n\\t\\t\"i\":\"aeou\",\\n\\t\\t\"o\":\"iu\",\\n\\t\\t\"u\":\"a\",\\n\\t}\\n\\tmemo = {(c,0):1 for c in \"aeiou\"}\\n\\tM = 10**9+7\\n\\tdef dfs(x, n):\\n\\t\\tif (x,n) not in memo\\n\\t\\t\\tmemo[x,n] = sum(dfs(y, n-1) for y in graph[x]) % M\\n\\t\\treturn memo[x,n]\\n\\treturn dfs(\"$\", n)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countVowelPermutation(n):\\n\\tgraph = {\\n\\t\\t\"$\":\"aeiou\",\\n\\t\\t\"a\":\"e\",\\n\\t\\t\"e\":\"ai\",\\n\\t\\t\"i\":\"aeou\",\\n\\t\\t\"o\":\"iu\",\\n\\t\\t\"u\":\"a\",\\n\\t}\\n\\tmemo = {(c,0):1 for c in \"aeiou\"}\\n\\tM = 10**9+7\\n\\tdef dfs(x, n):\\n\\t\\tif (x,n) not in memo\\n\\t\\t\\tmemo[x,n] = sum(dfs(y, n-1) for y in graph[x]) % M\\n\\t\\treturn memo[x,n]\\n\\treturn dfs(\"$\", n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 398198,
                "title": "python3-straightforward",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        dp = [1] * 5\\n        for _ in range(n - 1):\\n            add = [0] * 5\\n            # from a\\n            add[1] = (add[1] + dp[0]) % mod\\n            # from e\\n            add[0] = (add[0] + dp[1]) % mod\\n            add[2] = (add[2] + dp[1]) % mod\\n            # from i\\n            add[0] = (add[0] + dp[2]) % mod\\n            add[1] = (add[1] + dp[2]) % mod\\n            add[3] = (add[3] + dp[2]) % mod\\n            add[4] = (add[4] + dp[2]) % mod\\n            # from o\\n            add[2] = (add[2] + dp[3]) % mod\\n            add[4] = (add[4] + dp[3]) % mod\\n            # from u\\n            add[0] = (add[0] + dp[4]) % mod\\n            for i in range(5):\\n                dp[i] = add[i] % mod\\n        return sum(dp) % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        dp = [1] * 5\\n        for _ in range(n - 1):\\n            add = [0] * 5\\n            # from a\\n            add[1] = (add[1] + dp[0]) % mod\\n            # from e\\n            add[0] = (add[0] + dp[1]) % mod\\n            add[2] = (add[2] + dp[1]) % mod\\n            # from i\\n            add[0] = (add[0] + dp[2]) % mod\\n            add[1] = (add[1] + dp[2]) % mod\\n            add[3] = (add[3] + dp[2]) % mod\\n            add[4] = (add[4] + dp[2]) % mod\\n            # from o\\n            add[2] = (add[2] + dp[3]) % mod\\n            add[4] = (add[4] + dp[3]) % mod\\n            # from u\\n            add[0] = (add[0] + dp[4]) % mod\\n            for i in range(5):\\n                dp[i] = add[i] % mod\\n        return sum(dp) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393120,
                "title": "java-o-n-extremely-easy-and-short-dp-solution-with-two-dimension-array",
                "content": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n      int mod = 1000000007;\\n      long[][]combinations = new long[5][n];\\n        for (int i=0;i<=4;i++)combinations[i][0]=1;\\n        for (int i=1;i<n;i++){\\n              combinations[0][i]=combinations[1][i-1];\\n              combinations[1][i]=(combinations[0][i-1]+combinations[2][i-1])%mod;\\n              combinations[2][i]=(combinations[0][i-1]+combinations[1][i-1]+combinations[3][i-1]+combinations[4][i-1])%mod;\\n              combinations[3][i]=(combinations[2][i-1]+combinations[4][i-1])%mod;\\n              combinations[4][i]=combinations[0][i-1];\\n        }\\n        return (int)((combinations[0][n-1]+combinations[1][n-1]+combinations[2][n-1]+combinations[3][n-1]+combinations[4][n-1])%mod);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n      int mod = 1000000007;\\n      long[][]combinations = new long[5][n];\\n        for (int i=0;i<=4;i++)combinations[i][0]=1;\\n        for (int i=1;i<n;i++){\\n              combinations[0][i]=combinations[1][i-1];\\n              combinations[1][i]=(combinations[0][i-1]+combinations[2][i-1])%mod;\\n              combinations[2][i]=(combinations[0][i-1]+combinations[1][i-1]+combinations[3][i-1]+combinations[4][i-1])%mod;\\n              combinations[3][i]=(combinations[2][i-1]+combinations[4][i-1])%mod;\\n              combinations[4][i]=combinations[0][i-1];\\n        }\\n        return (int)((combinations[0][n-1]+combinations[1][n-1]+combinations[2][n-1]+combinations[3][n-1]+combinations[4][n-1])%mod);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392178,
                "title": "easy-c-solution-4-approaches-recursion-top-down-bottom-up-space-optimized",
                "content": "#  -> Approach 1: Recursion (TLE)\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        if(n==1)\\n            return 5;\\n        \\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        int c=0;\\n        for(int i=0; i<5; i++)\\n            c += count(i, 1, n, vowels);\\n            \\n        return c;\\n    }\\n    \\n    int count(int prev, int len, int n, vector<int> vowels){\\n        if(len==n)\\n            return 1;\\n        \\n        if(prev == 0)\\n            return count(1, len+1, n, vowels);\\n        if(prev == 1)\\n            return count(0, len+1, n, vowels)+count(2, len+1, n, vowels);\\n        if(prev == 2)\\n            return count(0, len+1, n, vowels)+count(1, len+1, n, vowels)+\\n                   count(3, len+1, n, vowels)+count(4, len+1, n, vowels);\\n        if(prev == 3)\\n            return count(2, len+1, n, vowels)+count(4, len+1, n, vowels);\\n        if(prev == 4)\\n            return count(0, len+1, n, vowels);\\n        \\n        return 0;\\n    }\\n};\\n```\\n\\n#  -> Approach 2: Top-Down (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        if(n==1)\\n            return 5;\\n        \\n        vector<vector<int>> dp(5, vector<int> (n+1, -1));\\n        for(int i=0; i<5; i++)\\n            dp[i][n]=1;\\n        \\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        int c=0;\\n        for(int i=0; i<5; i++)\\n            c = (c+count(i, 1, n, vowels, dp))%mod;\\n            \\n        return c;\\n    }\\n    \\n    long long int count(int prev, int len, int n, vector<int> vowels, vector<vector<int>> &dp){\\n        if(dp[prev][len] != -1)\\n            return dp[prev][len]%mod;\\n        \\n        long long int c=0;\\n        if(prev == 0)\\n            c = count(1, len+1, n, vowels, dp)%mod;\\n        else if(prev == 1)\\n            c = (count(0, len+1, n, vowels, dp)+count(2, len+1, n, vowels, dp))%mod;\\n        else if(prev == 2)\\n            c = (count(0, len+1, n, vowels, dp)+count(1, len+1, n, vowels, dp)+\\n                    count(3, len+1, n, vowels, dp)+count(4, len+1, n, vowels, dp))%mod;\\n        else if(prev == 3)\\n            c = (count(2, len+1, n, vowels, dp)+count(4, len+1, n, vowels, dp))%mod;\\n        else if(prev == 4)\\n            c = (count(0, len+1, n, vowels, dp))%mod;\\n        \\n        return dp[prev][len] = c;\\n    }\\n};\\n```\\n\\n#  -> Approach 3: Bottom-Up (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        vector<vector<long>> dp(5, vector<long> (n+1, 0));\\n        for(int i=0; i<5; i++)\\n            dp[i][n]=1;\\n        \\n      \\n        for(int len=n-1; len>0; len--){\\n            dp[0][len]=  (dp[1][len+1])%mod;\\n            dp[1][len] = (dp[0][len+1]+dp[2][len+1])%mod;\\n            dp[2][len] = (dp[0][len+1]+dp[1][len+1]+dp[3][len+1]+dp[4][len+1])%mod;\\n            dp[3][len] = (dp[2][len+1]+dp[4][len+1])%mod;\\n            dp[4][len] = (dp[0][len+1])%mod;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<5; i++)\\n            ans = (ans+dp[i][1])%mod;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n#  -> Approach 4: Space Optimisation (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        vector<long> prev(5, 1);\\n      \\n        vector<long> curr(5, 0);\\n        for(int len=n-1; len>0; len--){\\n            curr[0] = prev[1]%mod;\\n            curr[1] = (prev[0]+prev[2])%mod;\\n            curr[2] = (prev[0]+prev[1]+prev[3]+prev[4])%mod;\\n            curr[3] = (prev[2]+prev[4])%mod;\\n            curr[4] = (prev[0])%mod;\\n            \\n            prev = curr;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<5; i++)\\n            ans = (ans+prev[i])%mod;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        if(n==1)\\n            return 5;\\n        \\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        int c=0;\\n        for(int i=0; i<5; i++)\\n            c += count(i, 1, n, vowels);\\n            \\n        return c;\\n    }\\n    \\n    int count(int prev, int len, int n, vector<int> vowels){\\n        if(len==n)\\n            return 1;\\n        \\n        if(prev == 0)\\n            return count(1, len+1, n, vowels);\\n        if(prev == 1)\\n            return count(0, len+1, n, vowels)+count(2, len+1, n, vowels);\\n        if(prev == 2)\\n            return count(0, len+1, n, vowels)+count(1, len+1, n, vowels)+\\n                   count(3, len+1, n, vowels)+count(4, len+1, n, vowels);\\n        if(prev == 3)\\n            return count(2, len+1, n, vowels)+count(4, len+1, n, vowels);\\n        if(prev == 4)\\n            return count(0, len+1, n, vowels);\\n        \\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        if(n==1)\\n            return 5;\\n        \\n        vector<vector<int>> dp(5, vector<int> (n+1, -1));\\n        for(int i=0; i<5; i++)\\n            dp[i][n]=1;\\n        \\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        int c=0;\\n        for(int i=0; i<5; i++)\\n            c = (c+count(i, 1, n, vowels, dp))%mod;\\n            \\n        return c;\\n    }\\n    \\n    long long int count(int prev, int len, int n, vector<int> vowels, vector<vector<int>> &dp){\\n        if(dp[prev][len] != -1)\\n            return dp[prev][len]%mod;\\n        \\n        long long int c=0;\\n        if(prev == 0)\\n            c = count(1, len+1, n, vowels, dp)%mod;\\n        else if(prev == 1)\\n            c = (count(0, len+1, n, vowels, dp)+count(2, len+1, n, vowels, dp))%mod;\\n        else if(prev == 2)\\n            c = (count(0, len+1, n, vowels, dp)+count(1, len+1, n, vowels, dp)+\\n                    count(3, len+1, n, vowels, dp)+count(4, len+1, n, vowels, dp))%mod;\\n        else if(prev == 3)\\n            c = (count(2, len+1, n, vowels, dp)+count(4, len+1, n, vowels, dp))%mod;\\n        else if(prev == 4)\\n            c = (count(0, len+1, n, vowels, dp))%mod;\\n        \\n        return dp[prev][len] = c;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        vector<vector<long>> dp(5, vector<long> (n+1, 0));\\n        for(int i=0; i<5; i++)\\n            dp[i][n]=1;\\n        \\n      \\n        for(int len=n-1; len>0; len--){\\n            dp[0][len]=  (dp[1][len+1])%mod;\\n            dp[1][len] = (dp[0][len+1]+dp[2][len+1])%mod;\\n            dp[2][len] = (dp[0][len+1]+dp[1][len+1]+dp[3][len+1]+dp[4][len+1])%mod;\\n            dp[3][len] = (dp[2][len+1]+dp[4][len+1])%mod;\\n            dp[4][len] = (dp[0][len+1])%mod;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<5; i++)\\n            ans = (ans+dp[i][1])%mod;\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        vector<long> prev(5, 1);\\n      \\n        vector<long> curr(5, 0);\\n        for(int len=n-1; len>0; len--){\\n            curr[0] = prev[1]%mod;\\n            curr[1] = (prev[0]+prev[2])%mod;\\n            curr[2] = (prev[0]+prev[1]+prev[3]+prev[4])%mod;\\n            curr[3] = (prev[2]+prev[4])%mod;\\n            curr[4] = (prev[0])%mod;\\n            \\n            prev = curr;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<5; i++)\\n            ans = (ans+prev[i])%mod;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391368,
                "title": "recursive-to-dynamic-programming-explained",
                "content": "Recursive(TLE) :If you want how this is working then uncommnet and see the out at each stage surely you will get the idea.\\n```\\nclass Solution {\\n    static List<String> list;\\n    //static Map<String,List<String>> mp;\\n    public int countVowelPermutation(int n){\\n          list=new ArrayList();\\n          list.add(\"a\");\\n          list.add(\"e\");\\n          list.add(\"i\");\\n          list.add(\"o\");\\n          list.add(\"u\");\\n        \\n        Map<String,List<String>> mp=new HashMap<>();\\n        mp.put(\"a\",new ArrayList<String>());\\n        mp.get(\"a\").add(\"e\");\\n        \\n        //System.out.println(mp.get(\"a\"));\\n        \\n        mp.put(\"e\",new ArrayList<String>());\\n        mp.get(\"e\").add(\"a\");\\n        mp.get(\"e\").add(\"i\");\\n        \\n        mp.put(\"i\",new ArrayList());\\n        mp.get(\"i\").add(\"a\");\\n        mp.get(\"i\").add(\"e\");\\n        mp.get(\"i\").add(\"o\");\\n        mp.get(\"i\").add(\"u\");\\n        \\n        mp.put(\"o\",new ArrayList());\\n        mp.get(\"o\").add(\"i\");\\n        mp.get(\"o\").add(\"u\");\\n        \\n        mp.put(\"u\",new ArrayList());\\n        mp.get(\"u\").add(\"a\");\\n        \\n        List<String> ans=new ArrayList();\\n        \\n        \\n        return solve(0,n,ans,mp,new StringBuilder(\"\"),new HashMap<String,Integer>());\\n    }\\n    \\n    \\n    public static int solve(int idx,int end,List<String> ans,Map<String,List<String>> mp,StringBuilder asf,HashMap<String,Integer> dict){\\n        if(idx==end){\\n            //System.out.println(asf);\\n            ans.add(asf.toString());\\n            return 1;\\n        }\\n        \\n        String key=idx+\"#\"+asf+\"#\";\\n        \\n        if(dict.containsKey(key)==true){\\n            System.out.println(key);\\n             return dict.get(key);\\n        }\\n        \\n        int count=0;\\n        \\n        if(idx==0){\\n              for(int i=0;i<list.size();i++){\\n                 asf.append(list.get(i)+\"\");\\n                 count+=solve(idx+1,end,ans,mp,asf,dict);\\n                 asf.deleteCharAt(idx);\\n              }\\n        }else{\\n             for(int i=0;i<list.size();i++){\\n                 List<String> find=mp.get(list.get(i));\\n                // System.out.println(list.get(i)+\" \"+asf.charAt(idx-1)+\" \"+idx);\\n                 if(find==null) continue;\\n                 if(find.contains(asf.charAt(idx-1)+\"\")==false) continue; \\n                 asf.append(list.get(i)+\"\");\\n                 count+=solve(idx+1,end,ans,mp,asf,dict);\\n                 asf.deleteCharAt(idx);\\n             }\\n        }\\n        \\n        dict.put(key,count);\\n        \\n        // for(Map.Entry<String,List<String>> ent: mp.entrySet()){\\n        //     System.out.println(ent.getKey() +\" \"+ ent.getValue());\\n        // }\\n        \\n        return count;\\n```\\n\\nDynamic Programming(Accepted)\\ndp[i][j] : stores the count of strings of length i which ends at char j.\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[][] dp=new long[n+1][5];\\n        \\n        for(int i=0;i<5;i++){\\n            dp[1][i]=1;\\n        }\\n        \\n        int mod=(int)1e9 +7;\\n        \\n        for(int i=2;i<=n;i++){ \\n             dp[i][0]=(dp[i-1][1] )% mod;  \\n             dp[i][1]=(dp[i-1][0] + dp[i-1][2])% mod;\\n             dp[i][2]=(dp[i-1][0] + dp[i-1][1] +dp[i-1][3] + dp[i-1][4] )% mod;\\n             dp[i][3]=(dp[i-1][2] + dp[i-1][4])% mod;\\n             dp[i][4]=(dp[i-1][0])% mod;\\n        }\\n        \\n        long count=0;\\n        for(int j=0;j<5;j++){\\n            count=( count + dp[n][j])%mod;\\n        }\\n        \\n        return (int)count;\\n        \\n    }\\n}\\n```\\n\\n```\\nplz upvote if you like\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static List<String> list;\\n    //static Map<String,List<String>> mp;\\n    public int countVowelPermutation(int n){\\n          list=new ArrayList();\\n          list.add(\"a\");\\n          list.add(\"e\");\\n          list.add(\"i\");\\n          list.add(\"o\");\\n          list.add(\"u\");\\n        \\n        Map<String,List<String>> mp=new HashMap<>();\\n        mp.put(\"a\",new ArrayList<String>());\\n        mp.get(\"a\").add(\"e\");\\n        \\n        //System.out.println(mp.get(\"a\"));\\n        \\n        mp.put(\"e\",new ArrayList<String>());\\n        mp.get(\"e\").add(\"a\");\\n        mp.get(\"e\").add(\"i\");\\n        \\n        mp.put(\"i\",new ArrayList());\\n        mp.get(\"i\").add(\"a\");\\n        mp.get(\"i\").add(\"e\");\\n        mp.get(\"i\").add(\"o\");\\n        mp.get(\"i\").add(\"u\");\\n        \\n        mp.put(\"o\",new ArrayList());\\n        mp.get(\"o\").add(\"i\");\\n        mp.get(\"o\").add(\"u\");\\n        \\n        mp.put(\"u\",new ArrayList());\\n        mp.get(\"u\").add(\"a\");\\n        \\n        List<String> ans=new ArrayList();\\n        \\n        \\n        return solve(0,n,ans,mp,new StringBuilder(\"\"),new HashMap<String,Integer>());\\n    }\\n    \\n    \\n    public static int solve(int idx,int end,List<String> ans,Map<String,List<String>> mp,StringBuilder asf,HashMap<String,Integer> dict){\\n        if(idx==end){\\n            //System.out.println(asf);\\n            ans.add(asf.toString());\\n            return 1;\\n        }\\n        \\n        String key=idx+\"#\"+asf+\"#\";\\n        \\n        if(dict.containsKey(key)==true){\\n            System.out.println(key);\\n             return dict.get(key);\\n        }\\n        \\n        int count=0;\\n        \\n        if(idx==0){\\n              for(int i=0;i<list.size();i++){\\n                 asf.append(list.get(i)+\"\");\\n                 count+=solve(idx+1,end,ans,mp,asf,dict);\\n                 asf.deleteCharAt(idx);\\n              }\\n        }else{\\n             for(int i=0;i<list.size();i++){\\n                 List<String> find=mp.get(list.get(i));\\n                // System.out.println(list.get(i)+\" \"+asf.charAt(idx-1)+\" \"+idx);\\n                 if(find==null) continue;\\n                 if(find.contains(asf.charAt(idx-1)+\"\")==false) continue; \\n                 asf.append(list.get(i)+\"\");\\n                 count+=solve(idx+1,end,ans,mp,asf,dict);\\n                 asf.deleteCharAt(idx);\\n             }\\n        }\\n        \\n        dict.put(key,count);\\n        \\n        // for(Map.Entry<String,List<String>> ent: mp.entrySet()){\\n        //     System.out.println(ent.getKey() +\" \"+ ent.getValue());\\n        // }\\n        \\n        return count;\\n```\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[][] dp=new long[n+1][5];\\n        \\n        for(int i=0;i<5;i++){\\n            dp[1][i]=1;\\n        }\\n        \\n        int mod=(int)1e9 +7;\\n        \\n        for(int i=2;i<=n;i++){ \\n             dp[i][0]=(dp[i-1][1] )% mod;  \\n             dp[i][1]=(dp[i-1][0] + dp[i-1][2])% mod;\\n             dp[i][2]=(dp[i-1][0] + dp[i-1][1] +dp[i-1][3] + dp[i-1][4] )% mod;\\n             dp[i][3]=(dp[i-1][2] + dp[i-1][4])% mod;\\n             dp[i][4]=(dp[i-1][0])% mod;\\n        }\\n        \\n        long count=0;\\n        for(int j=0;j<5;j++){\\n            count=( count + dp[n][j])%mod;\\n        }\\n        \\n        return (int)count;\\n        \\n    }\\n}\\n```\n```\\nplz upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391285,
                "title": "dynamic-programming",
                "content": "```\\n  => Here, our idea to solve this problem is, we first need to understand for n=1 and n==2 ehat is valid permutation\\n  \\n  for n=1,\\n  \\n  a,e,i,o,u\\n  \\n  for n=2,\\n  \\n  if you observe question then you can be come up with below conclusion,\\n  \\n     before a  either e,u,i \\n\\t before e  either i,a\\n\\t before i  either e,o\\n\\t before o either i\\n\\t before u either o,i\\n\\t \\n\\tso for n=2 ans is \\n\\t\\n\\tua,ea,ia,ie,ae,ei,oi,io,ou,iu.\\n\\t\\n\\tso lets denote a=0, b=1, c=2, d=3, e=4;\\n\\t\\n\\tNow, out ith state of dp is dependent on i-1 state of dp\\n\\t\\n\\t    -> for 0(a charactor) of ith state we must choose 1(e),4(u),2(i) of i-1th dp state as we disscuss before a means before 0th charactor there must be e,u,i  which is denoted by 1,4,2.\\n\\t\\n\\t and so on for 1, 2, 3, 4th charator of ith state.\\n\\t   \\n```\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5,0));\\n        if(n==1) return 5;\\n        else if(n==2) return 10;\\n        \\n        dp[1][0]=dp[1][1]=dp[1][2]=dp[1][3]=dp[1][4]=1;\\n        \\n        for(int i=2;i<=n;i++)\\n        {  \\n            dp[i][0]=((dp[i-1][1]+dp[i-1][2])%mod+dp[i-1][4])%mod;\\n            dp[i][1]=(dp[i-1][0]+dp[i-1][2])%mod;\\n            dp[i][2]=(dp[i-1][1]+dp[i-1][3])%mod;\\n            dp[i][3]=(dp[i-1][2])%mod;\\n            dp[i][4]=(dp[i-1][2]+dp[i-1][3])%mod;\\n             \\n        }\\n        \\n        return (((dp[n][0]+dp[n][1])%mod+(dp[n][2]+dp[n][3])%mod)%mod+dp[n][4])%mod;\\n    }  \\n};\\n\\n\\n\\nIf you like please upvote.\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n  => Here, our idea to solve this problem is, we first need to understand for n=1 and n==2 ehat is valid permutation\\n  \\n  for n=1,\\n  \\n  a,e,i,o,u\\n  \\n  for n=2,\\n  \\n  if you observe question then you can be come up with below conclusion,\\n  \\n     before a  either e,u,i \\n\\t before e  either i,a\\n\\t before i  either e,o\\n\\t before o either i\\n\\t before u either o,i\\n\\t \\n\\tso for n=2 ans is \\n\\t\\n\\tua,ea,ia,ie,ae,ei,oi,io,ou,iu.\\n\\t\\n\\tso lets denote a=0, b=1, c=2, d=3, e=4;\\n\\t\\n\\tNow, out ith state of dp is dependent on i-1 state of dp\\n\\t\\n\\t    -> for 0(a charactor) of ith state we must choose 1(e),4(u),2(i) of i-1th dp state as we disscuss before a means before 0th charactor there must be e,u,i  which is denoted by 1,4,2.\\n\\t\\n\\t and so on for 1, 2, 3, 4th charator of ith state.\\n\\t   \\n```\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5,0));\\n        if(n==1) return 5;\\n        else if(n==2) return 10;\\n        \\n        dp[1][0]=dp[1][1]=dp[1][2]=dp[1][3]=dp[1][4]=1;\\n        \\n        for(int i=2;i<=n;i++)\\n        {  \\n            dp[i][0]=((dp[i-1][1]+dp[i-1][2])%mod+dp[i-1][4])%mod;\\n            dp[i][1]=(dp[i-1][0]+dp[i-1][2])%mod;\\n            dp[i][2]=(dp[i-1][1]+dp[i-1][3])%mod;\\n            dp[i][3]=(dp[i-1][2])%mod;\\n            dp[i][4]=(dp[i-1][2]+dp[i-1][3])%mod;\\n             \\n        }\\n        \\n        return (((dp[n][0]+dp[n][1])%mod+(dp[n][2]+dp[n][3])%mod)%mod+dp[n][4])%mod;\\n    }  \\n};\\n\\n\\n\\nIf you like please upvote.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390907,
                "title": "beats-100-other-s-solutions-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        \\n        long long int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1e9 + 7;\\n        for (int k = 2; k <= n; k++) {\\n            long long int ta = a, ti = i, te = e, to = o, tu = u;\\n            a = te;\\n            e = ta + ti;\\n            i = ta + te + to + tu;\\n            o = ti + tu;\\n            u = ta;\\n            \\n            a %= mod;\\n            e %= mod;\\n            i %= mod;\\n            o %= mod;\\n            u %= mod;\\n        }\\n        return (a + e + i + o + u) % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        \\n        long long int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1e9 + 7;\\n        for (int k = 2; k <= n; k++) {\\n            long long int ta = a, ti = i, te = e, to = o, tu = u;\\n            a = te;\\n            e = ta + ti;\\n            i = ta + te + to + tu;\\n            o = ti + tu;\\n            u = ta;\\n            \\n            a %= mod;\\n            e %= mod;\\n            i %= mod;\\n            o %= mod;\\n            u %= mod;\\n        }\\n        return (a + e + i + o + u) % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308850,
                "title": "o-logn-solution-beats-100",
                "content": "```\\npublic class Solution {\\n    public int CountVowelPermutation(int n) {\\n        // converted adjacency list to matrix\\n        //a->e\\n        //e->a,i\\n        //i->a,e,o,u\\n        //o->i,u\\n        //u->a\\n        long[,] matrix = {\\n            {0,1,0,0,0},\\n            {1,0,1,0,0},\\n            {1,1,0,1,1},\\n            {0,0,1,0,1},\\n            {1,0,0,0,0}\\n        };\\n        long[,] res = {\\n            {1,1,1,1,1}\\n        };\\n        n=n-1;\\n        while(n>0){\\n            if(n%2==0){\\n                matrix = MatrixMultiplication(matrix,matrix);\\n                n/=2;\\n            }\\n            else{\\n                res = MatrixMultiplication(res,matrix);\\n                n-=1;\\n            }\\n        }\\n        long count=0;\\n        for(int i=0;i<5;i++){\\n            count=(count+res[0,i])%1000000007;\\n        }\\n        return (int)count;\\n     }\\n    \\n    public long[,] MatrixMultiplication(long[,] matrix1,long[,] matrix2){\\n        long[,] product = new long[5,5];\\n        for(int i=0;i<matrix1.GetLength(0);i++){\\n            for(int j=0;j<5;j++){\\n                for(int k=0;k<5;k++){\\n                    product[i,j] = (product[i,j]+matrix1[i,k]*matrix2[k,j])%1000000007;\\n                }\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountVowelPermutation(int n) {\\n        // converted adjacency list to matrix\\n        //a->e\\n        //e->a,i\\n        //i->a,e,o,u\\n        //o->i,u\\n        //u->a\\n        long[,] matrix = {\\n            {0,1,0,0,0},\\n            {1,0,1,0,0},\\n            {1,1,0,1,1},\\n            {0,0,1,0,1},\\n            {1,0,0,0,0}\\n        };\\n        long[,] res = {\\n            {1,1,1,1,1}\\n        };\\n        n=n-1;\\n        while(n>0){\\n            if(n%2==0){\\n                matrix = MatrixMultiplication(matrix,matrix);\\n                n/=2;\\n            }\\n            else{\\n                res = MatrixMultiplication(res,matrix);\\n                n-=1;\\n            }\\n        }\\n        long count=0;\\n        for(int i=0;i<5;i++){\\n            count=(count+res[0,i])%1000000007;\\n        }\\n        return (int)count;\\n     }\\n    \\n    public long[,] MatrixMultiplication(long[,] matrix1,long[,] matrix2){\\n        long[,] product = new long[5,5];\\n        for(int i=0;i<matrix1.GetLength(0);i++){\\n            for(int j=0;j<5;j++){\\n                for(int k=0;k<5;k++){\\n                    product[i,j] = (product[i,j]+matrix1[i,k]*matrix2[k,j])%1000000007;\\n                }\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001213,
                "title": "c-o-n-time-dynamic-programming-tribute-to-my-ex",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int countVowelPermutation(int n) {\\n        vector<long long> kar(n,1);\\n        vector<vector<long long>> opkar;\\n         const int mod=1e9+7;\\n        for(int i=0;i<5;++i){\\n            opkar.push_back(kar);\\n        }\\n        \\n        if(n==1){\\n            return 5;\\n        }\\n        else{\\n            for(int i=1;i<n;++i){                \\n                        opkar[0][i] = (opkar[2][i-1] + opkar[1][i-1] + opkar[4][i-1])%mod;                \\n                        opkar[1][i] = (opkar[0][i-1] + opkar[2][i-1])%mod;                    \\n                        opkar[2][i] = (opkar[1][i-1] + opkar[3][i-1])%mod;                    \\n                        opkar[3][i] = (opkar[2][i-1])%mod;\\n                        opkar[4][i] = (opkar[2][i-1] + opkar[3][i-1])%mod;\\n                                            \\n                }\\n            \\n            long long count = 0;\\n            for(int i =0;i<5;++i){\\n                count += opkar[i][n-1];\\n            }\\n            return count % mod;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int countVowelPermutation(int n) {\\n        vector<long long> kar(n,1);\\n        vector<vector<long long>> opkar;\\n         const int mod=1e9+7;\\n        for(int i=0;i<5;++i){\\n            opkar.push_back(kar);\\n        }\\n        \\n        if(n==1){\\n            return 5;\\n        }\\n        else{\\n            for(int i=1;i<n;++i){                \\n                        opkar[0][i] = (opkar[2][i-1] + opkar[1][i-1] + opkar[4][i-1])%mod;                \\n                        opkar[1][i] = (opkar[0][i-1] + opkar[2][i-1])%mod;                    \\n                        opkar[2][i] = (opkar[1][i-1] + opkar[3][i-1])%mod;                    \\n                        opkar[3][i] = (opkar[2][i-1])%mod;\\n                        opkar[4][i] = (opkar[2][i-1] + opkar[3][i-1])%mod;\\n                                            \\n                }\\n            \\n            long long count = 0;\\n            for(int i =0;i<5;++i){\\n                count += opkar[i][n-1];\\n            }\\n            return count % mod;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923424,
                "title": "c-100-fast-short-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    long long ans = 0;\\n    int countVowelPermutation(int n) {\\n        long long dp[5][n+1];\\n        \\n        memset(dp, 0, sizeof(dp));\\n        dp[0][1] = 1, dp[1][1] = 1, dp[2][1] = 1, dp[3][1] = 1, dp[4][1] = 1;\\n        \\n        for(int i = 2; i<=n; i++){\\n\\n                dp[0][i] = (dp[1][i-1]) % mod;\\n                dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % mod;\\n                dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % mod;\\n                dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % mod;\\n                dp[4][i] = (dp[0][i-1]) % mod;\\n            \\n        }\\n        \\n        for(int i =0; i<5; i++){\\n            ans = (ans + dp[i][n]) % mod;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    long long ans = 0;\\n    int countVowelPermutation(int n) {\\n        long long dp[5][n+1];\\n        \\n        memset(dp, 0, sizeof(dp));\\n        dp[0][1] = 1, dp[1][1] = 1, dp[2][1] = 1, dp[3][1] = 1, dp[4][1] = 1;\\n        \\n        for(int i = 2; i<=n; i++){\\n\\n                dp[0][i] = (dp[1][i-1]) % mod;\\n                dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % mod;\\n                dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % mod;\\n                dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % mod;\\n                dp[4][i] = (dp[0][i-1]) % mod;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1322330,
                "title": "python3-4x4-matrix-exponentiation-beat-100-of-python3-submissions",
                "content": "What makes this a different solution to other matrix solutions is that the chosen matrix is only **4x4** compared to those 5x5 ones, which theoretically means more performant by 64/125. (matrix exponentiation has O(M^3 log(N)) where M is the matrix dimension size and N is iterations.)\\n\\n```python\\nMOD = 10**9 + 7\\n\\n\\ndef multiply(mtx1, mtx2):\\n    ret = []\\n    rows = len(mtx1)\\n    cols = len(mtx2)\\n    for i in range(rows):\\n        ret.append([])\\n        for j in range(rows):\\n            ret[i].append(0)\\n            for k in range(cols):\\n                ret[i][j] = ret[i][j] + mtx1[i][k] * mtx2[k][j] % MOD\\n    return ret\\n\\n\\ndef fast_power(mtx, n):\\n    if n == 0:\\n        dim = len(mtx)\\n        return [\\n            [\\n                1 if i == j else 0\\n                for j in range(dim)\\n            ]\\n            for i in range(dim)\\n        ]\\n\\n    if n == 1:\\n        return mtx\\n\\n    res = fast_power(mtx, n // 2)\\n    res = multiply(res, res)\\n\\n    if n % 2 == 1:\\n        res = multiply(mtx, res)\\n\\n    return res\\n\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        factor = fast_power([\\n            [1, 1, 0, 0],\\n            [1, 0, 1, 0],\\n            [0, 0, 1, 1],\\n            [2, 0, 0, -1]\\n        ], n - 1)\\n\\n        # multiply([[1, 0, 0, 0]], factor) == factor[0]\\n        return sum(multiply([factor[0]], [[5], [5], [4], [2]])[0]) % MOD\\n```\\n\\n### Short explaination\\n\\nNk denotes that all possible vowels at the nth iteration.\\n\\nPk denotes the pattern found at the nth iteration.\\n\\nF(Pk) denotes the transition of a pattern.\\n\\nSteps to find patterns at k-th iteration:\\n- Find all possible vowels at this iteration\\n- Reorder vowels to match the pattern found at last iteration\\n- Give it a name denoted as Pk\\n- Replace vowels with existing pattern names\\n\\n```\\nN1 = a e  i    o  u = P1                                      (new pattern found, P1 = aeiou)\\nN2 = e ai aeou iu a = aeiou aaeiu = P1 + P2                   (new pattern found, P2 = aaeiu)\\nN3 = ai e aeou e ai iu a aeou a e = aeiou aeiou aaeiu aaee    (new pattern found, P3 = aaee)\\n   = P1 + P1 + P2 + P3\\n   = 2*P1 + P2 + P3\\nN4 = e aeou ai e ai iu a ai e aeou aeou a e e ai iu a e ai\\n   = aeiou aeiou aeiou aaeiu aaeiu aaee aaee ii               (new pattern found, P4 = ii)\\n   = P1 + P1 + P1 + P2 + P2 + P3 + P3 + P4\\n   = 3*P1 + 2*P2 + 2*P3 + P4\\nN5 = ... (DIY) ...                                            (no new pattern found, the system converges)\\n   = 7*P1 + 3*P2 + 4*P3 + P4                                  (Is that why the example give n=5 :D)\\n \\nP1 = 5 (length of aeiou)\\nP2 = 5 (lengh of aaeiu)\\nP3 = 4 (length of aaee)\\nP4 = 2 (length of ii)\\n\\nVerify:\\nN1 = 5\\nN2 = 10\\nN3 = 19\\nN4 = 35\\nN5 = 68\\n(Pass)\\n\\nWhat we learn from the 4 patterns:\\nF(P1) = P1 + P2\\nF(P2) = P1 + P3\\nF(P3) = P3 + P4\\nF(P4) = 2*P1 - P4\\n\\n(do not worry the subtraction, there is always a P3 at last iteration generating a P4 to compensate this.\\nThink of this P4 borrowed from F(P3))\\n\\nMake it a transition matrix:\\np1\\' = 1*p1 + 1*p2 + 0*p3 + 2*p4\\np2\\' = 1*p1 + 0*p2 + 0*p3 + 0*p4\\np3\\' = 0*p1 + 1*p2 + 1*p3 + 0*p4\\np4\\' = 0*p1 + 0*p2 + 1*p3 + (-1)*p4\\n\\nDone:\\n| p1\\' |   | 1 1 0 2  |   | p1 |\\n| p2\\' |   | 1 0 0 0  |   | p2 |\\n| p3\\' | = | 0 1 1 0  | * | p3 | \\n| p4\\' |   | 0 0 1 -1 |   | p4 |\\n\\n(Though I use a transposed version in the code lol :D)\\n```\\n\\n### Long explaination (in Chinese)\\nhttps://medium.com/cow-say/1220-count-vowels-permutation-921d259e9439",
                "solutionTags": [],
                "code": "```python\\nMOD = 10**9 + 7\\n\\n\\ndef multiply(mtx1, mtx2):\\n    ret = []\\n    rows = len(mtx1)\\n    cols = len(mtx2)\\n    for i in range(rows):\\n        ret.append([])\\n        for j in range(rows):\\n            ret[i].append(0)\\n            for k in range(cols):\\n                ret[i][j] = ret[i][j] + mtx1[i][k] * mtx2[k][j] % MOD\\n    return ret\\n\\n\\ndef fast_power(mtx, n):\\n    if n == 0:\\n        dim = len(mtx)\\n        return [\\n            [\\n                1 if i == j else 0\\n                for j in range(dim)\\n            ]\\n            for i in range(dim)\\n        ]\\n\\n    if n == 1:\\n        return mtx\\n\\n    res = fast_power(mtx, n // 2)\\n    res = multiply(res, res)\\n\\n    if n % 2 == 1:\\n        res = multiply(mtx, res)\\n\\n    return res\\n\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        factor = fast_power([\\n            [1, 1, 0, 0],\\n            [1, 0, 1, 0],\\n            [0, 0, 1, 1],\\n            [2, 0, 0, -1]\\n        ], n - 1)\\n\\n        # multiply([[1, 0, 0, 0]], factor) == factor[0]\\n        return sum(multiply([factor[0]], [[5], [5], [4], [2]])[0]) % MOD\\n```\n```\\nN1 = a e  i    o  u = P1                                      (new pattern found, P1 = aeiou)\\nN2 = e ai aeou iu a = aeiou aaeiu = P1 + P2                   (new pattern found, P2 = aaeiu)\\nN3 = ai e aeou e ai iu a aeou a e = aeiou aeiou aaeiu aaee    (new pattern found, P3 = aaee)\\n   = P1 + P1 + P2 + P3\\n   = 2*P1 + P2 + P3\\nN4 = e aeou ai e ai iu a ai e aeou aeou a e e ai iu a e ai\\n   = aeiou aeiou aeiou aaeiu aaeiu aaee aaee ii               (new pattern found, P4 = ii)\\n   = P1 + P1 + P1 + P2 + P2 + P3 + P3 + P4\\n   = 3*P1 + 2*P2 + 2*P3 + P4\\nN5 = ... (DIY) ...                                            (no new pattern found, the system converges)\\n   = 7*P1 + 3*P2 + 4*P3 + P4                                  (Is that why the example give n=5 :D)\\n \\nP1 = 5 (length of aeiou)\\nP2 = 5 (lengh of aaeiu)\\nP3 = 4 (length of aaee)\\nP4 = 2 (length of ii)\\n\\nVerify:\\nN1 = 5\\nN2 = 10\\nN3 = 19\\nN4 = 35\\nN5 = 68\\n(Pass)\\n\\nWhat we learn from the 4 patterns:\\nF(P1) = P1 + P2\\nF(P2) = P1 + P3\\nF(P3) = P3 + P4\\nF(P4) = 2*P1 - P4\\n\\n(do not worry the subtraction, there is always a P3 at last iteration generating a P4 to compensate this.\\nThink of this P4 borrowed from F(P3))\\n\\nMake it a transition matrix:\\np1\\' = 1*p1 + 1*p2 + 0*p3 + 2*p4\\np2\\' = 1*p1 + 0*p2 + 0*p3 + 0*p4\\np3\\' = 0*p1 + 1*p2 + 1*p3 + 0*p4\\np4\\' = 0*p1 + 0*p2 + 1*p3 + (-1)*p4\\n\\nDone:\\n| p1\\' |   | 1 1 0 2  |   | p1 |\\n| p2\\' |   | 1 0 0 0  |   | p2 |\\n| p3\\' | = | 0 1 1 0  | * | p3 | \\n| p4\\' |   | 0 0 1 -1 |   | p4 |\\n\\n(Though I use a transposed version in the code lol :D)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317101,
                "title": "c-dynamic-programming-simple-solution",
                "content": "**Please up vote( if useful )**\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n  ll mod = 1000000000 + 7;\\n  ll rec(vector<vector<ll>> &dp, ll i, ll j, ll n)\\n  {\\n    if (i == n)\\n      return 1;\\n    if (dp[i][j] != -1)\\n      return dp[i][j];\\n    if (j == \\'a\\' - \\'a\\')\\n      dp[i][j] = rec(dp, i + 1, \\'e\\' - \\'a\\', n);\\n    else if (j == \\'e\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'a\\' - \\'a\\', n) + rec(dp, i + 1, \\'i\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'i\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'a\\' - \\'a\\', n) + rec(dp, i + 1, \\'e\\' - \\'a\\', n) + rec(dp, i + 1, \\'o\\' - \\'a\\', n) + rec(dp, i + 1, \\'u\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'o\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'i\\' - \\'a\\', n) + rec(dp, i + 1, \\'u\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'u\\' - \\'a\\')\\n      dp[i][j] = rec(dp, i + 1, \\'a\\' - \\'a\\', n);\\n    return dp[i][j]%mod;\\n  }\\n  int countVowelPermutation(int n) {\\n    std::vector<std::vector<ll>> dp(n + 1, std::vector<ll> (27, -1));\\n    // dp[i][j] = number of permutations possible of i length, having the j vowel at ith position.\\n    return (rec(dp, 1, \\'a\\' - \\'a\\', n) + rec(dp, 1, \\'e\\' - \\'a\\', n) + rec(dp, 1, \\'i\\' - \\'a\\', n) + rec(dp, 1, \\'o\\' - \\'a\\', n) + rec(dp, 1, \\'u\\' - \\'a\\', n)) % mod;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n  ll mod = 1000000000 + 7;\\n  ll rec(vector<vector<ll>> &dp, ll i, ll j, ll n)\\n  {\\n    if (i == n)\\n      return 1;\\n    if (dp[i][j] != -1)\\n      return dp[i][j];\\n    if (j == \\'a\\' - \\'a\\')\\n      dp[i][j] = rec(dp, i + 1, \\'e\\' - \\'a\\', n);\\n    else if (j == \\'e\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'a\\' - \\'a\\', n) + rec(dp, i + 1, \\'i\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'i\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'a\\' - \\'a\\', n) + rec(dp, i + 1, \\'e\\' - \\'a\\', n) + rec(dp, i + 1, \\'o\\' - \\'a\\', n) + rec(dp, i + 1, \\'u\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'o\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'i\\' - \\'a\\', n) + rec(dp, i + 1, \\'u\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'u\\' - \\'a\\')\\n      dp[i][j] = rec(dp, i + 1, \\'a\\' - \\'a\\', n);\\n    return dp[i][j]%mod;\\n  }\\n  int countVowelPermutation(int n) {\\n    std::vector<std::vector<ll>> dp(n + 1, std::vector<ll> (27, -1));\\n    // dp[i][j] = number of permutations possible of i length, having the j vowel at ith position.\\n    return (rec(dp, 1, \\'a\\' - \\'a\\', n) + rec(dp, 1, \\'e\\' - \\'a\\', n) + rec(dp, 1, \\'i\\' - \\'a\\', n) + rec(dp, 1, \\'o\\' - \\'a\\', n) + rec(dp, 1, \\'u\\' - \\'a\\', n)) % mod;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315905,
                "title": "count-vowels-permutation-dp-from-recursion",
                "content": "```\\nRecursion(TLE )\\n\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1000000007;\\n    unordered_map<int,vector<int>> umap;\\n    \\n\\t//this recursive function takes current size and last letter of string form so.\\n\\t    int rec(int n, int l,int last){\\n\\t\\t//base cases\\n        if(n == l) return 1;\\n        if(last == -1){\\n            return (rec(n,1,0)%mod + rec(n,1,1)%mod + rec(n,1,2)%mod + rec(n,1,3)%mod + rec(n,1,4)%mod ) % mod ;\\n        }\\n        \\n       // calculate for all the possible letter that can be placed after this\\n        vector<int> v = umap[last];\\n        int ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            ans = (ans%mod + rec(n,l+1,v[i])%mod) % mod;\\n        }\\n        return  (ans % mod);\\n    }\\n        \\n    int countVowelPermutation(int n) {\\n         umap[0] = {1};\\n        umap[1] = {0,2};\\n        umap[2] = {0,1,3,4};\\n        umap[3] = {4,2};\\n        umap[4] = {0};\\n        \\n         return rec(n,0,-1);\\n        \\n    }\\n};\\n```\\n\\n**Accepted**(DP bottom-up approach)\\n```\\n\\nDP [i][j] -: total no of strings having length i and end with  j (it integer map of given char)\\nDP[1][j] ,(0<j<5) = 1  //base case string \\nDP[i][j] = DP[i-1][umap[j][0]] + DP....   // all possible j\\n\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1000000007;\\n    unordered_map<int,vector<int>> umap;\\n    vector<vector<int>> dp;\\n        \\n        \\n    int countVowelPermutation(int n) {\\n        umap[0] = {1,2,4};\\n        umap[1] = {0,2};\\n        umap[2] = {1,3};\\n        umap[3] = {2};\\n        umap[4] = {3,2};\\n        dp.resize(n+1,vector<int>(5,-1));\\n        \\n        // return rec(n,0,-1);\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<5;j++){\\n                if(i == 1){\\n                    dp[i][j] = 1;\\n                }\\n                else{\\n                    vector<int> v = umap[j];\\n                    int ans = 0;\\n                    for(int l=0;l<v.size();l++){\\n                        ans = (ans%mod + dp[i-1][v[l]]%mod) % mod;\\n                    }\\n                    dp[i][j] = ans % mod;\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i=0;i<5;i++){\\n            res = (res%mod + dp[n][i]%mod) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nRecursion(TLE )\\n\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1000000007;\\n    unordered_map<int,vector<int>> umap;\\n    \\n\\t//this recursive function takes current size and last letter of string form so.\\n\\t    int rec(int n, int l,int last){\\n\\t\\t//base cases\\n        if(n == l) return 1;\\n        if(last == -1){\\n            return (rec(n,1,0)%mod + rec(n,1,1)%mod + rec(n,1,2)%mod + rec(n,1,3)%mod + rec(n,1,4)%mod ) % mod ;\\n        }\\n        \\n       // calculate for all the possible letter that can be placed after this\\n        vector<int> v = umap[last];\\n        int ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            ans = (ans%mod + rec(n,l+1,v[i])%mod) % mod;\\n        }\\n        return  (ans % mod);\\n    }\\n        \\n    int countVowelPermutation(int n) {\\n         umap[0] = {1};\\n        umap[1] = {0,2};\\n        umap[2] = {0,1,3,4};\\n        umap[3] = {4,2};\\n        umap[4] = {0};\\n        \\n         return rec(n,0,-1);\\n        \\n    }\\n};\\n```\n```\\n\\nDP [i][j] -: total no of strings having length i and end with  j (it integer map of given char)\\nDP[1][j] ,(0<j<5) = 1  //base case string \\nDP[i][j] = DP[i-1][umap[j][0]] + DP....   // all possible j\\n\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1000000007;\\n    unordered_map<int,vector<int>> umap;\\n    vector<vector<int>> dp;\\n        \\n        \\n    int countVowelPermutation(int n) {\\n        umap[0] = {1,2,4};\\n        umap[1] = {0,2};\\n        umap[2] = {1,3};\\n        umap[3] = {2};\\n        umap[4] = {3,2};\\n        dp.resize(n+1,vector<int>(5,-1));\\n        \\n        // return rec(n,0,-1);\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<5;j++){\\n                if(i == 1){\\n                    dp[i][j] = 1;\\n                }\\n                else{\\n                    vector<int> v = umap[j];\\n                    int ans = 0;\\n                    for(int l=0;l<v.size();l++){\\n                        ans = (ans%mod + dp[i-1][v[l]]%mod) % mod;\\n                    }\\n                    dp[i][j] = ans % mod;\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i=0;i<5;i++){\\n            res = (res%mod + dp[n][i]%mod) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315892,
                "title": "count-vowels-best-solution-python-o-1-memory-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        \\n        na = 1\\n        ne = 1\\n        ni = 1\\n        no = 1\\n        nu = 1\\n        \\n        if(n==1):\\n            return 5\\n        \\n        else:\\n            \\n            for _ in range(n-1):\\n                \\n                na,ne,ni,no,nu = ne , na + ni , na+ne+no+nu , ni + nu , na\\n                \\n            return (na+ne+ni+no+nu)%(10**9+7)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        \\n        na = 1\\n        ne = 1\\n        ni = 1\\n        no = 1\\n        nu = 1\\n        \\n        if(n==1):\\n            return 5\\n        \\n        else:\\n            \\n            for _ in range(n-1):\\n                \\n                na,ne,ni,no,nu = ne , na + ni , na+ne+no+nu , ni + nu , na\\n                \\n            return (na+ne+ni+no+nu)%(10**9+7)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1315880,
                "title": "c-3-approaches-recur-memo-bottom-up-dp-organised-and-simple-with-comments",
                "content": "```\\n/*\\n\\tFor more interview Qn : https://github.com/MAZHARMIK/Interview_DS_Algo\\n    Similar Qn            : https://leetcode.com/problems/count-sorted-vowel-strings/\\n*/\\n\\n//Approach-1 (Top Down - Recursion + Memo) Time : O(n)\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    vector<vector<long long>> t;\\n    \\n    /*\\n        Accoring to question : \\n        a -> e\\n        e -> a, i\\n        i -> a, e, o, u\\n        o -> i, u\\n        u -> a\\n        So, count of strings of length n ending at \\'a\\' ?\\n            We can have vowels \\'e\\', \\'i\\' & \\'u\\' in which we can have ending vowel as \\'a\\'\\n        So,         count of strings of length n ending at \\'a\\'  = count of strings of length (n-1) ending at \\'e\\', \\'i\\', \\'u\\'.\\n        \\n        similarly,  We can have vowels \\'a\\' & \\'i\\' in which we can have ending vowel as \\'e\\'\\n                    We can have vowels \\'e\\' & \\'o\\' in which we can have ending vowel as \\'i\\'\\n                    We can have vowels i\\' in which we can have ending vowel as \\'o\\'\\n                    We can have vowels \\'i\\' & \\'o\\' in which we can have ending vowel as \\'u\\'\\n        And in this fashion, we find the count recursively\\n    */\\n    int count(int n, int vowel) {\\n        if(t[n][vowel] != -1)\\n            return t[n][vowel];\\n        \\n        /*\\n            When n is 0, why dowe return 1 ?\\n            Let\\'s look at the caller function countVowelPermutation()\\n            If n = 1, we would call \\n            count(n-1, a) + count(n-1, e) + count(n-1, i) + count(n-1, o) + count(n-1, u)\\n            and for n = 1, we know that count is 5\\n            So, only if we return 1 from here, we will be able to get 5.\\n            This is how I found \\n        */\\n        if(n == 0)\\n            return 1;\\n        \\n        if(vowel == a) {\\n            return t[n][vowel] = ((count(n-1, e) + count(n-1, i))%M + count(n-1, u))%M;\\n        } else if(vowel == e) {\\n            return t[n][vowel] = ((count(n-1, a) + count(n-1, i)))%M;\\n        } else if(vowel == i) {\\n            return t[n][vowel] = ((count(n-1, e) + count(n-1, o)))%M;\\n        } else if(vowel == o) {\\n            return t[n][vowel] = count(n-1, i);\\n        } else if(vowel == u) {\\n            return t[n][vowel] = ((count(n-1, i) + count(n-1, o)))%M;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        t.resize(n, vector<long long>(5, -1));\\n        long long result = 0;\\n        \\n        result = (result + count(n-1, a)) %M; //count(x, v) = # of strings of length x which ends at vowel v\\n        result = (result + count(n-1, e)) %M;\\n        result = (result + count(n-1, i)) %M;\\n        result = (result + count(n-1, o)) %M;\\n        result = (result + count(n-1, u)) %M;\\n        \\n        return result;\\n        \\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Top Down DP : Just iterative version of Approach-1) Time : O(n)\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    \\n    int countVowelPermutation(int n) {\\n        long long t[n+1][5];\\n        //t[i][j] = # strings of length i ending with vowel j\\n        \\n        for(int vowel = a; vowel<=u; vowel++) {\\n            t[1][vowel] = 1;\\n        }\\n        \\n        for(int len = 2; len<=n; len++) {\\n            t[len][a] = ((t[len-1][e] + t[len-1][i])%M + t[len-1][u])%M;\\n            \\n            t[len][e] = (t[len-1][a] + t[len-1][i])%M;\\n            \\n            t[len][i] = (t[len-1][e] + t[len-1][o])%M;\\n            \\n            t[len][o] = t[len-1][i];\\n            \\n            t[len][u] = (t[len-1][i] + t[len-1][o])%M;\\n        }\\n        \\n\\n        long long count = 0;\\n        for(int vowel = a; vowel <= u; vowel++) {\\n            count = (count+t[n][vowel])%M;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (We can apply approach-1 in same way asked in question)\\n/*\\nInstead of considering the string \\'ending with vowel v\\', we consider strings \\'starting with vowel v\\'\\njust as mentioned in the question. It\\'s more intuitive\\n*/\\n\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    vector<vector<long long>> t;\\n    \\n    /*\\n        Accoring to question : \\n        a -> e\\n        e -> a, i\\n        i -> a, e, o, u\\n        o -> i, u\\n        u -> a\\n        So, count of strings of length n starting at \\'a\\' ?\\n            We can have vowel \\'e\\' after \\'a\\'\\n        So, count of strings of length n starting at \\'a\\'  = count of strings of length (n-1) starting at \\'e\\' and so on.    \\n        And in this fashion, we find the count recursively\\n    */\\n    \\n    long long count(int n, int vowel) {\\n        if(t[n][vowel] != -1)\\n            return t[n][vowel];\\n        if(n == 0)\\n            return 1;\\n        \\n        if(vowel == a) {\\n            return t[n][vowel] = (count(n-1, e))%M;\\n        } else if(vowel == e) {\\n            return t[n][vowel] = ((count(n-1, a) + count(n-1, i)))%M;\\n        } else if(vowel == i) {\\n            return t[n][vowel] = (count(n-1, a) + count(n-1, e) + count(n-1, o) + count(n-1, u))%M;\\n        } else if(vowel == o) {\\n            return t[n][vowel] = (count(n-1, i) + count(n-1, u))%M;\\n        } else if(vowel == u) {\\n            return t[n][vowel] = (count(n-1, a))%M;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        t.resize(n, vector<long long>(5, -1));\\n        long long result = 0;\\n        \\n        result = (result + count(n-1, a)) %M; //count(x, v) = # of strings of length x which ends at vowel v\\n        result = (result + count(n-1, e)) %M;\\n        result = (result + count(n-1, i)) %M;\\n        result = (result + count(n-1, o)) %M;\\n        result = (result + count(n-1, u)) %M;\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tFor more interview Qn : https://github.com/MAZHARMIK/Interview_DS_Algo\\n    Similar Qn            : https://leetcode.com/problems/count-sorted-vowel-strings/\\n*/\\n\\n//Approach-1 (Top Down - Recursion + Memo) Time : O(n)\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    vector<vector<long long>> t;\\n    \\n    /*\\n        Accoring to question : \\n        a -> e\\n        e -> a, i\\n        i -> a, e, o, u\\n        o -> i, u\\n        u -> a\\n        So, count of strings of length n ending at \\'a\\' ?\\n            We can have vowels \\'e\\', \\'i\\' & \\'u\\' in which we can have ending vowel as \\'a\\'\\n        So,         count of strings of length n ending at \\'a\\'  = count of strings of length (n-1) ending at \\'e\\', \\'i\\', \\'u\\'.\\n        \\n        similarly,  We can have vowels \\'a\\' & \\'i\\' in which we can have ending vowel as \\'e\\'\\n                    We can have vowels \\'e\\' & \\'o\\' in which we can have ending vowel as \\'i\\'\\n                    We can have vowels i\\' in which we can have ending vowel as \\'o\\'\\n                    We can have vowels \\'i\\' & \\'o\\' in which we can have ending vowel as \\'u\\'\\n        And in this fashion, we find the count recursively\\n    */\\n    int count(int n, int vowel) {\\n        if(t[n][vowel] != -1)\\n            return t[n][vowel];\\n        \\n        /*\\n            When n is 0, why dowe return 1 ?\\n            Let\\'s look at the caller function countVowelPermutation()\\n            If n = 1, we would call \\n            count(n-1, a) + count(n-1, e) + count(n-1, i) + count(n-1, o) + count(n-1, u)\\n            and for n = 1, we know that count is 5\\n            So, only if we return 1 from here, we will be able to get 5.\\n            This is how I found \\n        */\\n        if(n == 0)\\n            return 1;\\n        \\n        if(vowel == a) {\\n            return t[n][vowel] = ((count(n-1, e) + count(n-1, i))%M + count(n-1, u))%M;\\n        } else if(vowel == e) {\\n            return t[n][vowel] = ((count(n-1, a) + count(n-1, i)))%M;\\n        } else if(vowel == i) {\\n            return t[n][vowel] = ((count(n-1, e) + count(n-1, o)))%M;\\n        } else if(vowel == o) {\\n            return t[n][vowel] = count(n-1, i);\\n        } else if(vowel == u) {\\n            return t[n][vowel] = ((count(n-1, i) + count(n-1, o)))%M;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        t.resize(n, vector<long long>(5, -1));\\n        long long result = 0;\\n        \\n        result = (result + count(n-1, a)) %M; //count(x, v) = # of strings of length x which ends at vowel v\\n        result = (result + count(n-1, e)) %M;\\n        result = (result + count(n-1, i)) %M;\\n        result = (result + count(n-1, o)) %M;\\n        result = (result + count(n-1, u)) %M;\\n        \\n        return result;\\n        \\n    }\\n};\\n```\n```\\n//Approach-2 (Top Down DP : Just iterative version of Approach-1) Time : O(n)\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    \\n    int countVowelPermutation(int n) {\\n        long long t[n+1][5];\\n        //t[i][j] = # strings of length i ending with vowel j\\n        \\n        for(int vowel = a; vowel<=u; vowel++) {\\n            t[1][vowel] = 1;\\n        }\\n        \\n        for(int len = 2; len<=n; len++) {\\n            t[len][a] = ((t[len-1][e] + t[len-1][i])%M + t[len-1][u])%M;\\n            \\n            t[len][e] = (t[len-1][a] + t[len-1][i])%M;\\n            \\n            t[len][i] = (t[len-1][e] + t[len-1][o])%M;\\n            \\n            t[len][o] = t[len-1][i];\\n            \\n            t[len][u] = (t[len-1][i] + t[len-1][o])%M;\\n        }\\n        \\n\\n        long long count = 0;\\n        for(int vowel = a; vowel <= u; vowel++) {\\n            count = (count+t[n][vowel])%M;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\n//Approach-3 (We can apply approach-1 in same way asked in question)\\n/*\\nInstead of considering the string \\'ending with vowel v\\', we consider strings \\'starting with vowel v\\'\\njust as mentioned in the question. It\\'s more intuitive\\n*/\\n\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    vector<vector<long long>> t;\\n    \\n    /*\\n        Accoring to question : \\n        a -> e\\n        e -> a, i\\n        i -> a, e, o, u\\n        o -> i, u\\n        u -> a\\n        So, count of strings of length n starting at \\'a\\' ?\\n            We can have vowel \\'e\\' after \\'a\\'\\n        So, count of strings of length n starting at \\'a\\'  = count of strings of length (n-1) starting at \\'e\\' and so on.    \\n        And in this fashion, we find the count recursively\\n    */\\n    \\n    long long count(int n, int vowel) {\\n        if(t[n][vowel] != -1)\\n            return t[n][vowel];\\n        if(n == 0)\\n            return 1;\\n        \\n        if(vowel == a) {\\n            return t[n][vowel] = (count(n-1, e))%M;\\n        } else if(vowel == e) {\\n            return t[n][vowel] = ((count(n-1, a) + count(n-1, i)))%M;\\n        } else if(vowel == i) {\\n            return t[n][vowel] = (count(n-1, a) + count(n-1, e) + count(n-1, o) + count(n-1, u))%M;\\n        } else if(vowel == o) {\\n            return t[n][vowel] = (count(n-1, i) + count(n-1, u))%M;\\n        } else if(vowel == u) {\\n            return t[n][vowel] = (count(n-1, a))%M;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        t.resize(n, vector<long long>(5, -1));\\n        long long result = 0;\\n        \\n        result = (result + count(n-1, a)) %M; //count(x, v) = # of strings of length x which ends at vowel v\\n        result = (result + count(n-1, e)) %M;\\n        result = (result + count(n-1, i)) %M;\\n        result = (result + count(n-1, o)) %M;\\n        result = (result + count(n-1, u)) %M;\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315546,
                "title": "c-recursion-memoization-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = (int)1e9 + 7;\\n    int helper(int n, char i, unordered_map<char,vector<char>>& vc,vector<vector<long long>>& dp){\\n        if(n==0) return 1;\\n        if (dp[n][i-\\'a\\']!=0) return dp[n][i-\\'a\\']%mod;\\n        for(int j=0;j<vc[i].size();j++){\\n            dp[n][i-\\'a\\']+=(helper(n-1,vc[i][j],vc,dp))%mod;\\n        }\\n        return dp[n][i-\\'a\\']%mod;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        unordered_map<char,vector<char>> vc;\\n        vc[\\'a\\'].push_back(\\'e\\');\\n        vc[\\'e\\'].push_back(\\'a\\');vc[\\'e\\'].push_back(\\'i\\');\\n        vc[\\'i\\'].push_back(\\'a\\');vc[\\'i\\'].push_back(\\'e\\');vc[\\'i\\'].push_back(\\'o\\');vc[\\'i\\'].push_back(\\'u\\');\\n        vc[\\'o\\'].push_back(\\'i\\');vc[\\'o\\'].push_back(\\'u\\');\\n        vc[\\'u\\'].push_back(\\'a\\');        \\n        vector<vector<long long>> dp(n+1,vector<long long>(26,0));\\n        long long c=0;\\n        for(auto it = vc.begin();it!=vc.end();it++){\\n            dp[n][it->first-\\'a\\']+=(helper(n-1,it->first,vc,dp))%mod;\\n            c += (dp[n][it->first-\\'a\\'])%mod;\\n        }\\n        return c%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = (int)1e9 + 7;\\n    int helper(int n, char i, unordered_map<char,vector<char>>& vc,vector<vector<long long>>& dp){\\n        if(n==0) return 1;\\n        if (dp[n][i-\\'a\\']!=0) return dp[n][i-\\'a\\']%mod;\\n        for(int j=0;j<vc[i].size();j++){\\n            dp[n][i-\\'a\\']+=(helper(n-1,vc[i][j],vc,dp))%mod;\\n        }\\n        return dp[n][i-\\'a\\']%mod;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        unordered_map<char,vector<char>> vc;\\n        vc[\\'a\\'].push_back(\\'e\\');\\n        vc[\\'e\\'].push_back(\\'a\\');vc[\\'e\\'].push_back(\\'i\\');\\n        vc[\\'i\\'].push_back(\\'a\\');vc[\\'i\\'].push_back(\\'e\\');vc[\\'i\\'].push_back(\\'o\\');vc[\\'i\\'].push_back(\\'u\\');\\n        vc[\\'o\\'].push_back(\\'i\\');vc[\\'o\\'].push_back(\\'u\\');\\n        vc[\\'u\\'].push_back(\\'a\\');        \\n        vector<vector<long long>> dp(n+1,vector<long long>(26,0));\\n        long long c=0;\\n        for(auto it = vc.begin();it!=vc.end();it++){\\n            dp[n][it->first-\\'a\\']+=(helper(n-1,it->first,vc,dp))%mod;\\n            c += (dp[n][it->first-\\'a\\'])%mod;\\n        }\\n        return c%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315527,
                "title": "c-easy-dp-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int countVowelPermutation(int n) {\\n        \\n        //Let dp[i][j] be the number of strings of length i that ends with the j-th vowel.\\n        long long int mod = 1000000007;\\n        long long int dp[n + 1][5];\\n        for(int i = 1; i <= n; i++)\\n        {\\n            dp[i][0] = 1;\\n            dp[i][1] = 1;\\n            dp[i][2] = 1;\\n            dp[i][3] = 1;\\n            dp[i][4] = 1;\\n        }\\n        \\n        //Creating combinations of each vowel using following conditions:\\n        //For a: ea, ia, ua\\n        //For e: ae, ie\\n        //For i: ei, oi\\n        //For o: io\\n        //For u: iu, ou\\n        \\n        for(int i = 2; i <= n; i++)\\n        {\\n            dp[i][0] += (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % mod;\\n            dp[i][1] += (dp[i - 1][0] + dp[i - 1][2]) % mod;\\n            dp[i][2] += (dp[i - 1][1] + dp[i - 1][3]) % mod;\\n            dp[i][3] += (dp[i - 1][2]) % mod;\\n            dp[i][4] += (dp[i - 1][2]+ dp[i - 1][3]) % mod;\\n        }\\n        \\n        //Finding N-th and (N-1)-th solutions\\n        long long int x = (dp[n][0] + dp[n][1] + dp[n][2] + dp[n][3] + dp[n][4]) % mod;\\n        long long int y = (dp[n - 1][0] + dp[n - 1][1] + dp[n - 1][2] + dp[n - 1][3] + dp[n - 1][4]) % mod;\\n        \\n        if(n == 1)\\n            return x;\\n        \\n        //Using basics of Modular Arithmetic to overcome overflow\\n        return (x % mod - y % mod + mod) % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int countVowelPermutation(int n) {\\n        \\n        //Let dp[i][j] be the number of strings of length i that ends with the j-th vowel.\\n        long long int mod = 1000000007;\\n        long long int dp[n + 1][5];\\n        for(int i = 1; i <= n; i++)\\n        {\\n            dp[i][0] = 1;\\n            dp[i][1] = 1;\\n            dp[i][2] = 1;\\n            dp[i][3] = 1;\\n            dp[i][4] = 1;\\n        }\\n        \\n        //Creating combinations of each vowel using following conditions:\\n        //For a: ea, ia, ua\\n        //For e: ae, ie\\n        //For i: ei, oi\\n        //For o: io\\n        //For u: iu, ou\\n        \\n        for(int i = 2; i <= n; i++)\\n        {\\n            dp[i][0] += (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % mod;\\n            dp[i][1] += (dp[i - 1][0] + dp[i - 1][2]) % mod;\\n            dp[i][2] += (dp[i - 1][1] + dp[i - 1][3]) % mod;\\n            dp[i][3] += (dp[i - 1][2]) % mod;\\n            dp[i][4] += (dp[i - 1][2]+ dp[i - 1][3]) % mod;\\n        }\\n        \\n        //Finding N-th and (N-1)-th solutions\\n        long long int x = (dp[n][0] + dp[n][1] + dp[n][2] + dp[n][3] + dp[n][4]) % mod;\\n        long long int y = (dp[n - 1][0] + dp[n - 1][1] + dp[n - 1][2] + dp[n - 1][3] + dp[n - 1][4]) % mod;\\n        \\n        if(n == 1)\\n            return x;\\n        \\n        //Using basics of Modular Arithmetic to overcome overflow\\n        return (x % mod - y % mod + mod) % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315343,
                "title": "i-would-expect-dp-space-o-1-if-i-were-the-interviewer",
                "content": "I would expect,\\n- DP with two int[5] arrays to compress the space to O(1).\\n- I DO NOT like the idea which mods (10^9+7), as it is not the focus of the question itself.\\n- Comparing top-to-bottom and bottom-to-top would be an extra bonus point, such as why for this question bottom-to-top is more convenient.\\n\\nAlthough it is a HARD question, probably it is very good for practicing DP.\\n \\n```java\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[] countPrev = new long[5];\\n        long[] countCur = new long[5];\\n        Arrays.fill(countPrev, 1);\\n        \\n        long mod = 1000000007;\\n        \\n        for(int i=1; i <n ;i++){\\n            \\n            \\n            /*\\n            Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n            Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n            Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n            Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n            Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n            */\\n            countCur[0] = countPrev[1] % mod;\\n            countCur[1] = (countPrev[0]+countPrev[2]) % mod;\\n            countCur[2] = (countPrev[0]+countPrev[1]+countPrev[3]+countPrev[4]) % mod;\\n            countCur[3] = (countPrev[2]+countPrev[4]) % mod;\\n            countCur[4] = countPrev[0] % mod;\\n            \\n            long[] tmp = countPrev;\\n            countPrev = countCur;\\n            countCur = tmp;\\n        }\\n        \\n        return (int)((countPrev[0] + countPrev[1] + countPrev[2] + countPrev[3] + countPrev[4]) % mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[] countPrev = new long[5];\\n        long[] countCur = new long[5];\\n        Arrays.fill(countPrev, 1);\\n        \\n        long mod = 1000000007;\\n        \\n        for(int i=1; i <n ;i++){\\n            \\n            \\n            /*\\n            Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n            Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n            Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n            Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n            Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n            */\\n            countCur[0] = countPrev[1] % mod;\\n            countCur[1] = (countPrev[0]+countPrev[2]) % mod;\\n            countCur[2] = (countPrev[0]+countPrev[1]+countPrev[3]+countPrev[4]) % mod;\\n            countCur[3] = (countPrev[2]+countPrev[4]) % mod;\\n            countCur[4] = countPrev[0] % mod;\\n            \\n            long[] tmp = countPrev;\\n            countPrev = countCur;\\n            countCur = tmp;\\n        }\\n        \\n        return (int)((countPrev[0] + countPrev[1] + countPrev[2] + countPrev[3] + countPrev[4]) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315184,
                "title": "easy-dp-solution",
                "content": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        int mod=1000_000_007;\\n        long dp[][]=new long[n][5];\\n        Arrays.fill(dp[0],1);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<5;j++){\\n                if(j==0){                              // for \\'a\\'\\n                    dp[i][j]=dp[i-1][1];\\n                }\\n                else if(j==1){                              // for \\'e\\'\\n                    dp[i][j]=dp[i-1][0]+dp[i-1][2];\\n                }\\n                else if(j==2){                              // for \\'i\\'\\n                    dp[i][j]=dp[i-1][0]+dp[i-1][1]+dp[i-1][3]+dp[i-1][4];\\n                }\\n                else if(j==3){                              // for \\'o\\'\\n                    dp[i][j]=dp[i-1][2]+dp[i-1][4];\\n                }\\n                else{                              // for \\'u\\'\\n                    dp[i][j]=dp[i-1][0];\\n                }\\n                dp[i][j]=dp[i][j]%mod;\\n            }\\n        }\\n\\t\\t//just add all answers possible from vowels\\n        long ans=0;\\n        for(int j=0;j<5;j++)\\n            ans+=dp[n-1][j];\\n        \\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        int mod=1000_000_007;\\n        long dp[][]=new long[n][5];\\n        Arrays.fill(dp[0],1);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<5;j++){\\n                if(j==0){                              // for \\'a\\'\\n                    dp[i][j]=dp[i-1][1];\\n                }\\n                else if(j==1){                              // for \\'e\\'\\n                    dp[i][j]=dp[i-1][0]+dp[i-1][2];\\n                }\\n                else if(j==2){                              // for \\'i\\'\\n                    dp[i][j]=dp[i-1][0]+dp[i-1][1]+dp[i-1][3]+dp[i-1][4];\\n                }\\n                else if(j==3){                              // for \\'o\\'\\n                    dp[i][j]=dp[i-1][2]+dp[i-1][4];\\n                }\\n                else{                              // for \\'u\\'\\n                    dp[i][j]=dp[i-1][0];\\n                }\\n                dp[i][j]=dp[i][j]%mod;\\n            }\\n        }\\n\\t\\t//just add all answers possible from vowels\\n        long ans=0;\\n        for(int j=0;j<5;j++)\\n            ans+=dp[n-1][j];\\n        \\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173310,
                "title": "my-java-solution-with-my-understanding-as-comments",
                "content": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        if (n == 1)\\n            return 5;\\n        if (n == 2)\\n            return 10;\\n        int mod = (int)1e9 + 7;\\n        // 0th index - a\\n        // 1st index - e\\n        // 2nd index - i\\n        // 3rd index - o\\n        // 4th index - u\\n        long [][] dp = new long [n + 1][5]; \\n        \\n        // if n = 1, then with every letter we can create a string\\n        for (int i=0; i<5; i++) {\\n            dp[1][i] = 1;\\n        }\\n        for (int i=1; i<n; i++) {\\n                // a is followed in e, i, u\\n                dp[i + 1][0] = (dp[i][1] + dp[i][2] + dp[i][4]) % mod;\\n                // e is followed in a, i\\n                dp[i + 1][1] = (dp[i][0] + dp[i][2]) % mod;\\n                // i is followed in e, o\\n                dp[i + 1][2] = (dp[i][1] + dp[i][3]) % mod;\\n                // o is followed in i\\n                dp[i + 1][3] = (dp[i][2]) % mod;\\n                // u is followed in i, o\\n                dp[i + 1][4] = (dp[i][2] + dp[i][3]) % mod;\\n        }\\n        long answer = 0;\\n        for (int i=0; i<5; i++) {\\n            answer = (answer + dp[n][i]) % mod;\\n        }\\n        return (int) answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        if (n == 1)\\n            return 5;\\n        if (n == 2)\\n            return 10;\\n        int mod = (int)1e9 + 7;\\n        // 0th index - a\\n        // 1st index - e\\n        // 2nd index - i\\n        // 3rd index - o\\n        // 4th index - u\\n        long [][] dp = new long [n + 1][5]; \\n        \\n        // if n = 1, then with every letter we can create a string\\n        for (int i=0; i<5; i++) {\\n            dp[1][i] = 1;\\n        }\\n        for (int i=1; i<n; i++) {\\n                // a is followed in e, i, u\\n                dp[i + 1][0] = (dp[i][1] + dp[i][2] + dp[i][4]) % mod;\\n                // e is followed in a, i\\n                dp[i + 1][1] = (dp[i][0] + dp[i][2]) % mod;\\n                // i is followed in e, o\\n                dp[i + 1][2] = (dp[i][1] + dp[i][3]) % mod;\\n                // o is followed in i\\n                dp[i + 1][3] = (dp[i][2]) % mod;\\n                // u is followed in i, o\\n                dp[i + 1][4] = (dp[i][2] + dp[i][3]) % mod;\\n        }\\n        long answer = 0;\\n        for (int i=0; i<5; i++) {\\n            answer = (answer + dp[n][i]) % mod;\\n        }\\n        return (int) answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127526,
                "title": "java-dp-o-n-constant-memory",
                "content": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long mod = (long) 1e9 + 7;\\n        \\n        long[] dp = {1, 1, 1, 1, 1};        \\n        for(int i = 2; i <= n; i += 1) {\\n            long[] temp = new long[5];\\n            \\n            temp[0] = (dp[1] + dp[2] + dp[4]) % mod;\\n            temp[1] = (dp[0] + dp[2]) % mod;\\n            temp[2] = (dp[1] + dp[3]) % mod;\\n            temp[3] = dp[2];\\n            temp[4] = (dp[2] + dp[3]) % mod;\\n            \\n            dp = temp;\\n        }        \\n                \\n        return (int) ((dp[0] + dp[1] + dp[2] + dp[3] + dp[4]) % mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long mod = (long) 1e9 + 7;\\n        \\n        long[] dp = {1, 1, 1, 1, 1};        \\n        for(int i = 2; i <= n; i += 1) {\\n            long[] temp = new long[5];\\n            \\n            temp[0] = (dp[1] + dp[2] + dp[4]) % mod;\\n            temp[1] = (dp[0] + dp[2]) % mod;\\n            temp[2] = (dp[1] + dp[3]) % mod;\\n            temp[3] = dp[2];\\n            temp[4] = (dp[2] + dp[3]) % mod;\\n            \\n            dp = temp;\\n        }        \\n                \\n        return (int) ((dp[0] + dp[1] + dp[2] + dp[3] + dp[4]) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103573,
                "title": "javascript-faster-than-100-no-matrix",
                "content": "see other solutions for example why.\\nI tried doing other solutions with array destructuring, using the .map function, etc... \\njust keep it simple i guess!\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countVowelPermutation = function (n) {\\n   const modVal = (1e9 + 7);\\n   let a = 1;\\n   let e = 1;\\n   let i = 1;\\n   let o = 1;\\n   let u = 1;\\n\\n   for (let x = 1; x < n; x++) {\\n      let tempA = e % modVal;\\n      let tempE = (a + i) % modVal;\\n      let tempI = (a + e + o + u) % modVal;\\n      let tempO = (i + u) % modVal;\\n      let tempU = a % modVal;\\n      a = tempA;\\n      e = tempE;\\n      i = tempI;\\n      o = tempO;\\n      u = tempU;\\n   }\\n\\n   return (a + e + i + o + u) % modVal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countVowelPermutation = function (n) {\\n   const modVal = (1e9 + 7);\\n   let a = 1;\\n   let e = 1;\\n   let i = 1;\\n   let o = 1;\\n   let u = 1;\\n\\n   for (let x = 1; x < n; x++) {\\n      let tempA = e % modVal;\\n      let tempE = (a + i) % modVal;\\n      let tempI = (a + e + o + u) % modVal;\\n      let tempO = (i + u) % modVal;\\n      let tempU = a % modVal;\\n      a = tempA;\\n      e = tempE;\\n      i = tempI;\\n      o = tempO;\\n      u = tempU;\\n   }\\n\\n   return (a + e + i + o + u) % modVal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081078,
                "title": "c-0ms-100-easy-iteratively-obvious",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Count Vowels Permutation.\\nMemory Usage: 5.8 MB, less than 99.59% of C++ online submissions for Count Vowels Permutation.\\n```\\nclass Solution {\\npublic:\\n  int countVowelPermutation(int n) {\\n    unsigned int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1000000007;\\n    while(--n){\\n      unsigned int new_a = (e + i + u)%mod;\\n      unsigned int new_e = (a + i)%mod;\\n      unsigned int new_i = (e + o)%mod;\\n      unsigned int new_u = (i + o)%mod;\\n      a = new_a, e = new_e, o = i%mod, i = new_i, u = new_u;\\n    }\\n    \\n    return (a + e + i + o + u)%mod;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int countVowelPermutation(int n) {\\n    unsigned int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1000000007;\\n    while(--n){\\n      unsigned int new_a = (e + i + u)%mod;\\n      unsigned int new_e = (a + i)%mod;\\n      unsigned int new_i = (e + o)%mod;\\n      unsigned int new_u = (i + o)%mod;\\n      a = new_a, e = new_e, o = i%mod, i = new_i, u = new_u;\\n    }\\n    \\n    return (a + e + i + o + u)%mod;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058365,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "The problem can be solved by matrix power. Similar problems are\\n[70. Climbing Stairs ](https://leetcode.com/problems/climbing-stairs/discuss/929659/Evolve-from-brute-force-to-optimal)\\n[509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/discuss/989672/Evolve-from-intuition)\\n[552. Student Attendance Record II](https://leetcode.com/problems/student-attendance-record-ii/discuss/650804/Evolve-from-brute-force-to-optimal).\\n[935. Knight Dialer](https://leetcode.com/problems/knight-dialer/discuss/893523/Evolve-from-brute-force-to-dp)\\n1. Brute force O(4^n)\\n```\\n\\tMap<Character, List<Character>> map;\\n    public int countVowelPermutation(int n) {\\n        map = new HashMap<>();\\n        map.put(\\'a\\', Arrays.asList(\\'e\\'));\\n        map.put(\\'e\\', Arrays.asList(\\'a\\',\\'i\\'));\\n        map.put(\\'i\\', Arrays.asList(\\'a\\',\\'e\\',\\'o\\',\\'u\\'));\\n        map.put(\\'o\\', Arrays.asList(\\'i\\',\\'u\\'));\\n        map.put(\\'u\\', Arrays.asList(\\'a\\'));\\n        map.put(\\' \\', Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'));\\n        return permutations(\\' \\',n);\\n\\n    }\\n    private int permutations(char pre, int n) {\\n        if(n==0) {\\n            return 1;\\n        }\\n        int count=0;\\n        for(char c:map.get(pre)) {\\n            count+=permutations(c,n-1); \\n        }\\n        return count;\\n    }\\n```\\n2. Memoization O(n)\\n```\\n\\tint[][] mem;\\n    int MOD = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        mem = new int[n+1][118];\\n        map = new HashMap<>();\\n        map.put(\\'a\\', Arrays.asList(\\'e\\'));\\n        map.put(\\'e\\', Arrays.asList(\\'a\\',\\'i\\'));\\n        map.put(\\'i\\', Arrays.asList(\\'a\\',\\'e\\',\\'o\\',\\'u\\'));\\n        map.put(\\'o\\', Arrays.asList(\\'i\\',\\'u\\'));\\n        map.put(\\'u\\', Arrays.asList(\\'a\\'));\\n        map.put(\\' \\', Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'));\\n        return permutations(\\' \\',n);\\n\\n    }\\n    private int permutations(char pre, int n) {\\n        if(n==0) {\\n            return 1;\\n        }\\n        if(mem[n][pre]>0) {\\n            return mem[n][pre];\\n        }\\n        int count=0;\\n        for(char c:map.get(pre)) {\\n            count+=permutations(c,n-1); \\n            count%=MOD;\\n        }\\n        return mem[n][pre]=count;\\n    }\\n```\\n3. dp O(n)\\n```\\n\\tint MOD = (int)1e9+7;\\n    public int countVowelPermutation(int n) {\\n        int[][] dp = new int[n][5];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<n;i++) {\\n            dp[i][0] = ((dp[i-1][1] + dp[i-1][2])%MOD + dp[i-1][4])%MOD;\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][2])%MOD;\\n            dp[i][2] = (dp[i-1][1] +dp[i-1][3])%MOD;\\n            dp[i][3] = dp[i-1][2];\\n            dp[i][4] = (dp[i-1][2] + dp[i-1][3])%MOD;\\n        }\\n        int perm = 0;\\n        for(int num:dp[n-1]) {\\n            perm = (perm+num)%MOD;\\n        }\\n        return perm;\\n    }\\n```\\n4. Matrix power O(logn). M is the adjcency matrix. Each column denotes the chars that can precede the column. The code is same as [935. Knight Dialer](https://leetcode.com/problems/knight-dialer/discuss/893523/Evolve-from-brute-force-to-dp) except the matrix.\\n```\\n\\tint MOD = (int)1e9+7, N = 5;\\n    public int countVowelPermutation(int n) {\\n        int[][] M = {{0, 1, 0, 0, 0},\\n                    {1, 0, 1, 0, 0},\\n                    {1, 1, 0, 1, 1},\\n                    {0, 0, 1, 0, 1},\\n                    {1, 0, 0, 0, 0}};\\n        M = pow(M, n-1);\\n        int sum=0;\\n        for(int[] row:M)  \\n            for(int s:row)\\n                sum=(sum+s)%MOD;\\n        return sum;\\n    }\\n    private int[][] pow(int[][] M, int n) {\\n        int[][] A = new int[N][N];\\n        for(int i=0;i<N;i++) A[i][i]=1;\\n        while(n>0) {\\n            if((n&1)==1) A=mult(M,A);\\n            M=mult(M,M);\\n            n>>=1;\\n        }\\n        return A;\\n    }\\n    private int[][] mult(int[][] A, int[][] B) {\\n        int[][] C=new int[N][N];\\n        for(int i=0;i<N;i++) \\n            for(int j=0;j<N;j++)\\n                for(int k=0;k<N;k++)\\n                    C[i][j]=(int)((C[i][j]+(long)A[i][k]*B[k][j])%MOD);    \\n        return C;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tMap<Character, List<Character>> map;\\n    public int countVowelPermutation(int n) {\\n        map = new HashMap<>();\\n        map.put(\\'a\\', Arrays.asList(\\'e\\'));\\n        map.put(\\'e\\', Arrays.asList(\\'a\\',\\'i\\'));\\n        map.put(\\'i\\', Arrays.asList(\\'a\\',\\'e\\',\\'o\\',\\'u\\'));\\n        map.put(\\'o\\', Arrays.asList(\\'i\\',\\'u\\'));\\n        map.put(\\'u\\', Arrays.asList(\\'a\\'));\\n        map.put(\\' \\', Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'));\\n        return permutations(\\' \\',n);\\n\\n    }\\n    private int permutations(char pre, int n) {\\n        if(n==0) {\\n            return 1;\\n        }\\n        int count=0;\\n        for(char c:map.get(pre)) {\\n            count+=permutations(c,n-1); \\n        }\\n        return count;\\n    }\\n```\n```\\n\\tint[][] mem;\\n    int MOD = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        mem = new int[n+1][118];\\n        map = new HashMap<>();\\n        map.put(\\'a\\', Arrays.asList(\\'e\\'));\\n        map.put(\\'e\\', Arrays.asList(\\'a\\',\\'i\\'));\\n        map.put(\\'i\\', Arrays.asList(\\'a\\',\\'e\\',\\'o\\',\\'u\\'));\\n        map.put(\\'o\\', Arrays.asList(\\'i\\',\\'u\\'));\\n        map.put(\\'u\\', Arrays.asList(\\'a\\'));\\n        map.put(\\' \\', Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'));\\n        return permutations(\\' \\',n);\\n\\n    }\\n    private int permutations(char pre, int n) {\\n        if(n==0) {\\n            return 1;\\n        }\\n        if(mem[n][pre]>0) {\\n            return mem[n][pre];\\n        }\\n        int count=0;\\n        for(char c:map.get(pre)) {\\n            count+=permutations(c,n-1); \\n            count%=MOD;\\n        }\\n        return mem[n][pre]=count;\\n    }\\n```\n```\\n\\tint MOD = (int)1e9+7;\\n    public int countVowelPermutation(int n) {\\n        int[][] dp = new int[n][5];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<n;i++) {\\n            dp[i][0] = ((dp[i-1][1] + dp[i-1][2])%MOD + dp[i-1][4])%MOD;\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][2])%MOD;\\n            dp[i][2] = (dp[i-1][1] +dp[i-1][3])%MOD;\\n            dp[i][3] = dp[i-1][2];\\n            dp[i][4] = (dp[i-1][2] + dp[i-1][3])%MOD;\\n        }\\n        int perm = 0;\\n        for(int num:dp[n-1]) {\\n            perm = (perm+num)%MOD;\\n        }\\n        return perm;\\n    }\\n```\n```\\n\\tint MOD = (int)1e9+7, N = 5;\\n    public int countVowelPermutation(int n) {\\n        int[][] M = {{0, 1, 0, 0, 0},\\n                    {1, 0, 1, 0, 0},\\n                    {1, 1, 0, 1, 1},\\n                    {0, 0, 1, 0, 1},\\n                    {1, 0, 0, 0, 0}};\\n        M = pow(M, n-1);\\n        int sum=0;\\n        for(int[] row:M)  \\n            for(int s:row)\\n                sum=(sum+s)%MOD;\\n        return sum;\\n    }\\n    private int[][] pow(int[][] M, int n) {\\n        int[][] A = new int[N][N];\\n        for(int i=0;i<N;i++) A[i][i]=1;\\n        while(n>0) {\\n            if((n&1)==1) A=mult(M,A);\\n            M=mult(M,M);\\n            n>>=1;\\n        }\\n        return A;\\n    }\\n    private int[][] mult(int[][] A, int[][] B) {\\n        int[][] C=new int[N][N];\\n        for(int i=0;i<N;i++) \\n            for(int j=0;j<N;j++)\\n                for(int k=0;k<N;k++)\\n                    C[i][j]=(int)((C[i][j]+(long)A[i][k]*B[k][j])%MOD);    \\n        return C;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1049494,
                "title": "java-recursive-solution-using-dp",
                "content": "JAVA CODE IS:\\n```\\nclass Solution {\\n    int mod=1000000000+7;\\n    Integer dp[][];\\n    int arr[][]=new int[][]{{1},{0,2},{0,1,3,4},{2,4},{0}};\\n    int find(int size,int n,int curr){\\n        if(size==n-1)\\n            return 1;\\n        if(dp[size][curr]!=null)\\n            return dp[size][curr];\\n        int count=0;\\n        for(int d : arr[curr]){\\n            dp[size+1][d]=find(size+1,n,d);\\n            count=(count+dp[size+1][d])%mod;\\n        }\\n        return dp[size][curr]=count;\\n    }\\n    public int countVowelPermutation(int n) {\\n        dp=new Integer[n+1][5];\\n        int count=0;\\n        for(int i=0;i<5;i++)\\n        count=(count+find(0,n,i))%mod;\\n        return count;\\n    }\\n}\\n```\\n\\n***PLEASE,UPVOTE IF THIS IS REALLY HELPFUL FOR YOU***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000000+7;\\n    Integer dp[][];\\n    int arr[][]=new int[][]{{1},{0,2},{0,1,3,4},{2,4},{0}};\\n    int find(int size,int n,int curr){\\n        if(size==n-1)\\n            return 1;\\n        if(dp[size][curr]!=null)\\n            return dp[size][curr];\\n        int count=0;\\n        for(int d : arr[curr]){\\n            dp[size+1][d]=find(size+1,n,d);\\n            count=(count+dp[size+1][d])%mod;\\n        }\\n        return dp[size][curr]=count;\\n    }\\n    public int countVowelPermutation(int n) {\\n        dp=new Integer[n+1][5];\\n        int count=0;\\n        for(int i=0;i<5;i++)\\n        count=(count+find(0,n,i))%mod;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917004,
                "title": "c-dynamic-programming-with-explanation",
                "content": "The list dp[i][j] means that how many kinds of length i end with j (a:0, e:1, i:2, o:3, u:4) exists. So we just only need to write the transition by the principle given. Pretty easy.\\n```\\nclass Solution \\n{\\npublic:\\n    int countVowelPermutation(int n) \\n    {\\n        // a: e-a\\n        // e: a-e or i-e\\n        // i: a-i, e-i, o-i, u-i\\n        // o: i-o, u-i\\n        // u: a-u\\n        vector<vector<int>> dp(n + 1, vector<int>(5, 0));\\n        int mod = 1000000007;\\n        int ret = 0;\\n        dp[1][0] = 1, dp[1][1] = 1, dp[1][2] = 1, dp[1][3] = 1, dp[1][4] = 1;\\n        for(int i = 1; i <= n - 1; i++)\\n        {\\n            dp[i+1][0] = dp[i][1];//a\\n            dp[i+1][1] = (dp[i][0] + dp[i][2]) % mod;//e\\n            dp[i+1][2] = ((dp[i][0] + dp[i][1]) % mod + \\n                          (dp[i][3] + dp[i][4]) % mod) % mod;//i\\n            dp[i+1][3] = (dp[i][2] + dp[i][4]) % mod;\\n            dp[i+1][4] = (dp[i][0]);\\n        }\\n        for(int i = 0; i < 5; i++)\\n            ret = (ret + dp[n][i]) % mod;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countVowelPermutation(int n) \\n    {\\n        // a: e-a\\n        // e: a-e or i-e\\n        // i: a-i, e-i, o-i, u-i\\n        // o: i-o, u-i\\n        // u: a-u\\n        vector<vector<int>> dp(n + 1, vector<int>(5, 0));\\n        int mod = 1000000007;\\n        int ret = 0;\\n        dp[1][0] = 1, dp[1][1] = 1, dp[1][2] = 1, dp[1][3] = 1, dp[1][4] = 1;\\n        for(int i = 1; i <= n - 1; i++)\\n        {\\n            dp[i+1][0] = dp[i][1];//a\\n            dp[i+1][1] = (dp[i][0] + dp[i][2]) % mod;//e\\n            dp[i+1][2] = ((dp[i][0] + dp[i][1]) % mod + \\n                          (dp[i][3] + dp[i][4]) % mod) % mod;//i\\n            dp[i+1][3] = (dp[i][2] + dp[i][4]) % mod;\\n            dp[i+1][4] = (dp[i][0]);\\n        }\\n        for(int i = 0; i < 5; i++)\\n            ret = (ret + dp[n][i]) % mod;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454367,
                "title": "memoization-dp-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int last, int n, vector<vector<int>> &dp, int mod) {\\n        if(i == n) return 1;\\n        if(dp[i][last] != -1) return dp[i][last];\\n\\n        long long ans = 0;\\n        if(last == 0) {\\n            for(int j=1; j<=5; j++) ans += dfs(i + 1, j, n, dp, mod);\\n        }\\n        else if(last == 1) ans += dfs(i + 1, 2, n, dp, mod);\\n        else if(last == 2) ans += dfs(i + 1, 1, n, dp, mod) + dfs(i + 1, 3, n, dp, mod);\\n        else if(last == 3) {\\n            for(int j=1; j<=5; j++) {\\n                if(last != j) ans += dfs(i + 1, j, n, dp, mod);\\n            }\\n        }\\n        else if(last == 4) ans += dfs(i + 1, 3, n, dp, mod) + dfs(i + 1, 5, n, dp, mod);\\n        else ans += dfs(i + 1, 1, n, dp, mod);\\n\\n        return dp[i][last] = ans % mod;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n, vector<int> (6, -1));\\n        return dfs(0, 0, n, dp, 1e9 + 7);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int last, int n, vector<vector<int>> &dp, int mod) {\\n        if(i == n) return 1;\\n        if(dp[i][last] != -1) return dp[i][last];\\n\\n        long long ans = 0;\\n        if(last == 0) {\\n            for(int j=1; j<=5; j++) ans += dfs(i + 1, j, n, dp, mod);\\n        }\\n        else if(last == 1) ans += dfs(i + 1, 2, n, dp, mod);\\n        else if(last == 2) ans += dfs(i + 1, 1, n, dp, mod) + dfs(i + 1, 3, n, dp, mod);\\n        else if(last == 3) {\\n            for(int j=1; j<=5; j++) {\\n                if(last != j) ans += dfs(i + 1, j, n, dp, mod);\\n            }\\n        }\\n        else if(last == 4) ans += dfs(i + 1, 3, n, dp, mod) + dfs(i + 1, 5, n, dp, mod);\\n        else ans += dfs(i + 1, 1, n, dp, mod);\\n\\n        return dp[i][last] = ans % mod;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n, vector<int> (6, -1));\\n        return dfs(0, 0, n, dp, 1e9 + 7);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451839,
                "title": "c-simple-dp-solution",
                "content": "```\\n    int countVowelPermutation(int n) {\\n        int  mod = 1e9+7;\\n        vector<vector<long long>> dp(n+1,vector<long long>(5,1));\\n        for(int i = 2;i<=n;i++)\\n        {\\n            dp[i][0] = (dp[i-1][1] + dp[i-1][4] + dp[i-1][2])%mod;   // words ending with \\'a\\'\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][2])%mod;   // words ending with \\'e\\'\\n            dp[i][2] = (dp[i-1][1] + dp[i-1][3])%mod;   // words ending with \\'i\\'\\n            dp[i][3] = (dp[i-1][2])%mod ;               // words ending with \\'o\\'\\n            dp[i][4] = (dp[i-1][3] + dp[i-1][2])%mod;   // words ending with \\'u\\'\\n        }\\n        long long ans = 0;\\n        for(int i = 0;i<5;i++) ans = (ans + dp[n][i])%mod;\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int countVowelPermutation(int n) {\\n        int  mod = 1e9+7;\\n        vector<vector<long long>> dp(n+1,vector<long long>(5,1));\\n        for(int i = 2;i<=n;i++)\\n        {\\n            dp[i][0] = (dp[i-1][1] + dp[i-1][4] + dp[i-1][2])%mod;   // words ending with \\'a\\'\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][2])%mod;   // words ending with \\'e\\'\\n            dp[i][2] = (dp[i-1][1] + dp[i-1][3])%mod;   // words ending with \\'i\\'\\n            dp[i][3] = (dp[i-1][2])%mod ;               // words ending with \\'o\\'\\n            dp[i][4] = (dp[i-1][3] + dp[i-1][2])%mod;   // words ending with \\'u\\'\\n        }\\n        long long ans = 0;\\n        for(int i = 0;i<5;i++) ans = (ans + dp[n][i])%mod;\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2396245,
                "title": "python-solution-1d-dynamic-programming-100-faster",
                "content": "the total number of permutations is found by adding all the strings ending with every character in {a,e,i,o,u} \\nbased on given rules - we create formula to find number of strings ending with that character.\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        store = [1,1,1,1,1]\\n        MOD = 10**9 + 7\\n        A, E, I, O, U = 0, 1, 2, 3, 4\\n        for _ in range(1,n):\\n            a, e, i, o, u = store\\n            \\n            store[A] = (e + i + u) % MOD\\n            store[E] = (a + i) % MOD\\n            store[I] = (e + o) % MOD\\n            store[O] = (i)\\n            store[U] = (i + o) % MOD\\n            \\n        return sum(store) % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        store = [1,1,1,1,1]\\n        MOD = 10**9 + 7\\n        A, E, I, O, U = 0, 1, 2, 3, 4\\n        for _ in range(1,n):\\n            a, e, i, o, u = store\\n            \\n            store[A] = (e + i + u) % MOD\\n            store[E] = (a + i) % MOD\\n            store[I] = (e + o) % MOD\\n            store[O] = (i)\\n            store[U] = (i + o) % MOD\\n            \\n        return sum(store) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395293,
                "title": "simple-striver-solution-recursion-memoization-tabulation",
                "content": "**Striver method to solve DP questions.**\\n\\nSimilar to Ninja Training question.\\n*To understand the complete method, watch :*  https://www.youtube.com/watch?v=AE39gJYuRog&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY&index=8\\n\\n\\n# **Recursion with Memoization!!!**\\n\\n```\\nclass Solution {\\n    \\n    private static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        long dp[][]=new long[n+1][6];\\n        \\n        for(long[] e:dp)\\n            Arrays.fill(e,-1);\\n        \\n        long ans = recursion(n,5,dp);\\n        \\n        return (int)ans%mod;\\n    }\\n    \\n    long recursion(int n,int last,long[][] dp)\\n    {\\n        if(n==0)\\n            return 1L;\\n        \\n        if(dp[n][last]!=-1)\\n            return dp[n][last];\\n        \\n        long ans=0L;\\n        \\n        if(last==0)\\n            ans=recursion(n-1,1,dp);\\n        if(last==1)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,2,dp);\\n        if(last==2)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,1,dp)+recursion(n-1,3,dp)+recursion(n-1,4,dp);\\n        if(last==3)\\n            ans=recursion(n-1,2,dp)+recursion(n-1,4,dp);\\n        if(last==4)\\n            ans=recursion(n-1,0,dp);\\n        if(last==5)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,1,dp)+recursion(n-1,2,dp)+recursion(n-1,3,dp)+recursion(n-1,4,dp);\\n        \\n        return dp[n][last] = ans%mod;\\n    }\\n}\\n```\\n\\n\\n\\n\\n# **Tabulation**\\n\\n```\\nclass Solution {\\n    \\n    private static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        long dp[][]=new long[n+1][6];\\n        \\n        for(int last=0;last<6;last++)\\n            dp[0][last]=1L;\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int last=0;last<6;last++)\\n            {\\n                long ans=0L;\\n        \\n                if(last==0)\\n                    ans = dp[i-1][1];\\n                if(last==1)\\n                    ans = dp[i-1][0]+dp[i-1][2];\\n                if(last==2)\\n                    ans = dp[i-1][0]+dp[i-1][1]+dp[i-1][3]+dp[i-1][4];\\n                if(last==3)\\n                    ans = dp[i-1][2]+dp[i-1][4];\\n                if(last==4)\\n                    ans = dp[i-1][0];\\n                if(last==5)\\n                    ans = dp[i-1][0]+dp[i-1][1]+dp[i-1][2]+dp[i-1][3]+dp[i-1][4];\\n                \\n                dp[i][last] = ans%mod;\\n            }\\n        }\\n                \\n        return (int)dp[n][5]%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        long dp[][]=new long[n+1][6];\\n        \\n        for(long[] e:dp)\\n            Arrays.fill(e,-1);\\n        \\n        long ans = recursion(n,5,dp);\\n        \\n        return (int)ans%mod;\\n    }\\n    \\n    long recursion(int n,int last,long[][] dp)\\n    {\\n        if(n==0)\\n            return 1L;\\n        \\n        if(dp[n][last]!=-1)\\n            return dp[n][last];\\n        \\n        long ans=0L;\\n        \\n        if(last==0)\\n            ans=recursion(n-1,1,dp);\\n        if(last==1)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,2,dp);\\n        if(last==2)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,1,dp)+recursion(n-1,3,dp)+recursion(n-1,4,dp);\\n        if(last==3)\\n            ans=recursion(n-1,2,dp)+recursion(n-1,4,dp);\\n        if(last==4)\\n            ans=recursion(n-1,0,dp);\\n        if(last==5)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,1,dp)+recursion(n-1,2,dp)+recursion(n-1,3,dp)+recursion(n-1,4,dp);\\n        \\n        return dp[n][last] = ans%mod;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    private static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        long dp[][]=new long[n+1][6];\\n        \\n        for(int last=0;last<6;last++)\\n            dp[0][last]=1L;\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int last=0;last<6;last++)\\n            {\\n                long ans=0L;\\n        \\n                if(last==0)\\n                    ans = dp[i-1][1];\\n                if(last==1)\\n                    ans = dp[i-1][0]+dp[i-1][2];\\n                if(last==2)\\n                    ans = dp[i-1][0]+dp[i-1][1]+dp[i-1][3]+dp[i-1][4];\\n                if(last==3)\\n                    ans = dp[i-1][2]+dp[i-1][4];\\n                if(last==4)\\n                    ans = dp[i-1][0];\\n                if(last==5)\\n                    ans = dp[i-1][0]+dp[i-1][1]+dp[i-1][2]+dp[i-1][3]+dp[i-1][4];\\n                \\n                dp[i][last] = ans%mod;\\n            }\\n        }\\n                \\n        return (int)dp[n][5]%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394623,
                "title": "python-o-log-n-time",
                "content": "**>>>Comments**\\n\\nThe solution involves the use of Linear algebra (matrix exponentiation).\\n\\nIntuition:\\nThis is just an improvement over the DP bottom up approach presented in the approach 2 of the \"official\" leetcode solution.\\nInstead of storing the values of the current permutations that end with a vocal in 5 separate variables, we store all those values in a vector, let\\'s call it \"b\".\\nIn that solution to find the number of permutations of length i that finish with a vocal you utilize a linear combination of the values of the previous entries of the vector b:\\n**but each time you use a linear combination of  the values of a vector to compute an other vector this is equivalent to a matrix multiplication**, you have to know this very well otherwise you will not have the intuition to use matrix multiplication.\\n\\nIf someone knows how to somehow anticipate the module operation to prevent the numbers from getting too big would be helpful, because this is what forced me to make dtype = object, slowing down the code.\\n\\n**>>>Code**\\n\\nMore readable version:\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = np.array([[0,1,1,0,1],[1,0,1,0,0],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,1,0]], dtype = object)\\n        b = np.array([1,1,1,1,1], dtype = object)\\n        a = np.linalg.matrix_power(a,n-1)\\n        b = matmul(a,b)\\n        return floor(np.sum(b))%1000000007\\n```\\n\\nShorter version: takes advantage of the fact that since b is a vector of all ones when is multiplying it by a matrix and then taking the sum of the entries of the result is the same as just summing all the element of the matrix without multiplying it: \\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = np.array([[0,1,1,0,1],[1,0,1,0,0],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,1,0]], dtype = object)\\n        a = np.linalg.matrix_power(a,n-1)\\n        return floor(np.sum(a))%1000000007\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = np.array([[0,1,1,0,1],[1,0,1,0,0],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,1,0]], dtype = object)\\n        b = np.array([1,1,1,1,1], dtype = object)\\n        a = np.linalg.matrix_power(a,n-1)\\n        b = matmul(a,b)\\n        return floor(np.sum(b))%1000000007\\n```\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = np.array([[0,1,1,0,1],[1,0,1,0,0],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,1,0]], dtype = object)\\n        a = np.linalg.matrix_power(a,n-1)\\n        return floor(np.sum(a))%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394184,
                "title": "c-clean-code-well-explained",
                "content": "Each vowel allows some number of subsequent characters. These transitions are like a tree. This problem is asking, \"what\\'s the width of the tree with height n?\"\\n\\n![image](https://assets.leetcode.com/users/images/91b5c38a-ebc8-43e9-af13-03e9b3cc5b71_1659890728.907886.png)\\n\\nMy solution keeps track of the number of each vowel at a level in this tree. To calculate say \\'A\\', we calculate how many nodes in the previous level produce \\'A\\'. This is the number of \\'E\\', \\'I\\', and \\'U\\' nodes.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long mod = 1e9+7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        long a2, e2, i2, o2, u2;\\n        \\n        for(int j = 2; j <= n; j++){\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = (i) % mod;\\n            u2 = (i + o) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long mod = 1e9+7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        long a2, e2, i2, o2, u2;\\n        \\n        for(int j = 2; j <= n; j++){\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = (i) % mod;\\n            u2 = (i + o) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393912,
                "title": "c-dp-recursion-memoization-easy-to-understand-straight-forward",
                "content": "```\\nclass Solution {\\npublic:\\n    #define mod  1000000007\\n    int solve(char ch,int n){\\n        if(n==0) return 1;\\n        \\n        if(ch==\\'a\\'){\\n            return solve(\\'e\\',n-1);\\n        }else if(ch==\\'e\\'){\\n            return (solve(\\'a\\',n-1)+solve(\\'i\\',n-1))%mod;\\n        }else if(ch==\\'i\\'){\\n            return (((solve(\\'a\\',n-1)+solve(\\'e\\',n-1))%mod+solve(\\'o\\',n-1))%mod+solve(\\'u\\',n-1))%mod;\\n        }else if(ch==\\'o\\'){\\n            return solve(\\'i\\',n-1)+solve(\\'u\\',n-1)%mod;\\n        }else{\\n            return solve(\\'a\\',n-1);\\n        }\\n    }\\n       int solveMemo(char ch,int n,vector<vector<int>>&dp){\\n        if(n==0) return 1;\\n        if(dp[n][ch-\\'a\\']!=-1) return dp[n][ch-\\'a\\'];\\n        if(ch==\\'a\\'){\\n            return dp[n][ch-\\'a\\']=solveMemo(\\'e\\',n-1,dp);\\n        }else if(ch==\\'e\\'){\\n            return dp[n][ch-\\'a\\']=(solveMemo(\\'a\\',n-1,dp)+solveMemo(\\'i\\',n-1,dp))%mod;\\n        }else if(ch==\\'i\\'){            \\n            return dp[n][ch-\\'a\\']=(((solveMemo(\\'a\\',n-1,dp)+solveMemo(\\'e\\',n-1,dp))%mod+solveMemo(\\'o\\',n-1,dp))%mod+solveMemo(\\'u\\',n-1,dp))%mod;\\n        }else if(ch==\\'o\\'){\\n            return dp[n][ch-\\'a\\']=(solveMemo(\\'i\\',n-1,dp)+solveMemo(\\'u\\',n-1,dp))%mod;\\n        }else{\\n            return dp[n][ch-\\'a\\']=solveMemo(\\'a\\',n-1,dp);\\n        }\\n    }\\n    int countVowelPermutation(int n) {\\n        \\n        int ans=0;\\n        vector<char>vec={\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        // for(int i=0;i<5;i++){\\n        //     ans=(ans+solve(vec[i],n-1))%mod;\\n        // }\\n        vector<vector<int>>dp(n+1,vector<int>(26,-1));\\n          for(int i=0;i<5;i++){\\n            ans=(ans+solveMemo(vec[i],n-1,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define mod  1000000007\\n    int solve(char ch,int n){\\n        if(n==0) return 1;\\n        \\n        if(ch==\\'a\\'){\\n            return solve(\\'e\\',n-1);\\n        }else if(ch==\\'e\\'){\\n            return (solve(\\'a\\',n-1)+solve(\\'i\\',n-1))%mod;\\n        }else if(ch==\\'i\\'){\\n            return (((solve(\\'a\\',n-1)+solve(\\'e\\',n-1))%mod+solve(\\'o\\',n-1))%mod+solve(\\'u\\',n-1))%mod;\\n        }else if(ch==\\'o\\'){\\n            return solve(\\'i\\',n-1)+solve(\\'u\\',n-1)%mod;\\n        }else{\\n            return solve(\\'a\\',n-1);\\n        }\\n    }\\n       int solveMemo(char ch,int n,vector<vector<int>>&dp){\\n        if(n==0) return 1;\\n        if(dp[n][ch-\\'a\\']!=-1) return dp[n][ch-\\'a\\'];\\n        if(ch==\\'a\\'){\\n            return dp[n][ch-\\'a\\']=solveMemo(\\'e\\',n-1,dp);\\n        }else if(ch==\\'e\\'){\\n            return dp[n][ch-\\'a\\']=(solveMemo(\\'a\\',n-1,dp)+solveMemo(\\'i\\',n-1,dp))%mod;\\n        }else if(ch==\\'i\\'){            \\n            return dp[n][ch-\\'a\\']=(((solveMemo(\\'a\\',n-1,dp)+solveMemo(\\'e\\',n-1,dp))%mod+solveMemo(\\'o\\',n-1,dp))%mod+solveMemo(\\'u\\',n-1,dp))%mod;\\n        }else if(ch==\\'o\\'){\\n            return dp[n][ch-\\'a\\']=(solveMemo(\\'i\\',n-1,dp)+solveMemo(\\'u\\',n-1,dp))%mod;\\n        }else{\\n            return dp[n][ch-\\'a\\']=solveMemo(\\'a\\',n-1,dp);\\n        }\\n    }\\n    int countVowelPermutation(int n) {\\n        \\n        int ans=0;\\n        vector<char>vec={\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        // for(int i=0;i<5;i++){\\n        //     ans=(ans+solve(vec[i],n-1))%mod;\\n        // }\\n        vector<vector<int>>dp(n+1,vector<int>(26,-1));\\n          for(int i=0;i<5;i++){\\n            ans=(ans+solveMemo(vec[i],n-1,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392733,
                "title": "c-easy-and-dp-solution",
                "content": "DP solution\\n```\\nclass Solution {\\npublic:   \\n    int countVowelPermutation(int n) {\\n        const int mod=1000000007;\\n\\t\\tlong long int arr[n][5];\\n\\t\\tfor(int i=0;i<5;i++)\\n\\t\\t{\\n\\t\\t\\tarr[0][i]=1;\\n\\t\\t}\\n\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tarr[i][0]=arr[i-1][1]+arr[i-1][2]+arr[i-1][4];\\n\\t\\t\\tarr[i][0]%=mod;\\n\\t\\t\\tarr[i][1]=arr[i-1][0]+arr[i-1][2];  \\n\\t\\t\\tarr[i][1]%=mod;\\n\\t\\t\\tarr[i][2]=arr[i-1][1]+arr[i-1][3];\\n\\t\\t\\tarr[i][2]%=mod;\\n\\t\\t\\tarr[i][3]=arr[i-1][2];\\n\\t\\t\\tarr[i][3]%=mod;\\n\\t\\t\\tarr[i][4]=arr[i-1][2]+arr[i-1][3];\\n\\t\\t\\tarr[i][4]%=mod;\\n\\t\\t}\\n\\t\\tlong long int ans=0;\\n\\t\\tfor(int i=0;i<5;i++)\\n\\t\\t{\\n\\t\\t\\tans+=arr[n-1][i];\\n\\t\\t\\tans%=mod;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```\\nEasy solution\\n```\\nclass Solution {\\npublic:\\n    \\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    int countVowelPermutation(int n) {\\n        const int mod=1000000007;\\n\\t\\tlong long int arr[n][5];\\n\\t\\tfor(int i=0;i<5;i++)\\n\\t\\t{\\n\\t\\t\\tarr[0][i]=1;\\n\\t\\t}\\n\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tarr[i][0]=arr[i-1][1]+arr[i-1][2]+arr[i-1][4];\\n\\t\\t\\tarr[i][0]%=mod;\\n\\t\\t\\tarr[i][1]=arr[i-1][0]+arr[i-1][2];  \\n\\t\\t\\tarr[i][1]%=mod;\\n\\t\\t\\tarr[i][2]=arr[i-1][1]+arr[i-1][3];\\n\\t\\t\\tarr[i][2]%=mod;\\n\\t\\t\\tarr[i][3]=arr[i-1][2];\\n\\t\\t\\tarr[i][3]%=mod;\\n\\t\\t\\tarr[i][4]=arr[i-1][2]+arr[i-1][3];\\n\\t\\t\\tarr[i][4]%=mod;\\n\\t\\t}\\n\\t\\tlong long int ans=0;\\n\\t\\tfor(int i=0;i<5;i++)\\n\\t\\t{\\n\\t\\t\\tans+=arr[n-1][i];\\n\\t\\t\\tans%=mod;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392650,
                "title": "c-recursion-memoization-easy-explanation-dp",
                "content": "First of all Let\\'s Understand why this problem can be solved by Dynamic-Programming , for approaching this as a dp problem this should have repeating sub problems , so let us understand why this have repeating subproblems....\\nIf we fix the first character as any of the one vowel , so if we start the recursion tree by fixing the first character as \\'a\\' then then second character can be only \\'e\\' , if the length is 10 then again we can think \\'e\\' as the fixed character recursively and for \\'e\\' now we can have the third character as \\'a\\' or \\'i\\'  ...........so we can go on till we reach to the index n , like this we can count permutations .\\nBut let us try to think of the memoizing state , only last fixed character can not define the state completely , we need some index sort of thing , for that let\\'s analayze the state : if the last character was \\'e\\' and current index is 4 from the total length of 10 , so the remaining indices which are left to be explored are 6 , and that defines the dp state , because again we can come to this same state for some different recursion state we can have same character \\'e\\' as the last character and remaining `(n-i)`  indices , so we can memoize this in a DP table ,\\nthe Parameters are the last character and the remaining indices.\\n\\nso just go for the recursion tree and memoize the state as `dp[n-i][lastCharacter]`  and add the answers for the different fixed first index characters .\\nHappy coding \\uD83E\\uDD1E\\n\\nCode:\\n```\\ntypedef long long int l;\\nclass Solution {\\npublic:\\n    map<char,int> m;\\n    int MOD=1e9+7;\\n    l recursion(int i,int n,char last,vector<vector<l>> &dp){\\n        if(i==n){\\n            return 1;\\n        }\\n        \\n        if(dp[n-i][m[last]]!=-1){\\n                return dp[n-i][m[last]];\\n        }\\n        if(last==\\'a\\')\\n                return dp[n-i][m[last]]=recursion(i+1,n,\\'e\\',dp)%MOD;\\n            \\n        if(last==\\'e\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'a\\',dp)+recursion(i+1,n,\\'i\\',dp))%MOD;\\n                \\n        if(last==\\'i\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'a\\',dp)+recursion(i+1,n,\\'e\\',dp)+recursion(i+1,n,\\'o\\',dp)+recursion(i+1,n,\\'u\\',dp))%MOD;\\n                   \\n        if(last==\\'o\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'i\\',dp)+recursion(i+1,n,\\'u\\',dp))%MOD;\\n                       \\n        return dp[n-i][m[last]]=recursion(i+1,n,\\'a\\',dp)%MOD;\\n                       \\n    }\\n    int countVowelPermutation(int n) {\\n        vector<vector<l>> dp(n+1,vector<l>(6,-1));\\n        l ans=0;\\n        m[\\'a\\']=1;  // this mapping for getting integer out of our vowels , for memoizing in array \\n        m[\\'e\\']=2;\\n        m[\\'i\\']=3;\\n        m[\\'o\\']=4;\\n        m[\\'u\\']=5;\\n        // as we have done for the 0th index we are going for the next index which is 1 and the starting character as different vowels\\n        ans=(ans+recursion(1,n,\\'a\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'e\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'i\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'o\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'u\\',dp))%MOD;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ntypedef long long int l;\\nclass Solution {\\npublic:\\n    map<char,int> m;\\n    int MOD=1e9+7;\\n    l recursion(int i,int n,char last,vector<vector<l>> &dp){\\n        if(i==n){\\n            return 1;\\n        }\\n        \\n        if(dp[n-i][m[last]]!=-1){\\n                return dp[n-i][m[last]];\\n        }\\n        if(last==\\'a\\')\\n                return dp[n-i][m[last]]=recursion(i+1,n,\\'e\\',dp)%MOD;\\n            \\n        if(last==\\'e\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'a\\',dp)+recursion(i+1,n,\\'i\\',dp))%MOD;\\n                \\n        if(last==\\'i\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'a\\',dp)+recursion(i+1,n,\\'e\\',dp)+recursion(i+1,n,\\'o\\',dp)+recursion(i+1,n,\\'u\\',dp))%MOD;\\n                   \\n        if(last==\\'o\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'i\\',dp)+recursion(i+1,n,\\'u\\',dp))%MOD;\\n                       \\n        return dp[n-i][m[last]]=recursion(i+1,n,\\'a\\',dp)%MOD;\\n                       \\n    }\\n    int countVowelPermutation(int n) {\\n        vector<vector<l>> dp(n+1,vector<l>(6,-1));\\n        l ans=0;\\n        m[\\'a\\']=1;  // this mapping for getting integer out of our vowels , for memoizing in array \\n        m[\\'e\\']=2;\\n        m[\\'i\\']=3;\\n        m[\\'o\\']=4;\\n        m[\\'u\\']=5;\\n        // as we have done for the 0th index we are going for the next index which is 1 and the starting character as different vowels\\n        ans=(ans+recursion(1,n,\\'a\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'e\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'i\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'o\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'u\\',dp))%MOD;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392259,
                "title": "0-ms-faster-than-100-o-n-c-dp-well-explaned",
                "content": "Given length of string ```n``` with vowels. Also given some ```rules or mappings```, each vowel allows some number of subsequent characters. You need to find the total number of different strings we can form of length of ```n```.\\n```\\n\\'a\\'    =>    \\'e\\'\\n\\'e\\'    =>    \\'a\\' / \\'i\\'\\n\\'i\\'    =>    \\'a\\' / \\'e\\' / \\'o\\' / \\'u\\'\\n\\'o\\'    =>    \\'i\\' / \\'u\\'\\n\\'u\\'    =>    \\'a\\'\\n```\\nBut when you observe from oposite side then you can see next vowel depends on some specific current vowels. In simple words, next vowel character count sum of some current vowels count.\\n```\\nNext            Current\\n\\'a\\'    <=    \\'e\\' + \\'i\\' + \\'u\\'\\n\\'e\\'    <=    \\'a\\' + \\'i\\'\\n\\'i\\'    <=    \\'e\\' + \\'o\\'\\n\\'o\\'    <=    \\'i\\'\\n\\'u\\'    <=    \\'i\\' + \\'o\\'\\n```\\nLet\\'s see the simple c++ code:\\n```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int countVowelPermutation(int n) {\\n        int dp[n][5];\\n        for (int i = 0; i < 5 ; i++) {\\n            dp[0][i] = 1;\\n        }\\n        for (int i = 0; i < n-1; i++) {\\n            dp[i + 1][0] = ((dp[i][1] + dp[i][2]) % mod + dp[i][4]) % mod;\\n            dp[i + 1][1] = (dp[i][0] + dp[i][2]) % mod;\\n            dp[i + 1][2] = (dp[i][1] + dp[i][3]) % mod;\\n            dp[i + 1][3] = dp[i][2];\\n            dp[i + 1][4] = (dp[i][2] + dp[i][3]) % mod;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < 5; i++) {\\n            ans = (ans + dp[n - 1][i]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Time Complexity:*** ```O(N)```. The total time complexity becomes ```O(5*N) = O(N)```.\\n***Space Complexity:*** ```O(N)```. The total space complexity becomes ```O(5*N) = O(N)```.\\n\\n```IF YOU REALLY FOUND MY SOLUTION HELPFUL THEN JUST PLEASE UPVOTE IT.```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```n```\n```rules or mappings```\n```n```\n```\\n\\'a\\'    =>    \\'e\\'\\n\\'e\\'    =>    \\'a\\' / \\'i\\'\\n\\'i\\'    =>    \\'a\\' / \\'e\\' / \\'o\\' / \\'u\\'\\n\\'o\\'    =>    \\'i\\' / \\'u\\'\\n\\'u\\'    =>    \\'a\\'\\n```\n```\\nNext            Current\\n\\'a\\'    <=    \\'e\\' + \\'i\\' + \\'u\\'\\n\\'e\\'    <=    \\'a\\' + \\'i\\'\\n\\'i\\'    <=    \\'e\\' + \\'o\\'\\n\\'o\\'    <=    \\'i\\'\\n\\'u\\'    <=    \\'i\\' + \\'o\\'\\n```\n```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int countVowelPermutation(int n) {\\n        int dp[n][5];\\n        for (int i = 0; i < 5 ; i++) {\\n            dp[0][i] = 1;\\n        }\\n        for (int i = 0; i < n-1; i++) {\\n            dp[i + 1][0] = ((dp[i][1] + dp[i][2]) % mod + dp[i][4]) % mod;\\n            dp[i + 1][1] = (dp[i][0] + dp[i][2]) % mod;\\n            dp[i + 1][2] = (dp[i][1] + dp[i][3]) % mod;\\n            dp[i + 1][3] = dp[i][2];\\n            dp[i + 1][4] = (dp[i][2] + dp[i][3]) % mod;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < 5; i++) {\\n            ans = (ans + dp[n - 1][i]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```O(N)```\n```O(5*N) = O(N)```\n```O(N)```\n```O(5*N) = O(N)```\n```IF YOU REALLY FOUND MY SOLUTION HELPFUL THEN JUST PLEASE UPVOTE IT.```",
                "codeTag": "Java"
            },
            {
                "id": 2392131,
                "title": "java-solution-clean-and-well-commented-code-dynamic-programming-easy-to-understand-approach",
                "content": "Well, First think of the **smallest case possible**, `(n == 1)` *In this case the answer is clearly 5*  *(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')*. Then, think of the number of ways you can make ans for `( n == 2 ) `, *By adding characters at the end of all the answer strings in (n == 1) by following the rules. Right?*\\n\\nTo consider all the possibilities I have made an array `\"data\"` which stores all the eligible characters we can append to each of the current string.\\n\\nSo, we have to figure out the ans for \\'n\\' and have only five type of strings possible at each level (**ending with all the five characters**) hence the **dp** array is of dimensions `( n + 1 ) * 5`.\\n\\n*Now, you can go through the code to understand the problem and its approach completely.*\\n\\n\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[][] dp = new long[n+1][5];\\n\\t\\t// Filling the dp array for base case (i.e, n == 1)\\n        for(int i=0; i<5; i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n\\t\\t// Considering  a = 0, e = 1, i = 2, o = 3 and u  = 4 ( for the representation of their indices )\\n\\t\\t// Filling the data array with the characters we can append after the respective character\\n        int[][] data = {{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        int M = (int)1e9+7;\\n        \\n        for(int i=2; i<=n; i++){\\n\\t\\t// we started forming the ans from n = 2 case\\n\\t\\t\\n            for(int j=0; j<5; j++){\\n\\t\\t\\t// traversing all the columns of previous row and adding in the current one\\n\\t\\t\\t\\n                for(int k=0; k<data[j].length; k++){\\n\\t\\t\\t\\t// We have to add to all those characters which can be appended by the previous end characters. \\n\\t\\t\\t\\t//So, the number of strings ending with \\'e\\'s can be formed by appending after all the previously ending with \\'a\\' strings\\n\\t\\t\\t\\t// Here, the mod has also been taken to prevent overflow\\n\\t\\t\\t\\t// data[j][k] let\\'say for j=0 will represent the index of \\'e\\' (1). And we add the number of \\'a\\'s ( dp[ i - 1 ][ j ] ) to it.\\n\\t\\t\\t\\t\\n                    dp[i][data[j][k]] = (dp[i][data[j][k]] + dp[i-1][j])%M;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// At the end the sum of all the strings (ending with the respective character) is our answer for all the strings of length \\'n\\'\\n        long sum = 0;\\n        for(int i=0; i<5; i++){\\n            sum =(sum + dp[n][i])%M;\\n        }\\n        return (int)sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[][] dp = new long[n+1][5];\\n\\t\\t// Filling the dp array for base case (i.e, n == 1)\\n        for(int i=0; i<5; i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n\\t\\t// Considering  a = 0, e = 1, i = 2, o = 3 and u  = 4 ( for the representation of their indices )\\n\\t\\t// Filling the data array with the characters we can append after the respective character\\n        int[][] data = {{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        int M = (int)1e9+7;\\n        \\n        for(int i=2; i<=n; i++){\\n\\t\\t// we started forming the ans from n = 2 case\\n\\t\\t\\n            for(int j=0; j<5; j++){\\n\\t\\t\\t// traversing all the columns of previous row and adding in the current one\\n\\t\\t\\t\\n                for(int k=0; k<data[j].length; k++){\\n\\t\\t\\t\\t// We have to add to all those characters which can be appended by the previous end characters. \\n\\t\\t\\t\\t//So, the number of strings ending with \\'e\\'s can be formed by appending after all the previously ending with \\'a\\' strings\\n\\t\\t\\t\\t// Here, the mod has also been taken to prevent overflow\\n\\t\\t\\t\\t// data[j][k] let\\'say for j=0 will represent the index of \\'e\\' (1). And we add the number of \\'a\\'s ( dp[ i - 1 ][ j ] ) to it.\\n\\t\\t\\t\\t\\n                    dp[i][data[j][k]] = (dp[i][data[j][k]] + dp[i-1][j])%M;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// At the end the sum of all the strings (ending with the respective character) is our answer for all the strings of length \\'n\\'\\n        long sum = 0;\\n        for(int i=0; i<5; i++){\\n            sum =(sum + dp[n][i])%M;\\n        }\\n        return (int)sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392056,
                "title": "c-dynamic-programming-approach",
                "content": "**One can think of using bruteforce approach in this problem by finding out all the possible strings ending with a particular vowel that leads to branches and overlapping subproblems. Thus, evidently dynamic programming comes into picture.**\\n\\nWe know the possibille strings that can be formed from a string ending with certain characters. So generating the dp[][] matrix becomes simple by observing which vowel comes next if the string end with any vowel.\\n\\nExample : \\n* \\'a\\' will be the end of the string if the previous one ended with an \\'e\\' , \\'u\\' or \\'i\\'.\\n* \\'e\\' will be the end of the string if the previous one ended with an \\'a\\'  or \\'i\\'.\\n* \\'i\\' will be the end of the string if the previous one ended with an \\'e\\' or \\'o\\'.\\n* \\'o\\' will be the end of the string only if the previous one ended with an \\'i\\'.\\n* \\'u\\' will be the end of the string if the previous one ended with an \\'i\\' or \\'o\\'.\\n\\n**Code**\\n\\n```\\nint countVowelPermutation(int n)\\n{\\n    int mod = 1000000007;\\n\\t// dimensions of dp is nx5 as we have only 5 characters to compute\\n    long long dp[n][5];\\n\\t// initializing first row with 1 (when n = 1 , only a character is there)\\n    dp[0][0] = dp[0][1] = dp[0][2] = dp[0][3] = dp[0][4] = 1;\\n    for (int i = 1; i < n; i++)\\n    {\\n        dp[i][0] = ((dp[i - 1][1]) + (dp[i - 1][2]) + (dp[i - 1][4])) % mod;         // cases for a\\n        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod;                              // cases for e\\n        dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % mod;                              // cases for i\\n        dp[i][3] = (dp[i - 1][2]) % mod;                                             // cases for o\\n        dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % mod;                              // cases for u\\n    }\\n    long long ans = 0;\\n    for (int i = 0; i < 5; i++)\\n        ans = (ans + dp[n - 1][i]) % mod;\\n\\t\\t// finally return the sum of all possibilities \\n    return ans;\\n}\\n```\\n\\n**Please upvote if this post was useful.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelPermutation(int n)\\n{\\n    int mod = 1000000007;\\n\\t// dimensions of dp is nx5 as we have only 5 characters to compute\\n    long long dp[n][5];\\n\\t// initializing first row with 1 (when n = 1 , only a character is there)\\n    dp[0][0] = dp[0][1] = dp[0][2] = dp[0][3] = dp[0][4] = 1;\\n    for (int i = 1; i < n; i++)\\n    {\\n        dp[i][0] = ((dp[i - 1][1]) + (dp[i - 1][2]) + (dp[i - 1][4])) % mod;         // cases for a\\n        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod;                              // cases for e\\n        dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % mod;                              // cases for i\\n        dp[i][3] = (dp[i - 1][2]) % mod;                                             // cases for o\\n        dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % mod;                              // cases for u\\n    }\\n    long long ans = 0;\\n    for (int i = 0; i < 5; i++)\\n        ans = (ans + dp[n - 1][i]) % mod;\\n\\t\\t// finally return the sum of all possibilities \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391656,
                "title": "java-easy-to-understand-explained",
                "content": "**Do consider upvoting if you find this helpful!**\\n**Also feel free to ask any queries or to suggest any improvements :)**\\n\\nThis solution can be easier to understand if one is familiar with the memoization(top-down) technique used to solve the standard fibonacci series problem with dp.\\n\\nI\\'ll try to explain with an analogical visualizaion...\\n\\n```\\nlength             string ending at vowel\\n     n                          a\\n                             /  |  \\\\\\n                            /   |   \\\\\\n                           /    |    \\\\\\n     n-1                  e     i     u\\n                         / \\\\   / \\\\   / \\\\\\n     n-2                a   i e   o i   o\\n     .                       \\n     .\\n     . and so on\\n```\\n\\nI hope this clearly shows the overlapping sub-problems(the 2 **i**\\'s and 2 **o**\\'s at length n-2) that are being encountered and why dp is necessary to avoid repition of calculating same sub-problem again and again!\\n\\n```\\nclass Solution {\\n    \\n    static int[][] dp;\\n    static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        /*  a -> 0\\n            e -> 1\\n            i -> 2\\n            o -> 3\\n            u -> 4   */\\n        \\n        dp = new int[5][n+1]; // dp array stores the no. of strings of length \\'n\\' ending at i-th vowel \\n        \\n        for(int i=0; i<5; i++)\\n                dp[i][1] = 1; // base cases where for n = 1, each character itself is a valid string\\n        \\n        \\n        // prefix array stores 1 at all the j-th indexes where i-th vowel is preceeded by j-th vowel\\n        \\n        int[][] prefix = {{-1, 1, 1, -1, 1},   //a preceeded by e,i,u (1,2,4)...therefore prefix[0][1] = prefix[0][2] = prefix[0][4] = 1\\n                          {1, -1, 1, -1, -1},  //e preceeded by a,i (0,2)\\n                          {-1, 1, -1, 1, -1},  //i preceeded by e,o (1,3)\\n                          {-1, -1, 1, -1, -1}, //o preceeded by i (2)\\n                          {-1, -1, 1, 1, -1}}; //u preceeded by i,0 (2,3)\\n                \\n        \\n        \\n        for(int i=0; i<5; i++){\\n            digDown(i, n, prefix); // the actual solution phase...finding all the strings ending at each vowel with length \\'n\\'\\n        }\\n        \\n        int sum = 0;\\n        for(int i=0; i<5; i++){\\n            sum = (sum + dp[i][n]%mod)%mod; // calculating the answer...adding up the total strings ending at each vowel\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public void digDown(int c, int n, int[][] prefix){\\n        // here c is the index of current vowel and n is the current lenght of string into consideration\\n\\t\\t\\n        if(n == 1) return; // remember the base cases mentioned earlier!\\n        \\n        for(int i=0; i<5; i++){\\n            \\n            if(prefix[c][i] == 1){ // i.e. if the vowel \\'c\\' is preceeded by vowel \\'i\\' we proceed further\\n                \\n                if(dp[i][n-1] == 0) digDown(i, n-1, prefix); // if the value(i.e. the no. of strings) is not yet calculated for string ending at \\n                                                             // vowel i of length \\'n-1\\'...we call the recursive function to find that out\\n                \\n                dp[c][n] = (dp[c][n]%mod + dp[i][n-1]%mod)%mod; // finally adding the values from vaild predecessor vowel\\n            }\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nlength             string ending at vowel\\n     n                          a\\n                             /  |  \\\\\\n                            /   |   \\\\\\n                           /    |    \\\\\\n     n-1                  e     i     u\\n                         / \\\\   / \\\\   / \\\\\\n     n-2                a   i e   o i   o\\n     .                       \\n     .\\n     . and so on\\n```\n```\\nclass Solution {\\n    \\n    static int[][] dp;\\n    static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        /*  a -> 0\\n            e -> 1\\n            i -> 2\\n            o -> 3\\n            u -> 4   */\\n        \\n        dp = new int[5][n+1]; // dp array stores the no. of strings of length \\'n\\' ending at i-th vowel \\n        \\n        for(int i=0; i<5; i++)\\n                dp[i][1] = 1; // base cases where for n = 1, each character itself is a valid string\\n        \\n        \\n        // prefix array stores 1 at all the j-th indexes where i-th vowel is preceeded by j-th vowel\\n        \\n        int[][] prefix = {{-1, 1, 1, -1, 1},   //a preceeded by e,i,u (1,2,4)...therefore prefix[0][1] = prefix[0][2] = prefix[0][4] = 1\\n                          {1, -1, 1, -1, -1},  //e preceeded by a,i (0,2)\\n                          {-1, 1, -1, 1, -1},  //i preceeded by e,o (1,3)\\n                          {-1, -1, 1, -1, -1}, //o preceeded by i (2)\\n                          {-1, -1, 1, 1, -1}}; //u preceeded by i,0 (2,3)\\n                \\n        \\n        \\n        for(int i=0; i<5; i++){\\n            digDown(i, n, prefix); // the actual solution phase...finding all the strings ending at each vowel with length \\'n\\'\\n        }\\n        \\n        int sum = 0;\\n        for(int i=0; i<5; i++){\\n            sum = (sum + dp[i][n]%mod)%mod; // calculating the answer...adding up the total strings ending at each vowel\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public void digDown(int c, int n, int[][] prefix){\\n        // here c is the index of current vowel and n is the current lenght of string into consideration\\n\\t\\t\\n        if(n == 1) return; // remember the base cases mentioned earlier!\\n        \\n        for(int i=0; i<5; i++){\\n            \\n            if(prefix[c][i] == 1){ // i.e. if the vowel \\'c\\' is preceeded by vowel \\'i\\' we proceed further\\n                \\n                if(dp[i][n-1] == 0) digDown(i, n-1, prefix); // if the value(i.e. the no. of strings) is not yet calculated for string ending at \\n                                                             // vowel i of length \\'n-1\\'...we call the recursive function to find that out\\n                \\n                dp[c][n] = (dp[c][n]%mod + dp[i][n-1]%mod)%mod; // finally adding the values from vaild predecessor vowel\\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391434,
                "title": "c-dp-easy-to-understand-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    // Mapping vowols to allowed Vowels\\n    // a -> e\\n    // e ->a,i\\n    // i !-> i\\n    // o -> i,u\\n    // u -> a\\n    \\n    int mod=1000000007;\\n     int dp[20001][26]={0};\\n    int solve(int idx,char prevchar,int n,map<char,vector<char>> &mp)\\n    {\\n        if(idx==n)return 1;\\n        if(dp[idx][prevchar-\\'a\\'])return dp[idx][prevchar-\\'a\\'];\\n         int t1=0;\\n       \\n       \\n        for(auto ch:mp[prevchar])\\n        {\\n            t1=(t1%mod+(solve(idx+1,ch,n,mp)%mod))%mod;\\n        }\\n    \\n    return dp[idx][prevchar-\\'a\\']=t1;\\n    }\\n    int countVowelPermutation(int n) {\\n        map<char,vector<char>> mp;\\n        mp[\\'a\\']={\\'e\\'};\\n        mp[\\'e\\']={\\'a\\',\\'i\\'};\\n        mp[\\'i\\']={\\'a\\',\\'e\\',\\'o\\',\\'u\\'};\\n        mp[\\'o\\']={\\'i\\',\\'u\\'};\\n        mp[\\'u\\']={\\'a\\'};\\n        mp[\\'s\\']={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n     \\n        return solve(0,\\'s\\',n,mp);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Mapping vowols to allowed Vowels\\n    // a -> e\\n    // e ->a,i\\n    // i !-> i\\n    // o -> i,u\\n    // u -> a\\n    \\n    int mod=1000000007;\\n     int dp[20001][26]={0};\\n    int solve(int idx,char prevchar,int n,map<char,vector<char>> &mp)\\n    {\\n        if(idx==n)return 1;\\n        if(dp[idx][prevchar-\\'a\\'])return dp[idx][prevchar-\\'a\\'];\\n         int t1=0;\\n       \\n       \\n        for(auto ch:mp[prevchar])\\n        {\\n            t1=(t1%mod+(solve(idx+1,ch,n,mp)%mod))%mod;\\n        }\\n    \\n    return dp[idx][prevchar-\\'a\\']=t1;\\n    }\\n    int countVowelPermutation(int n) {\\n        map<char,vector<char>> mp;\\n        mp[\\'a\\']={\\'e\\'};\\n        mp[\\'e\\']={\\'a\\',\\'i\\'};\\n        mp[\\'i\\']={\\'a\\',\\'e\\',\\'o\\',\\'u\\'};\\n        mp[\\'o\\']={\\'i\\',\\'u\\'};\\n        mp[\\'u\\']={\\'a\\'};\\n        mp[\\'s\\']={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n     \\n        return solve(0,\\'s\\',n,mp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391212,
                "title": "easy-explanation",
                "content": "We just need to construct a 2-dimensional DP matrix of n x 5. In which size 5 is used for 5 vowels like for \\'a\\' is stored at index 0, for \\'e\\' at index 1 and so on. Now, we just we our previous result to get the answer based on the given conditions in the question and also took modulas of 1e9+7 due to very large values.\\n```\\nint countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n,vector<int>(5,0));\\n        for(int i=0;i<5;i++)\\n                dp[0][i]=1;\\n        int mod=1e9+7;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<5;j++)\\n            {\\n                if(j==0)\\n                    dp[i][j]=(dp[i-1][1])%mod;\\n                else if(j==1)\\n                    dp[i][j]=(dp[i-1][0]%mod+dp[i-1][2]%mod)%mod;\\n                else if(j==2)\\n                    dp[i][j]=((dp[i-1][0]%mod+dp[i-1][1]%mod)%mod+\\n                              (dp[i-1][3]%mod+dp[i-1][4]%mod)%mod)%mod;\\n                else if(j==3)\\n                    dp[i][j]=(dp[i-1][2]%mod+dp[i-1][4]%mod)%mod;\\n                else \\n                    dp[i][j]=dp[i-1][0]%mod;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<5;i++)\\n            ans=(ans+dp[n-1][i])%mod;\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n,vector<int>(5,0));\\n        for(int i=0;i<5;i++)\\n                dp[0][i]=1;\\n        int mod=1e9+7;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<5;j++)\\n            {\\n                if(j==0)\\n                    dp[i][j]=(dp[i-1][1])%mod;\\n                else if(j==1)\\n                    dp[i][j]=(dp[i-1][0]%mod+dp[i-1][2]%mod)%mod;\\n                else if(j==2)\\n                    dp[i][j]=((dp[i-1][0]%mod+dp[i-1][1]%mod)%mod+\\n                              (dp[i-1][3]%mod+dp[i-1][4]%mod)%mod)%mod;\\n                else if(j==3)\\n                    dp[i][j]=(dp[i-1][2]%mod+dp[i-1][4]%mod)%mod;\\n                else \\n                    dp[i][j]=dp[i-1][0]%mod;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<5;i++)\\n            ans=(ans+dp[n-1][i])%mod;\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391118,
                "title": "tabulation-c",
                "content": "```\\nint countVowelPermutation(int n) {\\n        vector<vector<long long>> dp(n+1,vector<long long>(5,0));\\n        //a = 0,e = 1,i =2, o =3, u=4;\\n        int mod = (int)1e9 + 7;\\n        \\n        for(int i=0;i<5;i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n        // for(auto it:dp){\\n        //     for(auto jt:it){\\n        //         cout<<jt<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        for(int j=2;j<=n;j++){\\n            dp[j][0] = (dp[j-1][1] + dp[j-1][2] + dp[j-1][4]) % mod; //a\\n            dp[j][1] = (dp[j-1][0] + dp[j-1][2]) % mod; //e\\n            dp[j][2] = (dp[j-1][1] + dp[j-1][3]) % mod; //i\\n            dp[j][3] = dp[j-1][2] % mod; // o\\n            dp[j][4] = (dp[j-1][2] + dp[j-1][3])%mod; //u\\n        }\\n        \\n        long long sum = 0;\\n        for(int i=0;i<5;i++){\\n            sum += dp[n][i];\\n        }\\n        \\n        return sum%mod;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelPermutation(int n) {\\n        vector<vector<long long>> dp(n+1,vector<long long>(5,0));\\n        //a = 0,e = 1,i =2, o =3, u=4;\\n        int mod = (int)1e9 + 7;\\n        \\n        for(int i=0;i<5;i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n        // for(auto it:dp){\\n        //     for(auto jt:it){\\n        //         cout<<jt<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        for(int j=2;j<=n;j++){\\n            dp[j][0] = (dp[j-1][1] + dp[j-1][2] + dp[j-1][4]) % mod; //a\\n            dp[j][1] = (dp[j-1][0] + dp[j-1][2]) % mod; //e\\n            dp[j][2] = (dp[j-1][1] + dp[j-1][3]) % mod; //i\\n            dp[j][3] = dp[j-1][2] % mod; // o\\n            dp[j][4] = (dp[j-1][2] + dp[j-1][3])%mod; //u\\n        }\\n        \\n        long long sum = 0;\\n        for(int i=0;i<5;i++){\\n            sum += dp[n][i];\\n        }\\n        \\n        return sum%mod;\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2391011,
                "title": "c-dp-memorization-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countVowelPermutation(int n) {\\n        vector<vector<long long>> dp(n,vector<long long>(6,-1));\\n        return fun(dp,0,-1);\\n    }\\n    int fun(vector<vector<long long>>& dp,int i,int c)\\n    {\\n        if(i>=dp.size())\\n            return 1;\\n        \\n        if(dp[i][c+1]!=-1)\\n            return dp[i][c+1];\\n        \\n        long long t=0;\\n        if(c==-1)\\n        {\\n            for(int j=0;j<5;j++)\\n                t+=fun(dp,i+1,j)%mod;\\n        }\\n        else\\n        {\\n            vector<long long> v(5,0);\\n            v[0]=fun(dp,i+1,0)%mod;// a\\n            v[1]=fun(dp,i+1,1)%mod;// e\\n            v[2]=fun(dp,i+1,2)%mod;// i\\n            v[3]=fun(dp,i+1,3)%mod;// o\\n            v[4]=fun(dp,i+1,4)%mod;// u\\n            \\n            if(c==0)// a\\n                t=v[1]%mod; // e\\n            if(c==1)// e\\n                t=(v[0]+v[2])%mod;// a,i\\n            if(c==2)// i\\n                t=(v[0]+v[1]+v[3]+v[4])%mod;// a,e,o,u\\n            if(c==3)// 0\\n                t=(v[2]+v[4])%mod;// i,u\\n            if(c==4)// u\\n                t=v[0]%mod;// a\\n        }\\n        return dp[i][c+1]=t%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countVowelPermutation(int n) {\\n        vector<vector<long long>> dp(n,vector<long long>(6,-1));\\n        return fun(dp,0,-1);\\n    }\\n    int fun(vector<vector<long long>>& dp,int i,int c)\\n    {\\n        if(i>=dp.size())\\n            return 1;\\n        \\n        if(dp[i][c+1]!=-1)\\n            return dp[i][c+1];\\n        \\n        long long t=0;\\n        if(c==-1)\\n        {\\n            for(int j=0;j<5;j++)\\n                t+=fun(dp,i+1,j)%mod;\\n        }\\n        else\\n        {\\n            vector<long long> v(5,0);\\n            v[0]=fun(dp,i+1,0)%mod;// a\\n            v[1]=fun(dp,i+1,1)%mod;// e\\n            v[2]=fun(dp,i+1,2)%mod;// i\\n            v[3]=fun(dp,i+1,3)%mod;// o\\n            v[4]=fun(dp,i+1,4)%mod;// u\\n            \\n            if(c==0)// a\\n                t=v[1]%mod; // e\\n            if(c==1)// e\\n                t=(v[0]+v[2])%mod;// a,i\\n            if(c==2)// i\\n                t=(v[0]+v[1]+v[3]+v[4])%mod;// a,e,o,u\\n            if(c==3)// 0\\n                t=(v[2]+v[4])%mod;// i,u\\n            if(c==4)// u\\n                t=v[0]%mod;// a\\n        }\\n        return dp[i][c+1]=t%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390991,
                "title": "2-approaches-with-optimisation",
                "content": "**Solution 1:** Basic Tabulation with no optimisation -->\\n```\\nclass Solution {  // TC: O(N)  SC: O(N)\\n    private int add(int a,int b){return (int)(((long)a+b)%1000000007);}\\n    public int countVowelPermutation(int n) {\\n        int dp[][] = new int[n][5],i,j,res=0;\\n        for(j=0;j<5;j++) dp[0][j] = 1;\\n        for(i=0;i<(n-1);i++){\\n            dp[i+1][1]=add(dp[i+1][1],dp[i][0]); // for \\'a\\'\\n            \\n            dp[i+1][0]=add(dp[i+1][0],dp[i][1]); // for \\'e\\'\\n            dp[i+1][2]=add(dp[i+1][2],dp[i][1]);\\n            \\n            for(j=0;j<5;j++) if(j!=2) dp[i+1][j]=add(dp[i+1][j],dp[i][2]); // for \\'i\\'\\n            \\n            dp[i+1][2]=add(dp[i+1][2],dp[i][3]); // for \\'o\\'\\n            dp[i+1][4]=add(dp[i+1][4],dp[i][3]);\\n            \\n            dp[i+1][0]=add(dp[i+1][0],dp[i][4]); // for \\'u\\'\\n        }\\n        \\n        for(j=0;j<5;j++) res=add(res,dp[n-1][j]);\\n        \\n        return res;\\n    }\\n}\\n```\\n**Solution 2:** Space Optimised Tabulated approach -->\\n```\\nclass Solution {  // TC: O(N) SC: O(1)\\n    private int add(int a,int b){return (int)(((long)a+b)%1000000007);}\\n    public int countVowelPermutation(int n) {\\n        int dp[] = new int[5],j,res=0,a,e,i,o,u;\\n        for(j=0;j<5;j++) dp[j] = 1;\\n        for(j=0;j<(n-1);a=e=i=o=u=0,j++){             \\n            e=dp[0]; // for \\'a\\'             \\n            a=i=dp[1]; // for \\'e\\'\\n            a=add(a,dp[2]); e=add(e,dp[2]); o=dp[2]; u=dp[2]; // for \\'i\\'            \\n            i=add(i,dp[3]); u=add(u,dp[3]); // for \\'o\\'            \\n            a=add(a,dp[4]); // for \\'u\\'\\n            \\n            dp[0]=a; dp[1]=e; dp[2]=i; dp[3]=o; dp[4]=u;\\n        }\\n        \\n        for(j=0;j<5;j++) res=add(res,dp[j]);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {  // TC: O(N)  SC: O(N)\\n    private int add(int a,int b){return (int)(((long)a+b)%1000000007);}\\n    public int countVowelPermutation(int n) {\\n        int dp[][] = new int[n][5],i,j,res=0;\\n        for(j=0;j<5;j++) dp[0][j] = 1;\\n        for(i=0;i<(n-1);i++){\\n            dp[i+1][1]=add(dp[i+1][1],dp[i][0]); // for \\'a\\'\\n            \\n            dp[i+1][0]=add(dp[i+1][0],dp[i][1]); // for \\'e\\'\\n            dp[i+1][2]=add(dp[i+1][2],dp[i][1]);\\n            \\n            for(j=0;j<5;j++) if(j!=2) dp[i+1][j]=add(dp[i+1][j],dp[i][2]); // for \\'i\\'\\n            \\n            dp[i+1][2]=add(dp[i+1][2],dp[i][3]); // for \\'o\\'\\n            dp[i+1][4]=add(dp[i+1][4],dp[i][3]);\\n            \\n            dp[i+1][0]=add(dp[i+1][0],dp[i][4]); // for \\'u\\'\\n        }\\n        \\n        for(j=0;j<5;j++) res=add(res,dp[n-1][j]);\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {  // TC: O(N) SC: O(1)\\n    private int add(int a,int b){return (int)(((long)a+b)%1000000007);}\\n    public int countVowelPermutation(int n) {\\n        int dp[] = new int[5],j,res=0,a,e,i,o,u;\\n        for(j=0;j<5;j++) dp[j] = 1;\\n        for(j=0;j<(n-1);a=e=i=o=u=0,j++){             \\n            e=dp[0]; // for \\'a\\'             \\n            a=i=dp[1]; // for \\'e\\'\\n            a=add(a,dp[2]); e=add(e,dp[2]); o=dp[2]; u=dp[2]; // for \\'i\\'            \\n            i=add(i,dp[3]); u=add(u,dp[3]); // for \\'o\\'            \\n            a=add(a,dp[4]); // for \\'u\\'\\n            \\n            dp[0]=a; dp[1]=e; dp[2]=i; dp[3]=o; dp[4]=u;\\n        }\\n        \\n        for(j=0;j<5;j++) res=add(res,dp[j]);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390397,
                "title": "100-faster-dp-maths-solution-easy-understanding",
                "content": "# **100 % faster DP Maths Solution || Easy understanding**\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long a=1,b=1,c=1,d=1,e=1;\\n        long long sum=0;\\n        int mod=1000000007;\\n        for(int i=0;i<n;i++){\\n            sum=(a+b+c+d+e)%mod;\\n            \\n            long long arr[5]={a,b,c,d,e};\\n\\t\\t\\t//counting the occurances which will be ending with respective vowels\\n            a=(arr[1]+arr[2]+arr[4])%mod;\\n            b=(arr[0]+arr[2])%mod;\\n            c=(arr[1]+arr[3])%mod;\\n            d=(arr[2])%mod;\\n            e=(arr[2]+arr[3])%mod;\\n            \\n        }\\n        return sum%mod;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/7a9a071e-03d4-4253-82f7-9be15ea58353_1659843423.9459577.png)\\n\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long a=1,b=1,c=1,d=1,e=1;\\n        long long sum=0;\\n        int mod=1000000007;\\n        for(int i=0;i<n;i++){\\n            sum=(a+b+c+d+e)%mod;\\n            \\n            long long arr[5]={a,b,c,d,e};\\n\\t\\t\\t//counting the occurances which will be ending with respective vowels\\n            a=(arr[1]+arr[2]+arr[4])%mod;\\n            b=(arr[0]+arr[2])%mod;\\n            c=(arr[1]+arr[3])%mod;\\n            d=(arr[2])%mod;\\n            e=(arr[2]+arr[3])%mod;\\n            \\n        }\\n        return sum%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390340,
                "title": "java-simple-solution-using-recursion-and-memoization",
                "content": "```\\nclass Solution {\\n\\t// a=0, e=1, i=2, o=3, u=4\\n\\t// Mapping a->e \\n\\t\\t\\t   e->a,i\\n\\t\\t\\t   i->a,e,o,u\\n\\t\\t\\t   o-> i,u\\n\\t\\t\\t   u->a\\n    int[][] canGo = {{1},{0,2},{0,1,3,4},{2,4},{0}}; \\n    int MOD = 1000000007;\\n    public int helper(int n, int prev, Integer[][] dp){\\n        if(n==0)\\n            return 1;\\n        if(dp[n][prev] != null)\\n            return dp[n][prev];\\n        int sum = 0;\\n\\t\\t// From previous vowel try all possible vowels that can come next\\n        for(int i: canGo[prev]){\\n            sum = (sum%MOD +helper(n-1,i,dp)%MOD)%MOD;\\n        }\\n        return dp[n][prev] = sum;\\n    }\\n    public int countVowelPermutation(int n) {\\n        int ans = 0;\\n        Integer[][] dp = new Integer[n][5];\\n        for(int i=0;i<5;i++){ // Start with all possibilities i.e. a, e, i, o, u\\n            ans = (ans + helper(n-1,i,dp))%MOD;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\t// a=0, e=1, i=2, o=3, u=4\\n\\t// Mapping a->e \\n\\t\\t\\t   e->a,i\\n\\t\\t\\t   i->a,e,o,u\\n\\t\\t\\t   o-> i,u\\n\\t\\t\\t   u->a\\n    int[][] canGo = {{1},{0,2},{0,1,3,4},{2,4},{0}}; \\n    int MOD = 1000000007;\\n    public int helper(int n, int prev, Integer[][] dp){\\n        if(n==0)\\n            return 1;\\n        if(dp[n][prev] != null)\\n            return dp[n][prev];\\n        int sum = 0;\\n\\t\\t// From previous vowel try all possible vowels that can come next\\n        for(int i: canGo[prev]){\\n            sum = (sum%MOD +helper(n-1,i,dp)%MOD)%MOD;\\n        }\\n        return dp[n][prev] = sum;\\n    }\\n    public int countVowelPermutation(int n) {\\n        int ans = 0;\\n        Integer[][] dp = new Integer[n][5];\\n        for(int i=0;i<5;i++){ // Start with all possibilities i.e. a, e, i, o, u\\n            ans = (ans + helper(n-1,i,dp))%MOD;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390233,
                "title": "beginner-friendly-java-javascript-python-o-n-solutions",
                "content": "**Time complexity : O(n)**\\n**Java**\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        long mod = 1000000007;\\n        while(n-- > 1){\\n            long new_a = a % mod, new_e = e % mod, new_i = i % mod, new_o = o % mod, new_u = u % mod;\\n            a = new_e + new_i + new_u;\\n            e = new_a + new_i;\\n            i = new_e + new_o;\\n            o = new_i;\\n            u = new_i + new_o;\\n        }\\n        return (int)((a+e+i+o+u) % mod);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar countVowelPermutation = function(n) {\\n    let a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1000000007\\n    while(n-- > 1){\\n        let new_a = a % mod, new_e = e % mod, new_i = i % mod, new_o = o % mod, new_u = u % mod\\n        a = new_e + new_i + new_u\\n        e = new_a + new_i\\n        i = new_e + new_o\\n        o = new_i\\n        u = new_i + new_o\\n    }\\n    return (a + e + i + o + u) % mod\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def countVowelPermutation(self, n):\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a, e, i, o, u = e+i+u, a+i, e+o, i, i+o\\n        return (a+e+i+o+u) % (10**9+7)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        long mod = 1000000007;\\n        while(n-- > 1){\\n            long new_a = a % mod, new_e = e % mod, new_i = i % mod, new_o = o % mod, new_u = u % mod;\\n            a = new_e + new_i + new_u;\\n            e = new_a + new_i;\\n            i = new_e + new_o;\\n            o = new_i;\\n            u = new_i + new_o;\\n        }\\n        return (int)((a+e+i+o+u) % mod);\\n    }\\n}\\n```\n```\\nvar countVowelPermutation = function(n) {\\n    let a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1000000007\\n    while(n-- > 1){\\n        let new_a = a % mod, new_e = e % mod, new_i = i % mod, new_o = o % mod, new_u = u % mod\\n        a = new_e + new_i + new_u\\n        e = new_a + new_i\\n        i = new_e + new_o\\n        o = new_i\\n        u = new_i + new_o\\n    }\\n    return (a + e + i + o + u) % mod\\n};\\n```\n```\\nclass Solution(object):\\n    def countVowelPermutation(self, n):\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a, e, i, o, u = e+i+u, a+i, e+o, i, i+o\\n        return (a+e+i+o+u) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751484,
                "title": "beginner-friendly-dfs-with-comments-grandma-can-understand-python",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={} // Dictionary which stores memoized solution \\n        rules={} // Dictionary which stores the rules given\\n        rules[\\'\\']={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'} // if the starting string is empty, it can choose any character in the vowels set\\n        rules[\\'a\\']={\\'e\\'} // a can only be followed by e\\n        rules[\\'e\\']={\\'a\\',\\'i\\'} // e can only be followed by a and i\\n        rules[\\'i\\']={\\'a\\',\\'e\\',\\'o\\',\\'u\\'} // i cannot be followed by another i\\n        rules[\\'o\\']={\\'i\\',\\'u\\'} // o can be only followed by i and u\\n        rules[\\'u\\']={\\'a\\'} // u can only be folllowed by a\\n        def dfs(i,last):   // passes in the current index to be inserted in the string and the last character used\\n            if i==n: // if current index is equal to n, then we have constructed the string of required length n\\n                dp[(i,last)]=1 // cache the value for current index and last character \\n            elif (i,last) not in dp:  // if current index, last character key not in DP\\n                dp[(i,last)]=0 // Initialize the dp[current index, last character] to 0\\n                for c in rules[last]: // For each character in rules we iterate \\n                    dp[(i,last)]+=dfs(i+1,c)  // increment by passing the next position and character as DFS\\n            return dp[(i,last)] // return the cached solution\\n        return dfs(0,\\'\\')%((10**9)+7) // return by calling dfs for starting index 0 and empty string \"\"\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={} // Dictionary which stores memoized solution \\n        rules={} // Dictionary which stores the rules given\\n        rules[\\'\\']={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'} // if the starting string is empty, it can choose any character in the vowels set\\n        rules[\\'a\\']={\\'e\\'} // a can only be followed by e\\n        rules[\\'e\\']={\\'a\\',\\'i\\'} // e can only be followed by a and i\\n        rules[\\'i\\']={\\'a\\',\\'e\\',\\'o\\',\\'u\\'} // i cannot be followed by another i\\n        rules[\\'o\\']={\\'i\\',\\'u\\'} // o can be only followed by i and u\\n        rules[\\'u\\']={\\'a\\'} // u can only be folllowed by a\\n        def dfs(i,last):   // passes in the current index to be inserted in the string and the last character used\\n            if i==n: // if current index is equal to n, then we have constructed the string of required length n\\n                dp[(i,last)]=1 // cache the value for current index and last character \\n            elif (i,last) not in dp:  // if current index, last character key not in DP\\n                dp[(i,last)]=0 // Initialize the dp[current index, last character] to 0\\n                for c in rules[last]: // For each character in rules we iterate \\n                    dp[(i,last)]+=dfs(i+1,c)  // increment by passing the next position and character as DFS\\n            return dp[(i,last)] // return the cached solution\\n        return dfs(0,\\'\\')%((10**9)+7) // return by calling dfs for starting index 0 and empty string \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320295,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\t\\t# You can solve the problem removing the lists and just use a few variables, but for simplicity I used lists\\n\\t\\t# case where n=1\\n        a = [1]\\n        e = [1]\\n        i = [1]\\n        o = [1]\\n        u = [1]\\n        \\n        for _ in range(n-1):\\n            a.append(e[-1])\\n            e.append(a[-2] + i[-1]) # it is -2 because we appended a new number in the previous line (same thing will be with the rest)\\n            i.append(a[-2] + e[-2] + o[-1] + u[-1])\\n            o.append(i[-2] + u[-1])\\n            u.append(a[-2])\\n\\n        # get last values\\n        return (a[-1] + e[-1] + i[-1] + o[-1] + u[-1]) % (10**9+7)\\n\\t\\t\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\t\\t# You can solve the problem removing the lists and just use a few variables, but for simplicity I used lists\\n\\t\\t# case where n=1\\n        a = [1]\\n        e = [1]\\n        i = [1]\\n        o = [1]\\n        u = [1]\\n        \\n        for _ in range(n-1):\\n            a.append(e[-1])\\n            e.append(a[-2] + i[-1]) # it is -2 because we appended a new number in the previous line (same thing will be with the rest)\\n            i.append(a[-2] + e[-2] + o[-1] + u[-1])\\n            o.append(i[-2] + u[-1])\\n            u.append(a[-2])\\n\\n        # get last values\\n        return (a[-1] + e[-1] + i[-1] + o[-1] + u[-1]) % (10**9+7)\\n\\t\\t\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317522,
                "title": "c-nothing-fancy-just-10-lines-of-code",
                "content": "```\\n#define MOD 1000000007;\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        for(int it=1;it<n;it++){\\n            long long aw = a, ew = e, iw = i, ow = o, uw = u;\\n            e = (aw + iw)%MOD;\\n            a = (ew + iw + uw)%MOD;\\n            i = (ew + ow)%MOD;\\n            o = iw;\\n            u = (iw + ow)%MOD;\\n        }\\n        return (a+e+i+o+u)%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define MOD 1000000007;\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        for(int it=1;it<n;it++){\\n            long long aw = a, ew = e, iw = i, ow = o, uw = u;\\n            e = (aw + iw)%MOD;\\n            a = (ew + iw + uw)%MOD;\\n            i = (ew + ow)%MOD;\\n            o = iw;\\n            u = (iw + ow)%MOD;\\n        }\\n        return (a+e+i+o+u)%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316811,
                "title": "unordered-map-instead-of-dp-array-o-n",
                "content": "i have used two unordered maps. one for previous values and another for current values\\ncounting the occurences of a last charecter ,then adding it to corresponding character folows  \\nthat...\\n```\\nclass Solution {\\npublic:\\n     const unsigned int M = 1000000007;\\n    int countVowelPermutation(int n) {\\n        unordered_map<char,long>m;\\n        unordered_map<char,long>um;\\n        m[\\'a\\']=1;\\n        m[\\'e\\']=1;\\n        m[\\'i\\']=1;\\n        m[\\'o\\']=1;\\n        m[\\'u\\']=1;\\n        for(int i=1;i<n;i++){\\n            for(auto c:m) um[c.first]=c.second;\\n            m[\\'a\\']=(um[\\'e\\']+um[\\'u\\']+um[\\'i\\'])%M;\\n            m[\\'e\\']=(um[\\'a\\']+um[\\'i\\'])%M;\\n            m[\\'i\\']=(um[\\'e\\']+um[\\'o\\'])%M;\\n            m[\\'o\\']=(um[\\'i\\'])%M;\\n            m[\\'u\\']=(um[\\'i\\']+um[\\'o\\'])%M;\\n        }\\n        long long sum=0;\\n        for(auto c: m){\\n            sum=(sum+c.second)%M;\\n        }\\n     return sum;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     const unsigned int M = 1000000007;\\n    int countVowelPermutation(int n) {\\n        unordered_map<char,long>m;\\n        unordered_map<char,long>um;\\n        m[\\'a\\']=1;\\n        m[\\'e\\']=1;\\n        m[\\'i\\']=1;\\n        m[\\'o\\']=1;\\n        m[\\'u\\']=1;\\n        for(int i=1;i<n;i++){\\n            for(auto c:m) um[c.first]=c.second;\\n            m[\\'a\\']=(um[\\'e\\']+um[\\'u\\']+um[\\'i\\'])%M;\\n            m[\\'e\\']=(um[\\'a\\']+um[\\'i\\'])%M;\\n            m[\\'i\\']=(um[\\'e\\']+um[\\'o\\'])%M;\\n            m[\\'o\\']=(um[\\'i\\'])%M;\\n            m[\\'u\\']=(um[\\'i\\']+um[\\'o\\'])%M;\\n        }\\n        long long sum=0;\\n        for(auto c: m){\\n            sum=(sum+c.second)%M;\\n        }\\n     return sum;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316739,
                "title": "count-vowel-soltion-in-java-very-easy-to-understand",
                "content": "class Solution {\\n    int mod=1000000007;\\n\\t HashMap<Character,Integer> map=new HashMap<Character,Integer>();\\n\\t ArrayList<ArrayList<Character>> arr=new ArrayList<ArrayList<Character>>();\\n\\tpublic  int Permutation(char ch[],int n,int j,int dp[][])\\n\\t{\\n\\t\\tif(n==0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\tif(dp[n][j]>-1)\\n\\t\\t{\\n\\t\\t\\treturn dp[n][j];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint result=0;\\n\\t\\t\\tfor(int i=0;i<arr.get(j).size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult=(result%mod+(Permutation(ch,n-1,map.get(arr.get(j).get(i)),dp)%mod)%mod);\\n\\t\\t\\t}\\n\\t\\t     return dp[n][j]=result;\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\t public  int countVowelPermutation(int n)\\n\\t    {\\n\\t         map.put(\\'a\\',0);map.put(\\'e\\',1);map.put(\\'i\\',2);map.put(\\'o\\',3);map.put(\\'u\\',4);\\n\\t         int dp[][]=new int[n+1][7];\\n\\t         for(int i=0;i<n+1;i++)\\n\\t         {\\n\\t        \\t for(int j=0;j<7;j++)\\n\\t        \\t {\\n\\t        \\t\\t dp[i][j]=-1;\\n\\t        \\t }\\n\\t         }\\n\\t         for(int i=0;i<5;i++)\\n\\t         {\\n\\t        \\t arr.add(new ArrayList());\\n\\t         }\\n\\t         arr.get(0).add(\\'e\\');arr.get(1).add(\\'a\\');\\n\\t         arr.get(1).add(\\'i\\');arr.get(2).add(\\'a\\');arr.get(2).add(\\'e\\');arr.get(2).add(\\'o\\');arr.get(2).add(\\'u\\');\\n\\t         arr.get(3).add(\\'i\\');arr.get(3).add(\\'u\\');arr.get(4).add(\\'a\\');\\n\\t         char ch[]= {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n\\t         int result=0;\\n\\t         for(int i=0;i<5;i++)\\n\\t         {\\n\\t        \\t result=(result%mod+Permutation(ch,n-1,i,dp)%mod)%mod;\\n\\t        \\t \\n\\t         }\\n         System.out.println(result);\\n\\t         return result;\\n\\t    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    int mod=1000000007;\\n\\t HashMap<Character,Integer> map=new HashMap<Character,Integer>();\\n\\t ArrayList<ArrayList<Character>> arr=new ArrayList<ArrayList<Character>>();\\n\\tpublic  int Permutation(char ch[],int n,int j,int dp[][])\\n\\t{\\n\\t\\tif(n==0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1316711,
                "title": "java-o-n-and-o-log-n-with-detailed-explanation",
                "content": "**DP: Linear calculation**\\n\\nLet dp[L][a] represent the number of strings of length ```L``` ending with ```a``` (same thing goes for other characters), then as per the rules given in the problem, we have the following recurrence relations:\\n\\ndp[L+1][a] = dp[L][e] + dp[L][i] + dp[L][u]       // because ```a``` can come after ```e```, ```i``` and ```u``` only\\ndp[L+1][e] = dp[L][a] + dp[L][i]\\ndp[L+1][i] = dp[L][e] + dp[L][o]\\ndp[L+1][o] = dp[L][i]\\ndp[L+1][u] = dp[L][i] + dp[L][o]\\n\\nAs values for dp[L+1] depends only on dp[L] values, we can just maintain the last set of values instead of full dp table thereby reducing space.\\n\\n```\\n// 8 ms. 92.46%\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long A = 1, E = 1, I = 1, O = 1, U = 1, MOD = 1_000_000_007;\\n        while(--n > 0) {\\n            long a = A, e = E, i = I, o = O, u = U;\\n            A = (e + i + u) % MOD;\\n            E = (a + i) % MOD;\\n            I = (e + o) % MOD;\\n            O = i;\\n            U = (i + o) % MOD;\\n        }\\n        return (int) ((A + E + I + O + U) % MOD);\\n    }\\n}\\n```\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n**DP: Logarithmic calculation using matrix multiplication**\\n************\\nWe can speed up calculation of higher terms of linear recurrence relations using matrix multiplication. Approach goes like this:\\n\\nSay, we have a function f which is recursively defined like this:\\n\\nf(i) = c(i-1) * f(i-1) + c(i-2) * f(i-2) + ... + c(i-k) * f(i-k)\\n\\nwhere c(i-1), c(i-2) ... c(i-k) are some constant values which represent the coefficients of corresponding terms. Since f depends on last k terms, we\\'d be given its first k values (or base case), in other words, f(0), f(1), ... f(k-1) are known.\\n\\nNow, we define two matrices, F(i) and C.\\n\\nF(i) is a 1 x k matrix = [ f(i) f(i-1) ... f(i-k+1) ]\\nSimilarly, F(i-1) = [ f(i-1) f(i-2) ... f(i-k) ]\\n\\nC is a k x k matrix = [ c(i-1) 1 0 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-2) 0 1 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-3) 0 0 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;...\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-k+1) 0 0 ... 1 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-k) 0 0 ... 0 ]\\n\\nFirst column has all the coefficients. Second column has a 1 in first row, all other elements are zero. Third column has a 1 in second row, all other elements are zero. And so on for the remaining columns.\\n\\nDefining F and C this way ensures that:\\n[ f(i) f(i-1) ... f(i-k+1) ] = [ f(i-1) f(i-2) ... f(i-k) ] * [ c(i-1) 1 0 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-2) 0 1 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; [ c(i-3) 0 0 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;...\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-k+1) 0 0 ... 1 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-k) 0 0 ... 0 ]\\n\\ni.e. F(i) = F(i-1) * C\\nSo to get F(i+1),\\nF(i+1) = F(i) * C = F(i-1) * C * C = F(i-1) * C<sup>2</sup>\\nSimilarly, to get F(n),\\nF(n) = F(n-1) * C = F(n-2) * C<sup>2</sup> = ... = F(k-1) * C<sup>n-k+1</sup>\\n\\nCalculating C<sup>p</sup> takes O(log p) iterations using [exponentiation by squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring). Since all multiplications are of k x k matrices, it takes O(k<sup>3</sup>) time for each.\\n\\nSo, overall time complexity to calculate f(n) using this approach is O(k<sup>3</sup> log (n - k + 1)). Since k is generally much smaller compared to n, this is much faster than O(n).\\n\\n************\\nComing to this problem, our matrix equation looks like this:\\n\\n[ dp[L+1][a]  dp[L+1][e] dp[L+1][i] dp[L+1][o] dp[L+1] [u] ] = [ dp[L][a]  dp[L][e] dp[L][i] dp[L][o] dp[L] [u] ] * [ 0 1 0 0 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ 1 0 1 0 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ 1 1 0 1 1 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ 0 0 1 0 1 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ 1 0 0 0 0 ]\\n\\nOnce we have the correct coefficient matrix, remaining steps are identical.\\n\\n```\\n// 2 ms. 99.44%\\nclass Solution {\\n    private final int MOD = 1_000_000_007;\\n    private int[][] multiply(int[][] A, int[][] B) {\\n        int m = A.length, kk = B.length, n = B[0].length;\\n        int[][] P = new int[m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                for(int k = 0; k < kk; k++) {\\n                    P[i][j] = (int) ((P[i][j] + (long) A[i][k] * B[k][j]) % MOD);\\n                }\\n            }\\n        }\\n        return P;\\n    }\\n    private int[][] power(int[][] A, int n) {\\n        int[][] R = new int[A.length][A.length];\\n        for(int i = 0; i < R.length; i++) {\\n            R[i][i] = 1;\\n        }\\n        while(n > 0) {\\n            if((n & 1) != 0) {\\n                R = multiply(R, A);\\n            }\\n            A = multiply(A, A);\\n            n >>= 1;\\n        }\\n        return R;\\n    }\\n    public int countVowelPermutation(int n) {\\n        int[][] C = {\\n            {0, 1, 0, 0, 0},\\n            {1, 0, 1, 0, 0},\\n            {1, 1, 0, 1, 1},\\n            {0, 0, 1, 0, 1},\\n            {1, 0, 0, 0, 0}\\n        };\\n        int[] F = multiply(new int[][] { {1, 1, 1, 1, 1} }, power(C, n - 1))[0];\\n        int res = 0;\\n        for(int i = 0; i < 5; i++) {\\n            res = (res + F[i]) % MOD;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nTime complexity: O(log n)\\nSpace complexity: O(1)",
                "solutionTags": [],
                "code": "```L```\n```a```\n```a```\n```e```\n```i```\n```u```\n```\\n// 8 ms. 92.46%\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long A = 1, E = 1, I = 1, O = 1, U = 1, MOD = 1_000_000_007;\\n        while(--n > 0) {\\n            long a = A, e = E, i = I, o = O, u = U;\\n            A = (e + i + u) % MOD;\\n            E = (a + i) % MOD;\\n            I = (e + o) % MOD;\\n            O = i;\\n            U = (i + o) % MOD;\\n        }\\n        return (int) ((A + E + I + O + U) % MOD);\\n    }\\n}\\n```\n```\\n// 2 ms. 99.44%\\nclass Solution {\\n    private final int MOD = 1_000_000_007;\\n    private int[][] multiply(int[][] A, int[][] B) {\\n        int m = A.length, kk = B.length, n = B[0].length;\\n        int[][] P = new int[m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                for(int k = 0; k < kk; k++) {\\n                    P[i][j] = (int) ((P[i][j] + (long) A[i][k] * B[k][j]) % MOD);\\n                }\\n            }\\n        }\\n        return P;\\n    }\\n    private int[][] power(int[][] A, int n) {\\n        int[][] R = new int[A.length][A.length];\\n        for(int i = 0; i < R.length; i++) {\\n            R[i][i] = 1;\\n        }\\n        while(n > 0) {\\n            if((n & 1) != 0) {\\n                R = multiply(R, A);\\n            }\\n            A = multiply(A, A);\\n            n >>= 1;\\n        }\\n        return R;\\n    }\\n    public int countVowelPermutation(int n) {\\n        int[][] C = {\\n            {0, 1, 0, 0, 0},\\n            {1, 0, 1, 0, 0},\\n            {1, 1, 0, 1, 1},\\n            {0, 0, 1, 0, 1},\\n            {1, 0, 0, 0, 0}\\n        };\\n        int[] F = multiply(new int[][] { {1, 1, 1, 1, 1} }, power(C, n - 1))[0];\\n        int res = 0;\\n        for(int i = 0; i < 5; i++) {\\n            res = (res + F[i]) % MOD;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316707,
                "title": "c-8ms-6-1mb-dp-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tconst int MOD = 1e9 + 7;\\n\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\tvector<int> arr(5 ,1);\\n\\n\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\tint arr1 = arr[1];\\n\\t\\t\\t\\tint arr2 = arr[2];\\n\\t\\t\\t\\tarr[1] = (arr[0] + arr2)%MOD;\\n\\t\\t\\t\\tarr[2] = (arr1 + arr[3])%MOD;\\n\\t\\t\\t\\tarr[0] = ((arr1 + arr2)%MOD + arr[4])%MOD;\\n\\t\\t\\t\\tarr[4] = (arr2 + arr[3])%MOD;\\n\\t\\t\\t\\tarr[3] = arr2%MOD;\\n\\t\\t\\t}\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor(int i = 0;i < 5; i++){\\n\\t\\t\\t\\tsum += arr[i];\\n\\t\\t\\t\\tsum %= MOD;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tconst int MOD = 1e9 + 7;\\n\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\tvector<int> arr(5 ,1);\\n\\n\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\tint arr1 = arr[1];\\n\\t\\t\\t\\tint arr2 = arr[2];\\n\\t\\t\\t\\tarr[1] = (arr[0] + arr2)%MOD;\\n\\t\\t\\t\\tarr[2] = (arr1 + arr[3])%MOD;\\n\\t\\t\\t\\tarr[0] = ((arr1 + arr2)%MOD + arr[4])%MOD;\\n\\t\\t\\t\\tarr[4] = (arr2 + arr[3])%MOD;\\n\\t\\t\\t\\tarr[3] = arr2%MOD;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1316547,
                "title": "python-dp-recursive-o-n-matrix-multiplication-o-log-n-5-solutions-explained",
                "content": "### Approach #1 - Top-down Recursive with cache\\n* We know which characters will be follow after the `last` character, which are stored in `next_chars`\\n* In every iteration, we reduce the value of `n` and recursively compute the number of permutations for each possible `last` character.\\n* We have to cache intermediate solutions to avoid computing the same solution for a pair of `last` and `m`\\n* Complexity: \\n\\t* Time: `O(n)`\\n\\t\\t*  In every iteration, there will be at max 5 recursive calls, rest will be cached.\\n\\t\\t*  There will be `n` iterations, since we decrease it by 1 every time.\\n\\t* Space: `O(n)`\\n\\t\\t* Stack space and some constant space taken by each instance of `countPerms()`\\n\\n### Python Implementation #1A\\n* Using the rules in forward: which characters will come after the current one.\\n\\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        next_chars = {\\'a\\': \\'e\\', \\'e\\': \\'ai\\', \\'i\\': \\'aeou\\', \\'o\\': \\'iu\\', \\'u\\': \\'a\\', \\'\\': \\'aeiou\\'}\\n        @cache\\n        def countPerms(last, m):\\n            if m == 0: return 1\\n            return sum([countPerms(c, m-1) for c in next_chars[last]]) % (10**9+7)\\n        return countPerms(\\'\\', n)\\n```\\n\\n### Python Implementation #1B\\n* Using the rules in reverse: which characters came before the current one.\\n\\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        prev_chars = {\\'a\\': \\'eiu\\', \\'e\\': \\'ai\\', \\'i\\': \\'eo\\', \\'o\\': \\'i\\', \\'u\\': \\'io\\', \\'\\': \\'aeiou\\'}\\n        \\n        @cache\\n        def countPerms(last, m):\\n            if m == 0: return 1\\n            return sum([countPerms(c, m-1) for c in prev_chars[last]]) % (10**9+7)\\n            \\n        return countPerms(\\'\\', n)\\n```\\n\\n### Approach #2 - Bottom-up Dynamic Programming\\n* Similar approach as above, but this time we go bottom-up.\\n* Time complexity remains the same, `O(n)`\\n\\t*  It runs faster as it doesn\\'t need to visit call stack everytime\\n* Space complexity becomes `O(1)`\\n\\n### Python Implementation #2A\\n* Using the rules in forward: which characters will come after the current one.\\n\\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        M = 10**9+7\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a,e,i,o,u = e, a+i, a+e+o+u, i+u, a\\n            a,e,i,o,u = [x % M for x in (a,e,i,o,u)]\\n        return (a+e+i+o+u) % M\\n```\\n\\n### Python Implementation #2B\\n* Using the rules in reverse: which characters came before the current one.\\n\\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        M = 10**9+7\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a,e,i,o,u = e+i+u, a+i, e+o, i, i+o\\n            a,e,i,o,u = [x % M for x in (a,e,i,o,u)]\\n        return (a+e+i+o+u) % M\\n```\\n\\n### Approach #3 - Matrix Multiplication in O(log n) time\\n* We can represent the character followed-by relationship using a Transition Matrix `T` \\n* Identity Matrix `I` represents the case `n=1`\\n* Every time we want to add a character, as per the rules, we just need to multiply the Identity Matrix with the Transition Matrix `I X T`\\n* For a string of length `n` the answer is the sum of all the numbers in the matrix: \\n\\t`result = I x T x T x T x ... (n-1) times`\\n* This can be done in maximum `2*log(n)` steps, each involving one matrix multiplication\\n\\t* If `n` is odd: multiply `result` with `T` and reduce `n` by `1`\\n\\t* If `n` is even: multiply `T`  with itself and reduce `n` by a factor of `2`\\n\\t* `n` will eventually become `1` and populate the correct answer into `result`\\n* The matrix multiplication has to be done in `mod 10^9+7` since numbers can become large\\n* Final answer is the sum of all numbers in the `result` matrix (`mod 10^9+7`)\\n* Complexity:\\n\\t* Time: `O(log n)`  \\n\\t\\t* Every two consecutive steps in the loop will halve `n`\\n\\t\\t* Every step multiplies two 5x5 matrices in `O(1)` time\\n\\t* Space: `O(1)`\\n\\t\\t* Need to hold only two 5x5 matrices in memory and a few other variables\\n\\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        # O(log n) solution\\n        M = 10**9+7\\n\\n        def multiply(A, B):\\n            C = [[0]*5 for _ in range(5)]\\n            for i in range(5):\\n                for j in range(5):\\n                    for k in range(5):\\n                        C[i][j] = (C[i][j] + (A[i][k] * B[k][j]) % M) % M\\n            return C\\n        \\n        # Transition matrix derived from the rules\\n        T = [[0, 1, 0, 0, 0],[1, 0, 1, 0, 0],[1, 1, 0, 1, 1], [0, 0, 1, 0, 1],[1, 0, 0, 0, 0]]\\n        \\n        # Identity matrix\\n        result = [[1 if i == j else 0 for i in range(5)] for j in range(5)]\\n        n -= 1\\n        while n:\\n            if n&1: \\n                result = multiply(result, T)\\n                n -= 1\\n            else:\\n                T = multiply(T, T)\\n                n //= 2\\n                \\n        return sum([sum(row) % M for row in result]) % M\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def countVowelPermutation(self, n: int) -> int:\\n        next_chars = {\\'a\\': \\'e\\', \\'e\\': \\'ai\\', \\'i\\': \\'aeou\\', \\'o\\': \\'iu\\', \\'u\\': \\'a\\', \\'\\': \\'aeiou\\'}\\n        @cache\\n        def countPerms(last, m):\\n            if m == 0: return 1\\n            return sum([countPerms(c, m-1) for c in next_chars[last]]) % (10**9+7)\\n        return countPerms(\\'\\', n)\\n```\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        prev_chars = {\\'a\\': \\'eiu\\', \\'e\\': \\'ai\\', \\'i\\': \\'eo\\', \\'o\\': \\'i\\', \\'u\\': \\'io\\', \\'\\': \\'aeiou\\'}\\n        \\n        @cache\\n        def countPerms(last, m):\\n            if m == 0: return 1\\n            return sum([countPerms(c, m-1) for c in prev_chars[last]]) % (10**9+7)\\n            \\n        return countPerms(\\'\\', n)\\n```\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        M = 10**9+7\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a,e,i,o,u = e, a+i, a+e+o+u, i+u, a\\n            a,e,i,o,u = [x % M for x in (a,e,i,o,u)]\\n        return (a+e+i+o+u) % M\\n```\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        M = 10**9+7\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a,e,i,o,u = e+i+u, a+i, e+o, i, i+o\\n            a,e,i,o,u = [x % M for x in (a,e,i,o,u)]\\n        return (a+e+i+o+u) % M\\n```\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        # O(log n) solution\\n        M = 10**9+7\\n\\n        def multiply(A, B):\\n            C = [[0]*5 for _ in range(5)]\\n            for i in range(5):\\n                for j in range(5):\\n                    for k in range(5):\\n                        C[i][j] = (C[i][j] + (A[i][k] * B[k][j]) % M) % M\\n            return C\\n        \\n        # Transition matrix derived from the rules\\n        T = [[0, 1, 0, 0, 0],[1, 0, 1, 0, 0],[1, 1, 0, 1, 1], [0, 0, 1, 0, 1],[1, 0, 0, 0, 0]]\\n        \\n        # Identity matrix\\n        result = [[1 if i == j else 0 for i in range(5)] for j in range(5)]\\n        n -= 1\\n        while n:\\n            if n&1: \\n                result = multiply(result, T)\\n                n -= 1\\n            else:\\n                T = multiply(T, T)\\n                n //= 2\\n                \\n        return sum([sum(row) % M for row in result]) % M\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1316534,
                "title": "count-vowels-permutation-c-so-much-easy-solution",
                "content": "Look,\\nAll the strings of length n may ends with \\'a\\' / \\'e\\' / \\'i\\' / \\'o\\' / \\'u\\'. So we have to sum up all those string of length n.\\n\\nFor n=1,\\nThere are only 1 string of length 1 ends with each of the 5 vowels. So ans is 5.\\n\\nFor n>1,\\n1. If a string ends with \\'a\\', the vowel before \\'a\\' should be \\'e\\' / \\'i\\' / \\'u\\'.\\n2. If a string ends with \\'e\\', the vowel before \\'e\\' should be \\'a\\' / \\'i\\'.\\n3. If a string ends with \\'i\\', the vowel before \\'i\\' should be \\'e\\' / \\'o\\'.\\n4. If a string ends with \\'o\\', the vowel before \\'o\\' should be \\'i\\'.\\n5. If a string ends with \\'u\\', the vowel before \\'u\\' should be  \\'i\\' / \\'o\\'.\\n\\nSo,\\nThe number of string of length n ends with \\'a\\' is the sum of the number of string of length (n-1) ends with \\'e\\' and  ends with \\'i\\' and ends with \\'u\\'. Same for the other 4 vowels.\\n\\nFrom 2 to n , we have to update the number of string ends with each vowel from its previous record.\\n\\nAt last ans is the total number of string ends with each 5 vowels.\\n\\nN.B: Everytime mod each calculation with 1000000007.\\n\\n**Runtime beats : 100.00%   and Memory usage beats : 95.70%**\\n**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long j,pre_a,pre_e,pre_i,pre_o,pre_u,new_a,new_e,new_i,new_o,new_u,ans=0,m=1000000007;\\n        \\n        //for n=1\\n        new_a=new_e=new_i=new_o=new_u=1;\\n        \\n        //from 2 to n updating the string number from previous record\\n        for(j=2;j<=n;j++){\\n            //recording new to previous for next calculation\\n            pre_a=new_a, pre_e=new_e, pre_i=new_i, pre_o=new_o, pre_u=new_u;\\n            \\n            new_a=((pre_e % m) + (pre_i % m) + (pre_u % m))%m;\\n            new_e=((pre_a % m) + (pre_i % m))%m;\\n            new_i=((pre_e % m) + (pre_o % m))%m;\\n            new_o=pre_i % m;\\n            new_u=((pre_i % m) + (pre_o % m))%m;\\n        }\\n        ans=(new_a + new_e + new_i + new_o + new_u)%m;\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Time Complexity : O(n)\\nSpace Complexity :O(1)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long j,pre_a,pre_e,pre_i,pre_o,pre_u,new_a,new_e,new_i,new_o,new_u,ans=0,m=1000000007;\\n        \\n        //for n=1\\n        new_a=new_e=new_i=new_o=new_u=1;\\n        \\n        //from 2 to n updating the string number from previous record\\n        for(j=2;j<=n;j++){\\n            //recording new to previous for next calculation\\n            pre_a=new_a, pre_e=new_e, pre_i=new_i, pre_o=new_o, pre_u=new_u;\\n            \\n            new_a=((pre_e % m) + (pre_i % m) + (pre_u % m))%m;\\n            new_e=((pre_a % m) + (pre_i % m))%m;\\n            new_i=((pre_e % m) + (pre_o % m))%m;\\n            new_o=pre_i % m;\\n            new_u=((pre_i % m) + (pre_o % m))%m;\\n        }\\n        ans=(new_a + new_e + new_i + new_o + new_u)%m;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315306,
                "title": "c-really-simple-solution-explaination",
                "content": "The logic is really simple : We just need to follow the constraints. \\nLet 0 denotes \\'a\\', 1 denotes \\'e\\', 2 denotes \\'i\\', 3 denotes \\'o\\' and 4 denotes \\'u\\'. \\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\t\\tlong long int mod = pow(10, 9) + 7;\\n\\t\\t\\t\\tvector <long long int> dp1(5, 1);\\n\\t\\t\\t\\tvector <long long int> dp2(5, 1);\\n\\t\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\t\\tdp2[0] = dp1[1]; // Since a should be followed by e\\n\\t\\t\\t\\t\\tdp2[1] = (dp1[0] + dp1[2]) % mod; // e should be followed by a or i\\n\\t\\t\\t\\t\\tdp2[2] = (dp1[0] + dp1[1] + dp1[3] + dp1[4]) % mod; // i can be followed by anything except i\\n\\t\\t\\t\\t\\tdp2[3] = (dp1[2] + dp1[4]) % mod; // o should be followed by i or u\\n\\t\\t\\t\\t\\tdp2[4] = dp1[0]; // u should be followed by a\\n\\t\\t\\t\\t\\tdp1 = dp2; // copying the values for next iteration\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong long int count = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < 5; i++) // Do summation of the resultant array for all the sequences count.\\n\\t\\t\\t\\t\\tcount = (count + dp1[i]) % mod;\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\nDo upvote, if you find it useful.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\t\\tlong long int mod = pow(10, 9) + 7;\\n\\t\\t\\t\\tvector <long long int> dp1(5, 1);\\n\\t\\t\\t\\tvector <long long int> dp2(5, 1);\\n\\t\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\t\\tdp2[0] = dp1[1]; // Since a should be followed by e\\n\\t\\t\\t\\t\\tdp2[1] = (dp1[0] + dp1[2]) % mod; // e should be followed by a or i\\n\\t\\t\\t\\t\\tdp2[2] = (dp1[0] + dp1[1] + dp1[3] + dp1[4]) % mod; // i can be followed by anything except i\\n\\t\\t\\t\\t\\tdp2[3] = (dp1[2] + dp1[4]) % mod; // o should be followed by i or u\\n\\t\\t\\t\\t\\tdp2[4] = dp1[0]; // u should be followed by a\\n\\t\\t\\t\\t\\tdp1 = dp2; // copying the values for next iteration\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1315112,
                "title": "simple-solution-in-java-treating-the-conditions-as-a-directed-graph",
                "content": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        if(n == 1){\\n            return 5;\\n        }\\n        \\n        int mod = (int) (1e9 + 7);\\n    \\n        // denoting the vowels by integers:\\n        // a: 0, e: 1, i: 2, o: 3, u: 4\\n        long dp[][] = new long[n + 1][5];\\n        \\n        for(int i = 0; i < 5; i++){\\n            dp[0][i] = 0;\\n            dp[1][i] = 1;\\n        }\\n        \\n        int graph[][] = new int[][]{\\n            {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}\\n        };\\n        \\n        for(int i = 1; i < n; i++){\\n            for(int node = 0; node < 5; node++){\\n                for(int neighbor: graph[node]){\\n\\t\\t\\t\\t\\t// for length i + 1, all the permutations that satisfy the conditions can be taken, basically having a link from node to neighbor means satisfying the condition for the node \"node\"\\n                    dp[i + 1][node] += dp[i][neighbor] % mod;\\n                }\\n            }\\n        }\\n        long ans = 0;\\n        for(int i = 0; i < 5; i++){\\n            ans = (ans + dp[n][i]) % mod;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        if(n == 1){\\n            return 5;\\n        }\\n        \\n        int mod = (int) (1e9 + 7);\\n    \\n        // denoting the vowels by integers:\\n        // a: 0, e: 1, i: 2, o: 3, u: 4\\n        long dp[][] = new long[n + 1][5];\\n        \\n        for(int i = 0; i < 5; i++){\\n            dp[0][i] = 0;\\n            dp[1][i] = 1;\\n        }\\n        \\n        int graph[][] = new int[][]{\\n            {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}\\n        };\\n        \\n        for(int i = 1; i < n; i++){\\n            for(int node = 0; node < 5; node++){\\n                for(int neighbor: graph[node]){\\n\\t\\t\\t\\t\\t// for length i + 1, all the permutations that satisfy the conditions can be taken, basically having a link from node to neighbor means satisfying the condition for the node \"node\"\\n                    dp[i + 1][node] += dp[i][neighbor] % mod;\\n                }\\n            }\\n        }\\n        long ans = 0;\\n        for(int i = 0; i < 5; i++){\\n            ans = (ans + dp[n][i]) % mod;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681748,
                "title": "java-intuitive-nice-and-clean-top-down-dp-solution-recursive-memo",
                "content": "```\\nclass Solution {\\n    private final char[] vowels = new char[]{\\'#\\',\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    private final int MOD = 1_000_000_007;\\n    private int length;\\n    private int[][] memo;\\n    \\n    public int countVowelPermutation(int n) {\\n        length = n;\\n        memo = new int[n][6];\\n        for (int[] ints : memo) Arrays.fill(ints, -1);\\n        return count(0, 0);\\n    }\\n\\n    private int count(int index, int previous) {\\n        if (index == length) return 1;\\n        if (memo[index][previous] != -1) return memo[index][previous];\\n\\n        long result = 0;\\n        for (int i = 1; i < vowels.length; i++) {\\n            char vowel = vowels[i];\\n            switch (vowels[previous]) {\\n                case \\'a\\':\\n                    if (vowel == \\'e\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'e\\':\\n                    if (vowel == \\'a\\' || vowel == \\'i\\')\\n                        result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'i\\':\\n                    if (vowel != \\'i\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'o\\':\\n                    if (vowel == \\'i\\' || vowel == \\'u\\')\\n                        result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'u\\':\\n                    if (vowel == \\'a\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                default:\\n                    result = (result + count(index + 1, i)) % MOD;\\n            }\\n        }\\n\\n        memo[index][previous] = (int) result;\\n        return memo[index][previous];\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private final char[] vowels = new char[]{\\'#\\',\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    private final int MOD = 1_000_000_007;\\n    private int length;\\n    private int[][] memo;\\n    \\n    public int countVowelPermutation(int n) {\\n        length = n;\\n        memo = new int[n][6];\\n        for (int[] ints : memo) Arrays.fill(ints, -1);\\n        return count(0, 0);\\n    }\\n\\n    private int count(int index, int previous) {\\n        if (index == length) return 1;\\n        if (memo[index][previous] != -1) return memo[index][previous];\\n\\n        long result = 0;\\n        for (int i = 1; i < vowels.length; i++) {\\n            char vowel = vowels[i];\\n            switch (vowels[previous]) {\\n                case \\'a\\':\\n                    if (vowel == \\'e\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'e\\':\\n                    if (vowel == \\'a\\' || vowel == \\'i\\')\\n                        result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'i\\':\\n                    if (vowel != \\'i\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'o\\':\\n                    if (vowel == \\'i\\' || vowel == \\'u\\')\\n                        result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'u\\':\\n                    if (vowel == \\'a\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                default:\\n                    result = (result + count(index + 1, i)) % MOD;\\n            }\\n        }\\n\\n        memo[index][previous] = (int) result;\\n        return memo[index][previous];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556830,
                "title": "python-easy-peasy-top-down-dp-recursion-memoization",
                "content": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n        m = (10**9+7)\\n        from functools import lru_cache\\n        \\n        @lru_cache(None)\\n        def helper(last, n):\\n            if n==1:\\n                if last==None:\\n                    return 5\\n                else:\\n                    if last==\\'a\\':\\n                        return 1\\n                    if last==\\'e\\':\\n                        return 2\\n                    if last==\\'i\\':\\n                        return 4\\n                    if last==\\'o\\':\\n                        return 2\\n                    if last==\\'u\\':\\n                        return 1\\n                \\n            ans  = 0\\n            if last==None:\\n                ans += helper(\\'a\\', n-1)+helper(\\'e\\', n-1)+helper(\\'i\\', n-1)+helper(\\'o\\', n-1)+helper(\\'u\\', n-1)\\n                ans %= m\\n            else:\\n                if last == \\'a\\':\\n                    ans += helper(\\'e\\', n-1)\\n                    ans %= m\\n                if last == \\'e\\':\\n                    ans += helper(\\'a\\', n-1)+helper(\\'i\\', n-1)\\n                    ans %= m\\n                if last == \\'i\\':\\n                    ans += helper(\\'a\\', n-1)+helper(\\'e\\', n-1)+helper(\\'o\\', n-1)+helper(\\'u\\', n-1)\\n                    ans %= m\\n                if last == \\'o\\':\\n                    ans += helper(\\'i\\', n-1)+helper(\\'u\\', n-1)\\n                    ans %= m\\n                if last == \\'u\\':\\n                    ans += helper(\\'a\\', n-1)\\n                    ans %= m\\n                    \\n            return ans    \\n            \\n        return helper(None, n)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n        m = (10**9+7)\\n        from functools import lru_cache\\n        \\n        @lru_cache(None)\\n        def helper(last, n):\\n            if n==1:\\n                if last==None:\\n                    return 5\\n                else:\\n                    if last==\\'a\\':\\n                        return 1\\n                    if last==\\'e\\':\\n                        return 2\\n                    if last==\\'i\\':\\n                        return 4\\n                    if last==\\'o\\':\\n                        return 2\\n                    if last==\\'u\\':\\n                        return 1\\n                \\n            ans  = 0\\n            if last==None:\\n                ans += helper(\\'a\\', n-1)+helper(\\'e\\', n-1)+helper(\\'i\\', n-1)+helper(\\'o\\', n-1)+helper(\\'u\\', n-1)\\n                ans %= m\\n            else:\\n                if last == \\'a\\':\\n                    ans += helper(\\'e\\', n-1)\\n                    ans %= m\\n                if last == \\'e\\':\\n                    ans += helper(\\'a\\', n-1)+helper(\\'i\\', n-1)\\n                    ans %= m\\n                if last == \\'i\\':\\n                    ans += helper(\\'a\\', n-1)+helper(\\'e\\', n-1)+helper(\\'o\\', n-1)+helper(\\'u\\', n-1)\\n                    ans %= m\\n                if last == \\'o\\':\\n                    ans += helper(\\'i\\', n-1)+helper(\\'u\\', n-1)\\n                    ans %= m\\n                if last == \\'u\\':\\n                    ans += helper(\\'a\\', n-1)\\n                    ans %= m\\n                    \\n            return ans    \\n            \\n        return helper(None, n)",
                "codeTag": "Python3"
            },
            {
                "id": 438467,
                "title": "c-o-logn-matrix-multiplication-0ms-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<long long> a = {0,1,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0};\\n        a = matpow(a, n-1);\\n        long long sum = 0;\\n        for (auto& x : a) {\\n            sum += x;\\n        }\\n        return sum % mod;\\n    }\\nprivate:\\n    const int mod = (int)(7 + 1e9);\\n    vector<long long> matmul(const vector<long long>& m1, const vector<long long>& m2) {\\n        vector<long long> res(25, 0);\\n        for (int i = 0; i < 5; ++i) {\\n            for (int j = 0; j < 5; ++j) {\\n                for (int k = 0; k < 5; ++k) {\\n                    res[i*5+j] += m1[i*5+k]*m2[k*5+j]; \\n                }\\n                res[i*5+j] %= mod;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<long long> matpow(const vector<long long>& m, int n) {\\n        if (n == 0) {\\n            return {1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1};\\n        }\\n        else if (n == 1) {\\n            return m;\\n        }\\n        else {\\n            int i = n/2;\\n            vector<long long> mt = matpow(m, i);\\n            mt = matmul(mt, mt);\\n            if (n%2 == 1) {\\n                mt = matmul(mt, m);\\n            }\\n            return mt;            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<long long> a = {0,1,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0};\\n        a = matpow(a, n-1);\\n        long long sum = 0;\\n        for (auto& x : a) {\\n            sum += x;\\n        }\\n        return sum % mod;\\n    }\\nprivate:\\n    const int mod = (int)(7 + 1e9);\\n    vector<long long> matmul(const vector<long long>& m1, const vector<long long>& m2) {\\n        vector<long long> res(25, 0);\\n        for (int i = 0; i < 5; ++i) {\\n            for (int j = 0; j < 5; ++j) {\\n                for (int k = 0; k < 5; ++k) {\\n                    res[i*5+j] += m1[i*5+k]*m2[k*5+j]; \\n                }\\n                res[i*5+j] %= mod;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<long long> matpow(const vector<long long>& m, int n) {\\n        if (n == 0) {\\n            return {1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1};\\n        }\\n        else if (n == 1) {\\n            return m;\\n        }\\n        else {\\n            int i = n/2;\\n            vector<long long> mt = matpow(m, i);\\n            mt = matmul(mt, mt);\\n            if (n%2 == 1) {\\n                mt = matmul(mt, m);\\n            }\\n            return mt;            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399989,
                "title": "js-dp-o-n-very-readable-and-concise-o-1-space-solution-thought-process",
                "content": "**Thought process**\\nFirst lay out the tranformation clearly\\n * a > ae\\n * e > ea, ei\\n * i > ia, ie, io, iu\\n * o > oi, ou\\n * u > ua\\n\\nWe can see that in order to compute `i`th result, we need to look at `i-1`th result, which is a clear sign for DP. But how do we do DP for this question? \\n\\nIt seems like only the last alphabet is really important, we don\\'t care about the anything before it. To help save space, we can just store the results in an array representing count of last alphabet `[# of a, # of e, # of i, # of o, # of u]`. \\n\\nTo verify this works, we manually compute the 3rd and 4th result and yes indeed it is correct:\\n * a : 1 > 3 > 6 > 11\\n * e : 1 > 2 > 5 > 9\\n * i : 1 > 2 > 4 > 7\\n * o : 1 > 1 > 2 > 3\\n * u : 1 > 2 > 2 > 5\\n \\n Totals: 5 > 10 > 19 > 35\\n\\n**Code**\\n```\\nvar countVowelPermutation = function(n) {\\n  if(n == 1) return 5;\\n  if(n == 2) return 10;\\n  \\n  let res = [3,2,2,1,2]; // start with 2nd result array, since it\\'s already given in problem statement\\n  let mod = 1e9 + 7;\\n  for(let i=3;i<=n;i++){ \\n    res = [\\n      (res[1]+res[2]+res[4]) % mod, //a\\n      (res[0]+res[2]) % mod, //e\\n      (res[1]+res[3]) % mod, //i\\n      (res[2]) % mod, //o\\n      (res[2]+res[3]) % mod //u\\n    ];\\n  }\\n  \\n  return (res[0] + res[1] + res[2] + res[3] + res[4]) % mod;\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nvar countVowelPermutation = function(n) {\\n  if(n == 1) return 5;\\n  if(n == 2) return 10;\\n  \\n  let res = [3,2,2,1,2]; // start with 2nd result array, since it\\'s already given in problem statement\\n  let mod = 1e9 + 7;\\n  for(let i=3;i<=n;i++){ \\n    res = [\\n      (res[1]+res[2]+res[4]) % mod, //a\\n      (res[0]+res[2]) % mod, //e\\n      (res[1]+res[3]) % mod, //i\\n      (res[2]) % mod, //o\\n      (res[2]+res[3]) % mod //u\\n    ];\\n  }\\n  \\n  return (res[0] + res[1] + res[2] + res[3] + res[4]) % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399378,
                "title": "ultrafast-solution-explicit-mathematical-expression",
                "content": "Since the DP equation can be expressed as matrix multiplication, we can solve its eigensystem and get straightforward explicit expression of the answer.\\n```class Solution(object):\\n    def fastpow(self,x,n):\\n        if n==1:return x\\n        elif n&1:return (x*self.fastpow(x,n//2)**2)%1000000007\\n        else:return (self.fastpow(x,n//2)**2)%1000000007\\n    def countVowelPermutation(self, n):\\n        return (62759413*self.fastpow(44051588,n) + 784439686*self.fastpow(419376480,n) + 638771916*self.fastpow(653592850,n) + 514029000*self.fastpow(882979097,n))%1000000007\\n\\t\\t",
                "solutionTags": [],
                "code": "Since the DP equation can be expressed as matrix multiplication, we can solve its eigensystem and get straightforward explicit expression of the answer.\\n```class Solution(object):\\n    def fastpow(self,x,n):\\n        if n==1:return x\\n        elif n&1:return (x*self.fastpow(x,n//2)**2)%1000000007\\n        else:return (self.fastpow(x,n//2)**2)%1000000007\\n    def countVowelPermutation(self, n):\\n        return (62759413*self.fastpow(44051588,n) + 784439686*self.fastpow(419376480,n) + 638771916*self.fastpow(653592850,n) + 514029000*self.fastpow(882979097,n))%1000000007\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 398753,
                "title": "c-java-bottom-up-dp-solution-o-n-10ms-clean-vs-explain-easy-understand",
                "content": "**Intuition**\\nWe have the following statements:\\n* Each character is a lower case vowel (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n* Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n* Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n* Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n* Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n* Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n\\nLet  \\n```java\\n0 -> a, 1 -> e, 2 -> i, 3 -> o, 4 -> u\\n```\\nWe have the following graph relationship:\\n```java\\n0 -> {1}\\n1 -> {0,2}\\n2 -> {0,1,3,4}\\n3 -> {2,4}\\n4 -> {0}\\n```\\n\\nLet `dp[n][char]` denotes the number of strings of length n starting at `char`. \\nHence, `dp[n+1][u]` = sum of all `dp[n][v]` such that there is a directed connection from u to v (u -> v).\\n\\n**Java**\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        int MOD = (int) (1e9 + 7);\\n        long[][] dp = new long[n + 1][5]; // dp[n][i] is the number of strings of length n starting at char i\\n        for (int i = 0; i < 5; i++)\\n            dp[1][i] = 1; // there are only 1 string of length 1 that start with char i\\n\\n        int[][] relation = new int[][]{{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        for (int i = 1; i < n; i++) { // O(N) -> This is complexity of this solution\\n            for (int u = 0; u < 5; u++) { // This block of code cost O(1) in Time\\n                dp[i + 1][u] = 0;\\n                for (int v : relation[u]) {\\n                    dp[i + 1][u] += dp[i][v] % MOD;\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < 5; i++)\\n            ans = (ans + dp[n][i]) % MOD;\\n        return (int) ans;\\n    }\\n}\\n```\\n\\n**C++**\\n```C++\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        int MOD = 1e9 + 7;\\n        vector<vector<ll>> dp = vector(n+1, vector<ll>(5)); // dp[n][i] is the number of strings of length n starting at char i\\n        for (int i = 0; i < 5; i++)\\n            dp[1][i] = 1; // there are only 1 string of length n that start with char i\\n\\n        vector<vector<ll>> relation = {{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        for (int i = 1; i < n; i++) { // O(N) -> This is complexity of this solution\\n            for (int u = 0; u < 5; u++) { // This block of code cost O(1) in Time\\n                dp[i + 1][u] = 0;\\n                for (int v : relation[u]) {\\n                    dp[i + 1][u] += dp[i][v] % MOD;\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < 5; i++)\\n            ans = (ans + dp[n][i]) % MOD;\\n        return (int) ans;\\n    }\\n};\\n```\\n**Complexity**\\n- Time: O(N)\\n- Space: O(N)",
                "solutionTags": [],
                "code": "```java\\n0 -> a, 1 -> e, 2 -> i, 3 -> o, 4 -> u\\n```\n```java\\n0 -> {1}\\n1 -> {0,2}\\n2 -> {0,1,3,4}\\n3 -> {2,4}\\n4 -> {0}\\n```\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        int MOD = (int) (1e9 + 7);\\n        long[][] dp = new long[n + 1][5]; // dp[n][i] is the number of strings of length n starting at char i\\n        for (int i = 0; i < 5; i++)\\n            dp[1][i] = 1; // there are only 1 string of length 1 that start with char i\\n\\n        int[][] relation = new int[][]{{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        for (int i = 1; i < n; i++) { // O(N) -> This is complexity of this solution\\n            for (int u = 0; u < 5; u++) { // This block of code cost O(1) in Time\\n                dp[i + 1][u] = 0;\\n                for (int v : relation[u]) {\\n                    dp[i + 1][u] += dp[i][v] % MOD;\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < 5; i++)\\n            ans = (ans + dp[n][i]) % MOD;\\n        return (int) ans;\\n    }\\n}\\n```\n```C++\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        int MOD = 1e9 + 7;\\n        vector<vector<ll>> dp = vector(n+1, vector<ll>(5)); // dp[n][i] is the number of strings of length n starting at char i\\n        for (int i = 0; i < 5; i++)\\n            dp[1][i] = 1; // there are only 1 string of length n that start with char i\\n\\n        vector<vector<ll>> relation = {{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        for (int i = 1; i < n; i++) { // O(N) -> This is complexity of this solution\\n            for (int u = 0; u < 5; u++) { // This block of code cost O(1) in Time\\n                dp[i + 1][u] = 0;\\n                for (int v : relation[u]) {\\n                    dp[i + 1][u] += dp[i][v] % MOD;\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < 5; i++)\\n            ans = (ans + dp[n][i]) % MOD;\\n        return (int) ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398241,
                "title": "solution-in-python-3-dp-three-lines-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        C, m = [1]*5, 10**9 + 7\\n        for i in range(n-1): C = [(C[1]+C[2]+C[4]) % m, (C[0]+C[2]) % m, (C[1]+C[3]) % m, C[2] % m, (C[2]+C[3]) % m]\\n        return sum(C) % m\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        C, m = [1]*5, 10**9 + 7\\n        for i in range(n-1): C = [(C[1]+C[2]+C[4]) % m, (C[0]+C[2]) % m, (C[1]+C[3]) % m, C[2] % m, (C[2]+C[3]) % m]\\n        return sum(C) % m\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 398218,
                "title": "java-top-down-dp",
                "content": "```\\nclass Solution {\\n    char[] cc = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    int MOD = 1_000_000_007;\\n    public int countVowelPermutation(int n) {\\n        long res = 0;\\n        Map<String, Long> memo = new HashMap<>();\\n        for (int i = 0; i < 5; i++) {\\n            res = (res + helper(1, cc[i], n, memo)) % MOD;\\n        }\\n        return (int) res;\\n    }\\n    long helper(int index, char c, int n, Map<String, Long> memo) {\\n        if (index == n) {\\n            return 1;\\n        }\\n        String str = index + \" \" + c;\\n        if (memo.containsKey(str)) {\\n            return memo.get(str);\\n        }\\n        long res = 0;\\n        if (c == \\'a\\') {\\n            res = helper(index + 1, \\'e\\', n, memo);\\n        }\\n        if (c == \\'e\\') {\\n            res = (res + helper(index + 1, \\'a\\', n, memo)) % MOD;\\n            res = (res + helper(index + 1, \\'i\\', n, memo)) % MOD;\\n        }\\n        if (c == \\'i\\') {\\n            for (int i = 0; i < 5; i++) {\\n                if (cc[i] != \\'i\\') {\\n                    res = (res + helper(index + 1, cc[i], n, memo)) % MOD;\\n                }\\n            }\\n        }\\n        if (c == \\'o\\') {\\n            res = (res + helper(index + 1, \\'u\\', n, memo)) % MOD;\\n            res = (res + helper(index + 1, \\'i\\', n, memo)) % MOD;\\n        }\\n        if (c == \\'u\\') {\\n            res = (res + helper(index + 1, \\'a\\', n, memo)) % MOD;\\n        }\\n        memo.put(str, res);\\n        return memo.get(str);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[] cc = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    int MOD = 1_000_000_007;\\n    public int countVowelPermutation(int n) {\\n        long res = 0;\\n        Map<String, Long> memo = new HashMap<>();\\n        for (int i = 0; i < 5; i++) {\\n            res = (res + helper(1, cc[i], n, memo)) % MOD;\\n        }\\n        return (int) res;\\n    }\\n    long helper(int index, char c, int n, Map<String, Long> memo) {\\n        if (index == n) {\\n            return 1;\\n        }\\n        String str = index + \" \" + c;\\n        if (memo.containsKey(str)) {\\n            return memo.get(str);\\n        }\\n        long res = 0;\\n        if (c == \\'a\\') {\\n            res = helper(index + 1, \\'e\\', n, memo);\\n        }\\n        if (c == \\'e\\') {\\n            res = (res + helper(index + 1, \\'a\\', n, memo)) % MOD;\\n            res = (res + helper(index + 1, \\'i\\', n, memo)) % MOD;\\n        }\\n        if (c == \\'i\\') {\\n            for (int i = 0; i < 5; i++) {\\n                if (cc[i] != \\'i\\') {\\n                    res = (res + helper(index + 1, cc[i], n, memo)) % MOD;\\n                }\\n            }\\n        }\\n        if (c == \\'o\\') {\\n            res = (res + helper(index + 1, \\'u\\', n, memo)) % MOD;\\n            res = (res + helper(index + 1, \\'i\\', n, memo)) % MOD;\\n        }\\n        if (c == \\'u\\') {\\n            res = (res + helper(index + 1, \\'a\\', n, memo)) % MOD;\\n        }\\n        memo.put(str, res);\\n        return memo.get(str);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398179,
                "title": "simple-python-o-n-time-and-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp = [1 for _ in range(5)]\\n        for j in range(1,n):\\n            temp = [0 for _ in range(5)]\\n            temp[0] = dp[1]\\n            temp[1] = dp[0] + dp[2]\\n            for i in [0,1,3,4]:\\n                temp[2] += dp[i]\\n            temp[3] = dp[2] + dp[4]\\n            temp[4] = dp[0]\\n            dp = temp\\n        return sum(dp) % (10 ** 9 + 7)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp = [1 for _ in range(5)]\\n        for j in range(1,n):\\n            temp = [0 for _ in range(5)]\\n            temp[0] = dp[1]\\n            temp[1] = dp[0] + dp[2]\\n            for i in [0,1,3,4]:\\n                temp[2] += dp[i]\\n            temp[3] = dp[2] + dp[4]\\n            temp[4] = dp[0]\\n            dp = temp\\n        return sum(dp) % (10 ** 9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 3704454,
                "title": "simple-and-easy-to-understand-java-solution-using-recursion",
                "content": "# Intuition\\nThe problem states to count all the permutations possible of a given length of the vowels so we have to find all possible permuatations therefore we go with recursion. \\n\\n# Approach\\nLabel vowels with indices, 0 -> a, 1 -> b & so on.\\nJust keep track of the last used vowel using a last parameter and do what is told in the question. At the starting we know that last used is nothing so we specify \\'5\\' as the last used parameter. When the index reaches the desired length we return 1.  \\nWe know that there are over lapping sub problems therefore we memoize the solution. \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=1000000007;\\n    private long solve(int index, int n, int last, long[][] dp){\\n        if(index==n)\\n            return 1;\\n        if(last == 0){\\n            return dp[index][0] = solve(index+1,n,1,dp)%mod;\\n        }\\n        if(dp[index][last]!=-1){\\n            return dp[index][last];\\n        }\\n        if(last==1){\\n            return dp[index][1] = (solve(index+1,n,0,dp)+solve(index+1,n,2,dp))%mod;\\n        }\\n        if(last == 2){\\n            return dp[index][2] = (solve(index+1,n,0,dp)+solve(index+1,n,1,dp)+solve(index+1,n,3,dp)+solve(index+1,n,4,dp))%mod;\\n        }\\n        if(last == 3){\\n            return dp[index][3] = (solve(index+1,n,2,dp)+solve(index+1,n,4,dp))%mod;\\n        }\\n        if(last == 4){\\n            return dp[index][4] = solve(index+1,n,0,dp)%mod;\\n        }\\n        else{\\n            return solve(index+1,n,0,dp)+solve(index+1,n,1,dp)+solve(index+1,n,2,dp)+solve(index+1,n,3,dp)+solve(index+1,n,4,dp);\\n        }\\n    }\\n    public int countVowelPermutation(int n) {\\n        long[][] dp = new long[n][6];\\n        for(long[] arr: dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        long ans = solve(0,n,5,dp)%mod;\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    private long solve(int index, int n, int last, long[][] dp){\\n        if(index==n)\\n            return 1;\\n        if(last == 0){\\n            return dp[index][0] = solve(index+1,n,1,dp)%mod;\\n        }\\n        if(dp[index][last]!=-1){\\n            return dp[index][last];\\n        }\\n        if(last==1){\\n            return dp[index][1] = (solve(index+1,n,0,dp)+solve(index+1,n,2,dp))%mod;\\n        }\\n        if(last == 2){\\n            return dp[index][2] = (solve(index+1,n,0,dp)+solve(index+1,n,1,dp)+solve(index+1,n,3,dp)+solve(index+1,n,4,dp))%mod;\\n        }\\n        if(last == 3){\\n            return dp[index][3] = (solve(index+1,n,2,dp)+solve(index+1,n,4,dp))%mod;\\n        }\\n        if(last == 4){\\n            return dp[index][4] = solve(index+1,n,0,dp)%mod;\\n        }\\n        else{\\n            return solve(index+1,n,0,dp)+solve(index+1,n,1,dp)+solve(index+1,n,2,dp)+solve(index+1,n,3,dp)+solve(index+1,n,4,dp);\\n        }\\n    }\\n    public int countVowelPermutation(int n) {\\n        long[][] dp = new long[n][6];\\n        for(long[] arr: dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        long ans = solve(0,n,5,dp)%mod;\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878417,
                "title": "c-most-simple-dp-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time com, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<long long> dp(5,1);\\n\\n        long long a,b,c,d,e;\\n        for(int i=1;i<n;i++){\\n            a=dp[0];\\n            b=dp[1];\\n            c=dp[2];\\n            d=dp[3];\\n            e=dp[4];\\n\\n            dp[0]=(b+c+e)%1000000007;\\n            dp[1]=(a+c)%1000000007;\\n            dp[2]=(b+d)%1000000007;\\n            dp[3]=c%1000000007;\\n            dp[4]=(c+d)%1000000007;\\n\\n        }\\n        return (dp[0]+dp[1]+dp[2]+dp[3]+dp[4])%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<long long> dp(5,1);\\n\\n        long long a,b,c,d,e;\\n        for(int i=1;i<n;i++){\\n            a=dp[0];\\n            b=dp[1];\\n            c=dp[2];\\n            d=dp[3];\\n            e=dp[4];\\n\\n            dp[0]=(b+c+e)%1000000007;\\n            dp[1]=(a+c)%1000000007;\\n            dp[2]=(b+d)%1000000007;\\n            dp[3]=c%1000000007;\\n            dp[4]=(c+d)%1000000007;\\n\\n        }\\n        return (dp[0]+dp[1]+dp[2]+dp[3]+dp[4])%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608692,
                "title": "java-solution-with-detailed-explanation",
                "content": "\\n```\\n/*approach:\\n    Each character is a lower case vowel (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n    Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n    Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n    Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n    Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n    Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n    \\n        // vowel & index mapping\\n        // a: 0\\n        // e: 1\\n        // i: 2\\n        // o: 3\\n        // u: 4\\n        \\n        intially for n=1 all values can be used 1 time so dp[i][i] =1 for all vowels\\n\\n     Here we can see:-\\n        // Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n        // Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n        // Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n        // Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n        // Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n        // === In other words: \\n        // \\'a\\' can be followed by {\\'e\\'}\\n        // \\'e\\' can be followed by {\\'a\\', \\'i\\'}\\n        // \\'i\\' can be followed by {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}\\n        // \\'o\\' can be followed by {\\'i\\', \\'u\\'}\\n        // \\'u\\' can be followed by {\\'a\\'}\\n        // === In other words:\\n        // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n        // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n        // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n        // \\'o\\' can follow {\\'i\\'}\\n        // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n*/\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n       int mod=1000_000_007;  \\n       long [][]dp =new long[n+1][5];\\n       for(int i=0;i<5;i++) dp[1][i]=1;\\n    \\n        for(int i=2;i<=n;i++){\\n            dp[i][0]=(dp[i-1][1]+dp[i-1][2]+dp[i-1][4])%mod;\\n             dp[i][1]=(dp[i-1][0]+dp[i-1][2])%mod;\\n             dp[i][2]=(dp[i-1][1]+dp[i-1][3])%mod;\\n             dp[i][3]=(dp[i-1][2])%mod;\\n             dp[i][4]=(dp[i-1][2]+dp[i-1][3])%mod;\\n        }\\n        long sum=0;\\n        for(long d:dp[n]){\\n            sum+=d;\\n            sum%=mod;\\n        }\\n       return (int)sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/*approach:\\n    Each character is a lower case vowel (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n    Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n    Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n    Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n    Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n    Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n    \\n        // vowel & index mapping\\n        // a: 0\\n        // e: 1\\n        // i: 2\\n        // o: 3\\n        // u: 4\\n        \\n        intially for n=1 all values can be used 1 time so dp[i][i] =1 for all vowels\\n\\n     Here we can see:-\\n        // Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n        // Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n        // Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n        // Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n        // Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n        // === In other words: \\n        // \\'a\\' can be followed by {\\'e\\'}\\n        // \\'e\\' can be followed by {\\'a\\', \\'i\\'}\\n        // \\'i\\' can be followed by {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}\\n        // \\'o\\' can be followed by {\\'i\\', \\'u\\'}\\n        // \\'u\\' can be followed by {\\'a\\'}\\n        // === In other words:\\n        // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n        // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n        // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n        // \\'o\\' can follow {\\'i\\'}\\n        // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n*/\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n       int mod=1000_000_007;  \\n       long [][]dp =new long[n+1][5];\\n       for(int i=0;i<5;i++) dp[1][i]=1;\\n    \\n        for(int i=2;i<=n;i++){\\n            dp[i][0]=(dp[i-1][1]+dp[i-1][2]+dp[i-1][4])%mod;\\n             dp[i][1]=(dp[i-1][0]+dp[i-1][2])%mod;\\n             dp[i][2]=(dp[i-1][1]+dp[i-1][3])%mod;\\n             dp[i][3]=(dp[i-1][2])%mod;\\n             dp[i][4]=(dp[i-1][2]+dp[i-1][3])%mod;\\n        }\\n        long sum=0;\\n        for(long d:dp[n]){\\n            sum+=d;\\n            sum%=mod;\\n        }\\n       return (int)sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485411,
                "title": "simple-solution-python",
                "content": "Simple Solution:\\n```\\ndef countVowelPermutation(self, n: int) -> int:\\n        a,e,i,o,u = 1,1,1,1,1\\n        for _ in range(1,n):\\n            a,e,i,o,u = (e+i+u), (a+i), (e+o), (i), (i+o)    \\n        return sum([a,e,i,o,u])%(10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n        a,e,i,o,u = 1,1,1,1,1\\n        for _ in range(1,n):\\n            a,e,i,o,u = (e+i+u), (a+i), (e+o), (i), (i+o)    \\n        return sum([a,e,i,o,u])%(10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2444990,
                "title": "no-brainer-dp-inspired-by-leetcode-1641-count-sorted-vowel-strings",
                "content": "Inspired by a solution for count sorted vowel strings https://leetcode.com/problems/count-sorted-vowel-strings/discuss/918507/Java-DP-O(n)-time-Easy-to-understand\\n\\n```\\ndef countVowelPermutation(self, n: int) -> int:\\n\\ta,e,i,o,u = 1,1,1,1,1\\n\\twhile n>1:\\n\\t\\ta, e, i, o, u = e, a + i, a + e + o + u, i + u, a\\n\\t\\tn-=1\\n\\treturn (a+e+i+o+u) % (10**9+7)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n\\ta,e,i,o,u = 1,1,1,1,1\\n\\twhile n>1:\\n\\t\\ta, e, i, o, u = e, a + i, a + e + o + u, i + u, a\\n\\t\\tn-=1\\n\\treturn (a+e+i+o+u) % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2417023,
                "title": "simple-c-o-n-time-o-n-space",
                "content": "When size is 1 there is only possiblity for each char, when more that one it depends on given condition.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long t[n][5], mod=1e9+7;\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<5; j++) {\\n                if (i==0)\\n                    t[i][j]=1;\\n                else if (j==0) // a\\n                    t[i][j]=t[i-1][1]; // e\\n                else if (j==1) // e\\n                    t[i][j]=(t[i-1][0]+t[i-1][2])%mod; // a,i\\n                else if (j==2) // i\\n                    t[i][j]=(t[i-1][0]+t[i-1][1]+t[i-1][3]+t[i-1][4])%mod; // a,e,o,u\\n                else if (j==3) // o\\n                    t[i][j]=(t[i-1][2]+t[i-1][4])%mod; // i,u\\n                else // u\\n                    t[i][j]=t[i-1][0]; // a\\n            }\\n        }\\n        return accumulate(t[n-1], t[n-1]+5, 0ll) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long t[n][5], mod=1e9+7;\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<5; j++) {\\n                if (i==0)\\n                    t[i][j]=1;\\n                else if (j==0) // a\\n                    t[i][j]=t[i-1][1]; // e\\n                else if (j==1) // e\\n                    t[i][j]=(t[i-1][0]+t[i-1][2])%mod; // a,i\\n                else if (j==2) // i\\n                    t[i][j]=(t[i-1][0]+t[i-1][1]+t[i-1][3]+t[i-1][4])%mod; // a,e,o,u\\n                else if (j==3) // o\\n                    t[i][j]=(t[i-1][2]+t[i-1][4])%mod; // i,u\\n                else // u\\n                    t[i][j]=t[i-1][0]; // a\\n            }\\n        }\\n        return accumulate(t[n-1], t[n-1]+5, 0ll) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401006,
                "title": "c-dp-easy-understanding-intuitions-explained",
                "content": "```\\n ll mod=1e9+7;\\n    \\n    // Intuitions -> as the instructions given in the qquestion \\n    \\n    // we will modify it slightly \\n    \\n    // _ a -> then _ will have {e , i , u}\\n    \\n    // _ e -> then _ will have {a , i }\\n    \\n    // _ i -> then _ will have {o , e }\\n    \\n    // _ o -> then _ will have {  i  }\\n    \\n    // _ u -> then _ will have { o , i }\\n    \\n    // so now we will start forming the decision tree \\n    \\n    //  a , e , i , o , u \\n    \\n    // now for next char having as ith index has \\'a\\' as current char -> \\n    \\n    // this value is equal to i-th index having ( e , i , u ) as i-1th character \\n    \\n    //i.e dp[i][\\'a\\']=dp[i-1][\\'e\\'] + dp[i-1][\\'i\\'] + dp[i-1][\\'u\\']\\n    // dp[i][\\'e\\']=dp[i-1][\\'a\\'] + dp[i-1][\\'i\\'] \\n    // dp[i][\\'i\\']=dp[i-1][\\'o\\'] + dp[i-1][\\'e\\'] \\n    // dp[i][\\'o\\']=dp[i-1][\\'i\\']\\n    // dp[i][\\'u\\']=dp[i-1][\\'o\\'] + dp[i-1][\\'i\\'] \\n    \\n    int countVowelPermutation(int n) {\\n        \\n        vector<vector<ll>> dp(n+1 , vector<ll>(5 , 1));\\n        \\n        int a=0;\\n        int e=1;\\n        int i=2;\\n        int o=3;\\n        int u=4;\\n        \\n        // taking the index of the characters \\n        \\n        for(int k=1;k<n;k++)\\n        {\\n            dp[k][a]= (dp[k-1][e] + dp[k-1][i] + dp[k-1][u])%mod;\\n            dp[k][e]=(dp[k-1][a] + dp[k-1][i])%mod;\\n            dp[k][i]= (dp[k-1][o] + dp[k-1][e])%mod;\\n            dp[k][o]=dp[k-1][i]%mod;\\n            dp[k][u]=(dp[k-1][o] + dp[k-1][i])%mod;\\n        }\\n        \\n        ll ans=0;\\n        \\n        ans = (dp[n-1][a] + dp[n-1][e] + dp[n-1][i] + dp[n-1][o] + dp[n-1][u])%mod;\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n ll mod=1e9+7;\\n    \\n    // Intuitions -> as the instructions given in the qquestion \\n    \\n    // we will modify it slightly \\n    \\n    // _ a -> then _ will have {e , i , u}\\n    \\n    // _ e -> then _ will have {a , i }\\n    \\n    // _ i -> then _ will have {o , e }\\n    \\n    // _ o -> then _ will have {  i  }\\n    \\n    // _ u -> then _ will have { o , i }\\n    \\n    // so now we will start forming the decision tree \\n    \\n    //  a , e , i , o , u \\n    \\n    // now for next char having as ith index has \\'a\\' as current char -> \\n    \\n    // this value is equal to i-th index having ( e , i , u ) as i-1th character \\n    \\n    //i.e dp[i][\\'a\\']=dp[i-1][\\'e\\'] + dp[i-1][\\'i\\'] + dp[i-1][\\'u\\']\\n    // dp[i][\\'e\\']=dp[i-1][\\'a\\'] + dp[i-1][\\'i\\'] \\n    // dp[i][\\'i\\']=dp[i-1][\\'o\\'] + dp[i-1][\\'e\\'] \\n    // dp[i][\\'o\\']=dp[i-1][\\'i\\']\\n    // dp[i][\\'u\\']=dp[i-1][\\'o\\'] + dp[i-1][\\'i\\'] \\n    \\n    int countVowelPermutation(int n) {\\n        \\n        vector<vector<ll>> dp(n+1 , vector<ll>(5 , 1));\\n        \\n        int a=0;\\n        int e=1;\\n        int i=2;\\n        int o=3;\\n        int u=4;\\n        \\n        // taking the index of the characters \\n        \\n        for(int k=1;k<n;k++)\\n        {\\n            dp[k][a]= (dp[k-1][e] + dp[k-1][i] + dp[k-1][u])%mod;\\n            dp[k][e]=(dp[k-1][a] + dp[k-1][i])%mod;\\n            dp[k][i]= (dp[k-1][o] + dp[k-1][e])%mod;\\n            dp[k][o]=dp[k-1][i]%mod;\\n            dp[k][u]=(dp[k-1][o] + dp[k-1][i])%mod;\\n        }\\n        \\n        ll ans=0;\\n        \\n        ans = (dp[n-1][a] + dp[n-1][e] + dp[n-1][i] + dp[n-1][o] + dp[n-1][u])%mod;\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2398031,
                "title": "dp-approach-and-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```\\n**Please UPVOTE if you fund this solution helpful.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397327,
                "title": "simple-and-clear-solution-with-recursion-and-memorization-c-dp",
                "content": "class Solution {\\nprivate:\\n    int mod = 1000000007;\\n    map<int, int> a;\\n    map<int, int> e;\\n    map<int, int> i;\\n    map<int, int> o;\\n    map<int, int> u;\\n    int aCount(int n)\\n    {\\n        if (n == 2)\\n            return 1;\\n        if (a.find(n) != a.end())\\n            return a[n];\\n\\n        a[n] = ((eCount(n - 1)) % mod);\\n        return a[n];\\n    }\\n    int eCount(int n)\\n    {\\n        if (n == 2)\\n            return 2;\\n        if (e.find(n) != e.end())\\n            return e[n];\\n        e[n] = (aCount(n - 1)) % mod;\\n        e[n] = (e[n] + iCount(n - 1)) % mod;\\n        return e[n];\\n    }\\n    int iCount(int n)\\n    {\\n        if (n == 2)\\n            return 4;\\n        if (i.find(n) != i.end())\\n            return i[n];\\n        i[n] = (aCount(n - 1)) % mod;\\n        i[n] = (i[n] + eCount(n - 1)) % mod;\\n        i[n] = (i[n] + oCount(n - 1)) % mod;\\n        i[n] = (i[n] + uCount(n - 1)) % mod;\\n        return i[n];\\n    }\\n    int oCount(int n)\\n    {\\n        if (n == 2)\\n            return 2;\\n        if (o.find(n) != o.end())\\n            return o[n];\\n        o[n] = iCount(n - 1) % mod;\\n        o[n] = (o[n] + uCount(n - 1)) % mod;\\n        return o[n];\\n    }\\n    int uCount(int n)\\n    {\\n        if (n == 2)\\n            return 1;\\n        if (u.find(n) != u.end())\\n            return u[n];\\n        u[n] = aCount(n - 1) % mod;\\n        return u[n];\\n    }\\n\\npublic:\\n    int countVowelPermutation(int n)\\n    {\\n        if (n == 1)\\n            return 5;\\n        int sum = aCount(n) % mod;\\n        sum = (sum + eCount(n)) % mod;\\n        sum = (sum + iCount(n)) % mod;\\n        sum = (sum + oCount(n)) % mod;\\n        sum = (sum + uCount(n)) % mod;\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n    int mod = 1000000007;\\n    map<int, int> a;\\n    map<int, int> e;\\n    map<int, int> i;\\n    map<int, int> o;\\n    map<int, int> u;\\n    int aCount(int n)\\n    {\\n        if (n == 2)\\n            return 1;\\n        if (a.find(n) != a.end())\\n            return a[n];\\n\\n        a[n] = ((eCount(n - 1)) % mod);\\n        return a[n];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2395343,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int MOD = 1000000007;\\n    \\n    \\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> ind(5);\\n        \\n        ind[0] = {1,2,4};\\n        ind[1] = {0, 2};\\n        ind[2] = {1, 3};\\n        ind[3] = {2};\\n        ind[4] = {2, 3};\\n        \\n        vector<vector<int>> dp(5, vector<int>(n, 1));\\n        \\n        int ans=0;\\n        \\n        for(int j=1;j<n;j++){\\n            for(int i=0;i<5;i++){\\n                dp[i][j]=0;\\n                for(int k=0;k<ind[i].size();k++){\\n                    dp[i][j]=(dp[i][j]+dp[ind[i][k]][j-1])%MOD;\\n                }\\n            }\\n        }\\n        for(int i=0;i<5;i++){\\n            ans = (ans+dp[i][n-1])%MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int MOD = 1000000007;\\n    \\n    \\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> ind(5);\\n        \\n        ind[0] = {1,2,4};\\n        ind[1] = {0, 2};\\n        ind[2] = {1, 3};\\n        ind[3] = {2};\\n        ind[4] = {2, 3};\\n        \\n        vector<vector<int>> dp(5, vector<int>(n, 1));\\n        \\n        int ans=0;\\n        \\n        for(int j=1;j<n;j++){\\n            for(int i=0;i<5;i++){\\n                dp[i][j]=0;\\n                for(int k=0;k<ind[i].size();k++){\\n                    dp[i][j]=(dp[i][j]+dp[ind[i][k]][j-1])%MOD;\\n                }\\n            }\\n        }\\n        for(int i=0;i<5;i++){\\n            ans = (ans+dp[i][n-1])%MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395255,
                "title": "go-o-n-time-o-1-space-dp-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Count Vowels Permutation.\\nMemory Usage: 1.9 MB, less than 100.00% of Go online submissions for Count Vowels Permutation.\\n```\\nfunc countVowelPermutation(n int) int {\\n    const (\\n        a = iota\\n        e\\n        i\\n        o\\n        u\\n    )\\n    const m = 1e9+7\\n    \\n    curr := [5]int{1,1,1,1,1}\\n    next := [5]int{}\\n    \\n    for ; n > 1; n-- {\\n        // \\'a\\' may only be followed by an \\'e\\'\\n        next[e] += curr[a]\\n        \\n        // \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'\\n        next[a] += curr[e]\\n        next[i] += curr[e]\\n        \\n        // \\'i\\' may not be followed by another \\'i\\'\\n        next[a] += curr[i]\\n        next[e] += curr[i]\\n        next[o] += curr[i]\\n        next[u] += curr[i]\\n        \\n        // \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'\\n        next[i] += curr[o]\\n        next[u] += curr[o]\\n        \\n        // \\'u\\' may only be followed by an \\'a\\'\\n        next[a] += curr[u]\\n        \\n        for char := 0; char < 5; char++ {\\n            next[char] %= m\\n        }\\n        \\n        curr, next = next, [5]int{}\\n    }\\n    return (curr[a] + curr[e] + curr[i] + curr[o] + curr[u]) % m\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc countVowelPermutation(n int) int {\\n    const (\\n        a = iota\\n        e\\n        i\\n        o\\n        u\\n    )\\n    const m = 1e9+7\\n    \\n    curr := [5]int{1,1,1,1,1}\\n    next := [5]int{}\\n    \\n    for ; n > 1; n-- {\\n        // \\'a\\' may only be followed by an \\'e\\'\\n        next[e] += curr[a]\\n        \\n        // \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'\\n        next[a] += curr[e]\\n        next[i] += curr[e]\\n        \\n        // \\'i\\' may not be followed by another \\'i\\'\\n        next[a] += curr[i]\\n        next[e] += curr[i]\\n        next[o] += curr[i]\\n        next[u] += curr[i]\\n        \\n        // \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'\\n        next[i] += curr[o]\\n        next[u] += curr[o]\\n        \\n        // \\'u\\' may only be followed by an \\'a\\'\\n        next[a] += curr[u]\\n        \\n        for char := 0; char < 5; char++ {\\n            next[char] %= m\\n        }\\n        \\n        curr, next = next, [5]int{}\\n    }\\n    return (curr[a] + curr[e] + curr[i] + curr[o] + curr[u]) % m\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2395157,
                "title": "easy-to-understand-python-solution",
                "content": "Here we have to calculate Number of ways we can arrange vowels based on the rules. So we can use these rules to form our base conditions and proceed. \\n\\nIntuition\\nHere we start with making a string of length one.\\nThe strings available are \"a\", \"e\", \"i\" , \"o\", \"u\". So we assign this value\\nThen we start building the length of our string.\\nWe run the loop for (n - 1) times.\\nImportant Points to observe :\\n1. At any jth iteration a,e,i,o,u variables contain the value of all possible strings that start with respective variables of length (j - 1).\\n2. We can use this number to build. \\n3. For eg, we are at 10th iteration so our variables contain values for string of 9 length. Thus if we want to know how many strings of length 10 we can make that begin with e, we can use formula from rules i.e, e = a + i.\\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a, e, i, o, u = 1, 1, 1, 1, 1 # \\n        for _ in range(n - 1): \\n            a, e, i, o, u = e, a + i, e + o + a + u, i + u, a\\n        return (a + e + i + o + u) % (10**9 + 7)\\n```\\n\\nOne important thing to note is that all the values we are updating(a,i,e,o,u) must happen simultaneously. More formally we cannot change value of \\'a\\' first and then use this changed \\'a\\' for operations we have to perform on other vowels.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a, e, i, o, u = 1, 1, 1, 1, 1 # \\n        for _ in range(n - 1): \\n            a, e, i, o, u = e, a + i, e + o + a + u, i + u, a\\n        return (a + e + i + o + u) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394907,
                "title": "why-fear-when-dp-is-here-most-optimized-beats-96-6-explained-properly",
                "content": "***Please upvote if you found it helpful.***\\n\\n**Dynamic programming aproach**\\n\\nclass Solution:\\n    \\n\\tdef countVowelPermutation(self, n: int) -> int:\\n        mod = int(1e9) + 7\\n        # a,e,i,o,u=0,1,2,3,4\\n        choices={0: [1], 1: [0, 2], 2: [0, 1, 3, 4], 3: [2, 4], 4: [0]}\\n        \\n\\t\\t#here dp is previous row used for calculation\\n        dp=[0]*(5)\\n\\t\\t#cur is current row which will be updated at every iteration and made dp row after that iteration\\n        cur=[0]*(5)\\n        \\n\\t\\t#this is done because at starting any element can be picked \\n        for vow in range(5):\\n            dp[vow]=1\\n        \\n        for i in range(1,n):\\n\\t\\t#last is the last vowel picked for condition check\\n            for last in range(5):\\n                pick=0\\n                for vow in choices[last]:\\n                    pick+=dp[vow]\\n                #this is done to store all possibities with one vowel having many choices\\n\\t\\t\\t\\t#like \"i\" has 4 choices,\"e \"and \"o\" has two choices and \"a\"  and \"u\" have a single choice only. \\n\\t\\t\\t\\tcur[last]=pick\\n            dp=cur[:]\\n                \\n        return sum(dp)%mod\\n\\n**Recursion of above code**\\n\\nclass Solution:\\n    \\n    def countVowelPermutation(self, n: int) -> int:\\n        def f(i,last,choices):\\n            if i==1:\\n                return 1\\n            pick=0\\n            for vow in choices[last]:\\n                pick+=f(i-1,vow,choices)\\n            return pick\\n        mod=int(1e9) + 7\\n        choices={\"a\":[\"e\"],\\n                \"e\":[\"a\",\"i\"],\\n                \"i\":[\\'a\\',\\'e\\',\\'o\\',\\'u\\'],\\n                \"o\":[\"i\",\"u\"],\\n                \"u\":[\"a\"] }\\n        count=0\\n        for last in choices.keys():\\n            count+=f(n,last,choices)\\n        return count%mod\\n\\t\\n\\t\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution:\\n    \\n\\tdef countVowelPermutation(self, n: int) -> int:\\n        mod = int(1e9) + 7\\n        # a,e,i,o,u=0,1,2,3,4\\n        choices={0: [1], 1: [0, 2], 2: [0, 1, 3, 4], 3: [2, 4], 4: [0]}",
                "codeTag": "Java"
            },
            {
                "id": 2394879,
                "title": "easy-to-understand-memoized-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n  int mod = 1e9 + 7;\\n  int dp[100005][115];\\n\\n  long long int help(int n, int idx, char c) {\\n    if (idx == n)\\n      return 1;\\n\\n    if (dp[idx][c - \\'a\\'] != -1)\\n      return dp[idx][c - \\'a\\'] % mod;\\n\\n    long long int ans = 0;\\n\\n    switch (c) {\\n\\n    case \\'a\\':\\n      ans += help(n, idx + 1, \\'e\\') % mod;\\n      break;\\n\\n    case \\'e\\':\\n      ans += help(n, idx + 1, \\'a\\') + help(n, idx + 1, \\'i\\');\\n      break;\\n\\n    case \\'i\\':\\n      ans += help(n, idx + 1, \\'a\\') + help(n, idx + 1, \\'e\\') +\\n             help(n, idx + 1, \\'o\\') + help(n, idx + 1, \\'u\\');\\n      break;\\n\\n    case \\'o\\':\\n      ans += help(n, idx + 1, \\'i\\') + help(n, idx + 1, \\'u\\');\\n      break;\\n\\n    case \\'u\\':\\n      ans += help(n, idx + 1, \\'a\\');\\n      break;\\n    }\\n\\n    return dp[idx][c - \\'a\\'] = ans % mod;\\n  }\\n\\n  int countVowelPermutation(int n) {\\n    long long int ans = 0;\\n\\n    vector<char> vowels{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    memset(dp, -1, sizeof(dp));\\n\\n    for (char &c : vowels)\\n      ans += help(n, 1, c);\\n\\n    return ans % mod;\\n  }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int mod = 1e9 + 7;\\n  int dp[100005][115];\\n\\n  long long int help(int n, int idx, char c) {\\n    if (idx == n)\\n      return 1;\\n\\n    if (dp[idx][c - \\'a\\'] != -1)\\n      return dp[idx][c - \\'a\\'] % mod;\\n\\n    long long int ans = 0;\\n\\n    switch (c) {\\n\\n    case \\'a\\':\\n      ans += help(n, idx + 1, \\'e\\') % mod;\\n      break;\\n\\n    case \\'e\\':\\n      ans += help(n, idx + 1, \\'a\\') + help(n, idx + 1, \\'i\\');\\n      break;\\n\\n    case \\'i\\':\\n      ans += help(n, idx + 1, \\'a\\') + help(n, idx + 1, \\'e\\') +\\n             help(n, idx + 1, \\'o\\') + help(n, idx + 1, \\'u\\');\\n      break;\\n\\n    case \\'o\\':\\n      ans += help(n, idx + 1, \\'i\\') + help(n, idx + 1, \\'u\\');\\n      break;\\n\\n    case \\'u\\':\\n      ans += help(n, idx + 1, \\'a\\');\\n      break;\\n    }\\n\\n    return dp[idx][c - \\'a\\'] = ans % mod;\\n  }\\n\\n  int countVowelPermutation(int n) {\\n    long long int ans = 0;\\n\\n    vector<char> vowels{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    memset(dp, -1, sizeof(dp));\\n\\n    for (char &c : vowels)\\n      ans += help(n, 1, c);\\n\\n    return ans % mod;\\n  }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394874,
                "title": "python-easy-dp",
                "content": "From observation you can see that:\\ncountVowelPermutation(n+1) = the sum of (letters that end in each vowel of length n * possible vowels that can come after that vowel)\\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        myStore = {\\'a\\': 1, \\'e\\': 1, \\'i\\': 1, \\'o\\': 1, \\'u\\': 1}\\n        \\n        for i in range(n - 1):\\n            myStore[\\'a\\'],myStore[\\'e\\'],myStore[\\'i\\'],myStore[\\'o\\'],myStore[\\'u\\'] = myStore[\\'e\\'] + myStore[\\'i\\'] + myStore[\\'u\\'],myStore[\\'a\\'] + myStore[\\'i\\'],myStore[\\'e\\'] + myStore[\\'o\\'], myStore[\\'i\\'], myStore[\\'i\\'] + myStore[\\'o\\']\\n        \\n        return sum(myStore.values()) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        myStore = {\\'a\\': 1, \\'e\\': 1, \\'i\\': 1, \\'o\\': 1, \\'u\\': 1}\\n        \\n        for i in range(n - 1):\\n            myStore[\\'a\\'],myStore[\\'e\\'],myStore[\\'i\\'],myStore[\\'o\\'],myStore[\\'u\\'] = myStore[\\'e\\'] + myStore[\\'i\\'] + myStore[\\'u\\'],myStore[\\'a\\'] + myStore[\\'i\\'],myStore[\\'e\\'] + myStore[\\'o\\'], myStore[\\'i\\'], myStore[\\'i\\'] + myStore[\\'o\\']\\n        \\n        return sum(myStore.values()) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394862,
                "title": "clean-c-solution-using-dp-2-d-matrix",
                "content": "The simplest way to approach this problem is by using dynamic programming. The Hint 2 given in the description gives away the actual way to go. \\n\"**Let dp[i][j] be the number of strings of length i that ends with the j-th vowel.**\"\\n\\nWe will initialize a 2-D matrix of size  n * 5 where n is the length of strings and 5 , which is the number of vowels. \\n\\ndp[i][j] will denote the number of strings of length \"i\" which end with \"jth vowel\". Ex: dp[0][1] = 1 --> number of strings of length 1 which end with 2nd vowel - e \\n\\n**Note that I am using zero based indexing here.**\\n\\nThe first row will be all 1s as there can exactly 1 possible combination of all vowels. \\n\\nWe will follow the set of rules given and update the rows till we reach the n th row. \\n\\nAs the sum will be large, we will use mod(10 power 9 + 7).\\n\\nAt the end, we will calculate the mod of sum of elements of the nth row and return.\\n\\n```\\nint countVowelPermutation(int n) {\\n        int count = 0;\\n        vector<vector<long long int>> dp(n, vector<long long int> (5, 0));\\n        for(int i=0;i<5;++i)\\n            dp[0][i] = 1;\\n       \\n        for(int i=0;i<n-1;++i){\\n            for(int j=0;j<5;++j){\\n                switch(j){\\n                    case 0:\\n                        {\\n                            dp[i+1][1] = (dp[i][j] + dp[i+1][1])%mod ;\\n                            break;\\n                        }\\n                    case 1:\\n                        {\\n                            dp[i+1][0] = (dp[i][j] + dp[i+1][0])%mod;\\n                            dp[i+1][2] = (dp[i][j] + dp[i+1][2])%mod;\\n                            break;\\n                        }\\n                    case 2:\\n                        {\\n                            dp[i+1][0] = (dp[i][j]+dp[i+1][0])%mod;\\n                            dp[i+1][1] = (dp[i][j]+dp[i+1][1])%mod;\\n                            dp[i+1][3] = (dp[i][j]+dp[i+1][3])%mod;\\n                            dp[i+1][4] = (dp[i][j]+dp[i+1][4])%mod;\\n                            break;\\n                        }\\n                    case 3:\\n                        {\\n                            dp[i+1][2] = (dp[i][j]+dp[i+1][2])%mod;\\n                            dp[i+1][4] = (dp[i][j]+dp[i+1][4])%mod;\\n                            break;\\n                        }\\n                    case 4:\\n                        {\\n                            dp[i+1][0] = (dp[i][j]+dp[i+1][0])%mod;\\n                            break;\\n                        }\\n                }\\n\\n            }\\n        }\\n   \\n    for(int i = 0; i < 5; ++i){\\n        count = (dp[n-1][i] + count)%mod;\\n    }\\n    return count;\\n}\\n```\\n\\nPlease upvote if it helped!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelPermutation(int n) {\\n        int count = 0;\\n        vector<vector<long long int>> dp(n, vector<long long int> (5, 0));\\n        for(int i=0;i<5;++i)\\n            dp[0][i] = 1;\\n       \\n        for(int i=0;i<n-1;++i){\\n            for(int j=0;j<5;++j){\\n                switch(j){\\n                    case 0:\\n                        {\\n                            dp[i+1][1] = (dp[i][j] + dp[i+1][1])%mod ;\\n                            break;\\n                        }\\n                    case 1:\\n                        {\\n                            dp[i+1][0] = (dp[i][j] + dp[i+1][0])%mod;\\n                            dp[i+1][2] = (dp[i][j] + dp[i+1][2])%mod;\\n                            break;\\n                        }\\n                    case 2:\\n                        {\\n                            dp[i+1][0] = (dp[i][j]+dp[i+1][0])%mod;\\n                            dp[i+1][1] = (dp[i][j]+dp[i+1][1])%mod;\\n                            dp[i+1][3] = (dp[i][j]+dp[i+1][3])%mod;\\n                            dp[i+1][4] = (dp[i][j]+dp[i+1][4])%mod;\\n                            break;\\n                        }\\n                    case 3:\\n                        {\\n                            dp[i+1][2] = (dp[i][j]+dp[i+1][2])%mod;\\n                            dp[i+1][4] = (dp[i][j]+dp[i+1][4])%mod;\\n                            break;\\n                        }\\n                    case 4:\\n                        {\\n                            dp[i+1][0] = (dp[i][j]+dp[i+1][0])%mod;\\n                            break;\\n                        }\\n                }\\n\\n            }\\n        }\\n   \\n    for(int i = 0; i < 5; ++i){\\n        count = (dp[n-1][i] + count)%mod;\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2394838,
                "title": "1220-count-vowels-permutation-c-code",
                "content": "## 1220. Count Vowels Permutation\\n##### Hard | C++ Code Solution Explanation | Dynamic Programming\\n\\n\\n#### Problem\\nGiven an integer n, your task is to count how many strings of length n can be formed under the following rules:\\n\\n* Each character is a lower case vowel (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n* Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n* Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n* Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n* Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n* Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n\\nSince the answer may be too large, return it modulo 10^9 + 7.\\n\\n#### Solution\\n\\nlet the vowels be denoted as numbers\\n* a = 0\\n* e = 1\\n* i = 2\\n* o = 3\\n* u = 4\\n\\n1. We will make two vectors `prev`,` cur`.\\n2. `prev` will store the number of strings that are ending with each vowel and will be used to calculate `cur`.\\n3. Values will be calculated from previous string using the rules mentioned.\\n\\nFor Example:\\n* The string of length ` n-1` can be appended with \\'a\\' (or end with \\'a\\') to make length `n` only if when string of length `n-1` end with \\'e\\' or \\'i\\' or \\'u\\',\\n`cur[a]= prev[e] + prev[i]+ prev[u];`\\n* Similarly we can calculate for other vowels.\\n\\n#### Code \\n```\\nint countVowelPermutation(int n) {\\n        \\n        vector<int>prev(5, 1);\\n        vector<int>cur(5, 1);\\n        \\n        int sum =0, mod=1000000007;\\n        \\n        for(int i=1; i<n; i++){\\n            cur[0]= ((prev[1]%mod + prev[2]%mod)%mod + prev[4]%mod)%mod;\\n            cur[1]=(prev[0]%mod + prev[2]%mod)%mod;\\n            cur[2]= (prev[1]%mod + prev[3]%mod)%mod;\\n            cur[3]= prev[2]%mod;\\n            cur[4] = (prev[2]%mod + prev[3]%mod)%mod;\\n            prev = cur;\\n        }\\n        \\n        for(int i=0; i<5; i++){\\n            \\n            sum=((cur[i]%mod) + sum%mod)%mod;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelPermutation(int n) {\\n        \\n        vector<int>prev(5, 1);\\n        vector<int>cur(5, 1);\\n        \\n        int sum =0, mod=1000000007;\\n        \\n        for(int i=1; i<n; i++){\\n            cur[0]= ((prev[1]%mod + prev[2]%mod)%mod + prev[4]%mod)%mod;\\n            cur[1]=(prev[0]%mod + prev[2]%mod)%mod;\\n            cur[2]= (prev[1]%mod + prev[3]%mod)%mod;\\n            cur[3]= prev[2]%mod;\\n            cur[4] = (prev[2]%mod + prev[3]%mod)%mod;\\n            prev = cur;\\n        }\\n        \\n        for(int i=0; i<5; i++){\\n            \\n            sum=((cur[i]%mod) + sum%mod)%mod;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2394825,
                "title": "java-dynamic-programming-o-n-time-o-1-space",
                "content": "**Intuition:**\\nWe create a 2-dimensional 5xn array, and traverse it filling each position dp[i][0 to 4] according to the five values of the last iteration dp[i-1][0 to 4].\\n\\n**Approach: bottom-up DP with O(n) space**\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        \\n        int[][] dp = new int[n][5];\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        dp[0][2] = 1;\\n        dp[0][3] = 1;\\n        dp[0][4] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            dp[i][1] += dp[i-1][0]; // a -> ae\\n            \\n            dp[i][0] += dp[i-1][1]; // e -> ea\\n            dp[i][2] += dp[i-1][1]; // e -> ei\\n            \\n            dp[i][0] += dp[i-1][2]; // i -> ia\\n            dp[i][1] += dp[i-1][2]; // i -> ie\\n            dp[i][3] += dp[i-1][2]; // i -> io\\n            dp[i][4] += dp[i-1][2]; // i -> iu\\n            \\n            dp[i][2] += dp[i-1][3]; // o -> oi\\n            dp[i][4] += dp[i-1][3]; // o -> ou\\n            \\n            dp[i][0] %= mod; // As a general rule, max int is bigger than twice (10\\u2079 + 7), but smaller than three times that number. We are safe adding two values, but risk overflow with a third.\\n            dp[i][0] += dp[i-1][4]; // u -> ua\\n            \\n            for(int j = 0; j < 5; j++) {\\n                dp[i][j] %= mod;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 5; i++) {\\n            ans = (ans + dp[n-1][i])%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Second approach: O(1) space**\\n\\nNotice that we are saving values to a row, then using them immediately, then never using them again. We can reuse this slots instead of keeping them all:\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        \\n        int[] last = new int[5];\\n        int[] cur = new int[5];\\n        last[0] = 1;\\n        last[1] = 1;\\n        last[2] = 1;\\n        last[3] = 1;\\n        last[4] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            cur[1] = last[0];  // \"+=\" -> \"=\"!!\\n            \\n            cur[0] = last[1];  // !!\\n            cur[2] = last[1];  // !!\\n            \\n            cur[0] += last[2];\\n            cur[1] += last[2];\\n            cur[3] = last[2];  // !!\\n            cur[4] = last[2];  // !!\\n            \\n            cur[2] += last[3];\\n            cur[4] += last[3];\\n            \\n            cur[0] = cur[0]%mod + last[4];\\n            \\n            for(int j = 0; j < 5; j++) {\\n                last[j] = cur[j]%mod;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 5; i++) {\\n            ans = (ans + last[i])%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        \\n        int[][] dp = new int[n][5];\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        dp[0][2] = 1;\\n        dp[0][3] = 1;\\n        dp[0][4] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            dp[i][1] += dp[i-1][0]; // a -> ae\\n            \\n            dp[i][0] += dp[i-1][1]; // e -> ea\\n            dp[i][2] += dp[i-1][1]; // e -> ei\\n            \\n            dp[i][0] += dp[i-1][2]; // i -> ia\\n            dp[i][1] += dp[i-1][2]; // i -> ie\\n            dp[i][3] += dp[i-1][2]; // i -> io\\n            dp[i][4] += dp[i-1][2]; // i -> iu\\n            \\n            dp[i][2] += dp[i-1][3]; // o -> oi\\n            dp[i][4] += dp[i-1][3]; // o -> ou\\n            \\n            dp[i][0] %= mod; // As a general rule, max int is bigger than twice (10\\u2079 + 7), but smaller than three times that number. We are safe adding two values, but risk overflow with a third.\\n            dp[i][0] += dp[i-1][4]; // u -> ua\\n            \\n            for(int j = 0; j < 5; j++) {\\n                dp[i][j] %= mod;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 5; i++) {\\n            ans = (ans + dp[n-1][i])%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        \\n        int[] last = new int[5];\\n        int[] cur = new int[5];\\n        last[0] = 1;\\n        last[1] = 1;\\n        last[2] = 1;\\n        last[3] = 1;\\n        last[4] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            cur[1] = last[0];  // \"+=\" -> \"=\"!!\\n            \\n            cur[0] = last[1];  // !!\\n            cur[2] = last[1];  // !!\\n            \\n            cur[0] += last[2];\\n            cur[1] += last[2];\\n            cur[3] = last[2];  // !!\\n            cur[4] = last[2];  // !!\\n            \\n            cur[2] += last[3];\\n            cur[4] += last[3];\\n            \\n            cur[0] = cur[0]%mod + last[4];\\n            \\n            for(int j = 0; j < 5; j++) {\\n                last[j] = cur[j]%mod;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 5; i++) {\\n            ans = (ans + last[i])%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394765,
                "title": "easy-memoization-dp-graph-using-adjacency-list",
                "content": "To solve using graph, assume all vowels as nodes and to what they are being followed,\\na -> e\\ne -> a, i\\ni  -> a, e, o, u (excluding i)\\no -> i, u\\nu -> a\\n\\n**CODE:-**\\n```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    unordered_map< string, int> dp;\\n\\n    int dfs(unordered_map<char, vector<char>> &adj, char v, int n, int i){\\n        if(i == n) //base condition\\n            return 1;\\n        \\n        // making key i.e {i, v} -> i_v\\n        string key = to_string(i) +\"_\" + v;\\n        \\n        // if already present\\n        if(dp.find(key) != dp.end())\\n            return dp[key];\\n        \\n        long ans = 0;\\n        for(auto c : adj[v]){\\n            ans += dfs(adj, c, n, i+1);\\n            ans %= mod;\\n            dp[key] += ans;\\n        }\\n        \\n        return dp[key] = (ans%mod);\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        // making adjacency matrix\\n        // mapping vowels to what can comes after\\n        unordered_map<char, vector<char>> adjacencyMatrix;\\n        adj[\\'a\\'] = {\\'e\\'};\\n        adj[\\'e\\'] = {\\'a\\', \\'i\\'};\\n        adj[\\'i\\'] = {\\'a\\', \\'e\\', \\'o\\', \\'u\\'};\\n        adj[\\'o\\'] = {\\'i\\', \\'u\\'};\\n        adj[\\'u\\'] = {\\'a\\'};\\n        \\n        \\n        long ans = 0;\\n        for(auto i : adjacencyMatrix){\\n            ans += dfs(adjacencyMatrix, i.first, n, 1);\\n            ans %= mod;\\n        }\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    unordered_map< string, int> dp;\\n\\n    int dfs(unordered_map<char, vector<char>> &adj, char v, int n, int i){\\n        if(i == n) //base condition\\n            return 1;\\n        \\n        // making key i.e {i, v} -> i_v\\n        string key = to_string(i) +\"_\" + v;\\n        \\n        // if already present\\n        if(dp.find(key) != dp.end())\\n            return dp[key];\\n        \\n        long ans = 0;\\n        for(auto c : adj[v]){\\n            ans += dfs(adj, c, n, i+1);\\n            ans %= mod;\\n            dp[key] += ans;\\n        }\\n        \\n        return dp[key] = (ans%mod);\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        // making adjacency matrix\\n        // mapping vowels to what can comes after\\n        unordered_map<char, vector<char>> adjacencyMatrix;\\n        adj[\\'a\\'] = {\\'e\\'};\\n        adj[\\'e\\'] = {\\'a\\', \\'i\\'};\\n        adj[\\'i\\'] = {\\'a\\', \\'e\\', \\'o\\', \\'u\\'};\\n        adj[\\'o\\'] = {\\'i\\', \\'u\\'};\\n        adj[\\'u\\'] = {\\'a\\'};\\n        \\n        \\n        long ans = 0;\\n        for(auto i : adjacencyMatrix){\\n            ans += dfs(adjacencyMatrix, i.first, n, 1);\\n            ans %= mod;\\n        }\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394763,
                "title": "c-detailed-explanation",
                "content": "/*\\n\\n    dp[i][0] --> stores count of i-length string , ends with character \\'a\\'        \\n    \\n     dp[i][1] --> stores count of i-length string , ends with character \\'e\\'\\n    \\n     dp[i][2] --> stores count of i-length string , ends with character \\'i\\'\\n    \\n     dp[i][3] --> stores count of i-length string , ends with character \\'o\\'\\n    \\n     dp[i][4] --> stores count of i-length string , ends with character \\'u\\'\\n    \\n    \\n     Required Recurrences for solving the problem ......\\n    \\n    \\n    According to the question Each character \\'a\\' may only be followed by \\'e\\' .\\n    \\n    That means if character at i-th index be \\'e\\' , then its one of the previous characters might be \\'a\\'\\n    \\n    \\'a\\' --next--> \\'e\\'\\n    \\'a\\' <--prev-- \\'e\\'\\n    \\n    Now , the recurrence boils down to ---->\\n    \\n    for the character at i-th index , try to figure out all the possible (i-1)-th indexed characters.\\n    \\n    e.g : dp[i][\\'e\\'] = dp[i-1][\\'a\\'] + dp[i-1][\\'i\\']\\n    \\n    \\n    */\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t`class Solution {\\npublic:\\n\\ntypedef long long ll;\\n\\nconst ll M = 1e9 + 7;\\n\\nll mod(ll a){\\n    return ((a%M)+M)%M;\\n}\\n\\nll mul(ll a,ll b){\\n    return mod(mod(a)*mod(b));\\n}\\n\\nll add(ll a,ll b){\\n    return mod(mod(a)+mod(b));\\n}\\n\\nint countVowelPermutation(int n) {\\n    \\n    vector<vector<ll>>dp(n+1,vector<ll>(5,0LL));\\n   \\n    // Base Case :\\n    \\n    dp[1][0]=1LL;\\n    dp[1][1]=1LL;\\n    dp[1][2]=1LL;\\n    dp[1][3]=1LL;\\n    dp[1][4]=1LL;\\n    \\n    // Transitions for recurrence :\\n    \\n    for(ll i=2;i<=n;++i){\\n        \\n        // For character \\'a\\' \\n        \\n        dp[i][0] = add(add(dp[i-1][1],dp[i-1][2]),dp[i-1][4]);\\n        \\n        // For character \\'e\\'\\n        \\n        dp[i][1] = add(dp[i-1][0],dp[i-1][2]);\\n        \\n        // For character \\'i\\'\\n        \\n        dp[i][2] = add(dp[i-1][1],dp[i-1][3]);\\n        \\n        // For character \\'o\\'\\n        \\n        dp[i][3] = dp[i-1][2];\\n        \\n        // For character \\'u\\'\\n        \\n        dp[i][4] = add(dp[i-1][2],dp[i-1][3]);\\n        \\n    }\\n    \\n    ll total = 0LL;\\n    \\n    for(ll i=0;i<5;++i){\\n        \\n        total=add(total,dp[n][i]);\\n        \\n    }\\n    \\n    return total;\\n    \\n}\\n};\\n`\\n\\n/*\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(N*5) --> O(N)\\n\\n*/",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\ntypedef long long ll;\\n\\nconst ll M = 1e9 + 7;\\n\\nll mod(ll a){\\n    return ((a%M)+M)%M;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2394649,
                "title": "is-it-worthy",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int n,map<int,set<int>>&mp,vector<vector<int>>&dp){\\n        if(i==n){\\n            return 1;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int res=0;\\n        for(int k=1;k<=5;k++){\\n            if(j==0){\\n                res = (res % 1000000007 + dfs(i+1,k,n,mp,dp)%1000000007)%1000000007;\\n            }\\n            else if(mp[j].find(k)!=mp[j].end()){\\n                 res = (res % 1000000007 + dfs(i+1,k,n,mp,dp)%1000000007)%1000000007;\\n            }\\n        }\\n        return dp[i][j]=res;\\n    }\\n    int countVowelPermutation(int n) {\\n        map<int,set<int>>mp;\\n        mp[1].insert(2);\\n        mp[2].insert(1);\\n        mp[2].insert(3);\\n        mp[3].insert(1);\\n        mp[3].insert(2);\\n        mp[3].insert(4);\\n        mp[3].insert(5);\\n        mp[4].insert(3);\\n        mp[4].insert(5);\\n        mp[5].insert(1);\\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(6,-1));\\n        return dfs(0,0,n,mp,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int n,map<int,set<int>>&mp,vector<vector<int>>&dp){\\n        if(i==n){\\n            return 1;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int res=0;\\n        for(int k=1;k<=5;k++){\\n            if(j==0){\\n                res = (res % 1000000007 + dfs(i+1,k,n,mp,dp)%1000000007)%1000000007;\\n            }\\n            else if(mp[j].find(k)!=mp[j].end()){\\n                 res = (res % 1000000007 + dfs(i+1,k,n,mp,dp)%1000000007)%1000000007;\\n            }\\n        }\\n        return dp[i][j]=res;\\n    }\\n    int countVowelPermutation(int n) {\\n        map<int,set<int>>mp;\\n        mp[1].insert(2);\\n        mp[2].insert(1);\\n        mp[2].insert(3);\\n        mp[3].insert(1);\\n        mp[3].insert(2);\\n        mp[3].insert(4);\\n        mp[3].insert(5);\\n        mp[4].insert(3);\\n        mp[4].insert(5);\\n        mp[5].insert(1);\\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(6,-1));\\n        return dfs(0,0,n,mp,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1785736,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1573109,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1569642,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1754338,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 2028857,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 2008790,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1999436,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1936154,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1890503,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1754341,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1785736,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1573109,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1569642,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1754338,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 2028857,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 2008790,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1999436,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1936154,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1890503,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1754341,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Merge In Between Linked Lists",
        "question_content": "<p>You are given two linked lists: <code>list1</code> and <code>list2</code> of sizes <code>n</code> and <code>m</code> respectively.</p>\n\n<p>Remove <code>list1</code>&#39;s nodes from the <code>a<sup>th</sup></code> node to the <code>b<sup>th</sup></code> node, and put <code>list2</code> in their place.</p>\n\n<p>The blue edges and nodes in the following figure indicate the result:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/fig1.png\" style=\"height: 130px; width: 504px;\" />\n<p><em>Build the result list and return its head.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/merge_linked_list_ex1.png\" style=\"width: 406px; height: 140px;\" />\n<pre>\n<strong>Input:</strong> list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\n<strong>Output:</strong> [0,1,2,1000000,1000001,1000002,5]\n<strong>Explanation:</strong> We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/merge_linked_list_ex2.png\" style=\"width: 463px; height: 140px;\" />\n<pre>\n<strong>Input:</strong> list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]\n<strong>Output:</strong> [0,1,1000000,1000001,1000002,1000003,1000004,6]\n<strong>Explanation:</strong> The blue edges and nodes in the above figure indicate the result.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= list1.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= a &lt;= b &lt; list1.length - 1</code></li>\n\t<li><code>1 &lt;= list2.length &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 952030,
                "title": "java-python-3-straight-forward-codes-w-comments-and-analysis",
                "content": "\\n\\n```java\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode end = list1, start = null;\\n        for (int i = 0; i < b; ++i, end = end.next) { // locate b upon termination of the loop.\\n            if (i == a - 1) { // locate the node right before a.\\n                start = end;\\n            }\\n        }\\n        start.next = list2; // connect the node right before a to the head of list2, hence cut off a from list1.\\n        while (list2.next != null) { // traverse till the end of list2. \\n            list2 = list2.next;\\n        }\\n        list2.next = end.next; // connect end of list2 to the node right after b.\\n        end.next = null; // cut off b from list1.\\n        return list1;\\n    }\\n```\\n\\n```python\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        start, end = None, list1\\n        for i in range(b):\\n            if i == a - 1:\\n                start = end\\n            end = end.next\\n        start.next = list2\\n        while list2.next:\\n            list2 = list2.next\\n        list2.next = end.next\\n        end.next = None\\n        return list1\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(1), where n = size(list1) + size(list2).",
                "solutionTags": [],
                "code": "```java\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode end = list1, start = null;\\n        for (int i = 0; i < b; ++i, end = end.next) { // locate b upon termination of the loop.\\n            if (i == a - 1) { // locate the node right before a.\\n                start = end;\\n            }\\n        }\\n        start.next = list2; // connect the node right before a to the head of list2, hence cut off a from list1.\\n        while (list2.next != null) { // traverse till the end of list2. \\n            list2 = list2.next;\\n        }\\n        list2.next = end.next; // connect end of list2 to the node right after b.\\n        end.next = null; // cut off b from list1.\\n        return list1;\\n    }\\n```\n```python\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        start, end = None, list1\\n        for i in range(b):\\n            if i == a - 1:\\n                start = end\\n            end = end.next\\n        start.next = list2\\n        while list2.next:\\n            list2 = list2.next\\n        list2.next = end.next\\n        end.next = None\\n        return list1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 952044,
                "title": "c-easy-approch",
                "content": "<iframe src=\"https://leetcode.com/playground/aE2EFkMv/shared\" frameBorder=\"0\" width=\"1000\" height=\"400\"></iframe>",
                "solutionTags": [],
                "code": "<iframe src=\"https://leetcode.com/playground/aE2EFkMv/shared\" frameBorder=\"0\" width=\"1000\" height=\"400\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 952008,
                "title": "java-straightforward-solution-in-o-n-time",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode start = list1;\\n        for (int i = 1; i < a; i++) {\\n            start = start.next;\\n        }\\n        \\n        ListNode end = start;\\n        for (int i = a; i <= b; i++) {\\n            end = end.next;\\n        }\\n        \\n        start.next = list2;\\n        while (list2.next != null) {\\n            list2 = list2.next;\\n        }\\n        \\n        list2.next = end.next;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode start = list1;\\n        for (int i = 1; i < a; i++) {\\n            start = start.next;\\n        }\\n        \\n        ListNode end = start;\\n        for (int i = a; i <= b; i++) {\\n            end = end.next;\\n        }\\n        \\n        start.next = list2;\\n        while (list2.next != null) {\\n            list2 = list2.next;\\n        }\\n        \\n        list2.next = end.next;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993116,
                "title": "java-easy-solution-beats-100-time-o-n-space-o-1",
                "content": "**Approach**\\n* Assign `left` pointer as `list1` and traverse till you find `a` value\\n* Have `middle` pointer and traverse till you find `b` value\\n* Map the `left` to `list2` and traverse till the end\\n* At last assign the next element of the `list2` as the next element of the `middle` pointer\\n```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode left = list1;\\n        for (int i = 1; i < a; i++)\\n            left = left.next;\\n        \\n        ListNode middle = left;\\n        for (int i = a; i <= b; i++)\\n            middle = middle.next;\\n        \\n\\t\\tleft.next = list2;\\n        while (list2.next != null)\\n            list2 = list2.next;\\n        \\n        list2.next = middle.next;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode left = list1;\\n        for (int i = 1; i < a; i++)\\n            left = left.next;\\n        \\n        ListNode middle = left;\\n        for (int i = a; i <= b; i++)\\n            middle = middle.next;\\n        \\n\\t\\tleft.next = list2;\\n        while (list2.next != null)\\n            list2 = list2.next;\\n        \\n        list2.next = middle.next;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952567,
                "title": "basic-c-approach-clean-and-simple-with-explanation",
                "content": "The basic approach is as follows :-\\n\\n1. Traverse the linked list to the given elements a and b\\n1. Set the next of a to the head of the other given linked list\\n1. Set the next of the tail of the other given linked list to the pointer to b\\n1. Return the original linked list as the final answer\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        int jump1 = 1;\\n        ListNode *temp1 = list1;\\n        while (jump1 < a){\\n            temp1 = temp1->next;\\n            jump1++;\\n        }                                //Gets the pointer to a\\n        \\n\\t\\tint jump2 = 1;\\n        ListNode *temp2 = list1;\\n        while(jump2 <= b){\\n            temp2 = temp2->next;\\n            jump2++;\\n        }                                //Gets the pointer to b\\n        \\n\\t\\tListNode *temp3=list2;\\n        while(temp3->next != NULL){\\n            temp3=temp3->next;\\n        }                               //Gets the pointer to the tail of list2\\n        \\n\\t\\t\\n\\t\\ttemp1->next=list2;              //set the next pointer of a to the head of list2\\n        \\n\\t\\ttemp3->next = temp2->next;      //set next of tail of list2 to the pointer to b\\n        \\n\\t\\treturn list1;                   //return the original list i.e. list1\\n        \\n    }\\n};\\n```\\n\\nAuthor: shubham1592\\n[https://github.com/shubham1592/LeetCode/blob/main/1669_Merge_In_Between_Linked_Lists.cpp](https://github.com/shubham1592/LeetCode/blob/main/1669_Merge_In_Between_Linked_Lists.cpp)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        int jump1 = 1;\\n        ListNode *temp1 = list1;\\n        while (jump1 < a){\\n            temp1 = temp1->next;\\n            jump1++;\\n        }                                //Gets the pointer to a\\n        \\n\\t\\tint jump2 = 1;\\n        ListNode *temp2 = list1;\\n        while(jump2 <= b){\\n            temp2 = temp2->next;\\n            jump2++;\\n        }                                //Gets the pointer to b\\n        \\n\\t\\tListNode *temp3=list2;\\n        while(temp3->next != NULL){\\n            temp3=temp3->next;\\n        }                               //Gets the pointer to the tail of list2\\n        \\n\\t\\t\\n\\t\\ttemp1->next=list2;              //set the next pointer of a to the head of list2\\n        \\n\\t\\ttemp3->next = temp2->next;      //set next of tail of list2 to the pointer to b\\n        \\n\\t\\treturn list1;                   //return the original list i.e. list1\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011399,
                "title": "python-3-2-pointers-approach-code-with-comments-o-m-n",
                "content": "This is my approach to the problem using 2 pointers :\\n```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        # Define 2 pointers\\n\\t\\tptr1 = list1\\n        ptr2 = list1\\n        i, j = 0, 0\\n\\t\\t\\n\\t\\t# Loop for pointer 1 to reach previous node from a\\n        while i!=a-1:\\n            ptr1 = ptr1.next\\n            i += 1 \\n\\t\\t\\t\\n\\t\\t# Loop for pointer 2 to reach node b\\n        while j!=b:\\n            ptr2 = ptr2.next\\n            j += 1\\n\\t\\t\\t\\n\\t\\t# Connect list2 to the next of pointer1\\n        ptr1.next = list2\\n\\t\\t\\n\\t\\t# Traverse the list2 till end node\\n        while list2.next!=None:\\n            list2 = list2.next\\n\\t\\t\\n\\t\\t# Assign the next of pointer 2 to the next of list2 i.e connect the remaining part of list1 to list2\\n        list2.next = ptr2.next\\n\\t\\t\\n\\t\\t# return final list\\n        return list1\\n```\\n\\nFeel free to comment down your solutions as well :)",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        # Define 2 pointers\\n\\t\\tptr1 = list1\\n        ptr2 = list1\\n        i, j = 0, 0\\n\\t\\t\\n\\t\\t# Loop for pointer 1 to reach previous node from a\\n        while i!=a-1:\\n            ptr1 = ptr1.next\\n            i += 1 \\n\\t\\t\\t\\n\\t\\t# Loop for pointer 2 to reach node b\\n        while j!=b:\\n            ptr2 = ptr2.next\\n            j += 1\\n\\t\\t\\t\\n\\t\\t# Connect list2 to the next of pointer1\\n        ptr1.next = list2\\n\\t\\t\\n\\t\\t# Traverse the list2 till end node\\n        while list2.next!=None:\\n            list2 = list2.next\\n\\t\\t\\n\\t\\t# Assign the next of pointer 2 to the next of list2 i.e connect the remaining part of list1 to list2\\n        list2.next = ptr2.next\\n\\t\\t\\n\\t\\t# return final list\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098242,
                "title": "python-99-50-beats-t-o-n",
                "content": "```\\n\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        head = list1\\n        for _ in range(a-1):\\n            head = head.next\\n        cur = head.next\\n        for _ in range(b-a):\\n            cur = cur.next\\n        head.next = list2\\n        while head.next:\\n            head = head.next\\n        if cur.next:\\n            head.next = cur.next\\n        return list1\\n```\\nPlease upvote if you get it.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        head = list1\\n        for _ in range(a-1):\\n            head = head.next\\n        cur = head.next\\n        for _ in range(b-a):\\n            cur = cur.next\\n        head.next = list2\\n        while head.next:\\n            head = head.next\\n        if cur.next:\\n            head.next = cur.next\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952004,
                "title": "c-straightforward-o-n",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nFind the following pointers:\\n* `p` where `p->next` points to `a`th node.\\n* `q` where `p` points to `b`th node.\\n\\nThen we can stitch them together by assigning:\\n* `B` to `p->next`\\n* `q->next` to the `next` pointer of `B`\\'s tail node.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-40/problems/merge-in-between-linked-lists/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* A, int a, int b, ListNode* B) {\\n        ListNode *q = A, *p = NULL;\\n        for (int i = 0; i < b; ++i) {\\n            if (i == a - 1) p = q;\\n            q = q->next;\\n        }\\n        p->next = B;\\n        while (B->next) B = B->next;\\n        B->next = q->next;\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-40/problems/merge-in-between-linked-lists/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* A, int a, int b, ListNode* B) {\\n        ListNode *q = A, *p = NULL;\\n        for (int i = 0; i < b; ++i) {\\n            if (i == a - 1) p = q;\\n            q = q->next;\\n        }\\n        p->next = B;\\n        while (B->next) B = B->next;\\n        B->next = q->next;\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971160,
                "title": "c-solution-don-t-forget-to-free-memory-for-removed-nodes",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        int splitPosition = 0;\\n        ListNode* current = list1;\\n        while(splitPosition != a - 1)\\n        {\\n            current = current->next;\\n            splitPosition++;\\n        }\\n        \\n        ListNode* removeNodes = current->next;\\n        current->next = list2;\\n        splitPosition++;\\n        \\n        while(splitPosition != b + 1)\\n        {\\n            ListNode* deleteNode = removeNodes;\\n            removeNodes = removeNodes->next;\\n            delete deleteNode; \\n            splitPosition++;\\n        }\\n        \\n        ListNode* endNodeOfList2 = list2;\\n        while(endNodeOfList2->next != NULL)\\n            endNodeOfList2 = endNodeOfList2->next;\\n        \\n        endNodeOfList2->next = removeNodes;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        int splitPosition = 0;\\n        ListNode* current = list1;\\n        while(splitPosition != a - 1)\\n        {\\n            current = current->next;\\n            splitPosition++;\\n        }\\n        \\n        ListNode* removeNodes = current->next;\\n        current->next = list2;\\n        splitPosition++;\\n        \\n        while(splitPosition != b + 1)\\n        {\\n            ListNode* deleteNode = removeNodes;\\n            removeNodes = removeNodes->next;\\n            delete deleteNode; \\n            splitPosition++;\\n        }\\n        \\n        ListNode* endNodeOfList2 = list2;\\n        while(endNodeOfList2->next != NULL)\\n            endNodeOfList2 = endNodeOfList2->next;\\n        \\n        endNodeOfList2->next = removeNodes;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455238,
                "title": "c-straight-forward-code-simplest-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *ptr=list1;\\n         ListNode *ptr2=list1;\\n        while(a>1)\\n        {\\n            a--;\\n            ptr=ptr->next;\\n        }\\n        while(b)\\n        {\\n            ptr2=ptr2->next;\\n            b--;\\n        }\\n        ptr->next=list2;\\n        while(ptr->next)\\n        {\\n            ptr=ptr->next;\\n        }\\n         ptr->next=ptr2->next;\\n        return list1;\\n    }\\n};\\n```\\nPlz upvote, it means a lot.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *ptr=list1;\\n         ListNode *ptr2=list1;\\n        while(a>1)\\n        {\\n            a--;\\n            ptr=ptr->next;\\n        }\\n        while(b)\\n        {\\n            ptr2=ptr2->next;\\n            b--;\\n        }\\n        ptr->next=list2;\\n        while(ptr->next)\\n        {\\n            ptr=ptr->next;\\n        }\\n         ptr->next=ptr2->next;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952256,
                "title": "java-two-pointer-approach",
                "content": "```\\n public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        if(list1 == null || list2 == null){\\n            return null;\\n        }\\n        ListNode slow,fast;\\n        slow=list1;\\n        fast=list1;\\n        int k=b-a+1;\\n        for(int i=0;i<k;i++)\\n            fast=fast.next;\\n        \\n        for(int i=1;i<a;i++)\\n\\t\\t{ \\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        slow.next=list2;\\n        while(list2.next!=null)\\n            list2=list2.next;\\n\\t\\t\\t\\n        list2.next=fast.next;\\n        \\n        return list1;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        if(list1 == null || list2 == null){\\n            return null;\\n        }\\n        ListNode slow,fast;\\n        slow=list1;\\n        fast=list1;\\n        int k=b-a+1;\\n        for(int i=0;i<k;i++)\\n            fast=fast.next;\\n        \\n        for(int i=1;i<a;i++)\\n\\t\\t{ \\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        slow.next=list2;\\n        while(list2.next!=null)\\n            list2=list2.next;\\n\\t\\t\\t\\n        list2.next=fast.next;\\n        \\n        return list1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2328182,
                "title": "python-simple-maths",
                "content": "\\n    def mergeInBetween(self, list1, a, b, list2):\\n        cur1, cur2, res1, res2 = list1, list2, [], []\\n        \\n        while cur1:\\n            res1.append(cur1.val)\\n            cur1 = cur1.next\\n            \\n        while cur2:\\n            res2.append(cur2.val)\\n            cur2 = cur2.next\\n                \\n        res = res1[:a] + res2 + res1[b+1:]\\n        \\n        r1 = r2 = ListNode()\\n        \\n        for i in res:\\n            r1.next = ListNode(i)\\n            r1 = r1.next\\n            \\n        return r2.next",
                "solutionTags": [],
                "code": "\\n    def mergeInBetween(self, list1, a, b, list2):\\n        cur1, cur2, res1, res2 = list1, list2, [], []\\n        \\n        while cur1:\\n            res1.append(cur1.val)\\n            cur1 = cur1.next\\n            \\n        while cur2:\\n            res2.append(cur2.val)\\n            cur2 = cur2.next\\n                \\n        res = res1[:a] + res2 + res1[b+1:]\\n        \\n        r1 = r2 = ListNode()\\n        \\n        for i in res:\\n            r1.next = ListNode(i)\\n            r1 = r1.next\\n            \\n        return r2.next",
                "codeTag": "Python3"
            },
            {
                "id": 1633126,
                "title": "c-linked-list-to-vector-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        vector<int> nums1, nums2, res;\\n        ListNode* temp1 = list1, *temp2 = list2;\\n        while(temp1 != NULL)\\n            nums1.push_back(temp1->val), temp1 = temp1->next;\\n        \\n        while(temp2 != NULL)\\n            nums2.push_back(temp2->val), temp2 = temp2->next;\\n        \\n        \\n        for(int i = 0; i < a; i++)\\n            res.push_back(nums1[i]);\\n        for(int i = 0; i < nums2.size(); i++)\\n            res.push_back(nums2[i]);\\n        for(int i = b+1; i < nums1.size(); i++)\\n            res.push_back(nums1[i]);\\n        \\n        ListNode* head = new ListNode(0), *curr = head;\\n        int i = 0;\\n        while(i < res.size()){\\n            curr->next = new ListNode(res[i++]);\\n            curr = curr->next;\\n        }\\n        \\n        return head->next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        vector<int> nums1, nums2, res;\\n        ListNode* temp1 = list1, *temp2 = list2;\\n        while(temp1 != NULL)\\n            nums1.push_back(temp1->val), temp1 = temp1->next;\\n        \\n        while(temp2 != NULL)\\n            nums2.push_back(temp2->val), temp2 = temp2->next;\\n        \\n        \\n        for(int i = 0; i < a; i++)\\n            res.push_back(nums1[i]);\\n        for(int i = 0; i < nums2.size(); i++)\\n            res.push_back(nums2[i]);\\n        for(int i = b+1; i < nums1.size(); i++)\\n            res.push_back(nums1[i]);\\n        \\n        ListNode* head = new ListNode(0), *curr = head;\\n        int i = 0;\\n        while(i < res.size()){\\n            curr->next = new ListNode(res[i++]);\\n            curr = curr->next;\\n        }\\n        \\n        return head->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004652,
                "title": "java-1000-beats-0-n-3-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPLEASE UPVOTE ME \\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode curr = list1;\\n        ListNode NewNode1 = list1;\\n        ListNode NewNode2 = list1;\\n        \\n        for(int i=0; i<b; i++){\\n            if(i==a-1)  NewNode1 = curr;\\n            curr = curr.next;\\n        }\\n        NewNode2 = curr.next;\\n        NewNode1.next = list2;\\n        while(list2.next!=null){\\n            list2 = list2.next;\\n        } \\n        list2.next = NewNode2;\\n        return list1;\\n   \\n      \\n//         Another solution\\n\\n        // int count = 0;\\n        // ListNode curr = list1;\\n        // ListNode newVal = null;\\n        // while(curr!=null){\\n        //     if(count==b) newVal = curr.next;\\n        //     count++;\\n        //     curr = curr.next;\\n        // }\\n        // curr = list1; count=0;\\n        // while(curr!=null){\\n        //     count++;\\n        //     if(count==a) curr.next = list2;\\n        //     curr = curr.next; \\n        // }\\n        // curr = list1;\\n        // while(curr.next!=null){\\n        //     curr = curr.next;\\n        // }\\n        // curr.next = newVal;\\n        // return list1;\\n    }\\n}\\n//     same approach but using for loop\\n\\n        // ListNode head = list1;\\n        // for(int i = 1; i < a; i++) {\\n        //     head = head.next;\\n        // }\\n        // ListNode temp = head;\\n        // for(int i = 0; i < b-a+2; i++) {\\n        //     temp = temp.next;\\n        // }\\n        // ListNode temp2 = list2;\\n        // while(temp2.next != null) {\\n        //     temp2 = temp2.next;\\n        // }\\n        // head.next = list2;\\n        // temp2.next = temp;\\n        // return list1;\\n\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode curr = list1;\\n        ListNode NewNode1 = list1;\\n        ListNode NewNode2 = list1;\\n        \\n        for(int i=0; i<b; i++){\\n            if(i==a-1)  NewNode1 = curr;\\n            curr = curr.next;\\n        }\\n        NewNode2 = curr.next;\\n        NewNode1.next = list2;\\n        while(list2.next!=null){\\n            list2 = list2.next;\\n        } \\n        list2.next = NewNode2;\\n        return list1;\\n   \\n      \\n//         Another solution\\n\\n        // int count = 0;\\n        // ListNode curr = list1;\\n        // ListNode newVal = null;\\n        // while(curr!=null){\\n        //     if(count==b) newVal = curr.next;\\n        //     count++;\\n        //     curr = curr.next;\\n        // }\\n        // curr = list1; count=0;\\n        // while(curr!=null){\\n        //     count++;\\n        //     if(count==a) curr.next = list2;\\n        //     curr = curr.next; \\n        // }\\n        // curr = list1;\\n        // while(curr.next!=null){\\n        //     curr = curr.next;\\n        // }\\n        // curr.next = newVal;\\n        // return list1;\\n    }\\n}\\n//     same approach but using for loop\\n\\n        // ListNode head = list1;\\n        // for(int i = 1; i < a; i++) {\\n        //     head = head.next;\\n        // }\\n        // ListNode temp = head;\\n        // for(int i = 0; i < b-a+2; i++) {\\n        //     temp = temp.next;\\n        // }\\n        // ListNode temp2 = list2;\\n        // while(temp2.next != null) {\\n        //     temp2 = temp2.next;\\n        // }\\n        // head.next = list2;\\n        // temp2.next = temp;\\n        // return list1;\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257142,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        ListNode* start;\\n        ListNode* last;\\n        ListNode* curr = list1;\\n        \\n        int count = 1;\\n        \\n        while(curr){\\n            \\n            if(count == a) start = curr;\\n            if(count == b) last = curr->next->next;\\n            curr = curr->next;\\n            count++;\\n        }\\n        \\n        start->next = list2;\\n        curr = list2;\\n        while(curr->next){\\n            curr= curr->next;\\n        }\\n        curr->next = last;\\n        \\n        return list1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        ListNode* start;\\n        ListNode* last;\\n        ListNode* curr = list1;\\n        \\n        int count = 1;\\n        \\n        while(curr){\\n            \\n            if(count == a) start = curr;\\n            if(count == b) last = curr->next->next;\\n            curr = curr->next;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 952318,
                "title": "easy-understanding-c-explained",
                "content": "```\\n//list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* prev,*tail,*head=list1;\\n        int x=a-1;\\n        while(x--) head=head->next; \\n\\t\\t//prev and head is at index=3 i.e. val=2 of list1\\n        prev=head;\\n        b=b-a+1; //node that we have to delete\\n        while(b--) head=head->next;\\n\\t\\t//know head is at index=5 i.e. val=4 of list1\\n        tail=head->next; //tail is at index=6 i.e. val=5 of list1 \\n        head->next=NULL;\\n\\t\\t//merge list2 in list1 with prev\\n        prev->next=list2;\\n        while(prev->next!=NULL){\\n            prev=prev->next;\\n        }\\n\\t\\t//prev is the know the last element of list2\\n\\t\\t//join it with list1(tail)\\n        prev->next=tail;\\n        return list1;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* prev,*tail,*head=list1;\\n        int x=a-1;\\n        while(x--) head=head->next; \\n\\t\\t//prev and head is at index=3 i.e. val=2 of list1\\n        prev=head;\\n        b=b-a+1; //node that we have to delete\\n        while(b--) head=head->next;\\n\\t\\t//know head is at index=5 i.e. val=4 of list1\\n        tail=head->next; //tail is at index=6 i.e. val=5 of list1 \\n        head->next=NULL;\\n\\t\\t//merge list2 in list1 with prev\\n        prev->next=list2;\\n        while(prev->next!=NULL){\\n            prev=prev->next;\\n        }\\n\\t\\t//prev is the know the last element of list2\\n\\t\\t//join it with list1(tail)\\n        prev->next=tail;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952006,
                "title": "python-straightforward",
                "content": "Find the node before a and after b in the `list1`, then fix the next pointers to join `prea` and `postb` nodes with `list2`:\\n```\\ndef mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n\\tprea = postb = None\\n\\tdummy = cur = ListNode(next=list1)\\n\\tfor i in range(b+1):\\n\\t\\tif i == a: prea = cur\\n\\t\\tcur = cur.next\\n\\tpostb = cur.next\\n\\n\\tprea.next = list2\\n\\twhile list2.next:\\n\\t\\tlist2 = list2.next\\n\\n\\tlist2.next = postb\\n\\treturn dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n\\tprea = postb = None\\n\\tdummy = cur = ListNode(next=list1)\\n\\tfor i in range(b+1):\\n\\t\\tif i == a: prea = cur\\n\\t\\tcur = cur.next\\n\\tpostb = cur.next\\n\\n\\tprea.next = list2\\n\\twhile list2.next:\\n\\t\\tlist2 = list2.next\\n\\n\\tlist2.next = postb\\n\\treturn dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3336825,
                "title": "java-solution-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe naive approach of the solution is that, we declare a new linked list and copy the `list1` in new list upto `a` and the further traverse `list2` and copy them in the new linked list and again traverse `list1` upto `b` and start copying and then finally return the head of the new linked list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe step by step approach to solve this problem is described below:\\n1. First traverse list1 upto `a-1` and store its address at `curr1` and again traverse the same `list1` upto position b and store its address at `curr2`.\\n2. Set the `curr1 next` address as the starting address of `list2`.\\n3. Further traverse `list2` upto the last node and finally set the next of last node of `list2` as `curr2 next.`\\n4. Return `list1.`\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n is the length of the `list1`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n***KINDLY UPVOTE THIS SOLUTION.***\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i=1;\\n        ListNode curr1=list1, curr2=list1;\\n    // Traversing list1 to store address of a-1 in curr1\\n        while(i<a){\\n            curr1=curr1.next;\\n            i++;\\n        }\\n        i=0;\\n    //Traversing list2 to store address of b in curr2\\n        while(i<b){\\n            curr2=curr2.next;\\n            i++;\\n        }\\n    //curr1\\'s next store the starting address of list2\\n        curr1.next=list2;\\n    // Traversing list2 to reach the last node\\n        while(list2.next!=null)\\n            list2=list2.next;\\n    // The last node of list2 next value should store the address of curr2.next\\n        list2.next=curr2.next;\\n        return list1;\\n    }\\n}\\nKINDLY UPVOTE THIS SOLUTION IF YOU FIND IT USEFUL.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i=1;\\n        ListNode curr1=list1, curr2=list1;\\n    // Traversing list1 to store address of a-1 in curr1\\n        while(i<a){\\n            curr1=curr1.next;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3263700,
                "title": "easy-to-understand-beats-100-o-n-time-complexity-java-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n- O(n+m)\\n\\n\\n- Space complexity:\\n- O(1)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i=0;\\n        // CREATE A TEMPORARY NODE FOR LIST1\\n        ListNode temp=list1;\\n        // TRAVERSE TILL A-1 INDEX TO JOIN IT WITH STARTING NODE OF LIST2\\n        while(i<a-1)\\n        {\\n            temp = temp.next;\\n            i++;\\n        }\\n        i=0;\\n        // CREATE A TEMPORARY NODE FOR LIST2\\n        ListNode temp2 = list1;\\n        // TRAVERSE TILL BTH INDEX TO JOIN  LAST NODE OF LIST2  WITH BTH INDEX\\n        while(i<b)\\n        {\\n            temp2=temp2.next;\\n            i++;\\n        }\\n        ListNode temp3 = list2;\\n        // REACH TILL LAST NODE OF LIST2\\n        while(temp3.next!=null)\\n            temp3=temp3.next;\\n        // JOIN RESPECTIVE NODE TO EACH OTHER\\n        temp.next = list2;\\n`       temp3.next = temp2.next;\\n        return list1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i=0;\\n        // CREATE A TEMPORARY NODE FOR LIST1\\n        ListNode temp=list1;\\n        // TRAVERSE TILL A-1 INDEX TO JOIN IT WITH STARTING NODE OF LIST2\\n        while(i<a-1)\\n        {\\n            temp = temp.next;\\n            i++;\\n        }\\n        i=0;\\n        // CREATE A TEMPORARY NODE FOR LIST2\\n        ListNode temp2 = list1;\\n        // TRAVERSE TILL BTH INDEX TO JOIN  LAST NODE OF LIST2  WITH BTH INDEX\\n        while(i<b)\\n        {\\n            temp2=temp2.next;\\n            i++;\\n        }\\n        ListNode temp3 = list2;\\n        // REACH TILL LAST NODE OF LIST2\\n        while(temp3.next!=null)\\n            temp3=temp3.next;\\n        // JOIN RESPECTIVE NODE TO EACH OTHER\\n        temp.next = list2;\\n`       temp3.next = temp2.next;\\n        return list1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520616,
                "title": "java-c-single-loop-minimalistic-readable-code-w-comments-explanation",
                "content": "**Example :  list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]**\\n\\t\\n\\t- - Pick the previous node where a = 3th . prevStart = 2\\n\\t- - Pick the after node where b = 4th . postEnd = 4\\n\\t- - Then assign node 2 -> list2 and find last node of list2\\n\\t- - Then assign to the last node to rest of the list1. 2 -> list2 ->5\\n\\t\\n```\\npublic ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2)\\n        {\\n\\t\\t\\tListNode cur = list1, prevStart = null, postEnd = null;\\n\\n            while (cur.next != null)\\n            {\\n\\t\\t\\t\\t// find previous node from where removing start\\n                if (--a == 0)\\n                    prevStart = cur;\\n\\t\\t\\t\\t\\n                if (b-- == 0)\\n                {\\n                    postEnd = cur.next;  // find after the removing node\\n                    cur = prevStart;  // cur node assign to the start position of remove\\n                    prevStart.next = list2; // assign list2 from the start position of removing\\n                }\\n                cur = cur.next;\\n            }\\n            cur.next = postEnd; // assign remain nodes of list1 \\n            return list1;\\n        }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2)\\n        {\\n\\t\\t\\tListNode cur = list1, prevStart = null, postEnd = null;\\n\\n            while (cur.next != null)\\n            {\\n\\t\\t\\t\\t// find previous node from where removing start\\n                if (--a == 0)\\n                    prevStart = cur;\\n\\t\\t\\t\\t\\n                if (b-- == 0)\\n                {\\n                    postEnd = cur.next;  // find after the removing node\\n                    cur = prevStart;  // cur node assign to the start position of remove\\n                    prevStart.next = list2; // assign list2 from the start position of removing\\n                }\\n                cur = cur.next;\\n            }\\n            cur.next = postEnd; // assign remain nodes of list1 \\n            return list1;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1337588,
                "title": "c-clean-code-explained-easy-to-understand",
                "content": "I have used 3 pointers for the soution of this problem one pointer will be one node behind the point of merging in list 1 and second pointer will be on node ahead of the last point of merging. My 3rd pointer will be at the last point of my list 2 and then after having these 3 pointers we can perform the merge operation like a piece of cake.\\n\\n\\n```\\nListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        a=a-1;\\n        b=b+1;\\n        ListNode *start=list1;\\n        ListNode *end=list1;\\n        ListNode *tail=list2;\\n        while(a--)\\n        {\\n            start=start->next;\\n        }\\n        while(b--)\\n        {\\n            end=end->next;\\n        }\\n        while(tail->next!=NULL)\\n        {\\n            tail=tail->next;\\n        }\\n        start->next=list2;\\n        tail->next=end;\\n        \\n        \\n        return list1;\\n    }\\n    ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        a=a-1;\\n        b=b+1;\\n        ListNode *start=list1;\\n        ListNode *end=list1;\\n        ListNode *tail=list2;\\n        while(a--)\\n        {\\n            start=start->next;\\n        }\\n        while(b--)\\n        {\\n            end=end->next;\\n        }\\n        while(tail->next!=NULL)\\n        {\\n            tail=tail->next;\\n        }\\n        start->next=list2;\\n        tail->next=end;\\n        \\n        \\n        return list1;\\n    }\\n    ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1109092,
                "title": "java-simple-and-easy-to-understand-soln-1-ms-faster-than-100-00-clean-code-with-comment",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode curr1 = list1;\\n        \\n        //find the ath prev node and bth next node of list 1\\n        ListNode athPrevNode = null;\\n        ListNode bthNextNode = null;\\n        int i = 0;\\n        while(curr1 != null){\\n            if(i == a - 1){\\n                athPrevNode = curr1;\\n            }\\n            \\n            if(i == b + 1){\\n                bthNextNode = curr1;\\n                break;\\n            }\\n            \\n            curr1 = curr1.next;\\n            i++;\\n        }\\n        \\n        //find last node of list 2\\n        ListNode curr2 = list2;\\n        while(curr2 != null && curr2.next != null){\\n            curr2 = curr2.next;\\n        }\\n        \\n        //now insert list2 in list 1\\n        athPrevNode.next = list2;\\n        curr2.next = bthNextNode;\\n        \\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode curr1 = list1;\\n        \\n        //find the ath prev node and bth next node of list 1\\n        ListNode athPrevNode = null;\\n        ListNode bthNextNode = null;\\n        int i = 0;\\n        while(curr1 != null){\\n            if(i == a - 1){\\n                athPrevNode = curr1;\\n            }\\n            \\n            if(i == b + 1){\\n                bthNextNode = curr1;\\n                break;\\n            }\\n            \\n            curr1 = curr1.next;\\n            i++;\\n        }\\n        \\n        //find last node of list 2\\n        ListNode curr2 = list2;\\n        while(curr2 != null && curr2.next != null){\\n            curr2 = curr2.next;\\n        }\\n        \\n        //now insert list2 in list 1\\n        athPrevNode.next = list2;\\n        curr2.next = bthNextNode;\\n        \\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094785,
                "title": "javascript-solution",
                "content": "```\\nvar mergeInBetween = function(list1, a, b, list2) {\\n    let start = list1;\\n    let end = list1;\\n    \\n    for (let i = 0; i <= b && start != null && end != null; i++) {\\n        if (i < a - 1) start = start.next;\\n        if (i <= b) end = end.next;\\n    }\\n    \\n    let tail = list2;\\n    \\n    while (tail.next != null) {\\n        tail = tail.next;\\n    }\\n    \\n    start.next = list2;\\n    tail.next = end;\\n    \\n    return list1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeInBetween = function(list1, a, b, list2) {\\n    let start = list1;\\n    let end = list1;\\n    \\n    for (let i = 0; i <= b && start != null && end != null; i++) {\\n        if (i < a - 1) start = start.next;\\n        if (i <= b) end = end.next;\\n    }\\n    \\n    let tail = list2;\\n    \\n    while (tail.next != null) {\\n        tail = tail.next;\\n    }\\n    \\n    start.next = list2;\\n    tail.next = end;\\n    \\n    return list1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016082,
                "title": "c-100-faster-and-100-efficient-most-efficient-linear-approach",
                "content": "**Code** -\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *slow = list1, *fast = list1, *temp = list2;\\n        while(--a){\\n            slow = slow -> next;\\n        }\\n        b += 2;\\n        while(--b){\\n            fast = fast -> next;\\n        }\\n        while(list2 -> next != nullptr){\\n            list2 = list2 -> next;\\n        }\\n        \\n        slow -> next = temp;\\n        list2 -> next = fast;\\n        return list1;\\n    }\\n};\\n```\\n\\n**Result**\\n\\n**Runtime**: **260 ms**, faster than **100.00%** of C++ online submissions for Merge In Between Linked Lists.\\n**Memory Usage**: **94.5 MB**, less than **100.00%** of C++ online submissions for Merge In Between Linked Lists.",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *slow = list1, *fast = list1, *temp = list2;\\n        while(--a){\\n            slow = slow -> next;\\n        }\\n        b += 2;\\n        while(--b){\\n            fast = fast -> next;\\n        }\\n        while(list2 -> next != nullptr){\\n            list2 = list2 -> next;\\n        }\\n        \\n        slow -> next = temp;\\n        list2 -> next = fast;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970171,
                "title": "python3-two-pointers-commented",
                "content": "```python\\ndef mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        pos, a_node = 0, list1\\n        while pos < a - 1:          # let a_node point to the list1 node at index a - 1\\n            a_node = a_node.next\\n            pos += 1\\n        b_node = a_node\\n        while pos < b + 1:          # let b_node point to the list1 node at index b + 1\\n            b_node = b_node.next\\n            pos += 1\\n        a_node.next = list2         # put list2 after a_node\\n        while list2.next:\\n            list2 = list2.next\\n        list2.next = b_node         # put list2 before b_node\\n        return list1                # return the head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        pos, a_node = 0, list1\\n        while pos < a - 1:          # let a_node point to the list1 node at index a - 1\\n            a_node = a_node.next\\n            pos += 1\\n        b_node = a_node\\n        while pos < b + 1:          # let b_node point to the list1 node at index b + 1\\n            b_node = b_node.next\\n            pos += 1\\n        a_node.next = list2         # put list2 after a_node\\n        while list2.next:\\n            list2 = list2.next\\n        list2.next = b_node         # put list2 before b_node\\n        return list1                # return the head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 957356,
                "title": "c",
                "content": "```\\npublic ListNode MergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n\\tListNode p1 = list1, p2 = list1;\\n\\twhile (--a > 0) p1 = p1.next;\\n\\twhile (b-- > 0) p2 = p2.next;\\n\\tp1.next = list2;\\n\\twhile (p1.next != null) p1 = p1.next;\\n\\tp1.next = p2.next;\\n\\treturn list1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode MergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n\\tListNode p1 = list1, p2 = list1;\\n\\twhile (--a > 0) p1 = p1.next;\\n\\twhile (b-- > 0) p2 = p2.next;\\n\\tp1.next = list2;\\n\\twhile (p1.next != null) p1 = p1.next;\\n\\tp1.next = p2.next;\\n\\treturn list1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952001,
                "title": "python3-o-m-n-time-o-1-space-solution",
                "content": "M -> len(list1)\\nN -> len(list2)\\n```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        list2_head = list2_tail = list2\\n        while list2_tail and list2_tail.next:\\n            list2_tail = list2_tail.next\\n            \\n        list1_head = list1\\n        for _ in range(a-1):\\n            list1_head = list1_head.next\\n            \\n        nxt = list1_head.next\\n        list1_head.next = list2_head\\n        list1_head = nxt\\n        \\n        for _ in range(a, b):\\n            list1_head = list1_head.next\\n            \\n        list2_tail.next = list1_head.next\\n        list1_head.next = None # Not necessary and is just for the sake of completeness and detaching the middle\\n        \\n        return list1\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        list2_head = list2_tail = list2\\n        while list2_tail and list2_tail.next:\\n            list2_tail = list2_tail.next\\n            \\n        list1_head = list1\\n        for _ in range(a-1):\\n            list1_head = list1_head.next\\n            \\n        nxt = list1_head.next\\n        list1_head.next = list2_head\\n        list1_head = nxt\\n        \\n        for _ in range(a, b):\\n            list1_head = list1_head.next\\n            \\n        list2_tail.next = list1_head.next\\n        list1_head.next = None # Not necessary and is just for the sake of completeness and detaching the middle\\n        \\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980071,
                "title": "simple-java-solution-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head = list1;\\n        for(int i = 1; i < a; i++) {\\n            head = head.next;\\n        }\\n        ListNode temp = head;\\n        for(int i = 0; i < b-a+2; i++) {\\n            temp = temp.next;\\n        }\\n        ListNode temp2 = list2;\\n        while(temp2.next != null) {\\n            temp2 = temp2.next;\\n        }\\n        head.next = list2;\\n        temp2.next = temp;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head = list1;\\n        for(int i = 1; i < a; i++) {\\n            head = head.next;\\n        }\\n        ListNode temp = head;\\n        for(int i = 0; i < b-a+2; i++) {\\n            temp = temp.next;\\n        }\\n        ListNode temp2 = list2;\\n        while(temp2.next != null) {\\n            temp2 = temp2.next;\\n        }\\n        head.next = list2;\\n        temp2.next = temp;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857405,
                "title": "best-c-solution-with-explanation-beginner-friendly-approach-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergePos(ListNode* node, int count){\\n        while(count--)\\n            node = node->next;\\n        return node;\\n    }\\n\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        // Step 1 - Find node before removal\\n        int count = 1;\\n        ListNode *temp = list1;\\n        while(count++ < a){\\n            temp = temp->next;\\n        }\\n\\n        // Step 2 - Find node to join after removal\\n        ListNode *pos = mergePos(temp->next, b-a+1);\\n\\n        // Step 3 - Merge list2 at the removed part of list1\\n        temp->next = list2;\\n        ListNode *list2Tail = list2;\\n        // find tail of list2 to later merge with list1\\n        while(list2Tail->next != NULL){\\n            list2Tail = list2Tail->next;\\n        }\\n        \\n        // Step 4 - Merge list2 with the list1 node after removal\\n        list2Tail->next = pos;\\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergePos(ListNode* node, int count){\\n        while(count--)\\n            node = node->next;\\n        return node;\\n    }\\n\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        // Step 1 - Find node before removal\\n        int count = 1;\\n        ListNode *temp = list1;\\n        while(count++ < a){\\n            temp = temp->next;\\n        }\\n\\n        // Step 2 - Find node to join after removal\\n        ListNode *pos = mergePos(temp->next, b-a+1);\\n\\n        // Step 3 - Merge list2 at the removed part of list1\\n        temp->next = list2;\\n        ListNode *list2Tail = list2;\\n        // find tail of list2 to later merge with list1\\n        while(list2Tail->next != NULL){\\n            list2Tail = list2Tail->next;\\n        }\\n        \\n        // Step 4 - Merge list2 with the list1 node after removal\\n        list2Tail->next = pos;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762469,
                "title": "simple-easy-to-understand-c-solution",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* fir=list1;\\n        ListNode* sec=list1;\\n        while(--a){\\n            fir=fir->next;\\n        }\\n        while(b--){\\n            sec=sec->next;\\n        }\\n        sec=sec->next;\\n        fir->next=list2;\\n        while(fir->next!=NULL){\\n            fir=fir->next;\\n        }\\n        fir->next=sec;\\n        return list1;\\n      }\\n    };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* fir=list1;\\n        ListNode* sec=list1;\\n        while(--a){\\n            fir=fir->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3473512,
                "title": "easy-java-fastest-beats-100-linkedlist-traversal-solution",
                "content": "# Approach\\n- Create two pointers pointing to list1 head.\\n- traverse the first pointer to the node after which list2 needs to be joined.\\n- take the second pointer to the node where the list2 end needs to be connected to list1\\'s second part.\\n- connect the first pointer to the list2\\n- traverse to the end of list2.\\n- Connect the list2 to second pointer,\\n- Return the head copy for the first list.\\n\\n# Complexity\\n- Time complexity:O(m+n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        // create the copy pointers and the return pointer\\n\\n        ListNode ret = list1;\\n        ListNode curr = list1;\\n        ListNode curr2 = list1;\\n        \\n        // Take the first pointer to location a. \\n        \\n        while(a>1){\\n            a--;\\n            curr = curr.next;\\n        }\\n        \\n        \\n        // take the second pointer ro location b.\\n\\n        while(b>0){\\n            b--;\\n            curr2 = curr2.next;\\n        }\\n        curr2 = curr2.next;\\n        \\n        // connecting first pointer to list2\\n\\n        curr.next = list2;\\n        \\n        // traverse thorugh list2 and connect the end to second pointer\\n\\n        while(list2.next!=null){\\n            list2 = list2.next;\\n        } \\n        list2.next = curr2;\\n        return ret;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        // create the copy pointers and the return pointer\\n\\n        ListNode ret = list1;\\n        ListNode curr = list1;\\n        ListNode curr2 = list1;\\n        \\n        // Take the first pointer to location a. \\n        \\n        while(a>1){\\n            a--;\\n            curr = curr.next;\\n        }\\n        \\n        \\n        // take the second pointer ro location b.\\n\\n        while(b>0){\\n            b--;\\n            curr2 = curr2.next;\\n        }\\n        curr2 = curr2.next;\\n        \\n        // connecting first pointer to list2\\n\\n        curr.next = list2;\\n        \\n        // traverse thorugh list2 and connect the end to second pointer\\n\\n        while(list2.next!=null){\\n            list2 = list2.next;\\n        } \\n        list2.next = curr2;\\n        return ret;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428332,
                "title": "easy-c-code-o-n-fully-explained-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ni Have solved merge two list problem on leetcode, so from their this method came in my mind.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link (a-1)th node to list2. list2 last node to (b+1)th node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(M+N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* t1 = list1;\\n        ListNode* t2 = list1;\\n        for(int i = 0; i < a-1; i++) // setting t1 at its correct place, that is , at (a-1) nodes from starting\\n        t1 = t1 -> next;\\n        for(int i = 0; i < b; i++) // setting t2 at its correct place, that is , at b nodes from starting \\n        t2 = t2 -> next;\\n        ListNode* temp = t2 -> next; // storing the track of rest of the list after b nodes\\n        t1 -> next = list2; // merging list2 in list1.\\n        ListNode* t3 = list2;\\n        while(t3 -> next != NULL)\\n        t3 = t3 -> next;\\n\\n        t3 -> next = temp; // t3->next is NULL, so merging the track of list1 after b nodes.\\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* t1 = list1;\\n        ListNode* t2 = list1;\\n        for(int i = 0; i < a-1; i++) // setting t1 at its correct place, that is , at (a-1) nodes from starting\\n        t1 = t1 -> next;\\n        for(int i = 0; i < b; i++) // setting t2 at its correct place, that is , at b nodes from starting \\n        t2 = t2 -> next;\\n        ListNode* temp = t2 -> next; // storing the track of rest of the list after b nodes\\n        t1 -> next = list2; // merging list2 in list1.\\n        ListNode* t3 = list2;\\n        while(t3 -> next != NULL)\\n        t3 = t3 -> next;\\n\\n        t3 -> next = temp; // t3->next is NULL, so merging the track of list1 after b nodes.\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384984,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode * l1a = list1;\\n        ListNode * l1b = list1;\\n        ListNode * l2  = list2;\\n        for(int i=1;i<a;i++){\\n            if(l1a->next) l1a = l1a->next;\\n        }\\n        for(int i=0;i<=b;i++){\\n            if(l1b) l1b = l1b->next;\\n        }\\n        l1a->next = l2;\\n        while(l2->next) l2=l2->next;\\n        l2->next = l1b;\\n        return list1;\\n    }\\n};\\n```\\n**Time Complexity : O(a+b+no. of nodes in list2)** \\n**Worst Case: O(list1+list2)**\\n**Space Complexity: O(1)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode * l1a = list1;\\n        ListNode * l1b = list1;\\n        ListNode * l2  = list2;\\n        for(int i=1;i<a;i++){\\n            if(l1a->next) l1a = l1a->next;\\n        }\\n        for(int i=0;i<=b;i++){\\n            if(l1b) l1b = l1b->next;\\n        }\\n        l1a->next = l2;\\n        while(l2->next) l2=l2->next;\\n        l2->next = l1b;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304529,
                "title": "simple-c-code-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *ptr = list1,*save = list1, *end = list2;\\n            \\n        for(int i=0;i<a-1;i++){\\n           // if(ptr==NULL) return NULL;\\n            ptr = ptr->next;\\n        }\\n        for(int i=0;i<=b;i++){\\n            save = save->next;\\n        }\\n        while(end->next!=NULL){\\n            end = end->next;\\n        }\\n        ptr->next = list2;\\n        \\n        end->next = save;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *ptr = list1,*save = list1, *end = list2;\\n            \\n        for(int i=0;i<a-1;i++){\\n           // if(ptr==NULL) return NULL;\\n            ptr = ptr->next;\\n        }\\n        for(int i=0;i<=b;i++){\\n            save = save->next;\\n        }\\n        while(end->next!=NULL){\\n            end = end->next;\\n        }\\n        ptr->next = list2;\\n        \\n        end->next = save;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268476,
                "title": "python3-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will get to the node before \\'a\\' th index and will link the next pointer to list 2 and using another loop will get to the \\'b\\' th node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will get to the \"a - 1\"th node (in code the first loop).\\n2. Link this to the first node of list2 but before that store the a\\'th node in a temporary variable.\\n3. Now we must visit the last node of list2 which we have linked to the list1\\n```\\nwhile itr.next:\\n    itr = itr.next\\n```\\n4. Now we have to find the b\\'th node (using temporary variable node) and linked the \\'b + 1\\'th to the list got from Step 2.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nm)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        itr = list1\\n        cnt = 0\\n        while itr:\\n            if cnt == a - 1:\\n                node = itr.next\\n                itr.next = list2\\n                while itr.next:\\n                    itr = itr.next\\n                \\n                while node:\\n                    if cnt == b:\\n                        itr.next = node\\n                        break\\n                    else:\\n                        node = node.next\\n                        cnt += 1\\n            else:\\n                cnt += 1\\n                itr = itr.next\\n        return list1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nwhile itr.next:\\n    itr = itr.next\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        itr = list1\\n        cnt = 0\\n        while itr:\\n            if cnt == a - 1:\\n                node = itr.next\\n                itr.next = list2\\n                while itr.next:\\n                    itr = itr.next\\n                \\n                while node:\\n                    if cnt == b:\\n                        itr.next = node\\n                        break\\n                    else:\\n                        node = node.next\\n                        cnt += 1\\n            else:\\n                cnt += 1\\n                itr = itr.next\\n        return list1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876686,
                "title": "java",
                "content": "if u like it pls upvote\\n\\n```\\n\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode left;\\n        ListNode res = new ListNode(-1);\\n        left = res;\\n\\n        for (int i = 0; i < a; i++) {\\n            left.next = new ListNode(list1.val);\\n            left = left.next;\\n            list1 = list1.next;\\n        }\\n\\n        while (list2 != null) {\\n            left.next = new ListNode(list2.val);\\n            left = left.next;\\n            list2 = list2.next;\\n        }\\n\\n        while (list1 != null) {\\n            if (list1.val > b) {\\n                left.next = new ListNode(list1.val);\\n                left = left.next;\\n            }\\n            list1 = list1.next;\\n        }\\n\\n        return res.next;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode left;\\n        ListNode res = new ListNode(-1);\\n        left = res;\\n\\n        for (int i = 0; i < a; i++) {\\n            left.next = new ListNode(list1.val);\\n            left = left.next;\\n            list1 = list1.next;\\n        }\\n\\n        while (list2 != null) {\\n            left.next = new ListNode(list2.val);\\n            left = left.next;\\n            list2 = list2.next;\\n        }\\n\\n        while (list1 != null) {\\n            if (list1.val > b) {\\n                left.next = new ListNode(list1.val);\\n                left = left.next;\\n            }\\n            list1 = list1.next;\\n        }\\n\\n        return res.next;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2855496,
                "title": "java-solution-100-faster-in-o-n-time-and-o-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i=0;\\n        ListNode t1=list1;\\n        ListNode t2=list1;\\n        while(i<a-1){\\n            i++;\\n            t1=t1.next;\\n        }\\n        i=0;\\n        while(i<b){\\n            i++;\\n            t2=t2.next;\\n        }\\n        t2=t2.next;\\n        ListNode last=list2;\\n        while(last.next!=null){\\n            last=last.next;\\n        }\\n        t1.next=list2;\\n        last.next=t2;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i=0;\\n        ListNode t1=list1;\\n        ListNode t2=list1;\\n        while(i<a-1){\\n            i++;\\n            t1=t1.next;\\n        }\\n        i=0;\\n        while(i<b){\\n            i++;\\n            t2=t2.next;\\n        }\\n        t2=t2.next;\\n        ListNode last=list2;\\n        while(last.next!=null){\\n            last=last.next;\\n        }\\n        t1.next=list2;\\n        last.next=t2;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223098,
                "title": "c-solution-merge-in-between-linked-lists",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *temp1 = list1;\\n        ListNode *temp2 = list1;\\n        \\n        a--;\\n        while(a--){\\n            temp1 = temp1->next;\\n        }\\n        \\n        while(b--){\\n            temp2 = temp2->next;\\n        }\\n        \\n        temp1->next = list2;\\n        while(temp1->next != NULL){\\n            temp1 = temp1->next;\\n        }\\n        \\n        temp1->next = temp2->next;\\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *temp1 = list1;\\n        ListNode *temp2 = list1;\\n        \\n        a--;\\n        while(a--){\\n            temp1 = temp1->next;\\n        }\\n        \\n        while(b--){\\n            temp2 = temp2->next;\\n        }\\n        \\n        temp1->next = list2;\\n        while(temp1->next != NULL){\\n            temp1 = temp1->next;\\n        }\\n        \\n        temp1->next = temp2->next;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833998,
                "title": "python3-explanation-example",
                "content": "**Idea:** Given the integer a and integer b we first Traversal a node of list1 then save the pointer suppose in `start`. Then continue traversal to b node. We point `start` to list2 and we traversal list2 to the end and point end of list2 to b.\\n\\n**Example:**\\n```\\nlist1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\\n \\n(i) First do traversal of a node(3 node). so we travel 0->1->2.\\n\\tNow save the pointer in start. \\n(ii) Continue Traversal of list to b node(4 node). \\n\\tso 0->1->2->3.\\n(iii) Now point start to list2. \\n\\t so, 0->1->2->1000000->1000001->1000002.\\n(iv) Now do travesal of list2. and map end of list2 to b, \\n\\t so, 0->1->2->1000000->1000001->1000002->5.\\n```\\n\\n**Code:**\\n```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        curr=list1\\n        for count in range(b):\\n            if count==a-1:      # travel to a node and   --> step 1\\n                start=curr      # then save pointer in start\\n            curr=curr.next   # continue travel to b node  --> step 2\\n        start.next=list2     # point start to list2   --> step3\\n        while list2.next:    # travel list2   --> step 4\\n            list2=list2.next\\n        list2.next=curr.next  # map end of list2 to b\\n        return list1\\n```\\nUpvote if you find it helpful :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nlist1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\\n \\n(i) First do traversal of a node(3 node). so we travel 0->1->2.\\n\\tNow save the pointer in start. \\n(ii) Continue Traversal of list to b node(4 node). \\n\\tso 0->1->2->3.\\n(iii) Now point start to list2. \\n\\t so, 0->1->2->1000000->1000001->1000002.\\n(iv) Now do travesal of list2. and map end of list2 to b, \\n\\t so, 0->1->2->1000000->1000001->1000002->5.\\n```\n```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        curr=list1\\n        for count in range(b):\\n            if count==a-1:      # travel to a node and   --> step 1\\n                start=curr      # then save pointer in start\\n            curr=curr.next   # continue travel to b node  --> step 2\\n        start.next=list2     # point start to list2   --> step3\\n        while list2.next:    # travel list2   --> step 4\\n            list2=list2.next\\n        list2.next=curr.next  # map end of list2 to b\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730588,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        auto temp1 = list1;\\n        auto temp2 = list1;\\n        for(int i=0;i<a-1;i++){\\n            temp1 = temp1->next;\\n            temp2 = temp2->next;\\n        }\\n        for(int i=a;i<=b;i++)\\n            temp2 = temp2->next;\\n        temp1->next = list2;\\n        while(list2->next)\\n            list2=list2->next;\\n        list2->next = temp2->next;\\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        auto temp1 = list1;\\n        auto temp2 = list1;\\n        for(int i=0;i<a-1;i++){\\n            temp1 = temp1->next;\\n            temp2 = temp2->next;\\n        }\\n        for(int i=a;i<=b;i++)\\n            temp2 = temp2->next;\\n        temp1->next = list2;\\n        while(list2->next)\\n            list2=list2->next;\\n        list2->next = temp2->next;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566863,
                "title": "java-11-lines-best-solution-here-comments",
                "content": "Simple two pointer approach, no fast slow needed.\\n```java\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2){\\n        ListNode dummy = new ListNode(0), p = dummy;\\n        p.next = list1;\\n        \\n        // move p to node before position a, set next of this node to list 2, set t to p.next\\n        for (int i = 0 ; i < a; i++) p = p.next;\\n        ListNode t = p.next;\\n        p.next = list2;\\n        \\n        // move t to node at position b, move p to last node in list 2 and connect p to t.next\\n        for (int i = 0; i < b-a; i++) t = t.next;\\n        while (p.next != null) p = p.next;\\n        p.next = t.next;\\n\\t\\t\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2){\\n        ListNode dummy = new ListNode(0), p = dummy;\\n        p.next = list1;\\n        \\n        // move p to node before position a, set next of this node to list 2, set t to p.next\\n        for (int i = 0 ; i < a; i++) p = p.next;\\n        ListNode t = p.next;\\n        p.next = list2;\\n        \\n        // move t to node at position b, move p to last node in list 2 and connect p to t.next\\n        for (int i = 0; i < b-a; i++) t = t.next;\\n        while (p.next != null) p = p.next;\\n        p.next = t.next;\\n\\t\\t\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487824,
                "title": "java-solution",
                "content": "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n\\t\\n\\t\\n        ListNode temp1=list1;\\n        ListNode temp2=list1;\\n        int h=Math.max(a,b);\\n        int s=Math.min(a,b);\\n        System.out.println(s);\\n        int i =0;\\n        while(temp1!=null && i!=s-1 ){//now here we will stop early by one\\n            temp1=temp1.next;\\n            i++;\\n        }\\n        int j =0;\\n        while(temp2!=null && j!=h){//here we stop on the node\\n            temp2=temp2.next;\\n            j++;\\n        }\\n        temp1.next=list2;\\n        ListNode temp= list2;\\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        temp.next=temp2.next;\\n        \\n        return list1;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n\\t\\n\\t\\n        ListNode temp1=list1;\\n        ListNode temp2=list1;\\n        int h=Math.max(a,b);\\n        int s=Math.min(a,b);\\n        System.out.println(s);\\n        int i =0;\\n        while(temp1!=null && i!=s-1 ){//now here we will stop early by one\\n            temp1=temp1.next;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1412901,
                "title": "c-simple-easy-aproach",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2){\\n        ListNode *temp1=list1, *temp2=list1;\\n        int cnt=0;\\n        for(int i=0;i<=b;i++){\\n            if(cnt<a-1){\\n                temp1=temp1->next;\\n            }\\n            temp2=temp2->next;\\n            cnt++;\\n        }\\n        ListNode *ptr=list2;\\n        temp1->next=list2;\\n        while(ptr->next!=NULL){\\n            ptr=ptr->next;\\n        }\\n        ptr->next=temp2;\\n        return list1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2){\\n        ListNode *temp1=list1, *temp2=list1;\\n        int cnt=0;\\n        for(int i=0;i<=b;i++){\\n            if(cnt<a-1){\\n                temp1=temp1->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1388152,
                "title": "c-easy-understanding-solution-better-than-90-both-in-time-as-well-as-space-with-explanation",
                "content": "//first we will made some additional nodes that we will use to store the position corresponding to //previous node of a and next node of b ,after travelling through linked list we are having our position //and after that it is just if lse we will have an if that if a==0  that\\'s the first node and the two //conditions inside it that either the b is last node or not and same condition with else\\n//i hope the code is understandable if face any issue or find mistake in code or nice approach please //write in comments thanks.\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        ListNode *temp=list1;\\n        ListNode *prev1,*prev2;\\n        int c=0;\\n        while(temp!=NULL){\\n            if(c==a-1){\\n                prev1=temp;\\n            }\\n            if(c==b){\\n                prev2=temp->next;\\n            }\\n            c++;\\n             temp=temp->next;\\n      \\n        }\\n        \\n        ListNode * temp1=list2;\\n        while(temp1->next!=NULL){\\n            temp1=temp1->next;\\n        }\\n     \\n        if(a==0){\\n            if(prev2==NULL){\\n                return list2;\\n            }\\n            else{\\n                list1->next=list2;\\n                temp1->next=prev2;\\n                return list1->next;\\n            }\\n        }\\n        else{\\n            if(prev2==NULL){\\n                prev1->next=list2;\\n                return list1;\\n            }\\n            else{\\n                prev1->next=list2;\\n                temp1->next=prev2;\\n                return list1;\\n                \\n            }\\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        ListNode *temp=list1;\\n        ListNode *prev1,*prev2;\\n        int c=0;\\n        while(temp!=NULL){\\n            if(c==a-1){\\n                prev1=temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1387631,
                "title": "python3-85-2-pointer-solution-o-n-o-1-space",
                "content": "```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n\\n        point1 = list1\\n        point2 = list1\\n        for _ in range(b - a):\\n            point2 = point2.next\\n        prev = None\\n        for _ in range(a):\\n            prev = point1\\n            point1 = point1.next\\n            point2 = point2.next\\n        \\n        prev.next = list2\\n        while list2.next:\\n            list2 = list2.next\\n        list2.next = point2.next\\n        \\n        return list1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n\\n        point1 = list1\\n        point2 = list1\\n        for _ in range(b - a):\\n            point2 = point2.next\\n        prev = None\\n        for _ in range(a):\\n            prev = point1\\n            point1 = point1.next\\n            point2 = point2.next\\n        \\n        prev.next = list2\\n        while list2.next:\\n            list2 = list2.next\\n        list2.next = point2.next\\n        \\n        return list1",
                "codeTag": "Java"
            },
            {
                "id": 1385262,
                "title": "easy-python-solution-faster-than-80-14",
                "content": "```\\nstart=head\\nk=0\\nwhile start!=None:\\n\\tif k==a-1:\\n\\t\\tfur=start.next\\n\\t\\tstart.next=list2\\n\\t\\tstart2=list2\\n\\t\\twhile start2.next!=None:\\n\\t\\t\\tstart2=start2.next\\n\\t\\tk2=a\\n\\t\\twhile(fur!=None):\\n\\t\\t\\tif k2==b:\\n\\t\\t\\t\\tif (fur.next!=None):\\n\\t\\t\\t\\t\\tstart2.next=fur.next\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstart2.next=None\\n\\t\\t\\tk2+=1\\n\\t\\t\\tfur=fur.next\\n\\t\\treturn head\\n\\tk+=1\\n\\tstart=start.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nstart=head\\nk=0\\nwhile start!=None:\\n\\tif k==a-1:\\n\\t\\tfur=start.next\\n\\t\\tstart.next=list2\\n\\t\\tstart2=list2\\n\\t\\twhile start2.next!=None:\\n\\t\\t\\tstart2=start2.next\\n\\t\\tk2=a\\n\\t\\twhile(fur!=None):\\n\\t\\t\\tif k2==b:\\n\\t\\t\\t\\tif (fur.next!=None):\\n\\t\\t\\t\\t\\tstart2.next=fur.next\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstart2.next=None\\n\\t\\t\\tk2+=1\\n\\t\\t\\tfur=fur.next\\n\\t\\treturn head\\n\\tk+=1\\n\\tstart=start.next\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1294348,
                "title": "golang-solution-faster-than-100",
                "content": "```\\nfunc mergeInBetween(list1 *ListNode, a int, b int, list2 *ListNode) *ListNode {\\n    curr := list1\\n    curr2 := list2\\n    var endofL2 *ListNode\\n    count := 0\\n    \\n    for curr2 != nil{\\n        if curr2.Next == nil{\\n            endofL2 = curr2\\n        }\\n        curr2 = curr2.Next\\n    }\\n    \\n    for curr != nil{\\n        if count == a-1{\\n            afterRemoved := curr\\n            \\n            for i := 0 ; i < b-a+2 ; i++{\\n                afterRemoved = afterRemoved.Next\\n            }\\n            \\n            curr.Next = list2\\n            endofL2.Next = afterRemoved\\n            return list1\\n        }\\n        count++\\n        curr = curr.Next\\n    }\\n    return &ListNode{}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mergeInBetween(list1 *ListNode, a int, b int, list2 *ListNode) *ListNode {\\n    curr := list1\\n    curr2 := list2\\n    var endofL2 *ListNode\\n    count := 0\\n    \\n    for curr2 != nil{\\n        if curr2.Next == nil{\\n            endofL2 = curr2\\n        }\\n        curr2 = curr2.Next\\n    }\\n    \\n    for curr != nil{\\n        if count == a-1{\\n            afterRemoved := curr\\n            \\n            for i := 0 ; i < b-a+2 ; i++{\\n                afterRemoved = afterRemoved.Next\\n            }\\n            \\n            curr.Next = list2\\n            endofL2.Next = afterRemoved\\n            return list1\\n        }\\n        count++\\n        curr = curr.Next\\n    }\\n    return &ListNode{}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1250830,
                "title": "java-linkedlist-1ms-beats-100-t-c-o-b-list2-size",
                "content": "\\t\\n\\t// O(b + list2.size)\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        ListNode temp1 = list1;\\n        for(int i = 0; i < a - 1; i++)\\n            temp1 = temp1.next;\\n        \\n        int total = b - a + 1;\\n        ListNode temp2 = temp1;\\n        for(int i = 0; i <= total; i++)\\n            temp2 = temp2.next;\\n        \\n        temp1.next = list2;\\n        while(temp1.next != null)\\n            temp1 = temp1.next;\\n        \\n        temp1.next = temp2;\\n        return list1;\\n    }",
                "solutionTags": [],
                "code": "\\t\\n\\t// O(b + list2.size)\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        ListNode temp1 = list1;\\n        for(int i = 0; i < a - 1; i++)\\n            temp1 = temp1.next;\\n        \\n        int total = b - a + 1;\\n        ListNode temp2 = temp1;\\n        for(int i = 0; i <= total; i++)\\n            temp2 = temp2.next;\\n        \\n        temp1.next = list2;\\n        while(temp1.next != null)\\n            temp1 = temp1.next;\\n        \\n        temp1.next = temp2;\\n        return list1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1130846,
                "title": "simplest-solution-in-c",
                "content": "struct ListNode* mergeInBetween(struct ListNode* list1, int a, int b, struct ListNode* list2){\\n    struct ListNode *head, *tail, *tail2;\\n    int i, j;\\n    i = j = 1;\\n    head = list1;\\n    tail = list1;\\n    while(i<a){\\n        head = head->next;\\n        i++;\\n    }\\n    while(j<=b){\\n        tail = tail->next;\\n        j++;\\n    }\\n    tail2 = list2;\\n    while(tail2->next != NULL){\\n        tail2 = tail2->next; \\n    }\\n    head->next = list2;\\n    tail2->next = tail->next;\\n    tail->next = NULL;\\n    return list1;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "struct ListNode* mergeInBetween(struct ListNode* list1, int a, int b, struct ListNode* list2){\\n    struct ListNode *head, *tail, *tail2;\\n    int i, j;\\n    i = j = 1;\\n    head = list1;\\n    tail = list1;\\n    while(i<a){\\n        head = head->next;\\n        i++;\\n    }\\n    while(j<=b){\\n        tail = tail->next;\\n        j++;\\n    }\\n    tail2 = list2;\\n    while(tail2->next != NULL){\\n        tail2 = tail2->next; \\n    }\\n    head->next = list2;\\n    tail2->next = tail->next;\\n    tail->next = NULL;\\n    return list1;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 989246,
                "title": "rust-linear-time-and-no-extra-space-o-n-m-time-and-o-1-space",
                "content": "```\\nuse std::mem;\\n\\nimpl Solution {\\n    pub fn merge_in_between(\\n        list1: Option<Box<ListNode>>, \\n        a: i32, \\n        b: i32,\\n        mut list2: Option<Box<ListNode>>,\\n    ) -> Option<Box<ListNode>> {\\n        let mut head = list1.unwrap();\\n        \\n        let mut current = head.as_mut();\\n        for _ in 0..(a - 1) {\\n            current = current.next.as_mut().unwrap();\\n        }\\n\\t\\t\\n        mem::swap(&mut current.next, &mut list2);\\n        \\n        while current.next.is_some() {\\n            current = current.next.as_mut().unwrap();\\n        }\\n\\n        for _ in 0..(b - a + 1) {\\n            list2 = list2.unwrap().next;\\n        }\\n        current.next = list2;\\n        \\n        return Some(head);\\n    }\\n}\\n```\\nYou can see more Leetcode solutions writen in Rust on: https://github.com/garciparedes/leetcode",
                "solutionTags": [
                    "Rust",
                    "Linked List"
                ],
                "code": "```\\nuse std::mem;\\n\\nimpl Solution {\\n    pub fn merge_in_between(\\n        list1: Option<Box<ListNode>>, \\n        a: i32, \\n        b: i32,\\n        mut list2: Option<Box<ListNode>>,\\n    ) -> Option<Box<ListNode>> {\\n        let mut head = list1.unwrap();\\n        \\n        let mut current = head.as_mut();\\n        for _ in 0..(a - 1) {\\n            current = current.next.as_mut().unwrap();\\n        }\\n\\t\\t\\n        mem::swap(&mut current.next, &mut list2);\\n        \\n        while current.next.is_some() {\\n            current = current.next.as_mut().unwrap();\\n        }\\n\\n        for _ in 0..(b - a + 1) {\\n            list2 = list2.unwrap().next;\\n        }\\n        current.next = list2;\\n        \\n        return Some(head);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 973086,
                "title": "java-solution-easy-approach-o-n-time-and-o-1-space-solution",
                "content": "\\n    class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode athNode=list1;\\n        \\n        for(int i=0;i<a-1;i++)\\n        {\\n            athNode=athNode.next;\\n        }\\n        \\n        ListNode bthNode=athNode;\\n        for(int i=a;i<=b;i++)\\n        {\\n            bthNode=bthNode.next;\\n        }\\n        athNode.next=list2;\\n        while(list2.next!=null)\\n        {\\n            list2=list2.next;\\n        }\\n        list2.next=bthNode.next;\\n        return list1;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode athNode=list1;\\n        \\n        for(int i=0;i<a-1;i++)\\n        {\\n            athNode=athNode.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 952104,
                "title": "c-easy-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        int counter = 0;\\n        ListNode *curr = new ListNode(0);\\n        curr->next = list1;\\n        ListNode *prev = list1;\\n\\t\\t\\n\\t\\t// prev keeps track of previous node of list1\\n\\t\\t// Here we are iterating till we reach node of index a\\n        while(list1 != NULL && counter != a)\\n        {\\n            prev = list1;\\n            list1 = list1->next;\\n            counter++;\\n        }\\n        \\n\\t\\t// Iterating till we reach b+1 index node\\n        while(counter != b+1)\\n        {\\n            list1 = list1->next;\\n            counter++;\\n        }\\n        \\n\\t\\t// storing the remaining list1 values in temp\\n        ListNode *temp = list1;\\n        \\n\\t\\t// Assigning prev value to current\\n        ListNode *current = prev;\\n\\t\\t\\n\\t\\t// Adding list2 to list1\\n        current->next = list2;\\n        \\n\\t\\t// Iterating the entire list2 elements\\n        while(current->next != NULL)\\n        {\\n            current = current->next;\\n        }\\n\\t\\t// finally combining the remaining list1 elements\\n        current->next = temp;\\n        return curr->next;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        int counter = 0;\\n        ListNode *curr = new ListNode(0);\\n        curr->next = list1;\\n        ListNode *prev = list1;\\n\\t\\t\\n\\t\\t// prev keeps track of previous node of list1\\n\\t\\t// Here we are iterating till we reach node of index a\\n        while(list1 != NULL && counter != a)\\n        {\\n            prev = list1;\\n            list1 = list1->next;\\n            counter++;\\n        }\\n        \\n\\t\\t// Iterating till we reach b+1 index node\\n        while(counter != b+1)\\n        {\\n            list1 = list1->next;\\n            counter++;\\n        }\\n        \\n\\t\\t// storing the remaining list1 values in temp\\n        ListNode *temp = list1;\\n        \\n\\t\\t// Assigning prev value to current\\n        ListNode *current = prev;\\n\\t\\t\\n\\t\\t// Adding list2 to list1\\n        current->next = list2;\\n        \\n\\t\\t// Iterating the entire list2 elements\\n        while(current->next != NULL)\\n        {\\n            current = current->next;\\n        }\\n\\t\\t// finally combining the remaining list1 elements\\n        current->next = temp;\\n        return curr->next;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951996,
                "title": "c-short-concise-simple-readable-15-lines-explanation-interview-o-n",
                "content": "```\\n/*\\n\\nc++ - Short Concise -Simple Readable - Beginner - 15 lines - explanation - Interview - O(N)\\n\\nCreate a listNode pointer, move it till a, then insert list2 there, then move till the end of list 2. Similarly the same pointer after skipping b-a+1 nodes. Then attach the tail of current list2 there.\\n\\nThen return the head of list1\\n\\nBeats 100% Space\\n\\n*/\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        int p1=0;\\n        ListNode*curr1=list1,*curr2=list1;\\n        while(p1<a-1 && curr1){\\n            p1+=1;\\n            curr1=curr1->next;\\n            curr2=curr2->next;\\n        }\\n        while(p1<b+1){\\n            p1+=1;\\n            curr2=curr2->next;\\n        }\\n        curr1->next=list2;\\n        while(curr1->next){\\n            curr1=curr1->next;\\n        }\\n        curr1->next=curr2;\\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\nc++ - Short Concise -Simple Readable - Beginner - 15 lines - explanation - Interview - O(N)\\n\\nCreate a listNode pointer, move it till a, then insert list2 there, then move till the end of list 2. Similarly the same pointer after skipping b-a+1 nodes. Then attach the tail of current list2 there.\\n\\nThen return the head of list1\\n\\nBeats 100% Space\\n\\n*/\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        int p1=0;\\n        ListNode*curr1=list1,*curr2=list1;\\n        while(p1<a-1 && curr1){\\n            p1+=1;\\n            curr1=curr1->next;\\n            curr2=curr2->next;\\n        }\\n        while(p1<b+1){\\n            p1+=1;\\n            curr2=curr2->next;\\n        }\\n        curr1->next=list2;\\n        while(curr1->next){\\n            curr1=curr1->next;\\n        }\\n        curr1->next=curr2;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101380,
                "title": "easy-c-solution-not-the-best-but-quite-easy-to-understand-beats-85-of-users",
                "content": "```\\n/**\\n * Definition for singly-linked list.****\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* temp1 = list1;\\n        ListNode* temp2 = list1;\\n        ListNode* temp3 = list1;\\n        ListNode* afterremove = NULL;\\n        ListNode* prev = NULL;\\n        int count = 0;\\n        while(temp1 != NULL){\\n            if(count == b){\\n                afterremove = temp1->next;\\n                break;\\n            }\\n            count++;\\n            temp1 = temp1->next;\\n        }\\n        int count1 = 0;\\n        while(temp2 != NULL){\\n            if(count1 == a-1){\\n                temp2->next = list2;\\n                break;\\n            }\\n            count1++;\\n            temp2 = temp2->next;\\n        }\\n        while(temp3 != NULL){\\n            prev = temp3;\\n            temp3 = temp3->next;\\n        }\\n        prev->next = afterremove;\\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.****\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* temp1 = list1;\\n        ListNode* temp2 = list1;\\n        ListNode* temp3 = list1;\\n        ListNode* afterremove = NULL;\\n        ListNode* prev = NULL;\\n        int count = 0;\\n        while(temp1 != NULL){\\n            if(count == b){\\n                afterremove = temp1->next;\\n                break;\\n            }\\n            count++;\\n            temp1 = temp1->next;\\n        }\\n        int count1 = 0;\\n        while(temp2 != NULL){\\n            if(count1 == a-1){\\n                temp2->next = list2;\\n                break;\\n            }\\n            count1++;\\n            temp2 = temp2->next;\\n        }\\n        while(temp3 != NULL){\\n            prev = temp3;\\n            temp3 = temp3->next;\\n        }\\n        prev->next = afterremove;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055598,
                "title": "efficient-merging-with-o-n-o-1-complexities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is a way more generalized, as it will be analogous to repair the damaged patch in a cloth or the rope.\\nAnyone can do is to navigate to the damaged portions and then sew the new patch to the both ends of the older part.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. As it was discussed in the intuition, we\\'r going to initilize the pointers that will help us in navigating through the lists.\\n2. At first we need to track about the curtailing ends in the list1, so we\\'r going to traverse along the list and make the notes of \"a - 1\" and \"b + 1\" positions.(as we need to remove the positions in the range of [a, b] so we need the past and next pointers of this range.)\\n3. In the next stage we need the last node of the list2.(To attach it to the remains of the curtailed list1.)\\n4. Now we need to attach the first pointer of list2 to the ath pointer of the list1.(Which in turn removes the list1\\'s nodes from ath pointer, and the new list1\\'s end point is list2\\'s end point.)\\n5. Now with the previously marked last pointer of list2, we will attach the list1\\'s \"b + 1\" pointer to list2\\'s end point.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWith 2 while loops running independently, the time complexity would be O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe didnt used any extra data structure in the procedure, therefore space complexity would be constant i.e., O(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        l1ptr, l2ptr, i = list1, list2, 0\\n        while True:\\n            if i == a - 1:\\n                athptr = l1ptr\\n            if i == b + 1:\\n                bthptr = l1ptr\\n                break\\n            i += 1\\n            l1ptr = l1ptr.next\\n        while True:\\n            if l2ptr.next == None:\\n                break\\n            else:\\n                l2ptr = l2ptr.next\\n        athptr.next = list2\\n        l2ptr.next = bthptr\\n        return list1\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        l1ptr, l2ptr, i = list1, list2, 0\\n        while True:\\n            if i == a - 1:\\n                athptr = l1ptr\\n            if i == b + 1:\\n                bthptr = l1ptr\\n                break\\n            i += 1\\n            l1ptr = l1ptr.next\\n        while True:\\n            if l2ptr.next == None:\\n                break\\n            else:\\n                l2ptr = l2ptr.next\\n        athptr.next = list2\\n        l2ptr.next = bthptr\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048647,
                "title": "java-easy-to-understand-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = list1;\\n        ListNode prev = dummy;\\n        for (int i = 0; i < a; i++) {\\n            prev = prev.next;\\n        }\\n        \\n        // Move curr to the node after \\'b\\'\\n        ListNode curr = prev;\\n        for (int i = a; i <= b + 1; i++) {\\n            curr = curr.next;\\n        }\\n        \\n        // Connect the nodes before \\'a\\' to list2\\n        prev.next = list2;\\n        \\n        // Find the end of list2 and connect it to the nodes after \\'b\\'\\n        while (list2.next != null) {\\n            list2 = list2.next;\\n        }\\n        list2.next = curr;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = list1;\\n        ListNode prev = dummy;\\n        for (int i = 0; i < a; i++) {\\n            prev = prev.next;\\n        }\\n        \\n        // Move curr to the node after \\'b\\'\\n        ListNode curr = prev;\\n        for (int i = a; i <= b + 1; i++) {\\n            curr = curr.next;\\n        }\\n        \\n        // Connect the nodes before \\'a\\' to list2\\n        prev.next = list2;\\n        \\n        // Find the end of list2 and connect it to the nodes after \\'b\\'\\n        while (list2.next != null) {\\n            list2 = list2.next;\\n        }\\n        list2.next = curr;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025760,
                "title": "super-easy-and-efficient-python",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        start, end = list1, list1\\n        for _ in range(a-1):\\n            start = start.next\\n        print(start.val)\\n\\n        for _ in range(b+1):\\n            end = end.next\\n        print(end.val)\\n\\n        start.next = list2\\n        while start.next:\\n            start = start.next\\n        start.next = end\\n        return list1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        start, end = list1, list1\\n        for _ in range(a-1):\\n            start = start.next\\n        print(start.val)\\n\\n        for _ in range(b+1):\\n            end = end.next\\n        print(end.val)\\n\\n        start.next = list2\\n        while start.next:\\n            start = start.next\\n        start.next = end\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980068,
                "title": "simple-java-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head = list1;\\n        for(int i = 1; i < a; i++) {\\n            head = head.next;\\n        }\\n        ListNode temp = head;\\n        for(int i = 0; i < b-a+2; i++) {\\n            temp = temp.next;\\n        }\\n        ListNode temp2 = list2;\\n        while(temp2.next != null) {\\n            temp2 = temp2.next;\\n        }\\n        head.next = list2;\\n        temp2.next = temp;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head = list1;\\n        for(int i = 1; i < a; i++) {\\n            head = head.next;\\n        }\\n        ListNode temp = head;\\n        for(int i = 0; i < b-a+2; i++) {\\n            temp = temp.next;\\n        }\\n        ListNode temp2 = list2;\\n        while(temp2.next != null) {\\n            temp2 = temp2.next;\\n        }\\n        head.next = list2;\\n        temp2.next = temp;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963747,
                "title": "beats-100-very-simple-code-explained-in-hindi-java-c-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSbse pehle hm ath node ke previous node tk traverse krenge that is hmara ek pointer a-1 pr ho uske baad hm bth node tk traverse krenge that is pointer 2 bth node pr h. simply ab (a-1)th node ka next list2 ka head krdenge. Ab list2 ke last node tk traverse krna h or list2 ke last node ka next bth node ke next ke equal kr dena.\\nThis will beat 100% people in runtime.\\nWrite System.gc(); in last line and it will beat 100% people in memory then....\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i;\\n        ListNode t,c=list1;\\n        for(i=1;i<a;i++) c=c.next;\\n        t=c.next;\\n        for(i=a;i<b;i++) t=t.next;\\n        c.next=list2;\\n        while(list2.next != null) list2=list2.next;\\n        list2.next=t.next;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i;\\n        ListNode t,c=list1;\\n        for(i=1;i<a;i++) c=c.next;\\n        t=c.next;\\n        for(i=a;i<b;i++) t=t.next;\\n        c.next=list2;\\n        while(list2.next != null) list2=list2.next;\\n        list2.next=t.next;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333427,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *ptr1 = list1,*ptr2 = list1, *end = list2;\\n            \\n        for(int i=0;i<=b;i++){\\n            if(i<a-1)\\n                ptr1= ptr1->next;\\n            ptr2=ptr2->next;\\n        }\\n        while(end->next!=NULL){\\n            end = end->next;\\n        }\\n        ptr1->next = list2;\\n        \\n        end->next = ptr2;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *ptr1 = list1,*ptr2 = list1, *end = list2;\\n            \\n        for(int i=0;i<=b;i++){\\n            if(i<a-1)\\n                ptr1= ptr1->next;\\n            ptr2=ptr2->next;\\n        }\\n        while(end->next!=NULL){\\n            end = end->next;\\n        }\\n        ptr1->next = list2;\\n        \\n        end->next = ptr2;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303650,
                "title": "easy-to-understand-for-beginner-ninjas-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* head1, int a, int b, ListNode* head2) {\\n        ListNode* prev=head1,*ptr=head1;\\n        ListNode* ptr2=head2;\\n        bool ch=false;\\n        int cnta=0,cntb=0;\\n        while(ptr2->next!=NULL)ptr2=ptr2->next;\\n        while(ptr!=NULL)\\n        {\\n            cntb=cnta;\\n            if(cnta==a)\\n            {\\n                prev->next=head2;\\n                while(ptr!=nullptr)\\n                {\\n                    if(cntb==b)\\n                    {\\n                        ptr2->next=ptr->next;\\n                        ch=true;\\n                        break;\\n                    }\\n                    ptr=ptr->next;\\n                    cntb++;\\n                }\\n                if(ch)break;\\n            }\\n            prev=ptr;\\n            ptr=ptr->next;\\n            cnta++;\\n        }\\n        return head1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* head1, int a, int b, ListNode* head2) {\\n        ListNode* prev=head1,*ptr=head1;\\n        ListNode* ptr2=head2;\\n        bool ch=false;\\n        int cnta=0,cntb=0;\\n        while(ptr2->next!=NULL)ptr2=ptr2->next;\\n        while(ptr!=NULL)\\n        {\\n            cntb=cnta;\\n            if(cnta==a)\\n            {\\n                prev->next=head2;\\n                while(ptr!=nullptr)\\n                {\\n                    if(cntb==b)\\n                    {\\n                        ptr2->next=ptr->next;\\n                        ch=true;\\n                        break;\\n                    }\\n                    ptr=ptr->next;\\n                    cntb++;\\n                }\\n                if(ch)break;\\n            }\\n            prev=ptr;\\n            ptr=ptr->next;\\n            cnta++;\\n        }\\n        return head1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231080,
                "title": "python3-easy-solution",
                "content": "# It would be really great if you guys upvote, if found the solution helpful.\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        lst1,lst2= [],[]\\n        while list1:\\n            lst1.append(list1.val)\\n            list1 = list1.next\\n        while list2:\\n            lst2.append(list2.val)\\n            list2 = list2.next\\n        lst1[a:b+1]=lst2[:]\\n        a = ListNode(0)\\n        temp = a\\n        for i in lst1:\\n            temp.next = ListNode(i)\\n            temp = temp.next\\n        return a.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        lst1,lst2= [],[]\\n        while list1:\\n            lst1.append(list1.val)\\n            list1 = list1.next\\n        while list2:\\n            lst2.append(list2.val)\\n            list2 = list2.next\\n        lst1[a:b+1]=lst2[:]\\n        a = ListNode(0)\\n        temp = a\\n        for i in lst1:\\n            temp.next = ListNode(i)\\n            temp = temp.next\\n        return a.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171422,
                "title": "easy-c-2-pointers-approach",
                "content": "# Approach\\nJust create two pointers. Go to their particular index of start and begin point. Insert the list2 between them.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* p1 = list1;\\n        ListNode* p2 = list1;\\n\\n        for(int i=0;i<a-1;i++){\\n            p1 = p1->next;\\n        }\\n\\n        for(int i=0;i<b;i++){\\n            p2 = p2->next;\\n        }\\n\\n        p1->next = list2;\\n        ListNode* temp = list2;\\n        while(temp->next!=NULL){\\n            temp = temp->next;\\n        }\\n        temp->next = p2->next;\\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* p1 = list1;\\n        ListNode* p2 = list1;\\n\\n        for(int i=0;i<a-1;i++){\\n            p1 = p1->next;\\n        }\\n\\n        for(int i=0;i<b;i++){\\n            p2 = p2->next;\\n        }\\n\\n        p1->next = list2;\\n        ListNode* temp = list2;\\n        while(temp->next!=NULL){\\n            temp = temp->next;\\n        }\\n        temp->next = p2->next;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171417,
                "title": "easy-c-solution-using-2-pointers-approach",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* p1=list1;\\n        ListNode* p2=list1;\\n        for(int i=0; i<a-1; i++){\\n            p1=p1->next;\\n        }\\n        for(int i=0; i<b; i++){\\n            p2=p2->next;\\n        }\\n        p1->next=list2;\\n        ListNode*temp =list2;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n        }\\n        temp->next=p2->next;\\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* p1=list1;\\n        ListNode* p2=list1;\\n        for(int i=0; i<a-1; i++){\\n            p1=p1->next;\\n        }\\n        for(int i=0; i<b; i++){\\n            p2=p2->next;\\n        }\\n        p1->next=list2;\\n        ListNode*temp =list2;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n        }\\n        temp->next=p2->next;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136998,
                "title": "simple-java-iteration-algorithm",
                "content": "**Algorithm :**\\n```\\n1. create dummy list to store the answer.\\n2. create another list to iterate through the list1.\\n3. now create a length variable to maintan the length, and checking for a and b points.\\n4. Traverse untill list1 is not empty, if (length == a) then add all the list2 elements to the running list.\\n5. skip the list1 elements until we reach the b point.\\n6. while this process, if (length != a) then we add the list1 elements to running list.\\n```\\n\\n```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        ListNode dummy = new ListNode();\\n        ListNode ans = dummy;\\n        \\n        int len = 0;\\n        \\n        while (list1 != null) {\\n\\t\\n\\t\\t\\t// this is the position we need to append list2\\n            if (len == a) {\\n                \\n\\t\\t\\t\\t// adding list2 elements\\n                while (list2 != null) {\\n                    ans.next = list2;\\n                    ans = ans.next;\\n                    list2 = list2.next;                   \\n                }\\n                \\n\\t\\t\\t\\t// skipping list1 elements\\n                while (len != b + 1) {\\n                    list1 = list1.next;\\n                    ++len;\\n                }  \\n            }\\n            \\n\\t\\t\\t// adding list1 elements\\n            ans.next = list1;\\n            ans = ans.next;\\n            list1 = list1.next;\\n            ++len;       \\n        }\\n        return dummy.next;\\n    }    \\n}        \\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n1. create dummy list to store the answer.\\n2. create another list to iterate through the list1.\\n3. now create a length variable to maintan the length, and checking for a and b points.\\n4. Traverse untill list1 is not empty, if (length == a) then add all the list2 elements to the running list.\\n5. skip the list1 elements until we reach the b point.\\n6. while this process, if (length != a) then we add the list1 elements to running list.\\n```\n```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        ListNode dummy = new ListNode();\\n        ListNode ans = dummy;\\n        \\n        int len = 0;\\n        \\n        while (list1 != null) {\\n\\t\\n\\t\\t\\t// this is the position we need to append list2\\n            if (len == a) {\\n                \\n\\t\\t\\t\\t// adding list2 elements\\n                while (list2 != null) {\\n                    ans.next = list2;\\n                    ans = ans.next;\\n                    list2 = list2.next;                   \\n                }\\n                \\n\\t\\t\\t\\t// skipping list1 elements\\n                while (len != b + 1) {\\n                    list1 = list1.next;\\n                    ++len;\\n                }  \\n            }\\n            \\n\\t\\t\\t// adding list1 elements\\n            ans.next = list1;\\n            ans = ans.next;\\n            list1 = list1.next;\\n            ++len;       \\n        }\\n        return dummy.next;\\n    }    \\n}        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110323,
                "title": "c-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        long int count=1,temp=1;\\n        ListNode* p=list1,*q=list1,*z=list2;\\n        while(count<a){\\n            p=p->next;\\n            count++;\\n        }\\n        while(temp<=b){\\n            q=q->next;\\n            temp++;\\n        }\\n        while(z->next!=NULL){\\n            z=z->next;\\n        }\\n        p->next=list2;\\n        z->next=q->next;\\n        return list1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        long int count=1,temp=1;\\n        ListNode* p=list1,*q=list1,*z=list2;\\n        while(count<a){\\n            p=p->next;\\n            count++;\\n        }\\n        while(temp<=b){\\n            q=q->next;\\n            temp++;\\n        }\\n        while(z->next!=NULL){\\n            z=z->next;\\n        }\\n        p->next=list2;\\n        z->next=q->next;\\n        return list1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108825,
                "title": "easy-c-code-simple-code-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *temp=list1;\\n        while(a>1)\\n        {\\n            temp=temp->next;\\n            a--;\\n            b--;\\n        }\\n        ListNode* temp2=temp,*curr=list2;\\n        while(b)\\n        {\\n            temp2=temp2->next;\\n            b--;\\n        }\\n\\n        while(curr->next!=NULL)\\n        {\\n           curr=curr->next;\\n        }\\n        /*if(temp==list1)\\n        {\\n            list1->next=list2;\\n            curr->next=temp2->next;\\n            return list1;\\n        }*/\\n        temp->next=list2;\\n        curr->next=temp2->next;\\n        return list1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *temp=list1;\\n        while(a>1)\\n        {\\n            temp=temp->next;\\n            a--;\\n            b--;\\n        }\\n        ListNode* temp2=temp,*curr=list2;\\n        while(b)\\n        {\\n            temp2=temp2->next;\\n            b--;\\n        }\\n\\n        while(curr->next!=NULL)\\n        {\\n           curr=curr->next;\\n        }\\n        /*if(temp==list1)\\n        {\\n            list1->next=list2;\\n            curr->next=temp2->next;\\n            return list1;\\n        }*/\\n        temp->next=list2;\\n        curr->next=temp2->next;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029635,
                "title": "c-beginner-friendly-solution-very-easy",
                "content": "##### Brute Force\\n* Time Complexity = `O(N)`\\n* Space Complexity = `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *left = nullptr, *right = nullptr, *prev = nullptr;\\n        ListNode * curr = list1;\\n        int cnt = 0;\\n        while(curr) {\\n            if(cnt == a)  {\\n                left = prev;\\n            }\\n            if(cnt == b) {\\n                right = curr -> next;\\n            }\\n            prev = curr;\\n            curr = curr -> next;\\n            cnt++;\\n        }\\n\\n        curr = list2;\\n\\n        while(curr -> next) curr = curr -> next;\\n\\n        if(left == nullptr) {\\n            curr -> next = right;\\n            return list2;\\n        }\\n\\n        left -> next = list2;\\n        curr -> next = right;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *left = nullptr, *right = nullptr, *prev = nullptr;\\n        ListNode * curr = list1;\\n        int cnt = 0;\\n        while(curr) {\\n            if(cnt == a)  {\\n                left = prev;\\n            }\\n            if(cnt == b) {\\n                right = curr -> next;\\n            }\\n            prev = curr;\\n            curr = curr -> next;\\n            cnt++;\\n        }\\n\\n        curr = list2;\\n\\n        while(curr -> next) curr = curr -> next;\\n\\n        if(left == nullptr) {\\n            curr -> next = right;\\n            return list2;\\n        }\\n\\n        left -> next = list2;\\n        curr -> next = right;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012442,
                "title": "easy-python-solution-loops-arrays",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        res = []\\n        pos = 0\\n        while list1:\\n            if pos == a:\\n                while True:\\n                    while list2:\\n                        res.append(list2.val)\\n                        list2 = list2.next\\n\\n                    if pos == b:\\n                        list1 = list1.next\\n                        break\\n                    list1 = list1.next\\n                    pos += 1\\n\\n            res.append(list1.val)\\n            list1 = list1.next\\n            pos += 1\\n        d = n = ListNode()\\n        for i in res:\\n            d.next = ListNode(i)\\n            d = d.next\\n\\n        return n.next\\n\\n\\n```\\nDo upvote if you like the solution :)\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        res = []\\n        pos = 0\\n        while list1:\\n            if pos == a:\\n                while True:\\n                    while list2:\\n                        res.append(list2.val)\\n                        list2 = list2.next\\n\\n                    if pos == b:\\n                        list1 = list1.next\\n                        break\\n                    list1 = list1.next\\n                    pos += 1\\n\\n            res.append(list1.val)\\n            list1 = list1.next\\n            pos += 1\\n        d = n = ListNode()\\n        for i in res:\\n            d.next = ListNode(i)\\n            d = d.next\\n\\n        return n.next\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929973,
                "title": "beats-90-linked-list-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO((length(list1))+(length(list2)))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        curr=list1\\n        t=0\\n        var=None\\n        while curr!=None:\\n            t+=1\\n            if t==b+1:\\n                break\\n            if a==t:\\n                pp=curr.next\\n                var=curr\\n                var.next=list2\\n                # curr.next=None\\n                curr=pp\\n            curr=curr.next\\n        temp=list1\\n        while temp!=None:\\n            if temp.next==None:\\n                break\\n            temp=temp.next\\n        temp.next=curr\\n        return list1\\n\\n        \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        curr=list1\\n        t=0\\n        var=None\\n        while curr!=None:\\n            t+=1\\n            if t==b+1:\\n                break\\n            if a==t:\\n                pp=curr.next\\n                var=curr\\n                var.next=list2\\n                # curr.next=None\\n                curr=pp\\n            curr=curr.next\\n        temp=list1\\n        while temp!=None:\\n            if temp.next==None:\\n                break\\n            temp=temp.next\\n        temp.next=curr\\n        return list1\\n\\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800059,
                "title": "easy-solution-c-using-two-pointers",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* temp=list1;\\n        int t=a;\\n        while(--t)\\n            temp=temp->next;  //traverse till a\\'th node in list1\\n        \\n        ListNode* temp2=list1;\\n        \\n        for(int i=0;i<=(b);i++)\\n            temp2=temp2->next; //traverse till next node of b\\'th node of list1\\n        \\n        temp->next=list2;    //join the list 2 with a\\'th node\\n        while(temp->next!=NULL)\\n        {\\n            temp=temp->next;\\n        }\\n        temp->next = temp2;  \\n        \\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* temp=list1;\\n        int t=a;\\n        while(--t)\\n            temp=temp->next;  //traverse till a\\'th node in list1\\n        \\n        ListNode* temp2=list1;\\n        \\n        for(int i=0;i<=(b);i++)\\n            temp2=temp2->next; //traverse till next node of b\\'th node of list1\\n        \\n        temp->next=list2;    //join the list 2 with a\\'th node\\n        while(temp->next!=NULL)\\n        {\\n            temp=temp->next;\\n        }\\n        temp->next = temp2;  \\n        \\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775086,
                "title": "very-easy-c-self-explainable-code-finally-nailed-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        int count=0;\\n        ListNode* temp=list1;\\n        while(temp!=NULL)\\n        {\\n            count++;\\n            if(count==a)\\n            break;\\n\\n            temp=temp->next;\\n\\n        }\\n        ListNode* i=temp;\\n        temp=temp->next;\\n        cout<<temp->val;\\n        int g=0;\\n        count=b-a+1;\\n        while(temp!=NULL)\\n        {\\n    g++;\\n       if(count==g)\\n       break;\\n       temp=temp->next;\\n        }\\n        temp=temp->next;\\n        ListNode* o=temp;\\n        cout<<temp->val;\\n          while(list2!=NULL && list2->next!=NULL)\\n          {\\n              \\n              i->next=list2;\\n              i=i->next;\\n              list2=list2->next;\\n          }\\n          if(o!=NULL)\\n          list2->next=o;;\\n          \\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        int count=0;\\n        ListNode* temp=list1;\\n        while(temp!=NULL)\\n        {\\n            count++;\\n            if(count==a)\\n            break;\\n\\n            temp=temp->next;\\n\\n        }\\n        ListNode* i=temp;\\n        temp=temp->next;\\n        cout<<temp->val;\\n        int g=0;\\n        count=b-a+1;\\n        while(temp!=NULL)\\n        {\\n    g++;\\n       if(count==g)\\n       break;\\n       temp=temp->next;\\n        }\\n        temp=temp->next;\\n        ListNode* o=temp;\\n        cout<<temp->val;\\n          while(list2!=NULL && list2->next!=NULL)\\n          {\\n              \\n              i->next=list2;\\n              i=i->next;\\n              list2=list2->next;\\n          }\\n          if(o!=NULL)\\n          list2->next=o;;\\n          \\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2704428,
                "title": "java-solution-100-faster-with-explanation",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        //Step1 : First place the pointer at (a-1)th node of list1\\n        ListNode prev = list1;\\n        int firstPointer = a - 1;\\n       while(firstPointer-->0){\\n            prev = prev.next;\\n        }\\n        \\n         //Step2 : Create dummy pointer for list2  get to last second node of it.\\n        ListNode dummyList2 = list2;\\n        while(dummyList2.next != null) {\\n            dummyList2 = dummyList2.next;\\n        }\\n        \\n        //Step3 : Place another pointer at (b+1) th node of list1\\n        int secondPointer = b+1;\\n        ListNode dummyList1 = list1;\\n        while(secondPointer-->0){\\n            dummyList1 = dummyList1.next;\\n        }\\n       \\n        //At last merge (a-1)th node of list1 with list2\\n        prev.next = list2;\\n        //End node of list2 will be linked with (b+1)th node of the  list1\\n        dummyList2.next = dummyList1;\\n       \\n      \\n       \\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        //Step1 : First place the pointer at (a-1)th node of list1\\n        ListNode prev = list1;\\n        int firstPointer = a - 1;\\n       while(firstPointer-->0){\\n            prev = prev.next;\\n        }\\n        \\n         //Step2 : Create dummy pointer for list2  get to last second node of it.\\n        ListNode dummyList2 = list2;\\n        while(dummyList2.next != null) {\\n            dummyList2 = dummyList2.next;\\n        }\\n        \\n        //Step3 : Place another pointer at (b+1) th node of list1\\n        int secondPointer = b+1;\\n        ListNode dummyList1 = list1;\\n        while(secondPointer-->0){\\n            dummyList1 = dummyList1.next;\\n        }\\n       \\n        //At last merge (a-1)th node of list1 with list2\\n        prev.next = list2;\\n        //End node of list2 will be linked with (b+1)th node of the  list1\\n        dummyList2.next = dummyList1;\\n       \\n      \\n       \\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699822,
                "title": "easy-java-solution-straight-forward-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head = list1;\\n        ListNode start = list2;\\n        while(list2.next != null){\\n            list2 = list2.next;\\n        }\\n        ListNode end = list2;\\n        ListNode lista = null;\\n        ListNode listb = null;\\n        int count = 0;\\n        while(list1 != null){\\n            if(count+1 == a){\\n                lista = list1;\\n            }\\n            if(count+1 == b){\\n                listb = list1.next;\\n                break;\\n            }\\n            count++;\\n            list1 = list1.next;\\n        }\\n        lista.next = start;\\n        end.next = listb.next;\\n        return head;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head = list1;\\n        ListNode start = list2;\\n        while(list2.next != null){\\n            list2 = list2.next;\\n        }\\n        ListNode end = list2;\\n        ListNode lista = null;\\n        ListNode listb = null;\\n        int count = 0;\\n        while(list1 != null){\\n            if(count+1 == a){\\n                lista = list1;\\n            }\\n            if(count+1 == b){\\n                listb = list1.next;\\n                break;\\n            }\\n            count++;\\n            list1 = list1.next;\\n        }\\n        lista.next = start;\\n        end.next = listb.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641130,
                "title": "traverse-and-join-bruteforce-approach-o-n-time-complexity",
                "content": "# Intuition\\nTraverse the list to find the values of a and b. Then store those ndoes. After that traverse in the second list, Store first and last of that list, after that, point the last of list12 to the b th node.\\n\\n# Approach\\nWe will take a size counter, and whenever we get the ath size, we will store the address of its previous node. Because according to the question ath node should be excluded.\\n\\nThen when we find the bth node, we will exclude that too, meaning that this time we will store the next.\\n\\nAt last we will find the first and last node of list2. And, then join the nodes accordingly.\\n\\n`a1->next=b1`\\n`b2->next=a2`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        // a and b are not data points, but they are like indexes. starting from 0.\\n        ListNode* a1 = NULL; //will store the node of previous to the size a. i.e where size+1==a\\n        ListNode* a2 = NULL; //will store the node where the size of the node will be equal to b.\\n        ListNode* b1 = NULL; //used to store the first node of list2.\\n        ListNode* b2 = NULL; //used to store the last node of list2.\\n        ListNode* l1 = list1; //rederence to the list1 orignal head.\\n        int size = 0; //size stores what is the current size of the linked list.\\n        while(list1->next!=NULL){\\n            // store previous and check if next->next!=NULL although this condition will always \\n            // meet because of questions input is length-1.\\n            if(list1->next->next!=NULL && size+1==a ){ \\n                a1 = list1; //store the node in a1\\n            }else if(size==b){ //store next \\n                a2 = list1->next;\\n            }\\n            list1 = list1->next; //move ahead into list\\n            size++; //increase the size\\n        }\\n\\n        b1 = list2; //store the first of list2\\n        while(list2->next!=NULL){\\n            list2 = list2->next;\\n        }\\n        b2 = list2; //store the last of list2.\\n\\n        // if at any case we found that a1==NULL, we will directly store b1. \\n        // Will not store in its next.\\n        // Current link is as follows....\\n        // LIST1->A1->\\n        if(a1!=NULL) {\\n            a1->next= b1; //pointing to the b1\\n        }\\n        //UPDATED LINKS WILL BE: LIST1->A1->B1->B2->\\n        else{\\n            a1=b1;\\n        }\\n        b2->next = a2;  //point the b2 to a2.\\n        //UPDATED LINK: LIST1->A1->B1->B2->A2 //final result\\n        return l1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        // a and b are not data points, but they are like indexes. starting from 0.\\n        ListNode* a1 = NULL; //will store the node of previous to the size a. i.e where size+1==a\\n        ListNode* a2 = NULL; //will store the node where the size of the node will be equal to b.\\n        ListNode* b1 = NULL; //used to store the first node of list2.\\n        ListNode* b2 = NULL; //used to store the last node of list2.\\n        ListNode* l1 = list1; //rederence to the list1 orignal head.\\n        int size = 0; //size stores what is the current size of the linked list.\\n        while(list1->next!=NULL){\\n            // store previous and check if next->next!=NULL although this condition will always \\n            // meet because of questions input is length-1.\\n            if(list1->next->next!=NULL && size+1==a ){ \\n                a1 = list1; //store the node in a1\\n            }else if(size==b){ //store next \\n                a2 = list1->next;\\n            }\\n            list1 = list1->next; //move ahead into list\\n            size++; //increase the size\\n        }\\n\\n        b1 = list2; //store the first of list2\\n        while(list2->next!=NULL){\\n            list2 = list2->next;\\n        }\\n        b2 = list2; //store the last of list2.\\n\\n        // if at any case we found that a1==NULL, we will directly store b1. \\n        // Will not store in its next.\\n        // Current link is as follows....\\n        // LIST1->A1->\\n        if(a1!=NULL) {\\n            a1->next= b1; //pointing to the b1\\n        }\\n        //UPDATED LINKS WILL BE: LIST1->A1->B1->B2->\\n        else{\\n            a1=b1;\\n        }\\n        b2->next = a2;  //point the b2 to a2.\\n        //UPDATED LINK: LIST1->A1->B1->B2->A2 //final result\\n        return l1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626236,
                "title": "c-clean-code-which-beats-90-soln-in-time-and-99-soln-in-space",
                "content": "```\\nListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        a--; b++;\\n        ListNode *h1=list1, *t1=list1, *h2=list2, *t2=list2, *head=list1;\\n        while(t2->next) t2=t2->next;\\n        while(a--) h1=h1->next;\\n        while(b--) t1=t1->next;\\n        h1->next=h2; t2->next=t1;\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        a--; b++;\\n        ListNode *h1=list1, *t1=list1, *h2=list2, *t2=list2, *head=list1;\\n        while(t2->next) t2=t2->next;\\n        while(a--) h1=h1->next;\\n        while(b--) t1=t1->next;\\n        h1->next=h2; t2->next=t1;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589191,
                "title": "easy-understand-100-fast-0ms-very-simple",
                "content": "```\\nListNode p=list1;\\n        ListNode q=list1;\\n        b=b-a;\\n        while(a>1){\\n            p=p.next;\\n            a--;\\n        }\\n        q=p;\\n        while(b>=0){\\n         q=q.next;  \\n         b--;   \\n        }\\n        while(list2!=null){\\n            p.next=list2;\\n            p=p.next;\\n            list2=list2.next;\\n        }\\n        p.next=q.next;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nListNode p=list1;\\n        ListNode q=list1;\\n        b=b-a;\\n        while(a>1){\\n            p=p.next;\\n            a--;\\n        }\\n        q=p;\\n        while(b>=0){\\n         q=q.next;  \\n         b--;   \\n        }\\n        while(list2!=null){\\n            p.next=list2;\\n            p=p.next;\\n            list2=list2.next;\\n        }\\n        p.next=q.next;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539859,
                "title": "java-solution-not-the-best",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode firstL2 = list2;\\n        ListNode lastL2 = list2;\\n        while (list2 != null) {\\n            lastL2 = list2;\\n            list2 = list2.next;\\n        }\\n        \\n        ListNode aMinus1L1 = list1;\\n        ListNode bPlus1L1 = list1;\\n        ListNode temp = list1;\\n        int count = 0;\\n        while(list1 != null) {\\n            if (count == a - 1) {\\n                aMinus1L1 = list1;\\n            } \\n            if (count == b + 1) {\\n                bPlus1L1 = list1;\\n                break;\\n            }\\n            list1 = list1.next;\\n            count++;\\n        }\\n        \\n        aMinus1L1.next = firstL2;\\n        lastL2.next = bPlus1L1;\\n        return temp;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode firstL2 = list2;\\n        ListNode lastL2 = list2;\\n        while (list2 != null) {\\n            lastL2 = list2;\\n            list2 = list2.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2521562,
                "title": "easy-c-solution",
                "content": "First reach the last of linkedlist2 using a tail pointer. Now using two pointers, reach node before index a and after index b, and then simply update relevant links to get the required linked list.\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* tail=list2;\\n        while(tail->next!=NULL)\\n            tail=tail->next;\\n        ListNode* aNode=list1;\\n        ListNode* bNode=list1;\\n        while(--a && --b)\\n            aNode=aNode->next;\\n        bNode=aNode;\\n        do{\\n                bNode=bNode->next;\\n        }while(b--);\\n        aNode->next=list2;\\n        tail->next=bNode;\\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* tail=list2;\\n        while(tail->next!=NULL)\\n            tail=tail->next;\\n        ListNode* aNode=list1;\\n        ListNode* bNode=list1;\\n        while(--a && --b)\\n            aNode=aNode->next;\\n        bNode=aNode;\\n        do{\\n                bNode=bNode->next;\\n        }while(b--);\\n        aNode->next=list2;\\n        tail->next=bNode;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477944,
                "title": "java-fast-solution-with-comments-and-explanation",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        // traversing till a - 1 in list1\\n        \\n        ListNode tempNode =  list1;\\n        \\n        for( int i = 0  ; i < a -1; i++ ){\\n            tempNode = tempNode.next;\\n        }\\n        \\n        // traversing till b + 1 in list1\\n        \\n        ListNode tempNode2 = list1;\\n        \\n        for( int i = 0 ; i < b + 1 ; i++ ){\\n            tempNode2 = tempNode2.next;\\n        }\\n        \\n        // connecting the ( a - 1 )th node to the head of the second list \\n        \\n        tempNode.next = list2;\\n        \\n        \\n        // finding the tail of the list2\\n        \\n        ListNode list2_tail = list2;\\n        \\n        while( list2_tail.next != null ){\\n            list2_tail = list2_tail.next;\\n        }\\n        \\n        \\n        // now connneting the tail  of the list2 to the b+1 th node of the list1\\n        \\n        list2_tail.next = tempNode2;\\n        \\n        return list1;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        // traversing till a - 1 in list1\\n        \\n        ListNode tempNode =  list1;\\n        \\n        for( int i = 0  ; i < a -1; i++ ){\\n            tempNode = tempNode.next;\\n        }\\n        \\n        // traversing till b + 1 in list1\\n        \\n        ListNode tempNode2 = list1;\\n        \\n        for( int i = 0 ; i < b + 1 ; i++ ){\\n            tempNode2 = tempNode2.next;\\n        }\\n        \\n        // connecting the ( a - 1 )th node to the head of the second list \\n        \\n        tempNode.next = list2;\\n        \\n        \\n        // finding the tail of the list2\\n        \\n        ListNode list2_tail = list2;\\n        \\n        while( list2_tail.next != null ){\\n            list2_tail = list2_tail.next;\\n        }\\n        \\n        \\n        // now connneting the tail  of the list2 to the b+1 th node of the list1\\n        \\n        list2_tail.next = tempNode2;\\n        \\n        return list1;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473540,
                "title": "1669-merge-in-between-linked-lists-solution-with-beats-of-100",
                "content": "class Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n         ListNode* temp1=list1;  ListNode* nextnode=list1;\\n         ListNode* temp2=list2;  \\n        int k=1; \\n        while(k<a){\\n            temp1=temp1->next;\\n            nextnode=nextnode->next;\\n            k++;\\n        }\\n        int t=b-a+2;\\n        while(t--){\\n            nextnode=nextnode->next;\\n        }\\n        temp1->next=temp2;\\n        while(temp2->next!=NULL){\\n            temp2=temp2->next;\\n        }\\n         temp2->next=nextnode;\\n        return list1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n         ListNode* temp1=list1;  ListNode* nextnode=list1;\\n         ListNode* temp2=list2;  \\n        int k=1; \\n        while(k<a){\\n            temp1=temp1->next;\\n            nextnode=nextnode->next;\\n            k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2416424,
                "title": "c-simple-and-easy-to-understand",
                "content": "```\\nListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) { \\n    ListNode *it1 = list1, *it2 = list1;\\n        \\n    for (int i = 1; it1 != nullptr; i++) {\\n        it1 = it1->next;\\n        \\n        if (i < a) {\\n            it2 = it2->next;\\n        } else if (i >= a and i <= b + 1) {\\n            if (i == a) { // attach list2 to list1\\n                it2->next = list2;\\n                while (it2->next) it2 = it2->next; // take it2 ptr till the end of list2\\n            } else if (i == b + 1) { // attach list2 to link1\\n                it2->next = it1;\\n            }\\n        }\\n\\t}\\n        \\n\\treturn list1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) { \\n    ListNode *it1 = list1, *it2 = list1;\\n        \\n    for (int i = 1; it1 != nullptr; i++) {\\n        it1 = it1->next;\\n        \\n        if (i < a) {\\n            it2 = it2->next;\\n        } else if (i >= a and i <= b + 1) {\\n            if (i == a) { // attach list2 to list1\\n                it2->next = list2;\\n                while (it2->next) it2 = it2->next; // take it2 ptr till the end of list2\\n            } else if (i == b + 1) { // attach list2 to link1\\n                it2->next = it1;\\n            }\\n        }\\n\\t}\\n        \\n\\treturn list1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2370451,
                "title": "c-simple-and-very-easy-to-understand-code",
                "content": "\\n        ListNode* curr1=list1; \\n        ListNode* curr2=list2;        \\n        ListNode* curra=NULL;     \\n        ListNode* currb=list1;\\n        while(a--){\\n            curra=curr1;\\n            curr1=curr1->next;\\n            \\n        }\\n        \\n        while(b--){\\n            currb=currb->next;\\n        }\\n        currb=currb->next;\\n        while(curr2->next!=NULL){\\n            curr2=curr2->next;\\n        }\\n        curra->next=list2;\\n        curr2->next=currb;\\n        return list1;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "\\n        ListNode* curr1=list1; \\n        ListNode* curr2=list2;        \\n        ListNode* curra=NULL;     \\n        ListNode* currb=list1;\\n        while(a--){\\n            curra=curr1;\\n            curr1=curr1->next;\\n            \\n        }\\n        \\n        while(b--){\\n            currb=currb->next;\\n        }\\n        currb=currb->next;\\n        while(curr2->next!=NULL){\\n            curr2=curr2->next;\\n        }\\n        curra->next=list2;\\n        curr2->next=currb;\\n        return list1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2325419,
                "title": "1669-merge-in-between-linked-lists",
                "content": "**Please upvote if you liked the solution**\\n\\'\\'\\'class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode temp=list1;\\n        ListNode head1=list1;\\n        ListNode tail1=list1;\\n        a=a-1;\\n        b=b+1;\\n        if(a==0)\\n        {\\n            head1=list1;\\n        }\\n      \\n        else{\\n        while(temp!=null && a>0 && b!=0)\\n        {\\n            temp=temp.next;   \\n            a--;\\n            b--;\\n        }\\n            \\n        head1=temp;   //Getting the a\\'th node of list 1 in head1\\n        }\\n            while(temp!=null && b!=0)\\n            {\\n                b--;              //Getting a  b\\'th node of the the list1 in tail1\\n                temp=temp.next;\\n            }\\n        tail1=temp;\\n        \\n        //Merging the list1 with list2\\n        head1.next=list2;\\n        temp=list2;\\n        while(temp.next!=null)\\n        {\\n            temp=temp.next;\\n        }\\n        temp.next=tail1;\\n        return list1;\\n    }\\n}\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode temp=list1;\\n        ListNode head1=list1;\\n        ListNode tail1=list1;\\n        a=a-1;\\n        b=b+1;\\n        if(a==0)\\n        {\\n            head1=list1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2316798,
                "title": "c-solution-time-o-m-n-memory-o-1-easy-to-understand",
                "content": "```C#\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode MergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int position = 0;\\n        ListNode head = list1, iter1 = list1, removeStart = null, removeEnd = null;\\n        while (iter1 != null) {\\n            if (position == a - 1) removeStart = iter1;\\n            if (position == b + 1) removeEnd = iter1;\\n            \\n            position++;\\n            iter1 = iter1.next;\\n        }\\n        \\n        removeStart.next = list2;\\n        ListNode iter2 = list2;\\n        while (iter2.next != null) iter2 = iter2.next;\\n        iter2.next = removeEnd;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```C#\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode MergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int position = 0;\\n        ListNode head = list1, iter1 = list1, removeStart = null, removeEnd = null;\\n        while (iter1 != null) {\\n            if (position == a - 1) removeStart = iter1;\\n            if (position == b + 1) removeEnd = iter1;\\n            \\n            position++;\\n            iter1 = iter1.next;\\n        }\\n        \\n        removeStart.next = list2;\\n        ListNode iter2 = list2;\\n        while (iter2.next != null) iter2 = iter2.next;\\n        iter2.next = removeEnd;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314770,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head = list1;\\n        ListNode before = null;\\n        ListNode after = null;\\n      \\n        int count = 1;\\n        while(count<a){\\n            count++;\\n            list1 = list1.next;\\n        }\\n        \\n        before = list1;\\n        \\n        while(count<=b+1){\\n            count++;\\n            list1 = list1.next;\\n        }\\n        \\n        after = list1;\\n        \\n        while(list2!=null){\\n            before.next = list2;\\n            before= before.next;\\n            list2 = list2.next;\\n        }\\n        \\n        before.next = after;\\n        before = before.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head = list1;\\n        ListNode before = null;\\n        ListNode after = null;\\n      \\n        int count = 1;\\n        while(count<a){\\n            count++;\\n            list1 = list1.next;\\n        }\\n        \\n        before = list1;\\n        \\n        while(count<=b+1){\\n            count++;\\n            list1 = list1.next;\\n        }\\n        \\n        after = list1;\\n        \\n        while(list2!=null){\\n            before.next = list2;\\n            before= before.next;\\n            list2 = list2.next;\\n        }\\n        \\n        before.next = after;\\n        before = before.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303073,
                "title": "c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n\\n\\t\\t\\tListNode* temp = list1;\\n\\n\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\twhile(cnt != b){\\n\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t\\tcnt++;\\n\\t\\t   }\\n\\n\\n\\t\\t\\tListNode* temp1 = list1;\\n\\n\\t\\t\\tcnt = 0;\\n\\n\\t\\t\\twhile(cnt != a - 1){\\n\\t\\t\\t\\ttemp1 = temp1 -> next;\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(list2 != NULL){\\n\\t\\t\\t\\ttemp1 -> next = list2;\\n\\t\\t\\t\\tlist2 = list2 -> next;\\n\\t\\t\\t\\ttemp1 = temp1 -> next;\\n\\t\\t\\t}\\n\\n\\t\\t\\ttemp1 -> next = temp -> next;\\n\\n\\t\\t\\treturn list1;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n\\n\\t\\t\\tListNode* temp = list1;\\n\\n\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\twhile(cnt != b){\\n\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t\\tcnt++;\\n\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 2286839,
                "title": "faster-than-97-simple-linked-list-traversal-c",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* l1s = list1;\\n        ListNode* l1e = list1;\\n        ListNode* l2t = list2;\\n        while(l2t->next != NULL) l2t = l2t->next;\\n        while(l1s != NULL && --a ) l1s = l1s->next;\\n        while(l1e != NULL && b-- ) l1e = l1e->next;\\n        l1s->next = list2;\\n        l2t->next = l1e->next;\\n        return list1;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9278b03e-c418-42ad-992f-183c1abfaa14_1657903700.4234366.png)\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* l1s = list1;\\n        ListNode* l1e = list1;\\n        ListNode* l2t = list2;\\n        while(l2t->next != NULL) l2t = l2t->next;\\n        while(l1s != NULL && --a ) l1s = l1s->next;\\n        while(l1e != NULL && b-- ) l1e = l1e->next;\\n        l1s->next = list2;\\n        l2t->next = l1e->next;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244156,
                "title": "cpp-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* r = list1;\\n        ListNode* prevr = list1;\\n        int counter = 0;\\n        while(r!=NULL){\\n                if(counter==a)\\n                     break;\\n                prevr = r;\\n                r = r->next;\\n                counter++;\\n        }\\n            if(a!=b){\\n                    r = r->next;\\n                    counter++;\\n            }\\n              prevr->next = list2;\\n              while(list2->next!=NULL)\\n               list2 = list2->next;   \\n            while(r!=NULL){\\n              if(counter==b)\\n                     break;\\n                  r = r->next;\\n                  counter++;\\n            }\\n        list2->next = r->next;\\n            return list1;\\n    }\\n};\\n```\\n[https://github.com/Reehan9/Leetcode-Solutions]",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* r = list1;\\n        ListNode* prevr = list1;\\n        int counter = 0;\\n        while(r!=NULL){\\n                if(counter==a)\\n                     break;\\n                prevr = r;\\n                r = r->next;\\n                counter++;\\n        }\\n            if(a!=b){\\n                    r = r->next;\\n                    counter++;\\n            }\\n              prevr->next = list2;\\n              while(list2->next!=NULL)\\n               list2 = list2->next;   \\n            while(r!=NULL){\\n              if(counter==b)\\n                     break;\\n                  r = r->next;\\n                  counter++;\\n            }\\n        list2->next = r->next;\\n            return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190883,
                "title": "go-o-n-beats-78",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc mergeInBetween(list1 *ListNode, a int, b int, list2 *ListNode) *ListNode {\\n    newList1, count, prev := list1, -1, &ListNode{}\\n    \\n    for newList1 != nil {\\n        count++\\n        \\n        if count == a {\\n            if prev != nil {\\n                prev.Next = list2\\n            }\\n        }\\n        \\n        if count == b {\\n            newList1 = newList1.Next\\n            break\\n        }\\n        \\n        prev = newList1\\n        newList1 = newList1.Next\\n    }\\n    \\n    for list2.Next != nil {\\n        list2 = list2.Next\\n    }\\n    \\n    list2.Next = newList1\\n    \\n    return list1\\n}\\n\\n// Runtime: 106 ms, faster than 78.38% of Go online submissions for Merge In Between Linked Lists.\\n// Memory Usage: 7.2 MB, less than 100.00% of Go online submissions for Merge In Between Linked Lists.\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc mergeInBetween(list1 *ListNode, a int, b int, list2 *ListNode) *ListNode {\\n    newList1, count, prev := list1, -1, &ListNode{}\\n    \\n    for newList1 != nil {\\n        count++\\n        \\n        if count == a {\\n            if prev != nil {\\n                prev.Next = list2\\n            }\\n        }\\n        \\n        if count == b {\\n            newList1 = newList1.Next\\n            break\\n        }\\n        \\n        prev = newList1\\n        newList1 = newList1.Next\\n    }\\n    \\n    for list2.Next != nil {\\n        list2 = list2.Next\\n    }\\n    \\n    list2.Next = newList1\\n    \\n    return list1\\n}\\n\\n// Runtime: 106 ms, faster than 78.38% of Go online submissions for Merge In Between Linked Lists.\\n// Memory Usage: 7.2 MB, less than 100.00% of Go online submissions for Merge In Between Linked Lists.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2190021,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Two Pointer***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Com[plexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        // start point to the node just before ath node\\n        \\n        ListNode* start = list1;\\n        \\n        for(int i = 1; i < a; i++)\\n        {\\n            start = start -> next;\\n        }\\n        \\n        // end point to the node just after bth node\\n        \\n        ListNode* end = list1;\\n        \\n        for(int i = 1; i <= b + 1; i++)\\n        {\\n            end = end -> next;\\n        }\\n        \\n        // last node point to the last node of list2\\n        \\n        ListNode* last = list2;\\n        \\n        while(last -> next)\\n        {\\n            last = last -> next;\\n        }\\n        \\n        // merge and update pointers\\n        \\n        start -> next = list2;\\n        \\n        last -> next = end;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        // start point to the node just before ath node\\n        \\n        ListNode* start = list1;\\n        \\n        for(int i = 1; i < a; i++)\\n        {\\n            start = start -> next;\\n        }\\n        \\n        // end point to the node just after bth node\\n        \\n        ListNode* end = list1;\\n        \\n        for(int i = 1; i <= b + 1; i++)\\n        {\\n            end = end -> next;\\n        }\\n        \\n        // last node point to the last node of list2\\n        \\n        ListNode* last = list2;\\n        \\n        while(last -> next)\\n        {\\n            last = last -> next;\\n        }\\n        \\n        // merge and update pointers\\n        \\n        start -> next = list2;\\n        \\n        last -> next = end;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189809,
                "title": "c-easy-approach-easy-to-understand",
                "content": "``` \\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode*p = list1;\\n        ListNode*q = list1;\\n        ListNode*r= list2; \\n        for(int i =0;i<a-1;i++)p = p->next;\\n        for(int i =0;i<b;i++)q = q->next;\\n        while(r->next) r = r->next;\\n        \\n        p->next = list2;\\n        r->next = q->next;\\n        \\n        return list1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode*p = list1;\\n        ListNode*q = list1;\\n        ListNode*r= list2; \\n        for(int i =0;i<a-1;i++)p = p->next;\\n        for(int i =0;i<b;i++)q = q->next;\\n        while(r->next) r = r->next;\\n        \\n        p->next = list2;\\n        r->next = q->next;\\n        \\n        return list1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2155059,
                "title": "java-iteration",
                "content": "1. Start from the head of list1.\\n2. Reach to the left of \\'a\\'.\\n3. Point that node to the head of list2.\\n4. Point the end/ tail of list2 to the right of \\'b\\'.\\n5. Effectively we have skipped all the nodes from \\'a\\' to \\'b\\' and fitted list2 in between.\\n```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        ListNode prev = list1;\\n        ListNode nexxt = list1;\\n        for(int i=0; i<a-1; i++){\\n            prev=prev.next;\\n        }\\n        for(int i=0; i<b+1; i++){\\n            nexxt=nexxt.next;\\n        }\\n        prev.next=list2;\\n        ListNode temp = list2;\\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        temp.next = nexxt;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        ListNode prev = list1;\\n        ListNode nexxt = list1;\\n        for(int i=0; i<a-1; i++){\\n            prev=prev.next;\\n        }\\n        for(int i=0; i<b+1; i++){\\n            nexxt=nexxt.next;\\n        }\\n        prev.next=list2;\\n        ListNode temp = list2;\\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        temp.next = nexxt;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136107,
                "title": "c-simple-and-easy-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n               ListNode *temp=list1;\\n          ListNode *root=list1;\\n               int count=0,count1=0;\\n               while(count!=a)\\n               {\\n                   temp=temp->next;\\n                   count++;\\n               }\\n               count1=count;\\n               while(count1!=b)\\n               {\\n                  temp=temp->next;\\n                   count1++;\\n               }\\n                temp=temp->next;\\n        while(count!=1)\\n        {\\n          list1=list1->next;\\n            count--;\\n        }\\n        list1->next=list2;\\n        while(list1->next!=NULL)\\n            list1=list1->next;\\n        list1->next=temp;\\n        return root;\\n        \\n              \\n     }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n               ListNode *temp=list1;\\n          ListNode *root=list1;\\n               int count=0,count1=0;\\n               while(count!=a)\\n               {\\n                   temp=temp->next;\\n                   count++;\\n               }\\n               count1=count;\\n               while(count1!=b)\\n               {\\n                  temp=temp->next;\\n                   count1++;\\n               }\\n                temp=temp->next;\\n        while(count!=1)\\n        {\\n          list1=list1->next;\\n            count--;\\n        }\\n        list1->next=list2;\\n        while(list1->next!=NULL)\\n            list1=list1->next;\\n        list1->next=temp;\\n        return root;\\n        \\n              \\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114546,
                "title": "easy-c-solution",
                "content": "here,\\np points to (a-1)th node\\nq points to bth node\\nr points to the last node of second list\\nand we simply make the necessary connections specified in the question.\\n```\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* p = list1,*q=list1;\\n        a-=1;\\n        while(a--){\\n            p=p->next;\\n        }\\n        while(b--){\\n            q=q->next;\\n        }\\n        ListNode *r = list2;\\n        while(r->next){\\n            r=r->next;\\n        }\\n        p->next=list2;\\n        r->next=q->next;\\n        return list1;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "here,\\np points to (a-1)th node\\nq points to bth node\\nr points to the last node of second list\\nand we simply make the necessary connections specified in the question.\\n```\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* p = list1,*q=list1;\\n        a-=1;\\n        while(a--){\\n            p=p->next;\\n        }\\n        while(b--){\\n            q=q->next;\\n        }\\n        ListNode *r = list2;\\n        while(r->next){\\n            r=r->next;\\n        }\\n        p->next=list2;\\n        r->next=q->next;\\n        return list1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2078946,
                "title": "easy-c-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *start=list1;\\n        ListNode *end=list1;\\n        ListNode *mid=list2;\\n        for(int i=0;i<a-1;i++)\\n        {\\n            start=start->next;\\n        }\\n        for(int i=0;i<b+1;i++)\\n        {\\n            end=end->next;\\n        }\\n        while(mid->next)\\n        {\\n            mid=mid->next;\\n        }\\n        start->next=list2;\\n        mid->next=end;\\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *start=list1;\\n        ListNode *end=list1;\\n        ListNode *mid=list2;\\n        for(int i=0;i<a-1;i++)\\n        {\\n            start=start->next;\\n        }\\n        for(int i=0;i<b+1;i++)\\n        {\\n            end=end->next;\\n        }\\n        while(mid->next)\\n        {\\n            mid=mid->next;\\n        }\\n        start->next=list2;\\n        mid->next=end;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054447,
                "title": "brute-force-approach-easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode*ptr1=list1;\\n        ListNode*ptr2=list1;\\n        ListNode*prev=NULL;\\n        int i=0;\\n        while(i!=a)\\n        {\\n            prev=ptr1;\\n            ptr1=ptr1->next;\\n           i++;\\n        }\\n        int j=0;\\n        while(j!=b)\\n        {\\n            ptr2=ptr2->next;\\n            j++;\\n        }\\n        ListNode*ptr3=list2;\\n        while(ptr3->next!=NULL)\\n        {\\n            ptr3=ptr3->next;\\n        }\\n        prev->next=list2;\\n        ptr3->next=ptr2->next;\\n        ptr2->next=NULL;\\n        return list1;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode*ptr1=list1;\\n        ListNode*ptr2=list1;\\n        ListNode*prev=NULL;\\n        int i=0;\\n        while(i!=a)\\n        {\\n            prev=ptr1;\\n            ptr1=ptr1->next;\\n           i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1993177,
                "title": "java-2-ms",
                "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode ptr1=list1;\\n        ListNode ptr2=list1;\\n        a-=1;\\n        while(a!=0)\\n        {ptr1=ptr1.next;a--;}\\n         while(b!=0)\\n        {ptr2=ptr2.next;b--;}\\n        ListNode temp=list2;\\n        while(temp.next!=null)\\n        { temp=temp.next;}\\n        temp.next=ptr2.next;\\n        ptr1.next=list2;\\n        return list1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode ptr1=list1;\\n        ListNode ptr2=list1;\\n        a-=1;\\n        while(a!=0)\\n        {ptr1=ptr1.next;a--;}",
                "codeTag": "Java"
            },
            {
                "id": 1993175,
                "title": "merge-in-between-linked-lists",
                "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head1=list1;\\n        ListNode head2=list2;\\n        ListNode pre=null;\\n        while(a-->0)\\n        {\\n            pre=head1;\\n            head1=head1.next;\\n            b--;\\n        }\\n        while(b-->0)\\n        {\\n           head1=head1.next; \\n        }\\n        while(list2.next!=null)\\n        {\\n            list2=list2.next;\\n        }\\n        pre.next=head2;\\n        list2.next=head1.next;\\n        return list1;\\n    }\\n}****",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head1=list1;\\n        ListNode head2=list2;\\n        ListNode pre=null;\\n        while(a-->0)\\n        {\\n            pre=head1;\\n            head1=head1.next;\\n            b--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1986348,
                "title": "python-easy-approach-faster-than-99-solutions",
                "content": "```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        \\n        t = list2\\n        \\n        while t.next:\\n            t= t.next\\n        \\n        s = list1\\n        count = 0\\n        \\n        while s.next != None:\\n            if count == a-1:\\n                p = s.next\\n                count= count+1\\n                s.next=list2\\n                \\n                while count!= b:\\n                    p=p.next\\n                    count=count+1\\n                t.next = p.next\\n                break\\n                \\n            count=count+1\\n            s=s.next\\n        return list1\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        \\n        t = list2\\n        \\n        while t.next:\\n            t= t.next\\n        \\n        s = list1\\n        count = 0\\n        \\n        while s.next != None:\\n            if count == a-1:\\n                p = s.next\\n                count= count+1\\n                s.next=list2\\n                \\n                while count!= b:\\n                    p=p.next\\n                    count=count+1\\n                t.next = p.next\\n                break\\n                \\n            count=count+1\\n            s=s.next\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910796,
                "title": "straight-forward-short-and-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *s = list1, *e = list1, *c = list2;\\n        \\n        for(int i=0; i<a - 1; i++) s = s -> next;\\n        for(int i=0; i<b + 1; i++) e = e -> next;\\n        \\n        while(c -> next) c = c -> next;\\n        \\n        s -> next = list2;\\n        c -> next = e;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *s = list1, *e = list1, *c = list2;\\n        \\n        for(int i=0; i<a - 1; i++) s = s -> next;\\n        for(int i=0; i<b + 1; i++) e = e -> next;\\n        \\n        while(c -> next) c = c -> next;\\n        \\n        s -> next = list2;\\n        c -> next = e;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876242,
                "title": "easy-solution-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *start=list1,*end=list1;\\n        for(int i=1;i<a;i++){\\n            start=start->next;\\n        }\\n        for(int i=0;i<=b;i++){\\n            end=end->next;\\n        }\\n        ListNode * curr=list2;\\n        ListNode * temp=start->next;\\n        while(temp->next!=end){\\n            ListNode * p=temp;\\n            temp=temp->next;\\n            delete p;\\n        }\\n        start->next=list2;\\n        while(curr->next!=NULL){\\n            curr=curr->next;\\n        }\\n        curr->next=end;\\n        return list1;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *start=list1,*end=list1;\\n        for(int i=1;i<a;i++){\\n            start=start->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1819130,
                "title": "optimised-c-solution",
                "content": "```\\nListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) \\n    {\\n        ListNode* left=list1;\\n        \\n        int tempLeft=a-1,tempRight=b-a+1;\\n        \\n        while(tempLeft--)\\n        {\\n            left=left->next;\\n        }\\n        \\n        ListNode* right=left;\\n        \\n        while(tempRight--)\\n        {\\n            right=right->next;\\n        }\\n        \\n        right=right->next;\\n        \\n        left->next=list2;\\n        \\n        while(list2->next)\\n        {\\n            list2=list2->next;\\n        }\\n        \\n        list2->next=right;\\n        \\n        return list1;\\n    }",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) \\n    {\\n        ListNode* left=list1;\\n        \\n        int tempLeft=a-1,tempRight=b-a+1;\\n        \\n        while(tempLeft--)\\n        {\\n            left=left->next;\\n        }\\n        \\n        ListNode* right=left;\\n        \\n        while(tempRight--)\\n        {\\n            right=right->next;\\n        }\\n        \\n        right=right->next;\\n        \\n        left->next=list2;\\n        \\n        while(list2->next)\\n        {\\n            list2=list2->next;\\n        }\\n        \\n        list2->next=right;\\n        \\n        return list1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1818788,
                "title": "easy-c-sol-o-n-m-with-explanation",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *l1=list1,*l2=list1,*l3=list2;\\n        int a1=a-1,a2=b+1;\\n        while(a1--)   l1 = l1->next;   // Traversing to the ath node\\n        while(a2--)   l2 = l2->next;  // Traversing to the bth node\\n        while(l3->next)   l3 = l3->next;  // Traversing to the last node of the List2\\n        l1->next = list2;     // Pointing ath-1 node to the starting of the List2\\n        l3->next = l2;    // Pointing Last node of the List2 to the bth+1 node\\n        return list1;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *l1=list1,*l2=list1,*l3=list2;\\n        int a1=a-1,a2=b+1;\\n        while(a1--)   l1 = l1->next;   // Traversing to the ath node\\n        while(a2--)   l2 = l2->next;  // Traversing to the bth node\\n        while(l3->next)   l3 = l3->next;  // Traversing to the last node of the List2\\n        l1->next = list2;     // Pointing ath-1 node to the starting of the List2\\n        l3->next = l2;    // Pointing Last node of the List2 to the bth+1 node\\n        return list1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1807001,
                "title": "java-1ms-faster-than-100-w-explanation",
                "content": "\\n*// count list 2 and get it\\'s tail\\n            // count from the beginning of list 1 up to a\\n            // stop\\n            // save that node\\n            // set it\\'s next to the start of list 2\\n            // count up to b\\n            // stop\\n            // set list 2\\'s tail to that next*\\n\\n\\t\\t\\t\\n    class Solution {\\n        public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n            ListNode tail = list2;\\n            while (tail.next != null)\\n            {\\n                tail = tail.next;\\n            }\\n\\n            int counter = 1;\\n\\n            ListNode mid = list1;\\n\\n            while (counter != a)\\n            {\\n                mid = mid.next;\\n                counter ++;\\n            }\\n\\n            ListNode bTail = mid.next;\\n\\n\\n            while (counter != b)\\n            {\\n                bTail = bTail.next;\\n                counter++;\\n            }\\n\\n            mid.next = list2;\\n            tail.next = bTail.next;\\n\\n            return list1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n            ListNode tail = list2;\\n            while (tail.next != null)\\n            {\\n                tail = tail.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1757528,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        ListNode* p=list1;\\n        ListNode* q=list1;\\n        \\n        for(int i=0 ; i<b ; i++){\\n            if(i<a-1) p = p ->next;\\n            q = q->next;\\n        }\\n        \\n        p->next = list2;\\n        \\n        while(list2->next != NULL) list2 = list2->next;\\n        \\n        list2->next = q->next;\\n        \\n        return list1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        ListNode* p=list1;\\n        ListNode* q=list1;\\n        \\n        for(int i=0 ; i<b ; i++){\\n            if(i<a-1) p = p ->next;\\n            q = q->next;\\n        }\\n        \\n        p->next = list2;\\n        \\n        while(list2->next != NULL) list2 = list2->next;\\n        \\n        list2->next = q->next;\\n        \\n        return list1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739302,
                "title": "c-easy-solution",
                "content": "\\'\"  ListNode* last2=list2;\\n        while(last2->next!=NULL){\\n            last2=last2->next;\\n        }\\n        ListNode* temp=list1;\\n        ListNode* prev=NULL;\\n        int i=0;\\n        while(i!=a){\\n              prev=temp;\\n            temp=temp->next;\\n            i++;\\n        }\\n        while(i!=b){\\n            temp=temp->next;\\n            i++;\\n        }\\n        temp=temp->next;\\n        prev->next=list2;\\n        last2->next=temp;\\n        \\n        return list1;  \\'\"",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "\\'\"  ListNode* last2=list2;\\n        while(last2->next!=NULL){\\n            last2=last2->next;\\n        }\\n        ListNode* temp=list1;\\n        ListNode* prev=NULL;\\n        int i=0;\\n        while(i!=a){\\n              prev=temp;\\n            temp=temp->next;\\n            i++;\\n        }\\n        while(i!=b){\\n            temp=temp->next;\\n            i++;\\n        }\\n        temp=temp->next;\\n        prev->next=list2;\\n        last2->next=temp;\\n        \\n        return list1;  \\'\"",
                "codeTag": "Unknown"
            },
            {
                "id": 1733930,
                "title": "runtime-512-ms-faster-than-63-33-memory-usage-24-4-mb-less-than-91-11",
                "content": "find the (a-1)th node\\nassign it to left\\nfind the (b+1)th node\\nassign it to right\\nnow make the (a-1)th next point to 2nd list\\nand using a while loop traverse till last node of list2\\nnow assign right to last node of list2\\n### :)\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def mergeInBetween(self, list1, a, b, list2):\\n        \"\"\"\\n        :type list1: ListNode\\n        :type a: int\\n        :type b: int\\n        :type list2: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        temp = list1\\n        count = 0\\n        if list1 == None:\\n            return list1\\n        while temp:\\n            if count == a-1:\\n                left = temp\\n            if count == b+1:\\n                right = temp\\n            temp = temp.next\\n            count += 1\\n        temp = list2\\n        left.next = temp\\n        while temp:\\n            if temp.next == None:\\n                break\\n            temp = temp.next\\n        temp.next = right\\n        return list1\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def mergeInBetween(self, list1, a, b, list2):\\n        \"\"\"\\n        :type list1: ListNode\\n        :type a: int\\n        :type b: int\\n        :type list2: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        temp = list1\\n        count = 0\\n        if list1 == None:\\n            return list1\\n        while temp:\\n            if count == a-1:\\n                left = temp\\n            if count == b+1:\\n                right = temp\\n            temp = temp.next\\n            count += 1\\n        temp = list2\\n        left.next = temp\\n        while temp:\\n            if temp.next == None:\\n                break\\n            temp = temp.next\\n        temp.next = right\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674104,
                "title": "merge-in-between-linked-lists-easy-to-understand",
                "content": "As it is visible in the question itself, the only way we could merge these two lists into one is to **find the node, prior to node pointed by a** i.e. **a-1** here **aPrior** [to link the head of list2 to list1], and **find the node, past the node pointed by b** i.e. **b+1** here **bPast** [to link the tail of list2 to list1].![image](https://assets.leetcode.com/users/images/7e64b2a8-f1e6-4c15-98cb-a97693e86b42_1641613809.6541631.png)\\n\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2)\\n    {\\n        ListNode *aPrior = 0, *bPast = 0, *tmp = list1;\\n        int loop = 0;\\n        while (aPrior == 0 || bPast == 0) //looping till we find the node a-1 and b+1\\n        {\\n            if (a - 1 == loop)\\n                aPrior = tmp;\\n            if (b + 1 == loop)\\n                bPast = tmp;\\n            tmp = tmp->next;\\n            loop++;\\n        }\\n        tmp = list2;\\n        while (tmp->next != 0) //looping to find out the tail of list2\\n            tmp = tmp->next;\\n        aPrior->next = list2; //linking the head of list2 to List1Node[a-1]\\n        tmp->next = bPast; //linking the tail of list2 to List1Node[b+1]\\n        return list1;\\n    }\\n};\\n```\\n**Happy coding**\\u2764\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2)\\n    {\\n        ListNode *aPrior = 0, *bPast = 0, *tmp = list1;\\n        int loop = 0;\\n        while (aPrior == 0 || bPast == 0) //looping till we find the node a-1 and b+1\\n        {\\n            if (a - 1 == loop)\\n                aPrior = tmp;\\n            if (b + 1 == loop)\\n                bPast = tmp;\\n            tmp = tmp->next;\\n            loop++;\\n        }\\n        tmp = list2;\\n        while (tmp->next != 0) //looping to find out the tail of list2\\n            tmp = tmp->next;\\n        aPrior->next = list2; //linking the head of list2 to List1Node[a-1]\\n        tmp->next = bPast; //linking the tail of list2 to List1Node[b+1]\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653796,
                "title": "weeb-does-python-linked-list-beats-87-54",
                "content": "![image](https://assets.leetcode.com/users/images/c22ae258-98a4-49e5-b429-ecea47ecda89_1640745586.2476802.png)\\nThe idea is simple, we use 2 pointers.\\nOne pointer gets the a-1th node to connect to list2, but before that, we get need the second pointer to get\\nthe b+1th node to for connection.\\nLastly, once we get the a-1th node and b+1th node, we use a flag to continue our first pointer to get the tail of \\nlist2 for connection with the b+1th node on the second pointer.\\n\\n\\t# Definition for singly-linked list.\\n\\t# class ListNode:\\n\\t#     def __init__(self, val=0, next=None):\\n\\t#         self.val = val\\n\\t#         self.next = next\\n\\tclass Solution:\\n\\t\\tdef mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tlow, high = list1, list1\\n\\t\\t\\tflag = False\\n\\n\\t\\t\\twhile count < b+1:\\n\\t\\t\\t\\tif count == a-1:\\n\\t\\t\\t\\t\\twhile count < b+1:\\n\\t\\t\\t\\t\\t\\thigh = high.next\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\t\\t\\tflag = True\\n\\t\\t\\t\\t\\tlow.next = list2\\n\\n\\t\\t\\t\\tif flag: \\n\\t\\t\\t\\t\\twhile low:\\n\\t\\t\\t\\t\\t\\tif not low.next:\\n\\t\\t\\t\\t\\t\\t\\tlow.next = high\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tlow = low.next\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tlow = low.next\\n\\t\\t\\t\\thigh = high.next\\n\\n\\t\\t\\t\\tcount+=1\\n\\n\\t\\t\\treturn list1\\n\\nAlright, enough coding, take a break and watch some anime instead.\\nCheck out **\\u5148\\u8F29\\u304C\\u3046\\u3056\\u3044\\u5F8C\\u8F29\\u306E\\u8A71 (My Senpai is Annoying)**\\n\\n# Episodes: 12\\n# Genres: Comedy, Romance, Slice of Life\\nWholesome and cute anime, definitely a show you would want to watch when you have free time.\\nTry it out, the anime is a solid 7/10.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/c22ae258-98a4-49e5-b429-ecea47ecda89_1640745586.2476802.png)\\nThe idea is simple, we use 2 pointers.\\nOne pointer gets the a-1th node to connect to list2, but before that, we get need the second pointer to get\\nthe b+1th node to for connection.\\nLastly, once we get the a-1th node and b+1th node, we use a flag to continue our first pointer to get the tail of \\nlist2 for connection with the b+1th node on the second pointer.\\n\\n\\t# Definition for singly-linked list.\\n\\t# class ListNode:\\n\\t#     def __init__(self, val=0, next=None):\\n\\t#         self.val = val\\n\\t#         self.next = next\\n\\tclass Solution:\\n\\t\\tdef mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tlow, high = list1, list1\\n\\t\\t\\tflag = False\\n\\n\\t\\t\\twhile count < b+1:\\n\\t\\t\\t\\tif count == a-1:\\n\\t\\t\\t\\t\\twhile count < b+1:\\n\\t\\t\\t\\t\\t\\thigh = high.next\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\t\\t\\tflag = True\\n\\t\\t\\t\\t\\tlow.next = list2\\n\\n\\t\\t\\t\\tif flag: \\n\\t\\t\\t\\t\\twhile low:\\n\\t\\t\\t\\t\\t\\tif not low.next:\\n\\t\\t\\t\\t\\t\\t\\tlow.next = high\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tlow = low.next\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tlow = low.next\\n\\t\\t\\t\\thigh = high.next\\n\\n\\t\\t\\t\\tcount+=1\\n\\n\\t\\t\\treturn list1\\n\\nAlright, enough coding, take a break and watch some anime instead.\\nCheck out **\\u5148\\u8F29\\u304C\\u3046\\u3056\\u3044\\u5F8C\\u8F29\\u306E\\u8A71 (My Senpai is Annoying)**\\n\\n# Episodes: 12\\n# Genres: Comedy, Romance, Slice of Life\\nWholesome and cute anime, definitely a show you would want to watch when you have free time.\\nTry it out, the anime is a solid 7/10.",
                "codeTag": "Java"
            },
            {
                "id": 1636386,
                "title": "easy-solution-100-faster-than-other",
                "content": "```\\nstruct ListNode* mergeInBetween(struct ListNode* list1, int a, int b, struct ListNode* list2){\\n\\n        struct ListNode* ptr=NULL,*temp=list1,*ptr2=NULL;\\n    int count=0;\\n    b+=2;\\n    while(temp!=NULL)\\n    {\\n        count++;\\n        if(count==a)\\n        {\\n            ptr=temp;\\n        }\\n        if(count==b)\\n            ptr2=temp;\\n        temp=temp->next;\\n    }\\n    ptr->next=list2;\\n    while(list2->next!=NULL)\\n    {\\n        list2=list2->next;\\n    }\\n    list2->next=ptr2;\\n        return list1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nstruct ListNode* mergeInBetween(struct ListNode* list1, int a, int b, struct ListNode* list2){\\n\\n        struct ListNode* ptr=NULL,*temp=list1,*ptr2=NULL;\\n    int count=0;\\n    b+=2;\\n    while(temp!=NULL)\\n    {\\n        count++;\\n        if(count==a)\\n        {\\n            ptr=temp;\\n        }\\n        if(count==b)\\n            ptr2=temp;\\n        temp=temp->next;\\n    }\\n    ptr->next=list2;\\n    while(list2->next!=NULL)\\n    {\\n        list2=list2->next;\\n    }\\n    list2->next=ptr2;\\n        return list1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1628982,
                "title": "very-very-very-easy-c-solution-100-doraemon",
                "content": "\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n    \\n        ListNode* temp1=list1;\\n        ListNode* temp2=list1;\\n        \\n        int count=0;\\n        while(temp2!=NULL && count!=b+1 ){\\n            \\n            if(count==a-1){\\n                temp1=temp2;\\n            }\\n            \\n            temp2=temp2->next;\\n            count++;\\n        }\\n        \\n        temp1->next=list2;\\n        \\n        while(list2->next!=NULL){\\n            list2=list2->next;\\n        }\\n        \\n        list2->next=temp2;\\n        \\n        return list1;\\n        \\n        \\n    }",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n    \\n        ListNode* temp1=list1;\\n        ListNode* temp2=list1;\\n        \\n        int count=0;\\n        while(temp2!=NULL && count!=b+1 ){\\n            \\n            if(count==a-1){\\n                temp1=temp2;\\n            }\\n            \\n            temp2=temp2->next;\\n            count++;\\n        }\\n        \\n        temp1->next=list2;\\n        \\n        while(list2->next!=NULL){\\n            list2=list2->next;\\n        }\\n        \\n        list2->next=temp2;\\n        \\n        return list1;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1620769,
                "title": "js-92-one-pass",
                "content": "```\\nvar mergeInBetween = function(list1, a, b, list2) {\\n    let idx = 1; // find pointer_a before a\\n    const head = list1;\\n    let pointer_a = null;\\n    let pointer_b = null;\\n    while (list1) {\\n        if (idx === a) pointer_a = list1;\\n        if (idx - 1 === b) pointer_b = list1;\\n        list1 = list1.next;\\n        idx++;\\n    }\\n    pointer_a.next = list2;\\n    while (list2.next) list2 = list2.next;\\n    list2.next = pointer_b.next;\\n    return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar mergeInBetween = function(list1, a, b, list2) {\\n    let idx = 1; // find pointer_a before a\\n    const head = list1;\\n    let pointer_a = null;\\n    let pointer_b = null;\\n    while (list1) {\\n        if (idx === a) pointer_a = list1;\\n        if (idx - 1 === b) pointer_b = list1;\\n        list1 = list1.next;\\n        idx++;\\n    }\\n    pointer_a.next = list2;\\n    while (list2.next) list2 = list2.next;\\n    list2.next = pointer_b.next;\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1614807,
                "title": "c-easy-code",
                "content": "\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* mergeInBetween(ListNode* head1, int a, int b, ListNode* head2)\\n\\t\\t{\\n\\t\\t\\tListNode* runner=head1;\\n\\t\\t\\tListNode *start=NULL,*end=NULL;\\n\\t\\t\\tfor(int i=0;i<=b+1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i==a-1) start=runner;\\n\\t\\t\\t\\tif(i==b+1)  end = runner;\\n\\t\\t\\t\\trunner=runner->next;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tListNode* tail2 = NULL;\\n\\n\\t\\t\\trunner=head2;\\n\\t\\t\\twhile(runner)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(runner->next==NULL)\\n\\t\\t\\t\\t\\ttail2=runner;\\n\\n\\t\\t\\t\\trunner=runner->next;\\n\\t\\t\\t}\\n\\t\\t\\tstart->next=head2;\\n\\t\\t\\ttail2->next=end;\\n\\t\\t\\treturn head1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* mergeInBetween(ListNode* head1, int a, int b, ListNode* head2)\\n\\t\\t{\\n\\t\\t\\tListNode* runner=head1;\\n\\t\\t\\tListNode *start=NULL,*end=NULL;\\n\\t\\t\\tfor(int i=0;i<=b+1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i==a-1) start=runner;\\n\\t\\t\\t\\tif(i==b+1)  end = runner;\\n\\t\\t\\t\\trunner=runner->next;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1610890,
                "title": "here-is-my-c-solution-faster-than-99-user",
                "content": "In this what you can do is first find two pointers pointing to desired positions then just delink them and put second linked list there\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) \\n    {\\n        ListNode * curr1=list1,*curr2=list1;\\n        long long list1a=a;\\n        long long list1b=b;\\n        while(list1a>1)\\n        {\\n                curr1=curr1->next;\\n                list1a--;\\n        }\\n        while(list1b>0)\\n        {\\n                curr2=curr2->next;\\n                list1b--;\\n        }\\n        if(a==b)\\n        {\\n            ListNode * temp=curr1->next->next;\\n            curr1->next=list2;\\n            ListNode* curr3=list2;\\n            while(curr3->next!=nullptr)\\n            {\\n                curr3=curr3->next;\\n            }\\n            curr3->next=temp;\\n            curr2->next=nullptr;\\n            return list1;\\n\\n        }\\n        curr1->next=list2;\\n        ListNode* curr3=list2;\\n        while(curr3->next!=nullptr)\\n        {\\n            curr3=curr3->next;\\n        }\\n        curr3->next=curr2->next;\\n        curr2->next=nullptr;\\n        return list1;\\n    }\\n};\\'\\'\\'\\n\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) \\n    {\\n        ListNode * curr1=list1,*curr2=list1;\\n        long long list1a=a;\\n        long long list1b=b;\\n        while(list1a>1)\\n        {\\n                curr1=curr1->next;\\n                list1a--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1600769,
                "title": "c-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n       ListNode* t = list1;\\n        ListNode* pre=list1;\\n         \\n        while(a--){\\n            pre=t;\\n            t=t->next;\\n        }\\n        t=list1;\\n        while(b--){\\n            t=t->next;\\n        }\\n          t=t->next;\\n        pre->next=NULL;\\n        pre->next=list2;\\n        \\n        while(list2->next){\\n            list2=list2->next;\\n        }\\n           list2->next=t;\\n        return list1;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n       ListNode* t = list1;\\n        ListNode* pre=list1;\\n         \\n        while(a--){\\n            pre=t;\\n            t=t->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1581045,
                "title": "c-easy-to-understand-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *point=list1,*temp=list1;\\n        for(int i=0;i<=b;i++){\\n            if(i<a-1){\\n                point=point->next;\\n                temp=temp->next;\\n            }\\n            else    temp=temp->next;\\n        }\\n        point->next=list2;\\n        while(list2->next!=NULL){\\n            list2=list2->next;\\n        }\\n        list2->next=temp;\\n        return list1;\\n    }\\n};\\n```\\n\\n**RESULT:**\\n\\n**Runtime:** 256 ms, faster than 98.79% of C++ online submissions for Merge In Between Linked Lists.\\n**Memory Usage:** 94.4 MB, less than 92.96% of C++ online submissions for Merge In Between Linked Lists.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *point=list1,*temp=list1;\\n        for(int i=0;i<=b;i++){\\n            if(i<a-1){\\n                point=point->next;\\n                temp=temp->next;\\n            }\\n            else    temp=temp->next;\\n        }\\n        point->next=list2;\\n        while(list2->next!=NULL){\\n            list2=list2->next;\\n        }\\n        list2->next=temp;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549248,
                "title": "straight-forward-java-solution-100-faster-runtime-with-comments",
                "content": "```class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i = 1;\\n        ListNode mid1 = list1, mid2 = list2;\\n        \\n        // Storing mid1 value by traversing \\'a-1\\' node\\n        for(; i < a; i++) {\\n            mid1 = mid1.next;\\n        }\\n        \\n        mid2 = mid1;\\n        \\n        // Traversing a-(b+1) times to store \\'b-1\\' node\\n        for(; i <= b+1; i++){\\n            mid2 = mid2.next;\\n        }\\n       \\n        // assigning \\'head\\' of first list as next of mid1\\n        mid1.next = list2;\\n        \\n        // storing end of 2nd linkedlist in list2\\n        while(list2.next != null) list2 = list2.next;\\n        \\n        // assigning mid2 to last node of list2\\n        list2.next = mid2;\\n        \\n        return list1;\\n        \\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i = 1;\\n        ListNode mid1 = list1, mid2 = list2;\\n        \\n        // Storing mid1 value by traversing \\'a-1\\' node\\n        for(; i < a; i++) {\\n            mid1 = mid1.next;\\n        }\\n        \\n        mid2 = mid1;\\n        \\n        // Traversing a-(b+1) times to store \\'b-1\\' node\\n        for(; i <= b+1; i++){\\n            mid2 = mid2.next;\\n        }\\n       \\n        // assigning \\'head\\' of first list as next of mid1\\n        mid1.next = list2;\\n        \\n        // storing end of 2nd linkedlist in list2\\n        while(list2.next != null) list2 = list2.next;\\n        \\n        // assigning mid2 to last node of list2\\n        list2.next = mid2;\\n        \\n        return list1;\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1513894,
                "title": "o-n-slouation-most-fastest",
                "content": "\\n## JUST DO ONE THING FIND THE START NODE (s) AND FINISH NODE (f)\\n## then store new linklist next to start and triverse new linklist to the end\\n## store finish pointer to next of end\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* h, int a, int b, ListNode* n) {\\n        ListNode *s,*f;\\n        auto *p=h;\\n        int c = 0;\\n        while(h!=NULL)\\n        {\\n            if(c==(a-1)) s=h;\\n            if(c==(b+1)) f=h;\\n            c++;\\n            h=h->next;\\n        }\\n        s->next = n;\\n        while(n->next != NULL)\\n        {\\n            n=n->next;\\n        }\\n        n->next = f;\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* h, int a, int b, ListNode* n) {\\n        ListNode *s,*f;\\n        auto *p=h;\\n        int c = 0;\\n        while(h!=NULL)\\n        {\\n            if(c==(a-1)) s=h;\\n            if(c==(b+1)) f=h;\\n            c++;\\n            h=h->next;\\n        }\\n        s->next = n;\\n        while(n->next != NULL)\\n        {\\n            n=n->next;\\n        }\\n        n->next = f;\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510316,
                "title": "c-ac-straightforward",
                "content": "*1) Reach to the position a and b*\\n*2)Insert the second list*\\n*3)return first list after insertion*\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n       \\n        ListNode*p=list1;\\n        ListNode*q=list1;\\n        while(a>1){\\n            a--;\\n            p=p->next;\\n        }\\n        while(b){\\n            b--;\\n            q=q->next;\\n        }\\n        \\n        ListNode*tmp=q->next;\\n        q=NULL;\\n        p->next=list2;\\n        \\n        while(p->next){\\n            p=p->next;\\n        }\\n        p->next=tmp;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n       \\n        ListNode*p=list1;\\n        ListNode*q=list1;\\n        while(a>1){\\n            a--;\\n            p=p->next;\\n        }\\n        while(b){\\n            b--;\\n            q=q->next;\\n        }\\n        \\n        ListNode*tmp=q->next;\\n        q=NULL;\\n        p->next=list2;\\n        \\n        while(p->next){\\n            p=p->next;\\n        }\\n        p->next=tmp;\\n        \\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495435,
                "title": "java-o-n-m-solution",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head = list1;\\n        ListNode aBreak;\\n        for(int i=1;i<a;i++) list1=list1.next;\\n        aBreak=list1.next;\\n        list1.next=list2;\\n        while(list1.next!=null) list1=list1.next;\\n        for(int i=0;i<b-a+1;i++) aBreak=aBreak.next;\\n        list1.next=aBreak;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode head = list1;\\n        ListNode aBreak;\\n        for(int i=1;i<a;i++) list1=list1.next;\\n        aBreak=list1.next;\\n        list1.next=list2;\\n        while(list1.next!=null) list1=list1.next;\\n        for(int i=0;i<b-a+1;i++) aBreak=aBreak.next;\\n        list1.next=aBreak;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492358,
                "title": "kotlin-solution",
                "content": "```\\n    fun mergeInBetween(list1: ListNode?, a: Int, b: Int, list2: ListNode?): ListNode? {\\n        var tempA = a\\n        var tempB = b - a\\n        var head1 = list1\\n        var head2 = list2\\n        var list2Tail: ListNode? = null\\n\\n        while (tempA-- > 1) {\\n            head1 = head1?.next\\n        }\\n\\t\\t\\n        val initReplace: ListNode? = head1\\n\\t\\t\\n        while (tempB-- >= 0) {\\n            head1 = head1?.next\\n        }\\n\\t\\t\\n        val finishReplace: ListNode? = head1?.next\\n\\n        while (head2 != null) {\\n            list2Tail = head2\\n            head2 = head2.next\\n        }\\n\\n        initReplace?.next = list2\\n\\n        list2Tail?.next = finishReplace\\n        return list1\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    fun mergeInBetween(list1: ListNode?, a: Int, b: Int, list2: ListNode?): ListNode? {\\n        var tempA = a\\n        var tempB = b - a\\n        var head1 = list1\\n        var head2 = list2\\n        var list2Tail: ListNode? = null\\n\\n        while (tempA-- > 1) {\\n            head1 = head1?.next\\n        }\\n\\t\\t\\n        val initReplace: ListNode? = head1\\n\\t\\t\\n        while (tempB-- >= 0) {\\n            head1 = head1?.next\\n        }\\n\\t\\t\\n        val finishReplace: ListNode? = head1?.next\\n\\n        while (head2 != null) {\\n            list2Tail = head2\\n            head2 = head2.next\\n        }\\n\\n        initReplace?.next = list2\\n\\n        list2Tail?.next = finishReplace\\n        return list1\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1478425,
                "title": "java-easy-solution-2ms",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int a1 = 0;\\n        int b1 = 0;\\n        ListNode l1 = list1;\\n        ListNode l2 = list1;\\n\\t\\t\\n        while (a1 != (a - 1)) {\\n            l1 = l1.next;\\n            a1++;\\n        }\\n      \\n        while (b1 != b) {\\n            l2 = l2.next;\\n            b1++;\\n        }\\n\\t\\t\\n        ListNode tail = list2;\\n        while (tail.next != null) {\\n            tail = tail.next;\\n        }\\n        l1.next = list2;\\n        tail.next = l2.next;\\n        \\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int a1 = 0;\\n        int b1 = 0;\\n        ListNode l1 = list1;\\n        ListNode l2 = list1;\\n\\t\\t\\n        while (a1 != (a - 1)) {\\n            l1 = l1.next;\\n            a1++;\\n        }\\n      \\n        while (b1 != b) {\\n            l2 = l2.next;\\n            b1++;\\n        }\\n\\t\\t\\n        ListNode tail = list2;\\n        while (tail.next != null) {\\n            tail = tail.next;\\n        }\\n        l1.next = list2;\\n        tail.next = l2.next;\\n        \\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462161,
                "title": "90-faster-python",
                "content": "```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    # def __init__(self):\\n    #     self.count=0\\n\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        add=[]\\n        count=0\\n        node=list1\\n        while(node):\\n            if count==a-1:\\n                add.append(node)\\n            if count==b+1:\\n                add.append(node)\\n                break\\n            node=node.next\\n            count+=1\\n        node=list2\\n        while(node):\\n            if node.next==None:\\n                node.next=add[1]\\n                break\\n            node=node.next\\n        add[0].next=list2\\n        return list1\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    # def __init__(self):\\n    #     self.count=0\\n\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        add=[]\\n        count=0\\n        node=list1\\n        while(node):\\n            if count==a-1:\\n                add.append(node)\\n            if count==b+1:\\n                add.append(node)\\n                break\\n            node=node.next\\n            count+=1\\n        node=list2\\n        while(node):\\n            if node.next==None:\\n                node.next=add[1]\\n                break\\n            node=node.next\\n        add[0].next=list2\\n        return list1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455108,
                "title": "c-o-n",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* l1, int a, int b, ListNode* l2) {\\n        auto t = l1;\\n        int cnt = 0;\\n        ListNode* x;\\n        ListNode* y;\\n        while(t){\\n            if(cnt==a-1) x=t;\\n            if(cnt==b) y=t;\\n            cnt++;\\n            t=t->next;\\n        }\\n        x->next = l2;\\n        auto tm = l2;\\n        while(tm->next) tm=tm->next;\\n        tm->next = y->next;\\n        y->next=NULL;\\n        return l1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* l1, int a, int b, ListNode* l2) {\\n        auto t = l1;\\n        int cnt = 0;\\n        ListNode* x;\\n        ListNode* y;\\n        while(t){\\n            if(cnt==a-1) x=t;\\n            if(cnt==b) y=t;\\n            cnt++;\\n            t=t->next;\\n        }\\n        x->next = l2;\\n        auto tm = l2;\\n        while(tm->next) tm=tm->next;\\n        tm->next = y->next;\\n        y->next=NULL;\\n        return l1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451768,
                "title": "python",
                "content": "Idea : use count to know current node position. Use prev to record the parent of curr node.\\ninit curr = list1\\ngoing through curr and add count\\nif count == a:\\n\\tit means we can assign the prev.next = list2\\n\\tthen we find the last node of list2 in while loop\\nif count == b:\\n\\tit means the next of last node of list2 should be assigned to curr.next\\n\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        \\n        dummy = ListNode(-1)\\n        dummy.next = list1\\n        \\n        curr = list1\\n        prev = dummy\\n        count = 0\\n        \\n        while curr:\\n            \\n            if count == a:\\n                prev.next = list2\\n                while list2.next:\\n                    list2 = list2.next\\n            if count == b:\\n                list2.next = curr.next\\n                \\n            prev = curr\\n            curr = curr.next\\n            count += 1\\n            \\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        \\n        dummy = ListNode(-1)\\n        dummy.next = list1\\n        \\n        curr = list1\\n        prev = dummy\\n        count = 0\\n        \\n        while curr:\\n            \\n            if count == a:\\n                prev.next = list2\\n                while list2.next:\\n                    list2 = list2.next\\n            if count == b:\\n                list2.next = curr.next\\n                \\n            prev = curr\\n            curr = curr.next\\n            count += 1\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449996,
                "title": "java-solution",
                "content": "- divide the problem into 2 parts\\n\\t- when the value of a is 0 (i.e when we have to delete the nodes in first list from starting)\\n\\t- when we have to delete the nodes except from the starting!\\n\\n```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        if(a == 0)\\n        {\\n            ListNode temp = list1;\\n            ListNode nextPointer;\\n            int i = -1;\\n            while(true)\\n            {\\n                i++;\\n                if(i == b-1)\\n                {\\n                    nextPointer = temp.next;\\n                    break;\\n                }\\n                temp = temp.next;\\n            }\\n            // in second loop\\n            ListNode temp2 = list2;\\n            while(temp2.next!=null)\\n            {\\n                temp2 = temp2.next;\\n            }\\n            temp2.next = nextPointer;\\n            return list2;\\n        }\\n        else{\\n            ListNode prev = list1;\\n            ListNode next;\\n            ListNode temp = list1;\\n            int i =-1;\\n            while(i!=b-1)\\n            {\\n                i++;\\n                if(i == a-1)\\n                {\\n                    prev = temp;\\n                }\\n                temp = temp.next;\\n            }\\n            next = temp.next;\\n            prev.next = list2;\\n            while(list2.next!=null)\\n                list2 = list2.next;\\n            list2.next = next;\\n            return list1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        if(a == 0)\\n        {\\n            ListNode temp = list1;\\n            ListNode nextPointer;\\n            int i = -1;\\n            while(true)\\n            {\\n                i++;\\n                if(i == b-1)\\n                {\\n                    nextPointer = temp.next;\\n                    break;\\n                }\\n                temp = temp.next;\\n            }\\n            // in second loop\\n            ListNode temp2 = list2;\\n            while(temp2.next!=null)\\n            {\\n                temp2 = temp2.next;\\n            }\\n            temp2.next = nextPointer;\\n            return list2;\\n        }\\n        else{\\n            ListNode prev = list1;\\n            ListNode next;\\n            ListNode temp = list1;\\n            int i =-1;\\n            while(i!=b-1)\\n            {\\n                i++;\\n                if(i == a-1)\\n                {\\n                    prev = temp;\\n                }\\n                temp = temp.next;\\n            }\\n            next = temp.next;\\n            prev.next = list2;\\n            while(list2.next!=null)\\n                list2 = list2.next;\\n            list2.next = next;\\n            return list1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441148,
                "title": "best-c-solution",
                "content": "```\\nListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *temp = list1, *temp1 = list1;\\n        ListNode  *last = list2;\\n        for(int i=1; i<a;i++){\\n            temp = temp->next;\\n        }\\n        for(int i=1; i<=b+1;i++){\\n            temp1 = temp1->next;\\n        }\\n        temp->next = list2;\\n        while(last->next!=NULL){\\n            last = last->next;\\n        }\\n        last->next = temp1;\\n        \\n        \\n        return list1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode *temp = list1, *temp1 = list1;\\n        ListNode  *last = list2;\\n        for(int i=1; i<a;i++){\\n            temp = temp->next;\\n        }\\n        for(int i=1; i<=b+1;i++){\\n            temp1 = temp1->next;\\n        }\\n        temp->next = list2;\\n        while(last->next!=NULL){\\n            last = last->next;\\n        }\\n        last->next = temp1;\\n        \\n        \\n        return list1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1421527,
                "title": "java-simple-solution-beat-100-java-online-solution",
                "content": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode prev = null, cur = list1;\\n        int x = 0;\\n        while( x < a) {\\n            prev = cur;\\n            cur = cur.next;\\n            x++;\\n        }\\n        while(x <= b) {\\n            cur = cur.next;\\n            x++;\\n        }\\n        ListNode cur1 = list2;\\n        prev.next = cur1;\\n        while(cur1 != null) {\\n            prev = cur1;\\n            cur1 = cur1.next;\\n        }\\n        prev.next = cur;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode prev = null, cur = list1;\\n        int x = 0;\\n        while( x < a) {\\n            prev = cur;\\n            cur = cur.next;\\n            x++;\\n        }\\n        while(x <= b) {\\n            cur = cur.next;\\n            x++;\\n        }\\n        ListNode cur1 = list2;\\n        prev.next = cur1;\\n        while(cur1 != null) {\\n            prev = cur1;\\n            cur1 = cur1.next;\\n        }\\n        prev.next = cur;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408408,
                "title": "java-straight-forward-easy-solution",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i=0, j=0;\\n     \\n        ListNode p = list1, q = list1, end = list2;\\n        \\n        while( i < a-1){\\n            p = p.next;\\n            i++;\\n        }\\n        \\n        while( j < b){\\n            q = q.next;\\n            j++;\\n        }\\n        \\n        while(end.next != null){\\n            end = end.next;\\n        }\\n        \\n        p.next = list2;\\n        end.next = q.next;\\n        \\n        return list1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int i=0, j=0;\\n     \\n        ListNode p = list1, q = list1, end = list2;\\n        \\n        while( i < a-1){\\n            p = p.next;\\n            i++;\\n        }\\n        \\n        while( j < b){\\n            q = q.next;\\n            j++;\\n        }\\n        \\n        while(end.next != null){\\n            end = end.next;\\n        }\\n        \\n        p.next = list2;\\n        end.next = q.next;\\n        \\n        return list1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395661,
                "title": "java-100-o-n",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode temp = list1;\\n        ListNode k = list1;\\n        int c =0;\\n        while(c!=b){\\n            k = k.next;\\n            c++;\\n        }\\n        int c1 = 1;\\n        while(c1!=a){\\n            temp = temp.next;\\n            c1++;\\n        }\\n        temp.next = list2;\\n        while(temp.next!=null){\\n            temp = temp.next;\\n        }\\n        temp.next = k.next;\\n        return list1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode temp = list1;\\n        ListNode k = list1;\\n        int c =0;\\n        while(c!=b){\\n            k = k.next;\\n            c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1395653,
                "title": "simple-simple-simple-simple-simple-c-soluction",
                "content": "ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        ListNode *curr = list1;\\n        \\n        for(int i=1;i<a;i++)\\n            curr = curr->next;\\n        \\n        ListNode *temp1 = curr;\\n        \\n         ListNode *ar = list1;\\n        for(int i=0;i<b;i++)\\n          ar = ar->next;\\n        \\n        ListNode * car = list2;\\n        \\n        while(car->next !=0)\\n             car = car->next;\\n        \\n        curr->next = list2;\\n        car->next = ar->next;\\n        \\n        return list1;\\n         \\n              \\n    }****",
                "solutionTags": [],
                "code": "ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        \\n        ListNode *curr = list1;\\n        \\n        for(int i=1;i<a;i++)\\n            curr = curr->next;\\n        \\n        ListNode *temp1 = curr;\\n        \\n         ListNode *ar = list1;\\n        for(int i=0;i<b;i++)\\n          ar = ar->next;\\n        \\n        ListNode * car = list2;\\n        \\n        while(car->next !=0)\\n             car = car->next;\\n        \\n        curr->next = list2;\\n        car->next = ar->next;\\n        \\n        return list1;\\n         \\n              \\n    }****",
                "codeTag": "Unknown"
            },
            {
                "id": 1342367,
                "title": "easiest-approach-faster-than-100-00-of-java-online-submissions",
                "content": "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        ListNode head=list1;      \\n        ListNode tail=list1;\\n        \\n\\t\\t//Traversing till (a-1)th node\\n\\t\\t\\n        for(int i=0;i<a-1;i++){\\n            list1=list1.next;\\n        }\\n\\t\\t//Making list2  as the next of (a-1)th node\\n\\t\\t\\n\\t\\t  list1.next=list2;\\n        \\n\\t\\t//Storing (b+1)th node in tail\\n\\t\\t\\n         for(int i=0;i<=b;i++){\\n            tail=tail.next;\\n        }\\n         \\n\\t\\t //traversing till the last node of list2\\n\\t\\t \\n      while(list2!=null){\\n          list2=list2.next;\\n          list1=list1.next;\\n      }\\n        \\n        list1.next=tail;\\n        \\n        return head;\\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        ListNode head=list1;      \\n        ListNode tail=list1;\\n        \\n\\t\\t//Traversing till (a-1)th node\\n\\t\\t\\n        for(int i=0;i<a-1;i++){\\n            list1=list1.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1333331,
                "title": "c-faster-than-99",
                "content": "If you can optimize it further, please comment it down.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n\\t\\t\\tios_base::sync_with_stdio(false);\\n\\t\\t\\tcin.tie(nullptr);\\n\\t\\t\\tcout.tie(nullptr);\\n        \\n\\t\\t\\tListNode* temp = list1;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile(temp){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tif(count == a){\\n\\t\\t\\t\\t\\tListNode* prev_temp = temp->next;\\n\\t\\t\\t\\t\\ttemp->next = list2;\\n\\t\\t\\t\\t\\ttemp = prev_temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(count == b+1){\\n\\t\\t\\t\\t\\twhile(list2->next){\\n\\t\\t\\t\\t\\t\\tlist2 = list2->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlist2->next = temp->next;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttemp = temp->next;\\n\\t\\t\\t}\\n\\t\\t\\treturn list1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n\\t\\t\\tios_base::sync_with_stdio(false);\\n\\t\\t\\tcin.tie(nullptr);\\n\\t\\t\\tcout.tie(nullptr);\\n        \\n\\t\\t\\tListNode* temp = list1;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile(temp){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tif(count == a){\\n\\t\\t\\t\\t\\tListNode* prev_temp = temp->next;\\n\\t\\t\\t\\t\\ttemp->next = list2;\\n\\t\\t\\t\\t\\ttemp = prev_temp;\\n\\t\\t\\t\\t}",
                "codeTag": "C++"
            },
            {
                "id": 1322915,
                "title": "c-solution",
                "content": "public ListNode MergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n         ListNode dummy = new ListNode(0, list1);\\n            ListNode reference_node = dummy;\\n            int count = 0;\\n            while (list1 != null)\\n            {\\n                count++;\\n                if (count-1 != a && count-1 < a)\\n                {\\n                    if (reference_node.next != null)\\n                        reference_node = reference_node.next;\\n                }                \\n                else if(count-1 == a)\\n                {\\n                    reference_node.next = list2;\\n                    while (list2.next !=  null)\\n                    {\\n                        list2 = list2.next;\\n                    }                  \\n                }\\n                if(count-1 == b)\\n                {\\n                   list2.next = list1.next;\\n                }                \\n                list1 = list1.next;\\n            }\\n            return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "public ListNode MergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n         ListNode dummy = new ListNode(0, list1);\\n            ListNode reference_node = dummy;\\n            int count = 0;\\n            while (list1 != null)\\n            {\\n                count++;\\n                if (count-1 != a && count-1 < a)\\n                {\\n                    if (reference_node.next != null)\\n                        reference_node = reference_node.next;\\n                }                \\n                else if(count-1 == a)\\n                {\\n                    reference_node.next = list2;\\n                    while (list2.next !=  null)\\n                    {\\n                        list2 = list2.next;\\n                    }                  \\n                }\\n                if(count-1 == b)\\n                {\\n                   list2.next = list1.next;\\n                }                \\n                list1 = list1.next;\\n            }\\n            return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1321616,
                "title": "c-easy-and-beginner-friendly-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n   \\n        ListNode *prev=NULL, *cur=list1, *next=NULL;\\n       \\n        int k=0;\\n        while(k<=b && cur)\\n        {\\n            if(k== a-1)       //for storing the node before \\'a\\'th node\\n                prev=cur;\\n            if(k==b)           //for storing the node after \\'b\\'th node\\n            {\\n                next=cur->next;\\n                break;\\n            }\\n            cur=cur->next;\\n            ++k;\\n        }\\n        prev->next = list2;          //adding list2 to list1 at \\'a\\'th position\\n        \\n\\t\\twhile(list2->next)\\n         list2=list2->next;       //to get the last node of list2\\n        \\n        list2->next = next;      //adding the remaining list1 at end of list2\\n        \\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n   \\n        ListNode *prev=NULL, *cur=list1, *next=NULL;\\n       \\n        int k=0;\\n        while(k<=b && cur)\\n        {\\n            if(k== a-1)       //for storing the node before \\'a\\'th node\\n                prev=cur;\\n            if(k==b)           //for storing the node after \\'b\\'th node\\n            {\\n                next=cur->next;\\n                break;\\n            }\\n            cur=cur->next;\\n            ++k;\\n        }\\n        prev->next = list2;          //adding list2 to list1 at \\'a\\'th position\\n        \\n\\t\\twhile(list2->next)\\n         list2=list2->next;       //to get the last node of list2\\n        \\n        list2->next = next;      //adding the remaining list1 at end of list2\\n        \\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295474,
                "title": "simple-java-code-easy-to-understand",
                "content": "Dry run on a piece of paper and you will get it , its pretty straightforward \\n\\n```\\n// TC : linear \\n// SC : constant \\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode curr = list1;\\n        ListNode node1 = null;\\n        ListNode node2 = null;\\n        int idx = 0;\\n        while(curr!=null){\\n            if(idx==a-1){\\n                node1 = curr;\\n                curr = curr.next;\\n            }else if(idx==b){\\n                node2 = curr.next;\\n                curr.next = null;\\n                curr = node2;\\n            }else curr = curr.next;\\n            idx++;\\n        }\\n        node1.next = list2;\\n        curr = list2;\\n        while(curr.next!=null){\\n            curr = curr.next;\\n        }\\n        curr.next = node2;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// TC : linear \\n// SC : constant \\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode curr = list1;\\n        ListNode node1 = null;\\n        ListNode node2 = null;\\n        int idx = 0;\\n        while(curr!=null){\\n            if(idx==a-1){\\n                node1 = curr;\\n                curr = curr.next;\\n            }else if(idx==b){\\n                node2 = curr.next;\\n                curr.next = null;\\n                curr = node2;\\n            }else curr = curr.next;\\n            idx++;\\n        }\\n        node1.next = list2;\\n        curr = list2;\\n        while(curr.next!=null){\\n            curr = curr.next;\\n        }\\n        curr.next = node2;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293448,
                "title": "merge-in-between-linked-lists-cpp-beats-92",
                "content": "Hello, this is my first time posting on the leetcode discussion forum. I\\'m doing this now because this is the first time where I solved a medium level problem without looking at the solution or without any help. So, I just wanted to celebrate that by posting it here. Enough talking, let\\'s get into the code :3\\n\\nWe will be running three `while` loops. One is to keep track of the `b`th position, another is to keep track of the `a`th position and the other is to loop through the list. \\n\\nAt first we initialise two integers `counta` and `countb` to check for `a` and `b`. \\n\\nThe first loop is to find out where `b` ends, so that the `prev` will be pointing to `b+1`th node. This is the position where the end of the `list2` should be merged with `list1`.\\n\\nThe second loop is to find out where `a` ends, so that the `list1` can be broken and what this `curr->next = head2` does is that it breaks the `list1` and connects `list1` to `list2`. \\n\\nThe third loop is pretty simple, it\\'s just looping through the list with `curr` pointer.\\n\\nAt the end we say `curr->next = prev` to join back from `list2` to `list1`.\\n\\nThe logic is pretty simple, if you take a look at the code you\\'ll probably understand. \\n\\n```\\n\\t/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* head1, int a, int b, ListNode* head2) {\\n        ListNode* curr = head1;\\n        ListNode* prev = head1;\\n        int counta = 0; int countb = 0;\\n        while(prev->next!=NULL && countb<b+1){\\n            prev = prev->next;\\n            countb++;\\n        }\\n        while(curr->next!=NULL && counta<a-1) {                            \\n            curr = curr->next;       \\n            counta++;                \\n        }        \\n        curr->next = head2;\\n        while(curr->next!=NULL){\\n            curr = curr->next;\\n        }\\n        curr->next = prev;\\n        return head1;\\n    }\\n}; \\n```\\n\\nP.S: There might be numerous submissions which are better than this, but this is the first time I solved a medium level problem without any guidance or looking at the solution. Pls feel free to comment and suggest improvements. Thank you and have a great day :\\')",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n\\t/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* head1, int a, int b, ListNode* head2) {\\n        ListNode* curr = head1;\\n        ListNode* prev = head1;\\n        int counta = 0; int countb = 0;\\n        while(prev->next!=NULL && countb<b+1){\\n            prev = prev->next;\\n            countb++;\\n        }\\n        while(curr->next!=NULL && counta<a-1) {                            \\n            curr = curr->next;       \\n            counta++;                \\n        }        \\n        curr->next = head2;\\n        while(curr->next!=NULL){\\n            curr = curr->next;\\n        }\\n        curr->next = prev;\\n        return head1;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293124,
                "title": "python-details-clear-logic",
                "content": "\\t\\t# pre and cur ptr\\n        l1 = list1\\n        pre = list1\\n        cur = pre.next\\n        #put cur ptr at b node\\n        for i in range(b-1):\\n            cur = cur.next\\n        #put pre ptr at node before a node\\n        for j in range(a-1):\\n            pre = pre.next\\n        # link pre node to list2 head\\n        pre.next = list2\\n        #find list2 length\\n        l2 = 1\\n        while list2 and list2.next:\\n            l2 +=1\\n            list2 = list2.next\\n        #put pre ptr at list2 last node\\n        for k in range(l2):\\n            pre = pre.next\\n        #link pre node to node after b node \\n        pre.next = cur.next\\n        #cut the b node link\\n        cur.next = None\\n        return l1",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "\\t\\t# pre and cur ptr\\n        l1 = list1\\n        pre = list1\\n        cur = pre.next\\n        #put cur ptr at b node\\n        for i in range(b-1):\\n            cur = cur.next\\n        #put pre ptr at node before a node\\n        for j in range(a-1):\\n            pre = pre.next\\n        # link pre node to list2 head\\n        pre.next = list2\\n        #find list2 length\\n        l2 = 1\\n        while list2 and list2.next:\\n            l2 +=1\\n            list2 = list2.next\\n        #put pre ptr at list2 last node\\n        for k in range(l2):\\n            pre = pre.next\\n        #link pre node to node after b node \\n        pre.next = cur.next\\n        #cut the b node link\\n        cur.next = None\\n        return l1",
                "codeTag": "Unknown"
            },
            {
                "id": 1277360,
                "title": "java-easy-to-understand-100-faster-0ms",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n\\n        ListNode start = list1;\\n        int count = 0;\\n\\n        while (count<a-1){\\n            start = start.next;\\n            count++;\\n\\n        }\\n\\n        ListNode end = start.next;\\n        start.next = list2;\\n\\n        while (count<b){\\n            end = end.next;\\n            count++;\\n\\n        }\\n        \\n        while (list2.next!=null){\\n            list2 = list2.next;\\n        }\\n\\n        list2.next = end;\\n\\n        return list1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n\\n        ListNode start = list1;\\n        int count = 0;\\n\\n        while (count<a-1){\\n            start = start.next;\\n            count++;\\n\\n        }\\n\\n        ListNode end = start.next;\\n        start.next = list2;\\n\\n        while (count<b){\\n            end = end.next;\\n            count++;\\n\\n        }\\n        \\n        while (list2.next!=null){\\n            list2 = list2.next;\\n        }\\n\\n        list2.next = end;\\n\\n        return list1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271598,
                "title": "three-pointers-needed-to-solve-this-java-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode p1 = list1, p2 = list1, p3 = list2;\\n        \\n        for(int i=1 ; i<a ; i++){\\n            p1 = p1.next;\\n        }\\n        \\n        for(int i=1 ; i<=b+1 ; i++){\\n            p2 = p2.next;\\n        }\\n        \\n        while(p3.next != null){\\n            p3 = p3.next;\\n        }\\n        \\n        p1.next = list2;\\n        p3.next = p2;\\n        \\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode p1 = list1, p2 = list1, p3 = list2;\\n        \\n        for(int i=1 ; i<a ; i++){\\n            p1 = p1.next;\\n        }\\n        \\n        for(int i=1 ; i<=b+1 ; i++){\\n            p2 = p2.next;\\n        }\\n        \\n        while(p3.next != null){\\n            p3 = p3.next;\\n        }\\n        \\n        p1.next = list2;\\n        p3.next = p2;\\n        \\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269715,
                "title": "java-straight-forward-with-o-n-time-complexity-and-o-1-space-complexity",
                "content": "```\\n   public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode list1Temp = list1;\\n        ListNode list3 = null;\\n        int count = 1;\\n        //Create a new list3 which has all the elements after b\\n        while (list1Temp != null) {\\n            if (b == count) {\\n                list3 = list1Temp.next.next;\\n            } \\n            count ++;\\n            list1Temp = list1Temp.next;\\n        }\\n      \\n        // Add list2 after A and add list3 after the last element in the loop.\\n         ListNode list1Temp2 = list1;\\n        int newCount = 1;\\n        while(list1Temp2 != null) {\\n            if (a == newCount) {\\n                list1Temp2.next = list2;\\n            }\\n            if (list1Temp2.next == null) {\\n                list1Temp2.next = list3;\\n                break;\\n            }\\n            newCount++;\\n            list1Temp2 = list1Temp2.next;\\n        }\\n        return list1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode list1Temp = list1;\\n        ListNode list3 = null;\\n        int count = 1;\\n        //Create a new list3 which has all the elements after b\\n        while (list1Temp != null) {\\n            if (b == count) {\\n                list3 = list1Temp.next.next;\\n            } \\n            count ++;\\n            list1Temp = list1Temp.next;\\n        }\\n      \\n        // Add list2 after A and add list3 after the last element in the loop.\\n         ListNode list1Temp2 = list1;\\n        int newCount = 1;\\n        while(list1Temp2 != null) {\\n            if (a == newCount) {\\n                list1Temp2.next = list2;\\n            }\\n            if (list1Temp2.next == null) {\\n                list1Temp2.next = list3;\\n                break;\\n            }\\n            newCount++;\\n            list1Temp2 = list1Temp2.next;\\n        }\\n        return list1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1249945,
                "title": "very-simple-java-soln",
                "content": "```\\npublic ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode l1 = list1;\\n        ListNode prev = null;\\n        ListNode cur = null;\\n        \\n        //set prev node at a idx and cur node at b idx\\n        while(b-- > 0){\\n            if(--a == 0)\\n                prev = l1;\\n            l1 = l1.next;\\n        }\\n        cur = l1;\\n        \\n        //get l2 as tail of list2\\n        ListNode l2 = list2;\\n        while(l2.next!=null){\\n            l2 = l2.next;\\n        }\\n        \\n        //create links\\n        prev.next = list2;\\n        l2.next = cur.next;\\n        cur.next = null;\\n        return list1;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode l1 = list1;\\n        ListNode prev = null;\\n        ListNode cur = null;\\n        \\n        //set prev node at a idx and cur node at b idx\\n        while(b-- > 0){\\n            if(--a == 0)\\n                prev = l1;\\n            l1 = l1.next;\\n        }\\n        cur = l1;\\n        \\n        //get l2 as tail of list2\\n        ListNode l2 = list2;\\n        while(l2.next!=null){\\n            l2 = l2.next;\\n        }\\n        \\n        //create links\\n        prev.next = list2;\\n        l2.next = cur.next;\\n        cur.next = null;\\n        return list1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1248695,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* curr = list1;\\n        ListNode* t1;\\n        ListNode* t2;\\n        while(curr!=nullptr){\\n            if(curr->val==a-1){\\n                t1=curr;\\n            }\\n            if(curr->val==b+1){\\n                t2=curr;\\n            }\\n            curr=curr->next;\\n        }\\n        t1->next=list2;\\n        curr = list2;\\n        while(curr->next!=nullptr){\\n            curr=curr->next;\\n        }\\n        curr->next=t2;\\n        return list1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        ListNode* curr = list1;\\n        ListNode* t1;\\n        ListNode* t2;\\n        while(curr!=nullptr){\\n            if(curr->val==a-1){\\n                t1=curr;\\n            }\\n            if(curr->val==b+1){\\n                t2=curr;\\n            }\\n            curr=curr->next;\\n        }\\n        t1->next=list2;\\n        curr = list2;\\n        while(curr->next!=nullptr){\\n            curr=curr->next;\\n        }\\n        curr->next=t2;\\n        return list1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235851,
                "title": "simple-java-sol-100",
                "content": "Runtime: 1 ms, faster than 100.00% of Java online submissions for Merge In Between Linked Lists.\\nMemory Usage: 42.7 MB, less than 83.26% of Java online submissions for Merge In Between Linked Lists.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        ListNode enode = list2;\\n\\n        while(enode.next!=null){\\n            enode = enode.next;\\n        }\\n        \\n        ListNode node = list1;\\n        ListNode nodeA = list1;\\n        ListNode nodeB = list1;\\n        \\n        int c = 0;\\n        \\n        while(node!=null){\\n            \\n            if(c+1 == a){\\n                nodeA = node;\\n            }\\n            \\n            if(c == b){\\n                nodeB = node.next;\\n                node.next = null;\\n            }\\n            \\n            node = node.next;\\n            c++;\\n        }\\n        \\n        nodeA.next = list2;\\n        enode.next = nodeB;\\n        \\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        ListNode enode = list2;\\n\\n        while(enode.next!=null){\\n            enode = enode.next;\\n        }\\n        \\n        ListNode node = list1;\\n        ListNode nodeA = list1;\\n        ListNode nodeB = list1;\\n        \\n        int c = 0;\\n        \\n        while(node!=null){\\n            \\n            if(c+1 == a){\\n                nodeA = node;\\n            }\\n            \\n            if(c == b){\\n                nodeB = node.next;\\n                node.next = null;\\n            }\\n            \\n            node = node.next;\\n            c++;\\n        }\\n        \\n        nodeA.next = list2;\\n        enode.next = nodeB;\\n        \\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218933,
                "title": "java-easy-beats-100",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode node1=null,node2=null,temp=list1;\\n        for(int i=0;i<=b;i++){\\n            if(a-1==i){\\n                node1=temp;\\n                //System.out.println(temp.val+\" a\");\\n            }\\n            \\n            if(b==i){\\n                node2=temp;\\n                //System.out.println(temp.val+\" b\");\\n                break;\\n            }\\n            //System.out.println(temp.val);\\n            \\n            temp=temp.next;\\n        }\\n        \\n        node1.next=list2;\\n        temp=list2;\\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        temp.next=node2.next;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode node1=null,node2=null,temp=list1;\\n        for(int i=0;i<=b;i++){\\n            if(a-1==i){\\n                node1=temp;\\n                //System.out.println(temp.val+\" a\");\\n            }\\n            \\n            if(b==i){\\n                node2=temp;\\n                //System.out.println(temp.val+\" b\");\\n                break;\\n            }\\n            //System.out.println(temp.val);\\n            \\n            temp=temp.next;\\n        }\\n        \\n        node1.next=list2;\\n        temp=list2;\\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        temp.next=node2.next;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213082,
                "title": "wrong-test-case",
                "content": "I think this test case might be incorrect.\\n\\n```\\nInput:\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]\\n```",
                "solutionTags": [],
                "code": "```\\nInput:\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1196625,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        int x=1;\\n        ListNode*temp1=list1,*temp2=list1,*temp3=list2;\\n        \\n        while(x < a && temp1->next){\\n            temp1 = temp1->next;\\n            x++;\\n        }\\n        x=0;\\n        while(x<=b && temp2){\\n            temp2 = temp2->next;\\n            x++;\\n        }\\n        while(temp3->next!=NULL){\\n            temp3 =temp3->next;\\n        }\\n        \\n        temp1->next = list2;\\n        temp3->next = temp2;\\n        \\n        return list1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\\n        int x=1;\\n        ListNode*temp1=list1,*temp2=list1,*temp3=list2;\\n        \\n        while(x < a && temp1->next){\\n            temp1 = temp1->next;\\n            x++;\\n        }\\n        x=0;\\n        while(x<=b && temp2){\\n            temp2 = temp2->next;\\n            x++;\\n        }\\n        while(temp3->next!=NULL){\\n            temp3 =temp3->next;\\n        }\\n        \\n        temp1->next = list2;\\n        temp3->next = temp2;\\n        \\n        return list1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188530,
                "title": "java-1ms-43-2mb",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode aPrevNode = list1;\\n        b-=a;\\n        while(a > 1){\\n            a--;\\n            aPrevNode = aPrevNode.next;\\n        }\\n        ListNode bNode = aPrevNode;\\n        while(b >= 0){\\n            b--;\\n            bNode = bNode.next;\\n        }\\n        bNode = bNode.next;\\n        aPrevNode.next = list2;\\n        while(aPrevNode.next != null)\\n            aPrevNode = aPrevNode.next;\\n        aPrevNode.next = bNode;\\n        return list1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode aPrevNode = list1;\\n        b-=a;\\n        while(a > 1){\\n            a--;\\n            aPrevNode = aPrevNode.next;\\n        }\\n        ListNode bNode = aPrevNode;\\n        while(b >= 0){\\n            b--;\\n            bNode = bNode.next;\\n        }\\n        bNode = bNode.next;\\n        aPrevNode.next = list2;\\n        while(aPrevNode.next != null)\\n            aPrevNode = aPrevNode.next;\\n        aPrevNode.next = bNode;\\n        return list1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172486,
                "title": "java-1ms-100-faster",
                "content": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        //traversing the first pointer to a-1 index\\n        ListNode start = list1;\\n        for(int i =1; i < a; i++){\\n            start = start.next;\\n        }\\n        \\n        //traversing the end pointer to b+1 index\\n        ListNode end = list1;\\n        for(int i = 1; i <= b + 1; i++){\\n            end = end.next;\\n        }\\n        \\n        //traversing to the end node of list2 so it can point to end node\\n        ListNode ep = list2;\\n        while(ep.next != null)ep = ep.next;\\n        \\n        //joining both list\\n        start.next = list2;\\n        ep.next = end;\\n        \\n        return list1;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        //traversing the first pointer to a-1 index\\n        ListNode start = list1;\\n        for(int i =1; i < a; i++){\\n            start = start.next;\\n        }\\n        \\n        //traversing the end pointer to b+1 index\\n        ListNode end = list1;\\n        for(int i = 1; i <= b + 1; i++){\\n            end = end.next;\\n        }\\n        \\n        //traversing to the end node of list2 so it can point to end node\\n        ListNode ep = list2;\\n        while(ep.next != null)ep = ep.next;\\n        \\n        //joining both list\\n        start.next = list2;\\n        ep.next = end;\\n        \\n        return list1;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575162,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1568510,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1837523,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1575379,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1575456,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1818757,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 2065047,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 2038457,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1996823,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1830109,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1575162,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1568510,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1837523,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1575379,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1575456,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1818757,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 2065047,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 2038457,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1996823,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            },
            {
                "id": 1830109,
                "content": [
                    {
                        "username": "ekansh_04",
                        "content": "Just want to remind you that question is about from ath  node to bth node not to find that nodes which have value as \\'a\\' and \\'b\\'.\\n\\nit was silly mistake but i made that one and i actually passed 60/61 cases. So just be careful and reread the promt."
                    },
                    {
                        "username": "Kundan_yadav",
                        "content": "same here"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "same mistake , leetcode vague description for the win as always."
                    },
                    {
                        "username": "ImTheCurse",
                        "content": "how the hell you\\'ve passed all the test except for one?"
                    },
                    {
                        "username": "IsiTemi789",
                        "content": "I literally just made the same mistake! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "same mistake\\uD83D\\uDE05"
                    },
                    {
                        "username": "MayuD",
                        "content": "[@thalodsanjeev](/thalodsanjeev) Same :)"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "yes bro, i made the same mistake, and suprised that 60 test cases are passed"
                    },
                    {
                        "username": "krishnendu2",
                        "content": "\\nInput: [0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\nOutput: [0,1000000,1000001,1000002,5]\\nExpected: [0,3,2,1000000,1000001,1000002,5]\\n\\nThis is the only testcase that is failing in my code. When a =3 and b = 4 i think my output is the right one. Can anybody explain where I\\'m missing?"
                    },
                    {
                        "username": "mdabdulrahman",
                        "content": "[@dhruvs_777](/dhruvs_777) Thanks! I also confused"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "bro 3 and 4 is index number \\n"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "Hey mate so your solution is wrong because you are trying to find the node values. Rather the question is not clear on its statement that we have to work on index. What i mean is that. We have to take the size of the node not the value. Hence currently your program is \\nincluding 0, 5 from list 1 because value 3 is found on index 1. And value 4 is found at index 4.\\nWhereas, it should have done is included 0,3,2,5 from list 1. Because you have to exclude values from index 3 to index 4. Which will include values: 1,4.\\n\\nFor more you can see my solution: https://leetcode.com/problems/merge-in-between-linked-lists/discuss/2641130/traverse-and-join-bruteforce-approach-o-n-time-complexity\\n\\n\\n"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Read this and Thank me later....\\n\\n1. Consider list1 and list2 as a head of the linkedlist.\\n2. Traverse the list1 and store the address of (a-1)th node in variable.\\n3. Traverse the list1 and store the address of (b+1)th node in another variable.\\n4. Traverse the list2 and store the address of last node in variable.\\n5. Now link  (a-1)th node to list2. list2 last node to (b+1)th node."
                    },
                    {
                        "username": "user0533n",
                        "content": "Can some one please explain this test case  ?\\n\\n[0,3,2,1,4,5]\\n3\\n4\\n[1000000,1000001,1000002]\\n\\nOutput:\\n[0,1000000,1000001,1000002,5]\\nExpected:\\n[0,3,2,1000000,1000001,1000002,5]"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Look for indexes not the node values"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you are supposed to use indices, not values"
                    },
                    {
                        "username": "PRHYME",
                        "content": "![image](https://assets.leetcode.com/users/images/5a34a391-df39-448c-99be-3731c2d5b37c_1624734536.4688926.png)\\n\\nif a is 3 in input why are they expecting it to be included in the desired output? Is this an internal bug?"
                    },
                    {
                        "username": "the_ghost16",
                        "content": "we have to remove the position not value ."
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "Its not the value but the position of the node"
                    },
                    {
                        "username": "s1tsao",
                        "content": "Just want to point out a problem with the description, because I spent a few minutes confused. When they refer to the ath and bth node, they really mean a+1 and b+1 node. Better way of saying would be the ath index or bth index since that would imply the count starts at 0"
                    },
                    {
                        "username": "rsolovye",
                        "content": "Agree, if solved by the description of the problem, a-th and b-th nodes should not be in the output list, but they are present in the test cases.\\n \\nI had to advance pointer from the a-th node and last pointer of the list2 to the next node to pass tests"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "only one quention arasises are these list sorted?\\n"
                    },
                    {
                        "username": "AryanP45",
                        "content": "should be tagged Easy"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "THIS BLODDY QUESTION! WHO MADE THIS ? WHY ARE THE INSTRUCTIONS SO UNCLEAR ?????? \\nTHE SAMPLE TEST CASES ARE TOOOOOOO MISLEADING"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Nice hint was provided)"
                    }
                ]
            }
        ]
    },
    {
        "title": "First Day Where You Have Been in All the Rooms",
        "question_content": "<p>There are <code>n</code> rooms you need to visit, labeled from <code>0</code> to <code>n - 1</code>. Each day is labeled, starting from <code>0</code>. You will go in and visit one room a day.</p>\n\n<p>Initially on day <code>0</code>, you visit room <code>0</code>. The <strong>order</strong> you visit the rooms for the coming days is determined by the following <strong>rules</strong> and a given <strong>0-indexed</strong> array <code>nextVisit</code> of length <code>n</code>:</p>\n\n<ul>\n\t<li>Assuming that on a day, you visit room <code>i</code>,</li>\n\t<li>if you have been in room <code>i</code> an <strong>odd</strong> number of times (<strong>including</strong> the current visit), on the <strong>next</strong> day you will visit a room with a <strong>lower or equal room number</strong> specified by <code>nextVisit[i]</code> where <code>0 &lt;= nextVisit[i] &lt;= i</code>;</li>\n\t<li>if you have been in room <code>i</code> an <strong>even</strong> number of times (<strong>including</strong> the current visit), on the <strong>next</strong> day you will visit room <code>(i + 1) mod n</code>.</li>\n</ul>\n\n<p>Return <em>the label of the <strong>first</strong> day where you have been in <strong>all</strong> the rooms</em>. It can be shown that such a day exists. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nextVisit = [0,0]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\n- On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.\n&nbsp; On the next day you will visit room nextVisit[0] = 0\n- On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.\n&nbsp; On the next day you will visit room (0 + 1) mod 2 = 1\n- On day 2, you visit room 1. This is the first day where you have been in all the rooms.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nextVisit = [0,0,2]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong>\nYour room visiting order for each day is: [0,0,1,0,0,1,2,...].\nDay 6 is the first day where you have been in all the rooms.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nextVisit = [0,1,2,0]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong>\nYour room visiting order for each day is: [0,0,1,1,2,2,3,...].\nDay 6 is the first day where you have been in all the rooms.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nextVisit.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nextVisit[i] &lt;= i</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1445225,
                "title": "python-short-dp-explained",
                "content": "The idea is that we need to go back a lot of times. Define by `dp[i]` is number of days to reach cell `i`. We can only reach it from the cell `i-1`, so we need at least `dp[i-1]` steps. Then it will lead us to `dp[A[i-1]]` cell, because we visited `i-1` for the first time. Then we need to reach `i-1` from `A[i-1]` again. And finally we need one more step. \\n\\n#### Complexity\\nIt is `O(n)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, A):\\n        n, M = len(A), 10**9 + 7\\n        dp = [0]*n\\n        for i in range(1, n):\\n            dp[i] = (2*dp[i-1] - dp[A[i-1]] + 2) % M\\n\\n        return dp[-1]  \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, A):\\n        n, M = len(A), 10**9 + 7\\n        dp = [0]*n\\n        for i in range(1, n):\\n            dp[i] = (2*dp[i-1] - dp[A[i-1]] + 2) % M\\n\\n        return dp[-1]  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445156,
                "title": "c-dp",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. DP\\n\\nLet `dp[i]` be the number of days needed to jump from room `0` to room `i`. The answer is `dp[N - 1]`.\\n\\nFor `dp[i]`, on top of the days needed for reaching room `i-1`, i.e. `dp[i-1]`, we need these extra days to go from room `i-1` to room `i`.\\n\\n* If `A[i-1] == i-1`, we just need 2 days\\n* Otherwise, we need to jump to room `A[i-1]` first, taking 1 day. Then spent `dp[i-1] - dp[A[i-1]]` days to go from room `A[i-1]` to room `i-1` again. Lastly, take 1 day to go from room `i-1` to room `i`. So in total, we need extra `2 + dp[i-1] - dp[A[i-1]]` days.\\n\\nAfter some simplification, we get the following:\\n```\\ndp[i] = dp[i-1]                           // days needed to reach room i - 1\\n          + 2 + dp[i-1] - dp[A[i-1]]      // days needed to go from room i - 1 to room i\\n      = 2 + 2 * dp[i-1] - dp[A[i-1]]\\n               where 0 <= i < N - 1\\ndp[0] = 0\\n```\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/first-day-where-you-have-been-in-all-the-rooms/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& A) {\\n        long mod = 1e9 + 7, N = A.size();\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i < N; ++i) {\\n            dp[i] = ((long)2 + 2 * dp[i - 1] - dp[A[i - 1]] + mod) % mod;\\n        }\\n        return dp[N - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i] = dp[i-1]                           // days needed to reach room i - 1\\n          + 2 + dp[i-1] - dp[A[i-1]]      // days needed to go from room i - 1 to room i\\n      = 2 + 2 * dp[i-1] - dp[A[i-1]]\\n               where 0 <= i < N - 1\\ndp[0] = 0\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/first-day-where-you-have-been-in-all-the-rooms/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& A) {\\n        long mod = 1e9 + 7, N = A.size();\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i < N; ++i) {\\n            dp[i] = ((long)2 + 2 * dp[i - 1] - dp[A[i - 1]] + mod) % mod;\\n        }\\n        return dp[N - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445203,
                "title": "very-concise-c-dp-solution-o-n-with-explanation",
                "content": "Let\\'s say f[i] denotes the number of days that is needed to visit room i for the first time, and g[i] denotes the number of days to visit room i for the second time. \\nObviously we have f[0] = 1. Since 0 <= nextVisit[i] <= i, nextVisit[0] must be 0, so we also have g[0] = 2.\\n\\nNow let\\'s do the calculation of f[i] and g[i] (1 <= i < n):\\nConsidering that **0 <= nextVisit[i] <= i** (**with the nextVisit array we cannot proceed, only jump back**), the first time we reach room i, we must be coming from room i - 1 (even number of times). So we can say `f[i] = (g[i - 1] + 1) % MODN`\\n\\nTo calculate g[i], we must first reach room i taking f[i] days. Then we need to jump back to nextVisit[i]. Let\\'s say we will need d days to restart from nextVisit[i] and get back to room i again. We will have: `g[i] = (f[i] + 1 + d)`\\n\\nThe question now comes to how do we calculate d: we can notice that before we jump back to room nextVisit[i], room nextVisit[i] must have been visited **even** number of times (remember we cannot proceed with odd number of room visits). **The same rule applies to when we restart from nextVisit[i] to get to room i for the first time (f[i])**. So we can have `d = f[i] - f[nextVisit[i]]`\\n\\nFinally we have `g[i] = (f[i] * 2 - f[nextVisit[i]] + 1) % MODN`\\n```\\nclass Solution {\\n    const int MODN = 1000000007;\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        vector<long long> f(n, 0), g(n, 0);\\n        f[0] = 1;\\n        g[0] = 2;\\n        for (int i = 1; i < n; ++i) {\\n            f[i] = (g[i - 1] + 1) % MODN;\\n            g[i] = (f[i] * 2 + MODN - f[nextVisit[i]] + 1) % MODN;\\n        }\\n        return (f[n - 1] + MODN - 1) % MODN;\\n    }\\n};\\n```\\nPlease let me know if you have any questions. Kindly upvote if this answer helped you! Thanks :-)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int MODN = 1000000007;\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        vector<long long> f(n, 0), g(n, 0);\\n        f[0] = 1;\\n        g[0] = 2;\\n        for (int i = 1; i < n; ++i) {\\n            f[i] = (g[i - 1] + 1) % MODN;\\n            g[i] = (f[i] * 2 + MODN - f[nextVisit[i]] + 1) % MODN;\\n        }\\n        return (f[n - 1] + MODN - 1) % MODN;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455070,
                "title": "simulation-dp-alternative",
                "content": "This one was very hard for me. I tried to simulate and memoise cycles, but it failed stronger test cases (TLE).\\n\\n\\nI could not see a DP transition, so I kept on working on the simulation. Perhaps it would be easier to understand.\\n\\n1. When we visit a `room` for the first time on day `d1`, we store that day in `first[room]`.\\n\\t- Since the first visit is an odd visit, we go to the room specified in `nextVisit`.\\n\\t- But before we go, we remember the current room in `prev`.\\n2. When we visit the same `room` again on day `d2`, that means that we have a cycle. \\n\\t- The length of the cycle is `d2 - first[room]`. \\n\\t- After we add those days, we will be in the room after `prev` (we will visit `prev` one day before that, and it will be an even visit).\\n\\nI needed to whiteboard this to figure out the solution; here is an illustration of cycles and transitions for test case `[0,0,0,1,0,2]`.\\n\\n![image](https://assets.leetcode.com/users/images/b254581a-adf6-4373-a794-96b399ce1947_1631258725.6442018.png)\\n\\n**C++**\\n```cpp\\nint firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n    long long n = nextVisit.size(), total = 0, day = 0, room = 0, prev = 0, mod = 1000000007;\\n    vector<long long> visited(n), first(n, 0);\\n    while (total < n) {\\n        if (++visited[room] == 1) {\\n            ++total;\\n            first[room] = day++;\\n            prev = room;\\n            room = nextVisit[room]; \\n        }\\n        else {\\n            day = (mod + day + day - first[room]) % mod;\\n            room = (prev + 1) % n;\\n        }\\n    }\\n    return day - 1;\\n}   \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n    long long n = nextVisit.size(), total = 0, day = 0, room = 0, prev = 0, mod = 1000000007;\\n    vector<long long> visited(n), first(n, 0);\\n    while (total < n) {\\n        if (++visited[room] == 1) {\\n            ++total;\\n            first[room] = day++;\\n            prev = room;\\n            room = nextVisit[room]; \\n        }\\n        else {\\n            day = (mod + day + day - first[room]) % mod;\\n            room = (prev + 1) % n;\\n        }\\n    }\\n    return day - 1;\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445218,
                "title": "python-dp-with-explanation",
                "content": "I imagined the problem as a graph where we have two edges from each node, one for when the room is visited even number of time and one for when it is visited odd number of times. The important things to note are:\\n1. We want the visits for a particular node to become even in order to go to the next node. \\n2. The other thing we notice is that all the nodes before that have even number of visits as they have allowed to visit their next node.\\n\\nNow, when we first visit a node it obviously has odd number of visits so we need to first visit the node `nextVisit[i]` and come back to the same node to get even number of visits. To prevent recomputing this we define `dp[i]` as the number of days it took to reach node `i` starting from node `0` giving use the relation `dp[i+1] = dp[i] + 1(for going to nextVisit[i]) + (dp[i] - dp[nextVisit[i]])(for coming back to same node) + 1(for going to next node)` the final relation is `dp[i+1] = (2 * dp[i] + 2 - dp[nextVisit[i]]) % mod`.\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n = len(nextVisit);\\n        dp = [0 for _ in range(n)];\\n        mod = int(1e9+7);\\n        for i in range(n-1):\\n            dp[i+1] = (2 * dp[i] + 2 - dp[nextVisit[i]]) % mod;\\n        return dp[n-1];\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n = len(nextVisit);\\n        dp = [0 for _ in range(n)];\\n        mod = int(1e9+7);\\n        for i in range(n-1):\\n            dp[i+1] = (2 * dp[i] + 2 - dp[nextVisit[i]]) % mod;\\n        return dp[n-1];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463203,
                "title": "c-detailed-explanation-o-n-dp",
                "content": "There two major observation in the problem.\\n(i) If the count of visit of ith room is odd we cannot move forward.\\n(ii) In order to move forward from i -> i+1 room all rooms <= i must have an even count of visit\\n\\nNow let us assume dp[i] is no. of days required to reach i rooms\\ndp[0] = 0\\n\\nWe start from room 1 now we\\'ll have basically two condn. dp[i-1] == nextVisit[i-1]\\nor dp[i-1] != nextVisit[i-1];\\n\\n(i) For fist condn. we will always require 2 more days to reach the next day.\\nsay you have nextVisit as : [0,1,2]\\n\\nfor 0 -> 0 days\\n    1 -> 2 days\\n    2 -> 4 days\\n    \\n   and so on\\n\\nso we can say dp[i] = dp[i-1] + 2;\\n\\n(ii) For second condn. it\\'s a path we retrace say we have nextVisit as : [0,1,0]\\n\\nfor 0 and 1 it\\'ll be case(i)\\nfor 2 our path so far is 0->0->1->1->2\\nnow from 2 we reach 0 and we again retrace that path hence it becomes\\n0->0->1->1->2->0->0->1->1->2->3\\n\\nSo, we can see total days require is 10 and we can generalise this as\\n\\ndp[i] = dp[i-1] + (dp[i-1] - dp[nextVisit[i-1]]) + 2\\n\\nWhich means as follows\\ndp[i-1] : is the no. of days require to reach i-1 rooms\\ndp[i-1] - dp[nextVisit[i-1]] : is the no. of days to reach i-1th room again from nextVisit[i-1]\\n2 : is the i-1 to nextVisit[i-1] + i-1 to i in above example it is from 2->0 and 2->3 that is\\n    2 extra days will always be required.\\n\\nIf you like the explaination please upvote.\\n\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        int mod = 1e9 + 7;\\n        long long dp[n];\\n        dp[0] = 0;\\n        \\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            if(dp[i-1] == nextVisit[i-1])\\n                dp[i] = dp[i-1] + 2;\\n            else\\n                dp[i] = (2 + 2*dp[i-1] + mod - dp[nextVisit[i-1]])%mod;\\n        }\\n        \\n        return (int) dp[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        int mod = 1e9 + 7;\\n        long long dp[n];\\n        dp[0] = 0;\\n        \\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            if(dp[i-1] == nextVisit[i-1])\\n                dp[i] = dp[i-1] + 2;\\n            else\\n                dp[i] = (2 + 2*dp[i-1] + mod - dp[nextVisit[i-1]])%mod;\\n        }\\n        \\n        return (int) dp[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459388,
                "title": "understanding-the-logic",
                "content": "There are 2 key points that help us solve this question.\\n**1. The first time you reach room *i*, it will always be from position *i-1.***\\nFrom position *i-1*, you can either go to *i* or *nextVisit[i-1]* but *nextVisit[i-1] <= i-1* as given in the problem statement. Thus, to go ahead, you visit *i-1* again if number of visits are not even and then visit *i*  for the first time.\\n\\n**2. The first time you reach room *i*, all previous room will have been visited even number of times.**\\nTo  move to room i, i-1 must have been visited even number of times, subsequently to have visited i-1, i-2 must have been visited even number of times and so on.\\n\\nThus, we can break down the process of reaching room *i* into these sub-problems.\\n**1. Reach to room *i-1* for the first time.**\\nWe can maintain a dp of length of n where:\\n*n is total number of rooms (length of input array).*\\n*dp[i] = Number of days after which we reach room **i** for the first time.*\\nThus, to reach room *i-1*, we take dp[i-1] days.\\n**2. Add one day and move to *nextVisit[i-1]***\\nWhen we first visited *nextVisit[i-1]* it was on odd count, same as now, thus it can be considered as pseudo-first visit.\\n**3. Move from *nextVisit[i-1]*  to *i-1***\\nSince our visit to *nextVisit[i-1]* can be considered as pseudo-first visit, we can directly calculate the number of days it takes from *nextVisit[i-1]*  to *i-1* as *dp[i-1] - dp[nextVisit[i-1]]*.\\n**4. Add one day to go from [i-1] to i**\\n\\nThus we can say *dp[i] = dp[i-1] (Step 1) + 1 (Step 2) + dp[i-1] - dp[nextVisit[i-1]](Step 3) + 1(Step 4)*.\\nor ```dp[i] = dp[i-1] * 2 - dp[nextVisit[i-1]] + 2```\\n\\n*Note: dp[0] will always be 0 because we start from there.*\\n\\nSample Code (Java): \\n```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        long[] dp = new long[nextVisit.length];\\n        for(int i = 1; i < nextVisit.length; i++) \\n            dp[i] = (dp[i-1] * 2 - dp[nextVisit[i-1]] + 2 + mod) % mod;\\n        return (int)dp[dp.length - 1];\\n    }\\n}\\n```\\n\\nWhy do we add *mod*? Value goes out of Integer range making it reach the negative end on some testcases, we bring it back to range by adding mod and then we perform modulo operation to get our number of days.\\nBut why does it not affect the value, we\\'re adding *mod* right? It should change the actual value we get....right?\\nActually, no.\\nModulo operator has this property, (a+b) % c = ((a%c) + (b%c)) % c\\nthus (x + mod) % mod = (x%mod + mod%mod)%mod = x%mod as mod%mod = 0.\\n\\n",
                "solutionTags": [],
                "code": "```dp[i] = dp[i-1] * 2 - dp[nextVisit[i-1]] + 2```\n```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        long[] dp = new long[nextVisit.length];\\n        for(int i = 1; i < nextVisit.length; i++) \\n            dp[i] = (dp[i-1] * 2 - dp[nextVisit[i-1]] + 2 + mod) % mod;\\n        return (int)dp[dp.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445763,
                "title": "explanation-for-rookies-like-meself-1-line-dp-magic",
                "content": "* The problem has a strong DP pattern to it - The minimum days to reach Room i is completely dependent on smaller subproblems that have been solved before.\\n* The hard part is only to identify the recurrence relation.\\n* Once we define the DP table, it is easy to see that dp[0] will be 0;\\n* The most important observation is that you can only reach the room i via room i - 1 and hence we atleast need dp[i - 1] days to reach ith room and then some more.\\n* But we will also need (dp[i - 1] - dp[next[i - 1]]) days. Why?\\n* Well room i - 1 will send us back to room (next[i - 1]) because of the odd even rules and from there we will have to return to room i - 1 again. This will take us  (dp[i - 1] - dp[next[i - 1]]) days.\\n* So the total days will be  (dp[i - 1] + dp[i - 1] - dp[next[i - 1]]). +2 extra days to reach room i.\\n* Draw the dp table and try this to get the complete picture. A fully written explanation is not possible. Once you get a hang of the recurrence relation on paper, it will click.\\n* Overall a tough problem to crack in a contest or interview. Recursive solution is simple but cracking the dp idea for noobs like me is still pretty far away.\\n \\n---------------------------------------------\\n\\n\\n\\n\\n\\n\\n```\\n    int firstDayBeenInAllRooms(vector<int>& next) {\\n        \\n        int n = next.size(); int mod = pow(10, 9) + 7;\\n        vector<long> dp(n); dp[0] = 0;\\n        \\n        for(int i = 1 ; i < n ; i++) \\n            dp[i] = (dp[i - 1] + dp[i - 1] - dp[next[i - 1]] + 2 + mod) % mod;\\n        \\n        return dp.back();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int firstDayBeenInAllRooms(vector<int>& next) {\\n        \\n        int n = next.size(); int mod = pow(10, 9) + 7;\\n        vector<long> dp(n); dp[0] = 0;\\n        \\n        for(int i = 1 ; i < n ; i++) \\n            dp[i] = (dp[i - 1] + dp[i - 1] - dp[next[i - 1]] + 2 + mod) % mod;\\n        \\n        return dp.back();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445270,
                "title": "concise-c-with-explanation-dp-prefix-sum-o-n",
                "content": "**Note 1:** To the pass any index `i` the number of visits must become even \\nIf the number of visits are odd you will end up going a index `j = nextVisit[i]` with `0 <= j <= i` (Since `0 <= nextVisit[i] <= i`)\\n\\nAssume `days[i]` = number of days required to pass `i` if you visit index `i` for the fist time\\n\\n**Note 2** If you visited `i` for the first time, it would always be an odd visit, and you will have to go to `nextVisit[i]`.\\n\\nNow let `j = nextVisit[i]`\\n\\n**Case 1**\\nIf `j == i` then you will again reach `i` and number of visits will become even and you can move to `i+1`. Thus, `days[i] = 2`\\n\\n**Case 2**\\nIf `j < i`, then this visit to `j` will always be odd one (*Because you have already passed `j` earlier and thus number of visits must have become even*).\\nThus, to calculate `days[i]` = number of days required to pass `i`, you need to first pass `j`, then you will reach `j+1`, and now you have to pass `j+1`, then you reach `j+2` and so on. And then you will finally arrive at `i` and this time number of visits will be even and thus you can go to `i+1`.\\nThus = `days[i] = 2 + days[j] + days[j+1] + days[j+2] + ... + days[i-1]`\\n`2` becaue you also arrive at i 2 times.\\nBut note that doing this naively will cause TLE thus you can use prefix sum approach to optimize the solution.\\n\\n```\\nint mod = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        vector<int> days(n);\\n\\t\\t// days[i] = number of days required to pass i if you visit index i for the fist time\\n        vector<int> pre(n+1);\\n        pre[0] = 0;\\n        // pre[i] = days[0] + days[1] + ... + days[i-1]\\n        for (int i=0; i<n; i++) {\\n            int j = nextVisit[i];\\n            if (j == i) {\\n                days[i] = 2;\\n            } else {\\n                assert(j < i);\\n                // days[i] = 2 + (days[j] + days[j+1] + days[j+2] + ... + days[i-1]);\\n                days[i] = 2 + (pre[i] - pre[j]);\\n                days[i] = days[i] % mod;\\n                if (days[i] < 0) days[i] += mod;\\n            }\\n            pre[i+1] = (pre[i] + days[i]) % mod;\\n        }\\n        return (pre[n-1]) % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint mod = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        vector<int> days(n);\\n\\t\\t// days[i] = number of days required to pass i if you visit index i for the fist time\\n        vector<int> pre(n+1);\\n        pre[0] = 0;\\n        // pre[i] = days[0] + days[1] + ... + days[i-1]\\n        for (int i=0; i<n; i++) {\\n            int j = nextVisit[i];\\n            if (j == i) {\\n                days[i] = 2;\\n            } else {\\n                assert(j < i);\\n                // days[i] = 2 + (days[j] + days[j+1] + days[j+2] + ... + days[i-1]);\\n                days[i] = 2 + (pre[i] - pre[j]);\\n                days[i] = days[i] % mod;\\n                if (days[i] < 0) days[i] += mod;\\n            }\\n            pre[i+1] = (pre[i] + days[i]) % mod;\\n        }\\n        return (pre[n-1]) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445177,
                "title": "easy-dp-solution-o-n-with-explanation",
                "content": "If we observe then atleast two days  are needed to go from one room to next one when NextRoom[i]==i .\\nsecond thing is that we can observe that if NextRoom[i]=j  where j<i  , then the number of days needed to go from first visit to room  i to i+1 is  summation of  number of days needed to  go from   \\nj to (j+1)  + (j+1) to (j+2) .......  (i-1) to i  +2 . \\n\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nv) {\\n        long long mod=1000000007;\\n        long long n=nv.size();\\n \\n        vector<long long> days(n,0);\\n        days[0]=0;\\n        for(int i=0;i<n-1;i++){\\n            if(i==nv[i]){\\n                days[i+1]=(days[i]+2)%mod;\\n            }\\n            else {\\n                days[i+1]= ( 2*days[i]-days[nv[i]]+2)%mod;\\n                days[i+1]= ( days[i+1] +mod)%mod;\\n            }\\n        }\\n        return days[n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nv) {\\n        long long mod=1000000007;\\n        long long n=nv.size();\\n \\n        vector<long long> days(n,0);\\n        days[0]=0;\\n        for(int i=0;i<n-1;i++){\\n            if(i==nv[i]){\\n                days[i+1]=(days[i]+2)%mod;\\n            }\\n            else {\\n                days[i+1]= ( 2*days[i]-days[nv[i]]+2)%mod;\\n                days[i+1]= ( days[i+1] +mod)%mod;\\n            }\\n        }\\n        return days[n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447152,
                "title": "javascript-solution-with-explanation",
                "content": "This is split into 2 parts. First is a code that will work theoretically, but will fail the space allocation because `BigInt` takes up too much space. Then 2nd part is full solution that is accepted, but it has alot of extra code to deal with `BigInt`.\\n\\nThis code shows the algorithm (theoretical)\\n```javascript\\nconst firstDayBeenInAllRooms = function (arr) {\\n  let sum = 0n;\\n  const prefixes = new Array(arr.length);\\n\\n  let i = 0;\\n  let count = 0;\\n  while (i !== arr.length - 1) {\\n    const e = arr[i];\\n    if (e === i) {\\n      sum += 2n;\\n    } else {\\n      const days = sum - (prefixes[e - 1] || 0n);\\n      sum += days + 2n;\\n    }\\n    prefixes[i] = sum;\\n    i += 1;\\n  }\\n  return Number(sum % 1000000007n);\\n};\\n```\\n\\nNote, I use numbers like `0n`, `2n` etc. The `n` turns the number into a `BigInt`.\\n\\nThe above solution is essentially a prefix sum. In the `prefixes` array, each `prefixes[i]` contains the number of days to get to room `i`.\\n\\nExample: `[0,0,2,3,3,3,6,7]`\\n\\nPrefixes array will look like:\\n\\n```\\n[ 2, 6, 8, 10, 14, 22, 24, <empty>]\\n\\n/* Here\\'s how the prefixes are derived. Sum represents total number of days passed.\\n\\n* prefixes[0]: i is 0, and the value is 0. We are staying in same room, so its just 2. Sum is 2\\n* prefixes[1]: i is 1, and we stay in room 1, then stay in room 0 twice, then room 1 again (4). Sum is 6\\n* prefixes[2]: i is 2, and the value is 2. We are staying in same room, so its just 2. Sum is 8\\n* prefixes[3]: i is 3, and the value is 3. We are staying in same room, so its just 2. Sum is 10\\n* prefixes[4]: i is 4, and we stay in room 4, then start journey from room 3 again and then stay in room 4. Sum is 14\\n* prefixes[5]: i is 5, and we stay in room 5, then start journey from room 3 again and then stay in room 5. (14 - prefixes[3-1] + 2) gives us 8. Sum is 22\\n* prefixes[6]: i is 6, and the value is 6. We are staying in same room, so its just 2. Sum is 24 \\n* i is 7, we return the sum (24 days)\\n*/\\n```\\n\\n\\nThis code handles the mod operations to pass all test cases.\\n```javascript\\nconst firstDayBeenInAllRooms = function (arr) {\\n  let sum = 0;\\n\\n  let i = 0;\\n  let count = 0;\\n  while (i !== arr.length - 1) {\\n    const e = arr[i];\\n    if (e === i) {\\n      sum += 2;\\n    } else {\\n      const days = sum - (arr[e - 1] || 0);\\n      sum += days + 2;\\n    }\\n    arr[i] = sum % 1000000007;\\n    sum = sum % 1000000007;\\n    i += 1;\\n  }\\n  sum = sum % 1000000007;\\n  while (sum < 0) {\\n    sum += 1000000007;\\n  }\\n  return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst firstDayBeenInAllRooms = function (arr) {\\n  let sum = 0n;\\n  const prefixes = new Array(arr.length);\\n\\n  let i = 0;\\n  let count = 0;\\n  while (i !== arr.length - 1) {\\n    const e = arr[i];\\n    if (e === i) {\\n      sum += 2n;\\n    } else {\\n      const days = sum - (prefixes[e - 1] || 0n);\\n      sum += days + 2n;\\n    }\\n    prefixes[i] = sum;\\n    i += 1;\\n  }\\n  return Number(sum % 1000000007n);\\n};\\n```\n```\\n[ 2, 6, 8, 10, 14, 22, 24, <empty>]\\n\\n/* Here\\'s how the prefixes are derived. Sum represents total number of days passed.\\n\\n* prefixes[0]: i is 0, and the value is 0. We are staying in same room, so its just 2. Sum is 2\\n* prefixes[1]: i is 1, and we stay in room 1, then stay in room 0 twice, then room 1 again (4). Sum is 6\\n* prefixes[2]: i is 2, and the value is 2. We are staying in same room, so its just 2. Sum is 8\\n* prefixes[3]: i is 3, and the value is 3. We are staying in same room, so its just 2. Sum is 10\\n* prefixes[4]: i is 4, and we stay in room 4, then start journey from room 3 again and then stay in room 4. Sum is 14\\n* prefixes[5]: i is 5, and we stay in room 5, then start journey from room 3 again and then stay in room 5. (14 - prefixes[3-1] + 2) gives us 8. Sum is 22\\n* prefixes[6]: i is 6, and the value is 6. We are staying in same room, so its just 2. Sum is 24 \\n* i is 7, we return the sum (24 days)\\n*/\\n```\n```javascript\\nconst firstDayBeenInAllRooms = function (arr) {\\n  let sum = 0;\\n\\n  let i = 0;\\n  let count = 0;\\n  while (i !== arr.length - 1) {\\n    const e = arr[i];\\n    if (e === i) {\\n      sum += 2;\\n    } else {\\n      const days = sum - (arr[e - 1] || 0);\\n      sum += days + 2;\\n    }\\n    arr[i] = sum % 1000000007;\\n    sum = sum % 1000000007;\\n    i += 1;\\n  }\\n  sum = sum % 1000000007;\\n  while (sum < 0) {\\n    sum += 1000000007;\\n  }\\n  return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445252,
                "title": "java-dp",
                "content": "step one : we reach  i-1  with dp[i-1] steps;\\nstep two:  we rereach  i-1 with dp[i-1] - dp[nv[i-1]]+1   steps , since dp[i-1] may be less than dp[nv[i-1]],  so add a mod\\nstep three: we jump from i-1 to i with  1 step;\\n\\n\\nwe can see that when we reach a new idx , the count before idx is always even, means that we restart at nv[idx] with odd ; so if we want to rereach this idx , we must use dp[i-1] - dp[nv[i-1]] + 1 steps;\\n\\n```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] nv) {\\n        int len = nv.length;\\n        long[] dp = new long[len];\\n        dp[1] = 2;\\n        int mod = 1000000007;\\n        for(int i = 2 ; i < len ; i++){\\n            dp[i] = dp[i-1] + dp[i-1] + mod - dp[nv[i-1]] + 2;\\n            dp[i] %= mod;\\n        }\\n        return (int)dp[len-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] nv) {\\n        int len = nv.length;\\n        long[] dp = new long[len];\\n        dp[1] = 2;\\n        int mod = 1000000007;\\n        for(int i = 2 ; i < len ; i++){\\n            dp[i] = dp[i-1] + dp[i-1] + mod - dp[nv[i-1]] + 2;\\n            dp[i] %= mod;\\n        }\\n        return (int)dp[len-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279250,
                "title": "python-prefix-sum-dp-solution-with-explanation",
                "content": "There are two keypoints to approach this problem:\\n* When first visiting the room i+1, the room i is visited twice. One visit comes from \"the first visit to room i\", the second visit comes from \"additional steps to visit room i again\".\\n* The next day after we first visit room i, we will visit room (nextVisit[i]). The problem turns into \"how to go from room (nextVisit[i]) to room i\".  \\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n\\t        n:int = len(nextVisit)\\n        days:List[int] = n*[0] # days[i] is the number of days it takes to first reach room i\\n        MOD = pow(10, 9) + 7\\n        for i in range(0,n-1):\\n            # First we are already at room i. days[i] days has passed\\n            days[i+1] = days[i]\\n            # lets go from room i to room i+1. \\n            # When we first visit room i, we need to visit room i again (so room i is visited twice, which is an even number), then we can visit room i+1\\n            # after we fist visit room i, the next day we will visit room (nextVisit[i]). \\n            days[i+1] = (days[i+1] + 1) % MOD\\n            # Then the problem becomes \"how to go from room (nextVisit[i]) back to room i\". The step is (days[i] - days[nextVisit[i]])\\n            days[i+1] = (days[i+1] + days[i] - days[nextVisit[i]]) % MOD\\n            # Then, in the next day we go from room i to i+1\\n            days[i+1] = (days[i+1] + 1) % MOD\\n        \\n        return days[n-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n\\t        n:int = len(nextVisit)\\n        days:List[int] = n*[0] # days[i] is the number of days it takes to first reach room i\\n        MOD = pow(10, 9) + 7\\n        for i in range(0,n-1):\\n            # First we are already at room i. days[i] days has passed\\n            days[i+1] = days[i]\\n            # lets go from room i to room i+1. \\n            # When we first visit room i, we need to visit room i again (so room i is visited twice, which is an even number), then we can visit room i+1\\n            # after we fist visit room i, the next day we will visit room (nextVisit[i]). \\n            days[i+1] = (days[i+1] + 1) % MOD\\n            # Then the problem becomes \"how to go from room (nextVisit[i]) back to room i\". The step is (days[i] - days[nextVisit[i]])\\n            days[i+1] = (days[i+1] + days[i] - days[nextVisit[i]]) % MOD\\n            # Then, in the next day we go from room i to i+1\\n            days[i+1] = (days[i+1] + 1) % MOD\\n        \\n        return days[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330609,
                "title": "derivation-of-dp-solution",
                "content": "An important observation is that when we are at index `i`, all `j < i` must have been visited an even number of times, that is, all positions to the left look as if they have never been visited, this hints at the recursive nature of the problem. Let\\'s define `f(i)` to be the number of steps it takes to reach `i+1` from `i`, we have  \\n```0\\nf(i) == SUM[f(j), j in [next[i], i)] + 2\\n```\\nTo illustrate this relation, let\\'s suppose  `next[5] == 2`, observe how `f(5) == f(2) + f(3) + f(4) + 2`:\\n```\\nEEEEEOE  \\n     ^\\nEEOEEOE  1 step\\n  ^\\nEEEOEOE  f(2) steps\\n   ^\\nEEEEOOE  f(3) steps\\n    ^\\nEEEEEEE  f(4) steps\\n     ^\\nEEEEEEO  1 step\\n      ^\\n```\\n\\nWe can rewrite the recurrence in terms of the prefix sum `F(i) := SUM[f(j), j in [1,i)]`, the minimum number of steps to reach index `i`:\\n```0\\nF(i) == SUM[f(j), j in [1,i)]\\n     == SUM[f(j), j in [1, i-1)] + f(i-1)\\n\\t == F(i-1) + SUM[f(j), j in [next[i-1], i-1)] + 2\\n\\t == F(i-1) + (SUM[f(j), j in [1, i-1)] - SUM[f(j), j in [1, next[i-1])]) + 2\\n\\t == F(i-1) + (F(i-1) - F(next[i-1])) + 2\\n```\\nWriten as code:\\n```\\nint m = 1000000007;\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& next) {\\n        vector<long> dp (next.size());\\n        for (int i = 1; i < next.size(); ++i)\\n            dp[i] = (2 * dp[i-1] - dp[next[i-1]] + 2 + m) % m;\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```0\\nf(i) == SUM[f(j), j in [next[i], i)] + 2\\n```\n```\\nEEEEEOE  \\n     ^\\nEEOEEOE  1 step\\n  ^\\nEEEOEOE  f(2) steps\\n   ^\\nEEEEOOE  f(3) steps\\n    ^\\nEEEEEEE  f(4) steps\\n     ^\\nEEEEEEO  1 step\\n      ^\\n```\n```0\\nF(i) == SUM[f(j), j in [1,i)]\\n     == SUM[f(j), j in [1, i-1)] + f(i-1)\\n\\t == F(i-1) + SUM[f(j), j in [next[i-1], i-1)] + 2\\n\\t == F(i-1) + (SUM[f(j), j in [1, i-1)] - SUM[f(j), j in [1, next[i-1])]) + 2\\n\\t == F(i-1) + (F(i-1) - F(next[i-1])) + 2\\n```\n```\\nint m = 1000000007;\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& next) {\\n        vector<long> dp (next.size());\\n        for (int i = 1; i < next.size(); ++i)\\n            dp[i] = (2 * dp[i-1] - dp[next[i-1]] + 2 + m) % m;\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451051,
                "title": "c-dp-with-explanation",
                "content": "1. the relationship between dp[i] and dp[i-1]\\ndp[i] denotes the first day that I arrive at i, which means i-1 position has been visited twice, once from the beginning 0, and once from the position nextVisit[i - 1].\\nSo dp[i] is composed of three parts:\\n* dp[i - 1]: the days from 0 to i-1\\n* dp[i - 1] - dp[nextVisits[i-1]] + 1: the days from position nextVisit[i-1] to position i-1\\n* 1: from i - 1 to i\\nAs a result, dp[i] = dp[i-1] + dp[i-1] - dp[nextVisits[i - 1]] + 1 + 1\\n\\n2. avoid int overflow\\n2 * (1e10 + 7) is nearly INT_MAX, avoid overflow and negative results when calculating dp[i]\\n\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>&o nextVisit) {\\n        int n = nextVisit.size();\\n        int dp[n]; // initialization is not needed\\n        dp[0] = 0; // first day \\n        for(int i = 1; i < n; ++i){\\n            dp[i] = 2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2;\\n            if(dp[i] < 0)\\n                dp[i] += 1000000007;\\n            else dp[i] %= 1000000007;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>&o nextVisit) {\\n        int n = nextVisit.size();\\n        int dp[n]; // initialization is not needed\\n        dp[0] = 0; // first day \\n        for(int i = 1; i < n; ++i){\\n            dp[i] = 2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2;\\n            if(dp[i] < 0)\\n                dp[i] += 1000000007;\\n            else dp[i] %= 1000000007;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446959,
                "title": "java-code-with-explanation",
                "content": "For each room we keep track of count of days to reach it.\\n\\nObservation 1 : when we move from i to (i+1)th room there are even number of visits for all rooms from [0, i] inclusive.\\n\\nObservation 2: \\n```\\nif nextVisit[i-1] == i-1\\n```\\ntwo more days are needed to move to next room\\n\\nOtherwise if nextVisit[i-1] != i-1 then,\\n```\\n dp[i] = (dp[i-1] + dp[i-1] - dp[nextVisit[i-1]] + 2 + mod)%mod;\\n```\\n\\n\\n```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        int rooms = nextVisit.length;\\n        long dp[] = new long[rooms];\\n        int mod = (int)(1e9)+7;\\n        for (int i=1 ; i<rooms ; i++) {\\n            if (nextVisit[i-1] == i-1)\\n                dp[i] = dp[i-1]+2;\\n            else\\n                dp[i] = (dp[i-1] + dp[i-1] - dp[nextVisit[i-1]] + 2 + mod)%mod;\\n        }\\n        return (int)dp[rooms-1];\\n    }\\n}\\n```\\n\\nUpvote if you understood.\\nIf you have doubts i have prepared a video explaining the same on youtube. Hope you like it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nif nextVisit[i-1] == i-1\\n```\n```\\n dp[i] = (dp[i-1] + dp[i-1] - dp[nextVisit[i-1]] + 2 + mod)%mod;\\n```\n```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        int rooms = nextVisit.length;\\n        long dp[] = new long[rooms];\\n        int mod = (int)(1e9)+7;\\n        for (int i=1 ; i<rooms ; i++) {\\n            if (nextVisit[i-1] == i-1)\\n                dp[i] = dp[i-1]+2;\\n            else\\n                dp[i] = (dp[i-1] + dp[i-1] - dp[nextVisit[i-1]] + 2 + mod)%mod;\\n        }\\n        return (int)dp[rooms-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446619,
                "title": "python3-dp",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/84115397f703f3005c3ae0d5d759f4ac64f65de4) for solutions of weekly 257.\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        odd = [0]\\n        even = [1]\\n        for i in range(1, len(nextVisit)): \\n            odd.append((even[-1] + 1) % 1_000_000_007)\\n            even.append((2*odd[-1] - odd[nextVisit[i]] + 1) % 1_000_000_007)\\n        return odd[-1] \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        odd = [0]\\n        even = [1]\\n        for i in range(1, len(nextVisit)): \\n            odd.append((even[-1] + 1) % 1_000_000_007)\\n            even.append((2*odd[-1] - odd[nextVisit[i]] + 1) % 1_000_000_007)\\n        return odd[-1] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445212,
                "title": "python3-dp-o-n",
                "content": "**Explanation**\\nLet\\'s consider dp[i] to be the day on which we reach day i. It depends on when the i-1 will occur again so that we enter i-1th room even times and come to the ith room. To find when the i-1 will occur again we will have to see how many days it took to come from nex[i-1] to i-1 which is dp[i-1]-dp[nex[i-1]]+1. Hence, the day we reach ith room is dp[i-1]+(dp[i-1]-dp[nex[i-1]]+1)+1. \\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nex: List[int]) -> int:\\n        n = len(nex)\\n        dp = [0]*n\\n        mod  = 10**9+7\\n        for i in range(1,n):\\n            dp[i] = (dp[i-1]+(dp[i-1]-dp[nex[i-1]]+1)+1)%mod\\n        return dp[-1]\\n```\\n\\nIf you like the solution, please consider upvoting.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nex: List[int]) -> int:\\n        n = len(nex)\\n        dp = [0]*n\\n        mod  = 10**9+7\\n        for i in range(1,n):\\n            dp[i] = (dp[i-1]+(dp[i-1]-dp[nex[i-1]]+1)+1)%mod\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681979,
                "title": "java-solution-with-dp",
                "content": "1.dp[i]  means the number of days that you need to first get into the ith room.\\n2.First, you spend dp[i-1] day to get into i-1 room. Next you will be in nextVisit[i-1] room. The only way to get to ith room is to be in i-1 room again so you will visit i-1 room twice. Then you can go to ith room. \\n3.The days that we need to get to i-1 room again is dp[i-1] - dp[nextVisit[i-1]]. \\n4.If you visit a room for an odd times, you will go to a room with lower number next. If you go to a room with a higher number. That means, all the rooms with lower numbers you have already visited for even times.\\n```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        int[] dp = new int[nextVisit.length];\\n        int M = 1000000007;\\n        for (int i = 1; i < dp.length; i++) {\\n            int steps = 2 * dp[i-1] - dp[nextVisit[i-1]] + 2;\\n            dp[i] = steps < 0 ? (steps + M) % M : steps % M;\\n\\n        }\\n        return dp[dp.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        int[] dp = new int[nextVisit.length];\\n        int M = 1000000007;\\n        for (int i = 1; i < dp.length; i++) {\\n            int steps = 2 * dp[i-1] - dp[nextVisit[i-1]] + 2;\\n            dp[i] = steps < 0 ? (steps + M) % M : steps % M;\\n\\n        }\\n        return dp[dp.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445700,
                "title": "c-start-and-end-times",
                "content": "**Start time**: *Day when we visit node i for the first time*\\n**End time**: *Day when we visit node i for the first time after Start time*\\n\\nWe will calculate Start and End times for all nodes from 0 to n-1 in the following way - \\n\\n**Start time:**\\nstart[i] = end[i-1] + 1 for i>0 (this is true because we can only visit node i when we have visited the previous node (i-1) two times) \\nand start[0] = 0\\n\\n**End time:**\\nend[i] = start[i] + (start[i] - start[nums[i]] +1) \\nThis is because we want to know after how much time we will we able to revisit the node i once we start from node nums[i],  (start[i] - start[nums[i]] +1) is the number of days to revisit node i, if we start from node nums[i].\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n\\t// kulyash\\'s code\\n    int firstDayBeenInAllRooms(vector<int>& nums) {\\n        int n=nums.size();\\n        long long M=1000000007;\\n        vector<int>end(n,0),start(n,0);\\n        for(int i=0;i<n-1;i++){\\n            if(i!=0)start[i]=end[i-1]+1;\\n            end[i]=2*start[i]-start[nums[i]]+1;\\n            end[i]=(end[i]+M)%M;\\n        }\\n        return (end[n-2]+1)%M;\\n    }\\n};\\n```\\n\\nThe final output is end[n-2] + 1 which is same as start[n-1]!\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// kulyash\\'s code\\n    int firstDayBeenInAllRooms(vector<int>& nums) {\\n        int n=nums.size();\\n        long long M=1000000007;\\n        vector<int>end(n,0),start(n,0);\\n        for(int i=0;i<n-1;i++){\\n            if(i!=0)start[i]=end[i-1]+1;\\n            end[i]=2*start[i]-start[nums[i]]+1;\\n            end[i]=(end[i]+M)%M;\\n        }\\n        return (end[n-2]+1)%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445287,
                "title": "python-4-lines-solution-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/2e750513-c5bb-434a-809c-8aea090e01e6_1630815924.9723213.png)\\n\\nLet `dist[i]` be the minimum steps you need to visit `i`; `dist[0]=0`. To reach `i`, you need first  reach `i-1`, take 1 day back to `nextVisit[i-1]`, get from `nextVisit[i-1]` to `i-1`, and finally use 1 day to reach `i`. Meanwhile, the days needed from `nextVisit[i-1]` to `i-1` is `dist[i-1]-dist[nextVist[i-1]]`. So\\n```\\ndist[i]=dist[i-1]+1+dist[i-1]-dist[nextVist[i-1]]+1\\n```\\nFinally the code is\\n```\\ndef firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n    dist=[0]*len(nextVisit)\\n    for i in range(1,len(nextVisit)):\\n        dist[i]=(2*dist[i-1]-dist[nextVisit[i-1]]+2)%1000000007\\n    return dist[-1]\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndist[i]=dist[i-1]+1+dist[i-1]-dist[nextVist[i-1]]+1\\n```\n```\\ndef firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n    dist=[0]*len(nextVisit)\\n    for i in range(1,len(nextVisit)):\\n        dist[i]=(2*dist[i-1]-dist[nextVisit[i-1]]+2)%1000000007\\n    return dist[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1445208,
                "title": "kotlin-clean-and-short-o-n-solution",
                "content": "```\\nclass Solution {\\n    fun firstDayBeenInAllRooms(nextVisit: IntArray): Int {\\n        val mod = 1000000007\\n        val days = LongArray(nextVisit.size).apply { set(0, 1L) }\\n\\n        for (i in 1..days.lastIndex) {\\n            days[i] = (days[i - 1] + days[i - 1] - days[nextVisit[i - 1]] + 1 + 1) % mod\\n        }\\n\\n        return ((days.last() + mod - 1) % mod).toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun firstDayBeenInAllRooms(nextVisit: IntArray): Int {\\n        val mod = 1000000007\\n        val days = LongArray(nextVisit.size).apply { set(0, 1L) }\\n\\n        for (i in 1..days.lastIndex) {\\n            days[i] = (days[i - 1] + days[i - 1] - days[nextVisit[i - 1]] + 1 + 1) % mod\\n        }\\n\\n        return ((days.last() + mod - 1) % mod).toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114952,
                "title": "python3-solution-dp",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, A):\\n        n = len(A)\\n        mod = 10 ** 9 + 7\\n        dp = [0] * (n)\\n        for e, i in enumerate(A[:-1], 1):\\n            dp[e] = dp[e - 1] + 1\\n            dp[e] = (2 * dp[e] - dp[i]) % mod\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, A):\\n        n = len(A)\\n        mod = 10 ** 9 + 7\\n        dp = [0] * (n)\\n        for e, i in enumerate(A[:-1], 1):\\n            dp[e] = dp[e - 1] + 1\\n            dp[e] = (2 * dp[e] - dp[i]) % mod\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125397,
                "title": "detailed-explaination-prefix-sum-dp-c",
                "content": "\\n**The only way to get to room i+1 is when you are visiting room i and room i has been visited an even number of times.**\\nLet understand with example \\xA0\\n```\\n      room number  ->  0 1 2 3 4 5\\nlets take  nextVisit[]=[0,0,0,1,4,5] \\n```\\n```\\n\\u2705to go 1th room from 0th->0(odd),0(even)   //2 days\\n\\u2705to go 2th room from 1th->1(odd),0(odd),0(even),1(odd) why 0th visit is odd because there is no way \\u2705to  go i+1 without visiting twice   //4 days\\n\\u2705to go 3rd room from 2->2,0,0,1,0,0,1,2    //8 days\\n\\u2705to go 4 from 3  -> 3,1,0,0,1,2,0,0,1,0,0,1,2,3 //14 days\\n\\u2705to go 5th from 4th->4,4 // 2days\\nfinish\\n``` \\nCan You decode the pattern \\n```\\nfrom i to i+1-> i,ans of nextVisit[i] to i-1,i **\\nin mathmatical term to go i+1th room day_taken=sum(day taken from nextVisit[i] to i -1)+2 (first + second visit at i)\\ntake room 3 from above example \\ndays_taken_to_reach_room4_starting from 3\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 =sumof(nextvisit[3] to i-1)+2\\nans[3]=ans[1]+ans[2}+2\\n         =4+8+2=14\\n```\\n```\\nclass Solution {\\npublic:\\n    int m=1e9+7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n=nextVisit.size();\\n        vector<long long> dp(n);\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            long long day_taken_to_return_at_i=0;\\n            for(int j=nextVisit[i];j<i;j++)\\n                day_taken_to_return_at_i=(day_taken_to_return_at_i+dp[j])%m;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0dp[i]=(day_taken_to_return_at_i+2)%m;\\n            ans=(ans+dp[i])%m;\\n        }\\n        return ans;\\n    }\\n};\\n```  \\n`Time-O(n*n)`\\nThis solution will give us TLE \\nCan we optimise this further ?\\nAs we are calculating sum  \\nfor(int j=nextVisit[i];j<i;j++) Obvious answer will be using Prefix sum\\n```\\nclass Solution {\\npublic:\\n    int m=1e9+7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n=nextVisit.size();\\n        vector<long long> dp(n);\\n        long long ans=2; \\n        dp[0]=2;\\n        for(int i=1;i<n-1;i++){\\n            long long day_taken_to_return_at_i;\\n            int start=nextVisit[i]; //our starting position \\n            day_taken_to_return_at_i=dp[i-1]-(start>0?dp[start-1]:0);\\n            dp[i]=(day_taken_to_return_at_i+2)%m; //current ans\\n            ans=(ans+dp[i])%m; \\n            dp[i]+=dp[i-1]; //prefix sum of days to visit 0->i\\n        }\\n        return ans;\\n    }\\n};\\n``` \\n`Time-O(n)`",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n      room number  ->  0 1 2 3 4 5\\nlets take  nextVisit[]=[0,0,0,1,4,5] \\n```\n```\\n\\u2705to go 1th room from 0th->0(odd),0(even)   //2 days\\n\\u2705to go 2th room from 1th->1(odd),0(odd),0(even),1(odd) why 0th visit is odd because there is no way \\u2705to  go i+1 without visiting twice   //4 days\\n\\u2705to go 3rd room from 2->2,0,0,1,0,0,1,2    //8 days\\n\\u2705to go 4 from 3  -> 3,1,0,0,1,2,0,0,1,0,0,1,2,3 //14 days\\n\\u2705to go 5th from 4th->4,4 // 2days\\nfinish\\n```\n```\\nfrom i to i+1-> i,ans of nextVisit[i] to i-1,i **\\nin mathmatical term to go i+1th room day_taken=sum(day taken from nextVisit[i] to i -1)+2 (first + second visit at i)\\ntake room 3 from above example \\ndays_taken_to_reach_room4_starting from 3\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 =sumof(nextvisit[3] to i-1)+2\\nans[3]=ans[1]+ans[2}+2\\n         =4+8+2=14\\n```\n```\\nclass Solution {\\npublic:\\n    int m=1e9+7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n=nextVisit.size();\\n        vector<long long> dp(n);\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            long long day_taken_to_return_at_i=0;\\n            for(int j=nextVisit[i];j<i;j++)\\n                day_taken_to_return_at_i=(day_taken_to_return_at_i+dp[j])%m;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0dp[i]=(day_taken_to_return_at_i+2)%m;\\n            ans=(ans+dp[i])%m;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m=1e9+7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n=nextVisit.size();\\n        vector<long long> dp(n);\\n        long long ans=2; \\n        dp[0]=2;\\n        for(int i=1;i<n-1;i++){\\n            long long day_taken_to_return_at_i;\\n            int start=nextVisit[i]; //our starting position \\n            day_taken_to_return_at_i=dp[i-1]-(start>0?dp[start-1]:0);\\n            dp[i]=(day_taken_to_return_at_i+2)%m; //current ans\\n            ans=(ans+dp[i])%m; \\n            dp[i]+=dp[i-1]; //prefix sum of days to visit 0->i\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923290,
                "title": "easy-to-understand-python-dp-solution-explained",
                "content": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        N = len(nextVisit)\\n        res = [0 for i in range(N)]\\n        \\n        MOD = (10 ** 9 + 7)\\n        for i in range(0, N-1):\\n            # To reach next node\\n            # I am need to reach the current node twice\\n            if nextVisit[i] == i:\\n                # I can hang around at this node\\n                # So to reach next node, I just need to come from 0 to here (res[i] steps), go to here from here (1 step), and go directly to the next node (1 step)\\n                res[i+1] = (res[i] + 1 + 1) % MOD\\n            else:\\n                # I am not allowed to stay at this node\\n                # So to reach next node, I need to come from 0 to here (res[i] steps),\\n                # then I will get teleported to nextVisit[i] (1 step)\\n                # and I will need to come back here from nextVisit[i] (res[i] - res[nextVisit[i]] steps)\\n                # Now I would have come to this node twice already, so just need to take 1 more step to the next node\\n                res[i+1] = (res[i] + (res[i] - res[nextVisit[i]]) + 2) % MOD\\n        \\n        return res[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        N = len(nextVisit)\\n        res = [0 for i in range(N)]\\n        \\n        MOD = (10 ** 9 + 7)\\n        for i in range(0, N-1):\\n            # To reach next node\\n            # I am need to reach the current node twice\\n            if nextVisit[i] == i:\\n                # I can hang around at this node\\n                # So to reach next node, I just need to come from 0 to here (res[i] steps), go to here from here (1 step), and go directly to the next node (1 step)\\n                res[i+1] = (res[i] + 1 + 1) % MOD\\n            else:\\n                # I am not allowed to stay at this node\\n                # So to reach next node, I need to come from 0 to here (res[i] steps),\\n                # then I will get teleported to nextVisit[i] (1 step)\\n                # and I will need to come back here from nextVisit[i] (res[i] - res[nextVisit[i]] steps)\\n                # Now I would have come to this node twice already, so just need to take 1 more step to the next node\\n                res[i+1] = (res[i] + (res[i] - res[nextVisit[i]]) + 2) % MOD\\n        \\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551877,
                "title": "python-arrival-time-of-each-element",
                "content": "Initital Thought:\\n1. You will go right only when visited count for the element is Even... will that mean whenever we go right to any element their visited count is multiple of 2 or 0(if we take %2) so you can think like we come to that element first time. Will I need to solve something, or can store this in some array?\\n2. What will I store it? We need to return the arrival time when code reach to last element so we can just arrival time of each element.\\n\\nWill that help? YES, below is my code for reference:\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        time_taken = 0\\n        n = len(nextVisit)\\n        arrival_time = [0]*n\\n        MOD = 10**9 + 7\\n        \\n        for i, next_room in enumerate(nextVisit):\\n            if i != 0:\\n                arrival_time[i] = 1 + arrival_time[i-1] + time_taken\\n            time_taken = (arrival_time[i] - arrival_time[next_room])+1\\n        \\n        return (arrival_time[-1])%MOD\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        time_taken = 0\\n        n = len(nextVisit)\\n        arrival_time = [0]*n\\n        MOD = 10**9 + 7\\n        \\n        for i, next_room in enumerate(nextVisit):\\n            if i != 0:\\n                arrival_time[i] = 1 + arrival_time[i-1] + time_taken\\n            time_taken = (arrival_time[i] - arrival_time[next_room])+1\\n        \\n        return (arrival_time[-1])%MOD\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531892,
                "title": "java-dp-prefix-sum",
                "content": "The dp recurrence can be further shortened - but it is not a code golf competition.\\nSplitting the logic into - 1. calculating the number of days to move to next room and 2. the prefix sum calculation - made the most sense to me.\\nYou can use +/- MOD rather than % for extra performance. \\n```\\nstatic int MOD= 1_000_000_007;\\npublic int firstDayBeenInAllRooms(int[] nextVisit) {\\n\\tint n= nextVisit.length, ps[]= new int[n];\\n\\tps[0]= 2;\\n\\tfor(int i=1; i<n-1; i++){\\n\\t\\tint j= nextVisit[i];\\n\\t\\t// if I arrive to room i with an odd number of visits, how many days will it take me to move to i+1\\n\\t\\tint days= 2 + (ps[i-1]-(j==0 ? 0 : ps[j-1]));\\n\\t\\tif(days<0) days+= MOD;\\n\\t\\tif(days>=MOD) days-= MOD;\\n\\t\\tps[i]= ps[i-1] + days;\\n\\t\\tif(ps[i]>=MOD) ps[i]-= MOD;\\n\\t}\\n\\treturn ps[n-2];\\n}",
                "solutionTags": [],
                "code": "The dp recurrence can be further shortened - but it is not a code golf competition.\\nSplitting the logic into - 1. calculating the number of days to move to next room and 2. the prefix sum calculation - made the most sense to me.\\nYou can use +/- MOD rather than % for extra performance. \\n```\\nstatic int MOD= 1_000_000_007;\\npublic int firstDayBeenInAllRooms(int[] nextVisit) {\\n\\tint n= nextVisit.length, ps[]= new int[n];\\n\\tps[0]= 2;\\n\\tfor(int i=1; i<n-1; i++){\\n\\t\\tint j= nextVisit[i];\\n\\t\\t// if I arrive to room i with an odd number of visits, how many days will it take me to move to i+1\\n\\t\\tint days= 2 + (ps[i-1]-(j==0 ? 0 : ps[j-1]));\\n\\t\\tif(days<0) days+= MOD;\\n\\t\\tif(days>=MOD) days-= MOD;\\n\\t\\tps[i]= ps[i-1] + days;\\n\\t\\tif(ps[i]>=MOD) ps[i]-= MOD;\\n\\t}\\n\\treturn ps[n-2];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1498361,
                "title": "python-3-dp-explanation",
                "content": "### Explanation\\n- Fact, when you visit `i`, then other index less than `i` have already been visited even number of times. This is due to \\n\\t- > if you have been in room i an odd number of times (including the current visit), on the next day you will visit a room with a lower or equal room number specified by `nextVisit[i]` where `0 <= nextVisit[i] <= i`;\\n- To reach `i+1`, you need visited `i` for an odd time, then even time + 1; say `dp[i]`: moves need to visited `i`\\n\\t- odd visit to `i`: `dp[i]`\\n\\t- back to `nextVisit[i]`: `+1`\\n\\t- from `nextVisit[i]` to `i`: `dp[i] - dp[nextVisit[i]]`\\n\\t- odd visit to `i+1`: `+1`\\n- Now you have the transition function, see more explanation in below code comments\\n### Implementation\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n = len(nextVisit)\\n        dp = [0] * n\\n        mod = int(1e9+7)\\n        for i in range(n-1):\\n            # dp[i]: moves need to visited `i`\\n            # dp[i] - dp[nextVisit[i]] + 1: odd visit at i, then back to nextVisited[i] (+1), then move back to i (dp[i] - dp[nextVisit[i]]) for even visit\\n            # dp[i] + 1: even visit at i, then from i to i+1\\n            dp[i+1] = (dp[i] - dp[nextVisit[i]] + 1 + dp[i] + 1) % mod\\n        return dp[n-1] \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n = len(nextVisit)\\n        dp = [0] * n\\n        mod = int(1e9+7)\\n        for i in range(n-1):\\n            # dp[i]: moves need to visited `i`\\n            # dp[i] - dp[nextVisit[i]] + 1: odd visit at i, then back to nextVisited[i] (+1), then move back to i (dp[i] - dp[nextVisit[i]]) for even visit\\n            # dp[i] + 1: even visit at i, then from i to i+1\\n            dp[i+1] = (dp[i] - dp[nextVisit[i]] + 1 + dp[i] + 1) % mod\\n        return dp[n-1] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473957,
                "title": "python-dp-explanation-o-n",
                "content": "This is a O(n) DP solution. Main idea here is: for each room, the first visit to **i** leads to nextVisit[i] on the next day, and the second visit to **i** leads to **i+1** on the next day. All odd visits can be treated as first visit and all even visits can be treated as second visit. Here\\'s an example.\\nAssume nextVisit = [0, 0, 0, 0], n = 4. On day 14, all rooms are visited. The visiting log is as the below:\\n![image](https://assets.leetcode.com/users/images/7a621866-a768-4113-b3a5-03710657383f_1632103415.5733008.png)\\nWe can create 2 DP lists - **firstVisits** and **secondVisits** which stores the day when room **i** is visited first time and second time. The previous example has the following DP values:\\n![image](https://assets.leetcode.com/users/images/b20ff8b8-2f89-4e09-9865-378503525497_1632103447.6000285.png)\\nNotice:\\n* firstVisits[i] = secondVisits[i - 1] + 1\\n* secondVisits[i] = firstVisits[i] + 1 when nextVisit[i] == i\\n* More generic, secondVisits[i] = secondVisits[i - 1] - firstVisits[nextVisit[i]] + firstVisits[i] + 2, for all possible nextVisit[i]. In the previous example, secondVisits[2] = secondVisits[1] - firstVisits[0] + firstVisits[2] + 2 = 13\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        modFactor = 10**9 + 7\\n        firstVisits = [0]\\n        secondVisits = [1]\\n        N = len(nextVisit)\\n        for i in range(1, N - 1):\\n            firstVisits.append((secondVisits[i - 1] + 1) % modFactor)\\n            secondVisits.append(\\n                (secondVisits[i - 1] - firstVisits[nextVisit[i]] + firstVisits[i] + 2)\\n                % modFactor)\\n        return (secondVisits[N - 2] + 1) % modFactor\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        modFactor = 10**9 + 7\\n        firstVisits = [0]\\n        secondVisits = [1]\\n        N = len(nextVisit)\\n        for i in range(1, N - 1):\\n            firstVisits.append((secondVisits[i - 1] + 1) % modFactor)\\n            secondVisits.append(\\n                (secondVisits[i - 1] - firstVisits[nextVisit[i]] + firstVisits[i] + 2)\\n                % modFactor)\\n        return (secondVisits[N - 2] + 1) % modFactor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447258,
                "title": "look-at-hypothesis-to-get-it-nextvisit-i-i",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit){\\n       long long int mod = 1000000007;\\n       long long int dp[100001];\\n       long long int count = 0;\\n       int n = nextVisit.size();\\n       for(int i = 0;i < nextVisit.size();i++)\\n       {\\n           dp[i] = count;\\n           count = (count%mod+count%mod)%mod;\\n           count = (count+2)%mod;\\n           count = (count%mod-dp[nextVisit[i]]%mod+mod)%mod;\\n       }\\n       return dp[n-1]%mod;\\n    }\\n    \\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit){\\n       long long int mod = 1000000007;\\n       long long int dp[100001];\\n       long long int count = 0;\\n       int n = nextVisit.size();\\n       for(int i = 0;i < nextVisit.size();i++)\\n       {\\n           dp[i] = count;\\n           count = (count%mod+count%mod)%mod;\\n           count = (count+2)%mod;\\n           count = (count%mod-dp[nextVisit[i]]%mod+mod)%mod;\\n       }\\n       return dp[n-1]%mod;\\n    }\\n    \\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445559,
                "title": "greedy-4-lines-weill-explained-93-faster",
                "content": "## IDEA :\\nImagine this problem as a graph where we have two edges from each node, one for when the room is visited even number of time and one for when it is visited odd number of times. \\nThe important things to note are:\\n\\n*  *We want the visits for a particular node to become even in order to go to the next node.*\\n*  *The other thing we notice is that all the nodes before that have even number of visits as they have allowed to visit their next node.*\\n\\nNow, when we first visit a node it obviously has odd number of visits so we need to first visit the node nextVisit[i] and come back to the same node to get even number of visits. To prevent recomputing this we define dp[i] as the number of days it took to reach node i starting from node 0 giving use the relation **dp[i+1] = dp[i] + 1(for going to nextVisit[i]) + (dp[i] - dp[nextVisit[i]])(for coming back to same node) + 1(for going to next node)** the final relation is dp[i+1] = (2 * dp[i] + 2 - dp[nextVisit[i]]) % mod.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        MOD = 10**9+7\\n        n =len(nextVisit)\\n        dp=[0]*n\\n        for i in range(n-1):\\n            dp[i+1] += (2*dp[i] - dp[nextVisit[i]] + 2)%MOD\\n        \\n        return dp[-1]\\n\\t\\t\\n##### feel free to ask if you have any doubt!!\\n##### Thanks and **upvote** if it helps \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "## IDEA :\\nImagine this problem as a graph where we have two edges from each node, one for when the room is visited even number of time and one for when it is visited odd number of times. \\nThe important things to note are:\\n\\n*  *We want the visits for a particular node to become even in order to go to the next node.*\\n*  *The other thing we notice is that all the nodes before that have even number of visits as they have allowed to visit their next node.*\\n\\nNow, when we first visit a node it obviously has odd number of visits so we need to first visit the node nextVisit[i] and come back to the same node to get even number of visits. To prevent recomputing this we define dp[i] as the number of days it took to reach node i starting from node 0 giving use the relation **dp[i+1] = dp[i] + 1(for going to nextVisit[i]) + (dp[i] - dp[nextVisit[i]])(for coming back to same node) + 1(for going to next node)** the final relation is dp[i+1] = (2 * dp[i] + 2 - dp[nextVisit[i]]) % mod.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        MOD = 10**9+7\\n        n =len(nextVisit)\\n        dp=[0]*n\\n        for i in range(n-1):\\n            dp[i+1] += (2*dp[i] - dp[nextVisit[i]] + 2)%MOD\\n        \\n        return dp[-1]\\n\\t\\t\\n##### feel free to ask if you have any doubt!!\\n##### Thanks and **upvote** if it helps \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1445492,
                "title": "c-4-liners-o-n-dp-solution-with-explanation",
                "content": "Idea:\\n1. Use dp[i] to record the number of steps to reach i\\n->dp[i+1]=dp[i]+(dp[i]-dp[nextVisit[i]])+2\\n->dp[i]: number of steps for 0 to reach i\\n->dp[i]-dp[nextVisit[i]]: number of steps for nextVisit[i] to reach i\\n->2: number of steps for i to reach i+1\\n```\\nint firstDayBeenInAllRooms(vector<int>& nextVisit) \\n{\\n\\tlong n=nextVisit.size(),d=1000000007,dp[n+1];\\n\\tmemset(dp,0,sizeof(dp));\\n\\tfor(int i=0;i<n-1;i++) dp[i+1]=(2*dp[i]-dp[nextVisit[i]]+2+d)%d;\\n\\n\\treturn dp[n-1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint firstDayBeenInAllRooms(vector<int>& nextVisit) \\n{\\n\\tlong n=nextVisit.size(),d=1000000007,dp[n+1];\\n\\tmemset(dp,0,sizeof(dp));\\n\\tfor(int i=0;i<n-1;i++) dp[i+1]=(2*dp[i]-dp[nextVisit[i]]+2+d)%d;\\n\\n\\treturn dp[n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445368,
                "title": "c-o-n-prefix-sums-basic-overview",
                "content": "The primary observation here is that all the rooms will be reached one after the other.\\nSo, the number of days required to reach a particular room i would be equal to <b>cost[i - 1] + 1 + cost[i - 1] - cost[roomVisitedFromthelastroom] + 1</b>.\\nThe states of the rooms are not important as all of them will always be reset to even values after the transition from room i to room i + 1; so they can always be assumed as even values.\\nThe above things can easily be implemented via Prefix Sums.\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n      vector<long long> costs(nextVisit.size());\\n      long long modder = 1e+9 + 7;\\n      for(int i = 1; i < costs.size(); i++)\\n      {\\n        costs[i] = costs[i - 1] + 1;\\n        costs[i] %= modder;\\n        costs[i] += costs[i - 1] - costs[nextVisit[i - 1]] + 1;\\n        costs[i] %= modder;\\n      }\\n      int output = costs[nextVisit.size() - 1];\\n      if(output < 0)\\n      {output = modder + output;}\\n      return output;\\n    }\\n};\\n//Written by Namit Shah (Eclecticity).\\n//Hack/Challenge this if you wish to salvage a few points off a destined-to-sink ship.\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n      vector<long long> costs(nextVisit.size());\\n      long long modder = 1e+9 + 7;\\n      for(int i = 1; i < costs.size(); i++)\\n      {\\n        costs[i] = costs[i - 1] + 1;\\n        costs[i] %= modder;\\n        costs[i] += costs[i - 1] - costs[nextVisit[i - 1]] + 1;\\n        costs[i] %= modder;\\n      }\\n      int output = costs[nextVisit.size() - 1];\\n      if(output < 0)\\n      {output = modder + output;}\\n      return output;\\n    }\\n};\\n//Written by Namit Shah (Eclecticity).\\n//Hack/Challenge this if you wish to salvage a few points off a destined-to-sink ship.\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1445317,
                "title": "c-o-n-with-explanation",
                "content": "[credits](https://leetcode.com/problems/first-day-where-you-have-been-in-all-the-rooms/discuss/1445156/C%2B%2B-DP)\\n<b>Idea</b>\\n`firstDayVisited[i]` = The first day when room `i` was visited.\\nSince `nextVisit[i]` is less than or equal to `i` , our answer is already stored in an index smaller than `i` (which is already visited).\\nLets say on day `d` I am at the room `i` for the first time. Assume `n` is the total number of rooms. Since I visited the room `i` for the first time, I visited it odd number of times and I must visit `nextVisit[i]` now. \\nI claim that if `nextVisit[i]!=i` then **I am visiting `nextVisit[i]` odd number of time**. For the case when `nextVisit[i]==i` the value of `firstDayVisited[i+1]` is simply 2 and we\\'ll see that the expression that we develop takes into account of this `nextVisit[i]==i` case also.\\nThis claim is true because in order to move at a room having index greater than `i` , I must have visited it even number of times. Since my current room index `i` is greater than `nextVisit[i]` , I must have already visited `nextVisit[i]` even number of times and visiting it again. So, now I am visiting `nextVisit[i]` odd number of times. \\nThe first day I visited the room `nextVisit[i]` is stored in `firstDayVisited[nextVisit[i]]`. The day on which I visited room `i` is `d`. We can utilize these 2 informations to know when will we revisit room `i` again. The day of revisiting is the difference+1 , that is, `d-firstDayVisited[nextVisit[i]]+1` . Now, I\\'ll take 1 extra day to visit the room `i+1`.\\nSo, the day on which room `i+1` is visited for the first time = `d-firstDayVisited[nextVisit[i]]+2`. Using this pattern, we can see that the last room will be covered on the last day. So, we return `firstDayVisited[n-1]`.\\nFrom our definition of `firstDayVisited` , `d=firstDayVisited[i]`. For the case when `nextVisit[i]==i` , \\n`d-firstDayVisited[nextVisit[i]]+2 = firstDayVisited[i]-firstDayVisited[nextVisit[i]]+2 =  firstDayVisited[i]-firstDayVisited[i]+2 = 2`\\n\\n<b>Note</b>\\nDon\\'t take modulo at each step and maximize it. This may give wrong answer as it may happen that the modulo of a smaller number is greater than the modulo of a greater number. But we have to return the modulo of the greatest day of first visit of room `n-1` modulo 1e9+7\\n\\nDo comment in case of any confusion.\\n\\n```\\n\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\nint firstDayBeenInAllRooms(vector<int>& nextVisit){\\n    int n=nextVisit.size(),ans=0;\\n    vector<int> firstDayVisited(n,0);\\n    for(int i=0;i<n-1;i++) firstDayVisited[i+1]=(((firstDayVisited[i]-firstDayVisited[nextVisit[i]]+mod)%mod+2)%mod+firstDayVisited[i])%mod;\\n    return firstDayVisited.back();\\n}\\n};\\n```\\n\\n<b>100% faster code</b>\\n```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\nint firstDayBeenInAllRooms(vector<int>& nextVisit){\\n    int n=nextVisit.size(),ans=0;\\n    int *firstDayVisited=new int[n]();\\n    for(int i=0;i<n-1;i++) firstDayVisited[i+1]=(((firstDayVisited[i]-firstDayVisited[nextVisit[i]]+mod)%mod+2)%mod+firstDayVisited[i])%mod;\\n    return firstDayVisited[n-1];\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\nint firstDayBeenInAllRooms(vector<int>& nextVisit){\\n    int n=nextVisit.size(),ans=0;\\n    vector<int> firstDayVisited(n,0);\\n    for(int i=0;i<n-1;i++) firstDayVisited[i+1]=(((firstDayVisited[i]-firstDayVisited[nextVisit[i]]+mod)%mod+2)%mod+firstDayVisited[i])%mod;\\n    return firstDayVisited.back();\\n}\\n};\\n```\n```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\nint firstDayBeenInAllRooms(vector<int>& nextVisit){\\n    int n=nextVisit.size(),ans=0;\\n    int *firstDayVisited=new int[n]();\\n    for(int i=0;i<n-1;i++) firstDayVisited[i+1]=(((firstDayVisited[i]-firstDayVisited[nextVisit[i]]+mod)%mod+2)%mod+firstDayVisited[i])%mod;\\n    return firstDayVisited[n-1];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445163,
                "title": "c-easy-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& next) {\\n        ll n = next.size();\\n        ll mod = 1e9+7;\\n        vector<ll>time(n);\\n        vector<ll>pref(n);\\n        pref[0]=2;\\n        time[0]=2;\\n        ll arr = 2;\\n        for(ll i=1; i<n; i++){\\n            if(i==n-1)\\n                return arr%mod;\\n            ll p = next[i];\\n            ll end = (arr+1+(pref[i-1]-((p==0) ? 0 : pref[p-1]))+mod)%mod;\\n            time[i]=(end-arr+1+mod)%mod;\\n            pref[i] = (pref[i-1]+time[i]+mod)%mod;\\n            arr=  (end+1+mod)%mod;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& next) {\\n        ll n = next.size();\\n        ll mod = 1e9+7;\\n        vector<ll>time(n);\\n        vector<ll>pref(n);\\n        pref[0]=2;\\n        time[0]=2;\\n        ll arr = 2;\\n        for(ll i=1; i<n; i++){\\n            if(i==n-1)\\n                return arr%mod;\\n            ll p = next[i];\\n            ll end = (arr+1+(pref[i-1]-((p==0) ? 0 : pref[p-1]))+mod)%mod;\\n            time[i]=(end-arr+1+mod)%mod;\\n            pref[i] = (pref[i-1]+time[i]+mod)%mod;\\n            arr=  (end+1+mod)%mod;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901222,
                "title": "dp",
                "content": "**dp/running sum**\\n**time: `O(N)`; space: `O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/29da1ca5-128a-4f72-82b7-71f60cc97e64_1692049088.2139049.png)\\n\\n```\\nint firstDayBeenInAllRooms(vector<int>& n)\\n{\\n\\tint dp[100001]{};\\n\\tfor(int i{}; i<size(n); ++i)\\n\\t\\tdp[i+1] = (2*(dp[i]+1)-dp[n[i]]+1000000007ll)%1000000007;\\n\\treturn dp[size(n)-1];\\n}\\n```\\n\\n**Things I understood while working on this problem (not necessarily in the chronological order)**\\n\\n* second rule prevents infinite \"dead\" loops;\\n* you can\\'t immediately go forward if you have visited the point for the first time;\\n* you can go forward only if you\\'ve done a full loop: `i -> ... -> i`;\\n* the problem is inherently recursive: you have to redo what you\\'ve already done before.\\n* thus simulation may lead to exponentially growing paths. That\\'s why we need to reuse previous results in order to avoid that and \\'add changes\\'.\\n* we don\\'t need the exact path, we need the number of steps in the path;\\n* there are only only three elementary operations: `make one step forward`,  `revert to i-x`, `repeat i-th path`.\\n* to get to `i` you need to get to `i-1` that implies iterative solution. \\n* the solutions involves operations: `+1`, `reuse previous results`. We can reuse previos results via one of 2 dp methods:\\n> - bottom to up iteration with memorisation of the previous results;\\n> - up to bottom recursion;\\n* the answer is essentially the running sum of `loop(i)+one_step_forward`. Running sum enables queries: what\\'s the minimum number operations to get from `i` to `j`.\\n\\n![image](https://assets.leetcode.com/users/images/cdcc9230-dc67-4068-ba90-245fb8fdaaaa_1692034618.0753334.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint firstDayBeenInAllRooms(vector<int>& n)\\n{\\n\\tint dp[100001]{};\\n\\tfor(int i{}; i<size(n); ++i)\\n\\t\\tdp[i+1] = (2*(dp[i]+1)-dp[n[i]]+1000000007ll)%1000000007;\\n\\treturn dp[size(n)-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896289,
                "title": "easy-cpp-dp-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n=nextVisit.size();\\n        vector<long long>dp(n,0);\\n        int i=0;\\n        long long days=0;\\n        \\n        while(i<n){\\n         \\n            dp[i]=days;\\n         \\n           if(i==n-1)break;\\n             days++;\\n            if(nextVisit[i]==i){\\n                days=days+1;\\n                \\n            }\\n            else{\\n                long long k=(days-dp[nextVisit[i]]);\\n\\n                days+=(k%1000000007);\\n               \\n                \\n              \\n            }\\n         \\ni++;\\n\\n        }\\n        return (days)%1000000007;\\n    }\\n};\\n// \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n=nextVisit.size();\\n        vector<long long>dp(n,0);\\n        int i=0;\\n        long long days=0;\\n        \\n        while(i<n){\\n         \\n            dp[i]=days;\\n         \\n           if(i==n-1)break;\\n             days++;\\n            if(nextVisit[i]==i){\\n                days=days+1;\\n                \\n            }\\n            else{\\n                long long k=(days-dp[nextVisit[i]]);\\n\\n                days+=(k%1000000007);\\n               \\n                \\n              \\n            }\\n         \\ni++;\\n\\n        }\\n        return (days)%1000000007;\\n    }\\n};\\n// \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886385,
                "title": "super-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        int mod = 1_000_000_007;\\n        int n = nextVisit.length;\\n        long dp[] = new long[n];\\n        for (int i = 1; i < n; ++i) {\\n            dp[i] = (dp[i - 1] + dp[i - 1] - dp[nextVisit[i - 1]] + 2 + mod) % mod;\\n        }\\n        return (int) dp[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        int mod = 1_000_000_007;\\n        int n = nextVisit.length;\\n        long dp[] = new long[n];\\n        for (int i = 1; i < n; ++i) {\\n            dp[i] = (dp[i - 1] + dp[i - 1] - dp[nextVisit[i - 1]] + 2 + mod) % mod;\\n        }\\n        return (int) dp[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648758,
                "title": "c-dp-easy-detailed-explanation-give-it-a-read",
                "content": "# Approach\\n- Simulating the problem as it is will lead to tle because we will be recalculating the parts when we visit ith room odd number of times and then we go to nextVisit[i] then again come back to i.\\n- If we know how much days it will take to go from ith room to nextVisit[i] and then back to ith room (if ith room is visited odd number of times), we can add those days in the final answer and then move forward.\\n- Hence for each room we will store the first day when we reached it.\\n- This will help us answer our query efficiently because now we can do something like this-\\n- For example we are currently at ith room and it is our first visit and it took us 6 days to reach here, now we will go to nextVisit[i] which is say jth room and now as we have stored the first day when we reached jth room, let\\'s say it was day 4 so now we can directly answer that it would take (6-4)+1 days to go from ith to jth room and back to ith room.\\n- Here we are using dp array to store the first day we visited each room.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int firstDayBeenInAllRooms(vector<int>& arr) {\\n        long long days = 1;\\n        int n = arr.size();\\n        vector<int> dp(n,-1);\\n        dp[0] = 0;\\n        map<int,int> m;\\n        m[0] = 1;\\n        int i = arr[0];\\n        for(;i<n;)\\n        {\\n            m[i]++;\\n            if(m[i]%2!=0)\\n            {\\n                if(m[i]==1 && dp[i]==-1)\\n                dp[i] = days;\\n                int nextIdx = arr[i];\\n                long long d1 = dp[nextIdx];\\n                long long d2 = dp[i];\\n                days = (days+(d2-d1)+1+mod)%mod;\\n                m[i]++;\\n            }\\n            if(m[i]%2==0)\\n            {\\n                i = (i+1)%mod;\\n                days = (days+1)%mod;\\n                if(i==n-1)\\n                break;\\n            }\\n        }\\n        return days;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int firstDayBeenInAllRooms(vector<int>& arr) {\\n        long long days = 1;\\n        int n = arr.size();\\n        vector<int> dp(n,-1);\\n        dp[0] = 0;\\n        map<int,int> m;\\n        m[0] = 1;\\n        int i = arr[0];\\n        for(;i<n;)\\n        {\\n            m[i]++;\\n            if(m[i]%2!=0)\\n            {\\n                if(m[i]==1 && dp[i]==-1)\\n                dp[i] = days;\\n                int nextIdx = arr[i];\\n                long long d1 = dp[nextIdx];\\n                long long d2 = dp[i];\\n                days = (days+(d2-d1)+1+mod)%mod;\\n                m[i]++;\\n            }\\n            if(m[i]%2==0)\\n            {\\n                i = (i+1)%mod;\\n                days = (days+1)%mod;\\n                if(i==n-1)\\n                break;\\n            }\\n        }\\n        return days;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625679,
                "title": "java-solution",
                "content": "# logic\\n- i have learnt the logic from sandeep jana channel on youtube it has the best explaination \\n# code\\n```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] next) {\\n        int i,j,n=next.length;\\n        long mod=1000_000_007l;\\n        long dp[]=new long[n];\\n        dp[0]=0;\\n        for(i=1;i<n;i++)\\n        {\\n            if(next[i-1]==i-1)\\n            {\\n                dp[i]=(dp[i-1]+2)%mod;\\n            }\\n            else\\n            {\\n                dp[i]=(dp[i-1]+dp[i-1]+2-dp[next[i-1]]+mod)%mod;\\n            }\\n        }\\n        return (int)(dp[n-1]%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] next) {\\n        int i,j,n=next.length;\\n        long mod=1000_000_007l;\\n        long dp[]=new long[n];\\n        dp[0]=0;\\n        for(i=1;i<n;i++)\\n        {\\n            if(next[i-1]==i-1)\\n            {\\n                dp[i]=(dp[i-1]+2)%mod;\\n            }\\n            else\\n            {\\n                dp[i]=(dp[i-1]+dp[i-1]+2-dp[next[i-1]]+mod)%mod;\\n            }\\n        }\\n        return (int)(dp[n-1]%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615510,
                "title": "c-simple-dp-approach",
                "content": "# Intuition\\nUpon looking at the question we have a feel that i th room visits depends upon i-1th room visit\\'s and so on. Hence we approach the question through dp.\\n\\n# Approach\\n- The first line of thought to have a dp state is staraight forward. The vector **dp[i]** represent the first day the ith room is reached.\\n- The transition is: **dp[i] = dp[i-1] + 2 + (dp[i-1] - dp[nextVisit[i-1]])** The transition can be seen by dry running throught the example code \\n- Then the base case is decided which are dp[0] = 0 and dp[1] = 2\\n- Then iterative dp is performed\\n- To get the code under constrants modular arithmatic is used. Remember we are subtracting a term hence we are using +M and then taking the mod.\\n\\n# Complexity\\n- Time complexity:\\nAs the loop is running from 1 to N. And all other opperations are O(1) operations. The TC of the code is O(N)\\n\\n- Space complexity:\\nAs we are storing n values in the dp at time. We can say that the space complexity is also o(N).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        const int M = 1e9+7;\\n        int sum =0;\\n        vector<int> dp(n,0);\\n        visits[0] =1;\\n        dp[0] = 0;\\n        dp[1] = 2;\\n        for(int i=2;i<n;i++){\\n            dp[i] = ((dp[i-1] + 2)%M +dp[i-1])%M;\\n            dp[i] =  ((dp[i] - dp[nextVisit[i-1]])%M + M)%M;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        const int M = 1e9+7;\\n        int sum =0;\\n        vector<int> dp(n,0);\\n        visits[0] =1;\\n        dp[0] = 0;\\n        dp[1] = 2;\\n        for(int i=2;i<n;i++){\\n            dp[i] = ((dp[i-1] + 2)%M +dp[i-1])%M;\\n            dp[i] =  ((dp[i] - dp[nextVisit[i-1]])%M + M)%M;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424430,
                "title": "start-and-end-time-of-each-position",
                "content": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n = len(nextVisit)\\n        M = 10 ** 9 + 7\\n        start = [0] * n\\n        end = [0] * n\\n        end[0] = 1\\n        for i in range(1, n):\\n            start[i] = end[i - 1] + 1\\n            end[i] = 2 * start[i] - start[nextVisit[i]] + 1\\n            start[i] %= M\\n            end[i] %= M\\n        return start[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n = len(nextVisit)\\n        M = 10 ** 9 + 7\\n        start = [0] * n\\n        end = [0] * n\\n        end[0] = 1\\n        for i in range(1, n):\\n            start[i] = end[i - 1] + 1\\n            end[i] = 2 * start[i] - start[nextVisit[i]] + 1\\n            start[i] %= M\\n            end[i] %= M\\n        return start[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292177,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size() ;\\n        int M = 1e9 + 7 ;\\n        vector<long long>dp(n) ;\\n        dp[0] = 0 ;\\n        for(int i = 0; i < n - 1; i++){\\n            int j = nextVisit[i] ;\\n            //dp[i+1] = \\u7B2C\\u4E00\\u6B21\\u5230\\u9054i , \\u8DF3\\u56DE j (\\u6B65\\u6578+1) + dp[i] - dp[j]\\n            //          i --> i+1, \\u518D\\u52A0 1   \\n            dp[i+1] = ((dp[i] + 1 + dp[i] - dp[j] + M) + 1 ) % M ;\\n        }\\n        return dp[n-1] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size() ;\\n        int M = 1e9 + 7 ;\\n        vector<long long>dp(n) ;\\n        dp[0] = 0 ;\\n        for(int i = 0; i < n - 1; i++){\\n            int j = nextVisit[i] ;\\n            //dp[i+1] = \\u7B2C\\u4E00\\u6B21\\u5230\\u9054i , \\u8DF3\\u56DE j (\\u6B65\\u6578+1) + dp[i] - dp[j]\\n            //          i --> i+1, \\u518D\\u52A0 1   \\n            dp[i+1] = ((dp[i] + 1 + dp[i] - dp[j] + M) + 1 ) % M ;\\n        }\\n        return dp[n-1] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265829,
                "title": "easy-and-concise-solution-easily-understood-able",
                "content": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int firstDayBeenInAllRooms(int[] n) {\\n        long data[] = new long[n.length],count=0L;\\n        Arrays.fill(data,0L);\\n        long output = 0L;\\n        for(int i=0;i<n.length-1;i++){\\n            long temp = 0L;\\n            temp = (2L+((i-1>=0?1L*data[i-1]:0L)-(n[i]-1>=0?1L*data[n[i]-1]:0L)))%mod;\\n            data[i] = ((i-1>=0?data[i-1]:0)+(temp+mod)%mod)%mod;\\n        }\\n        return (int)(data[n.length-2]%mod);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int mod = 1000000007;\\n    public int firstDayBeenInAllRooms(int[] n) {\\n        long data[] = new long[n.length],count=0L;\\n        Arrays.fill(data,0L);\\n        long output = 0L;\\n        for(int i=0;i<n.length-1;i++){\\n            long temp = 0L;\\n            temp = (2L+((i-1>=0?1L*data[i-1]:0L)-(n[i]-1>=0?1L*data[n[i]-1]:0L)))%mod;\\n            data[i] = ((i-1>=0?data[i-1]:0)+(temp+mod)%mod)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3242780,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn first_day_been_in_all_rooms(next_visit: Vec<i32>) -> i32 {\\n        let mod_num = 1_000_000_007;\\n        let mut dp = vec![0_i64; next_visit.len() + 1];\\n        for i in 1..next_visit.len() {\\n            dp[i] = (2 + 2 * dp[i - 1] - dp[next_visit[i - 1] as usize] + mod_num) % mod_num;\\n        }\\n        dp[next_visit.len() - 1] as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn first_day_been_in_all_rooms(next_visit: Vec<i32>) -> i32 {\\n        let mod_num = 1_000_000_007;\\n        let mut dp = vec![0_i64; next_visit.len() + 1];\\n        for i in 1..next_visit.len() {\\n            dp[i] = (2 + 2 * dp[i - 1] - dp[next_visit[i - 1] as usize] + mod_num) % mod_num;\\n        }\\n        dp[next_visit.len() - 1] as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164156,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit)\\n    {\\n        int n=nextVisit.size();\\n        vector<long long>dp(n,0);\\n        long long mod=1e9+7;\\n        for (int i=1;i<n;i++)\\n        {\\n            if(nextVisit[i-1]==i-1)\\n            dp[i]=(dp[i-1]+2+mod)%mod;\\n            else{\\n                dp[i]=(dp[i-1]+2+dp[i-1]-dp[nextVisit[i-1]]+mod)%mod;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit)\\n    {\\n        int n=nextVisit.size();\\n        vector<long long>dp(n,0);\\n        long long mod=1e9+7;\\n        for (int i=1;i<n;i++)\\n        {\\n            if(nextVisit[i-1]==i-1)\\n            dp[i]=(dp[i-1]+2+mod)%mod;\\n            else{\\n                dp[i]=(dp[i-1]+2+dp[i-1]-dp[nextVisit[i-1]]+mod)%mod;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158470,
                "title": "c-prefix-sum-with-detailed-explaintaion",
                "content": "O(N) time, O(N) space\\n```\\nint firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        //key realization:\\n        //1. only move forward when current room is visited even times(to be specific, twice). \\n        //2. whenever we reach a new room, all previous rooms must have been visited even times.\\n        int n = nextVisit.size();\\n        //pre is prefix sum, pre[i] means the first day we visit ith room\\n        //for example, pre[3] = 5 means we visit room 3 on day 5, pre[7] = 10 means we visit room 7 on day 10, then to go from room 3 to room 7, it takes pre[7]-pre[3]+1 = 6 days. notice that we add 1 because we need to include day 5, which is pre[3]. \\n        vector<long> pre(n);\\n        long day = 0;\\n        int room = 0;\\n        int mod = 1e9+7;\\n        while(room<n-1){\\n            //in each iteration of while loop, we visit a brand new room, so the assumption here is that we visit the current new room once, and all previous rooms have been visited even times.\\n            pre[room] = day;\\n            //when next room to visit is itself, we can proceed to next unvisited room, but we need to revisit current room again first \\n            if(nextVisit[room]==room) day++;\\n            //when next room to visit is previous visited rooms, we don\\'t go through the repeated steps and recalculate, we can simply use prefix sum to quickly calculate how many days we need to get back to current room again. the formula is explained above.\\n            //a trick here is (value_to_calculate+mod)%mod.\\n            else{\\n                day = (day+pre[room]-pre[nextVisit[room]]+1+mod)%mod;\\n            }\\n            day++;\\n            room++;\\n        }\\n        return (int)day%mod;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        //key realization:\\n        //1. only move forward when current room is visited even times(to be specific, twice). \\n        //2. whenever we reach a new room, all previous rooms must have been visited even times.\\n        int n = nextVisit.size();\\n        //pre is prefix sum, pre[i] means the first day we visit ith room\\n        //for example, pre[3] = 5 means we visit room 3 on day 5, pre[7] = 10 means we visit room 7 on day 10, then to go from room 3 to room 7, it takes pre[7]-pre[3]+1 = 6 days. notice that we add 1 because we need to include day 5, which is pre[3]. \\n        vector<long> pre(n);\\n        long day = 0;\\n        int room = 0;\\n        int mod = 1e9+7;\\n        while(room<n-1){\\n            //in each iteration of while loop, we visit a brand new room, so the assumption here is that we visit the current new room once, and all previous rooms have been visited even times.\\n            pre[room] = day;\\n            //when next room to visit is itself, we can proceed to next unvisited room, but we need to revisit current room again first \\n            if(nextVisit[room]==room) day++;\\n            //when next room to visit is previous visited rooms, we don\\'t go through the repeated steps and recalculate, we can simply use prefix sum to quickly calculate how many days we need to get back to current room again. the formula is explained above.\\n            //a trick here is (value_to_calculate+mod)%mod.\\n            else{\\n                day = (day+pre[room]-pre[nextVisit[room]]+1+mod)%mod;\\n            }\\n            day++;\\n            room++;\\n        }\\n        return (int)day%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3062171,
                "title": "python-dp-solution",
                "content": "dp[i] means we reach room `i` at `dp[i]` days.\\nIn order to reach room `i+1`, we need to reach room `i` **twice** - even times.\\nThe first time is from room `0` to room `i`, while the second is from room `nextV[i]` to room `i`\\nAdditionally, there are 2 cost day - one for moving from room `i` to room `nextV[i]` and another for moving from room `i` to room `i+1`\\n```\\ndef firstDayBeenInAllRooms(self, nextV: List[int]) -> int:\\n\\tdp, mod = [0]*(len(nextV)), 10**9+7\\n\\tfor i in range(len(nextV)-1):\\n\\t\\tdp[i+1] = (dp[i]*2-dp[nextV[i]]+2)%mod\\n\\treturn dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef firstDayBeenInAllRooms(self, nextV: List[int]) -> int:\\n\\tdp, mod = [0]*(len(nextV)), 10**9+7\\n\\tfor i in range(len(nextV)-1):\\n\\t\\tdp[i+1] = (dp[i]*2-dp[nextV[i]]+2)%mod\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2997764,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = size(nextVisit), mod = 1000000007;\\n        vector<vector<long long int>> timeTaken(n+1, vector<long long int>(2, 0));\\n        timeTaken[1][0] = 1;\\n        timeTaken[1][1] = 2;\\n        for(int i=2; i<=n; i++){\\n            timeTaken[i][0] = timeTaken[i-1][1] + 1;\\n            timeTaken[i][1] = 2*timeTaken[i][0] - timeTaken[nextVisit[i-1]][1] + mod;\\n            timeTaken[i][0] %= mod;\\n            timeTaken[i][1] %= mod;\\n        }\\n        return (timeTaken[n][0] - 1 + mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = size(nextVisit), mod = 1000000007;\\n        vector<vector<long long int>> timeTaken(n+1, vector<long long int>(2, 0));\\n        timeTaken[1][0] = 1;\\n        timeTaken[1][1] = 2;\\n        for(int i=2; i<=n; i++){\\n            timeTaken[i][0] = timeTaken[i-1][1] + 1;\\n            timeTaken[i][1] = 2*timeTaken[i][0] - timeTaken[nextVisit[i-1]][1] + mod;\\n            timeTaken[i][0] %= mod;\\n            timeTaken[i][1] %= mod;\\n        }\\n        return (timeTaken[n][0] - 1 + mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950015,
                "title": "c-dp",
                "content": "\\n\\n\\n# Code\\n```\\n#define ll long long \\nint  mod=1e9+7;\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n          int n=nextVisit.size();\\n          vector<vector<ll>>dp(n,vector<ll>(2,0));\\n          dp[0][0]=2;\\n          dp[0][1]=1;\\n          for(int i=1;i<n;i++)\\n          {   dp[i][1]=dp[i-1][0]+1;\\n               if(i==n-1)break;\\n              dp[i][0]=(dp[i][1]+(dp[i-1][0]-dp[nextVisit[i]][1])+2)%mod;  \\n          }\\n          return (dp[n-1][1]+mod-1)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long \\nint  mod=1e9+7;\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n          int n=nextVisit.size();\\n          vector<vector<ll>>dp(n,vector<ll>(2,0));\\n          dp[0][0]=2;\\n          dp[0][1]=1;\\n          for(int i=1;i<n;i++)\\n          {   dp[i][1]=dp[i-1][0]+1;\\n               if(i==n-1)break;\\n              dp[i][0]=(dp[i][1]+(dp[i-1][0]-dp[nextVisit[i]][1])+2)%mod;  \\n          }\\n          return (dp[n-1][1]+mod-1)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814450,
                "title": "python-simple-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit):\\n        n, mod = len(nextVisit), 10**9 + 7\\n        dp = [0]*n \\n\\n        for i in range(1,n):\\n            dp[i] = (dp[i-1] + (dp[i-1] - dp[nextVisit[i-1]] + 1) + 1)%mod\\n\\n        return dp[-1]\\n\\n\\n\\n\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit):\\n        n, mod = len(nextVisit), 10**9 + 7\\n        dp = [0]*n \\n\\n        for i in range(1,n):\\n            dp[i] = (dp[i-1] + (dp[i-1] - dp[nextVisit[i-1]] + 1) + 1)%mod\\n\\n        return dp[-1]\\n\\n\\n\\n\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776890,
                "title": "c-3-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& v) {\\n        long pre_sum[100001]{}, mod = 1000000007, n = v.size();\\n        for(int i = 0; i < n; i++) pre_sum[i+1] = (pre_sum[i] + pre_sum[i] - pre_sum[v[i]] + 2 + mod)%mod;\\n        return pre_sum[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& v) {\\n        long pre_sum[100001]{}, mod = 1000000007, n = v.size();\\n        for(int i = 0; i < n; i++) pre_sum[i+1] = (pre_sum[i] + pre_sum[i] - pre_sum[v[i]] + 2 + mod)%mod;\\n        return pre_sum[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765071,
                "title": "python-two-solutions",
                "content": "# Approach\\nFirst approach (at the bottom of the code) was to directly simulate the process using caching. We keep track of the last day a room was visited in ```last_day``` and the number of times a room has been visited in ```visits```. The calculations performed coalesce into the dynamic programming solution at the top.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms2(self, next_visit: List[int]) -> int:\\n        p = 10**9 + 7\\n        n = len(next_visit)\\n        dp = [0]*n\\n\\n        for i in range(1,n):\\n            dp[i] = (2 * dp[i-1] - dp[next_visit[i-1]] + 2) % p\\n\\n        return dp[-1]\\n\\n    def firstDayBeenInAllRooms(self, next_visit: List[int]) -> int:\\n        p = 10**9 + 7\\n        n = len (next_visit)\\n        not_visited = set(range(n))\\n\\n        visits = [0] * n\\n        last_day = [float(\\'-inf\\')] * n\\n\\n        def simulate (room, day):\\n            not_visited.discard(room)\\n            while not_visited:\\n                visits[room] += 1\\n                last_day[room] = day\\n                if visits[room] & 1:\\n                    # This room has been visited an odd number of times.\\n                    day = (2*day - last_day[next_visit[room]] + 1) % p\\n\\n                # This room has been visited an even number of times.\\n                day += 1\\n                room = (room + 1) % n\\n                not_visited.discard(room)\\n\\n            return day\\n\\n        return simulate (0, 0) % p\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```last_day```\n```visits```\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms2(self, next_visit: List[int]) -> int:\\n        p = 10**9 + 7\\n        n = len(next_visit)\\n        dp = [0]*n\\n\\n        for i in range(1,n):\\n            dp[i] = (2 * dp[i-1] - dp[next_visit[i-1]] + 2) % p\\n\\n        return dp[-1]\\n\\n    def firstDayBeenInAllRooms(self, next_visit: List[int]) -> int:\\n        p = 10**9 + 7\\n        n = len (next_visit)\\n        not_visited = set(range(n))\\n\\n        visits = [0] * n\\n        last_day = [float(\\'-inf\\')] * n\\n\\n        def simulate (room, day):\\n            not_visited.discard(room)\\n            while not_visited:\\n                visits[room] += 1\\n                last_day[room] = day\\n                if visits[room] & 1:\\n                    # This room has been visited an odd number of times.\\n                    day = (2*day - last_day[next_visit[room]] + 1) % p\\n\\n                # This room has been visited an even number of times.\\n                day += 1\\n                room = (room + 1) % n\\n                not_visited.discard(room)\\n\\n            return day\\n\\n        return simulate (0, 0) % p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744269,
                "title": "c-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n        public int FirstDayBeenInAllRooms(int[] nextVisit)\\n        {\\n            long[] dp = new long[nextVisit.Length];\\n            int mod = (int)1e9 + 7;\\n\\n            for (int i = 1; i < nextVisit.Length; i++)\\n            {\\n                if (nextVisit[i - 1] == i - 1)\\n                {\\n                    dp[i] = dp[i - 1] + 2;\\n                }\\n                else\\n                {\\n                    dp[i] = (dp[i - 1] + dp[i-1] - dp[nextVisit[i-1]] + 2 + mod) % mod;\\n                }\\n            }\\n\\n            return (int)dp[nextVisit.Length - 1];\\n        }\\n       \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n        public int FirstDayBeenInAllRooms(int[] nextVisit)\\n        {\\n            long[] dp = new long[nextVisit.Length];\\n            int mod = (int)1e9 + 7;\\n\\n            for (int i = 1; i < nextVisit.Length; i++)\\n            {\\n                if (nextVisit[i - 1] == i - 1)\\n                {\\n                    dp[i] = dp[i - 1] + 2;\\n                }\\n                else\\n                {\\n                    dp[i] = (dp[i - 1] + dp[i-1] - dp[nextVisit[i-1]] + 2 + mod) % mod;\\n                }\\n            }\\n\\n            return (int)dp[nextVisit.Length - 1];\\n        }\\n       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736383,
                "title": "simple-dp-explained-python",
                "content": "Whenever u visit a node for the first time, you have to visit it again before moving forward. \\nTime it takes to visit it again = curr_time - FirstTime[nex] + 1\\nnex represents nextVisit[c_node],\\nnex <= c_node, so u must have visited nex before c_node unless nex is c_node. \\n\\n```\\ndef firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n    n = len(nextVisit)\\n    MOD = 1000000007\\n\\n    time = [0]*n\\n    c_time = -1\\n    for i in range(n):\\n        c_time += 1\\n        c_time %= MOD\\n        time[i] = c_time \\n        \\n        c_time += c_time - time[nextVisit[i]] + 1\\n    \\n    return time[n-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n    n = len(nextVisit)\\n    MOD = 1000000007\\n\\n    time = [0]*n\\n    c_time = -1\\n    for i in range(n):\\n        c_time += 1\\n        c_time %= MOD\\n        time[i] = c_time \\n        \\n        c_time += c_time - time[nextVisit[i]] + 1\\n    \\n    return time[n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2668443,
                "title": "python-o-n-dp-solution",
                "content": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        numRooms, day, MOD = len(nextVisit), 0, 1000000007\\n        daysToGetPast = [0] * numRooms\\n        for i in range(numRooms - 1):\\n            if nextVisit[i] == i:\\n                day = (day + 2) % MOD\\n            else:\\n                timeFromBegToEnterRoom = 0\\n                if nextVisit[i] > 0:\\n                    timeFromBegToEnterRoom = daysToGetPast[nextVisit[i] - 1]\\n                day = (((2*(day % MOD)) % MOD - (timeFromBegToEnterRoom % MOD)) + MOD) % MOD\\n                day = (day + 2) % MOD\\n            daysToGetPast[i] = day % MOD\\n        return daysToGetPast[numRooms - 2]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        numRooms, day, MOD = len(nextVisit), 0, 1000000007\\n        daysToGetPast = [0] * numRooms\\n        for i in range(numRooms - 1):\\n            if nextVisit[i] == i:\\n                day = (day + 2) % MOD\\n            else:\\n                timeFromBegToEnterRoom = 0\\n                if nextVisit[i] > 0:\\n                    timeFromBegToEnterRoom = daysToGetPast[nextVisit[i] - 1]\\n                day = (((2*(day % MOD)) % MOD - (timeFromBegToEnterRoom % MOD)) + MOD) % MOD\\n                day = (day + 2) % MOD\\n            daysToGetPast[i] = day % MOD\\n        return daysToGetPast[numRooms - 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651906,
                "title": "c-o-n-explanation",
                "content": "Let\\'s say we enter room#`i` for the first time.\\nTwo cases:\\n* if `nextVisit[i] == i` : going to need 2 additional days to get past this room\\n* else (if `nextVisit[i] < i`): we get sent back to room#`nextVisit[i]`. And we have to do the sequence again where we go from room#`nextVisit[i]` to room#`i`\\n\\nTo do this in linear time, we just have to store/cache the total days (from the beginning) it took us to getPastRoom `i`, and a variable to keep track of how many days have past since the beginning.\\n\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        vector<long long> daysToGetPast(n, 0);\\n        long long day = 0;\\n        int MOD = 1e9+7;\\n        \\n        for (int i = 0; i < n-1; ++i) {\\n            if (nextVisit[i] == i) {\\n                day = (day+2)%MOD;\\n            }\\n            else {\\n                \\n\\t\\t\\t\\tlong long p = 0; // p:= time to go from beginning to enter room#nextVisit[i]\\n                if (nextVisit[i] > 0) p = daysToGetPast[nextVisit[i]-1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// additional time to go from room#nextVisit[i]->entering room#[i]\\n                day = (((2*(day%MOD))%MOD-(p%MOD))+MOD)%MOD;\\n\\t\\t\\t\\t// we visit room#i twice, so need to add that to total time\\n                day = (day+2)%MOD;\\n            }\\n\\t\\t\\t// cache the number of days required to get past room[i-1]\\n            daysToGetPast[i] = day%MOD;\\n        }\\n\\t\\t\\n\\t\\t// time to visit all rooms = time required to enter last (n-1) room = time required to get past second-last (n-2th) room\\n        return (int) daysToGetPast[n-2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        vector<long long> daysToGetPast(n, 0);\\n        long long day = 0;\\n        int MOD = 1e9+7;\\n        \\n        for (int i = 0; i < n-1; ++i) {\\n            if (nextVisit[i] == i) {\\n                day = (day+2)%MOD;\\n            }\\n            else {\\n                \\n\\t\\t\\t\\tlong long p = 0; // p:= time to go from beginning to enter room#nextVisit[i]\\n                if (nextVisit[i] > 0) p = daysToGetPast[nextVisit[i]-1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// additional time to go from room#nextVisit[i]->entering room#[i]\\n                day = (((2*(day%MOD))%MOD-(p%MOD))+MOD)%MOD;\\n\\t\\t\\t\\t// we visit room#i twice, so need to add that to total time\\n                day = (day+2)%MOD;\\n            }\\n\\t\\t\\t// cache the number of days required to get past room[i-1]\\n            daysToGetPast[i] = day%MOD;\\n        }\\n\\t\\t\\n\\t\\t// time to visit all rooms = time required to enter last (n-1) room = time required to get past second-last (n-2th) room\\n        return (int) daysToGetPast[n-2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574135,
                "title": "o-n-simple-c",
                "content": "```\\nWe need to find the day we crossed n-1th room.\\nWe need atleast 2 days to cross a room.\\nThe number of days will be 2 when nextVisit[i] = i;\\nElse if nextVisit[i] = prev, then we will need prev->i + 2 days as we need to go back to prev\\nand from there we again need to come to current room.\\nSo maintain an array which tells us the day when we cross ith room.\\nFor 0th room dp[0] = 2, as we can cross room 0 on day 2 and can visit room 1.\\nSo for 1st room if dp[1]  = 1 then we can just add 2 to dp[0], dp[1] = dp[0] + 2;\\nelse we need to go back to room given in 1 and add those days too.\\nSo to generalize\\ndp[i] = dp[i-1] + 2;\\nif(nextVisit[i] != i) then dp[i] += days(nextVisit[i] -> i) and those days are from the day we\\nentered nextVisit[i] (which is dp[nextVisit[i]-1]) till the day we entered i (which is dp[i-1])\\n```\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll M = 1e9+7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        ll days[100001];\\n        days[0] = 2;\\n        for(int i=1; i<n-1; i++){\\n            ll visit = nextVisit[i];\\n            days[i] = days[i-1] + 2;\\n            if(visit != i) days[i] += (M + days[i-1] - (visit > 0?days[visit-1]:0))%M;\\n            days[i] %= M;\\n        }\\n        return days[n-2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nWe need to find the day we crossed n-1th room.\\nWe need atleast 2 days to cross a room.\\nThe number of days will be 2 when nextVisit[i] = i;\\nElse if nextVisit[i] = prev, then we will need prev->i + 2 days as we need to go back to prev\\nand from there we again need to come to current room.\\nSo maintain an array which tells us the day when we cross ith room.\\nFor 0th room dp[0] = 2, as we can cross room 0 on day 2 and can visit room 1.\\nSo for 1st room if dp[1]  = 1 then we can just add 2 to dp[0], dp[1] = dp[0] + 2;\\nelse we need to go back to room given in 1 and add those days too.\\nSo to generalize\\ndp[i] = dp[i-1] + 2;\\nif(nextVisit[i] != i) then dp[i] += days(nextVisit[i] -> i) and those days are from the day we\\nentered nextVisit[i] (which is dp[nextVisit[i]-1]) till the day we entered i (which is dp[i-1])\\n```\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll M = 1e9+7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        ll days[100001];\\n        days[0] = 2;\\n        for(int i=1; i<n-1; i++){\\n            ll visit = nextVisit[i];\\n            days[i] = days[i-1] + 2;\\n            if(visit != i) days[i] += (M + days[i-1] - (visit > 0?days[visit-1]:0))%M;\\n            days[i] %= M;\\n        }\\n        return days[n-2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531072,
                "title": "c-dp-using-prefix-sum",
                "content": "class Solution {\\npublic:\\n    int cnt[100001];\\n    int ret[100001];\\n    long long prefix[100001];\\n    int M=1e9+7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n=nextVisit.size();\\n        memset(ret,-1,sizeof(ret));\\n        memset(cnt,0,sizeof(cnt));\\n        ret[0]=1;\\n        cnt[0]=0;\\n        prefix[0]=1;\\n        if(n==0)\\n        return 0;\\n        long long time=2;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            cnt[i]++;\\n            cnt[i]=cnt[i]%2;\\n            if(cnt[i]==0)\\n            {\\n                time=(time+1)%M;\\n                continue;\\n            }\\n            int x=nextVisit[i];\\n                if(x==0)\\n                {\\n                  ret[i]=prefix[i-1]+i+1;\\n                  prefix[i]=(prefix[i-1]+ret[i])%M;\\n                }\\n                else\\n                {\\n                    ret[i]=(prefix[i-1]-prefix[x-1]+i+1-x+M)%M;\\n                    prefix[i]=(prefix[i-1]+ret[i])%M;\\n                }\\n                cnt[i]=0;\\n                if(x>0)\\n                time=(time+ret[i]+1)%M;\\n                else\\n                time=(time+ret[i]+1)%M;\\n        }\\n        return time;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int cnt[100001];\\n    int ret[100001];\\n    long long prefix[100001];\\n    int M=1e9+7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n=nextVisit.size();\\n        memset(ret,-1,sizeof(ret));\\n        memset(cnt,0,sizeof(cnt));\\n        ret[0]=1;\\n        cnt[0]=0;\\n        prefix[0]=1;\\n        if(n==0)\\n        return 0;\\n        long long time=2;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            cnt[i]++;\\n            cnt[i]=cnt[i]%2;\\n            if(cnt[i]==0)\\n            {\\n                time=(time+1)%M;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2507154,
                "title": "super-easy-amazing-dp-solution",
                "content": "```\\n```class Solution {\\npublic:\\n    int mod=1e9+7;\\n    int firstDayBeenInAllRooms(vector<int>& nxt) {\\n        int n=nxt.size();\\n        vector<int>dp(n,0);\\n        dp[0]=1;\\n        for(int i=1;i<n-1;i++){\\n            if(nxt[i]!=i){\\n               \\n                dp[i]=((dp[i-1]%mod*2)%mod+1-((nxt[i]-1>=0)?dp[nxt[i]-1]:0)+mod)%mod;\\n            }\\n            else{\\n                dp[i]=dp[i-1]%mod+1;\\n            }\\n            dp[i]=dp[i]%mod;\\n        }\\n        \\n        return (dp[n-2]%mod*2)%mod;\\n    }\\n};\\n```\\n\\n```\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2463809,
                "title": "dynamic-programming-beginner-c",
                "content": "class Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& arr) \\n    {   \\n    \\n        int n=arr.size(),mod=1e9+7;\\n        \\n        if(n==2)\\n            return 2;\\n        \\n        vector<int>dp(n-1);\\n        dp[0]=0;\\n        \\n        int d=2; // present day \\n        for(int i=1;i<n-1;i++)\\n        {\\n            dp[i]=d; // first time i entered this index on this day\\n             \\n            if(arr[i]!=i)  // present day-day i visted that index\\n            {\\n                d=(d+(d-dp[arr[i]]+mod)%mod)%mod;\\n            }\\n            \\n            d=(d+2)%mod; // every index req.atleast 2 days to jump ahead\\n        }\\n        \\n        return d;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& arr) \\n    {   \\n    \\n        int n=arr.size(),mod=1e9+7;\\n        \\n        if(n==2)\\n            return 2;\\n        \\n        vector<int>dp(n-1);\\n        dp[0]=0;\\n        \\n        int d=2; // present day \\n        for(int i=1;i<n-1;i++)\\n        {\\n            dp[i]=d; // first time i entered this index on this day\\n             \\n            if(arr[i]!=i)  // present day-day i visted that index\\n            {\\n                d=(d+(d-dp[arr[i]]+mod)%mod)%mod;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2416325,
                "title": "video-solution-very-similar-problem-on-codeforces",
                "content": "Very similar (kinda same) problem on Codeforces : https://codeforces.com/problemset/problem/1552/F\\n\\nAnd Amazing Video Solution (Not mine but really great) :: https://www.youtube.com/watch?v=_DaTsI42Wvo",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "Very similar (kinda same) problem on Codeforces : https://codeforces.com/problemset/problem/1552/F\\n\\nAnd Amazing Video Solution (Not mine but really great) :: https://www.youtube.com/watch?v=_DaTsI42Wvo",
                "codeTag": "Unknown"
            },
            {
                "id": 2274974,
                "title": "c-dp-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll big = 1e9 + 7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n\\t\\t// dp[i] means the steps it takes from i (first reaching i) to i+1;\\n        vector<ll> dp(n, 0);\\n\\t\\t// sum[i] = dp[0] + dp[1] ... + dp[i-1];\\n        vector<ll> sum(n, 0);\\n        dp[0] = 2;\\n        sum[1] = 2;\\n        for(int i=1; i<n-1; ++i) {\\n            int prev = nextVisit[i];\\n            dp[i] = (2 + sum[i] - sum[prev] + big) % big;\\n            sum[i+1] = (sum[i] + dp[i]) % big;\\n        }\\n        \\n        return sum[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll big = 1e9 + 7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n\\t\\t// dp[i] means the steps it takes from i (first reaching i) to i+1;\\n        vector<ll> dp(n, 0);\\n\\t\\t// sum[i] = dp[0] + dp[1] ... + dp[i-1];\\n        vector<ll> sum(n, 0);\\n        dp[0] = 2;\\n        sum[1] = 2;\\n        for(int i=1; i<n-1; ++i) {\\n            int prev = nextVisit[i];\\n            dp[i] = (2 + sum[i] - sum[prev] + big) % big;\\n            sum[i+1] = (sum[i] + dp[i]) % big;\\n        }\\n        \\n        return sum[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271658,
                "title": "python-o-n-time-and-o-n-space-solution",
                "content": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        #need to keep track of if visit ith room on even day is fine but odd day calulate the number\\n        #we maintain an array to keep track of the number of days it takes to visit back ith room\\n        #again(on second time it is even number)\\n        #that can be find out by if nextVisit[i] = j then numDays[j] ... + numDays[i-1]\\n        #numDays is the number of days it takes to visit i room again making it even\\n        sumUpto = [0 for i in range(len(nextVisit))]\\n        sumUpto[0] = 1\\n        for i in range(1,len(nextVisit)-1):\\n            if nextVisit[i] > 0:\\n                sumUpto[i] = 2*sumUpto[i-1] - sumUpto[nextVisit[i]-1] + (i-nextVisit[i]) + 1\\n            else:\\n                sumUpto[i] = 2*sumUpto[i-1] + i + 1\\n\\t\\t\\tsumUpto[i] %= 1000000007\\n        return (sumUpto[len(nextVisit)-2] + len(nextVisit)-1) % (1000000007)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        #need to keep track of if visit ith room on even day is fine but odd day calulate the number\\n        #we maintain an array to keep track of the number of days it takes to visit back ith room\\n        #again(on second time it is even number)\\n        #that can be find out by if nextVisit[i] = j then numDays[j] ... + numDays[i-1]\\n        #numDays is the number of days it takes to visit i room again making it even\\n        sumUpto = [0 for i in range(len(nextVisit))]\\n        sumUpto[0] = 1\\n        for i in range(1,len(nextVisit)-1):\\n            if nextVisit[i] > 0:\\n                sumUpto[i] = 2*sumUpto[i-1] - sumUpto[nextVisit[i]-1] + (i-nextVisit[i]) + 1\\n            else:\\n                sumUpto[i] = 2*sumUpto[i-1] + i + 1\\n\\t\\t\\tsumUpto[i] %= 1000000007\\n        return (sumUpto[len(nextVisit)-2] + len(nextVisit)-1) % (1000000007)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2252581,
                "title": "python-dp-o-n-4-line-code",
                "content": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        dp = [0 for _ in range(len(nextVisit))]\\n        for idx in range(len(nextVisit)-1):\\n            dp[idx+1] = (dp[idx]+1) * 2 - dp[nextVisit[idx]]\\n        return dp[-1] % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        dp = [0 for _ in range(len(nextVisit))]\\n        for idx in range(len(nextVisit)-1):\\n            dp[idx+1] = (dp[idx]+1) * 2 - dp[nextVisit[idx]]\\n        return dp[-1] % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000260,
                "title": "python-tc-o-n-detailed-and-easy-to-understand-comments",
                "content": "```\\ndef firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n = len(nextVisit)\\n        # firstArrivalDay[i] means the day of first time to visit room i. One important thing worth noting is if room i is firstly visited,\\n        # all preceding rooms i.e. 0,1,..,i-1 are visited even times, essentially, it\\'s same state all preceding rooms are not visited.\\n        # So, if on day t, we firstly visited room i-1, on which day will we visit room i? There are two cases to handle:\\n        # 1. if nextVisit[i-1] is i-1, it will take two days to visit room i which is day t+2\\n        # 2. if nextVisit[i-1] is smaller than i-1, let j = nextVisit[i-1], on day t+1, we goes back to room j. Note: on day t+1, it will be odd times to visit j.\\n        # Because all other rooms are visited even times, same with never be visited. So it will take same amout of days to move from room j to room i-1 with (firstArrivalDay[i-1] - firstArrayDay[j])\\n        firstArrivalDay = [0]*n\\n        MOD = 10**9 + 7\\n        \\n        for i in range(1, n):\\n            if nextVisit[i-1] == i-1:\\n                firstArrivalDay[i] = firstArrivalDay[i-1] + 1 + 1\\n            else:\\n                firstArrivalDay[i] = firstArrivalDay[i-1] + 1 + (firstArrivalDay[i-1] - firstArrivalDay[nextVisit[i-1]]) + 1\\n        if firstArrivalDay[n-1] > MOD:\\n            return firstArrivalDay[n-1] % (MOD)\\n        else:\\n            return firstArrivalDay[n-1]",
                "solutionTags": [],
                "code": "```\\ndef firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n = len(nextVisit)\\n        # firstArrivalDay[i] means the day of first time to visit room i. One important thing worth noting is if room i is firstly visited,\\n        # all preceding rooms i.e. 0,1,..,i-1 are visited even times, essentially, it\\'s same state all preceding rooms are not visited.\\n        # So, if on day t, we firstly visited room i-1, on which day will we visit room i? There are two cases to handle:\\n        # 1. if nextVisit[i-1] is i-1, it will take two days to visit room i which is day t+2\\n        # 2. if nextVisit[i-1] is smaller than i-1, let j = nextVisit[i-1], on day t+1, we goes back to room j. Note: on day t+1, it will be odd times to visit j.\\n        # Because all other rooms are visited even times, same with never be visited. So it will take same amout of days to move from room j to room i-1 with (firstArrivalDay[i-1] - firstArrayDay[j])\\n        firstArrivalDay = [0]*n\\n        MOD = 10**9 + 7\\n        \\n        for i in range(1, n):\\n            if nextVisit[i-1] == i-1:\\n                firstArrivalDay[i] = firstArrivalDay[i-1] + 1 + 1\\n            else:\\n                firstArrivalDay[i] = firstArrivalDay[i-1] + 1 + (firstArrivalDay[i-1] - firstArrivalDay[nextVisit[i-1]]) + 1\\n        if firstArrivalDay[n-1] > MOD:\\n            return firstArrivalDay[n-1] % (MOD)\\n        else:\\n            return firstArrivalDay[n-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1956598,
                "title": "c-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        int v[n];//v[i] is the first # for room i\\n        v[0] = 0;\\n        int ans = 1;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            ans = ((ans - v[nextVisit[i]] + 1000000007) % 1000000007 + ans + 1) %(1000000007);\\n            v[i+1] = ans - 1;\\n        }\\n        return (ans-1+ 1000000007)% 1000000007;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        int v[n];//v[i] is the first # for room i\\n        v[0] = 0;\\n        int ans = 1;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            ans = ((ans - v[nextVisit[i]] + 1000000007) % 1000000007 + ans + 1) %(1000000007);\\n            v[i+1] = ans - 1;\\n        }\\n        return (ans-1+ 1000000007)% 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952181,
                "title": "c-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    const int mod = 1e9 + 7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        int64 dp[n];\\n        dp[0] = 0LL;\\n        for(int i = 1; i < n; i++) {\\n            // 1. days to get to i - 1 = dp[i - 1]\\n            // 2. days to get to nextVisit[i - 1] from i - 1 = 1\\n            // 3. days to get to i - 1 from nextVisit[i - 1] = dp[i - 1] - dp[nextVisit[i - 1]]\\n            // 4. days to get to i from i - 1 = 1\\n            dp[i] = dp[i - 1] + 1LL + (dp[i - 1] - dp[nextVisit[i - 1]]) + 1LL + mod;\\n            dp[i] %= mod;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    const int mod = 1e9 + 7;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int n = nextVisit.size();\\n        int64 dp[n];\\n        dp[0] = 0LL;\\n        for(int i = 1; i < n; i++) {\\n            // 1. days to get to i - 1 = dp[i - 1]\\n            // 2. days to get to nextVisit[i - 1] from i - 1 = 1\\n            // 3. days to get to i - 1 from nextVisit[i - 1] = dp[i - 1] - dp[nextVisit[i - 1]]\\n            // 4. days to get to i from i - 1 = 1\\n            dp[i] = dp[i - 1] + 1LL + (dp[i - 1] - dp[nextVisit[i - 1]]) + 1LL + mod;\\n            dp[i] %= mod;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930486,
                "title": "java-dp-with-a-diagram",
                "content": "I drew this diagram to help me visualize this problem.\\nIn order to move the point marked as green, we have to visit the its previous element 2 times. \\nLet `pre[i]` be the first time we enter `i` room, so quickly, we can write down the first half of the relationship:  `pre[i] = pre[i-1] + 1 + ...`\\n\\nThen we consider how long it takes to get back from a random room we got teleported to back to the previous room before green room. \\nBut we actually know this already. It is `pre[i - 1] - pre[nextVisit[i - 1]]` because in order to get to previous room right before the green room, all the past rooms must have been visited even number of times, so we can just treat it as we are here the first time and re-use the same calculation.\\n\\nThus, we complete the re-occuring relationship as `pre[i] = pre[i - 1] + 1 + pre[i - 1] - pre[nextVisit[i - 1]] + 1`\\n\\nps. I named it as `pre` because I was more thinking about the concept of prefix sum espeically with `pre[i] = pre[i - 1] + .. ` and `pre[i - 1] - pre[x]`, but apparently it is more like `dp`\\n\\n![image](https://assets.leetcode.com/users/images/b6b9c62b-38f8-4480-8609-dab85dcb04c5_1649543750.0057323.png)\\n\\n\\n\\n```Java\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] A) {\\n        int m = (int)1e9 + 7;\\n        int[] pre = new int[A.length];\\n        for (int i = 1; i < A.length; i++){\\n            pre[i] = (pre[i - 1] + 1 + (pre[i - 1] - pre[A[i - 1]] + m) % m + 1) % m;\\n        }\\n\\n        return pre[A.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] A) {\\n        int m = (int)1e9 + 7;\\n        int[] pre = new int[A.length];\\n        for (int i = 1; i < A.length; i++){\\n            pre[i] = (pre[i - 1] + 1 + (pre[i - 1] - pre[A[i - 1]] + m) % m + 1) % m;\\n        }\\n\\n        return pre[A.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733857,
                "title": "golang-o-n",
                "content": "```\\nvar mod = 1000000007\\nfunc firstDayBeenInAllRooms(nextVisit []int) int {\\n    next := nextVisit\\n    first := make([]int, len(next))\\n    res := 0\\n    i := 0\\n    for i < len(next) - 1 {  \\n        first[i] = res % mod // first arrive at room i\\n        res =  (res + res - first[next[i]] + 1 + mod) % mod // re-arrive at room i\\n        i++\\n        res = (res + 1) % mod // move from room i to room i + 1\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar mod = 1000000007\\nfunc firstDayBeenInAllRooms(nextVisit []int) int {\\n    next := nextVisit\\n    first := make([]int, len(next))\\n    res := 0\\n    i := 0\\n    for i < len(next) - 1 {  \\n        first[i] = res % mod // first arrive at room i\\n        res =  (res + res - first[next[i]] + 1 + mod) % mod // re-arrive at room i\\n        i++\\n        res = (res + 1) % mod // move from room i to room i + 1\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1607275,
                "title": "java-o-n-space-o-n-dp-modified-prefixsum",
                "content": "- Let\\'s organize buffer array, where buffer[room] has a number of total days that are needed to leave exact room\\n- if we face the room with i==nextVisit[i], then certainly to leave that room we need take into consideration previous room total days number + 2\\n- if we face the room with i<nextVisit[i], then we have to take into consideration : previous room total days number + 1 (the first odd attempt in the current room) + number of days between nextVisit[i] index room (nearest room to the current room) and previous room + 1 (the second even attempt in the curent room)\\n```\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        final long mod = 1000000007L;\\n        int len = nextVisit.length;\\n        long[] prefixSum = new long[len+1];\\n\\n        for(int i=0;i<len;i++){\\n            if(nextVisit[i]==i)\\n                prefixSum[i+1] = prefixSum[i-1+1] + 2;\\n            else\\n                prefixSum[i+1] = (mod + prefixSum[i-1+1] + 1 + prefixSum[i-1+1] - prefixSum[ nextVisit[i]-1+1 ] + 1)%mod;\\n        }\\n        return (int) prefixSum[len-1];\\n    }\\n```\\n\\n\\n\\n\\n\\nOptimized version:\\n```\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        final long mod = 1000000007L;\\n        int len = nextVisit.length;\\n        long[] prefixSum = new long[len+1];\\n\\n        for(int i=0;i<len;i++)\\n                prefixSum[i+1] = (mod + prefixSum[i-1+1] + 1 + prefixSum[i-1+1] - prefixSum[ nextVisit[i]-1+1 ] + 1)%mod;\\n        \\n        return (int) prefixSum[len-1];\\n    }\\n```\\n\\nEven more optimized version :)\\n```\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        final long mod = 1000000007L;\\n        int len = nextVisit.length;\\n        long[] prefixSum = new long[len+1];\\n\\n        for(int i=0;i<len;i++)\\n                prefixSum[i+1] = (mod + prefixSum[i]*2 - prefixSum[ nextVisit[i] ] + 2)%mod;\\n        \\n        return (int) prefixSum[len-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        final long mod = 1000000007L;\\n        int len = nextVisit.length;\\n        long[] prefixSum = new long[len+1];\\n\\n        for(int i=0;i<len;i++){\\n            if(nextVisit[i]==i)\\n                prefixSum[i+1] = prefixSum[i-1+1] + 2;\\n            else\\n                prefixSum[i+1] = (mod + prefixSum[i-1+1] + 1 + prefixSum[i-1+1] - prefixSum[ nextVisit[i]-1+1 ] + 1)%mod;\\n        }\\n        return (int) prefixSum[len-1];\\n    }\\n```\n```\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        final long mod = 1000000007L;\\n        int len = nextVisit.length;\\n        long[] prefixSum = new long[len+1];\\n\\n        for(int i=0;i<len;i++)\\n                prefixSum[i+1] = (mod + prefixSum[i-1+1] + 1 + prefixSum[i-1+1] - prefixSum[ nextVisit[i]-1+1 ] + 1)%mod;\\n        \\n        return (int) prefixSum[len-1];\\n    }\\n```\n```\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        final long mod = 1000000007L;\\n        int len = nextVisit.length;\\n        long[] prefixSum = new long[len+1];\\n\\n        for(int i=0;i<len;i++)\\n                prefixSum[i+1] = (mod + prefixSum[i]*2 - prefixSum[ nextVisit[i] ] + 2)%mod;\\n        \\n        return (int) prefixSum[len-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1504189,
                "title": "c-dp-beats-99-95-python-too-slow-weird",
                "content": "Go back to index equal to nextVisit[i] if nextVisit[i]!=i as time is linear and it takes 2 steps to go forward and make even entries if nextVisit[i]=i . \\nC++ -->\\n\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nV) {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);\\n        int n=nV.size();\\n        int mod=1e9+7;\\n        vector<long int> dp(n);\\n        for (int i=1;i<n;i++){\\n            dp[i]=(2*dp[i-1]-dp[nV[i-1]]+2+mod)%mod;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n\\nPython -->\\n\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nV: List[int]) -> int:\\n        n=len(nV)\\n        mod=10**9+7\\n        dp=[0]*n\\n        for i in range(1,n):\\n            dp[i]=2*dp[i-1]-dp[nV[i-1]]+2\\n        return dp[-1]%mod\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nV) {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);\\n        int n=nV.size();\\n        int mod=1e9+7;\\n        vector<long int> dp(n);\\n        for (int i=1;i<n;i++){\\n            dp[i]=(2*dp[i-1]-dp[nV[i-1]]+2+mod)%mod;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nV: List[int]) -> int:\\n        n=len(nV)\\n        mod=10**9+7\\n        dp=[0]*n\\n        for i in range(1,n):\\n            dp[i]=2*dp[i-1]-dp[nV[i-1]]+2\\n        return dp[-1]%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494752,
                "title": "o-n-c",
                "content": "Main Thing is that, from some index we can go to higher index only when the current index is visited even number of times\\nAnother important thing: If we arrive at any index all indexes before it will definintely be traversed even number of times\\nLast Thing: Use Prefix array and Don\\'t forget to add Mod after prefix[i+1] - prefix[j]\\n```\\nint Mod = 1000000007;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n     \\n        int n = nextVisit.size();\\n        vector<int> prefix(n+1, 0);\\n        int j;\\n        for(int i=0; i<n; i++)\\n        {\\n            j = nextVisit[i];\\n            if(j==i)\\n            {\\n                prefix[i+1]=((prefix[i])%Mod + 2)%Mod;\\n            }\\n            else\\n            {\\n                int k = ((prefix[i] - prefix[j] + Mod)%Mod + 2)%Mod;\\n                prefix[i+1] = ((prefix[i])%Mod + (k)%Mod)%Mod;\\n            }\\n        }\\n        int ans = prefix[n-1]%Mod;\\n        cout<<prefix[n-1];\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Main Thing is that, from some index we can go to higher index only when the current index is visited even number of times\\nAnother important thing: If we arrive at any index all indexes before it will definintely be traversed even number of times\\nLast Thing: Use Prefix array and Don\\'t forget to add Mod after prefix[i+1] - prefix[j]\\n```\\nint Mod = 1000000007;\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n     \\n        int n = nextVisit.size();\\n        vector<int> prefix(n+1, 0);\\n        int j;\\n        for(int i=0; i<n; i++)\\n        {\\n            j = nextVisit[i];\\n            if(j==i)\\n            {\\n                prefix[i+1]=((prefix[i])%Mod + 2)%Mod;\\n            }\\n            else\\n            {\\n                int k = ((prefix[i] - prefix[j] + Mod)%Mod + 2)%Mod;\\n                prefix[i+1] = ((prefix[i])%Mod + (k)%Mod)%Mod;\\n            }\\n        }\\n        int ans = prefix[n-1]%Mod;\\n        cout<<prefix[n-1];\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1466750,
                "title": "python-simple-dp-detailed-explanation",
                "content": "**Intuiton:** The key to understanding this problem is within the contstraints, each index\\'s value can only be equal to the index itself or less. If it is equal to itself, well we know it will always take 2 days. If it is less than itself, well then from a DP approach we will already have data on the day.\\n**Solution:** We can think about each index (or day) as how many days it takes to move past it, since days are 0 indexed. The answer will always be the DP value at the 2nd to last day. Since, you can only increment by going forward, we know the minimum stay is 2 days. So at mimum our DP at each index is the previous DP+2. Then if our current value is not equal to its index, we increment our DP by (the previous day DP) minus (the DP of our current value). We do this because that\\'s how long it will take for each to get back to the current point.\\n\\nThis problem is pretty tricky, I think it should be a hard! Hope this helps someone better understand it!\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        dp = {}\\n        dp[-1] = 0\\n        dp[0] = 2\\n        for ind, n in enumerate(nextVisit[1:], 1):\\n            dp[ind] = dp[ind-1]+2\\n            if ind != n:\\n                dp[ind] = (dp[ind]+dp[ind-1]-dp[n-1])%MOD\\n        return dp[len(nextVisit)-2]\\n```\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        dp = {}\\n        dp[-1] = 0\\n        dp[0] = 2\\n        for ind, n in enumerate(nextVisit[1:], 1):\\n            dp[ind] = dp[ind-1]+2\\n            if ind != n:\\n                dp[ind] = (dp[ind]+dp[ind-1]-dp[n-1])%MOD\\n        return dp[len(nextVisit)-2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458963,
                "title": "easy-dp-c",
                "content": "class Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& arr) {\\n        \\n        int mod = 1e9+7;\\n        int n = arr.size();\\n        vector<int> dp(n );\\n        \\n        // the only way to visit room i is through i - 1\\n        \\n        for(int i = 1; i<n; i++)\\n        {\\n            dp[i] = ( 2*dp[i-1] - dp[arr[i-1]] + 2 + mod)%mod;\\n        \\n        }\\n        \\n        return dp[n-1];\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& arr) {\\n        \\n        int mod = 1e9+7;\\n        int n = arr.size();\\n        vector<int> dp(n );\\n        \\n        // the only way to visit room i is through i - 1\\n        \\n        for(int i = 1; i<n; i++)\\n        {\\n            dp[i] = ( 2*dp[i-1] - dp[arr[i-1]] + 2 + mod)%mod;\\n        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1456921,
                "title": "python-simple-dp-time-o-n-space-o-n-first-day-where-you-have-been-in-all-the-rooms",
                "content": "# Approach\\n## Important observations\\n* We can reach ith room only from (i-1)th room\\n* Patterns repeat. Hence use DP (Observe the image below)\\n![explanation](https://assets.leetcode.com/users/images/b254581a-adf6-4373-a794-96b399ce1947_1631258725.6442018.png)\\n## Explanation\\n* We can only move to the (i+1)th room if we visit ith room even number of times\\n* So dp[i] = number of days we need to reach (i-1)th and + 1 to move to ith room\\n* But when we reach (i-1)th room for the first time it is ODD so we need to go to next[i-1], from which we need to get to (i-1)th room again\\n* So dp[i]= dp[i-1] + (dp[i-1]-dp[next[i-1]]+1 )+1\\n# Code\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nxt: List[int]) -> int:\\n        N=len(nxt)\\n        dp=[0 for _ in range(N)]\\n        mod=10**9+7\\n        for i in range(1,N):\\n            dp[i]=(dp[i-1]+(dp[i-1]-dp[nxt[i-1]]+1)+1)%mod\\n        return dp[-1]\\n```\\n# Complexity\\n# Time\\n**O(N)**\\n# Space\\n**O(N)**\\n\\nAuthor : [Kiran Puli](https://kiranpuli.github.io/Portfolio/)\\nCredits (for image) : [votrubac](https://leetcode.com/votrubac)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nxt: List[int]) -> int:\\n        N=len(nxt)\\n        dp=[0 for _ in range(N)]\\n        mod=10**9+7\\n        for i in range(1,N):\\n            dp[i]=(dp[i-1]+(dp[i-1]-dp[nxt[i-1]]+1)+1)%mod\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456823,
                "title": "i-spent-several-hours-on-acing-this-question-in-scala",
                "content": "```scala\\n  def firstDayBeenInAllRooms(nvs: Array[Int]): Int = {\\n\\n    val len = nvs.length\\n    import scala.collection.mutable.HashMap\\n    val tab = new HashMap[Int, Long]\\n    val mod = 1000000007L\\n   \\n    def f(idx: Int): Long = {\\n  \\n\\n      if (idx == 0) return 0L\\n      if (tab.contains(idx)) return tab(idx)\\n      if (nvs(idx - 1) == idx - 1) {\\n        tab.put(idx,  f(idx - 1) + 2)\\n      } else {\\n        tab.put(idx, ((f(idx - 1) + f(idx - 1)) + 2L - f(nvs(idx - 1)) + mod) % mod)\\n      }\\n\\n      tab(idx)\\n    }\\n\\n    (f(len - 1) % mod).toInt\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def firstDayBeenInAllRooms(nvs: Array[Int]): Int = {\\n\\n    val len = nvs.length\\n    import scala.collection.mutable.HashMap\\n    val tab = new HashMap[Int, Long]\\n    val mod = 1000000007L\\n   \\n    def f(idx: Int): Long = {\\n  \\n\\n      if (idx == 0) return 0L\\n      if (tab.contains(idx)) return tab(idx)\\n      if (nvs(idx - 1) == idx - 1) {\\n        tab.put(idx,  f(idx - 1) + 2)\\n      } else {\\n        tab.put(idx, ((f(idx - 1) + f(idx - 1)) + 2L - f(nvs(idx - 1)) + mod) % mod)\\n      }\\n\\n      tab(idx)\\n    }\\n\\n    (f(len - 1) % mod).toInt\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1452829,
                "title": "python-dp",
                "content": "dp[i][0] the first day to arrive at room i with even times.\\ndp[i][1] the first day to arrive at room i with odd times.\\nThe idea of dp transition is following:\\n1. **dp[i][1] = dp[i-1][0]+1**, to arrive at room i, we must have visited room i-1 even times.\\n2. To calculate **dp[i][0]**,  first of all we should arrive at state **dp[i][1]**, then we move to room nextVisit[i], then go back to room i eventually. And it needs **dp[i][1]- dp[nextVisit[i]][1]** days. \\n3. **dp[i][0] = dp[i][1] + dp[i][1]- dp[nextVisit[i]] +1**, \\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n = len(nextVisit)\\n        dp = [[0 for i in range(2)] for i in range(n)]\\n        dp[0][1] = 0\\n        dp[0][0] = 1\\n        \\n        for i in range(1,n):\\n            dp[i][1] = dp[i-1][0]+1\\n            if nextVisit[i]==i:\\n                dp[i][0] = (dp[i][1]+1)%(10**9+7)\\n            else:\\n                dp[i][0] = (dp[i][1] + dp[i][1] - dp[nextVisit[i]][1] + 1)%(10**9+7)\\n        \\n        return dp[n-1][1]%(10**9+7)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n = len(nextVisit)\\n        dp = [[0 for i in range(2)] for i in range(n)]\\n        dp[0][1] = 0\\n        dp[0][0] = 1\\n        \\n        for i in range(1,n):\\n            dp[i][1] = dp[i-1][0]+1\\n            if nextVisit[i]==i:\\n                dp[i][0] = (dp[i][1]+1)%(10**9+7)\\n            else:\\n                dp[i][0] = (dp[i][1] + dp[i][1] - dp[nextVisit[i]][1] + 1)%(10**9+7)\\n        \\n        return dp[n-1][1]%(10**9+7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451907,
                "title": "c-easy-o-n-solution",
                "content": "I have maintained 2 arrays one is of parity `p` in order to get the current parity of the particular room as odd or even and one is `f` which is required to store the first day the particular element is visited once u jump onto a certain day i ` 0 <= i <= nextday[i]` the total number of days required to get back to the current room will be ` f[i] - f[a[i]] +1 ` . hence this value can be added to the `cur ` variable which stores the  current day which a particular room is visited . The implementation is given below -\\n\\n\\n```\\nusing ll = long long int;\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int firstDayBeenInAllRooms( vector<int>& a ) \\n    {\\n        ll n = a.size();\\n        vector < ll > p(n) , f(n);\\n        ll cur = 1;\\n        ll i = 0 ;\\n        while( i < n-1 ) \\n        {\\n\\t\\t\\tif( p[i] == 0 and f[i] == 0 )    //visiting a particualr room odd/first time \\n            {\\n                f[i] = cur;\\n                p[i] = 1;\\n            }\\n            else if ( p[i] == 0 and f[i] != 0 )  // visiting a particular room even/second time \\n            {\\n                i++;\\n                cur++;\\n            }\\n            else if( p[i] == 1 ) // jumping onto nextday[i] and calculating the required moves to reach this room again \\n            {\\n                cur += (f[i] - f[ a[i] ]+1) % mod;\\n                p[i] = 0;\\n            }\\n            cur %= mod;\\n        }\\n        return (cur - 1 + mod )% mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll = long long int;\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int firstDayBeenInAllRooms( vector<int>& a ) \\n    {\\n        ll n = a.size();\\n        vector < ll > p(n) , f(n);\\n        ll cur = 1;\\n        ll i = 0 ;\\n        while( i < n-1 ) \\n        {\\n\\t\\t\\tif( p[i] == 0 and f[i] == 0 )    //visiting a particualr room odd/first time \\n            {\\n                f[i] = cur;\\n                p[i] = 1;\\n            }\\n            else if ( p[i] == 0 and f[i] != 0 )  // visiting a particular room even/second time \\n            {\\n                i++;\\n                cur++;\\n            }\\n            else if( p[i] == 1 ) // jumping onto nextday[i] and calculating the required moves to reach this room again \\n            {\\n                cur += (f[i] - f[ a[i] ]+1) % mod;\\n                p[i] = 0;\\n            }\\n            cur %= mod;\\n        }\\n        return (cur - 1 + mod )% mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448271,
                "title": "c-easy-solution-100-beat-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        vector<long long>dp(nextVisit.size()-1);\\n        dp[0]=2;\\n        long long cv = 1e9+7;\\n        for(int i=1;i<nextVisit.size()-1;i++)\\n        {\\n            if(nextVisit[i]==i)\\n            {\\n                dp[i]=(dp[i-1]+2);\\n            }\\n            else\\n            {\\n                if(nextVisit[i]==0)\\n                {\\n                    dp[i]=(dp[i-1]+2)%cv;\\n                    dp[i]+=(dp[i-1]);\\n                }\\n                else\\n                {\\n                    dp[i]= (dp[i-1] - dp[nextVisit[i]-1] +2 +cv)% cv;\\n                    dp[i]+=(dp[i-1]);\\n                }\\n            }\\n        }\\n        return dp[dp.size()-1]%cv;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        vector<long long>dp(nextVisit.size()-1);\\n        dp[0]=2;\\n        long long cv = 1e9+7;\\n        for(int i=1;i<nextVisit.size()-1;i++)\\n        {\\n            if(nextVisit[i]==i)\\n            {\\n                dp[i]=(dp[i-1]+2);\\n            }\\n            else\\n            {\\n                if(nextVisit[i]==0)\\n                {\\n                    dp[i]=(dp[i-1]+2)%cv;\\n                    dp[i]+=(dp[i-1]);\\n                }\\n                else\\n                {\\n                    dp[i]= (dp[i-1] - dp[nextVisit[i]-1] +2 +cv)% cv;\\n                    dp[i]+=(dp[i-1]);\\n                }\\n            }\\n        }\\n        return dp[dp.size()-1]%cv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446693,
                "title": "c-1997-first-day-where-you-have-been-in-all-the-rooms",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        const int MOD = 1\\'000\\'000\\'007; \\n        int n = nextVisit.size(); \\n        vector<long> odd(n), even(n); \\n        even[0] = 1; \\n        for (int i = 1; i < n; ++i) {\\n            odd[i] = (even[i-1] + 1) % MOD; \\n            even[i] = (2*odd[i] - odd[nextVisit[i]] + 1 + MOD) % MOD; \\n        }\\n        return odd.back(); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        const int MOD = 1\\'000\\'000\\'007; \\n        int n = nextVisit.size(); \\n        vector<long> odd(n), even(n); \\n        even[0] = 1; \\n        for (int i = 1; i < n; ++i) {\\n            odd[i] = (even[i-1] + 1) % MOD; \\n            even[i] = (2*odd[i] - odd[nextVisit[i]] + 1 + MOD) % MOD; \\n        }\\n        return odd.back(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446666,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int mod = 1e9 + 7;\\n        int n = nextVisit.size();\\n        // ot[i] = time stamp when we reach \\'i\\' for the first time\\n        // ot[i] = et[i-1]+1\\n        // et[i] = time stamp when we reach \\'i\\' for the second time\\n        // et[i] = ot[i] + 1 if nextvisit[i]==i\\n        // else ot[i] + 1 + (et[i-1] - ot[k]) + 1, where k = nextvisit[i]\\n        vector<long> et(n);\\n        vector<long> ot(n);\\n        ot[0] = 0;\\n        et[0] = 1;\\n        for (int i=1; i<n; i++) {\\n            ot[i] = et[i-1] + 1;\\n            if (nextVisit[i]==i) {\\n                et[i] = (ot[i]+1 + mod) % mod;\\n            } else {\\n                et[i] = (ot[i] + et[i-1] + 2 - ot[nextVisit[i]] + mod) % mod;\\n            }\\n        }\\n        return ot[n-1] % mod;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        int mod = 1e9 + 7;\\n        int n = nextVisit.size();\\n        // ot[i] = time stamp when we reach \\'i\\' for the first time\\n        // ot[i] = et[i-1]+1\\n        // et[i] = time stamp when we reach \\'i\\' for the second time\\n        // et[i] = ot[i] + 1 if nextvisit[i]==i\\n        // else ot[i] + 1 + (et[i-1] - ot[k]) + 1, where k = nextvisit[i]\\n        vector<long> et(n);\\n        vector<long> ot(n);\\n        ot[0] = 0;\\n        et[0] = 1;\\n        for (int i=1; i<n; i++) {\\n            ot[i] = et[i-1] + 1;\\n            if (nextVisit[i]==i) {\\n                et[i] = (ot[i]+1 + mod) % mod;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1446046,
                "title": "dp-explained-with-comments-java",
                "content": "\\n```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        int n = nextVisit.length;\\n        long[] dp = new long[n];\\n        int mod = 1000000007;\\n        dp[0] = 2;\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            if(i == n - 1){\\n                break;\\n            }\\n            \\n            //days needed to reach i from 0 index\\n            long days = dp[i - 1];\\n            \\n            //days needed to reach i from nextVisit[i]\\n            //prefix sum technique just subtracting dp[nextVisit[i] - 1]\\n            if(nextVisit[i] - 1 >= 0){\\n                days = (days - dp[nextVisit[i] - 1] + mod) % mod;\\n            }\\n            \\n            //updating dp table\\n            dp[i] = (dp[i - 1] + days + 2) % mod;\\n        }\\n        \\n        return (int)dp[n - 2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        int n = nextVisit.length;\\n        long[] dp = new long[n];\\n        int mod = 1000000007;\\n        dp[0] = 2;\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            if(i == n - 1){\\n                break;\\n            }\\n            \\n            //days needed to reach i from 0 index\\n            long days = dp[i - 1];\\n            \\n            //days needed to reach i from nextVisit[i]\\n            //prefix sum technique just subtracting dp[nextVisit[i] - 1]\\n            if(nextVisit[i] - 1 >= 0){\\n                days = (days - dp[nextVisit[i] - 1] + mod) % mod;\\n            }\\n            \\n            //updating dp table\\n            dp[i] = (dp[i - 1] + days + 2) % mod;\\n        }\\n        \\n        return (int)dp[n - 2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445790,
                "title": "discussion-solution-for-a-harder-version",
                "content": "I was just wondering if there\\'s any efficient way to solve a harder version of this problem, or if it can be shown it\\'s not solvable in all scenarios.\\n\\nFor this version, we change the constraint from `0 <= nextVisit[i] <= i` to `0 <= nextVisit[i] <= n-1`, i.e., you can go to any room, not just a room you\\'ve visited earlier, due to the nextVisit array. The other rules stay the same - if we\\'ve visited a room `i` even number of times, we go to room `i+1` else we go to `nextVisit[i]` and we need to find the first day we have visited all rooms.\\n\\nI\\'ve not been able to come up with any example where it\\'s not possible to visit all the rooms, but the problem becomes really hard it seems.",
                "solutionTags": [],
                "code": "I was just wondering if there\\'s any efficient way to solve a harder version of this problem, or if it can be shown it\\'s not solvable in all scenarios.\\n\\nFor this version, we change the constraint from `0 <= nextVisit[i] <= i` to `0 <= nextVisit[i] <= n-1`, i.e., you can go to any room, not just a room you\\'ve visited earlier, due to the nextVisit array. The other rules stay the same - if we\\'ve visited a room `i` even number of times, we go to room `i+1` else we go to `nextVisit[i]` and we need to find the first day we have visited all rooms.\\n\\nI\\'ve not been able to come up with any example where it\\'s not possible to visit all the rooms, but the problem becomes really hard it seems.",
                "codeTag": "Unknown"
            },
            {
                "id": 1445456,
                "title": "python-brute-force-and-optimized",
                "content": "**Brute Force**\\nHaving a set to check until we reach all nodes and use the definitions given in question. Takes O(days) time and O(n) space. Gives TLE bcoz days can be huge.\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        mod = 1000000007\\n        n = len(nextVisit)\\n        times = [0]*n\\n        s = set()\\n        day = 0\\n        room = 0\\n        \\n        while len(s) < n:\\n            s.add(room)\\n            day += 1\\n            times[room] += 1\\n            if times[room] % 2 == 1:\\n                room = nextVisit[room]\\n            else:\\n                room = (room+1)%n\\n            \\n        return (day-1)%mod\\n```\\n\\n**Better approach**\\nInstead of traversing each day precompute the days for reaching from i th room to next room and from next room to i th room since we can move to next room only when its even number of visits.\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n, mod = len(nextVisit), 1000000007\\n        dp = [0]*n\\n        for i in range(1, n):\\n            dp[i] = (2*dp[i-1] - dp[nextVisit[i-1]] + 2) % mod\\n\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        mod = 1000000007\\n        n = len(nextVisit)\\n        times = [0]*n\\n        s = set()\\n        day = 0\\n        room = 0\\n        \\n        while len(s) < n:\\n            s.add(room)\\n            day += 1\\n            times[room] += 1\\n            if times[room] % 2 == 1:\\n                room = nextVisit[room]\\n            else:\\n                room = (room+1)%n\\n            \\n        return (day-1)%mod\\n```\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        n, mod = len(nextVisit), 1000000007\\n        dp = [0]*n\\n        for i in range(1, n):\\n            dp[i] = (2*dp[i-1] - dp[nextVisit[i-1]] + 2) % mod\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445427,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func firstDayBeenInAllRooms(_ nextVisit: [Int]) -> Int {\\n        let n = nextVisit.count, div = 1_000_000_007\\n        var firstDays = [Int](repeating: 0, count: n), returnDays = [Int](repeating: 0, count: n)\\n        for i in 0..<(n - 1) {\\n            let returnDay = (1 + 2 * firstDays[i] - firstDays[nextVisit[i]]) % div\\n            returnDays[i] = returnDay >= 0 ? returnDay : returnDay + div\\n            firstDays[i + 1] = 1 + returnDays[i]\\n        }\\n        return firstDays[n - 1] % div\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func firstDayBeenInAllRooms(_ nextVisit: [Int]) -> Int {\\n        let n = nextVisit.count, div = 1_000_000_007\\n        var firstDays = [Int](repeating: 0, count: n), returnDays = [Int](repeating: 0, count: n)\\n        for i in 0..<(n - 1) {\\n            let returnDay = (1 + 2 * firstDays[i] - firstDays[nextVisit[i]]) % div\\n            returnDays[i] = returnDay >= 0 ? returnDay : returnDay + div\\n            firstDays[i + 1] = 1 + returnDays[i]\\n        }\\n        return firstDays[n - 1] % div\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445257,
                "title": "python-dp-o-n-solution",
                "content": "\\n```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        \\n        res = 0\\n        n = len(nextVisit)\\n        # dp[i] = number of days took to go to i\\n        dp = [None for _ in range(n)]\\n        dp[0] = 0\\n        for i in range(n-1):\\n            # want to go from i to i+1\\n            if i == nextVisit[i]:\\n                # stays\\n                dp[i+1] = dp[i] + 2\\n            else:\\n                # goes back to j\\n                j = nextVisit[i]\\n\\t\\t\\t\\t# one step for going back to j\\n\\t\\t\\t\\t# dp[i]-dp[j] steps for going from i to j again\\n\\t\\t\\t\\t# one step for moving from i to i + 1\\n                dp[i+1] = dp[i] + 2 + dp[i] - dp[j]\\n        \\n        return dp[-1] % (1000000000 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        \\n        res = 0\\n        n = len(nextVisit)\\n        # dp[i] = number of days took to go to i\\n        dp = [None for _ in range(n)]\\n        dp[0] = 0\\n        for i in range(n-1):\\n            # want to go from i to i+1\\n            if i == nextVisit[i]:\\n                # stays\\n                dp[i+1] = dp[i] + 2\\n            else:\\n                # goes back to j\\n                j = nextVisit[i]\\n\\t\\t\\t\\t# one step for going back to j\\n\\t\\t\\t\\t# dp[i]-dp[j] steps for going from i to j again\\n\\t\\t\\t\\t# one step for moving from i to i + 1\\n                dp[i+1] = dp[i] + 2 + dp[i] - dp[j]\\n        \\n        return dp[-1] % (1000000000 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445191,
                "title": "c-o-n-prefix-sum",
                "content": "\\n`t` is time of days before you can move to next room\\n```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nV) {\\n        int mod = 1e9 + 7, n = nV.size();\\n        vector<long> psum(n);\\n        for (int i = 0; i < n - 1; i++) {\\n            long t = 2 + (psum[i] + mod - psum[nV[i]]) % mod;\\n            psum[i + 1] = (t + psum[i]) % mod;\\n        }\\n        return psum.back();\\n    }\\n};\\n```\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nV) {\\n        int mod = 1e9 + 7, n = nV.size();\\n        vector<long> psum(n);\\n        for (int i = 0; i < n - 1; i++) {\\n            long t = 2 + (psum[i] + mod - psum[nV[i]]) % mod;\\n            psum[i + 1] = (t + psum[i]) % mod;\\n        }\\n        return psum.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445172,
                "title": "python-simple-solution-dp-o-n",
                "content": "```python\\nclass Solution(object):\\n    def firstDayBeenInAllRooms(self, nextVisit):\\n        arr = [0] * len(nextVisit)\\n        days = 0\\n        for i in range(len(nextVisit)-1):\\n            arr[i] = days\\n            days += arr[i] - arr[nextVisit[i]] + 2\\n        return days % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def firstDayBeenInAllRooms(self, nextVisit):\\n        arr = [0] * len(nextVisit)\\n        days = 0\\n        for i in range(len(nextVisit)-1):\\n            arr[i] = days\\n            days += arr[i] - arr[nextVisit[i]] + 2\\n        return days % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642738,
                "title": "golang-c-dp-100-solution",
                "content": "```go\\nfunc firstDayBeenInAllRooms(nextVisit []int) int {\\n\\t// reached i+1, reach all elem from 0 to i even times\\n\\tdp := make([]int, len(nextVisit))\\n\\tdp[1] = 2\\n\\tday := 2\\n\\tfor i := 2; i < len(nextVisit); i++ {\\n\\t\\t// we are in room[i-1] and one day passed\\n\\t\\tday++\\n\\t\\tcurRoom := nextVisit[i-1]\\n\\t\\t// back to room[i-1], cost dp[i-1] - dp[curRoom] day, next day, we will arrival root[i] first time\\n\\t\\t// dp[i] may be less than dp[j] while j < i, so we add another 1000000007\\n\\t\\tday = (day + dp[i-1] - dp[curRoom] + 1 + 1000000007) % 1000000007\\n\\t\\tdp[i] = day\\n\\t}\\n\\treturn dp[len(nextVisit)-1]\\n}\\n```\\n\\n```c++\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        vector<long> dp(nextVisit.size());\\n        dp[1] = 2;\\n        for (int i = 2; i < nextVisit.size(); i++) {\\n            dp[i] = (dp[i-1] + dp[i-1] - dp[nextVisit[i-1]] + 1000000009) % 1000000007;\\n        }\\n        return static_cast<int>(dp[dp.size()-1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc firstDayBeenInAllRooms(nextVisit []int) int {\\n\\t// reached i+1, reach all elem from 0 to i even times\\n\\tdp := make([]int, len(nextVisit))\\n\\tdp[1] = 2\\n\\tday := 2\\n\\tfor i := 2; i < len(nextVisit); i++ {\\n\\t\\t// we are in room[i-1] and one day passed\\n\\t\\tday++\\n\\t\\tcurRoom := nextVisit[i-1]\\n\\t\\t// back to room[i-1], cost dp[i-1] - dp[curRoom] day, next day, we will arrival root[i] first time\\n\\t\\t// dp[i] may be less than dp[j] while j < i, so we add another 1000000007\\n\\t\\tday = (day + dp[i-1] - dp[curRoom] + 1 + 1000000007) % 1000000007\\n\\t\\tdp[i] = day\\n\\t}\\n\\treturn dp[len(nextVisit)-1]\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\\n        vector<long> dp(nextVisit.size());\\n        dp[1] = 2;\\n        for (int i = 2; i < nextVisit.size(); i++) {\\n            dp[i] = (dp[i-1] + dp[i-1] - dp[nextVisit[i-1]] + 1000000009) % 1000000007;\\n        }\\n        return static_cast<int>(dp[dp.size()-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2012723,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This is harder than many hard level problems I solved."
                    },
                    {
                        "username": "Ashh_87",
                        "content": "never thought it could be a dp , was getting tle"
                    }
                ]
            },
            {
                "id": 1976468,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This is harder than many hard level problems I solved."
                    },
                    {
                        "username": "Ashh_87",
                        "content": "never thought it could be a dp , was getting tle"
                    }
                ]
            }
        ]
    }
]