[
    {
        "title": "Most Profit Assigning Work",
        "question_content": "You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\n\n\tdifficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\n\tworker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).\n\nEvery worker can be assigned at most one job, but one job can be completed multiple times.\n\n\tFor example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\n&nbsp;\nExample 1:\n\nInput: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100\nExplanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.\n\nExample 2:\n\nInput: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\tn == difficulty.length\n\tn == profit.length\n\tm == worker.length\n\t1 <= n, m <= 104\n\t1 <= difficulty[i], profit[i], worker[i] <= 105",
        "solutions": [
            {
                "id": 127031,
                "title": "c-java-python-sort-and-two-pointer",
                "content": "# Solution 1\\n1. zip `difficulty` and `profit` as jobs.\\n2. sort `jobs` and sort \\'worker\\'.\\n3. Use 2 pointers. For each worker, find his maximum profit `best` he can make under his ability.\\n<br>\\n\\nBecause we have sorted `jobs` and `worker`,\\nwe will go through two lists only once.\\nthis will be only `O(D + W)`.\\n`O(DlogD + WlogW)`, as we sort jobs.\\n<br>\\n\\n**C++**\\n```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> jobs;\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.push_back(make_pair(difficulty[j], profit[j]));\\n        sort(jobs.begin(), jobs.end());\\n        sort(worker.begin(), worker.end());\\n        for (int & ability : worker) {\\n            while (i < N && ability >= jobs[i].first)\\n                best = max(jobs[i++].second, best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair<Integer, Integer>> jobs = new ArrayList<>();\\n        int N = profit.length, res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.add(new Pair<Integer, Integer>(difficulty[j], profit[j]));\\n        Collections.sort(jobs, Comparator.comparing(Pair::getKey));\\n        Arrays.sort(worker);\\n        for (int ability : worker) {\\n            while (i < N && ability >= jobs.get(i).getKey())\\n                best = Math.max(jobs.get(i++).getValue(), best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        jobs = sorted(zip(difficulty, profit))\\n        res = i = best = 0\\n        for ability in sorted(worker):\\n            while i < len(jobs) and ability >= jobs[i][0]:\\n                best = max(jobs[i][1], best)\\n                i += 1\\n            res += best\\n        return res\\n\\n```\\n<br>\\n\\n# Solution 2\\n1. Use a treemap<difficulty, profit>\\n2. Go through the treemap once, find the max profit `best` for each difficulty.\\nTime `O(DlogD + WlogD)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        map.put(0, 0);\\n        for (int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i], 0)));\\n        }\\n        int best = 0, res = 0;\\n        for (Integer key : map.keySet()) {\\n            best = Math.max(map.get(key), best);\\n            map.put(key, best);\\n        }\\n        for (int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        map<int, int> jobs;\\n        jobs[0] = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs[difficulty[j]] = max(jobs[difficulty[j]], profit[j]);\\n        for (auto &it: jobs)\\n            it.second = best = max(best, it.second);\\n        for (int & ability : worker)\\n            res += (--jobs.upper_bound(ability))->second;\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> jobs;\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.push_back(make_pair(difficulty[j], profit[j]));\\n        sort(jobs.begin(), jobs.end());\\n        sort(worker.begin(), worker.end());\\n        for (int & ability : worker) {\\n            while (i < N && ability >= jobs[i].first)\\n                best = max(jobs[i++].second, best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair<Integer, Integer>> jobs = new ArrayList<>();\\n        int N = profit.length, res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.add(new Pair<Integer, Integer>(difficulty[j], profit[j]));\\n        Collections.sort(jobs, Comparator.comparing(Pair::getKey));\\n        Arrays.sort(worker);\\n        for (int ability : worker) {\\n            while (i < N && ability >= jobs.get(i).getKey())\\n                best = Math.max(jobs.get(i++).getValue(), best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        jobs = sorted(zip(difficulty, profit))\\n        res = i = best = 0\\n        for ability in sorted(worker):\\n            while i < len(jobs) and ability >= jobs[i][0]:\\n                best = max(jobs[i][1], best)\\n                i += 1\\n            res += best\\n        return res\\n\\n```\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        map.put(0, 0);\\n        for (int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i], 0)));\\n        }\\n        int best = 0, res = 0;\\n        for (Integer key : map.keySet()) {\\n            best = Math.max(map.get(key), best);\\n            map.put(key, best);\\n        }\\n        for (int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        map<int, int> jobs;\\n        jobs[0] = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs[difficulty[j]] = max(jobs[difficulty[j]], profit[j]);\\n        for (auto &it: jobs)\\n            it.second = best = max(best, it.second);\\n        for (int & ability : worker)\\n            res += (--jobs.upper_bound(ability))->second;\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 127133,
                "title": "java-solution-with-treemap",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       \\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        // in case two jobs have same difficulty but different profit, we want to count\\n        // the higher profit\\n        for (int i = 0; i < difficulty.length; i++) {\\n            tmap.put(difficulty[i], Math.max(profit[i], tmap.getOrDefault(difficulty[i], 0)));\\n        }\\n\\n        int max = 0, res = 0;\\n        // maximum profit at this difficulty or below in case\\n        // lower difficulty job offers higher profit\\n        for (Integer key : tmap.keySet()) {\\n            max = Math.max(tmap.get(key), max);\\n            tmap.put(key, max);\\n        }\\n        \\n        Map.Entry<Integer, Integer> entry = null;\\n        for (int i = 0; i < worker.length; i++) {\\n            if (tmap.containsKey(worker[i])) {\\n                res += tmap.get(worker[i]);\\n            } else {\\n                entry = tmap.floorEntry(worker[i]);            \\n                if (entry != null) {\\n                    res += entry.getValue();\\n                }\\n            }  \\n        }\\n        return res;  \\n}",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       \\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        // in case two jobs have same difficulty but different profit, we want to count\\n        // the higher profit\\n        for (int i = 0; i < difficulty.length; i++) {\\n            tmap.put(difficulty[i], Math.max(profit[i], tmap.getOrDefault(difficulty[i], 0)));\\n        }\\n\\n        int max = 0, res = 0;\\n        // maximum profit at this difficulty or below in case\\n        // lower difficulty job offers higher profit\\n        for (Integer key : tmap.keySet()) {\\n            max = Math.max(tmap.get(key), max);\\n            tmap.put(key, max);\\n        }\\n        \\n        Map.Entry<Integer, Integer> entry = null;\\n        for (int i = 0; i < worker.length; i++) {\\n            if (tmap.containsKey(worker[i])) {\\n                res += tmap.get(worker[i]);\\n            } else {\\n                entry = tmap.floorEntry(worker[i]);            \\n                if (entry != null) {\\n                    res += entry.getValue();\\n                }\\n            }  \\n        }\\n        return res;  \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 175676,
                "title": "java-memorization-without-sort-beat-99-85",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126964,
                "title": "c-4-lines-sort-bucket-sort-and-bucked-sort-with-two-pointers",
                "content": "This solution sorts levels and assigns the maximum profit among all jobs with equal or lower level:\\n\\n1. Load levels and profits into a sorted map.\\n2. Update the map so that each level has the maximum possible profit. Practically, if the previous level has higher profit, we assign that profit to the current level.\\n3. For each worker, search the map to get the maximum profit for the worker\\'s level.\\n\\nThe complexity is O((n + m) log n), where n and m is the number of jobs and workers respectfully.\\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  map<int, int> m = { { 0, 0 } };\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto it = next(m.begin()); it != m.end(); ++it) it->second = max(it->second, prev(it)->second);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) {return s + prev(m.upper_bound(w))->second;});\\n}\\n```\\nAs a bonus, below is the solution that uses bucket sort. It requires, however, additional memory but the runtime complexity is O(N + m), where N is the number of levels (100,000 in our case). The second solution is only slightly faster in OJ (100 vs. 110 ms), probably because n is signifficantly smaller than N in the test cases.\\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {};\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto i = 1; i < 100001; ++i) m[i] = max(m[i], m[i - 1]);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) { return s + m[w]; });\\n}\\n```\\nI also checked the sort and two-pointer solution by @lee215. That solution requires two sorts, that\\'s why my preference was to sort once and fix profits in the linear time. Anyway, I adopted the two-pointer solution to use the bucket sort. Note that I store the number of workers with a given level in the second array.\\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {}, w[100001] = {}, p = 0, max_p = 0;\\n  for (auto i = 0; i < lv.size(); ++w[worker[i++]]) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  return accumulate(begin(w), end(w), 0, [&](int s, int w) { max_p = max(max_p, m[p++]); return s + max_p * w; });\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  map<int, int> m = { { 0, 0 } };\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto it = next(m.begin()); it != m.end(); ++it) it->second = max(it->second, prev(it)->second);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) {return s + prev(m.upper_bound(w))->second;});\\n}\\n```\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {};\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto i = 1; i < 100001; ++i) m[i] = max(m[i], m[i - 1]);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) { return s + m[w]; });\\n}\\n```\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {}, w[100001] = {}, p = 0, max_p = 0;\\n  for (auto i = 0; i < lv.size(); ++w[worker[i++]]) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  return accumulate(begin(w), end(w), 0, [&](int s, int w) { max_p = max(max_p, m[p++]); return s + max_p * w; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 438559,
                "title": "short-simple-binary-search-java",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = difficulty.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i=0;i<n;i++) {\\n            list.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        list.sort((a,b)->(a[0]-b[0]!=0?a[0]-b[0]:b[1]-a[1]));\\n        int[] max = new int[n];\\n        max[0]=list.get(0)[1];// Maximum Value till a given index.\\n        for (int i=1;i<n;i++) {\\n            max[i]=Math.max(list.get(i)[1],max[i-1]); \\n        }\\n        int ans=0;\\n        for(int w: worker) {\\n            int res = bs(w,list);\\n            ans+=res==-1?0:max[res];\\n        }\\n        return ans;\\n    }\\n\\t// Smallest index which is less than or equal to the given target.\\n    private int bs(int target,List<int[]> list) {\\n        int lo = 0;\\n        int hi = list.size()-1;\\n        if(target>=list.get(hi)[0]) {\\n            return hi;\\n        }\\n        int ans = -1;\\n        while (lo<hi) {\\n            int mid = (lo)+(hi-lo)/2;\\n            int val = list.get(mid)[0];\\n            if(target>=val) {\\n                ans=mid;\\n                lo=mid+1;\\n            } else {\\n                hi=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = difficulty.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i=0;i<n;i++) {\\n            list.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        list.sort((a,b)->(a[0]-b[0]!=0?a[0]-b[0]:b[1]-a[1]));\\n        int[] max = new int[n];\\n        max[0]=list.get(0)[1];// Maximum Value till a given index.\\n        for (int i=1;i<n;i++) {\\n            max[i]=Math.max(list.get(i)[1],max[i-1]); \\n        }\\n        int ans=0;\\n        for(int w: worker) {\\n            int res = bs(w,list);\\n            ans+=res==-1?0:max[res];\\n        }\\n        return ans;\\n    }\\n\\t// Smallest index which is less than or equal to the given target.\\n    private int bs(int target,List<int[]> list) {\\n        int lo = 0;\\n        int hi = list.size()-1;\\n        if(target>=list.get(hi)[0]) {\\n            return hi;\\n        }\\n        int ans = -1;\\n        while (lo<hi) {\\n            int mid = (lo)+(hi-lo)/2;\\n            int val = list.get(mid)[0];\\n            if(target>=val) {\\n                ans=mid;\\n                lo=mid+1;\\n            } else {\\n                hi=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126994,
                "title": "concise-c-solution-using-map-as-a-bst",
                "content": "```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    map<int, int> m{{0,0}};\\n    for (int i = 0; i < difficulty.size(); i++) // create the difficulty-maximum-profit BST\\n        m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n    int mx = 0, res = 0;\\n    for (auto &p : m) // update the BST to reflect the maximum profit for a job\\n        mx = p.second = max(p.second, mx);\\n    for (int w : worker) // look up the BST to find the maximum profit for each worker\\n        res += prev(m.upper_bound(w))->second;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    map<int, int> m{{0,0}};\\n    for (int i = 0; i < difficulty.size(); i++) // create the difficulty-maximum-profit BST\\n        m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n    int mx = 0, res = 0;\\n    for (auto &p : m) // update the BST to reflect the maximum profit for a job\\n        mx = p.second = max(p.second, mx);\\n    for (int w : worker) // look up the BST to find the maximum profit for each worker\\n        res += prev(m.upper_bound(w))->second;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1288704,
                "title": "simple-java-solution",
                "content": "**Approach** : \\n1. bind profit & difficulty array together using a simple 2d-array \\'pair\\'.\\n2.  sort pair array on basis of difficulty column.\\n3.  sort worker array.\\n3.  for each worker, find his maximum profit best he can make under his ability.\\n\\n**Doubt** :\\nWhat is the need to sort worker[ ] ???\\n**Reason** :\\nIf current worker has more capacity than his previous ones, then his minimum bestPay should be equal to, maximum bestPaySoFar of workers with less capacity.\\nIf he\\'s able to do more-tougher-job, but less-tougher-job pays more, then he\\'s automatically entitled to benefits of that less-tougher-job.\\nNow because he has more ability as compared to previous workers, he can explore more tougher-high-paying-jobs.\\n\\nDue to this, we need to traverse pair[ ] only once.\\nthough we have nested for-while loop, but complexity will become o[worker.length] + o[pair.length].\\n\\nOverall time complexity:\\ndue to sorting of both worker & pair : O(PlogP + WlogW).\\n\\n**Java**:\\n```\\npublic int maxProfitAssignment(int[] diff, int[] profit, int[] worker) {`\\n\\n\\tint pair[][] = new int[diff.length][2];\\n\\tfor(int i = 0; i < diff.length; i++){\\n\\t\\tpair[i][0] = diff[i];\\n\\t\\tpair[i][1] = profit[i];\\n\\t}\\n\\t// sorting 2d array on basis of difficulty colmn\\n\\tArrays.sort(pair, new Comparator<int[]>() {\\n\\t\\t@Override\\n\\t\\tpublic int compare(int o1[], int o2[]){\\n\\t\\t\\treturn Integer.valueOf(o1[0]).compareTo(o2[0]);\\n\\t\\t}\\n\\t});\\n\\n\\tint totalProfit = 0;\\n\\n\\t//MAGIC begins HERE\\n\\tArrays.sort(worker);\\n\\tint bestPaySoFar = 0;\\n\\tint i = 0;      // declaring globally creates MAGIC!!\\n\\n\\tfor(int k = 0; k < worker.length; k++){\\n\\t\\tint ability = worker[k];\\n\\n\\t\\twhile(i < pair.length && ability >= pair[i][0]){\\n\\t\\t\\tif(bestPaySoFar < pair[i][1])\\n\\t\\t\\t\\tbestPaySoFar = pair[i][1];\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\ttotalProfit += bestPaySoFar;\\n\\t}\\n\\n\\treturn totalProfit;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic int maxProfitAssignment(int[] diff, int[] profit, int[] worker) {`\\n\\n\\tint pair[][] = new int[diff.length][2];\\n\\tfor(int i = 0; i < diff.length; i++){\\n\\t\\tpair[i][0] = diff[i];\\n\\t\\tpair[i][1] = profit[i];\\n\\t}\\n\\t// sorting 2d array on basis of difficulty colmn\\n\\tArrays.sort(pair, new Comparator<int[]>() {\\n\\t\\t@Override\\n\\t\\tpublic int compare(int o1[], int o2[]){\\n\\t\\t\\treturn Integer.valueOf(o1[0]).compareTo(o2[0]);\\n\\t\\t}\\n\\t});\\n\\n\\tint totalProfit = 0;\\n\\n\\t//MAGIC begins HERE\\n\\tArrays.sort(worker);\\n\\tint bestPaySoFar = 0;\\n\\tint i = 0;      // declaring globally creates MAGIC!!\\n\\n\\tfor(int k = 0; k < worker.length; k++){\\n\\t\\tint ability = worker[k];\\n\\n\\t\\twhile(i < pair.length && ability >= pair[i][0]){\\n\\t\\t\\tif(bestPaySoFar < pair[i][1])\\n\\t\\t\\t\\tbestPaySoFar = pair[i][1];\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\ttotalProfit += bestPaySoFar;\\n\\t}\\n\\n\\treturn totalProfit;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126932,
                "title": "python-sort-based",
                "content": "The idea is to sort the profits and difficulty,  based on difficulty.\\nAlso the profits array can be modified to store the max_profits till that index.\\n\\nAfter that, its just a matter of finding the correct position for each worker in the difficulty array and adding the max_profit from the profit array.\\n\\n```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        max_profit = -math.inf\\n        profit = list(profit)\\n        for i in range(len(profit)):\\n            if max_profit < profit[i]:\\n                max_profit = profit[i]\\n            else:\\n                profit[i] = max_profit\\n        res = 0\\n        for w in worker:\\n            i = bisect_right(difficulty, w)\\n            if i != 0: res += profit[i-1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        max_profit = -math.inf\\n        profit = list(profit)\\n        for i in range(len(profit)):\\n            if max_profit < profit[i]:\\n                max_profit = profit[i]\\n            else:\\n                profit[i] = max_profit\\n        res = 0\\n        for w in worker:\\n            i = bisect_right(difficulty, w)\\n            if i != 0: res += profit[i-1]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 510197,
                "title": "c-very-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> diff_pro(100001,0);\\n        int res=0;\\n        for(int i=0;i<difficulty.size();i++){\\n            diff_pro[difficulty[i]]=max(diff_pro[difficulty[i]],profit[i]);\\n        }\\n        for(int i=1;i<100001;i++){\\n            diff_pro[i]=max(diff_pro[i],diff_pro[i-1]);\\n        }\\n        for(int i=0;i<worker.size();i++){\\n            res+=diff_pro[worker[i]];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> diff_pro(100001,0);\\n        int res=0;\\n        for(int i=0;i<difficulty.size();i++){\\n            diff_pro[difficulty[i]]=max(diff_pro[difficulty[i]],profit[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 126977,
                "title": "java-ac-sort-and-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int d;\\n        int p;\\n        public Pair(int d, int p) {\\n            this.d = d;\\n            this.p = p;\\n        }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair> list = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            list.add(new Pair(difficulty[i], profit[i]));\\n        }\\n\\n        // sort d from small to large and if d is the same, put smaller p in the front\\n        Collections.sort(list, (a, b) -> (a.d == b.d) ? a.p - b.p : a.d - b.d);\\n\\n        for (int i = 1; i < list.size(); i++) {\\n            // assign the max profit from 0 to current location\\n            list.get(i).p = Math.max(list.get(i).p, list.get(i - 1).p);\\n        }\\n\\n        int count = 0;\\n        for (int w : worker) {\\n            count += binarySearch(list, w);\\n        }\\n\\n        return count;\\n    }\\n\\n    // find the last number <= w in list.d, and return that index\\'s profit, if not available return 0.\\n    private int binarySearch(List<Pair> list, int w) {\\n        int start = 0;\\n        int end = list.size() - 1;\\n        while (start + 1 < end) {\\n            int mid = (end - start) / 2 + start;\\n            if (list.get(mid).d <= w) {\\n                start = mid;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n\\n        if (list.get(end).d <= w) {\\n            return list.get(end).p;\\n        }\\n        if (list.get(start).d <= w) {\\n            return list.get(start).p;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int d;\\n        int p;\\n        public Pair(int d, int p) {\\n            this.d = d;\\n            this.p = p;\\n        }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair> list = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            list.add(new Pair(difficulty[i], profit[i]));\\n        }\\n\\n        // sort d from small to large and if d is the same, put smaller p in the front\\n        Collections.sort(list, (a, b) -> (a.d == b.d) ? a.p - b.p : a.d - b.d);\\n\\n        for (int i = 1; i < list.size(); i++) {\\n            // assign the max profit from 0 to current location\\n            list.get(i).p = Math.max(list.get(i).p, list.get(i - 1).p);\\n        }\\n\\n        int count = 0;\\n        for (int w : worker) {\\n            count += binarySearch(list, w);\\n        }\\n\\n        return count;\\n    }\\n\\n    // find the last number <= w in list.d, and return that index\\'s profit, if not available return 0.\\n    private int binarySearch(List<Pair> list, int w) {\\n        int start = 0;\\n        int end = list.size() - 1;\\n        while (start + 1 < end) {\\n            int mid = (end - start) / 2 + start;\\n            if (list.get(mid).d <= w) {\\n                start = mid;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n\\n        if (list.get(end).d <= w) {\\n            return list.get(end).p;\\n        }\\n        if (list.get(start).d <= w) {\\n            return list.get(start).p;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861065,
                "title": "c-sorting-solution-o-wlogw-dlogd-dp-solution-o-w-d",
                "content": "**Sorting Solution: O(WLogW + DLogD)**\\n\\nRuntime: 172 ms, faster than 83.27% of C++ online submissions for Most Profit Assigning Work.\\nMemory Usage: 38 MB, less than 47.43% of C++ online submissions for Most Profit Assigning Work.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        // Make difficult and profit pair vector jobs\\n        vector<pair<int,int>>jobs;\\n        \\n        int d_size = difficulty.size();\\n        for(int i=0;i<d_size;i++)\\n            jobs.push_back(make_pair(difficulty[i],profit[i]));\\n        \\n        // sort jobs difficulty => O ( DLogD )\\n        sort(jobs.begin(),jobs.end());\\n        \\n        // sort workers array difficulty => O ( WLogW ) \\n        sort(worker.begin(),worker.end());\\n        \\n        int w_size = worker.size();\\n        int maxProfit = 0;\\n        int cprofit = 0;\\n        int cjob = 0;\\n        \\n        // Loop through workers array to find profit for each worker => O ( W + D )\\n        for(int i=0;i<w_size;i++)\\n        {\\n            // find max profit for worker[i] which is cprofit\\n            // As jobs and workers are sorted, cprofit is always max for any difficulty range\\n            while(cjob<d_size && jobs[cjob].first<=worker[i])\\n            {\\n                cprofit = max(cprofit,jobs[cjob].second);\\n                cjob++;\\n            }\\n            \\n            // update total max profit\\n            maxProfit+= cprofit;\\n        }\\n        \\n        return maxProfit;\\n    }\\n};\\n```\\n.\\n.\\n.\\n**DP Solution: O( W + D )**\\n\\nRuntime: 140 ms, faster than 97.43% of C++ online submissions for Most Profit Assigning Work.\\nMemory Usage: 35.7 MB, less than 97.24% of C++ online submissions for Most Profit Assigning Work.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int dp[100001] = {};\\n        int p_size = profit.size();\\n        \\n        for(int i=0;i<p_size;i++)\\n            dp[difficulty[i]] = max(profit[i],dp[difficulty[i]]);\\n        \\n        for(int i=1;i<=100000;i++)\\n            dp[i] = max(dp[i],dp[i-1]);\\n        \\n        int maxProfit = 0;\\n        int w_size = worker.size();\\n        \\n        for(int i=0;i<w_size;i++)\\n            maxProfit+=dp[worker[i]];\\n        \\n        return maxProfit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        // Make difficult and profit pair vector jobs\\n        vector<pair<int,int>>jobs;\\n        \\n        int d_size = difficulty.size();\\n        for(int i=0;i<d_size;i++)\\n            jobs.push_back(make_pair(difficulty[i],profit[i]));\\n        \\n        // sort jobs difficulty => O ( DLogD )\\n        sort(jobs.begin(),jobs.end());\\n        \\n        // sort workers array difficulty => O ( WLogW ) \\n        sort(worker.begin(),worker.end());\\n        \\n        int w_size = worker.size();\\n        int maxProfit = 0;\\n        int cprofit = 0;\\n        int cjob = 0;\\n        \\n        // Loop through workers array to find profit for each worker => O ( W + D )\\n        for(int i=0;i<w_size;i++)\\n        {\\n            // find max profit for worker[i] which is cprofit\\n            // As jobs and workers are sorted, cprofit is always max for any difficulty range\\n            while(cjob<d_size && jobs[cjob].first<=worker[i])\\n            {\\n                cprofit = max(cprofit,jobs[cjob].second);\\n                cjob++;\\n            }\\n            \\n            // update total max profit\\n            maxProfit+= cprofit;\\n        }\\n        \\n        return maxProfit;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int dp[100001] = {};\\n        int p_size = profit.size();\\n        \\n        for(int i=0;i<p_size;i++)\\n            dp[difficulty[i]] = max(profit[i],dp[difficulty[i]]);\\n        \\n        for(int i=1;i<=100000;i++)\\n            dp[i] = max(dp[i],dp[i-1]);\\n        \\n        int maxProfit = 0;\\n        int w_size = worker.size();\\n        \\n        for(int i=0;i<w_size;i++)\\n            maxProfit+=dp[worker[i]];\\n        \\n        return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126955,
                "title": "extremely-simple-using-priority-queue",
                "content": "Sort the class Work in ascending order of difficulty. If difficulty is the same, sort according to descending order of profit. Sort the worker as per ascending order of their ability. \\n\\nNow you just need to match the work with the worker and store the max profit seen until now and add it to the total profit. \\n\\n```\\npublic class Solution {\\n    class Work{\\n        int d; \\n        int p; \\n        Work(int d, int p){\\n            this.d = d; \\n            this.p = p; \\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<Work> pq = new PriorityQueue<Work>((a, b)->(a.d==b.d)?b.p-a.p:a.d-b.d);\\n        for(int i = 0; i < profit.length; ++i){\\n            pq.offer(new Work(difficulty[i], profit[i])); \\n        }\\n        Arrays.sort(worker); \\n        int i = 0; \\n        int cprofit = 0; \\n        int max = 0; \\n        while(!pq.isEmpty() && i < worker.length){\\n            Work w = pq.poll(); \\n            if(w.d <= worker[i]){\\n                max = Math.max(max, w.p); \\n            }else{\\n                i++; \\n                cprofit+=max; \\n                pq.offer(w); \\n            }\\n        }\\n        while(i < worker.length){\\n            cprofit+=max; \\n            i++; \\n        }\\n        return cprofit; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    class Work{\\n        int d; \\n        int p; \\n        Work(int d, int p){\\n            this.d = d; \\n            this.p = p; \\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<Work> pq = new PriorityQueue<Work>((a, b)->(a.d==b.d)?b.p-a.p:a.d-b.d);\\n        for(int i = 0; i < profit.length; ++i){\\n            pq.offer(new Work(difficulty[i], profit[i])); \\n        }\\n        Arrays.sort(worker); \\n        int i = 0; \\n        int cprofit = 0; \\n        int max = 0; \\n        while(!pq.isEmpty() && i < worker.length){\\n            Work w = pq.poll(); \\n            if(w.d <= worker[i]){\\n                max = Math.max(max, w.p); \\n            }else{\\n                i++; \\n                cprofit+=max; \\n                pq.offer(w); \\n            }\\n        }\\n        while(i < worker.length){\\n            cprofit+=max; \\n            i++; \\n        }\\n        return cprofit; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471974,
                "title": "much-intuitive-binary-search-greedy-simple-and-easy-to-understand-c-solution",
                "content": "# Intuition\\nWe Can Sort The Difficulty - Profit Pair And Use Binary Search For Assigning Jobs TO Workers\\n# Approach\\nWhy Sorting Based ON Difficulty but Not on Profit, Because In The Given Problem Workers Difficulty Level  Capability Is Provided Based On these Data We Should Assign The Jobs To Workers.\\nNow After Sorting Difficulty And Profit Pair , we Should Observe ONE Important Point Here\\nConsider The Example\\n Difficulty : [68,35,52,47,86]\\n Profit:[67,17,1,81,3]\\nWorkers :[92,10,85,84,82]\\nIf We Sort Difficulty And Profit Pair We Get \\nDifficulty :[35,47,52,68,86]\\nProfit : [17,81,1,67,3]\\n**Important Observation\\nIf A Worker Can Do A Job At difficulty Level X then he can do all Jobs With difficulty level less than or Equal to X**\\nNow if X=52 , What is The Maximum Profit ,we Can Get it is 81 .\\nAt difficulty level 81 we have maxprofit 81.\\nSo we should Update The Profit Values With Maximum Values From Previous Ones \\nie; \\nat i=1 profit[i]=max(profit[i],profit[i-1])=(81,17)=81\\n    at i=2 profit[i]=max(profit[i],profit[i-1])=(1,81)=81\\n    at i=3 profit[i]=max(profit[i],profit[i-1])=(67,81)=81\\n    at i=4 profit[i]=max(profit[i],profit[i-1])=(3,81)=81\\nThe Profit Array Becomes [17,81,81,81,81]\\nNow We Can Apply Binary Search (Upper Bound) For Every Worker Individually And Assign Jobs Finally Get The Max Profit.\\n\\n**PLEASE UPVOTE IF UNDERSTAND THE SOLUTION**\\n\\n\\n# Complexity\\n- Time complexity:\\nO(NLOGN+MLOGN)\\n- Space complexity:\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>arr;\\n         int n=difficulty.size();\\n     \\n         for(int i=0;i<n;i++)\\n         {\\n             arr.push_back({difficulty[i],profit[i]});\\n         }       \\n           sort(arr.begin(),arr.end());\\n\\n             for(int i=1;i<n;i++) arr[i].second=max(arr[i].second,arr[i-1].second);\\n         long long maxprofit=0;\\n         int low,high,mid,temprofit;\\n         for(auto i:worker)\\n         {\\n             low=0,high=n-1,temprofit=0;\\n             while(low<=high)\\n             {\\n                 mid=(low+high)/2;\\n                 if(arr[mid].first<=i)        low=mid+1;\\n                 else high=mid-1;\\n             }\\n          if(high>=0)   maxprofit=(long long)maxprofit+arr[high].second;\\n         }\\n         return maxprofit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>arr;\\n         int n=difficulty.size();\\n     \\n         for(int i=0;i<n;i++)\\n         {\\n             arr.push_back({difficulty[i],profit[i]});\\n         }       \\n           sort(arr.begin(),arr.end());\\n\\n             for(int i=1;i<n;i++) arr[i].second=max(arr[i].second,arr[i-1].second);\\n         long long maxprofit=0;\\n         int low,high,mid,temprofit;\\n         for(auto i:worker)\\n         {\\n             low=0,high=n-1,temprofit=0;\\n             while(low<=high)\\n             {\\n                 mid=(low+high)/2;\\n                 if(arr[mid].first<=i)        low=mid+1;\\n                 else high=mid-1;\\n             }\\n          if(high>=0)   maxprofit=(long long)maxprofit+arr[high].second;\\n         }\\n         return maxprofit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222137,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++){\\n            v.push_back({d[i],p[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int n=d.size();\\n        vector<int>dp(n+1);\\n        dp[0]=v[0].second;\\n        for(int i=1;i<n;i++){\\n            dp[i]=max(dp[i-1],v[i].second);\\n        }\\n        sort(d.begin(),d.end());\\n        int s=0;\\n        for(int i=0;i<w.size();i++){\\n           int in=upper_bound(d.begin(),d.end(),w[i])-d.begin();\\n           if(in!=0){\\n               in--;\\n               s+=dp[in];\\n           }\\n        }\\n        return s;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/44d7abb5-b520-4d81-b589-567c12aa2091_1677164915.7858884.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++){\\n            v.push_back({d[i],p[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int n=d.size();\\n        vector<int>dp(n+1);\\n        dp[0]=v[0].second;\\n        for(int i=1;i<n;i++){\\n            dp[i]=max(dp[i-1],v[i].second);\\n        }\\n        sort(d.begin(),d.end());\\n        int s=0;\\n        for(int i=0;i<w.size();i++){\\n           int in=upper_bound(d.begin(),d.end(),w[i])-d.begin();\\n           if(in!=0){\\n               in--;\\n               s+=dp[in];\\n           }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603913,
                "title": "python3-solved-using-binary-search-w-sorting-o-n-m-logn-runtime-solution",
                "content": "```\\nclass Solution:\\n    #Time-Complexity: O(n + nlogn + n + mlog(n)) -> O((n+m) *logn)\\n    #Space-Complexity: O(n)\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        #Approach: First of all, linearly traverse each and every corresponding index\\n        #position of first two input arrays: difficulty and profit to group each\\n        #item by 1-d array and put it in separate 2-d array. Then, sort the 2-d array\\n        #by increasing difficulty of the job! Then, for each worker, perform binary\\n        #search and consistently update the max profit the current worker can work and\\n        #earn! Add this value to answer variable, which is cumulative for all workers!\\n        #this will be the result returned at the end!\\n        arr = []\\n        for i in range(len(difficulty)):\\n            arr.append([difficulty[i], profit[i]])\\n        #sort by difficulty!\\n        arr.sort(key = lambda x: x[0])\\n        #then, I need to update the maximum profit up to each and every item!\\n        maximum = float(-inf)\\n        for j in range(len(arr)):\\n            maximum = max(maximum, arr[j][1])\\n            arr[j][1] = maximum\\n        ans = 0\\n        #iterate through each and every worker!\\n        for w in worker:\\n            bestProfit = 0\\n            #define search space to perform binary search!\\n            L, R = 0, len(arr) - 1\\n            #as long as search space has at least one element to consider or one job,\\n            #continue iterations of binary search!\\n            while L <= R:\\n                mid = (L + R) // 2\\n                mid_e = arr[mid]\\n                #check if current job has difficulty that is manageable!\\n                if(mid_e[0] <= w):\\n                    bestProfit = max(bestProfit, mid_e[1])\\n                    #we still need to search right and try higher difficulty\\n                    #jobs that might yield higher profit!\\n                    L = mid + 1\\n                    continue\\n                else:\\n                    R = mid - 1\\n                    continue\\n            #once we break from while loop and end binary search, we should have\\n            #found bestProfit for current worker performing task that is manageable!\\n            ans += bestProfit\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    #Time-Complexity: O(n + nlogn + n + mlog(n)) -> O((n+m) *logn)\\n    #Space-Complexity: O(n)\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        #Approach: First of all, linearly traverse each and every corresponding index\\n        #position of first two input arrays: difficulty and profit to group each\\n        #item by 1-d array and put it in separate 2-d array. Then, sort the 2-d array\\n        #by increasing difficulty of the job! Then, for each worker, perform binary\\n        #search and consistently update the max profit the current worker can work and\\n        #earn! Add this value to answer variable, which is cumulative for all workers!\\n        #this will be the result returned at the end!\\n        arr = []\\n        for i in range(len(difficulty)):\\n            arr.append([difficulty[i], profit[i]])\\n        #sort by difficulty!\\n        arr.sort(key = lambda x: x[0])\\n        #then, I need to update the maximum profit up to each and every item!\\n        maximum = float(-inf)\\n        for j in range(len(arr)):\\n            maximum = max(maximum, arr[j][1])\\n            arr[j][1] = maximum\\n        ans = 0\\n        #iterate through each and every worker!\\n        for w in worker:\\n            bestProfit = 0\\n            #define search space to perform binary search!\\n            L, R = 0, len(arr) - 1\\n            #as long as search space has at least one element to consider or one job,\\n            #continue iterations of binary search!\\n            while L <= R:\\n                mid = (L + R) // 2\\n                mid_e = arr[mid]\\n                #check if current job has difficulty that is manageable!\\n                if(mid_e[0] <= w):\\n                    bestProfit = max(bestProfit, mid_e[1])\\n                    #we still need to search right and try higher difficulty\\n                    #jobs that might yield higher profit!\\n                    L = mid + 1\\n                    continue\\n                else:\\n                    R = mid - 1\\n                    continue\\n            #once we break from while loop and end binary search, we should have\\n            #found bestProfit for current worker performing task that is manageable!\\n            ans += bestProfit\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1228765,
                "title": "easiest-c-soln-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pr, vector<int>& wo) {\\n        int n=dif.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({dif[i],pr[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxpro=v[0].second;\\n        for(int i=1;i<v.size();i++){\\n            maxpro=max(maxpro,v[i].second);\\n            v[i].second=maxpro;\\n        }\\n        int ans=0;\\n        for(auto &w:wo){\\n            int tmp=0;\\n            int i=0,j=n-1;\\n            while(i<=j){\\n                int m=(i+j)>>1;\\n                if(v[m].first<=w){\\n                    tmp=max(tmp,v[m].second);\\n                    i=m+1;\\n                }\\n                else j=m-1;\\n            }\\n            ans+=tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pr, vector<int>& wo) {\\n        int n=dif.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({dif[i],pr[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxpro=v[0].second;\\n        for(int i=1;i<v.size();i++){\\n            maxpro=max(maxpro,v[i].second);\\n            v[i].second=maxpro;\\n        }\\n        int ans=0;\\n        for(auto &w:wo){\\n            int tmp=0;\\n            int i=0,j=n-1;\\n            while(i<=j){\\n                int m=(i+j)>>1;\\n                if(v[m].first<=w){\\n                    tmp=max(tmp,v[m].second);\\n                    i=m+1;\\n                }\\n                else j=m-1;\\n            }\\n            ans+=tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055712,
                "title": "beat-99-71-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        int mp[100001] = {0}, res = 0;\\n        for(int i = 0; i < d.size(); i++)\\n            mp[d[i]] = max(mp[d[i]], p[i]);\\n        for(int i = 1; i < 100001; i++)\\n            mp[i] = max(mp[i], mp[i - 1]);\\n        for(auto n : w)\\n            res += mp[n];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        int mp[100001] = {0}, res = 0;\\n        for(int i = 0; i < d.size(); i++)\\n            mp[d[i]] = max(mp[d[i]], p[i]);\\n        for(int i = 1; i < 100001; i++)\\n            mp[i] = max(mp[i], mp[i - 1]);\\n        for(auto n : w)\\n            res += mp[n];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388263,
                "title": "java-hashmap-two-pointer-sort",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        if (difficulty == null || profit == null || worker == null) {\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        Map<Integer, Integer> dict = new HashMap<>();\\n        for (int i = 0; i < difficulty.length; i++) {\\n            // duplicate difficulty may have different profits\\n            dict.put(difficulty[i], Math.max(dict.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        Arrays.sort(difficulty);\\n        Arrays.sort(worker);\\n        \\n        int j = 0;\\n        int max = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            while (j < difficulty.length && worker[i] >= difficulty[j]) {\\n                max = Math.max(max, dict.get(difficulty[j]));\\n                j++;\\n            }\\n            res += max;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        if (difficulty == null || profit == null || worker == null) {\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        Map<Integer, Integer> dict = new HashMap<>();\\n        for (int i = 0; i < difficulty.length; i++) {\\n            // duplicate difficulty may have different profits\\n            dict.put(difficulty[i], Math.max(dict.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        Arrays.sort(difficulty);\\n        Arrays.sort(worker);\\n        \\n        int j = 0;\\n        int max = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            while (j < difficulty.length && worker[i] >= difficulty[j]) {\\n                max = Math.max(max, dict.get(difficulty[j]));\\n                j++;\\n            }\\n            res += max;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612171,
                "title": "greedy-c-simple-approach",
                "content": "# **if it Helps You, Please Upvote Me......!**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nApproach is simple, just try to understand the following conditions:-\\n\\n**worker 5 can get all the jobs with difficulty 5,4,3,2,1  but in all of the Jobs worker will choose the job with Maximum Profit.**\\n\\nby using this approach we can easily solve this problem let\\'s take an Example:-\\n**Difficulty: [1,5,4] ,Profit: [5,3,7] ,  worker [4,6]**\\n\\n**for 1st worker(4):- this worker can get the job 1,4 but he will choose the job that has maximum profit( that is 7)**\\n\\n**for 2nd worker(6):- this worker can get all the job 1,4,5 but he will choose the job that has maximum profit( that is 7)**\\n\\n**in this way the answer will be 7+7 = 14**\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/2729c740-f688-4f96-980e-3cb24d75cdfa_1686205157.029114.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440958,
                "title": "binary-search-approach-c-intuition-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObviously, for ith worker we\\'ll try to maximize the profit. So whatever tasks that can be done by this worker we\\'ll choose the max profit.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf a worker can do tasks with difficulty i then he can do every task having difficulty <=i so if I somehow know the max profit among all such tasks that\\'ll be the ans for that worker. This leads us to the binary search approach. Suppose I sort the tasks wrt to their difficulty and I know the max profit I can get from tasks having <=i diffculty that\\'ll be the answer. Make a vector pair of {difficulty,profit}\\ndo binary search on difficulty and take maximum of profit till that index which can be maintained by prefix maximum;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n + mlog(n));\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& profit, vector<int>& worker) {\\n        \\n        vector<pair<int,int>> a;\\n        int n = dif.size();\\n        for(int i = 0; i < n; i++) {\\n            a.push_back( { dif[i], profit[i] } );\\n        }\\n        \\n        sort(a.begin(), a.end());\\n        vector<int> preMax(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            preMax[i] = (i-1>=0) ? max(preMax[i-1],a[i].second) : a[i].second;\\n\\n        }\\n        \\n        int ans = 0;\\n        int m = worker.size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            pair<int,int> se = {worker[i],1e9};\\n            int ind = upper_bound(a.begin(),a.end(),se) - a.begin();\\n            if(ind==0) continue;\\n            --ind;\\n            \\n            ans += preMax[ind];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& profit, vector<int>& worker) {\\n        \\n        vector<pair<int,int>> a;\\n        int n = dif.size();\\n        for(int i = 0; i < n; i++) {\\n            a.push_back( { dif[i], profit[i] } );\\n        }\\n        \\n        sort(a.begin(), a.end());\\n        vector<int> preMax(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            preMax[i] = (i-1>=0) ? max(preMax[i-1],a[i].second) : a[i].second;\\n\\n        }\\n        \\n        int ans = 0;\\n        int m = worker.size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            pair<int,int> se = {worker[i],1e9};\\n            int ind = upper_bound(a.begin(),a.end(),se) - a.begin();\\n            if(ind==0) continue;\\n            --ind;\\n            \\n            ans += preMax[ind];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371795,
                "title": "c-easy-to-understand-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. make **vector{profit,difficulty}** and sort it \\n2. sort worker array \\n3. keep index at last of sorted vector{profit,difficulty}\\n4. **start from last of sorted worker array** and check for worker[i]>=difficulty of sorted array{profit,difficulty} \\n4,1. If not greater, do index-- till greater found and add that profit to final ans **because profits beyond that cannot be acquired by other workers futher in iteration** \\n4,2. Else add vector{profit,difficulty}[index] to finalAns\\n5. Return final Answer\\n \\n\\n\\n# Complexity\\nlength of difficulty array=n\\nlength of worker array=m\\n- Time complexity:O(nlogn+mlogm+n+m) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        int n=difficulty.size();\\n        vector<pair<int,int>> nums;\\n\\n        for(int i=0;i<n;i++){\\n            nums.push_back({profit[i],difficulty[i]});\\n        }\\n        sort(nums.begin(),nums.end());\\n        int index=n-1;\\n        int ans=0;\\n        sort(worker.begin(),worker.end());\\n        \\n        for(int i=worker.size()-1;i>=0;i--){\\n            while(index>=0 && nums[index].second>worker[i]) index--;\\n            if(index==-1) continue;\\n            ans+=nums[index].first;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        int n=difficulty.size();\\n        vector<pair<int,int>> nums;\\n\\n        for(int i=0;i<n;i++){\\n            nums.push_back({profit[i],difficulty[i]});\\n        }\\n        sort(nums.begin(),nums.end());\\n        int index=n-1;\\n        int ans=0;\\n        sort(worker.begin(),worker.end());\\n        \\n        for(int i=worker.size()-1;i>=0;i--){\\n            while(index>=0 && nums[index].second>worker[i]) index--;\\n            if(index==-1) continue;\\n            ans+=nums[index].first;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242537,
                "title": "for-rust-geeks",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n) + mlog(m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m + n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn max_profit_assignment(difficulty: Vec<i32>, profit: Vec<i32>, mut worker: Vec<i32>) -> i32 {\\n        let (n, m) = (profit.len(), worker.len());\\n        worker.sort_unstable();\\n\\n        let mut pos = (0..n).collect::<Vec<usize>>();\\n        pos.sort_unstable_by(|&a, &b| difficulty[a].cmp(&difficulty[b]));\\n\\n        let (mut i, mut j) = (0, 0);\\n        let mut ans = 0;\\n        let mut max = 0;\\n\\n        while j < m {\\n            while i < n && difficulty[pos[i]] <= worker[j] {\\n                max = i32::max(max, profit[pos[i]]);\\n                i += 1;\\n            }\\n\\n            ans += max;\\n            j += 1;\\n        }\\n\\n        ans   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_profit_assignment(difficulty: Vec<i32>, profit: Vec<i32>, mut worker: Vec<i32>) -> i32 {\\n        let (n, m) = (profit.len(), worker.len());\\n        worker.sort_unstable();\\n\\n        let mut pos = (0..n).collect::<Vec<usize>>();\\n        pos.sort_unstable_by(|&a, &b| difficulty[a].cmp(&difficulty[b]));\\n\\n        let (mut i, mut j) = (0, 0);\\n        let mut ans = 0;\\n        let mut max = 0;\\n\\n        while j < m {\\n            while i < n && difficulty[pos[i]] <= worker[j] {\\n                max = i32::max(max, profit[pos[i]]);\\n                i += 1;\\n            }\\n\\n            ans += max;\\n            j += 1;\\n        }\\n\\n        ans   \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141689,
                "title": "beats-100-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085557,
                "title": "simple-solution-using-heap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<vector<int>>p;\\n        priority_queue<int>q(worker.begin(),worker.end());\\n\\n        for(int i=0;i<profit.size();i++){\\n            p.push({profit[i],difficulty[i]});\\n        }\\n        int val=0;\\n        while(!p.empty() && !q.empty()){\\n            if(p.top()[1]>q.top())p.pop();\\n            else{\\n                val+=p.top()[0];\\n                q.pop();\\n            }\\n        }\\n        return val;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<vector<int>>p;\\n        priority_queue<int>q(worker.begin(),worker.end());\\n\\n        for(int i=0;i<profit.size();i++){\\n            p.push({profit[i],difficulty[i]});\\n        }\\n        int val=0;\\n        while(!p.empty() && !q.empty()){\\n            if(p.top()[1]>q.top())p.pop();\\n            else{\\n                val+=p.top()[0];\\n                q.pop();\\n            }\\n        }\\n        return val;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857961,
                "title": "python-sorting-bisect",
                "content": "# Intuition\\nThe main idea is to get maximum profit for current worker ability.\\nFirst of all we need to mix together difficulty and profit, sort them and initialize dp variable with maximum value with at least current difficulty. \\n\\n# Complexity\\n- Time complexity:\\nO(N*LogN) for sorting and bisect\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nimport bisect\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        difficultyProfit = list(zip(difficulty, profit))\\n        difficultyProfit.sort()\\n\\n        difficulty, profit = zip(*difficultyProfit)\\n\\n        n = len(profit)\\n        dp = [0] * n\\n        for i in range(n):\\n            dp[i] = max(profit[i], dp[i - 1])\\n\\n        result = 0\\n        for w in worker:\\n            index = bisect.bisect_right(difficulty, w) - 1\\n            if index < 0:\\n                continue\\n            \\n            result += dp[index]\\n        \\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        difficultyProfit = list(zip(difficulty, profit))\\n        difficultyProfit.sort()\\n\\n        difficulty, profit = zip(*difficultyProfit)\\n\\n        n = len(profit)\\n        dp = [0] * n\\n        for i in range(n):\\n            dp[i] = max(profit[i], dp[i - 1])\\n\\n        result = 0\\n        for w in worker:\\n            index = bisect.bisect_right(difficulty, w) - 1\\n            if index < 0:\\n                continue\\n            \\n            result += dp[index]\\n        \\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397464,
                "title": "o-nlogn-lower-bound-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        unordered_map<int,int>mp;  \\n        int m=0,ans=0;\\n        vector<vector<int>>v;\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            mp[v[i][0]]=m=max(m,v[i][1]);\\n        \\n        sort(difficulty.begin(),difficulty.end());\\n        \\n        for(int a:worker){\\n            int j=lower_bound(difficulty.begin(),difficulty.end(),a)-difficulty.begin();\\n            \\n            if(difficulty[j]>a || j==difficulty.size())\\n                j--;\\n            if(j>=0)\\n                ans+=mp[difficulty[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        unordered_map<int,int>mp;  \\n        int m=0,ans=0;\\n        vector<vector<int>>v;\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            mp[v[i][0]]=m=max(m,v[i][1]);\\n        \\n        sort(difficulty.begin(),difficulty.end());\\n        \\n        for(int a:worker){\\n            int j=lower_bound(difficulty.begin(),difficulty.end(),a)-difficulty.begin();\\n            \\n            if(difficulty[j]>a || j==difficulty.size())\\n                j--;\\n            if(j>=0)\\n                ans+=mp[difficulty[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168333,
                "title": "java-sol-beats-100-submission",
                "content": "``` \\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max1 = 0, max2 = 0, maxDp = 0;\\n        int maxProfit = 0;\\n        for (int i = 0 ; i < worker.length ; i++) {\\n           max1 = Math.max(worker[i], max1); \\n        }\\n        \\n        for (int j = 0 ; j < difficulty.length ; j++) {\\n           max2 = Math.max(difficulty[j], max2); \\n        }\\n        \\n        maxDp = Math.max(max1 + 1, max2 +1) ;\\n        \\n        int[] dp = new int[maxDp];\\n        \\n        for (int i = 0 ; i < difficulty.length ; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        \\n        for (int i = 1 ; i < dp.length ; i++) {\\n            dp[i] = Math.max(dp[i], dp[i-1]);\\n        }\\n        \\n        for (int work: worker) {\\n            maxProfit += dp[work];\\n        }\\n        \\n        return maxProfit;\\n    }",
                "solutionTags": [],
                "code": "``` \\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max1 = 0, max2 = 0, maxDp = 0;\\n        int maxProfit = 0;\\n        for (int i = 0 ; i < worker.length ; i++) {\\n           max1 = Math.max(worker[i], max1); \\n        }\\n        \\n        for (int j = 0 ; j < difficulty.length ; j++) {\\n           max2 = Math.max(difficulty[j], max2); \\n        }\\n        \\n        maxDp = Math.max(max1 + 1, max2 +1) ;\\n        \\n        int[] dp = new int[maxDp];\\n        \\n        for (int i = 0 ; i < difficulty.length ; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        \\n        for (int i = 1 ; i < dp.length ; i++) {\\n            dp[i] = Math.max(dp[i], dp[i-1]);\\n        }\\n        \\n        for (int work: worker) {\\n            maxProfit += dp[work];\\n        }\\n        \\n        return maxProfit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1156464,
                "title": "c-faster-than-94-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> vc;\\n        for(int i = 0; i < difficulty.size(); i++) vc.push_back(make_pair(difficulty[i], profit[i]));   \\n        sort(vc.begin(), vc.end());\\n        for(int i = 1; i < vc.size(); i++) vc[i].second=max(vc[i].second, vc[i-1].second);\\n         \\n        sort(worker.begin(), worker.end());\\n        int  x = 0, ans=0;\\n        for(int i = 0; i < worker.size(); i++){\\n            while(vc[x].first<=worker[i] && vc.size()>x){\\n                x++;\\n            }\\n            ans+=x==0?0:vc[x-1].second;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> vc;\\n        for(int i = 0; i < difficulty.size(); i++) vc.push_back(make_pair(difficulty[i], profit[i]));   \\n        sort(vc.begin(), vc.end());\\n        for(int i = 1; i < vc.size(); i++) vc[i].second=max(vc[i].second, vc[i-1].second);\\n         \\n        sort(worker.begin(), worker.end());\\n        int  x = 0, ans=0;\\n        for(int i = 0; i < worker.size(); i++){\\n            while(vc[x].first<=worker[i] && vc.size()>x){\\n                x++;\\n            }\\n            ans+=x==0?0:vc[x-1].second;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769072,
                "title": "python3-solution-using-dp-o-max-n-max-difficulty",
                "content": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        n=len(profit)\\n        maxm=max(difficulty)\\n        dp=[0]*(1+maxm)\\n        for i in range(n):\\n            dp[difficulty[i]]=max(dp[difficulty[i]],profit[i])\\n        for i in range(1,maxm+1):\\n            dp[i]=max(dp[i],dp[i-1])\\n        res=0\\n\\n        for x in worker:\\n            if x>maxm:\\n                res+=dp[maxm]\\n            else:\\n                res+=dp[x]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        n=len(profit)\\n        maxm=max(difficulty)\\n        dp=[0]*(1+maxm)\\n        for i in range(n):\\n            dp[difficulty[i]]=max(dp[difficulty[i]],profit[i])\\n        for i in range(1,maxm+1):\\n            dp[i]=max(dp[i],dp[i-1])\\n        res=0\\n\\n        for x in worker:\\n            if x>maxm:\\n                res+=dp[maxm]\\n            else:\\n                res+=dp[x]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227554,
                "title": "js-solution-beats-100-with-156-ms-where-existing-solution-takes-at-least-1088ms",
                "content": "```js\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const meta = profit.map((p, i) => ({ profit: p, difficulty: difficulty[i] })).sort((m1, m2) => m2.profit - m1.profit);\\n    const sortedWorker = worker.slice().sort((a, b) => b - a);\\n    let result = 0;\\n    let j = 0;\\n    for (let i = 0; i < meta.length; i++) {\\n        while (sortedWorker[j] >= meta[i].difficulty) {\\n            result += meta[i].profit;\\n            j++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const meta = profit.map((p, i) => ({ profit: p, difficulty: difficulty[i] })).sort((m1, m2) => m2.profit - m1.profit);\\n    const sortedWorker = worker.slice().sort((a, b) => b - a);\\n    let result = 0;\\n    let j = 0;\\n    for (let i = 0; i < meta.length; i++) {\\n        while (sortedWorker[j] >= meta[i].difficulty) {\\n            result += meta[i].profit;\\n            j++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659167,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\nThe workers have to perform the task with the maximum profit under the given difficulty. So 2 cases arise:- either difficulty of the task is greater than the worker\\'s ability or it is less than or equal to worker\\'s ability.The worker should always perform the most profitable task under the given difficulty range.\\n# Approach\\nFirst the worker\\'s ability is sorted in ascending order.The `difficulty` and `profit` arrays are directly related and difficulty should be in an ascending order. So a pair is formed and the maximum profit that could be achieved upto that difficulty level is calculated.Now iteration is performed using 2 pointers. If the `worker` array\\'s pointer reaches end first, it means all workers have been traversed. Otherwise some workers remain for whom maximum profitable task was being searched. But now we have to assign all of them the maximum profitable task we have obtained so far. In the end we return the result. \\n\\n# Complexity\\n- Time complexity:\\nO(M+N) `N`:- size of difficulty array, `M` :- size of worker array\\n- Space complexity:\\nO(M+N) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int profits = 0;\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> v;\\n        for(int i = 0; i < n; i++){\\n            v.push_back({difficulty[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxm = INT_MIN,prev = 0;\\n        auto it = v.begin();\\n        int j = 0;\\n        while(it != v.end() && j < m){\\n            maxm = max(maxm,it->second);\\n            if(it->first <= worker[j]){\\n                it++;\\n                prev = maxm;\\n            }\\n            else{\\n                profits+=prev;\\n                j++;\\n            }\\n        }\\n        while(j != m){\\n            profits+= prev;\\n            j++;\\n        }\\n        return profits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int profits = 0;\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> v;\\n        for(int i = 0; i < n; i++){\\n            v.push_back({difficulty[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxm = INT_MIN,prev = 0;\\n        auto it = v.begin();\\n        int j = 0;\\n        while(it != v.end() && j < m){\\n            maxm = max(maxm,it->second);\\n            if(it->first <= worker[j]){\\n                it++;\\n                prev = maxm;\\n            }\\n            else{\\n                profits+=prev;\\n                j++;\\n            }\\n        }\\n        while(j != m){\\n            profits+= prev;\\n            j++;\\n        }\\n        return profits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551451,
                "title": "all-kind-of-solution-with-explanation",
                "content": "### All These Solutions except the very last one are inspired by @lee215 and @votrubac\\n## Solution 1\\n```\\n1.Create a vector where each element is a pair comprised difficulty[i] and profit[i] for each i.\\n2.Sort it and it will be sorted by difficulty[i] by default.\\n3.Also sort the \\'worker\\', now for each worker[i] traverse \\'jobs\\' till jobs[j].first <= worker[i].\\n   We don\\'t need to traverse \\'j always from the beginning as \\n   \"one job can be completed multiple times\" means \\n   \\n   10 20 10 5   - profit     \\n   4  5  7  9   - difficulty \\n   2  4  8  10  - worker\\n\\n   for worker[2] = 8, I can do difficulty : 4,5,7 but 5 pay me highest(20) so I\\'ll take 5\\n   because I can do any job which difficulty level <= my difficulty level.\\n   So using max() we can easily find high paid level as we have \"sorted jobs\". \\n   \\n   Of course in pair difficult[i] is the first one cause we need to compare worker[i] with \\n   difficulty[i] and both denotes \\'difficulty level\\'.\\n```\\n\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> jobs;\\n        for(int i=0; i<difficulty.size(); i++)\\n            jobs.push_back({difficulty[i],profit[i]});\\n\\n        sort(begin(jobs),end(jobs));\\n        sort(begin(worker),end(worker));\\n\\n        int j = 0, best = 0, sum = 0;\\n        for(int & it : worker)\\n        {\\n            while(j<jobs.size() && jobs[j].first<=it)\\n                best = max(best, jobs[j].second), j++;\\n            sum += best;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit))\\n        j = best = ans = 0\\n        for ability in sorted(worker):\\n            while j < len(jobs) and jobs[j][0] <= ability:\\n                best = max(best, jobs[j][1])\\n                j += 1\\n            ans += best\\n        \\n        return ans\\n```\\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(n)\\n```\\n## Solution 2 :\\n```\\nmax(m[difficulty[i]], profit[i]) had done because there can be duplicate in \\'difficulty\\'.\\n\\nDifficulty      Profit                                     Profit\\n----------     --------         ___________               --------\\n    4             20           |            |                20\\n    6             10    ---->  |    Second  |  ----->        20\\n    8             30           |    For     |                30\\n    10            20           |    Loop    |                30\\n\\nreturn accumulate(begin(worker), end(worker), 0, [m](int sum, int value)...\\n                                              |\\n              sum = -------------------------\\n              and value = each value in worker\\n          \\n              1 2 4 5 8 9\\n              upper_bound(5) = 8 \\n              lower_bound(5) = 5 but\\n              1 2 4 8 9\\n              lower_bound(5) = 8. Upper_bound = 1 variation where lower_bound = 2 variation.\\nThat\\'s why upper_bound chosen. prev(upper_bound(iterator)) is the iterator we need here always.\\n```\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        map<int, int> m;\\n        for(int i=0; i<difficulty.size(); i++)\\n            m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n        \\n        for(auto it = next(m.begin()); it!= m.end(); it++)\\n            it->second = max(prev(it)->second, it->second);\\n        \\n        return accumulate(begin(worker), end(worker), 0, [m](int sum, int value){ return sum + prev(m.upper_bound(value))->second; });\\n    }\\n};\\n```\\n```\\nTime  Complexity : O(nlogn) as we took map.\\nSpace Complexity : O(n)\\n```\\n## Solution 3 :\\n```\\nHere difficulty[i] = index and profit[i] = value of the \" counting sort \\'jobs\\' \"\\n\\ndifficulty = [2,4,6,8,10], profit = [20,10,15,40,30], worker = [4,5,6,7]\\n\\n0  0  20  0   10  0   15  0   40  0   50 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n                  \\n                    * After the second for loop *\\n                     \\n0  0  20  20  20  20  20  20  40  40  40 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n\\nIn the map solution when we \"accumulate\"d for each worker[i] say for 5 we had to go for \\nprev(upper_bound) = prev(5) =  4 here, but here in counting sort we have 5 to access directly, \\n\\n                          \\'   20 (profit)\\n                            5  (difficulty)   \\'\\n\\nwe don\\'t need any upper bound or traversing the array to get the value. So this solution is fast.\\n```\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int jobs[100001] = {0};\\n        for(int i=0; i<difficulty.size(); i++)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<100001; i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\\n```\\nYou can also optimize it by below. We only need the maximum element of \\'worker\\'.\\n                2 4 6 8 9 10 (difficulty)\\n                2 3 5 7      (worker)\\nas we need till \\'7\\', so we don\\'t care values > 7 in \\'difficulty\\'. \\nMake sure the value in \\'difficulty\\' is <= the maximum in \\'worker\\'.\\n```\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int m = *max_element(begin(worker), end(worker)) + 1;\\n        vector<int> jobs(m, 0);\\n        for(int i=0; i<difficulty.size(); i++)\\n            if(difficulty[i] < m)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<m ;i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\\n```\\nTime  Complexity : O(n + m)\\nSpace Complexity : O(m)\\n```\\n## If the post was helpful an upvote will really make me happy:)",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\n1.Create a vector where each element is a pair comprised difficulty[i] and profit[i] for each i.\\n2.Sort it and it will be sorted by difficulty[i] by default.\\n3.Also sort the \\'worker\\', now for each worker[i] traverse \\'jobs\\' till jobs[j].first <= worker[i].\\n   We don\\'t need to traverse \\'j always from the beginning as \\n   \"one job can be completed multiple times\" means \\n   \\n   10 20 10 5   - profit     \\n   4  5  7  9   - difficulty \\n   2  4  8  10  - worker\\n\\n   for worker[2] = 8, I can do difficulty : 4,5,7 but 5 pay me highest(20) so I\\'ll take 5\\n   because I can do any job which difficulty level <= my difficulty level.\\n   So using max() we can easily find high paid level as we have \"sorted jobs\". \\n   \\n   Of course in pair difficult[i] is the first one cause we need to compare worker[i] with \\n   difficulty[i] and both denotes \\'difficulty level\\'.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> jobs;\\n        for(int i=0; i<difficulty.size(); i++)\\n            jobs.push_back({difficulty[i],profit[i]});\\n\\n        sort(begin(jobs),end(jobs));\\n        sort(begin(worker),end(worker));\\n\\n        int j = 0, best = 0, sum = 0;\\n        for(int & it : worker)\\n        {\\n            while(j<jobs.size() && jobs[j].first<=it)\\n                best = max(best, jobs[j].second), j++;\\n            sum += best;\\n        }\\n        return sum;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit))\\n        j = best = ans = 0\\n        for ability in sorted(worker):\\n            while j < len(jobs) and jobs[j][0] <= ability:\\n                best = max(best, jobs[j][1])\\n                j += 1\\n            ans += best\\n        \\n        return ans\\n```\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(n)\\n```\n```\\nmax(m[difficulty[i]], profit[i]) had done because there can be duplicate in \\'difficulty\\'.\\n\\nDifficulty      Profit                                     Profit\\n----------     --------         ___________               --------\\n    4             20           |            |                20\\n    6             10    ---->  |    Second  |  ----->        20\\n    8             30           |    For     |                30\\n    10            20           |    Loop    |                30\\n\\nreturn accumulate(begin(worker), end(worker), 0, [m](int sum, int value)...\\n                                              |\\n              sum = -------------------------\\n              and value = each value in worker\\n          \\n              1 2 4 5 8 9\\n              upper_bound(5) = 8 \\n              lower_bound(5) = 5 but\\n              1 2 4 8 9\\n              lower_bound(5) = 8. Upper_bound = 1 variation where lower_bound = 2 variation.\\nThat\\'s why upper_bound chosen. prev(upper_bound(iterator)) is the iterator we need here always.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        map<int, int> m;\\n        for(int i=0; i<difficulty.size(); i++)\\n            m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n        \\n        for(auto it = next(m.begin()); it!= m.end(); it++)\\n            it->second = max(prev(it)->second, it->second);\\n        \\n        return accumulate(begin(worker), end(worker), 0, [m](int sum, int value){ return sum + prev(m.upper_bound(value))->second; });\\n    }\\n};\\n```\n```\\nTime  Complexity : O(nlogn) as we took map.\\nSpace Complexity : O(n)\\n```\n```\\nHere difficulty[i] = index and profit[i] = value of the \" counting sort \\'jobs\\' \"\\n\\ndifficulty = [2,4,6,8,10], profit = [20,10,15,40,30], worker = [4,5,6,7]\\n\\n0  0  20  0   10  0   15  0   40  0   50 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n                  \\n                    * After the second for loop *\\n                     \\n0  0  20  20  20  20  20  20  40  40  40 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n\\nIn the map solution when we \"accumulate\"d for each worker[i] say for 5 we had to go for \\nprev(upper_bound) = prev(5) =  4 here, but here in counting sort we have 5 to access directly, \\n\\n                          \\'   20 (profit)\\n                            5  (difficulty)   \\'\\n\\nwe don\\'t need any upper bound or traversing the array to get the value. So this solution is fast.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int jobs[100001] = {0};\\n        for(int i=0; i<difficulty.size(); i++)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<100001; i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\n```\\nYou can also optimize it by below. We only need the maximum element of \\'worker\\'.\\n                2 4 6 8 9 10 (difficulty)\\n                2 3 5 7      (worker)\\nas we need till \\'7\\', so we don\\'t care values > 7 in \\'difficulty\\'. \\nMake sure the value in \\'difficulty\\' is <= the maximum in \\'worker\\'.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int m = *max_element(begin(worker), end(worker)) + 1;\\n        vector<int> jobs(m, 0);\\n        for(int i=0; i<difficulty.size(); i++)\\n            if(difficulty[i] < m)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<m ;i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\n```\\nTime  Complexity : O(n + m)\\nSpace Complexity : O(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372099,
                "title": "simple-priority-queue-east-to-understand-and-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we want to maximize the profit then we will try to assign the work having maximum profit to maximum workers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We use a priority queue to store the profits alongwith the difficulty level corresponding to the profit.\\n2. Now we sort the worker array, so that we can start traversing from larget element i.e worker having the greatest ability.\\n3. We keep popping from the heap if the difficulty level of the job is greater than the ability of the worker.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>> pq;\\n        \\n        for(int i=0;i<profit.size();i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        int i=worker.size()-1;\\n        int ans=0;\\n        while(i>=0 && !pq.empty()){\\n             if(worker[i]>=pq.top().second){\\n                    ans+=pq.top().first;\\n                    i--;\\n             } \\n             else{\\n                 pq.pop();\\n             }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>> pq;\\n        \\n        for(int i=0;i<profit.size();i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        int i=worker.size()-1;\\n        int ans=0;\\n        while(i>=0 && !pq.empty()){\\n             if(worker[i]>=pq.top().second){\\n                    ans+=pq.top().first;\\n                    i--;\\n             } \\n             else{\\n                 pq.pop();\\n             }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054184,
                "title": "c-fastest-priority-queue",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < profit.size(); i++){\\n            pq.push({profit[i], difficulty[i]});\\n        }\\n        int ans = 0;\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        while(!pq.empty() && i >= 0){\\n            pair<int, int> p = pq.top();\\n            if(worker[i] >= p.second){\\n                ans += p.first;\\n                i--;\\n            }\\n            else pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < profit.size(); i++){\\n            pq.push({profit[i], difficulty[i]});\\n        }\\n        int ans = 0;\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        while(!pq.empty() && i >= 0){\\n            pair<int, int> p = pq.top();\\n            if(worker[i] >= p.second){\\n                ans += p.first;\\n                i--;\\n            }\\n            else pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917295,
                "title": "sort-binary-search-prefix-array-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), ans = 0, mx = INT_MIN;\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end());\\n        \\n        vector<int> pre;\\n        for(auto i : v) pre.push_back(mx = max(i.second, mx));\\n\\n        for(int w : worker) {\\n            int s = 0, e = n - 1, val = 0;\\n            while(s <= e) {\\n                int m = (s + e) / 2;\\n                if(v[m].first <= w) val = max(val, pre[m]), s = m + 1;\\n                else e = m - 1;\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n/*\\n((2, 10), (4, 20), (6, 30), (8, 40), (10, 50))\\n10       20        30        40       50\\n\\n20 + 20 + 30 + 30 = 100\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), ans = 0, mx = INT_MIN;\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end());\\n        \\n        vector<int> pre;\\n        for(auto i : v) pre.push_back(mx = max(i.second, mx));\\n\\n        for(int w : worker) {\\n            int s = 0, e = n - 1, val = 0;\\n            while(s <= e) {\\n                int m = (s + e) / 2;\\n                if(v[m].first <= w) val = max(val, pre[m]), s = m + 1;\\n                else e = m - 1;\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n/*\\n((2, 10), (4, 20), (6, 30), (8, 40), (10, 50))\\n10       20        30        40       50\\n\\n20 + 20 + 30 + 30 = 100\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762294,
                "title": "python-o-n-2-o-nlogn-explained",
                "content": "## **1. BRUTE FORCE - O(N^2)**\\n\\nIn the Brute Force approach, for every worker, we go through every difficulty and if the worker can do that job, we check if it can give him a profit greater than previous job. If yes, update the maximum profit for that worker.\\n\\nIn the end, we add this maximum profit to the final output that we have to return.\\n\\nThe issue is that the arrays can be of up to 10^4 length. So, an O(N^2) solution will fail for large inputs and will show TLE.\\n\\nBut from this solution, we can start thinking about the Optimized Approach.\\n\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        maxProfit = 0\\n        \\n        m = len(worker)\\n        n = len(difficulty)\\n        \\n        # For every worker, find the maximum profit that he can get (if possible)\\n        for j in range (m):\\n            maxWorkerProfit = 0\\n            # Go through each job difficulty\\n            for i in range(n):\\n                # And if we find a difficulty <= ability of worker\\n                # Then we need to update the profit \\n                # if this job gives a higher profit than previous job\\n                if difficulty[i] <= worker[j]:\\n                    maxWorkerProfit = max(maxWorkerProfit, profit[i])\\n            \\n            # And when we found the maximum profit for this worker, just add it to the output that we need to return\\n            maxProfit += maxWorkerProfit\\n        \\n        \\n        return maxProfit\\n\\t\\t\\n## **2. BINARY SEARCH APPROACH - O(NLogN)**\\n\\nThe reason of O(N^2) complexity in Brute Force approach is that inner loop. For every worker, we have to iterate from the beginning to the end to find the maximum profit. \\n\\n\\tBut what if the difficulties were in sorted order already?\\n\\nIn that case, if a worker is able to do any job with difficulty[i], then we can say that he can also do any job that has a lower difficulty right? In other words, in that case, we don\\'t worry about the difficulties on left side as they will all be valid as the array is sorted. And that\\'s the idea of Binary Search. \\n\\nSo using Binary Search, all we have to do is find the rightmost valid difficulty out of the sorted difficulty list. Once we can find that, then all we need to find is what is the maximum profit that we can get in the [0, rightmost valid difficulty index] range. And to avoid calculating this for every worker, we can precomute this before we even apply Binary Search. \\n\\nBut there is one issue with this approach and I was stuck at this for almost half an hour before I realised that I made a dumb mistake.\\n\\nNotice that \"difficulty\" and \"profit\" are in sync. That means, ith difficulty has profit[i] profit. So if we only sort difficulty list, the profit list remains unchanged and that will not give us correct result. We cannot sort these two lists separately as well. Because profit of a job with a higher difficulty might be less than profit of a job with lower difficulty. So sorting them separately will also give wrong results.\\n\\nAnd so, we want a way such that when we sort the \"difficulty\" list, the \"profit\" list is still in sync. And for that, we can make a new list in which at every index, we have a pair of (difficulty, profit). So now, even if we sort this new list based on difficulty value, the profit value will always stay with its correct corresponding difficulty, just as it was initially in the input lists.\\n\\n*You will find a lot of questions that have a similar pattern and they might differ in only the way we precompute max value. For some problems, you have to find maximum on right side whereas for some you have to find maximum on left side of each index. That depends on the problem statement. For example here, we know that if one difficulty is valid, all difficulties less than it are also valid. Hence we precomputed the maximum value on left side of each index.*\\n\\n```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        maxProfit = 0\\n        \\n        m = len(worker)\\n        n = len(difficulty)\\n        \\n        # We cannot just sort difficulty array\\n        # We also need to make sure profit array is in same order as difficulty array\\n        # So what we can do is at each index, we can keep what is the difficulty of a job and what is its profit\\n        jobs = []\\n        for i in range(n): jobs.append((difficulty[i], profit[i]))\\n            \\n        # Now we can sort this new list we made and since difficulty is the first value in each tuple\\n        # this list will be sorted based on difficulty\\n        jobs.sort()\\n        \\n        # Precompute maximum profit on left for each index\\n        maxProfitSoFar = [0] * n\\n        \\n        # For first index, maximum profit on left will be profit at its index only\\n        maxProfitSoFar[0] = jobs[0][1]\\n        for i in range(1, n): maxProfitSoFar[i] = max(maxProfitSoFar[i - 1], jobs[i][1])           \\n\\n        # For every worker, find the maximum profit that he can get (if possible)\\n        for j in range(m):\\n            maxWorkerProfit = 0\\n            \\n            # Instead of linear search, we can now apply Binary Search here\\n            # As we have sorted the difficulty\\n            # Since difficulty is sorted, all we want to find is the rightmost valid index in difficulty array\\n            # That is the rightmost index at which difficulty is <= ability of the worker\\n            \\n            start = 0\\n            end = n - 1\\n            rightmostIndex = -1\\n            \\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # If job at mid can be done by worker\\n                # Then this is one possible solution\\n                # But we want rightmost valid difficulty\\n                # So we keep searching on right side of mid\\n                if jobs[mid][0] <= worker[j]:\\n                    rightmostIndex = mid\\n                    start = mid + 1 \\n                # If job at mid cannot be done by the worker\\n                # That means, no job after mid can be done as well\\n                # Since array is now sorted\\n                else: end = mid - 1\\n            \\n            # Now, as we have precomputed maximum profit till each index already\\n            # We can find the maximum profit till rightmostIndex in O(1) time\\n            if rightmostIndex != -1: maxWorkerProfit = maxProfitSoFar[rightmostIndex]\\n                \\n            # And append that to the final output that we need to return\\n            maxProfit += maxWorkerProfit\\n            \\n        \\n        return maxProfit\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        maxProfit = 0\\n        \\n        m = len(worker)\\n        n = len(difficulty)\\n        \\n        # We cannot just sort difficulty array\\n        # We also need to make sure profit array is in same order as difficulty array\\n        # So what we can do is at each index, we can keep what is the difficulty of a job and what is its profit\\n        jobs = []\\n        for i in range(n): jobs.append((difficulty[i], profit[i]))\\n            \\n        # Now we can sort this new list we made and since difficulty is the first value in each tuple\\n        # this list will be sorted based on difficulty\\n        jobs.sort()\\n        \\n        # Precompute maximum profit on left for each index\\n        maxProfitSoFar = [0] * n\\n        \\n        # For first index, maximum profit on left will be profit at its index only\\n        maxProfitSoFar[0] = jobs[0][1]\\n        for i in range(1, n): maxProfitSoFar[i] = max(maxProfitSoFar[i - 1], jobs[i][1])           \\n\\n        # For every worker, find the maximum profit that he can get (if possible)\\n        for j in range(m):\\n            maxWorkerProfit = 0\\n            \\n            # Instead of linear search, we can now apply Binary Search here\\n            # As we have sorted the difficulty\\n            # Since difficulty is sorted, all we want to find is the rightmost valid index in difficulty array\\n            # That is the rightmost index at which difficulty is <= ability of the worker\\n            \\n            start = 0\\n            end = n - 1\\n            rightmostIndex = -1\\n            \\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # If job at mid can be done by worker\\n                # Then this is one possible solution\\n                # But we want rightmost valid difficulty\\n                # So we keep searching on right side of mid\\n                if jobs[mid][0] <= worker[j]:\\n                    rightmostIndex = mid\\n                    start = mid + 1 \\n                # If job at mid cannot be done by the worker\\n                # That means, no job after mid can be done as well\\n                # Since array is now sorted\\n                else: end = mid - 1\\n            \\n            # Now, as we have precomputed maximum profit till each index already\\n            # We can find the maximum profit till rightmostIndex in O(1) time\\n            if rightmostIndex != -1: maxWorkerProfit = maxProfitSoFar[rightmostIndex]\\n                \\n            # And append that to the final output that we need to return\\n            maxProfit += maxWorkerProfit\\n            \\n        \\n        return maxProfit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2566859,
                "title": "cpp-easy-two-pointer",
                "content": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        vector<pair<int,int>> v;\\n        int n=profit.size(),m=worker.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({profit[i],difficulty[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int ans=0;\\n        \\n        int j=n-1,i=m-1;\\n        while(j>=0 and i>=0)\\n        {\\n            int p=v[j].first;\\n            int d=v[j].second;\\n            int k=j;\\n            while(k>0 and worker[k]<d)\\n            {\\n                k--;\\n                d=v[k].second;\\n            }\\n            if(k>=0 and worker[k]>=d)\\n            {\\n                i--;\\n                ans+=profit[k];\\n            }\\n            else\\n                j--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        vector<pair<int,int>> v;\\n        int n=profit.size(),m=worker.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({profit[i],difficulty[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2478003,
                "title": "python-commented-code-greedy",
                "content": "\\tclass Solution:\\n\\t\\tdef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\t\\t\\tjobs=[]\\n\\t\\t\\tfor dif,pro in zip(difficulty, profit):\\n\\t\\t\\t\\tjobs.append([dif,pro])\\n\\t\\t\\tjobs = sorted(jobs, key=lambda x:x[0]) #sort it based on the difficulty level\\n\\t\\t\\tans = i = best = 0\\n\\t\\t\\tfor skill in sorted(worker):\\n\\t\\t\\t\\twhile i < len(jobs) and skill >= jobs[i][0]:\\n\\t\\t\\t\\t\\tbest = max(best, jobs[i][1]) #doing this because even a low difficulty task can have a higher profit than a high difficulty task                                              \\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tans += best\\n\\t\\t\\treturn ans\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\t\\t\\tjobs=[]\\n\\t\\t\\tfor dif,pro in zip(difficulty, profit):\\n\\t\\t\\t\\tjobs.append([dif,pro])\\n\\t\\t\\tjobs = sorted(jobs, key=lambda x:x[0]) #sort it based on the difficulty level\\n\\t\\t\\tans = i = best = 0\\n\\t\\t\\tfor skill in sorted(worker):\\n\\t\\t\\t\\twhile i < len(jobs) and skill >= jobs[i][0]:\\n\\t\\t\\t\\t\\tbest = max(best, jobs[i][1]) #doing this because even a low difficulty task can have a higher profit than a high difficulty task                                              \\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tans += best\\n\\t\\t\\treturn ans\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2444367,
                "title": "my-c-solution-easy-approach-by-using-priority-queue",
                "content": "****Please upvote if you like****\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        int n=profit.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        int ans=0;\\n        sort(worker.rbegin(),worker.rend());\\n        for(auto u:worker)\\n        {\\n            while(!pq.empty()){\\n                if(pq.top().second>u)\\n                    pq.pop();\\n                else{\\n                    ans+=pq.top().first;\\n                    break;\\n                }\\n            }\\n            if(pq.empty())\\n                break;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```\\n****If you have any trouble to understand my code then please comment billow I will reply very soon****",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        int n=profit.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        int ans=0;\\n        sort(worker.rbegin(),worker.rend());\\n        for(auto u:worker)\\n        {\\n            while(!pq.empty()){\\n                if(pq.top().second>u)\\n                    pq.pop();\\n                else{\\n                    ans+=pq.top().first;\\n                    break;\\n                }\\n            }\\n            if(pq.empty())\\n                break;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163409,
                "title": "most-profit-assigning-work",
                "content": "# **Brute force gives TLE\\n**\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        if min(difficulty) > max(worker):\\n            return 0\\n        \\n        max_profit = 0\\n        work_assigned = 0\\n        \\n        for i in range(len(worker)):\\n            max_money = 0\\n            for j in range(len(difficulty)):\\n                if profit[j] >= max_money:\\n                    if worker[i]>=difficulty[j]: \\n                        max_money = max(max_money,profit[j])\\n                        work_assigned = difficulty[j]\\n            max_profit += max_money\\n        return max_profit\\n\\t\\t\\n# \\t\\tTwo pointers\\n\\t\\t\\n\\t\\tclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        jobs = sorted(zip(difficulty,profit))\\n        n = len(jobs)\\n        \\n        res = i = best = 0\\n        \\n        for ability in sorted(worker):\\n            while i < n and ability >= jobs[i][0]:\\n                best = max(best,jobs[i][1])\\n                i+=1\\n            res+=best\\n        \\n        return res\\n\\t\\t\\n# \\t\\tBinary search and Map\\n\\t\\t\\n\\t\\tclass Solution:\\n    def search_ceil(self,arr,k):\\n        low = 0\\n        high = len(arr) - 1\\n        res = -1                        #binary search\\n\\n        while low <= high:\\n            mid = low + (high - low)//2\\n\\n            if arr[mid] <= k:\\n                res = mid\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        if res != -1:\\n            return arr[res]\\n        else:\\n            return -1\\n        \\n    def make_a_map_as_per_max_profit(self,difficulty, profit):\\n        dp = sorted(zip(difficulty,profit))     #nested list\\n\\n        map = {}\\n\\n        max_p = dp[0][1]\\n        map[dp[0][0]] = dp[0][1]   \\n\\n        for i in range(1,len(dp)):\\n            if dp[i][1] < max_p:\\n                   map[dp[i][0]] = max_p         #hash_map\\n            else:\\n                max_p = max(max_p,dp[i][1])\\n                map[dp[i][0]] = max_p\\n        return map\\n        \\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        map = self.make_a_map_as_per_max_profit(difficulty, profit)\\n        max_profit = 0\\n        difficulty.sort()\\n        for i in worker:\\n            if self.search_ceil(difficulty,i) > 0:\\n                max_profit += map[self.search_ceil(difficulty,i)]        #calculate prfit\\n        return max_profit\\n\\t\\t",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        if min(difficulty) > max(worker):\\n            return 0\\n        \\n        max_profit = 0\\n        work_assigned = 0\\n        \\n        for i in range(len(worker)):\\n            max_money = 0\\n            for j in range(len(difficulty)):\\n                if profit[j] >= max_money:\\n                    if worker[i]>=difficulty[j]: \\n                        max_money = max(max_money,profit[j])\\n                        work_assigned = difficulty[j]\\n            max_profit += max_money\\n        return max_profit\\n\\t\\t\\n# \\t\\tTwo pointers\\n\\t\\t\\n\\t\\tclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        jobs = sorted(zip(difficulty,profit))\\n        n = len(jobs)\\n        \\n        res = i = best = 0\\n        \\n        for ability in sorted(worker):\\n            while i < n and ability >= jobs[i][0]:\\n                best = max(best,jobs[i][1])\\n                i+=1\\n            res+=best\\n        \\n        return res\\n\\t\\t\\n# \\t\\tBinary search and Map\\n\\t\\t\\n\\t\\tclass Solution:\\n    def search_ceil(self,arr,k):\\n        low = 0\\n        high = len(arr) - 1\\n        res = -1                        #binary search\\n\\n        while low <= high:\\n            mid = low + (high - low)//2\\n\\n            if arr[mid] <= k:\\n                res = mid\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        if res != -1:\\n            return arr[res]\\n        else:\\n            return -1\\n        \\n    def make_a_map_as_per_max_profit(self,difficulty, profit):\\n        dp = sorted(zip(difficulty,profit))     #nested list\\n\\n        map = {}",
                "codeTag": "Java"
            },
            {
                "id": 2010143,
                "title": "python3-sort-binary-search-prefix-sum",
                "content": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tn = len(difficulty)\\n\\tarr = [(difficulty[i], profit[i]) for i in range(n)]\\n\\tarr.sort()\\n\\tmax_profit = [n[1] for n in arr]\\n\\tcur = 0\\n\\tfor i in range(n):\\n\\t\\tcur = max(max_profit[i], cur)\\n\\t\\tmax_profit[i] = cur\\n\\tprofit = 0\\n\\n\\tfor diff in worker:\\n\\t\\tl, r = 0, n - 1\\n\\t\\twhile l < r:\\n\\t\\t\\tm = (l + r + 1) >> 1\\n\\t\\t\\tif arr[m][0] <= diff:\\n\\t\\t\\t\\tl = m\\n\\t\\t\\telse:\\n\\t\\t\\t\\tr = m - 1\\n\\t\\tprofit += max_profit[l] if arr[l][0] <= diff else 0\\n\\treturn profit\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tn = len(difficulty)\\n\\tarr = [(difficulty[i], profit[i]) for i in range(n)]\\n\\tarr.sort()\\n\\tmax_profit = [n[1] for n in arr]\\n\\tcur = 0\\n\\tfor i in range(n):\\n\\t\\tcur = max(max_profit[i], cur)\\n\\t\\tmax_profit[i] = cur\\n\\tprofit = 0\\n\\n\\tfor diff in worker:\\n\\t\\tl, r = 0, n - 1\\n\\t\\twhile l < r:\\n\\t\\t\\tm = (l + r + 1) >> 1\\n\\t\\t\\tif arr[m][0] <= diff:\\n\\t\\t\\t\\tl = m\\n\\t\\t\\telse:\\n\\t\\t\\t\\tr = m - 1\\n\\t\\tprofit += max_profit[l] if arr[l][0] <= diff else 0\\n\\treturn profit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1947836,
                "title": "javascript-subproblems-and-preprocessing",
                "content": "Sort the difficulties and workers, then get the maximum profit you can get at that difficulty (which includes any lower difficulties).\\nUse i,j counter to find the maximum difficulty each worker can take on. Since each difficulty is already pre-calculated to be the maximum profit, then just adding the profit should give you the total profit.\\n\\n```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const profitD = [];\\n    \\n    // create difficulty and profit array\\n    for (let i = 0; i < difficulty.length; i++) {\\n        profitD.push({d: difficulty[i], p: profit[i]});\\n    }\\n    \\n    // sort on difficulty\\n    profitD.sort((a, b) => a.d - b.d);\\n    // sort worker\\n    worker.sort((a, b) => a - b);\\n    \\n    \\n    // process to the array to get maxProfit So Far\\n    let maxSoFar = -Infinity;\\n    for (let i = 0; i < profitD.length; i++) {\\n        maxSoFar = Math.max(profitD[i].p, maxSoFar);\\n        profitD[i].p = maxSoFar;\\n    }\\n    \\n    \\n    let i = 0;\\n    let j = 0;\\n    let total = 0;\\n    while (i <= profitD.length && j < worker.length) {\\n        // use the last profit and assign it to all the remaining workers\\n        // can do this in another for loop\\n        if (i === profitD.length) {\\n            total += profitD[i - 1].p;\\n            j++;\\n            continue;\\n        }\\n          \\n        const {p, d} = profitD[i];\\n        // increment i if too difficult\\n        if (d <= worker[j]) {\\n            i++;\\n        } else {\\n            if (i - 1 >= 0) {\\n                total += profitD[i - 1].p;\\n            }\\n            j++;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const profitD = [];\\n    \\n    // create difficulty and profit array\\n    for (let i = 0; i < difficulty.length; i++) {\\n        profitD.push({d: difficulty[i], p: profit[i]});\\n    }\\n    \\n    // sort on difficulty\\n    profitD.sort((a, b) => a.d - b.d);\\n    // sort worker\\n    worker.sort((a, b) => a - b);\\n    \\n    \\n    // process to the array to get maxProfit So Far\\n    let maxSoFar = -Infinity;\\n    for (let i = 0; i < profitD.length; i++) {\\n        maxSoFar = Math.max(profitD[i].p, maxSoFar);\\n        profitD[i].p = maxSoFar;\\n    }\\n    \\n    \\n    let i = 0;\\n    let j = 0;\\n    let total = 0;\\n    while (i <= profitD.length && j < worker.length) {\\n        // use the last profit and assign it to all the remaining workers\\n        // can do this in another for loop\\n        if (i === profitD.length) {\\n            total += profitD[i - 1].p;\\n            j++;\\n            continue;\\n        }\\n          \\n        const {p, d} = profitD[i];\\n        // increment i if too difficult\\n        if (d <= worker[j]) {\\n            i++;\\n        } else {\\n            if (i - 1 >= 0) {\\n                total += profitD[i - 1].p;\\n            }\\n            j++;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795402,
                "title": "priorityqueue-treemap",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        PriorityQueue<Job> pq = new PriorityQueue<>((a, b) -> {\\n            \\n            if (a.profit == b.profit) {\\n                return a.difficulty - b.difficulty;\\n            } else {\\n                return b.profit - a.profit;\\n            }\\n        });\\n        \\n        int n = difficulty.length;\\n        for (int i = 0; i < n; i++) {\\n            pq.add(new Job(difficulty[i], profit[i]));\\n        }\\n        \\n        TreeMap<Integer, List<Integer>> treeMap = new TreeMap<>();\\n        for (int i = 0; i < worker.length; i++) {\\n            treeMap.computeIfAbsent(worker[i], v -> new ArrayList<>()).add(i);\\n        }\\n        \\n        int ret = 0;\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        while (!pq.isEmpty() && visited.size() != worker.length) {\\n            \\n            Job cur = pq.poll();\\n            int d = cur.difficulty;\\n            \\n            Map.Entry<Integer, List<Integer>> e = treeMap.ceilingEntry(d);\\n            if (e != null) {\\n                \\n                for (int w : e.getValue()) {\\n                    visited.add(w);\\n                }\\n                \\n                ret += e.getValue().size() * cur.profit;\\n                \\n                treeMap.remove(e.getKey());\\n                pq.add(cur);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    class Job {\\n        \\n        int difficulty;\\n        int profit;\\n        \\n        public Job(int difficulty, int profit) {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        PriorityQueue<Job> pq = new PriorityQueue<>((a, b) -> {\\n            \\n            if (a.profit == b.profit) {\\n                return a.difficulty - b.difficulty;\\n            } else {\\n                return b.profit - a.profit;\\n            }\\n        });\\n        \\n        int n = difficulty.length;\\n        for (int i = 0; i < n; i++) {\\n            pq.add(new Job(difficulty[i], profit[i]));\\n        }\\n        \\n        TreeMap<Integer, List<Integer>> treeMap = new TreeMap<>();\\n        for (int i = 0; i < worker.length; i++) {\\n            treeMap.computeIfAbsent(worker[i], v -> new ArrayList<>()).add(i);\\n        }\\n        \\n        int ret = 0;\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        while (!pq.isEmpty() && visited.size() != worker.length) {\\n            \\n            Job cur = pq.poll();\\n            int d = cur.difficulty;\\n            \\n            Map.Entry<Integer, List<Integer>> e = treeMap.ceilingEntry(d);\\n            if (e != null) {\\n                \\n                for (int w : e.getValue()) {\\n                    visited.add(w);\\n                }\\n                \\n                ret += e.getValue().size() * cur.profit;\\n                \\n                treeMap.remove(e.getKey());\\n                pq.add(cur);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    class Job {\\n        \\n        int difficulty;\\n        int profit;\\n        \\n        public Job(int difficulty, int profit) {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622126,
                "title": "java-solutions-with-optimization-steps-explained",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + n))\\n        // sort job by difficulty \\n        // binary search for index of max difficulty worker[i] can afford\\n        // loop from 0 to that index, checking one by one to find max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job);\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job);\\n            int max = 0;\\n            for (int j = 0; j<=idx; j++) {\\n                max = Math.max(job[j].profit, max);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```\\nWay 2: Optimize maximum finding using segment tree, without loops\\n```\\nclass Solution {\\n    int MM = (int)1e5;\\n    int seg[] = new int[3*MM];\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + log n)) or can be simplified to O(n log n)\\n        // sort job by difficulty \\n\\t\\t// build segment tree\\n        // binary search for index of max difficulty worker[i] can afford\\n        // query seg tree for the range [0, index] to find the max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job); // Sort requires O(n log n) \\n        build(0, m-1, 1, job); // Build tree requires O(n)\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job); // binary search takes O(log n)\\n            int max = queryMax(0, m-1, 0, idx, 1); // query takes O(log n)\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public void build(int l, int r, int idx, work[] jobs) {\\n        if (l == r) {\\n            seg[idx] = jobs[l].profit;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        build(l , m, idx*2, jobs); build(m+1, r, idx*2+1, jobs);\\n        seg[idx] = Math.max(seg[2*idx], seg[2*idx+1]);\\n    }\\n    public int queryMax(int l, int r, int ql, int qr, int idx) {\\n        if (ql>qr) return 0; \\n        if (l == ql && r == qr)return seg[idx];\\n        int m = (l+r)/2;\\n        if (ql > m) return queryMax(m+1, r, ql, qr, 2*idx+1);\\n        else if (qr<=m) return queryMax(l, m, ql, qr, 2*idx);\\n        else return Math.max(queryMax(l, m, ql, m, 2*idx), queryMax(m+1, r, m+1, qr, 2*idx+1));\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + n))\\n        // sort job by difficulty \\n        // binary search for index of max difficulty worker[i] can afford\\n        // loop from 0 to that index, checking one by one to find max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job);\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job);\\n            int max = 0;\\n            for (int j = 0; j<=idx; j++) {\\n                max = Math.max(job[j].profit, max);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int MM = (int)1e5;\\n    int seg[] = new int[3*MM];\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + log n)) or can be simplified to O(n log n)\\n        // sort job by difficulty \\n\\t\\t// build segment tree\\n        // binary search for index of max difficulty worker[i] can afford\\n        // query seg tree for the range [0, index] to find the max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job); // Sort requires O(n log n) \\n        build(0, m-1, 1, job); // Build tree requires O(n)\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job); // binary search takes O(log n)\\n            int max = queryMax(0, m-1, 0, idx, 1); // query takes O(log n)\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public void build(int l, int r, int idx, work[] jobs) {\\n        if (l == r) {\\n            seg[idx] = jobs[l].profit;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        build(l , m, idx*2, jobs); build(m+1, r, idx*2+1, jobs);\\n        seg[idx] = Math.max(seg[2*idx], seg[2*idx+1]);\\n    }\\n    public int queryMax(int l, int r, int ql, int qr, int idx) {\\n        if (ql>qr) return 0; \\n        if (l == ql && r == qr)return seg[idx];\\n        int m = (l+r)/2;\\n        if (ql > m) return queryMax(m+1, r, ql, qr, 2*idx+1);\\n        else if (qr<=m) return queryMax(l, m, ql, qr, 2*idx);\\n        else return Math.max(queryMax(l, m, ql, m, 2*idx), queryMax(m+1, r, m+1, qr, 2*idx+1));\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324179,
                "title": "with-explaination-faster-than-98-dp-java-easy-to-understand",
                "content": "Basically we have to find what maximum profit a worker could earn knowing that he is only able to do work of certain level of difficulty. For this we are creating a dp array and in that we are storing the max profit for each level.\\nFirst we are assigning values in dp from the profit array.After that maximum profit for any difficulty is the MAX profit of difficulty from level 0 difficulty to that level of difficulty.So value of that difficulty will be\\ndp[i]=Math.max(dp[0],dp[1],dp[2].......dp[i])\\nWe are doing this because a person can earn money by doing work of any difficulty level below tham it\\'s level.\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=-1;\\n        for(int val:difficulty)\\n            max=Math.max(val,max);\\n        int [] dp=new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++){\\n            dp[difficulty[i]]=Math.max(dp[difficulty[i]],profit[i]);\\n        }\\n        for(int i=1;i<dp.length;i++){\\n            dp[i]=Math.max(dp[i],dp[i-1]);\\n        }\\n        int ans=0;\\n        for(int val:worker){\\n            if(val<dp.length)\\n                ans+=dp[val];\\n            else\\n                ans+=dp[dp.length-1];\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=-1;\\n        for(int val:difficulty)\\n            max=Math.max(val,max);\\n        int [] dp=new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++){\\n            dp[difficulty[i]]=Math.max(dp[difficulty[i]],profit[i]);\\n        }\\n        for(int i=1;i<dp.length;i++){\\n            dp[i]=Math.max(dp[i],dp[i-1]);\\n        }\\n        int ans=0;\\n        for(int val:worker){\\n            if(val<dp.length)\\n                ans+=dp[val];\\n            else\\n                ans+=dp[dp.length-1];\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018819,
                "title": "c-sort-then-greedy-beats-100-time-72-89-space",
                "content": "Greedy\\nSort profit array\\nAssign as many of the highest paying jobs to workers as you can.\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        vector<pair<int,int>> jobs;\\n        for(int i = 0; i < profit.size(); i++) jobs.push_back({profit[i], difficulty[i]});\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        int j = profit.size()-1;\\n        for(; i >= 0; i--) {\\n            while(j >= 0 && jobs[j].second > worker[i]) j--;\\n            if(j < 0) break;\\n            ans += jobs[j].first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        vector<pair<int,int>> jobs;\\n        for(int i = 0; i < profit.size(); i++) jobs.push_back({profit[i], difficulty[i]});\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        int j = profit.size()-1;\\n        for(; i >= 0; i--) {\\n            while(j >= 0 && jobs[j].second > worker[i]) j--;\\n            if(j < 0) break;\\n            ans += jobs[j].first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776586,
                "title": "java-sorting-and-two-pointer-approach-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] diff, int[] pro, int[] work) {\\n        int maxProfit=0;\\n        Map<Integer,Integer> map=new HashMap<>(); \\n        for(int i=0;i<pro.length;i++){\\n            if(map.get(pro[i])!=null && map.get(pro[i])<diff[i]){\\n                continue;\\n            }\\n            map.put(pro[i],diff[i]);\\n        }\\n        Arrays.sort(pro);\\n        Arrays.sort(work);\\n        int w=work.length-1;\\n        int p=pro.length-1;\\n        while(w>=0 && p>=0) {\\n            if(map.get(pro[p])<=work[w]){\\n                maxProfit+=pro[p];\\n                w--;\\n            } else{\\n                p--;\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] diff, int[] pro, int[] work) {\\n        int maxProfit=0;\\n        Map<Integer,Integer> map=new HashMap<>(); \\n        for(int i=0;i<pro.length;i++){\\n            if(map.get(pro[i])!=null && map.get(pro[i])<diff[i]){\\n                continue;\\n            }\\n            map.put(pro[i],diff[i]);\\n        }\\n        Arrays.sort(pro);\\n        Arrays.sort(work);\\n        int w=work.length-1;\\n        int p=pro.length-1;\\n        while(w>=0 && p>=0) {\\n            if(map.get(pro[p])<=work[w]){\\n                maxProfit+=pro[p];\\n                w--;\\n            } else{\\n                p--;\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756765,
                "title": "python-sort-and-binary-search",
                "content": "Code is very descriptive, just read up.\\n\\n```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tdif_profit_hm = defaultdict(int)\\n\\tn = len(difficulty)\\n\\n\\t# Create a hash map to remember original values order\\n\\tfor dif, profit in zip(difficulty, profit):\\n\\t\\tdif_profit_hm[dif] = max(dif_profit_hm[dif], profit)\\n\\n\\t# Sorting to work with binary search\\n\\tsorted_dif = sorted(difficulty)\\n\\n\\t# dp that knows maximum for every index worker can have\\n\\tmax_profit_per_diff = [0] * n\\n\\tmax_profit_per_diff[0] = dif_profit_hm[sorted_dif[0]]\\n\\n\\tfor i in range(1, len(sorted_dif)):\\n\\t\\tval = sorted_dif[i]\\n\\t\\tmax_profit_per_diff[i] = max(dif_profit_hm[val], max_profit_per_diff[i - 1])\\n\\n\\tdef find_worker_index(worker_dif):\\n\\t\\tindex = bisect_right(sorted_dif, worker_dif)\\n\\t\\tif index == n: return n -1 # we are bigger than all indexes\\n\\t\\tif sorted_dif[index] == worker_dif:\\n\\t\\t\\treturn index\\n\\t\\treturn index - 1\\n\\n\\tmax_profit = 0\\n\\tfor w in worker:\\n\\t\\tworker_max_index = find_worker_index(w)\\n\\t\\tif worker_max_index == -1: continue\\n\\t\\tmax_profit += max_profit_per_diff[worker_max_index]\\n\\n\\treturn max_profit\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tdif_profit_hm = defaultdict(int)\\n\\tn = len(difficulty)\\n\\n\\t# Create a hash map to remember original values order\\n\\tfor dif, profit in zip(difficulty, profit):\\n\\t\\tdif_profit_hm[dif] = max(dif_profit_hm[dif], profit)\\n\\n\\t# Sorting to work with binary search\\n\\tsorted_dif = sorted(difficulty)\\n\\n\\t# dp that knows maximum for every index worker can have\\n\\tmax_profit_per_diff = [0] * n\\n\\tmax_profit_per_diff[0] = dif_profit_hm[sorted_dif[0]]\\n\\n\\tfor i in range(1, len(sorted_dif)):\\n\\t\\tval = sorted_dif[i]\\n\\t\\tmax_profit_per_diff[i] = max(dif_profit_hm[val], max_profit_per_diff[i - 1])\\n\\n\\tdef find_worker_index(worker_dif):\\n\\t\\tindex = bisect_right(sorted_dif, worker_dif)\\n\\t\\tif index == n: return n -1 # we are bigger than all indexes\\n\\t\\tif sorted_dif[index] == worker_dif:\\n\\t\\t\\treturn index\\n\\t\\treturn index - 1\\n\\n\\tmax_profit = 0\\n\\tfor w in worker:\\n\\t\\tworker_max_index = find_worker_index(w)\\n\\t\\tif worker_max_index == -1: continue\\n\\t\\tmax_profit += max_profit_per_diff[worker_max_index]\\n\\n\\treturn max_profit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 641854,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for (int i=0; i<profit.size(); i++){\\n            pq.push(make_pair(profit[i], difficulty[i]));\\n        }\\n        sort(worker.begin(), worker.end());\\n        int total = 0;\\n        for (int i=worker.size()-1; i>=0; i--){\\n            while (!pq.empty() && pq.top().second > worker[i]){\\n                pq.pop();\\n            }\\n            if (!pq.empty()){\\n                total += pq.top().first;\\n            }else{\\n                break;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for (int i=0; i<profit.size(); i++){\\n            pq.push(make_pair(profit[i], difficulty[i]));\\n        }\\n        sort(worker.begin(), worker.end());\\n        int total = 0;\\n        for (int i=worker.size()-1; i>=0; i--){\\n            while (!pq.empty() && pq.top().second > worker[i]){\\n                pq.pop();\\n            }\\n            if (!pq.empty()){\\n                total += pq.top().first;\\n            }else{\\n                break;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548935,
                "title": "python-o-n-log-n-sort-and-binary-search",
                "content": "Simple idea: sort the jobs by difficulty, then find the most profit that can be made up to each difficulty level. For each worker, do a binary search to determine the most difficult job they can complete, and hence the most profit.\\n\\n```python\\nclass Solution:\\n    \\n    def maxProfitAssignment(self, difficulties, profits, workers):\\n        \\n        # Sort difficulties and profits, with difficulties as the key:\\n        difficulties, profits = zip(*sorted(zip(difficulties, profits)))\\n        \\n        # Find the corresponding maximum profit for each difficulty level:\\n        max_profits = list(itertools.accumulate(profits, max))\\n        \\n        min_difficulty = min(difficulties)\\n        \\n        def max_profit(worker):\\n            if worker < min_difficulty:\\n                return 0\\n            return max_profits[bisect.bisect(difficulties, worker) - 1]\\n        \\n        return sum(map(max_profit, workers))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    \\n    def maxProfitAssignment(self, difficulties, profits, workers):\\n        \\n        # Sort difficulties and profits, with difficulties as the key:\\n        difficulties, profits = zip(*sorted(zip(difficulties, profits)))\\n        \\n        # Find the corresponding maximum profit for each difficulty level:\\n        max_profits = list(itertools.accumulate(profits, max))\\n        \\n        min_difficulty = min(difficulties)\\n        \\n        def max_profit(worker):\\n            if worker < min_difficulty:\\n                return 0\\n            return max_profits[bisect.bisect(difficulties, worker) - 1]\\n        \\n        return sum(map(max_profit, workers))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347627,
                "title": "python-2-pointer-greedy",
                "content": "Run time O(NlogN + KlogK + N)\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        for i in range(len(difficulty)):\\n            difficulty[i] = (difficulty[i], profit[i])\\n        difficulty.sort(key = lambda x:x[0]) # O(NlogN)\\n        i, L = 0, len(difficulty)\\n        ans, most = 0, 0\\n        for wker in sorted(worker):\\n            while i < L and difficulty[i][0] <= wker:\\n                most = max(most, difficulty[i][1])\\n                i += 1\\n            ans += most\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        for i in range(len(difficulty)):\\n            difficulty[i] = (difficulty[i], profit[i])\\n        difficulty.sort(key = lambda x:x[0]) # O(NlogN)\\n        i, L = 0, len(difficulty)\\n        ans, most = 0, 0\\n        for wker in sorted(worker):\\n            while i < L and difficulty[i][0] <= wker:\\n                most = max(most, difficulty[i][1])\\n                i += 1\\n            ans += most\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251244,
                "title": "why-does-my-solution-fail-the-last-testcase",
                "content": "I used Nlog(N) sort + binary search solution:\\nIt fails on this testcase:\\n[66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n[66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n[61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]\\noutput should be:  1392\\nbut i am getting: 1324\\n\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        dif_to_profit_map = {difficulty[i]:profit[i] for i in range(len(difficulty))}\\n        difficulty = sorted(difficulty)\\n        max_ = 0\\n        for i in difficulty:\\n            max_ = max(max_, dif_to_profit_map[i])\\n            dif_to_profit_map[i] = max_\\n\\n        def bs(arr, s, e, t):\\n            if s > e:\\n                return -1\\n            \\n            mid = (s + e) // 2\\n            \\n            if arr[mid] > t:\\n                return bs(arr, s, mid-1, t)\\n            \\n            elif arr[mid] <= t:\\n                if mid == len(arr)-1: return mid\\n                \\n                elif arr[mid+1] > t: return mid\\n                \\n                else: return bs(arr, mid+1, e, t) \\n                \\n        sol = 0\\n        for i in worker:\\n            ind = bs(difficulty, 0, len(difficulty), i)\\n            if ind != -1:\\n                sol += dif_to_profit_map[difficulty[ind]]\\n        \\n        return sol\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        dif_to_profit_map = {difficulty[i]:profit[i] for i in range(len(difficulty))}",
                "codeTag": "Java"
            },
            {
                "id": 4013864,
                "title": "c-solution-using-sorting",
                "content": "# Intuition\\n- Here a worker can perform any task whose difficulty is less than or equal to the ability of our worker\\n- So we need to sort the array and find the max profit that we can get for a worker with ability worker[i]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> nums(n);\\n        for(int i=0;i<n;i++){\\n            nums[i] = {difficulty[i],profit[i]};\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        int maxProfit = 0;\\n        int tempprofit = 0;\\n        for( int i = 0 , j = 0 ; i < n ; i++ ){\\n            while(j<n && nums[j].first <= worker[i]){\\n                tempprofit = max(nums[j].second,tempprofit);    // stores max profit for all tasks having dificilty <= worker[i]\\n                j++;\\n            }\\n            if(j>0 && nums[j-1].first<=worker[i])\\n                maxProfit += tempprofit;\\n        }\\n\\n        return maxProfit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> nums(n);\\n        for(int i=0;i<n;i++){\\n            nums[i] = {difficulty[i],profit[i]};\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        int maxProfit = 0;\\n        int tempprofit = 0;\\n        for( int i = 0 , j = 0 ; i < n ; i++ ){\\n            while(j<n && nums[j].first <= worker[i]){\\n                tempprofit = max(nums[j].second,tempprofit);    // stores max profit for all tasks having dificilty <= worker[i]\\n                j++;\\n            }\\n            if(j>0 && nums[j-1].first<=worker[i])\\n                maxProfit += tempprofit;\\n        }\\n\\n        return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918050,
                "title": "java-17ms-execution-time-beats-80-in-time-and-97-in-space-taken",
                "content": "# Intuition\\n- sorting\\n- binary search for getting max difficult work\\n\\n# Approach\\n- sort according to difficulty level of work\\n- get index what maximum difficulty level work user can do using binary search\\n- maintain maxProfit possible at a difficulty level(cover less difficult level profit as well because less difficult work can also have more profilt compare to higher difficulties)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static class Pair implements Comparable<Pair> {\\n            int dif;\\n            int pro;\\n            Pair (int dif, int pro) //constructor \\n            {\\n                this.dif = dif;\\n                this.pro = pro;\\n            }\\n            public int compareTo(Pair other) //making it only compare dif values\\n            {\\n                return this.dif - other.dif;\\n            }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int len = difficulty.length;\\n        Pair[] pairs = new Pair[len];\\n        for (int i=0; i< len; i++){\\n            pairs[i] = new Pair(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(pairs);\\n        \\n        int maxProfit = 0;\\n        //get max profit from possible difficulty work\\n        int maxSoFar[] = new int[len];\\n        maxSoFar[0] = pairs[0].pro;\\n        for(int i = 1; i < len; i++) {\\n            if (pairs[i].pro > maxSoFar[i-1]) {\\n                maxSoFar[i] = pairs[i].pro;\\n            } else {\\n                maxSoFar[i] = maxSoFar[i-1];\\n            }\\n        }\\n\\n        //System.out.println(\"checking workers cap now....\");\\n\\n        for(int i = 0; i<worker.length; i++) {\\n            int index = getIndex(worker[i], pairs, len);\\n            //System.out.println(\"index: \" + index + \" for item: \" + worker[i]);\\n\\n            if(index != -1) {\\n                 maxProfit += maxSoFar[index];;\\n            }\\n           \\n        }\\n        return maxProfit;\\n    }\\n\\n    private int getIndex(int cap, Pair []pair, int len) {\\n        int low = 0;\\n        int high = len-1;\\n        while (low <= high) {\\n            int mid = (high+low)/2;\\n            if (pair[mid].dif == cap ) {\\n                //Check for same items\\n                while(mid < high && pair[mid+1].dif == cap) mid ++;\\n                return mid;\\n            } else if (pair[mid].dif < cap) {\\n                low = mid+1 ;\\n            } else if (pair[mid].dif > cap) {\\n                high = mid-1 ;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static class Pair implements Comparable<Pair> {\\n            int dif;\\n            int pro;\\n            Pair (int dif, int pro) //constructor \\n            {\\n                this.dif = dif;\\n                this.pro = pro;\\n            }\\n            public int compareTo(Pair other) //making it only compare dif values\\n            {\\n                return this.dif - other.dif;\\n            }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int len = difficulty.length;\\n        Pair[] pairs = new Pair[len];\\n        for (int i=0; i< len; i++){\\n            pairs[i] = new Pair(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(pairs);\\n        \\n        int maxProfit = 0;\\n        //get max profit from possible difficulty work\\n        int maxSoFar[] = new int[len];\\n        maxSoFar[0] = pairs[0].pro;\\n        for(int i = 1; i < len; i++) {\\n            if (pairs[i].pro > maxSoFar[i-1]) {\\n                maxSoFar[i] = pairs[i].pro;\\n            } else {\\n                maxSoFar[i] = maxSoFar[i-1];\\n            }\\n        }\\n\\n        //System.out.println(\"checking workers cap now....\");\\n\\n        for(int i = 0; i<worker.length; i++) {\\n            int index = getIndex(worker[i], pairs, len);\\n            //System.out.println(\"index: \" + index + \" for item: \" + worker[i]);\\n\\n            if(index != -1) {\\n                 maxProfit += maxSoFar[index];;\\n            }\\n           \\n        }\\n        return maxProfit;\\n    }\\n\\n    private int getIndex(int cap, Pair []pair, int len) {\\n        int low = 0;\\n        int high = len-1;\\n        while (low <= high) {\\n            int mid = (high+low)/2;\\n            if (pair[mid].dif == cap ) {\\n                //Check for same items\\n                while(mid < high && pair[mid+1].dif == cap) mid ++;\\n                return mid;\\n            } else if (pair[mid].dif < cap) {\\n                low = mid+1 ;\\n            } else if (pair[mid].dif > cap) {\\n                high = mid-1 ;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581906,
                "title": "java-javascript-c-c-solution",
                "content": "**Java**\\n```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n\\n    private record Job(int difficulty, int profit) {}\\n\\n    public int maxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker) {\\n        int totalJobs = jobDifficulty.length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Arrays.sort(jobs, (x, y) -> x.difficulty - y.difficulty);\\n        Arrays.sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (int difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} jobDifficulty\\n * @param {number[]} jobProfit\\n * @param {number[]} maxDifficultyPerWorker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function (jobDifficulty, jobProfit, maxDifficultyPerWorker) {\\n    const totalJobs = jobDifficulty.length;\\n    const jobs = new Array(totalJobs);\\n    for (let i = 0; i < totalJobs; ++i) {\\n        jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n    }\\n\\n    jobs.sort((x, y) => x.difficulty - y.difficulty);\\n    maxDifficultyPerWorker.sort((x, y) => x - y);\\n\\n    let index = 0;\\n    let totalMaxProfit = 0;\\n    let currentMaxProfit = 0;\\n\\n    for (let difficulty of maxDifficultyPerWorker) {\\n        while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n            currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n            ++index;\\n        }\\n        totalMaxProfit += currentMaxProfit;\\n    }\\n\\n    return totalMaxProfit;\\n};\\n\\nfunction Job(difficulty, profit) {\\n    this.difficulty = difficulty;\\n    this.profit = profit;\\n}\\n```\\n**C++**\\n```\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Job {\\n        int difficulty;\\n        int profit;\\n        Job() = default;\\n        Job(int difficulty, int profit) : difficulty {difficulty}, profit {profit}{}\\n    };\\n\\npublic:\\n    int maxProfitAssignment(vector<int>& jobDifficulty, vector<int>& jobProfit, vector<int>& maxDifficultyPerWorker) const {\\n        int totalJobs = jobDifficulty.size();\\n        vector<Job>jobs(totalJobs);\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i].difficulty = jobDifficulty[i];\\n            jobs[i].profit = jobProfit[i];\\n        }\\n        const auto compare = [](const Job& first, const Job& second) {return first.difficulty < second.difficulty;};\\n        //C++20: std::ranages::sort(jobs, compare) \\n        //       std::ranages::sort(maxDifficultyPerWorker)  \\n        sort(jobs.begin(), jobs.end(), compare);\\n        sort(maxDifficultyPerWorker.begin(), maxDifficultyPerWorker.end());\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (const auto& difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n};\\n```\\n**C#**\\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    private struct Job\\n    {\\n        public int difficulty;\\n        public int profit;\\n        public Job(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n    public int MaxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker)\\n    {\\n        int totalJobs = jobDifficulty.Length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i)\\n        {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Array.Sort(jobs, (x, y) => x.difficulty - y.difficulty);\\n        Array.Sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        foreach (var difficulty in maxDifficultyPerWorker)\\n        {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty)\\n            {\\n                currentMaxProfit = Math.Max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n\\n    private record Job(int difficulty, int profit) {}\\n\\n    public int maxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker) {\\n        int totalJobs = jobDifficulty.length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Arrays.sort(jobs, (x, y) -> x.difficulty - y.difficulty);\\n        Arrays.sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (int difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} jobDifficulty\\n * @param {number[]} jobProfit\\n * @param {number[]} maxDifficultyPerWorker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function (jobDifficulty, jobProfit, maxDifficultyPerWorker) {\\n    const totalJobs = jobDifficulty.length;\\n    const jobs = new Array(totalJobs);\\n    for (let i = 0; i < totalJobs; ++i) {\\n        jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n    }\\n\\n    jobs.sort((x, y) => x.difficulty - y.difficulty);\\n    maxDifficultyPerWorker.sort((x, y) => x - y);\\n\\n    let index = 0;\\n    let totalMaxProfit = 0;\\n    let currentMaxProfit = 0;\\n\\n    for (let difficulty of maxDifficultyPerWorker) {\\n        while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n            currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n            ++index;\\n        }\\n        totalMaxProfit += currentMaxProfit;\\n    }\\n\\n    return totalMaxProfit;\\n};\\n\\nfunction Job(difficulty, profit) {\\n    this.difficulty = difficulty;\\n    this.profit = profit;\\n}\\n```\n```\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Job {\\n        int difficulty;\\n        int profit;\\n        Job() = default;\\n        Job(int difficulty, int profit) : difficulty {difficulty}, profit {profit}{}\\n    };\\n\\npublic:\\n    int maxProfitAssignment(vector<int>& jobDifficulty, vector<int>& jobProfit, vector<int>& maxDifficultyPerWorker) const {\\n        int totalJobs = jobDifficulty.size();\\n        vector<Job>jobs(totalJobs);\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i].difficulty = jobDifficulty[i];\\n            jobs[i].profit = jobProfit[i];\\n        }\\n        const auto compare = [](const Job& first, const Job& second) {return first.difficulty < second.difficulty;};\\n        //C++20: std::ranages::sort(jobs, compare) \\n        //       std::ranages::sort(maxDifficultyPerWorker)  \\n        sort(jobs.begin(), jobs.end(), compare);\\n        sort(maxDifficultyPerWorker.begin(), maxDifficultyPerWorker.end());\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (const auto& difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n};\\n```\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    private struct Job\\n    {\\n        public int difficulty;\\n        public int profit;\\n        public Job(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n    public int MaxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker)\\n    {\\n        int totalJobs = jobDifficulty.Length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i)\\n        {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Array.Sort(jobs, (x, y) => x.difficulty - y.difficulty);\\n        Array.Sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        foreach (var difficulty in maxDifficultyPerWorker)\\n        {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty)\\n            {\\n                currentMaxProfit = Math.Max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3481572,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, l = 0, p = 0;\\n        vector<pair<int, int>> pairs;\\n        for(int i = 0; i < n; i++) pairs.emplace_back(difficulty[i], profit[i]);\\n        sort(pairs.begin(), pairs.end());\\n        sort(worker.begin(), worker.end());\\n        for(int &w: worker){\\n            while(l < n && w >= pairs[l].first){\\n                p = max(p, pairs[l++].second);\\n            }\\n            res += p;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(profit, difficulty), reverse=True)\\n        worker.sort()\\n        total_profit = 0\\n\\n        for prof, diff in jobs:\\n            while worker and diff <= worker[-1]:\\n                total_profit += prof\\n                worker.pop()\\n            if not worker:\\n                break\\n\\n        return total_profit\\n```\\n\\n```Java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=0;\\n        for(int d:difficulty)\\n            max = Math.max(max, d);\\n        int[] dp = new int[max+1];\\n        for(int i=0;i<difficulty.length;i++) \\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        for(int i=1;i<=max;i++)\\n            dp[i] = Math.max(dp[i-1], dp[i]);\\n        int ans=0;\\n        for(int w:worker)\\n        {\\n            if(w>max) ans+=dp[max];\\n            else ans+=dp[w];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, l = 0, p = 0;\\n        vector<pair<int, int>> pairs;\\n        for(int i = 0; i < n; i++) pairs.emplace_back(difficulty[i], profit[i]);\\n        sort(pairs.begin(), pairs.end());\\n        sort(worker.begin(), worker.end());\\n        for(int &w: worker){\\n            while(l < n && w >= pairs[l].first){\\n                p = max(p, pairs[l++].second);\\n            }\\n            res += p;\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(profit, difficulty), reverse=True)\\n        worker.sort()\\n        total_profit = 0\\n\\n        for prof, diff in jobs:\\n            while worker and diff <= worker[-1]:\\n                total_profit += prof\\n                worker.pop()\\n            if not worker:\\n                break\\n\\n        return total_profit\\n```\n```Java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=0;\\n        for(int d:difficulty)\\n            max = Math.max(max, d);\\n        int[] dp = new int[max+1];\\n        for(int i=0;i<difficulty.length;i++) \\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        for(int i=1;i<=max;i++)\\n            dp[i] = Math.max(dp[i-1], dp[i]);\\n        int ans=0;\\n        for(int w:worker)\\n        {\\n            if(w>max) ans+=dp[max];\\n            else ans+=dp[w];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481270,
                "title": "no-binary-search-python-3-explainedd",
                "content": "Sort the array on the basis of profit (desc order) instead of difficulty after zipping them togther\\nAlso sort the worker array in descending order\\nNow if a task difficulty > worker[i] -> this task cant be done by any other worker too so j + 1\\nif difficulty < worker[i] => this task can be done i + 1.\\n`why not j + 1 here?` Because one task can be done by multiple workers\\n# Code\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, d: List[int], p: List[int], w: List[int]) -> int:\\n        task = list(zip(d, p))\\n        t = sorted(task, key=lambda x:-x[1])\\n        w.sort(reverse=True)\\n        profit = 0\\n        i = 0\\n        j = 0\\n        while i < len(w) and j < len(t):\\n            if w[i] < t[j][0]:\\n                j += 1\\n            else:\\n                profit += t[j][1]\\n                i += 1 \\n        return profit\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, d: List[int], p: List[int], w: List[int]) -> int:\\n        task = list(zip(d, p))\\n        t = sorted(task, key=lambda x:-x[1])\\n        w.sort(reverse=True)\\n        profit = 0\\n        i = 0\\n        j = 0\\n        while i < len(w) and j < len(t):\\n            if w[i] < t[j][0]:\\n                j += 1\\n            else:\\n                profit += t[j][1]\\n                i += 1 \\n        return profit\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370476,
                "title": "sort-binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size() , m = worker.size();\\n        vector<pair<int,int>> arr(n);   \\n        for(int i=0;i<n;i++) {\\n            arr[i] = {difficulty[i] , profit[i]};\\n        }\\n        sort(arr.begin() , arr.end());\\n        int ans = 0;\\n        // for(auto &i : arr) {\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        for(int i=0;i<m;i++) {\\n            int low = 0, high = n-1;\\n            int res = -1;\\n            while(low <= high) {\\n                int mid = low + (high-low) / 2;\\n                if(arr[mid].first <= worker[i]) {\\n                    res = mid;\\n                    low = mid+1;\\n                }\\n                else high = mid - 1;\\n            }\\n            if(res != -1) {\\n                int mx = 0;\\n                for(int i=0;i<=res;i++) {\\n                    mx = max(mx,arr[i].second);\\n                }\\n                ans += mx;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size() , m = worker.size();\\n        vector<pair<int,int>> arr(n);   \\n        for(int i=0;i<n;i++) {\\n            arr[i] = {difficulty[i] , profit[i]};\\n        }\\n        sort(arr.begin() , arr.end());\\n        int ans = 0;\\n        // for(auto &i : arr) {\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        for(int i=0;i<m;i++) {\\n            int low = 0, high = n-1;\\n            int res = -1;\\n            while(low <= high) {\\n                int mid = low + (high-low) / 2;\\n                if(arr[mid].first <= worker[i]) {\\n                    res = mid;\\n                    low = mid+1;\\n                }\\n                else high = mid - 1;\\n            }\\n            if(res != -1) {\\n                int mx = 0;\\n                for(int i=0;i<=res;i++) {\\n                    mx = max(mx,arr[i].second);\\n                }\\n                ans += mx;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3369923,
                "title": "python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        d = {}\\n        # mapping the difficulty with the corresponding profit and then storing it in the dictionary\\n        for x in range(len(difficulty)) :\\n            if difficulty[x] in d :\\n                d[difficulty[x]] = max( d[difficulty[x]] , profit[x])  # overwriting with highest value\\n            else:\\n                d[difficulty[x]] = profit[x]\\n\\n        # sorting the dictionary with respect to key\\n        dic = dict(sorted(d.items()))\\n        # sorting the difficulty also\\n        difficulty.sort()\\n    \\n        # now reassigning the profit with the max profit so far after sorting \\n        maxi = 0\\n        for x in dic.keys():\\n            maxi = max(maxi , dic[x] )\\n            dic[x] = maxi\\n            \\n        # calculating the total profit\\n        tot = 0\\n        for i in range(len(worker)) : \\n            # calculate the right position for the difficulty level of the workers\\n            r = bisect.bisect_left(difficulty,worker[i]) \\n            # if the position is at 0 then add the 0th profit only if the difficulty is equal \\n            if r==0: \\n                if difficulty[r] == worker[i] :\\n                    tot += dic[difficulty[r]]\\n                else:\\n                    tot += 0\\n            # if the difficulty is equal then add that profit \\n            elif r<len(difficulty) and difficulty[r] == worker[i] :\\n                tot += dic[difficulty[r]]\\n            # if the difficulty is not equal then add the previous profit \\n            else:\\n                tot += dic[difficulty[r-1]]\\n        return tot\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        d = {}\\n        # mapping the difficulty with the corresponding profit and then storing it in the dictionary\\n        for x in range(len(difficulty)) :\\n            if difficulty[x] in d :\\n                d[difficulty[x]] = max( d[difficulty[x]] , profit[x])  # overwriting with highest value\\n            else:\\n                d[difficulty[x]] = profit[x]\\n\\n        # sorting the dictionary with respect to key\\n        dic = dict(sorted(d.items()))\\n        # sorting the difficulty also\\n        difficulty.sort()\\n    \\n        # now reassigning the profit with the max profit so far after sorting \\n        maxi = 0\\n        for x in dic.keys():\\n            maxi = max(maxi , dic[x] )\\n            dic[x] = maxi\\n            \\n        # calculating the total profit\\n        tot = 0\\n        for i in range(len(worker)) : \\n            # calculate the right position for the difficulty level of the workers\\n            r = bisect.bisect_left(difficulty,worker[i]) \\n            # if the position is at 0 then add the 0th profit only if the difficulty is equal \\n            if r==0: \\n                if difficulty[r] == worker[i] :\\n                    tot += dic[difficulty[r]]\\n                else:\\n                    tot += 0\\n            # if the difficulty is equal then add that profit \\n            elif r<len(difficulty) and difficulty[r] == worker[i] :\\n                tot += dic[difficulty[r]]\\n            # if the difficulty is not equal then add the previous profit \\n            else:\\n                tot += dic[difficulty[r-1]]\\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316606,
                "title": "binary-search-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int>prefix;\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = diff.size();\\n        vector<pair<int,int>>v;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int difficulty = diff[i];\\n            int prof = profit[i];\\n            v.push_back(make_pair(difficulty,prof));\\n        }\\n        sort(v.begin(),v.end());\\n\\n        prefix.push_back(v[0].second);\\n        for(int i=1;i<v.size();i++)\\n        {\\n            int val = max(prefix[i-1],v[i].second);\\n            prefix.push_back(val);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int target = worker[i];\\n            binary_search_(v,0,v.size()-1,target,ans);\\n        }\\n        return ans;\\n    }\\n    void binary_search_(vector<pair<int,int>>&v,int start,int end,int targetdiff,int &ans)\\n    {\\n        int val = 0;\\n        while(start<=end)\\n        {\\n            int mid = (start + ((end - start)/2));\\n\\n            if(targetdiff == v[mid].first)\\n            {\\n               val = max(val,prefix[mid]);\\n               start = mid+1;        \\n            }\\n            else if(targetdiff > v[mid].first)\\n            {\\n                val = max(val,prefix[mid]);\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(start>=0 and start<v.size() and v[start].first <= targetdiff)\\n        val = max(val,prefix[start]);\\n\\n        if(end>=0 and end<v.size() and v[end].first <= targetdiff)\\n        val = max(val,prefix[end]);\\n\\n        ans = ans + val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int>prefix;\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = diff.size();\\n        vector<pair<int,int>>v;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int difficulty = diff[i];\\n            int prof = profit[i];\\n            v.push_back(make_pair(difficulty,prof));\\n        }\\n        sort(v.begin(),v.end());\\n\\n        prefix.push_back(v[0].second);\\n        for(int i=1;i<v.size();i++)\\n        {\\n            int val = max(prefix[i-1],v[i].second);\\n            prefix.push_back(val);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int target = worker[i];\\n            binary_search_(v,0,v.size()-1,target,ans);\\n        }\\n        return ans;\\n    }\\n    void binary_search_(vector<pair<int,int>>&v,int start,int end,int targetdiff,int &ans)\\n    {\\n        int val = 0;\\n        while(start<=end)\\n        {\\n            int mid = (start + ((end - start)/2));\\n\\n            if(targetdiff == v[mid].first)\\n            {\\n               val = max(val,prefix[mid]);\\n               start = mid+1;        \\n            }\\n            else if(targetdiff > v[mid].first)\\n            {\\n                val = max(val,prefix[mid]);\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(start>=0 and start<v.size() and v[start].first <= targetdiff)\\n        val = max(val,prefix[start]);\\n\\n        if(end>=0 and end<v.size() and v[end].first <= targetdiff)\\n        val = max(val,prefix[end]);\\n\\n        ans = ans + val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955918,
                "title": "easy-and-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs per question we have to maximize the profit \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo just make a pair of profit and it\\'s difficulty arrange the pair in ascending order take an iterator and put it in the last index of the pair and do the same thing for worker apply the condition as I have applied in my solution and you will get the required output, If you like this kindly Upvote.     \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)+O(mlogm)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        int n=difficulty.size(),m=worker.size();\\n        vector<pair<int,int>>jobs(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs[i].first=profit[i];\\n            jobs[i].second=difficulty[i];\\n        }\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(),worker.end());\\n        int j=m-1,i=n-1,sum=0;\\n        while(j>=0&&i>=0)\\n        {\\n          if(worker[j]>=jobs[i].second)\\n          {\\n              sum+=jobs[i].first;\\n              j--;\\n          }\\n          else\\n          {\\n              i--;\\n          }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        int n=difficulty.size(),m=worker.size();\\n        vector<pair<int,int>>jobs(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs[i].first=profit[i];\\n            jobs[i].second=difficulty[i];\\n        }\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(),worker.end());\\n        int j=m-1,i=n-1,sum=0;\\n        while(j>=0&&i>=0)\\n        {\\n          if(worker[j]>=jobs[i].second)\\n          {\\n              sum+=jobs[i].first;\\n              j--;\\n          }\\n          else\\n          {\\n              i--;\\n          }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761062,
                "title": "python-binary-search-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \"\"\"\\n        idea: \\n        - zip difficulty and profit\\n        -   sort by difficulty \\n        \\n        - iterate through each worker\\'s ability (worker)\\n        - find the greatest difficulty using binary search , returning the high (bisect right)\\n        -    max_profit += profit_of_worker[index found with binary search]\\n        \"\"\"\\n        diff_prof = [list(i) for i in zip(difficulty, profit)]\\n        diff_prof.sort(key = lambda x: x[0])\\n\\t\\t\\n        # need to make profit be the max up to i\\n        prev = diff_prof[0][1]\\n        for i in range(len(diff_prof)):\\n            diff_prof[i][1] = max(diff_prof[i][1], prev)\\n            prev = diff_prof[i][1]\\n\\n        max_profit = 0\\n        for ability in worker:\\n            index = self.binary_search(diff_prof, ability)\\n            if index >= 0 and index < len(diff_prof):\\n                max_profit += diff_prof[index][1]\\n        return max_profit\\n                \\n            \\n    def binary_search(self, diff_prof: List, ability: int) -> int:\\n        lo, hi = 0 , len(diff_prof) - 1\\n        index = -1\\n        while lo <= hi:\\n            mid = (lo + (hi - lo)//2)\\n            #mid = (hi + lo) // 2\\n            if diff_prof[mid][0] <= ability:\\n                # save index of what a worker can do up to\\n                index = mid \\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return index\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \"\"\"\\n        idea: \\n        - zip difficulty and profit\\n        -   sort by difficulty \\n        \\n        - iterate through each worker\\'s ability (worker)\\n        - find the greatest difficulty using binary search , returning the high (bisect right)\\n        -    max_profit += profit_of_worker[index found with binary search]\\n        \"\"\"\\n        diff_prof = [list(i) for i in zip(difficulty, profit)]\\n        diff_prof.sort(key = lambda x: x[0])\\n\\t\\t\\n        # need to make profit be the max up to i\\n        prev = diff_prof[0][1]\\n        for i in range(len(diff_prof)):\\n            diff_prof[i][1] = max(diff_prof[i][1], prev)\\n            prev = diff_prof[i][1]\\n\\n        max_profit = 0\\n        for ability in worker:\\n            index = self.binary_search(diff_prof, ability)\\n            if index >= 0 and index < len(diff_prof):\\n                max_profit += diff_prof[index][1]\\n        return max_profit\\n                \\n            \\n    def binary_search(self, diff_prof: List, ability: int) -> int:\\n        lo, hi = 0 , len(diff_prof) - 1\\n        index = -1\\n        while lo <= hi:\\n            mid = (lo + (hi - lo)//2)\\n            #mid = (hi + lo) // 2\\n            if diff_prof[mid][0] <= ability:\\n                # save index of what a worker can do up to\\n                index = mid \\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758748,
                "title": "c-prefixsum-sorting-binarysearch-tc-o-m-n-logn-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> v;\\n        int n = profit.size();\\n        int m = worker.size();\\n        for(int i = 0; i<n; i++) {\\n            v.push_back({difficulty[i], profit[i]});\\n        }\\n        // Sort the arrays according to lowest difficulty\\n        sort(v.begin(), v.end());\\n       // Now, we will find the job max difficulty which each worker can perform.\\n\\t   // Lets say, in this sortedArray, it comes out to be index 5.\\n\\t   // Since, we do not have the array sorted by profit, we cannot know what is the maxProfit achievable from job with atmost this difficulty.\\n\\t  // Hence, we find the max of Profits at this point. Kind of like how we maintain the prefix Sum.\\n\\t   vector<int> maxProfit(n);\\n        maxProfit[0] = v[0].second;\\n        for(int i = 1; i<n; i++)\\n            maxProfit[i] = max(maxProfit[i-1], v[i].second);\\n       \\n        int output = 0;\\n        \\n        for(int i = 0; i<m; i++) {\\n            int lo = 0, hi = n;\\n\\t\\t\\t// Finding the max index which has difficulty less than equal to worker\\'s calibre.\\\\\\n\\t\\t\\t// Classical maximisation problem of Binary Search.\\n            while(hi - lo > 1) {\\n                int mid = lo + (hi-lo)/2;\\n                if(v[mid].first <= worker[i]) {\\n                    lo = mid;\\n                } else {\\n                    hi = mid;\\n                }\\n            }\\n            int idx = hi-1;\\n            if(v[idx].first <= worker[i])\\n                output += maxProfit[idx];\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> v;\\n        int n = profit.size();\\n        int m = worker.size();\\n        for(int i = 0; i<n; i++) {\\n            v.push_back({difficulty[i], profit[i]});\\n        }\\n        // Sort the arrays according to lowest difficulty\\n        sort(v.begin(), v.end());\\n       // Now, we will find the job max difficulty which each worker can perform.\\n\\t   // Lets say, in this sortedArray, it comes out to be index 5.\\n\\t   // Since, we do not have the array sorted by profit, we cannot know what is the maxProfit achievable from job with atmost this difficulty.\\n\\t  // Hence, we find the max of Profits at this point. Kind of like how we maintain the prefix Sum.\\n\\t   vector<int> maxProfit(n);\\n        maxProfit[0] = v[0].second;\\n        for(int i = 1; i<n; i++)\\n            maxProfit[i] = max(maxProfit[i-1], v[i].second);\\n       \\n        int output = 0;\\n        \\n        for(int i = 0; i<m; i++) {\\n            int lo = 0, hi = n;\\n\\t\\t\\t// Finding the max index which has difficulty less than equal to worker\\'s calibre.\\\\\\n\\t\\t\\t// Classical maximisation problem of Binary Search.\\n            while(hi - lo > 1) {\\n                int mid = lo + (hi-lo)/2;\\n                if(v[mid].first <= worker[i]) {\\n                    lo = mid;\\n                } else {\\n                    hi = mid;\\n                }\\n            }\\n            int idx = hi-1;\\n            if(v[idx].first <= worker[i])\\n                output += maxProfit[idx];\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634281,
                "title": "java-solution-95-faster-method-1-prefix-sum-counting-sort-method-2-treemap",
                "content": "### **Method 1 - Counting-Sort & Prefix-Sum (Faster than 95percent)**\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max=0;\\n        for(int x:difficulty)\\n        {\\n            if(x>max)\\n                max=x;\\n        }\\n        \\n        int[] a = new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(a[difficulty[i]]<profit[i])\\n            a[difficulty[i]] = profit[i];\\n        }\\n        \\n        max=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]>max)\\n                max=a[i];\\n            else\\n                a[i]=max;\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            if(x>=a.length)\\n                x=a.length-1;\\n            sum+=a[x];\\n        }\\n        return sum;\\n    }\\n}\\n```\\n###  **Method 2 - Binary Search using TreeMap**\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Map<Integer,Integer> map  = new TreeMap<>();\\n       \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(map.get(difficulty[i])==null || map.get(difficulty[i])<profit[i])\\n            map.put(difficulty[i],profit[i]);\\n        }\\n        \\n        ArrayList<Integer> keys = new ArrayList<>(map.keySet());\\n        \\n        int max=0;\\n        for(var entry: map.entrySet())\\n        {\\n            int key = entry.getKey();\\n            int value = entry.getValue();\\n            \\n            if(value>max)\\n            {\\n                max = value;\\n            }\\n            else{\\n                map.put(key,max);\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            int idx = Collections.binarySearch(keys,x);\\n            if(idx<0)\\n            {\\n                idx = -1*(idx+1);\\n                idx--;\\n            }\\n            if(idx>=0)\\n            sum+=map.get(keys.get(idx));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max=0;\\n        for(int x:difficulty)\\n        {\\n            if(x>max)\\n                max=x;\\n        }\\n        \\n        int[] a = new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(a[difficulty[i]]<profit[i])\\n            a[difficulty[i]] = profit[i];\\n        }\\n        \\n        max=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]>max)\\n                max=a[i];\\n            else\\n                a[i]=max;\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            if(x>=a.length)\\n                x=a.length-1;\\n            sum+=a[x];\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Map<Integer,Integer> map  = new TreeMap<>();\\n       \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(map.get(difficulty[i])==null || map.get(difficulty[i])<profit[i])\\n            map.put(difficulty[i],profit[i]);\\n        }\\n        \\n        ArrayList<Integer> keys = new ArrayList<>(map.keySet());\\n        \\n        int max=0;\\n        for(var entry: map.entrySet())\\n        {\\n            int key = entry.getKey();\\n            int value = entry.getValue();\\n            \\n            if(value>max)\\n            {\\n                max = value;\\n            }\\n            else{\\n                map.put(key,max);\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            int idx = Collections.binarySearch(keys,x);\\n            if(idx<0)\\n            {\\n                idx = -1*(idx+1);\\n                idx--;\\n            }\\n            if(idx>=0)\\n            sum+=map.get(keys.get(idx));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497557,
                "title": "cpp-binary-search-lowerbound-greedy",
                "content": "```\\n//time complexity-mlogn\\n//first we wiil sort the array according to difficulty and store max profit according to diificulty\\n//find the lowerbound of capacity of current worker and add max profit to the answer\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    \\n        int n=profit.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++) v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        vector<int> mx(n);\\n        mx[0]=(v[0].second);\\n        //storin max profit at ith index\\n        for(int i=1;i<n;i++)\\n            mx[i]=max(mx[i-1],v[i].second);\\n        \\n        int m=worker.size();\\n        int ans(0);\\n        for(int i=0;i<m;i++){\\n            int key=worker[i];\\n            int l(0),h(n-1),mid;\\n            while(h-l>1){\\n                mid=l+(h-l)/2;\\n                if(v[mid].first<key) l=mid+1;\\n                else h=mid;\\n            }\\n            int ind=-1;\\n            if(v[l].first>=key) ind=l;\\n            else if(v[h].first>=key) ind=h;\\n            \\n            //if there is no lowerbound then worker can work at any capacity then we will take maximum profit\\n            if(ind==-1) ans+=mx[n-1];\\n            else if(v[ind].first==key){\\n                while(ind<n && v[ind].first==key) ind++;\\n                ans+=mx[ind-1];\\n            } \\n            else if(v[ind].first>key) ans+=(ind-1>=0)?mx[ind-1]:0;\\n        }\\n        return ans;\\n    }\\n};\\nif you like the solution please upvote and like it.\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\n//time complexity-mlogn\\n//first we wiil sort the array according to difficulty and store max profit according to diificulty\\n//find the lowerbound of capacity of current worker and add max profit to the answer\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    \\n        int n=profit.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++) v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        vector<int> mx(n);\\n        mx[0]=(v[0].second);\\n        //storin max profit at ith index\\n        for(int i=1;i<n;i++)\\n            mx[i]=max(mx[i-1],v[i].second);\\n        \\n        int m=worker.size();\\n        int ans(0);\\n        for(int i=0;i<m;i++){\\n            int key=worker[i];\\n            int l(0),h(n-1),mid;\\n            while(h-l>1){\\n                mid=l+(h-l)/2;\\n                if(v[mid].first<key) l=mid+1;\\n                else h=mid;\\n            }\\n            int ind=-1;\\n            if(v[l].first>=key) ind=l;\\n            else if(v[h].first>=key) ind=h;\\n            \\n            //if there is no lowerbound then worker can work at any capacity then we will take maximum profit\\n            if(ind==-1) ans+=mx[n-1];\\n            else if(v[ind].first==key){\\n                while(ind<n && v[ind].first==key) ind++;\\n                ans+=mx[ind-1];\\n            } \\n            else if(v[ind].first>key) ans+=(ind-1>=0)?mx[ind-1]:0;\\n        }\\n        return ans;\\n    }\\n};\\nif you like the solution please upvote and like it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328533,
                "title": "segment-tree-c-solution",
                "content": "**Prerequisite -> Segment trees theory.** \\n[**This**](https://www.youtube.com/watch?v=2FShdqn-Oz8&t=2355s) video greatly helped me understand segment trees. Errichto is awesome :)\\n\\n**C++**\\n```\\nclass Solution {\\n    vector<int> tree;\\n    int getMax(int i, int l, int r, int ql, int qr){\\n        if(ql<=l && r<=qr) return tree[i];\\n        if(qr<l || ql>r) return -1;\\n        int midl=l+((r-l)>>1);\\n        return max(getMax(i<<1, l, midl, ql, qr), getMax((i<<1)+1, midl+1, r, ql, qr));\\n    }\\n    inline int countOnes(int n){ //count total set bits in an integer\\n        int c=0;\\n        while(n) c+=1, n=n&(n-1);\\n        return c;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size(), cost=0;\\n        vector<pair<int, int>> p;\\n        for(int i=0; i<n; i++)\\n            p.push_back({difficulty[i], profit[i]});\\n        sort(p.begin(), p.end());\\n        while(countOnes(n)!=1){ //while n is not a power of 2 (we are basically padding the vector p with zeroes to have a size thats a power of 2).\\n            p.push_back({(int)1000000, 0});\\n            n++;\\n        }\\n        tree=vector<int>(n<<1); //n<<1 means n*2\\n        for(int i=0; i<n; i++) tree[i+n]=p[i].second;\\n        for(int i=n-1; i>=1; i--) tree[i]=max(tree[i<<1],tree[(i<<1)+1]);\\n        for(auto &i: worker) if(i>=p[0].first){\\n            int a=0, b=n-1;\\n            while(a<b){\\n                int mid=b+(a-b)/2;\\n                p[mid].first>i?\\n                    b=mid-1:\\n                    a=mid;\\n            }\\n            cost+=getMax(1, 0, n-1, 0, a); //getMax() will give max values in the range [0,a].\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> tree;\\n    int getMax(int i, int l, int r, int ql, int qr){\\n        if(ql<=l && r<=qr) return tree[i];\\n        if(qr<l || ql>r) return -1;\\n        int midl=l+((r-l)>>1);\\n        return max(getMax(i<<1, l, midl, ql, qr), getMax((i<<1)+1, midl+1, r, ql, qr));\\n    }\\n    inline int countOnes(int n){ //count total set bits in an integer\\n        int c=0;\\n        while(n) c+=1, n=n&(n-1);\\n        return c;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size(), cost=0;\\n        vector<pair<int, int>> p;\\n        for(int i=0; i<n; i++)\\n            p.push_back({difficulty[i], profit[i]});\\n        sort(p.begin(), p.end());\\n        while(countOnes(n)!=1){ //while n is not a power of 2 (we are basically padding the vector p with zeroes to have a size thats a power of 2).\\n            p.push_back({(int)1000000, 0});\\n            n++;\\n        }\\n        tree=vector<int>(n<<1); //n<<1 means n*2\\n        for(int i=0; i<n; i++) tree[i+n]=p[i].second;\\n        for(int i=n-1; i>=1; i--) tree[i]=max(tree[i<<1],tree[(i<<1)+1]);\\n        for(auto &i: worker) if(i>=p[0].first){\\n            int a=0, b=n-1;\\n            while(a<b){\\n                int mid=b+(a-b)/2;\\n                p[mid].first>i?\\n                    b=mid-1:\\n                    a=mid;\\n            }\\n            cost+=getMax(1, 0, n-1, 0, a); //getMax() will give max values in the range [0,a].\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272936,
                "title": "java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(b[1]-a[1]));\\n        for(int i=0;i<profit.length;i++)\\n        {\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        Arrays.sort(worker);\\n        int p=0;\\n        for(int i=worker.length-1;i>=0 && !pq.isEmpty();i--)\\n        {\\n            if(worker[i]>=pq.peek()[0])\\n                p=p+pq.peek()[1];\\n            else\\n            {\\n                while(!pq.isEmpty() && worker[i]<pq.peek()[0])\\n                    pq.poll();\\n                if(!pq.isEmpty())\\n                  p=p+pq.peek()[1];\\n            }\\n        }\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(b[1]-a[1]));\\n        for(int i=0;i<profit.length;i++)\\n        {\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        Arrays.sort(worker);\\n        int p=0;\\n        for(int i=worker.length-1;i>=0 && !pq.isEmpty();i--)\\n        {\\n            if(worker[i]>=pq.peek()[0])\\n                p=p+pq.peek()[1];\\n            else\\n            {\\n                while(!pq.isEmpty() && worker[i]<pq.peek()[0])\\n                    pq.poll();\\n                if(!pq.isEmpty())\\n                  p=p+pq.peek()[1];\\n            }\\n        }\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203850,
                "title": "c-binary-search-sorting-approach",
                "content": "```\\n// This is the Simple Binary Search Solution.\\n// First I am Sort Difficulty Vector and then after sorting I need to take Care of the Respective values.\\n// And For that I need map to store the corresponding values of profit vector.\\n// Now After Storing Values I just need to perform the upper bound for each value of worker vector and then ind-- \\n// I did because I need less than aur equal to value but upper bound does opposite.\\n// and then From beginning upto that index i am searching maximum value present in profit vector adding that to my ans will give me Result.\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        map<int,int>seen;\\n        int m = profit.size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            seen[difficulty[i]] = max(seen[difficulty[i]],profit[i]);\\n        }\\n        sort(difficulty.begin(),difficulty.end());\\n        int i = 0;\\n        for(auto it : difficulty)\\n        {\\n            profit[i] = seen[it];\\n            i++;\\n        }\\n        int n = worker.size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int ind = upper_bound(difficulty.begin(),difficulty.end(),worker[i]) - difficulty.begin();\\n            ind--;\\n            if(ind<0)\\n                continue;\\n            int max1 = *max_element(profit.begin(),profit.begin()+ind+1);\\n            ans+=max1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote If you Like The Solution......**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n// This is the Simple Binary Search Solution.\\n// First I am Sort Difficulty Vector and then after sorting I need to take Care of the Respective values.\\n// And For that I need map to store the corresponding values of profit vector.\\n// Now After Storing Values I just need to perform the upper bound for each value of worker vector and then ind-- \\n// I did because I need less than aur equal to value but upper bound does opposite.\\n// and then From beginning upto that index i am searching maximum value present in profit vector adding that to my ans will give me Result.\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        map<int,int>seen;\\n        int m = profit.size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            seen[difficulty[i]] = max(seen[difficulty[i]],profit[i]);\\n        }\\n        sort(difficulty.begin(),difficulty.end());\\n        int i = 0;\\n        for(auto it : difficulty)\\n        {\\n            profit[i] = seen[it];\\n            i++;\\n        }\\n        int n = worker.size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int ind = upper_bound(difficulty.begin(),difficulty.end(),worker[i]) - difficulty.begin();\\n            ind--;\\n            if(ind<0)\\n                continue;\\n            int max1 = *max_element(profit.begin(),profit.begin()+ind+1);\\n            ans+=max1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186392,
                "title": "c-code-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int x,vector<int> &diff,vector<int> &pro,vector<int> &worker){\\n        int i;\\n        int curr=0;\\n        \\n        for (i=0; i<worker.size(); i++){\\n            auto it=upper_bound(diff.begin(),diff.end(),worker[i]);\\n            \\n            if (it!=diff.end() && it!=diff.begin()){\\n                int idx=it-diff.begin()-1;\\n                curr+=pro[idx];\\n            }\\n            if (it==diff.end()){\\n                curr+=pro.back();\\n            }\\n        }\\n        \\n     return curr>=x;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker) {\\n        int l=0;\\n        int r=1e9+5;\\n        \\n        int i;\\n        vector<pair<int,int>> v;\\n        \\n        for (i=0; i<pro.size(); i++){\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for (i=1; i<v.size(); i++){\\n            v[i].second=max(v[i].second,v[i-1].second);\\n        }\\n        for (i=0; i<v.size(); i++){\\n            diff[i]=v[i].first;\\n            pro[i]=v[i].second;\\n        }\\n        \\n        while (r-l>1){\\n            int mid=l+(r-l)/2;\\n            if (check(mid,diff,pro,worker)){\\n                l=mid;\\n            }\\n            else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        if (check(r,diff,pro,worker)){\\n            return r;\\n        }\\n        else{\\n            return l;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int x,vector<int> &diff,vector<int> &pro,vector<int> &worker){\\n        int i;\\n        int curr=0;\\n        \\n        for (i=0; i<worker.size(); i++){\\n            auto it=upper_bound(diff.begin(),diff.end(),worker[i]);\\n            \\n            if (it!=diff.end() && it!=diff.begin()){\\n                int idx=it-diff.begin()-1;\\n                curr+=pro[idx];\\n            }\\n            if (it==diff.end()){\\n                curr+=pro.back();\\n            }\\n        }\\n        \\n     return curr>=x;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker) {\\n        int l=0;\\n        int r=1e9+5;\\n        \\n        int i;\\n        vector<pair<int,int>> v;\\n        \\n        for (i=0; i<pro.size(); i++){\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for (i=1; i<v.size(); i++){\\n            v[i].second=max(v[i].second,v[i-1].second);\\n        }\\n        for (i=0; i<v.size(); i++){\\n            diff[i]=v[i].first;\\n            pro[i]=v[i].second;\\n        }\\n        \\n        while (r-l>1){\\n            int mid=l+(r-l)/2;\\n            if (check(mid,diff,pro,worker)){\\n                l=mid;\\n            }\\n            else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        if (check(r,diff,pro,worker)){\\n            return r;\\n        }\\n        else{\\n            return l;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166941,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size();\\n        vector<pair<int,int>> vec(n);\\n        for(int i=0;i<n;i++) vec[i]={difficulty[i],profit[i]};\\n        sort(vec.begin(),vec.end());\\n        for(int i=1;i<n;i++) vec[i].second=max(vec[i].second,vec[i-1].second);\\n        int cost=0;\\n        for(auto it:worker){\\n            int low=0,high=n-1;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(vec[mid].first<=it) low=mid+1;\\n                else high=mid-1;\\n            }\\n            if(high>=0) cost+=vec[low-1].second;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size();\\n        vector<pair<int,int>> vec(n);\\n        for(int i=0;i<n;i++) vec[i]={difficulty[i],profit[i]};\\n        sort(vec.begin(),vec.end());\\n        for(int i=1;i<n;i++) vec[i].second=max(vec[i].second,vec[i-1].second);\\n        int cost=0;\\n        for(auto it:worker){\\n            int low=0,high=n-1;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(vec[mid].first<=it) low=mid+1;\\n                else high=mid-1;\\n            }\\n            if(high>=0) cost+=vec[low-1].second;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166157,
                "title": "golang-sorting",
                "content": "Pretty much the same answer as the one in the solution section.\\n\\n```\\n\\ntype job struct {\\n\\tdifficulty int\\n\\tprofit     int\\n}\\n\\nfunc maxProfitAssignment(difficulty []int, profit []int, worker []int) int {\\n\\tjobs := []job{}\\n\\n\\tfor i := 0; i < len(difficulty); i++ {\\n\\t\\ttemp := job{difficulty[i], profit[i]}\\n\\t\\tjobs = append(jobs, temp)\\n\\t}\\n\\n\\tsort.Slice(jobs, func(i int, j int) bool {\\n\\t\\treturn jobs[i].difficulty < jobs[j].difficulty\\n\\t})\\n\\n\\tsort.Sort(sort.IntSlice(worker))\\n\\n\\tans, i, best := 0, 0, 0\\n\\n\\tfor _, single_worker := range worker {\\n\\n\\t\\tfor i < len(worker) && single_worker >= jobs[i].difficulty {\\n\\t\\t\\tbest = int(math.Max(float64(best), float64(jobs[i].profit)))\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\tans += best\\n\\t}\\n\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n\\ntype job struct {\\n\\tdifficulty int\\n\\tprofit     int\\n}\\n\\nfunc maxProfitAssignment(difficulty []int, profit []int, worker []int) int {\\n\\tjobs := []job{}\\n\\n\\tfor i := 0; i < len(difficulty); i++ {\\n\\t\\ttemp := job{difficulty[i], profit[i]}\\n\\t\\tjobs = append(jobs, temp)\\n\\t}\\n\\n\\tsort.Slice(jobs, func(i int, j int) bool {\\n\\t\\treturn jobs[i].difficulty < jobs[j].difficulty\\n\\t})\\n\\n\\tsort.Sort(sort.IntSlice(worker))\\n\\n\\tans, i, best := 0, 0, 0\\n\\n\\tfor _, single_worker := range worker {\\n\\n\\t\\tfor i < len(worker) && single_worker >= jobs[i].difficulty {\\n\\t\\t\\tbest = int(math.Max(float64(best), float64(jobs[i].profit)))\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\tans += best\\n\\t}\\n\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151309,
                "title": "c-sort-and-binary-search",
                "content": "```\\nusing pii=pair<int,int>;\\n    int solve(int x,vector<pii> &v){\\n        int l=0,r=size(v)-1,ans=-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(v[m].first<=x) ans=m,l=m+1; //finding largest difficulty that is lesser than or equal to ability of worker\\n            else r=m-1;\\n        }\\n        if(ans==-1) return 0;\\n        return v[ans].second;\\n    }\\n    int maxProfitAssignment(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        vector<pii> v;\\n        int n=size(a),maxi=INT_MIN;\\n        for(int i=0;i<n;i++) v.push_back({a[i],b[i]});\\n        sort(begin(v),end(v));\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second); // for perticular difficulty maximum possible profit\\n            v[i].second=maxi;\\n        }\\n        int res=0;\\n        for(auto &x:c) res+=solve(x,v);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nusing pii=pair<int,int>;\\n    int solve(int x,vector<pii> &v){\\n        int l=0,r=size(v)-1,ans=-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(v[m].first<=x) ans=m,l=m+1; //finding largest difficulty that is lesser than or equal to ability of worker\\n            else r=m-1;\\n        }\\n        if(ans==-1) return 0;\\n        return v[ans].second;\\n    }\\n    int maxProfitAssignment(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        vector<pii> v;\\n        int n=size(a),maxi=INT_MIN;\\n        for(int i=0;i<n;i++) v.push_back({a[i],b[i]});\\n        sort(begin(v),end(v));\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second); // for perticular difficulty maximum possible profit\\n            v[i].second=maxi;\\n        }\\n        int res=0;\\n        for(auto &x:c) res+=solve(x,v);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2142170,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sorting && Binary Search***\\n\\n* ***Time Complexity : O(NlogN)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = difficulty.size();\\n        \\n        int m = worker.size();\\n        \\n        // make pair of difficulty[i] and profit[i]\\n        \\n        vector<pair<int, int>> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = {difficulty[i], profit[i]};\\n        }\\n        \\n        // sort the array\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        sort(difficulty.begin(), difficulty.end());\\n        \\n        // update the profit with maximum profit till ith index\\n        \\n        // so that we can choose a work with maximum profit in constant time\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            maxi = max(maxi, arr[i].second);\\n            \\n            arr[i].second = maxi;\\n        }\\n        \\n        // find the max_profit\\n        \\n        int max_profit = 0;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int idx = upper_bound(difficulty.begin(), difficulty.end(), worker[i]) - difficulty.begin();\\n            \\n            idx--;\\n    \\n            if(idx >= 0)\\n            {\\n                max_profit += arr[idx].second;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = difficulty.size();\\n        \\n        int m = worker.size();\\n        \\n        // make pair of difficulty[i] and profit[i]\\n        \\n        vector<pair<int, int>> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = {difficulty[i], profit[i]};\\n        }\\n        \\n        // sort the array\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        sort(difficulty.begin(), difficulty.end());\\n        \\n        // update the profit with maximum profit till ith index\\n        \\n        // so that we can choose a work with maximum profit in constant time\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            maxi = max(maxi, arr[i].second);\\n            \\n            arr[i].second = maxi;\\n        }\\n        \\n        // find the max_profit\\n        \\n        int max_profit = 0;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int idx = upper_bound(difficulty.begin(), difficulty.end(), worker[i]) - difficulty.begin();\\n            \\n            idx--;\\n    \\n            if(idx >= 0)\\n            {\\n                max_profit += arr[idx].second;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010515,
                "title": "easy-sorting-solution-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int ans = 0;\\n        vector<pair<int,int>> jobs;\\n        \\n        for(int i = 0; i < profit.size(); i++) \\n        {\\n            jobs.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(), worker.end());\\n        //sorting both arrays\\n        int j = profit.size()-1;\\n        for(int worker.size()-1; i >= 0; i--) {\\n            while(j >= 0 && jobs[j].second > worker[i]) {\\n                j--;\\n            }\\n            if(j < 0) break;\\n            ans = ans+jobs[j].first;\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976691,
                "title": "c-easy-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v;//make pair on difficulty and profit\\n        sort(worker.begin(),worker.end());//sort worker, later will depend on it to avoid more difficult than worker\\'s ability put in the vector\\n        for(int i=0;i<difficulty.size();i++)\\n        {\\n            if(difficulty[i]>worker[worker.size()-1])//if difficulty is more then worker\\'s ability\\n                continue;\\n            v.push_back({difficulty[i],profit[i]});//make pair on difficulty and profit\\n        }\\n        sort(v.begin(),v.end());//sort, later will use to make boundary\\n        \\n        int res=0;\\n        int lower=0;//the lower boundary(last worker\\'s most profit)\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int mmax=0;\\n            for(int j=lower;j<v.size();j++)//start with lower boundary\\n            {\\n                if(v[j].first>worker[i])//if now is more difficult than worker\\'s ability\\n                    break;\\n                if(mmax<v[j].second)//record the most profit\\n                {\\n                    lower=j;//the next worker\\'s lower boundary is here\\n                    mmax=v[j].second;\\n                }\\n            }\\n            res+=mmax;\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v;//make pair on difficulty and profit\\n        sort(worker.begin(),worker.end());//sort worker, later will depend on it to avoid more difficult than worker\\'s ability put in the vector\\n        for(int i=0;i<difficulty.size();i++)\\n        {\\n            if(difficulty[i]>worker[worker.size()-1])//if difficulty is more then worker\\'s ability\\n                continue;\\n            v.push_back({difficulty[i],profit[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1945986,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v{};\\n        int n=diff.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({diff[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxi=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second);\\n            profit[i] = maxi;\\n            diff[i] = v[i].first;\\n        }\\n        for(auto w:worker){\\n            int ub = upper_bound(diff.begin(),diff.end(),w)-diff.begin()-1;\\n            if(ub>=0) ans+=profit[ub];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v{};\\n        int n=diff.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({diff[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxi=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second);\\n            profit[i] = maxi;\\n            diff[i] = v[i].first;\\n        }\\n        for(auto w:worker){\\n            int ub = upper_bound(diff.begin(),diff.end(),w)-diff.begin()-1;\\n            if(ub>=0) ans+=profit[ub];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926631,
                "title": "c-binary-search-map-sort-three-simple-solution-with-explanation",
                "content": "# Solution 1 (R)\\n\\nWe construct `idx[i]` and sort `idx` based on `difficulty`. Also, use `maxv[idx[i]]` as best profit we have from `idx[0]`  to `idx[i]`. This is the best value that is based on sorted `difficulty`.\\n\\nThen for each value `w` in `worker`, use binary search to get the index of largest value that is \\u2264 `w` using `idx` and `difficulty` , `res += maxv[idx[right]]` .\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> idx;\\n        int n = profit.size();\\n        for (int i = 0; i < n; ++i) {\\n            idx.push_back(i);\\n        }\\n        sort(idx.begin(), idx.end(), [&difficulty](const int &a, const int &b){\\n            return difficulty[a] < difficulty[b];\\n        });\\n        vector<int> maxv;\\n        int m = 0;\\n        for (int i = 0; i < n; ++i) {\\n            m = max(m, profit[idx[i]]);\\n            maxv.push_back(m);\\n        }\\n        int res = 0;\\n        for (auto &w: worker) {\\n            int left = 0, right = n-1;\\n            while (left <= right) {\\n                int mid = left + (right-left)/2;\\n                if (difficulty[idx[mid]] <= w) {\\n                    left = mid+1;\\n                } else {\\n                    right = mid-1;\\n                }\\n            }\\n            if (right >= 0) {\\n                res += maxv[right];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n`n` : size of `difficulty` , `m` : size of `worker`\\n\\n**Time:** `O(nlogn + mlogn)` \\n**Space:** `O(n)` \\n\\n# Solution 2 (R)\\n\\nWe can also sort `data` , which is constructed by `difficulty` and `profit` , as well as `worker` .\\n\\nThen for each worker that is sorted, we maintain `best` as best profit we have until now and try to traverse `data` until its difficulty > the effort of the worker and update `best` at the same time.\\n\\nAfter that, `res += best` .\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size();\\n        vector<array<int,2>> data;\\n        for (int i = 0; i < n; ++i) {\\n            data.push_back({difficulty[i], profit[i]});\\n        }\\n        sort(worker.begin(), worker.end());\\n        sort(data.begin(), data.end());\\n        int i = 0, res = 0, best = 0;\\n        for (auto &w: worker) {\\n            while (i < n && data[i][0] <= w) {\\n                best = max(best, data[i++][1]);\\n            }\\n            res += best;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n`n` : size of `difficulty` , `m` : size of `worker`\\n\\n**Time:** `O(nlogn + mlogm)`   \\n**Space:** `O(n)`  \\n\\n# Solution 3 (R)\\n\\nWe use `map` to sort `difficulty` and since there might be multiple profit for same difficulty, need to pick max value.\\n\\nAfter that, traverse `map` again to fill each value with best value we have until now.\\n\\nLast, traverse `worker` and use upper_bound to get last largest value \\u2264 `worker` and find its value.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, best = 0;\\n        map<int,int> data;\\n        for (int i = 0; i < n; ++i) {\\n            data[difficulty[i]] = max(data[difficulty[i]], profit[i]);\\n        }\\n        for (auto &[d, p]: data) {\\n            best = max(best, p);\\n            p = best;\\n        }\\n        for (auto &w: worker) {\\n            res += prev(data.upper_bound(w))->second;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n`n` : size of `difficulty` , `m` : size of `worker`\\n\\n**Time:** `O(nlogn + mlogn)`   \\n**Space:** `O(n)`",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> idx;\\n        int n = profit.size();\\n        for (int i = 0; i < n; ++i) {\\n            idx.push_back(i);\\n        }\\n        sort(idx.begin(), idx.end(), [&difficulty](const int &a, const int &b){\\n            return difficulty[a] < difficulty[b];\\n        });\\n        vector<int> maxv;\\n        int m = 0;\\n        for (int i = 0; i < n; ++i) {\\n            m = max(m, profit[idx[i]]);\\n            maxv.push_back(m);\\n        }\\n        int res = 0;\\n        for (auto &w: worker) {\\n            int left = 0, right = n-1;\\n            while (left <= right) {\\n                int mid = left + (right-left)/2;\\n                if (difficulty[idx[mid]] <= w) {\\n                    left = mid+1;\\n                } else {\\n                    right = mid-1;\\n                }\\n            }\\n            if (right >= 0) {\\n                res += maxv[right];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size();\\n        vector<array<int,2>> data;\\n        for (int i = 0; i < n; ++i) {\\n            data.push_back({difficulty[i], profit[i]});\\n        }\\n        sort(worker.begin(), worker.end());\\n        sort(data.begin(), data.end());\\n        int i = 0, res = 0, best = 0;\\n        for (auto &w: worker) {\\n            while (i < n && data[i][0] <= w) {\\n                best = max(best, data[i++][1]);\\n            }\\n            res += best;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, best = 0;\\n        map<int,int> data;\\n        for (int i = 0; i < n; ++i) {\\n            data[difficulty[i]] = max(data[difficulty[i]], profit[i]);\\n        }\\n        for (auto &[d, p]: data) {\\n            best = max(best, p);\\n            p = best;\\n        }\\n        for (auto &w: worker) {\\n            res += prev(data.upper_bound(w))->second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871898,
                "title": "java-simple-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> task = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        \\n        for(int i=0; i<profit.length; i++)\\n            task.offer(new int[]{difficulty[i], profit[i]});\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i: worker)\\n            pq.offer(i);\\n        \\n        int sum = 0;\\n        \\n        while(!pq.isEmpty() && !task.isEmpty()){\\n            if(pq.peek() >= task.peek()[0]){\\n                while(!pq.isEmpty() && task.peek()[0] <= pq.peek()){\\n                    sum += task.peek()[1];\\n                    pq.poll();\\n                }\\n            }\\n            else{\\n                while(!task.isEmpty() && task.peek()[0] > pq.peek())\\n                    task.poll();\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> task = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        \\n        for(int i=0; i<profit.length; i++)\\n            task.offer(new int[]{difficulty[i], profit[i]});\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i: worker)\\n            pq.offer(i);\\n        \\n        int sum = 0;\\n        \\n        while(!pq.isEmpty() && !task.isEmpty()){\\n            if(pq.peek() >= task.peek()[0]){\\n                while(!pq.isEmpty() && task.peek()[0] <= pq.peek()){\\n                    sum += task.peek()[1];\\n                    pq.poll();\\n                }\\n            }\\n            else{\\n                while(!task.isEmpty() && task.peek()[0] > pq.peek())\\n                    task.poll();\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843630,
                "title": "java-with-treemap-neatly-bubbling-up-maximum",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Job> jobs = new ArrayList<>();\\n        int n = difficulty.length;\\n        for(int i=0; i<n; i++){\\n            jobs.add(new Job(difficulty[i], profit[i]));\\n        }\\n\\t\\t// sort based on difficulty (max profit in case of same difficulty)\\n        Collections.sort(jobs, new Comparator<>(){\\n            public int compare(Job j1, Job j2){\\n                if(j1.d == j2.d){\\n                    return j2.p - j1.p;\\n                }\\n                return j1.d - j2.d;\\n            }\\n        });\\n        int maxProfitSoFar = 0;\\n\\t\\t// bubble up the max profit seen so far from left to right \\n        for(Job j : jobs){\\n            maxProfitSoFar = Math.max(maxProfitSoFar, j.p);\\n            j.p = maxProfitSoFar;\\n        }\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(Job j : jobs){\\n            map.put(j.d, j.p);\\n        }\\n        \\n        int res = 0;\\n        for(int m : worker){\\n            Integer difficultyKey = map.floorKey(m);\\n            if(difficultyKey != null){\\n                res += map.get(difficultyKey);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Job {\\n    int d;\\n    int p;\\n    Job(int _d, int _p){\\n        d = _d;\\n        p = _p;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Job> jobs = new ArrayList<>();\\n        int n = difficulty.length;\\n        for(int i=0; i<n; i++){\\n            jobs.add(new Job(difficulty[i], profit[i]));\\n        }\\n\\t\\t// sort based on difficulty (max profit in case of same difficulty)\\n        Collections.sort(jobs, new Comparator<>(){\\n            public int compare(Job j1, Job j2){\\n                if(j1.d == j2.d){\\n                    return j2.p - j1.p;\\n                }\\n                return j1.d - j2.d;\\n            }\\n        });\\n        int maxProfitSoFar = 0;\\n\\t\\t// bubble up the max profit seen so far from left to right \\n        for(Job j : jobs){\\n            maxProfitSoFar = Math.max(maxProfitSoFar, j.p);\\n            j.p = maxProfitSoFar;\\n        }\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(Job j : jobs){\\n            map.put(j.d, j.p);\\n        }\\n        \\n        int res = 0;\\n        for(int m : worker){\\n            Integer difficultyKey = map.floorKey(m);\\n            if(difficultyKey != null){\\n                res += map.get(difficultyKey);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Job {\\n    int d;\\n    int p;\\n    Job(int _d, int _p){\\n        d = _d;\\n        p = _p;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836385,
                "title": "most-profit-assigning-work",
                "content": "```\\n  make difficulty and profit pair that will give you help in finding workers profit according to their strength.\\n  sort worker and difficulty\\n  search worker[i]\\'s floor in difficulty\\n```\\nclass Solution \\n{\\n public:\\n    //Searching worker strength in difficulty\\n    int binary(vector<int>&nums,int k)\\n    {\\n      int n = nums.size()-1;\\n      int l= 0;\\n      //speacial case if worker is not even able to do a least difficult task  \\n      if(nums[0]>k)\\n        return -1;\\n      //searching floor element\\n      int ans=0;\\n      while(l<=n)\\n      {\\n          int mid = (l+n)/2;\\n          if(nums[mid]<=k)\\n          {\\n            ans=mid;\\n            l=mid+1;\\n          }\\n          else\\n            n=mid -1 ;\\n        }\\n       return ans;\\n    }\\n    int maxProfitAssignment(vector<int>& d, vector<int>& pr, vector<int>& w) \\n    {\\n        int n = d.size();\\n        vector<pair<int,int>> p(n);\\n        for(int i=0;i<n;i++)\\n             p[i] = {d[i],pr[i]};\\n        // sorting in difficulty it will help to find the index easily \\n        sort(d.begin(),d.end());\\n         //sort it in difficulty and profit pairs it will give us workers difficulty strength and profit accordingly\\n        sort(p.begin(),p.end());\\n        for(int i=1;i<n;i++)\\n            p[i].second = max(p[i].second,p[i-1].second);\\n        int res =0;\\n        for(int i =0;i<w.size();i++)\\n        {\\n           int it = binary(d,w[i]);\\n           if(it>=0)\\n             res += p[it].second;\\n        }\\n       return res;\\n    }\\n};``",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n  make difficulty and profit pair that will give you help in finding workers profit according to their strength.\\n  sort worker and difficulty\\n  search worker[i]\\'s floor in difficulty\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803075,
                "title": "binary-search-cpp-simple-solution",
                "content": "int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n      \\n        vector<vector<int>>ds;\\n        \\n        for(int i=0; i<difficulty.size(); i++)\\n        {\\n            vector<int>arr;\\n            arr.push_back(difficulty[i]);\\n            arr.push_back(profit[i]);\\n            ds.push_back(arr);\\n        }\\n        \\n        // sortint by difficulty level\\n        sort(ds.begin(), ds.end());\\n        \\n        for(int i=1; i<ds.size(); i++)\\n        {\\n            ds[i][1] = max(ds[i-1][1], ds[i][1]);\\n\\t\\t\\n        }\\n        int sum = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int start = 0;\\n            int end = ds.size()-1;\\n            int target = worker[i];\\n            int ind  = -1;\\n            \\n            while(start <= end)\\n            {\\n                int mid = start + (end-start)/2;\\n                int midval = ds[mid][0];\\n                \\n                if(target>= midval)\\n                {\\n                    ind = mid;\\n                    start = mid + 1;\\n                }\\n                else{\\n                    end = mid -1;\\n                }\\n            }\\n            \\n            sum += ind>-1 ? ds[ind][1] : 0;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n      \\n        vector<vector<int>>ds;\\n        \\n        for(int i=0; i<difficulty.size(); i++)\\n        {\\n            vector<int>arr;\\n            arr.push_back(difficulty[i]);\\n            arr.push_back(profit[i]);\\n            ds.push_back(arr);\\n        }\\n        \\n        // sortint by difficulty level\\n        sort(ds.begin(), ds.end());\\n        \\n        for(int i=1; i<ds.size(); i++)\\n        {\\n            ds[i][1] = max(ds[i-1][1], ds[i][1]);\\n\\t\\t\\n        }\\n        int sum = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int start = 0;\\n            int end = ds.size()-1;\\n            int target = worker[i];\\n            int ind  = -1;\\n            \\n            while(start <= end)\\n            {\\n                int mid = start + (end-start)/2;\\n                int midval = ds[mid][0];\\n                \\n                if(target>= midval)\\n                {\\n                    ind = mid;\\n                    start = mid + 1;\\n                }\\n                else{\\n                    end = mid -1;\\n                }\\n            }\\n            \\n            sum += ind>-1 ? ds[ind][1] : 0;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1721292,
                "title": "easy-to-understand-java-29ms",
                "content": "```\\nclass Pair{\\n    public int first,second;\\n    Pair(int first,int second){\\n        this.first = first; this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> lst = new ArrayList<Pair>();\\n        for(int i=0;i<profit.length;i++){\\n            lst.add(new Pair(difficulty[i],profit[i]));\\n        }\\n        Collections.sort(lst,(Pair p1,Pair p2)->{\\n            return (p1.first==p2.first)?(p1.second-p2.second):(p1.first-p2.first);\\n        });\\n        Arrays.sort(worker);\\n        int res = 0,j = 0,temp = 0;\\n        for(int i=0;i<worker.length;i++){\\n            for(;j<lst.size();j++){\\n                if(lst.get(j).first>worker[i]){\\n                    break;\\n                }\\n                temp = Math.max(temp,lst.get(j).second);\\n            }res+=temp;\\n        }return res;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Pair{\\n    public int first,second;\\n    Pair(int first,int second){\\n        this.first = first; this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> lst = new ArrayList<Pair>();\\n        for(int i=0;i<profit.length;i++){\\n            lst.add(new Pair(difficulty[i],profit[i]));\\n        }\\n        Collections.sort(lst,(Pair p1,Pair p2)->{\\n            return (p1.first==p2.first)?(p1.second-p2.second):(p1.first-p2.first);\\n        });\\n        Arrays.sort(worker);\\n        int res = 0,j = 0,temp = 0;\\n        for(int i=0;i<worker.length;i++){\\n            for(;j<lst.size();j++){\\n                if(lst.get(j).first>worker[i]){\\n                    break;\\n                }\\n                temp = Math.max(temp,lst.get(j).second);\\n            }res+=temp;\\n        }return res;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594681,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxProfitAssignment(self, D: List[int], P: List[int], W: List[int]) -> int:\\n        n = len(D)\\n        \\n        # will be used to get sorted profits. sorted as per elements of difficulty\\n        indexes = sorted(range(n), key=lambda x:D[x])\\n        D.sort()\\n        \\n        # max prefix array\\n        max_profit = []\\n        mx = 0\\n        for i in range(n):\\n            mx = max(mx, P[indexes[i]])\\n            max_profit.append(mx)\\n            \\n        res = 0\\n        for w in W:\\n            idx = bisect.bisect(D, w) - 1\\n            if idx < 0:   continue\\n            res += max_profit[idx]\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, D: List[int], P: List[int], W: List[int]) -> int:\\n        n = len(D)\\n        \\n        # will be used to get sorted profits. sorted as per elements of difficulty\\n        indexes = sorted(range(n), key=lambda x:D[x])\\n        D.sort()\\n        \\n        # max prefix array\\n        max_profit = []\\n        mx = 0\\n        for i in range(n):\\n            mx = max(mx, P[indexes[i]])\\n            max_profit.append(mx)\\n            \\n        res = 0\\n        for w in W:\\n            idx = bisect.bisect(D, w) - 1\\n            if idx < 0:   continue\\n            res += max_profit[idx]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524028,
                "title": "python-3-solution-using-sort-hashmap-binary-search",
                "content": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tpd = defaultdict(int)\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(0, l):\\n\\t\\t#there might be different profit for same difficulty level\\n\\t\\t#so we pick the maximum one\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], profit[i])\\n\\n\\tdifficulty = sorted(set(difficulty))\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(1, l):\\n\\t\\t#task with less difficulty might be more profitable\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], pd[difficulty[i-1]])\\n\\t\\n\\t#since the array is sorted and everything is done as stated above\\n\\t# we can just perform binary search and find the task with proper difficulty (equal or the nearest smaller)\\n\\t\\n\\tdef binary_search(w):\\n\\t\\ts, e = 0, l-1\\n\\t\\tpos = -1\\n\\t\\twhile s<=e:\\n\\t\\t\\tmid = s+(e-s)//2\\n\\t\\t\\tif difficulty[mid]==w:\\n\\t\\t\\t\\treturn mid\\n\\t\\t\\telif difficulty[mid]<w:\\n\\t\\t\\t\\tpos = mid\\n\\t\\t\\t\\ts = mid+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\te = mid-1\\n\\t\\treturn pos\\n\\n\\tres = 0\\n\\tfor w in worker:\\n\\t\\tpos = binary_search(w)\\n\\t\\tif pos>=0:\\n\\t\\t\\tres+=pd[difficulty[pos]]\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tpd = defaultdict(int)\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(0, l):\\n\\t\\t#there might be different profit for same difficulty level\\n\\t\\t#so we pick the maximum one\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], profit[i])\\n\\n\\tdifficulty = sorted(set(difficulty))\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(1, l):\\n\\t\\t#task with less difficulty might be more profitable\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], pd[difficulty[i-1]])\\n\\t\\n\\t#since the array is sorted and everything is done as stated above\\n\\t# we can just perform binary search and find the task with proper difficulty (equal or the nearest smaller)\\n\\t\\n\\tdef binary_search(w):\\n\\t\\ts, e = 0, l-1\\n\\t\\tpos = -1\\n\\t\\twhile s<=e:\\n\\t\\t\\tmid = s+(e-s)//2\\n\\t\\t\\tif difficulty[mid]==w:\\n\\t\\t\\t\\treturn mid\\n\\t\\t\\telif difficulty[mid]<w:\\n\\t\\t\\t\\tpos = mid\\n\\t\\t\\t\\ts = mid+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\te = mid-1\\n\\t\\treturn pos\\n\\n\\tres = 0\\n\\tfor w in worker:\\n\\t\\tpos = binary_search(w)\\n\\t\\tif pos>=0:\\n\\t\\t\\tres+=pd[difficulty[pos]]\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1509325,
                "title": "javascript-solution-sort-and-two-pointers",
                "content": "```\\nvar maxProfitAssignment = function(difficulties, profits, workers) {\\n    const n = difficulties.length;\\n    const m = workers.length;\\n\\n    const jobs = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        const difficulty = difficulties[i];\\n        const profit = profits[i];\\n\\n        jobs[i] = { difficulty, profit };\\n    }\\n\\n    jobs.sort((a, b) => a.difficulty - b.difficulty); // sort the jobs by their difficulties\\n    workers.sort((a, b) => a - b); // sort the workers by their abilities\\n\\n    let jobIdx = 0; // pointer for the jobs array\\n    let workerIdx = 0; // pointer for the workers array\\n\\n    let totMaxProfit = 0;\\n    let bestIdx = 0;\\n\\n    while (workerIdx < m) {\\n        const workerAbility = workers[workerIdx];\\n        \\n        while (jobIdx < n && jobs[jobIdx].difficulty <= workerAbility) {\\n            if (jobs[jobIdx].profit > jobs[bestIdx].profit) {\\n                bestIdx = jobIdx;\\n            }\\n            jobIdx++;\\n        }\\n        \\n        if (jobs[bestIdx].difficulty <= workerAbility) {\\n            totMaxProfit += jobs[bestIdx].profit;\\n        }\\n        workerIdx++;\\n    }\\n    \\n    return totMaxProfit;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nvar maxProfitAssignment = function(difficulties, profits, workers) {\\n    const n = difficulties.length;\\n    const m = workers.length;\\n\\n    const jobs = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        const difficulty = difficulties[i];\\n        const profit = profits[i];\\n\\n        jobs[i] = { difficulty, profit };\\n    }\\n\\n    jobs.sort((a, b) => a.difficulty - b.difficulty); // sort the jobs by their difficulties\\n    workers.sort((a, b) => a - b); // sort the workers by their abilities\\n\\n    let jobIdx = 0; // pointer for the jobs array\\n    let workerIdx = 0; // pointer for the workers array\\n\\n    let totMaxProfit = 0;\\n    let bestIdx = 0;\\n\\n    while (workerIdx < m) {\\n        const workerAbility = workers[workerIdx];\\n        \\n        while (jobIdx < n && jobs[jobIdx].difficulty <= workerAbility) {\\n            if (jobs[jobIdx].profit > jobs[bestIdx].profit) {\\n                bestIdx = jobIdx;\\n            }\\n            jobIdx++;\\n        }\\n        \\n        if (jobs[bestIdx].difficulty <= workerAbility) {\\n            totMaxProfit += jobs[bestIdx].profit;\\n        }\\n        workerIdx++;\\n    }\\n    \\n    return totMaxProfit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1494625,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker)\\n    {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        sort(v.begin(),v.end());\\n        int best=0;\\n        int cost=0;\\n        for(int i=0,j=0;i<worker.size();i++)\\n        {\\n            int wt=worker[i];\\n            while(j<diff.size()&&wt>=v[j].first)\\n            {\\n                best=max(best,v[j].second);\\n                j++;\\n            }\\n            cost+=best;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker)\\n    {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        sort(v.begin(),v.end());\\n        int best=0;\\n        int cost=0;\\n        for(int i=0,j=0;i<worker.size();i++)\\n        {\\n            int wt=worker[i];\\n            while(j<diff.size()&&wt>=v[j].first)\\n            {\\n                best=max(best,v[j].second);\\n                j++;\\n            }\\n            cost+=best;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461056,
                "title": "java-51-faster-solution-using-binary-search",
                "content": "```\\nclass Pair{ // class to store the pair of difficulty and profit together\\n    int d;\\n    int p;\\n    Pair(int d,int p)\\n    {\\n        this.d=d;\\n        this.p=p;\\n    }\\n}\\nclass Solution {\\n    public static int binarysearch(ArrayList<Pair> arr,int val,int s,int e) // binary search function to find the maximum possible difficulty that can be done by the worker\\n    {\\n        if(s>e)\\n            return -1;\\n        int m=s+(e-s)/2;\\n        if(arr.get(m).d>val)\\n         return binarysearch(arr,val,s,m-1);\\n        else\\n        {\\n            int t=binarysearch(arr,val,m+1,e);\\n            return t==-1?m:t;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> arr=new ArrayList<>(); // list to store the pairs of difficulty and profit together\\n        for(int i=0;i<profit.length;i++)\\n            arr.add(new Pair(difficulty[i],profit[i]));\\n        Collections.sort(arr , new Comparator<Pair>(){ \\n            public int compare(Pair p1,Pair p2) // custom sort the list w.r.t difficulty\\n            {\\n                if(p1.d>p2.d)\\n                    return 1;\\n                if(p1.d==p2.d)\\n                    return 0;\\n                return -1;\\n            }\\n        });\\n        ArrayList<Integer> maxsofar=new ArrayList<>(); // list to store the maximum profit from 0 to ith index in the difficulty wise sorted list\\n        int maxx=0;\\n        for(Pair pr : arr)\\n        {\\n            maxx=Math.max(maxx,pr.p);\\n            maxsofar.add(maxx);\\n        }\\n        int sum=0;\\n        for(int i : worker)\\n        {\\n            int t=binarysearch(arr,i,0,arr.size()-1);\\n            if(t==-1)\\n                continue;\\n            sum+=maxsofar.get(t);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Pair{ // class to store the pair of difficulty and profit together\\n    int d;\\n    int p;\\n    Pair(int d,int p)\\n    {\\n        this.d=d;\\n        this.p=p;\\n    }\\n}\\nclass Solution {\\n    public static int binarysearch(ArrayList<Pair> arr,int val,int s,int e) // binary search function to find the maximum possible difficulty that can be done by the worker\\n    {\\n        if(s>e)\\n            return -1;\\n        int m=s+(e-s)/2;\\n        if(arr.get(m).d>val)\\n         return binarysearch(arr,val,s,m-1);\\n        else\\n        {\\n            int t=binarysearch(arr,val,m+1,e);\\n            return t==-1?m:t;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> arr=new ArrayList<>(); // list to store the pairs of difficulty and profit together\\n        for(int i=0;i<profit.length;i++)\\n            arr.add(new Pair(difficulty[i],profit[i]));\\n        Collections.sort(arr , new Comparator<Pair>(){ \\n            public int compare(Pair p1,Pair p2) // custom sort the list w.r.t difficulty\\n            {\\n                if(p1.d>p2.d)\\n                    return 1;\\n                if(p1.d==p2.d)\\n                    return 0;\\n                return -1;\\n            }\\n        });\\n        ArrayList<Integer> maxsofar=new ArrayList<>(); // list to store the maximum profit from 0 to ith index in the difficulty wise sorted list\\n        int maxx=0;\\n        for(Pair pr : arr)\\n        {\\n            maxx=Math.max(maxx,pr.p);\\n            maxsofar.add(maxx);\\n        }\\n        int sum=0;\\n        for(int i : worker)\\n        {\\n            int t=binarysearch(arr,i,0,arr.size()-1);\\n            if(t==-1)\\n                continue;\\n            sum+=maxsofar.get(t);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434903,
                "title": "c-priority-queue-8-lines",
                "content": "```\\n\\n```public:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int i,ans=0;\\n       priority_queue<pair<int,int>>pq;\\n        for(i=0;i<profit.size();i++)\\n        {\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        for(i=0;i<worker.size();i++)\\n        {\\n            while(!pq.empty()&&pq.top().second>worker[i])\\n            {\\n                pq.pop();\\n            }\\n            if(!pq.empty())\\n            {\\n                ans=ans+pq.top().first;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1409945,
                "title": "simple-python-o-nlogn-mlogm-sort-greedy-solution",
                "content": "If the ability of worker 1 is at least that of worker 2, worker1 can make a profit of at least that of worker 2 as well. We can start from the least skilled worker and increase max profit when we can. This way the total complexity is O(nlogn) for sorting difficulty and profit, O(mlogm) for sorting worker skills, and O(n) for scanning through difficulties.\\n\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        # sort difficulty and profit together as a tuple\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        ret = max_profit = idx = 0\\n        for ability in sorted(worker):\\n            # if ability is smaller than the smallest difficulty\\n            # it\\'s smaller than all difficulties\\n            if ability < difficulty[0]: continue\\n            # try to find a larger profit than the current one\\n            # this while loop will be run for at most len(difficulty) times\\n            # as idx is not reset at the end\\n            while idx < len(difficulty) and ability >= difficulty[idx]:\\n                max_profit = max(max_profit, profit[idx])\\n                idx += 1\\n            # increment total profit\\n            ret += max_profit\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        # sort difficulty and profit together as a tuple\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        ret = max_profit = idx = 0\\n        for ability in sorted(worker):\\n            # if ability is smaller than the smallest difficulty\\n            # it\\'s smaller than all difficulties\\n            if ability < difficulty[0]: continue\\n            # try to find a larger profit than the current one\\n            # this while loop will be run for at most len(difficulty) times\\n            # as idx is not reset at the end\\n            while idx < len(difficulty) and ability >= difficulty[idx]:\\n                max_profit = max(max_profit, profit[idx])\\n                idx += 1\\n            # increment total profit\\n            ret += max_profit\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378443,
                "title": "c-faster-than-50-easiest-solution-insertion-sort",
                "content": "\\'\\'\\'\\n\\n\\tint maxProfitAssignment(int* difficulty, int difficultySize, int* profit, int profitSize, int* worker, int workerSize){\\n    int i, j, tempval, tempval2, pr=0;\\n\\t\\n\\t// Example - difficulty = [10,8,6,4,2], profit = [50,40,30,20,10], worker = [7,6,5,4]\\n\\t\\n\\t/* Sorting difficulty array based on profit array\\n\\tSince we want to maximize profit so we figure out how can we get maximum profit and what is the \\n\\tdifficulty associated with it (Insertion sort as it it Stable)\\n\\t*/\\n    for(i=1; i<profitSize; ++i){\\n        if(profit[i]<profit[i-1]){\\n            tempval=profit[i];\\n            tempval2=difficulty[i];\\n            j=i-1;\\n            while(j>=0 && profit[j]>tempval){\\n                profit[j+1]=profit[j];\\n                difficulty[j+1]=difficulty[j];\\n                --j;\\n            } \\n            profit[j+1]=tempval;\\n            difficulty[j+1]=tempval2;\\n        }\\n    }\\n\\t// After sorting - difficulty = [2,4,6,8,10], profit = [10,20,30,40,50]\\n\\t\\n\\t// Now we Sort worker array \\n    for(i=1; i<workerSize; ++i){\\n        if(worker[i]<worker[i-1]){\\n            tempval=worker[i];\\n            j=i-1;\\n            while(j>=0 && worker[j]>tempval){\\n                worker[j+1]=worker[j];\\n                --j;\\n            } \\n            worker[j+1]=tempval;\\n        }\\n    }\\n\\t\\n\\t// After sorting -  worker = [4,5,6,7]\\n\\t\\n    // Main Logic\\n    int x=difficultySize-1; // last index of difficulty array (x=4)\\n    for(i=workerSize-1; i>=0; --i){\\n\\t\\t// we decrement x till we figure out an index where difficulty[x] <= worker [i]\\n\\t\\t// This goes on till difficulty[x]=6 or x=2\\n        while(x>-1 && difficulty[x]>worker[i]){\\n            --x;\\n        }\\n        if(x==-1) break;\\n        pr+=profit[x]; // difficulty[x]=6  and worker[i]=7 so we get maximum profit out of it\\n    }\\n    return pr;\\n\\t}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tint maxProfitAssignment(int* difficulty, int difficultySize, int* profit, int profitSize, int* worker, int workerSize){\\n    int i, j, tempval, tempval2, pr=0;\\n\\t\\n\\t// Example - difficulty = [10,8,6,4,2], profit = [50,40,30,20,10], worker = [7,6,5,4]\\n\\t\\n\\t/* Sorting difficulty array based on profit array\\n\\tSince we want to maximize profit so we figure out how can we get maximum profit and what is the \\n\\tdifficulty associated with it (Insertion sort as it it Stable)\\n\\t*/\\n    for(i=1; i<profitSize; ++i){\\n        if(profit[i]<profit[i-1]){\\n            tempval=profit[i];\\n            tempval2=difficulty[i];\\n            j=i-1;\\n            while(j>=0 && profit[j]>tempval){\\n                profit[j+1]=profit[j];\\n                difficulty[j+1]=difficulty[j];\\n                --j;\\n            } \\n            profit[j+1]=tempval;\\n            difficulty[j+1]=tempval2;\\n        }\\n    }\\n\\t// After sorting - difficulty = [2,4,6,8,10], profit = [10,20,30,40,50]\\n\\t\\n\\t// Now we Sort worker array \\n    for(i=1; i<workerSize; ++i){\\n        if(worker[i]<worker[i-1]){\\n            tempval=worker[i];\\n            j=i-1;\\n            while(j>=0 && worker[j]>tempval){\\n                worker[j+1]=worker[j];\\n                --j;\\n            } \\n            worker[j+1]=tempval;\\n        }\\n    }\\n\\t\\n\\t// After sorting -  worker = [4,5,6,7]\\n\\t\\n    // Main Logic\\n    int x=difficultySize-1; // last index of difficulty array (x=4)\\n    for(i=workerSize-1; i>=0; --i){\\n\\t\\t// we decrement x till we figure out an index where difficulty[x] <= worker [i]\\n\\t\\t// This goes on till difficulty[x]=6 or x=2\\n        while(x>-1 && difficulty[x]>worker[i]){\\n            --x;\\n        }\\n        if(x==-1) break;\\n        pr+=profit[x]; // difficulty[x]=6  and worker[i]=7 so we get maximum profit out of it\\n    }\\n    return pr;\\n\\t}\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1353377,
                "title": "sorting-binary-search",
                "content": "```\\nclass Solution {\\nprivate:\\n    int bs(vector<pair<int, int>>& job, int workerCap, int start, int end){\\n        // cout<<\"Got workerCap: \"<<workerCap<<\"\\\\n\";\\n        while(start<end){\\n            int mid = start + (end-start+1)/2;\\n            // cout<<\"Mid Diff Job: \"<<job[mid].first<<\"\\\\n\";\\n            if(job[mid].first > workerCap){\\n                // cout<<\"Shrinking End to: \"<<job[mid-1].first<<\"\\\\n\";\\n                end = mid-1;\\n            } else if(job[mid].first <= workerCap){\\n                // cout<<\"Shrinking start to: \"<<job[mid].first<<\"\\\\n\";\\n                start = mid;\\n            }\\n        }\\n        if(job[start].first > workerCap){\\n            // cout<<\"LowerBound not found!\\\\n\\\\n\";\\n            return -1;\\n        }\\n        // cout<<\"Referring job with difficulty: \"<< job[start].first<<\"\\\\n\\\\n\";\\n        return start;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        int res = 0;\\n        vector<pair<int, int>> job(n);\\n        for(int i=0;i<n;i++){\\n            job[i] = {difficulty[i], profit[i]};\\n        }\\n        sort(job.begin(), job.end());\\n        vector<int> jobWithMaxProfitUntilNow(n);\\n        int maxProfitJob = job[0].second;\\n        int maxProfitJobId = 0;\\n        for(int i=0;i<n;i++){\\n            if(job[i].second > maxProfitJob){\\n                maxProfitJob = job[i].second;\\n                maxProfitJobId = i;\\n            }\\n            jobWithMaxProfitUntilNow[i] = maxProfitJobId;\\n        }\\n        for(int i = m-1;i>=0;i--){\\n            int workerCap = worker[i];\\n            int bsid = bs(job, workerCap, 0, n-1);\\n            if(bsid==-1){\\n                continue;\\n            }\\n            res += job[jobWithMaxProfitUntilNow[bsid]].second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int bs(vector<pair<int, int>>& job, int workerCap, int start, int end){\\n        // cout<<\"Got workerCap: \"<<workerCap<<\"\\\\n\";\\n        while(start<end){\\n            int mid = start + (end-start+1)/2;\\n            // cout<<\"Mid Diff Job: \"<<job[mid].first<<\"\\\\n\";\\n            if(job[mid].first > workerCap){\\n                // cout<<\"Shrinking End to: \"<<job[mid-1].first<<\"\\\\n\";\\n                end = mid-1;\\n            } else if(job[mid].first <= workerCap){\\n                // cout<<\"Shrinking start to: \"<<job[mid].first<<\"\\\\n\";\\n                start = mid;\\n            }\\n        }\\n        if(job[start].first > workerCap){\\n            // cout<<\"LowerBound not found!\\\\n\\\\n\";\\n            return -1;\\n        }\\n        // cout<<\"Referring job with difficulty: \"<< job[start].first<<\"\\\\n\\\\n\";\\n        return start;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        int res = 0;\\n        vector<pair<int, int>> job(n);\\n        for(int i=0;i<n;i++){\\n            job[i] = {difficulty[i], profit[i]};\\n        }\\n        sort(job.begin(), job.end());\\n        vector<int> jobWithMaxProfitUntilNow(n);\\n        int maxProfitJob = job[0].second;\\n        int maxProfitJobId = 0;\\n        for(int i=0;i<n;i++){\\n            if(job[i].second > maxProfitJob){\\n                maxProfitJob = job[i].second;\\n                maxProfitJobId = i;\\n            }\\n            jobWithMaxProfitUntilNow[i] = maxProfitJobId;\\n        }\\n        for(int i = m-1;i>=0;i--){\\n            int workerCap = worker[i];\\n            int bsid = bs(job, workerCap, 0, n-1);\\n            if(bsid==-1){\\n                continue;\\n            }\\n            res += job[jobWithMaxProfitUntilNow[bsid]].second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1344821,
                "title": "c-easy-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    static bool compare(const int&a , const int &b)\\n    {\\n        return a>b;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<profit.size();i++)\\n        {\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end(),compare);\\n        int i=0;\\n        int ans=0;\\n        while(i<worker.size())\\n        {\\n            while(!pq.empty() && pq.top().second>worker[i])\\n            {\\n                pq.pop();\\n            }\\n            if(!pq.empty())\\n            {\\n                ans+=pq.top().first;\\n                i++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static bool compare(const int&a , const int &b)\\n    {\\n        return a>b;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<profit.size();i++)\\n        {\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end(),compare);\\n        int i=0;\\n        int ans=0;\\n        while(i<worker.size())\\n        {\\n            while(!pq.empty() && pq.top().second>worker[i])\\n            {\\n                pq.pop();\\n            }\\n            if(!pq.empty())\\n            {\\n                ans+=pq.top().first;\\n                i++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343418,
                "title": "c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> check(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            check[i]={difficulty[i],profit[i]};\\n        }\\n        sort(check.begin(),check.end());\\n        sort(worker.begin(),worker.end());\\n        int ans=0;\\n        int ptr1=0,ptr2=0;\\n        int maxProfit=0;\\n        int flag=0;\\n        while(ptr1<worker.size() && ptr2<check.size()){  \\n            \\n            if( worker[ptr1]>=check[ptr2].first){\\n                maxProfit=max(maxProfit,check[ptr2].second);\\n                ptr2++;\\n            }else{\\n                ans+=maxProfit;\\n                ptr1++;\\n                flag++;\\n            }\\n        }\\n        if(flag<worker.size())\\n            ans+=maxProfit * (worker.size()-flag);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> check(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            check[i]={difficulty[i],profit[i]};\\n        }\\n        sort(check.begin(),check.end());\\n        sort(worker.begin(),worker.end());\\n        int ans=0;\\n        int ptr1=0,ptr2=0;\\n        int maxProfit=0;\\n        int flag=0;\\n        while(ptr1<worker.size() && ptr2<check.size()){  \\n            \\n            if( worker[ptr1]>=check[ptr2].first){\\n                maxProfit=max(maxProfit,check[ptr2].second);\\n                ptr2++;\\n            }else{\\n                ans+=maxProfit;\\n                ptr1++;\\n                flag++;\\n            }\\n        }\\n        if(flag<worker.size())\\n            ans+=maxProfit * (worker.size()-flag);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081349,
                "title": "c-short-solution-88",
                "content": "Run-time is `O(NlogN + MlogM)`, space is `O(N)`, where `N` is size of `difficulty` and `M` size of `worker`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        std::vector<std::pair<int,int>> dnp;\\n        int size{(int)difficulty.size()};\\n        for(int i{0}; i < size; ++i) dnp.emplace_back(difficulty[i], profit[i]);\\n        std::sort(dnp.begin(), dnp.end(), [](const auto& a, const auto& b){return a.first < b.first;});\\n        for(int i{0}, max_{0}; i < size; ++i) {\\n            max_ = std::max(max_, dnp[i].second);\\n            dnp[i].second = max_;\\n        }\\n\\n        int sum{0};\\n        for(const auto &w: worker) {\\n            int tmp = sum;\\n            auto it{std::upper_bound(dnp.begin(), dnp.end(), std::pair(w, 0), [](const auto& a, const auto& b){return a.first < b.first;})};\\n            if(it != dnp.begin()) sum += (--it)->second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        std::vector<std::pair<int,int>> dnp;\\n        int size{(int)difficulty.size()};\\n        for(int i{0}; i < size; ++i) dnp.emplace_back(difficulty[i], profit[i]);\\n        std::sort(dnp.begin(), dnp.end(), [](const auto& a, const auto& b){return a.first < b.first;});\\n        for(int i{0}, max_{0}; i < size; ++i) {\\n            max_ = std::max(max_, dnp[i].second);\\n            dnp[i].second = max_;\\n        }\\n\\n        int sum{0};\\n        for(const auto &w: worker) {\\n            int tmp = sum;\\n            auto it{std::upper_bound(dnp.begin(), dnp.end(), std::pair(w, 0), [](const auto& a, const auto& b){return a.first < b.first;})};\\n            if(it != dnp.begin()) sum += (--it)->second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069376,
                "title": "python-sort-binary-search",
                "content": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        D = collections.defaultdict(list)\\n        for i in range(len(profit)):\\n            D[difficulty[i]].append(profit[i])\\n        dif = sorted(set(difficulty))\\n        prof = [None] * len(dif)\\n        maxGlobal = 0\\n        for i, n in enumerate(dif):\\n            maxLocal = max(D[n])\\n            if maxLocal > maxGlobal:\\n                maxGlobal = maxLocal\\n                prof[i] = maxGlobal\\n            else:\\n                prof[i] = maxGlobal\\n        res = 0\\n        for w in worker:\\n            idx = bisect_left(dif, w)\\n            flag = False\\n            if idx >= len(dif): \\n                idx -= 1\\n                flag = True\\n            if dif[idx] == w:\\n                res += prof[idx]\\n            else:\\n                if flag:\\n                    res += prof[idx]\\n                else:\\n                    idx -= 1\\n                    if idx < 0: continue\\n                    res += prof[idx]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        D = collections.defaultdict(list)\\n        for i in range(len(profit)):\\n            D[difficulty[i]].append(profit[i])\\n        dif = sorted(set(difficulty))\\n        prof = [None] * len(dif)\\n        maxGlobal = 0\\n        for i, n in enumerate(dif):\\n            maxLocal = max(D[n])\\n            if maxLocal > maxGlobal:\\n                maxGlobal = maxLocal\\n                prof[i] = maxGlobal\\n            else:\\n                prof[i] = maxGlobal\\n        res = 0\\n        for w in worker:\\n            idx = bisect_left(dif, w)\\n            flag = False\\n            if idx >= len(dif): \\n                idx -= 1\\n                flag = True\\n            if dif[idx] == w:\\n                res += prof[idx]\\n            else:\\n                if flag:\\n                    res += prof[idx]\\n                else:\\n                    idx -= 1\\n                    if idx < 0: continue\\n                    res += prof[idx]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060394,
                "title": "java-memorization-very-easy-to-understand",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] temp = new int[100000];\\n        for(int i=0; i<difficulty.length; i++) {\\n          temp[difficulty[i]] =  Math.max(profit[i], temp[difficulty[i]]);    \\n        }\\n        \\n        for(int i=1; i<temp.length; i++) {\\n          temp[i] = Math.max(temp[i-1], temp[i]);\\n          \\n        }\\n        int result =0;\\n        for(int i=0; i<worker.length; i++) {\\n            result += temp[worker[i]];\\n        }\\n        return result;\\n    }\\n\\t\\n\\t\\nRuntime: 11 ms, faster than 96.37% of Java online submissions for Most Profit Assigning Work.\\nMemory Usage: 40.1 MB, less than 83.69% of Java online submissions for Most Profit Assigning Work.",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] temp = new int[100000];\\n        for(int i=0; i<difficulty.length; i++) {\\n          temp[difficulty[i]] =  Math.max(profit[i], temp[difficulty[i]]);    \\n        }\\n        \\n        for(int i=1; i<temp.length; i++) {\\n          temp[i] = Math.max(temp[i-1], temp[i]);\\n          \\n        }\\n        int result =0;\\n        for(int i=0; i<worker.length; i++) {\\n            result += temp[worker[i]];\\n        }\\n        return result;\\n    }\\n\\t\\n\\t\\nRuntime: 11 ms, faster than 96.37% of Java online submissions for Most Profit Assigning Work.\\nMemory Usage: 40.1 MB, less than 83.69% of Java online submissions for Most Profit Assigning Work.",
                "codeTag": "Unknown"
            },
            {
                "id": 1015778,
                "title": "java-super-easy-sort-by-profit",
                "content": "1. Sort by profit\\n2. Two pointers: count backwards, to make sure better worker gets better profit. If the better worker can\\'t do job[i], the worse one can\\'t either. \\n\\n```\\nclass Solution {\\n    \\n    class Job {\\n        public int d;\\n        public int p;\\n        Job(int difficulty, int profit) {\\n            this.d = difficulty;\\n            this.p = profit;\\n        }\\n    }\\n    \\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        // Edge case\\n        if(difficulty.length == 0 || profit.length == 0 || worker.length == 0) return 0;\\n        \\n        // Translate to job\\n        Job[] jobs = new Job[difficulty.length];\\n        for(int i = 0; i < jobs.length; i++) {\\n            jobs[i] = new Job(difficulty[i], profit[i]);\\n        }\\n        \\n        // Sort \\n        Arrays.sort(jobs, (Job a, Job b) -> (a.p - b.p));\\n        Arrays.sort(worker);\\n        \\n        // Two pointers\\n        int res = 0;\\n        int i = jobs.length - 1, j = worker.length - 1;\\n        while(j >= 0 && i >= 0) {\\n            if(jobs[i].d > worker[j]) i--;\\n            else if(jobs[i].d <= worker[j]) {\\n                res += jobs[i].p;\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Job {\\n        public int d;\\n        public int p;\\n        Job(int difficulty, int profit) {\\n            this.d = difficulty;\\n            this.p = profit;\\n        }\\n    }\\n    \\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        // Edge case\\n        if(difficulty.length == 0 || profit.length == 0 || worker.length == 0) return 0;\\n        \\n        // Translate to job\\n        Job[] jobs = new Job[difficulty.length];\\n        for(int i = 0; i < jobs.length; i++) {\\n            jobs[i] = new Job(difficulty[i], profit[i]);\\n        }\\n        \\n        // Sort \\n        Arrays.sort(jobs, (Job a, Job b) -> (a.p - b.p));\\n        Arrays.sort(worker);\\n        \\n        // Two pointers\\n        int res = 0;\\n        int i = jobs.length - 1, j = worker.length - 1;\\n        while(j >= 0 && i >= 0) {\\n            if(jobs[i].d > worker[j]) i--;\\n            else if(jobs[i].d <= worker[j]) {\\n                res += jobs[i].p;\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002260,
                "title": "c-map-and-two-pointers-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int, int> myMap;\\n        \\n        for (int i = 0; i < difficulty.size(); i++)\\n            myMap[difficulty[i]] = max(myMap[difficulty[i]], profit[i]);\\n        \\n        sort(worker.begin(), worker.end());\\n        \\n        auto it = myMap.begin();\\n        int i = 0;\\n        int curMaxProfit = 0, totalProfit = 0;\\n        \\n        while (i < worker.size()) {\\n            if (it == myMap.end() or worker[i] < it->first) {\\n                totalProfit += curMaxProfit;\\n                i++;\\n            }\\n            else {\\n                curMaxProfit = max(curMaxProfit, it->second);\\n                it++; \\n            }              \\n        }\\n        \\n        return totalProfit;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int, int> myMap;\\n        \\n        for (int i = 0; i < difficulty.size(); i++)\\n            myMap[difficulty[i]] = max(myMap[difficulty[i]], profit[i]);\\n        \\n        sort(worker.begin(), worker.end());\\n        \\n        auto it = myMap.begin();\\n        int i = 0;\\n        int curMaxProfit = 0, totalProfit = 0;\\n        \\n        while (i < worker.size()) {\\n            if (it == myMap.end() or worker[i] < it->first) {\\n                totalProfit += curMaxProfit;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 934864,
                "title": "python3-two-approaches",
                "content": "Approach 1 - binary search \\nMaintain a mapping from (sorted) difficulty to max profit within this category. Given `worker`, binary search the max profit so that `difficulty <= worker`. \\n\\nImplementation \\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        mp = {}\\n        mx = 0\\n        for x, y in sorted(zip(difficulty, profit)):\\n            mp[x] = max(mp.get(x, 0), mx := max(mx, y))\\n        arr = list(mp.keys()) # ordered since 3.6\\n        \\n        ans = 0 \\n        for x in worker: \\n            i = bisect_right(arr, x) - 1\\n            if 0 <= i < len(arr): ans += mp[arr[i]]\\n        return ans \\n```\\n\\nApproach 2 - sorting \\nA smarter implementation of similar idea given by @lee215 in this [post](https://leetcode.com/problems/most-profit-assigning-work/discuss/127031/C%2B%2BJavaPython-Sort-and-Two-pointer). \\n\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        job = sorted(zip(difficulty, profit))\\n        ans = i = mx = 0 \\n        for w in sorted(worker): \\n            while i < len(job) and job[i][0] <= w: \\n                mx = max(mx, job[i][1])\\n                i += 1\\n            ans += mx \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        mp = {}\\n        mx = 0\\n        for x, y in sorted(zip(difficulty, profit)):\\n            mp[x] = max(mp.get(x, 0), mx := max(mx, y))\\n        arr = list(mp.keys()) # ordered since 3.6\\n        \\n        ans = 0 \\n        for x in worker: \\n            i = bisect_right(arr, x) - 1\\n            if 0 <= i < len(arr): ans += mp[arr[i]]\\n        return ans \\n```\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        job = sorted(zip(difficulty, profit))\\n        ans = i = mx = 0 \\n        for w in sorted(worker): \\n            while i < len(job) and job[i][0] <= w: \\n                mx = max(mx, job[i][1])\\n                i += 1\\n            ans += mx \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 912152,
                "title": "c-easy-solution-using-sorting-and-two-pointer-technique",
                "content": "we divide the problem into two processes: 1.sort work, difficulty and profit. 2. two-pointer technique traversing to find result\\n```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    int res = 0, curMax = 0, m = (int)worker.size(), n = (int)difficulty.size();\\n    // sort difficuty-profit and worker\\n    sort(worker.begin(), worker.end());\\n    vector<pair<int, int>> diffProf(n);\\n    for (int i = 0; i < n; i++){\\n        diffProf[i].first = difficulty[i];\\n        diffProf[i].second = profit[i];\\n    }\\n    sort(diffProf.begin(), diffProf.end());\\n    // two-pointer traversing, i for worker, j for diffProf\\n    int i = 0, j = 0;\\n    while (i < m) {\\n        while (j < n && worker[i] >= diffProf[j].first)\\n        {\\n            curMax = max(curMax, diffProf[j].second);\\n            j++;\\n        }\\n        res += curMax;\\n        i++;\\n    }\\n    return res;\\n}",
                "solutionTags": [],
                "code": "we divide the problem into two processes: 1.sort work, difficulty and profit. 2. two-pointer technique traversing to find result\\n```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    int res = 0, curMax = 0, m = (int)worker.size(), n = (int)difficulty.size();\\n    // sort difficuty-profit and worker\\n    sort(worker.begin(), worker.end());\\n    vector<pair<int, int>> diffProf(n);\\n    for (int i = 0; i < n; i++){\\n        diffProf[i].first = difficulty[i];\\n        diffProf[i].second = profit[i];\\n    }\\n    sort(diffProf.begin(), diffProf.end());\\n    // two-pointer traversing, i for worker, j for diffProf\\n    int i = 0, j = 0;\\n    while (i < m) {\\n        while (j < n && worker[i] >= diffProf[j].first)\\n        {\\n            curMax = max(curMax, diffProf[j].second);\\n            j++;\\n        }\\n        res += curMax;\\n        i++;\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 906712,
                "title": "java-treemap-solution",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer,Integer> treemap = new TreeMap<>();\\n        for(int i = 0; i < difficulty.length; i++) {\\n            treemap.put(difficulty[i], Math.max(profit[i], treemap.getOrDefault(difficulty[i], 0)));\\n        }\\n        \\n        int max = 0, res = 0;\\n        for(Integer key : treemap.keySet()) {\\n            max = Math.max(treemap.get(key), max);\\n            treemap.put(key, max);\\n        }\\n       \\n        for(int i = 0; i < worker.length; i++){\\n            Integer key = treemap.floorKey(worker[i]);\\n             if(key != null)\\n                 res += treemap.get(key);\\n               }\\n            \\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer,Integer> treemap = new TreeMap<>();\\n        for(int i = 0; i < difficulty.length; i++) {\\n            treemap.put(difficulty[i], Math.max(profit[i], treemap.getOrDefault(difficulty[i], 0)));\\n        }\\n        \\n        int max = 0, res = 0;\\n        for(Integer key : treemap.keySet()) {\\n            max = Math.max(treemap.get(key), max);\\n            treemap.put(key, max);\\n        }\\n       \\n        for(int i = 0; i < worker.length; i++){\\n            Integer key = treemap.floorKey(worker[i]);\\n             if(key != null)\\n                 res += treemap.get(key);\\n               }\\n            \\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 808144,
                "title": "c",
                "content": "` ` `\\nclass Solution {\\npublic:\\n    \\n    int binary_search(vector<int>&p, int w){\\n        \\n        int n = p.size()-1;\\n        int l= 0;\\n        if(p[0]> w)\\n            return -1;\\n        int ans = 0;\\n        while(l<=n){\\n            int mid = (l+n)/2;\\n            \\n            if(p[mid]<=w){\\n                ans = mid;\\n                l = mid+1;\\n            }\\n            else\\n                n = mid -1 ;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int maxProfitAssignment(vector<int>& d, vector<int>& pr, vector<int>& w) {\\n        \\n        int n = d.size();\\n        vector<pair<int,int>> p(n);\\n        \\n        for(int i=0;i<n;i++){\\n            p[i] = {d[i],pr[i]};\\n        }\\n        \\n        sort(d.begin(),d.end());\\n        \\n        sort(p.begin(),p.end());\\n        for(int i=1;i<n;i++){\\n            p[i].second = max(p[i].second,p[i-1].second);\\n        }\\n        \\n        int res =0;\\n        \\n        for(int i =0;i<w.size();i++){\\n            int it = binary_search(d,w[i]);\\n            //cout<<it<<\" \";\\n            if(it>=0){\\n                //cout<<p[it].second<<\" \";\\n                res += p[it].second;\\n            }\\n                \\n        }\\n        \\n        return res;\\n                \\n    }\\n};\\n` ` `",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int binary_search(vector<int>&p, int w){\\n        \\n        int n = p.size()-1;\\n        int l= 0;\\n        if(p[0]> w)\\n            return -1;\\n        int ans = 0;\\n        while(l<=n){\\n            int mid = (l+n)/2;\\n            \\n            if(p[mid]<=w){\\n                ans = mid;\\n                l = mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 754240,
                "title": "c-simle-sort-and-run",
                "content": "Just sort by profit and try to gain as much profit as possible\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pro, vector<int>& worker) \\n    {\\n        int n=dif.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++) v[i]={pro[i],dif[i]};\\n        // sort by profit descending\\n        sort(v.begin(),v.end(),greater<pair<int,int>>());\\n        // sort ability in descending\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        // ans is final answer, j is current worker\\'s index\\n        int j=0,ans=0;\\n\\t\\t// iterate over jobs\\n        for(int i=0;i<n;)\\n        {\\n            // no more workers left\\n            if(j>=worker.size()) break;\\n            // worker j can do task i\\n            if(worker[j]>=v[i].second) {ans+=v[i].first; j++;}\\n            // else goto next task\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pro, vector<int>& worker) \\n    {\\n        int n=dif.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++) v[i]={pro[i],dif[i]};\\n        // sort by profit descending\\n        sort(v.begin(),v.end(),greater<pair<int,int>>());\\n        // sort ability in descending\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        // ans is final answer, j is current worker\\'s index\\n        int j=0,ans=0;\\n\\t\\t// iterate over jobs\\n        for(int i=0;i<n;)\\n        {\\n            // no more workers left\\n            if(j>=worker.size()) break;\\n            // worker j can do task i\\n            if(worker[j]>=v[i].second) {ans+=v[i].first; j++;}\\n            // else goto next task\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680822,
                "title": "python-an-o-n-logn-solution",
                "content": "We sort both the works and the workers in decreasing order of profit and difficulty. Then for each worker, we try to pick the most profitable work he can take. Since we already sort the workers and the profit in terms of profit and difficulty, if worker i can take work j, then every worker coming after i can only at best take work j, or some work k with k > j. So, we can use two-pointer techniques to accumulate the result in O(N). Overall complexity: O(N logN).\\n\\n```\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        pd = list(zip(profit, difficulty))\\n        pd = sorted(pd, key = lambda x: -x[0])\\n        worker = sorted(worker, key = lambda x: -x)\\n        j, res = 0, 0\\n        for i, e in enumerate(worker):\\n            while j < len(pd) and e < pd[j][1]:\\n                j += 1\\n            if j == len(pd):\\n                return res\\n            res += pd[j][0]\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        pd = list(zip(profit, difficulty))\\n        pd = sorted(pd, key = lambda x: -x[0])\\n        worker = sorted(worker, key = lambda x: -x)\\n        j, res = 0, 0\\n        for i, e in enumerate(worker):\\n            while j < len(pd) and e < pd[j][1]:\\n                j += 1\\n            if j == len(pd):\\n                return res\\n            res += pd[j][0]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 615597,
                "title": "fast-concise-javascript-solution",
                "content": "\\n```\\nconst maxProfitAssignment = (difficultyArr, profitArr, workerArr) => {\\n    let jobMap = Array.from(difficultyArr, (x,i) => [profitArr[i], x])\\n    jobMap.sort((a,b) => b[0] - a[0]); workerArr.sort((a,b) => b - a)\\n    let totalProfit = 0\\n    let j = 0, w = 0\\n    while(j < jobMap.length && w < workerArr.length){\\n        let [profit, difficulty] = jobMap[j],\\n            worker = workerArr[w]\\n        if(difficulty > worker)j++\\n        else{\\n            totalProfit += profit\\n            w++\\n        }\\n        \\n    }\\n    return totalProfit\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxProfitAssignment = (difficultyArr, profitArr, workerArr) => {\\n    let jobMap = Array.from(difficultyArr, (x,i) => [profitArr[i], x])\\n    jobMap.sort((a,b) => b[0] - a[0]); workerArr.sort((a,b) => b - a)\\n    let totalProfit = 0\\n    let j = 0, w = 0\\n    while(j < jobMap.length && w < workerArr.length){\\n        let [profit, difficulty] = jobMap[j],\\n            worker = workerArr[w]\\n        if(difficulty > worker)j++\\n        else{\\n            totalProfit += profit\\n            w++\\n        }\\n        \\n    }\\n    return totalProfit\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520905,
                "title": "java-using-array-to-store-profit-for-each-difficulty",
                "content": "class Solution {\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] allProfit = new int[100000];\\n        int lOfJobs = difficulty.length;\\n        for(int i = 0; i < lOfJobs; i++) {\\n            if(profit[i] > allProfit[difficulty[i]]) {\\n                allProfit[difficulty[i]] = profit[i];\\n            }\\n        }\\n        \\n        int lOfAllProfit = allProfit.length;\\n        int max = allProfit[0];\\n        for(int i = 1; i < lOfAllProfit; i++) {\\n            max = Math.max(max, allProfit[i]);\\n\\t\\t\\tallProfit[i] = max;\\n        }\\n        \\n        int res = 0;\\n        int numOfWorker = worker.length;\\n        for(int i = 0; i < numOfWorker; i++) {\\n            res += allProfit[worker[i]];\\n        }\\n        return res;\\n    }\\n\\t\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] allProfit = new int[100000];\\n        int lOfJobs = difficulty.length;\\n        for(int i = 0; i < lOfJobs; i++) {\\n            if(profit[i] > allProfit[difficulty[i]]) {\\n                allProfit[difficulty[i]] = profit[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 449522,
                "title": "java-priority-queue-solution",
                "content": "```\\nclass Solution \\n{\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) \\n    {\\n        PriorityQueue<Data> pq = new PriorityQueue<>();\\n        for(int i = 0; i < difficulty.length; i++) \\n            pq.offer(new Data(difficulty[i], profit[i]));\\n        int max = 0, sum = 0;\\n        Arrays.sort(worker);\\n        for(int i = 0; i < worker.length; i++)\\n        {\\n            int ability = worker[i];\\n            while(!pq.isEmpty())\\n            {\\n                Data data = pq.peek();\\n                if(data.difficulty > ability) break;\\n                if(data.profit > max) max = data.profit;\\n                pq.poll();\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n    \\n    private class Data implements Comparable<Data>\\n    {\\n        int difficulty, profit;\\n        \\n        Data(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n        \\n        public int compareTo(Data data)\\n        {\\n            return this.difficulty - data.difficulty;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) \\n    {\\n        PriorityQueue<Data> pq = new PriorityQueue<>();\\n        for(int i = 0; i < difficulty.length; i++) \\n            pq.offer(new Data(difficulty[i], profit[i]));\\n        int max = 0, sum = 0;\\n        Arrays.sort(worker);\\n        for(int i = 0; i < worker.length; i++)\\n        {\\n            int ability = worker[i];\\n            while(!pq.isEmpty())\\n            {\\n                Data data = pq.peek();\\n                if(data.difficulty > ability) break;\\n                if(data.profit > max) max = data.profit;\\n                pq.poll();\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n    \\n    private class Data implements Comparable<Data>\\n    {\\n        int difficulty, profit;\\n        \\n        Data(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n        \\n        public int compareTo(Data data)\\n        {\\n            return this.difficulty - data.difficulty;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321714,
                "title": "java-solution-using-treemap",
                "content": "```\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        map.put(0, 0);\\n        for(int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(map.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        int max = 0;\\n        for(int key: map.keySet()) {\\n            max = Math.max(max, map.get(key));\\n            map.put(key, max);\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        map.put(0, 0);\\n        for(int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(map.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        int max = 0;\\n        for(int key: map.keySet()) {\\n            max = Math.max(max, map.get(key));\\n            map.put(key, max);\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267878,
                "title": "super-simple-kotlin-solution-faster-then-100",
                "content": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n\\n        val diffProfit =\\n            difficulty\\n                .zip(profit)\\n                .sortedByDescending { it.second }\\n\\n        return worker\\n            .map { workerMax ->\\n                diffProfit.find { it.first <= workerMax }\\n                    ?.second ?: 0\\n            }.sum()\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n\\n        val diffProfit =\\n            difficulty\\n                .zip(profit)\\n                .sortedByDescending { it.second }\\n\\n        return worker\\n            .map { workerMax ->\\n                diffProfit.find { it.first <= workerMax }\\n                    ?.second ?: 0\\n            }.sum()\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254762,
                "title": "treemap-simple-solution",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t//initialize difficult to profit map\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\tfor(int i=0;i<difficulty.length;i++){\\n\\t\\tmap.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i],0)));\\n\\t}\\n\\t//difficult jobs should have at least easier job\\'s profit \\n\\tint max =0;\\n\\tfor(Integer sortedDifficulty:map.keySet()){\\n\\t\\tmap.put(sortedDifficulty, Math.max(max, map.get(sortedDifficulty)));\\n\\t\\tmax = map.get(sortedDifficulty);\\n\\t}\\n\\t//add each profit to the result\\n\\tint result = 0;\\n\\tfor(int i=0;i<worker.length;i++){\\n\\t\\tif(map.floorKey(worker[i]) != null){\\n\\t\\t\\tresult += map.get(map.floorKey(worker[i]));\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t//initialize difficult to profit map\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\tfor(int i=0;i<difficulty.length;i++){\\n\\t\\tmap.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i],0)));\\n\\t}\\n\\t//difficult jobs should have at least easier job\\'s profit \\n\\tint max =0;\\n\\tfor(Integer sortedDifficulty:map.keySet()){\\n\\t\\tmap.put(sortedDifficulty, Math.max(max, map.get(sortedDifficulty)));\\n\\t\\tmax = map.get(sortedDifficulty);\\n\\t}\\n\\t//add each profit to the result\\n\\tint result = 0;\\n\\tfor(int i=0;i<worker.length;i++){\\n\\t\\tif(map.floorKey(worker[i]) != null){\\n\\t\\t\\tresult += map.get(map.floorKey(worker[i]));\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205773,
                "title": "python-sorting-and-two-pointers",
                "content": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        job = sorted(list(zip(profit, difficulty)), reverse = True)\\n        worker.sort(reverse = True)\\n        \\n        i = j = 0\\n        total = 0\\n        while i < len(worker) and j < len(job):\\n            if worker[i] >= job[j][1]:\\n                total += job[j][0]\\n                i += 1\\n            else:\\n                j += 1\\n        return total\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        job = sorted(list(zip(profit, difficulty)), reverse = True)\\n        worker.sort(reverse = True)\\n        \\n        i = j = 0\\n        total = 0\\n        while i < len(worker) and j < len(job):\\n            if worker[i] >= job[j][1]:\\n                total += job[j][0]\\n                i += 1\\n            else:\\n                j += 1\\n        return total\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 202734,
                "title": "c-javascript-two-pointer-binary-search-solution",
                "content": "C++ Binary Search\\n```\\nclass Solution {\\npublic:\\n    int findProfit(vector<pair<int,int> >& jobs,int target){\\n        \\n        int low=0;\\n        int high=jobs.size()-1;\\n       \\n        while(low+1<high){\\n            int mid=low+((high-low)>>1);\\n    \\n            if(target>=jobs[mid].first){\\n                low=mid;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n        if(target>=jobs[high].first) return jobs[high].second;\\n        if(target>=jobs[low].first) return jobs[low].second;\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        for(int i=1;i<jobs.size();i++){\\n            jobs[i].second=max(jobs[i].second,jobs[i-1].second);\\n        }\\n        for(auto work:worker){\\n            out+=findProfit(jobs,work);\\n        }\\n        return out;\\n    }\\n};\\n```\\n\\nC++ Two Pointers Solution\\n```\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        sort(worker.begin(),worker.end());\\n        int i=0,maxP=0;\\n        for(auto work:worker){\\n            while(i<jobs.size() && work>=jobs[i].first) maxP=max(maxP,jobs[i++].second);\\n            out+=maxP;\\n        }\\n        return out;\\n    }\\n```\\n\\nJavaScript Two Pointers Solution\\n```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    difficulty.forEach(function(value,index){\\n        p[index]=[difficulty[index],profit[index]];\\n    });\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    \\n    let i=0,maxP=0;\\n    worker.sort((a,b)=>a-b);\\n    for(let work of worker){\\n        while(i<p.length && work>=p[i][0])maxP=Math.max(p[i++][1],maxP)\\n        out+=maxP;\\n        \\n    }\\n    return out;\\n};\\n```\\n\\nJavaScript Binary Search\\n```\\nlet findProfit= function(difficulty,target){\\n\\n    let low=0;\\n    let high=difficulty.length-1;\\n\\n    while(low+1<high){\\n        let mid=low+((high-low)>>1);\\n\\n        if(target>=difficulty[mid][0]){\\n            low=mid;\\n        }else{\\n            high=mid;\\n        }\\n    }\\n    if(target>=difficulty[high][0]) return difficulty[high][1];\\n    if(target>=difficulty[low][0]) return difficulty[low][1];\\n\\n    return 0;\\n}\\n    \\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    for(let i=0;i<difficulty.length;i++){\\n        p[i]=[difficulty[i],profit[i]];\\n    }\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    for(let i=1;i<p.length;i++){\\n        p[i][1]=Math.max(p[i][1],p[i-1][1]);\\n    }\\n    for(let work of worker){\\n        out+=findProfit(p,work);\\n    }\\n    return out;\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findProfit(vector<pair<int,int> >& jobs,int target){\\n        \\n        int low=0;\\n        int high=jobs.size()-1;\\n       \\n        while(low+1<high){\\n            int mid=low+((high-low)>>1);\\n    \\n            if(target>=jobs[mid].first){\\n                low=mid;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n        if(target>=jobs[high].first) return jobs[high].second;\\n        if(target>=jobs[low].first) return jobs[low].second;\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        for(int i=1;i<jobs.size();i++){\\n            jobs[i].second=max(jobs[i].second,jobs[i-1].second);\\n        }\\n        for(auto work:worker){\\n            out+=findProfit(jobs,work);\\n        }\\n        return out;\\n    }\\n};\\n```\n```\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        sort(worker.begin(),worker.end());\\n        int i=0,maxP=0;\\n        for(auto work:worker){\\n            while(i<jobs.size() && work>=jobs[i].first) maxP=max(maxP,jobs[i++].second);\\n            out+=maxP;\\n        }\\n        return out;\\n    }\\n```\n```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    difficulty.forEach(function(value,index){\\n        p[index]=[difficulty[index],profit[index]];\\n    });\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    \\n    let i=0,maxP=0;\\n    worker.sort((a,b)=>a-b);\\n    for(let work of worker){\\n        while(i<p.length && work>=p[i][0])maxP=Math.max(p[i++][1],maxP)\\n        out+=maxP;\\n        \\n    }\\n    return out;\\n};\\n```\n```\\nlet findProfit= function(difficulty,target){\\n\\n    let low=0;\\n    let high=difficulty.length-1;\\n\\n    while(low+1<high){\\n        let mid=low+((high-low)>>1);\\n\\n        if(target>=difficulty[mid][0]){\\n            low=mid;\\n        }else{\\n            high=mid;\\n        }\\n    }\\n    if(target>=difficulty[high][0]) return difficulty[high][1];\\n    if(target>=difficulty[low][0]) return difficulty[low][1];\\n\\n    return 0;\\n}\\n    \\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    for(let i=0;i<difficulty.length;i++){\\n        p[i]=[difficulty[i],profit[i]];\\n    }\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    for(let i=1;i<p.length;i++){\\n        p[i][1]=Math.max(p[i][1],p[i-1][1]);\\n    }\\n    for(let work of worker){\\n        out+=findProfit(p,work);\\n    }\\n    return out;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188589,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n        val costAndProfit = (0 until difficulty.size)\\n                .map { Pair(difficulty[it], profit[it]) }\\n                .sortedBy { it.first }\\n                .groupBy { it.first }\\n                .map { it -> Pair(it.key, it.value.maxBy { it.second }!!.second) }\\n        \\n        val prefixMaxProfit = IntArray(costAndProfit.size)\\n        (0 until prefixMaxProfit.size).forEach {\\n            when (it) {\\n                0 -> prefixMaxProfit[it] = costAndProfit[0].second\\n                else -> prefixMaxProfit[it] = Math.max(prefixMaxProfit[it - 1], costAndProfit[it].second)\\n            }\\n        }\\n        \\n        return worker.sumBy { ability ->\\n            val insertAt = costAndProfit.binarySearchBy(ability, 0, costAndProfit.size) { it.first }\\n            when {\\n                insertAt >= 0 -> prefixMaxProfit[insertAt]\\n                insertAt == -1 -> 0\\n                else -> prefixMaxProfit[-insertAt - 2]\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n        val costAndProfit = (0 until difficulty.size)\\n                .map { Pair(difficulty[it], profit[it]) }\\n                .sortedBy { it.first }\\n                .groupBy { it.first }\\n                .map { it -> Pair(it.key, it.value.maxBy { it.second }!!.second) }\\n        \\n        val prefixMaxProfit = IntArray(costAndProfit.size)\\n        (0 until prefixMaxProfit.size).forEach {\\n            when (it) {\\n                0 -> prefixMaxProfit[it] = costAndProfit[0].second\\n                else -> prefixMaxProfit[it] = Math.max(prefixMaxProfit[it - 1], costAndProfit[it].second)\\n            }\\n        }\\n        \\n        return worker.sumBy { ability ->\\n            val insertAt = costAndProfit.binarySearchBy(ability, 0, costAndProfit.size) { it.first }\\n            when {\\n                insertAt >= 0 -> prefixMaxProfit[insertAt]\\n                insertAt == -1 -> 0\\n                else -> prefixMaxProfit[-insertAt - 2]\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164351,
                "title": "simple-java-solution-using-priority-queue",
                "content": "```\\n    public static int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> (a[0]-b[0]));\\n        int n = profit.length, t=0, cur=0;\\n        Arrays.sort(worker);\\n        \\n        for(int i=0;i<n;i++){\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        \\n        for(int i=0;i<worker.length;i++){\\n            while(!pq.isEmpty() && worker[i] >= pq.peek()[0]){\\n                cur = Math.max(cur, pq.poll()[1]);\\n            }\\n            t += cur;\\n        }\\n        \\n        return t;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> (a[0]-b[0]));\\n        int n = profit.length, t=0, cur=0;\\n        Arrays.sort(worker);\\n        \\n        for(int i=0;i<n;i++){\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        \\n        for(int i=0;i<worker.length;i++){\\n            while(!pq.isEmpty() && worker[i] >= pq.peek()[0]){\\n                cur = Math.max(cur, pq.poll()[1]);\\n            }\\n            t += cur;\\n        }\\n        \\n        return t;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 130307,
                "title": "c-nlogn-solution-greedy-using-map-and-sort",
                "content": "```\\n#include <vector>\\n#include <algorithm>\\n#include <vector>\\n#include <algorithm>\\n#include <functional>\\n#include <map>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int,greater<int>> m;\\n        for(int i = 0 ; i < difficulty.size() ; i++)\\n                {\\n                  m[profit[i]] =( m[profit[i]] > difficulty[i] ) ||  m[profit[i]] == 0 ? difficulty[i] : m[profit[i]];\\n                }\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        int ans = 0;\\n        auto iter = m.begin();\\n        for(int i = 0 ; i < worker.size() ; i++)\\n        {\\n          while(iter != m.end() && worker[i] < iter->second ) iter =  m.erase(iter);\\n                ans += iter == m.end() ? 0 : iter->first;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThe key thought is sort and \\n1.if worker_i.ablity > worker_j.ablity && worker_i cannot finish job_k , the work_j cannot finish job_k either.\\n2.if job_m.profit == job_n.profit && job_m.difficulty < job_n.difficulty , then no one will select job_n.\\nSo use sort is a very good way .",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n#include <vector>\\n#include <algorithm>\\n#include <functional>\\n#include <map>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int,greater<int>> m;\\n        for(int i = 0 ; i < difficulty.size() ; i++)\\n                {\\n                  m[profit[i]] =( m[profit[i]] > difficulty[i] ) ||  m[profit[i]] == 0 ? difficulty[i] : m[profit[i]];\\n                }\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        int ans = 0;\\n        auto iter = m.begin();\\n        for(int i = 0 ; i < worker.size() ; i++)\\n        {\\n          while(iter != m.end() && worker[i] < iter->second ) iter =  m.erase(iter);\\n                ans += iter == m.end() ? 0 : iter->first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 129241,
                "title": "c-sort-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>>v;\\n        for(int i = 0; i < difficulty.size(); i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [](vector<int>& v1, vector<int>& v2){ return v1[0] < v2[0]; });\\n        int maxProfit = 0;\\n        for(auto& x: v){\\n            maxProfit = max(maxProfit, x[1]);\\n            x[1] = maxProfit;\\n        }\\n        for(auto& x: worker){\\n            int pos = upper_bound(v.begin(), v.end(), x, [](int v1, vector<int>& v2){ return v1 < v2[0]; }) - v.begin() - 1;\\n            if(pos >= 0) res += v[pos][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>>v;\\n        for(int i = 0; i < difficulty.size(); i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [](vector<int>& v1, vector<int>& v2){ return v1[0] < v2[0]; });\\n        int maxProfit = 0;\\n        for(auto& x: v){\\n            maxProfit = max(maxProfit, x[1]);\\n            x[1] = maxProfit;\\n        }\\n        for(auto& x: worker){\\n            int pos = upper_bound(v.begin(), v.end(), x, [](int v1, vector<int>& v2){ return v1 < v2[0]; }) - v.begin() - 1;\\n            if(pos >= 0) res += v[pos][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127873,
                "title": "c-o-n-using-map",
                "content": "using map to remove possible same level with different profit, and then sort according to the difficulty.\\nsort the worker and using two pointer method to loop. The complxity is O(n+m)\\nThe max_profit is the max profit so far at difficulty level. This is to handle the case when the difficulty is higher, but profit is lower.\\nI add a INT_MAX diffcult at the map so that we can handle the worker>the max difficulty case.\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int> vp;\\n        for(int i=0;i<profit.size();i++) vp[difficulty[i]]=max(vp[difficulty[i]],profit[i]);\\n        vp[INT_MAX]=0;//add one as the end so worker>max can work\\n        sort(worker.begin(),worker.end());\\n        int i=0,max_profit=0,total=0; //max shall be 0\\n        for(auto it=vp.begin();it!=vp.end();it++)\\n        {\\n            while(it->first>worker[i])\\n            {\\n                total+=max_profit;i++;\\n                if(i>=worker.size()) break;\\n            }\\n            if(i>=worker.size()) break;\\n            max_profit=max(max_profit,it->second);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int> vp;\\n        for(int i=0;i<profit.size();i++) vp[difficulty[i]]=max(vp[difficulty[i]],profit[i]);\\n        vp[INT_MAX]=0;//add one as the end so worker>max can work\\n        sort(worker.begin(),worker.end());\\n        int i=0,max_profit=0,total=0; //max shall be 0\\n        for(auto it=vp.begin();it!=vp.end();it++)\\n        {\\n            while(it->first>worker[i])\\n            {\\n                total+=max_profit;i++;\\n                if(i>=worker.size()) break;\\n            }\\n            if(i>=worker.size()) break;\\n            max_profit=max(max_profit,it->second);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127151,
                "title": "java-accepted-solution",
                "content": "Sort and assign.\\n\\n```\\nclass Solution {\\n    private class Task {\\n        int diff;\\n        int pro;\\n        public Task(int d, int p) {\\n            diff = d;\\n            pro = p;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Task> tasks = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            tasks.add(new Task(difficulty[i], profit[i]));\\n        }\\n        \\n        Collections.sort(tasks, (a, b) -> b.pro - a.pro);\\n        int res = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            for (Task t : tasks) {\\n                if (t.diff <= worker[i]) {\\n                    res += t.pro;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private class Task {\\n        int diff;\\n        int pro;\\n        public Task(int d, int p) {\\n            diff = d;\\n            pro = p;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Task> tasks = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            tasks.add(new Task(difficulty[i], profit[i]));\\n        }\\n        \\n        Collections.sort(tasks, (a, b) -> b.pro - a.pro);\\n        int res = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            for (Task t : tasks) {\\n                if (t.diff <= worker[i]) {\\n                    res += t.pro;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127114,
                "title": "concise-java-solution-using-map",
                "content": "```\\n public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int maxD = 0;\\n        for(int i = 0;i<difficulty.length;++i){\\n            if(!map.containsKey(difficulty[i])) map.put(difficulty[i],profit[i]);   \\n            else map.put(difficulty[i],Math.max(map.get(difficulty[i]),profit[i])); \\n            maxD = Math.max(maxD,difficulty[i]);     \\n        }    \\n        int[] p =  new int[maxD + 1];\\n        for(int i=1;i<p.length;++i){\\n            p[i] = Math.max(p[i-1],map.getOrDefault(i,0));  // max profit for difficulty in [1,maxD]\\n        }\\n        \\n        int maxP = 0;\\n        for(int i=0;i<worker.length;++i){\\n            maxP+= worker[i] > maxD? p[maxD] : p[worker[i]];\\n        }\\n        return maxP;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int maxD = 0;\\n        for(int i = 0;i<difficulty.length;++i){\\n            if(!map.containsKey(difficulty[i])) map.put(difficulty[i],profit[i]);   \\n            else map.put(difficulty[i],Math.max(map.get(difficulty[i]),profit[i])); \\n            maxD = Math.max(maxD,difficulty[i]);     \\n        }    \\n        int[] p =  new int[maxD + 1];\\n        for(int i=1;i<p.length;++i){\\n            p[i] = Math.max(p[i-1],map.getOrDefault(i,0));  // max profit for difficulty in [1,maxD]\\n        }\\n        \\n        int maxP = 0;\\n        for(int i=0;i<worker.length;++i){\\n            maxP+= worker[i] > maxD? p[maxD] : p[worker[i]];\\n        }\\n        return maxP;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 127028,
                "title": "java-solution-o-m-n-log-m-n-time-and-o-n-space-with-explanation-easily-understand",
                "content": "```\\n/** O O((m + n)log(m + n)) time complexity and O(n) space complexity, m is the length of workers, n is length of jobs;\\n *  sort jobs according to the profit, and sort workers\\n *  scan jobs and workers both from the end, for worker[i], decrement j if jobs[j].level is higher than worker[i];\\n *  otherwise, the current profit is highest one worker[i] can achieve, add it to the maxprofit;\\n *  for worker[i - 1], since worker[i - 1] can only complete work with difficulty less than worker[i]\\n *  so all the previous jobs pass by worker[i] will also be passed by worker[i - 1], so we don\\'t need to back up pointer j to recheck\\n */\\nclass Solution {\\n    private class Job implements Comparable<Job>{\\n        int level;\\n        int prof;\\n        \\n        public Job(int level, int prof) {\\n            this.level = level;\\n            this.prof = prof;\\n        }\\n        \\n        public int compareTo(Job that) {\\n            return this.prof - that.prof;\\n        }\\n    }\\n    \\n            \\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Arrays.sort(worker);\\n        int n = difficulty.length;\\n        Job[] jobs = new Job[n];\\n        for (int i = 0; i < n; i++) {\\n            jobs[i] = new Job(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(jobs);\\n        int max = 0;\\n        \\n        int i = worker.length - 1, j = jobs.length - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (jobs[j].level > worker[i]) j--;\\n            else {\\n                max += jobs[j].prof;\\n                i--;\\n            }\\n        }\\n        return max;     \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private class Job implements Comparable<Job>{\\n        int level;\\n        int prof;\\n        \\n        public Job(int level, int prof) {\\n            this.level = level;\\n            this.prof = prof;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 126988,
                "title": "o-m-n-solution-based-on-preprocessing",
                "content": "Just keep a preprocess array for max profit until difficulty[index]\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] diff = new int[100000 + 1]; //10^5\\n        //diff[i] = maxProfit until difficulty i (inclusive)\\n        for(int i = 0; i < difficulty.length; ++i){\\n            diff[difficulty[i]] = Math.max(diff[difficulty[i]], profit[i]);\\n        }\\n        \\n        for(int i = 1; i < diff.length; ++i){\\n            diff[i] = Math.max(diff[i], diff[i - 1]);\\n        }\\n        int sol = 0;\\n        \\n        for(int x : worker) sol += diff[x];\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] diff = new int[100000 + 1]; //10^5\\n        //diff[i] = maxProfit until difficulty i (inclusive)\\n        for(int i = 0; i < difficulty.length; ++i){\\n            diff[difficulty[i]] = Math.max(diff[difficulty[i]], profit[i]);\\n        }\\n        \\n        for(int i = 1; i < diff.length; ++i){\\n            diff[i] = Math.max(diff[i], diff[i - 1]);\\n        }\\n        int sol = 0;\\n        \\n        for(int x : worker) sol += diff[x];\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126987,
                "title": "easy-to-understand-java-solution-with-priorityqueue-detail-explanation",
                "content": "This problem seems easy at first glance, but it does not provide too much details. Now consider, if a lower difficulty task has a higher profit, or two same difficulty tasks have different profits, then simply sorting the arrays and putting them into a map will not yield the most profit (sometimes it may work?). So I used a PriorityQueue to sort based on the profit (descending), and if there are same profits, then sort by their corresponding difficulties (descending). \\nNow sort the workers array. Check if their abilities are sufficient to do the work (pq.peek()). This way, it will certainly yield the highest profit.\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t\\t// sort the profit and difficulty arrays based on profit value and then difficulty values.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] > b[0]) return -1;\\n                else if (a[0] < b[0]) return 1;\\n                else return b[1] - a[1];\\n            }\\n        });\\n        for (int i = 0; i < profit.length; i++) {\\n            pq.offer(new int[]{profit[i], difficulty[i]});\\n        }\\n        Arrays.sort(worker);\\n        int res = 0;\\n\\t\\t\\t\\t// check workers ability, if it does not match, the next object in the pq will give next highest profit with less difficulty \\n        for (int i = worker.length - 1; i >= 0; i--) {\\n            while (!pq.isEmpty() && worker[i] < pq.peek()[1]) pq.poll();\\n            if (!pq.isEmpty()) res += pq.peek()[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t\\t// sort the profit and difficulty arrays based on profit value and then difficulty values.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] > b[0]) return -1;\\n                else if (a[0] < b[0]) return 1;\\n                else return b[1] - a[1];\\n            }\\n        });\\n        for (int i = 0; i < profit.length; i++) {\\n            pq.offer(new int[]{profit[i], difficulty[i]});\\n        }\\n        Arrays.sort(worker);\\n        int res = 0;\\n\\t\\t\\t\\t// check workers ability, if it does not match, the next object in the pq will give next highest profit with less difficulty \\n        for (int i = worker.length - 1; i >= 0; i--) {\\n            while (!pq.isEmpty() && worker[i] < pq.peek()[1]) pq.poll();\\n            if (!pq.isEmpty()) res += pq.peek()[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126983,
                "title": "python-solution",
                "content": "```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        import bisect\\n        \\n        sum_=0\\n        \\n        diff_profit = [(a,b) for a,b in zip(difficulty,profit)]\\n        \\n        diff_profit=sorted(diff_profit, key=lambda a:a[0])\\n                \\n        new_diffs=[0]\\n        new_profits=[0]\\n        \\n        for i in range(len(diff_profit)):\\n            if diff_profit[i][1]>new_profits[-1]:\\n                new_profits.append(diff_profit[i][1])\\n                new_diffs.append(diff_profit[i][0])\\n\\n        \\n        for i in range(len(worker)):\\n            index= bisect.bisect(new_diffs, worker[i])\\n            # print index, worker[i]\\n            if index-1<0:\\n                continue\\n            sum_+=new_profits[index-1]\\n        return sum_\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        import bisect\\n        \\n        sum_=0\\n        \\n        diff_profit = [(a,b) for a,b in zip(difficulty,profit)]\\n        \\n        diff_profit=sorted(diff_profit, key=lambda a:a[0])\\n                \\n        new_diffs=[0]\\n        new_profits=[0]\\n        \\n        for i in range(len(diff_profit)):\\n            if diff_profit[i][1]>new_profits[-1]:\\n                new_profits.append(diff_profit[i][1])\\n                new_diffs.append(diff_profit[i][0])\\n\\n        \\n        for i in range(len(worker)):\\n            index= bisect.bisect(new_diffs, worker[i])\\n            # print index, worker[i]\\n            if index-1<0:\\n                continue\\n            sum_+=new_profits[index-1]\\n        return sum_\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 126956,
                "title": "easy-java-solution-with-treemap-sorting",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int[][] arr = new int[difficulty.length][2];\\n        for(int i=0; i < difficulty.length; i++){\\n\\t\\t\\tarr[i][0] = difficulty[i];\\n\\t\\t\\tarr[i][1] = profit[i];\\n\\t\\t}\\n        Arrays.sort(arr, new Comparator<int[]>(){\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] a1, int[] a2){\\n\\t\\t\\t\\treturn a1[0]<a2[0]? -1: a1[0] == a2[0]? 0:1;\\n\\t\\t\\t}\\n\\t\\t});\\n        for(int i=1; i<arr.length; i++){\\n\\t\\t\\tarr[i][1] = Math.max(arr[i-1][1], arr[i][1]);\\n\\t\\t}\\n\\t\\tfor(int i=0; i<arr.length; i++){\\n\\t\\t\\tmap.put(arr[i][0], arr[i][1]);\\n\\t\\t}\\n        int ans = 0;\\n\\t\\tfor(int i=0; i<worker.length; i++){\\n\\t\\t\\tint ability = worker[i];\\n\\t\\t\\tInteger index = map.floorKey(ability);\\n\\t\\t\\tif(index != null){\\n                ans+=map.get(index);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int[][] arr = new int[difficulty.length][2];\\n        for(int i=0; i < difficulty.length; i++){\\n\\t\\t\\tarr[i][0] = difficulty[i];\\n\\t\\t\\tarr[i][1] = profit[i];\\n\\t\\t}\\n        Arrays.sort(arr, new Comparator<int[]>(){\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] a1, int[] a2){\\n\\t\\t\\t\\treturn a1[0]<a2[0]? -1: a1[0] == a2[0]? 0:1;\\n\\t\\t\\t}\\n\\t\\t});\\n        for(int i=1; i<arr.length; i++){\\n\\t\\t\\tarr[i][1] = Math.max(arr[i-1][1], arr[i][1]);\\n\\t\\t}\\n\\t\\tfor(int i=0; i<arr.length; i++){\\n\\t\\t\\tmap.put(arr[i][0], arr[i][1]);\\n\\t\\t}\\n        int ans = 0;\\n\\t\\tfor(int i=0; i<worker.length; i++){\\n\\t\\t\\tint ability = worker[i];\\n\\t\\t\\tInteger index = map.floorKey(ability);\\n\\t\\t\\tif(index != null){\\n                ans+=map.get(index);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126941,
                "title": "python-binary-search-solution-with-comments",
                "content": "```\\nclass Solution(object):\\n    def maxProfitAssignment(self, diff, pro, worker):\\n        N = len(diff)\\n        # Record max profit for each difficulty\\n        dic = {}\\n        for i in range(N):\\n            if diff[i] not in dic or pro[i]>dic[diff[i]]:\\n                dic[diff[i]] = pro[i]\\n        # Sort difficult and record max profit with diff[i] in pre\\n        diff = list(set(diff))\\n        diff.sort()\\n        pre = [0]*(len(diff)+1)\\n        \\n        for i in range(len(diff)):\\n            pre[i] = max(pre[i-1], dic[diff[i]])\\n        \\n        ret = 0\\n        for w in worker:\\n            # Use binary seach for each worker\\n            idx = bisect.bisect_left(diff, w)\\n            if idx==len(diff) or w<diff[idx]:\\n                idx -= 1\\n            ret += pre[idx]\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfitAssignment(self, diff, pro, worker):\\n        N = len(diff)\\n        # Record max profit for each difficulty\\n        dic = {}\\n        for i in range(N):\\n            if diff[i] not in dic or pro[i]>dic[diff[i]]:\\n                dic[diff[i]] = pro[i]\\n        # Sort difficult and record max profit with diff[i] in pre\\n        diff = list(set(diff))\\n        diff.sort()\\n        pre = [0]*(len(diff)+1)\\n        \\n        for i in range(len(diff)):\\n            pre[i] = max(pre[i-1], dic[diff[i]])\\n        \\n        ret = 0\\n        for w in worker:\\n            # Use binary seach for each worker\\n            idx = bisect.bisect_left(diff, w)\\n            if idx==len(diff) or w<diff[idx]:\\n                idx -= 1\\n            ret += pre[idx]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096222,
                "title": "easiest-way-to-solve-using-matrix-and-greedy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    // //brute force\\n    // let resprofit=0,map=new Map();\\n    // for(let i=0;i<difficulty.length;i++){\\n    //     map.set(difficulty[i],profit[i]);\\n    // }\\n    // const getMaxProfit=(target)=>{\\n    //     let maxprofit=0;\\n    //  for(let i=0;i<difficulty.length;i++){\\n    //   if(difficulty[i]<=target){\\n    //   maxprofit=Math.max(maxprofit,map.get(difficulty[i]))\\n    //   }\\n    //   else break;\\n    //  }\\n    //  return maxprofit;\\n    // }\\n    // for(let i=0;i<worker.length;i++){\\n    //     let currworker=worker[i];\\n    //     resprofit+=getMaxProfit(currworker);\\n    // }\\n    // return resprofit;\\n\\n    //greedy approch\\n    let jobs=[];\\n    for(let i=0;i<difficulty.length;i++){\\n        jobs.push([difficulty[i],profit[i]]);\\n    }\\n    jobs.sort((a,b)=>a[0]-b[0]);\\n    worker.sort((a,b)=>a-b);\\n\\n    let maxprofit=0,jobindex=0,bestprofit=0;\\n    for(let i=0;i<worker.length;i++){\\n        let ability=worker[i];\\n        while(jobindex < difficulty.length && jobs[jobindex][0] <=ability){\\n            bestprofit=Math.max(bestprofit,jobs[jobindex][1]);\\n            jobindex++;\\n        }\\n        maxprofit+=bestprofit;\\n    }\\n    return maxprofit;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    // //brute force\\n    // let resprofit=0,map=new Map();\\n    // for(let i=0;i<difficulty.length;i++){\\n    //     map.set(difficulty[i],profit[i]);\\n    // }\\n    // const getMaxProfit=(target)=>{\\n    //     let maxprofit=0;\\n    //  for(let i=0;i<difficulty.length;i++){\\n    //   if(difficulty[i]<=target){\\n    //   maxprofit=Math.max(maxprofit,map.get(difficulty[i]))\\n    //   }\\n    //   else break;\\n    //  }\\n    //  return maxprofit;\\n    // }\\n    // for(let i=0;i<worker.length;i++){\\n    //     let currworker=worker[i];\\n    //     resprofit+=getMaxProfit(currworker);\\n    // }\\n    // return resprofit;\\n\\n    //greedy approch\\n    let jobs=[];\\n    for(let i=0;i<difficulty.length;i++){\\n        jobs.push([difficulty[i],profit[i]]);\\n    }\\n    jobs.sort((a,b)=>a[0]-b[0]);\\n    worker.sort((a,b)=>a-b);\\n\\n    let maxprofit=0,jobindex=0,bestprofit=0;\\n    for(let i=0;i<worker.length;i++){\\n        let ability=worker[i];\\n        while(jobindex < difficulty.length && jobs[jobindex][0] <=ability){\\n            bestprofit=Math.max(bestprofit,jobs[jobindex][1]);\\n            jobindex++;\\n        }\\n        maxprofit+=bestprofit;\\n    }\\n    return maxprofit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090525,
                "title": "c-sorting",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\\\log{n})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>> v;\\n        for (int i = 0; i < profit.size(); ++ i) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [] (const vector<int>& l, const vector<int>& r) {\\n            return l[0] == r[0] ? l[1] < r[1] : l[0] < r[0];\\n        });\\n        for (int i = 1; i < v.size(); ++ i) v[i][1] = max(v[i][1], v[i - 1][1]);\\n        sort(worker.begin(), worker.end());\\n        int k = 0;\\n        for (int w : worker) {\\n            while (k < v.size() && v[k][0] <= w) ++ k;\\n            if (k) -- k;\\n            if (v[k][0] <= w) res += v[k][1];\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>> v;\\n        for (int i = 0; i < profit.size(); ++ i) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [] (const vector<int>& l, const vector<int>& r) {\\n            return l[0] == r[0] ? l[1] < r[1] : l[0] < r[0];\\n        });\\n        for (int i = 1; i < v.size(); ++ i) v[i][1] = max(v[i][1], v[i - 1][1]);\\n        sort(worker.begin(), worker.end());\\n        int k = 0;\\n        for (int w : worker) {\\n            while (k < v.size() && v[k][0] <= w) ++ k;\\n            if (k) -- k;\\n            if (v[k][0] <= w) res += v[k][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055585,
                "title": "c-o-nlogn-easy-solution",
                "content": "# Complexity\\n# - Time complexity:**O(nlogn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# - Space complexity:**O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w){\\n        vector<pair<int,int>>vp;\\n        for(int i =0 ;i<(int)d.size();i++){\\n            vp.push_back(make_pair(d[i],p[i]));\\n        }\\n        sort(d.begin(),d.end()),sort(vp.begin(),vp.end());\\n        int res = 0;\\n        for(int i = 1;i<(int)vp.size();i++){\\n            vp[i].second = max(vp[i].second,vp[i-1].second);\\n        }\\n        for(int i = 0;i<(int)w.size();i++){\\n            int idx = upper_bound(d.begin(),d.end(),w[i]) - d.begin();\\n            if(idx){\\n                idx--;\\n                res+=vp[idx].second;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w){\\n        vector<pair<int,int>>vp;\\n        for(int i =0 ;i<(int)d.size();i++){\\n            vp.push_back(make_pair(d[i],p[i]));\\n        }\\n        sort(d.begin(),d.end()),sort(vp.begin(),vp.end());\\n        int res = 0;\\n        for(int i = 1;i<(int)vp.size();i++){\\n            vp[i].second = max(vp[i].second,vp[i-1].second);\\n        }\\n        for(int i = 0;i<(int)w.size();i++){\\n            int idx = upper_bound(d.begin(),d.end(),w[i]) - d.begin();\\n            if(idx){\\n                idx--;\\n                res+=vp[idx].second;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024965,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012095,
                "title": "simple-sorting-for-loop-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d,vector<int>& p,vector<int>& w) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            v.push_back(make_pair(p[i],d[i]));\\n        }\\n        sort(v.rbegin(),v.rend());\\n        sort(w.rbegin(),w.rend());\\n        int j=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(w[j]>=v[i].second)\\n            {\\n                ans+=v[i].first;\\n                j++;\\n                i--;\\n            }\\n            if(j==w.size()) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d,vector<int>& p,vector<int>& w) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            v.push_back(make_pair(p[i],d[i]));\\n        }\\n        sort(v.rbegin(),v.rend());\\n        sort(w.rbegin(),w.rend());\\n        int j=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(w[j]>=v[i].second)\\n            {\\n                ans+=v[i].first;\\n                j++;\\n                i--;\\n            }\\n            if(j==w.size()) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007709,
                "title": "most-profit-assigning-work",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    let Ability = new Map();\\n    for(let i=0;i<worker.length;i++){\\n        for(let j=0;j<difficulty.length;j++){\\n        if(worker[i]>=difficulty[j]){\\n            if(Ability.has(i)){\\n                Ability.set(i,Math.max(Math.max(Ability.get(i),profit[j])))\\n            }\\n            else{\\n                Ability.set(i,profit[j])\\n            }\\n        }\\n        }\\n    }\\n   return Array.from(Ability.values()).reduce((acc,cur)=>{return acc+=cur},0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    let Ability = new Map();\\n    for(let i=0;i<worker.length;i++){\\n        for(let j=0;j<difficulty.length;j++){\\n        if(worker[i]>=difficulty[j]){\\n            if(Ability.has(i)){\\n                Ability.set(i,Math.max(Math.max(Ability.get(i),profit[j])))\\n            }\\n            else{\\n                Ability.set(i,profit[j])\\n            }\\n        }\\n        }\\n    }\\n   return Array.from(Ability.values()).reduce((acc,cur)=>{return acc+=cur},0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005645,
                "title": "javascript-compact-solution",
                "content": "```javascript\\nconst maxProfitAssignment = (dif, prof, workers) => {\\n  const tasks = dif.map((d, i) => [d, prof[i]]);\\n  tasks.sort(([d1, p1], [d2, p2]) => d1 - d2);\\n\\n  workers = workers.filter((w) => w >= tasks[0][0]);\\n  if (!workers.length) return 0; // strongest worker < easiest job\\n\\n  let maxProf = 0;\\n  const balancedTasks = tasks.map(([d, p]) => {\\n    if (p > maxProf) maxProf = p;\\n    return [d, maxProf];\\n  });\\n\\n  workers.sort((a, b) => a - b);\\n  const len = balancedTasks.length;\\n  let i = 0;\\n\\n  return workers.reduce((tot, worker) => {\\n    while (i < len && balancedTasks[i][0] <= worker) i++;\\n    return tot + balancedTasks[i - 1][1];\\n  }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst maxProfitAssignment = (dif, prof, workers) => {\\n  const tasks = dif.map((d, i) => [d, prof[i]]);\\n  tasks.sort(([d1, p1], [d2, p2]) => d1 - d2);\\n\\n  workers = workers.filter((w) => w >= tasks[0][0]);\\n  if (!workers.length) return 0; // strongest worker < easiest job\\n\\n  let maxProf = 0;\\n  const balancedTasks = tasks.map(([d, p]) => {\\n    if (p > maxProf) maxProf = p;\\n    return [d, maxProf];\\n  });\\n\\n  workers.sort((a, b) => a - b);\\n  const len = balancedTasks.length;\\n  let i = 0;\\n\\n  return workers.reduce((tot, worker) => {\\n    while (i < len && balancedTasks[i][0] <= worker) i++;\\n    return tot + balancedTasks[i - 1][1];\\n  }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992366,
                "title": "greedy-static-comparator",
                "content": "# Intuition\\nFirst arrange the difficulty array according to the profit array in descending order so that we can select closest difficulty with max profit.\\n\\nFor all the elements of worker check if the max profit difficulty is lesser than or equal to and if not keep decreasing difficulty.\\n\\nif correct difficulty is found add subsequent profit to the profit(total)\\n\\nreturn total profit\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool static cmp(const pair<int,int>& p1,const pair<int,int>& p2)\\n    {\\n        return p1.second>p2.second;\\n    }\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) \\n    {\\n        vector<pair<int,int>> m;//difficulty and profit\\n        for(int i=0;i<d.size();i++)\\n        {\\n            m.push_back({d[i],p[i]});\\n        }\\n        int n=w.size();\\n        int profit=0;\\n        sort(m.begin(),m.end(),cmp);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m.size();j++)\\n            {\\n                if(m[j].first<=w[i])\\n                {\\n                    profit+=m[j].second;\\n                    break;\\n                }\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(const pair<int,int>& p1,const pair<int,int>& p2)\\n    {\\n        return p1.second>p2.second;\\n    }\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) \\n    {\\n        vector<pair<int,int>> m;//difficulty and profit\\n        for(int i=0;i<d.size();i++)\\n        {\\n            m.push_back({d[i],p[i]});\\n        }\\n        int n=w.size();\\n        int profit=0;\\n        sort(m.begin(),m.end(),cmp);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m.size();j++)\\n            {\\n                if(m[j].first<=w[i])\\n                {\\n                    profit+=m[j].second;\\n                    break;\\n                }\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975311,
                "title": "dry-run-it-is-easiest-solution-begineer-friendly",
                "content": "# easy solution ...  :)\\n# HAPPY LEETCODING\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        worker.sort()\\n        arr=[]\\n        for i in range(len(profit)):\\n            arr.append([difficulty[i],profit[i]])\\n        arr.sort()\\n        ans=0\\n        max_score=0\\n        l=0\\n        for i in range(len(worker)):\\n            while l<len(arr) and arr[l][0]<=worker[i]:\\n                max_score=max(max_score,arr[l][1])\\n                l+=1\\n            ans+=max_score\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        worker.sort()\\n        arr=[]\\n        for i in range(len(profit)):\\n            arr.append([difficulty[i],profit[i]])\\n        arr.sort()\\n        ans=0\\n        max_score=0\\n        l=0\\n        for i in range(len(worker)):\\n            while l<len(arr) and arr[l][0]<=worker[i]:\\n                max_score=max(max_score,arr[l][1])\\n                l+=1\\n            ans+=max_score\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938170,
                "title": "kotlin-2-pointers",
                "content": "# Intuition\\nSort both the workers (descending) and the jobs by profit (descending). Start from the first job (most profitable) and try to assign it to as many capable workers as you can.\\n\\nSince the workers array is decendengly sorted by difficulty, the most capable worker is the one at hand. If that worker can not handle the job at hand, then no other worker will. We can safley discard the job in that case and pickup the next job in line.\\n\\nKeep matching jobs with workers as long as we still have jobs and workers remaining.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    data class Job(val difficulty: Int, val profit: Int)\\n\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n       // Most capable worker is the first.\\n       worker.sortDescending()\\n\\n       val jobs = mutableListOf<Job>()\\n       for(i in difficulty.indices) {\\n           jobs.add(Job(difficulty[i], profit[i]))\\n       }\\n       // Most profitable job is the first.\\n       // Try to assign it to as many workers as we can.\\n       jobs.sortWith(Comparator { x, y -> y.profit.compareTo(x.profit) })\\n\\n       var w = 0\\n       var j = 0\\n       var sum = 0\\n       // We still have workers and jobs left.\\n       while(w < worker.size && j < jobs.size) {\\n           // The most profitable job can be handled by the most capable worker.\\n           if(jobs[j].difficulty <= worker[w]) \\n               sum += jobs[j].profit\\n               // Assign the job to the worker and pickup the next worker in line. \\n               // We\\'ll keep the same job since it is the most profitable so far.\\n               // We\\'ll try to assign it to the next worker in the next iteration.\\n               w += 1\\n           } else {\\n               // The most capable worker so far can not handle this job. No one else can.\\n               // Discard the job and pickup the next one in line.\\n               j += 1\\n           }\\n       }\\n\\n       return sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\n    data class Job(val difficulty: Int, val profit: Int)\\n\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n       // Most capable worker is the first.\\n       worker.sortDescending()\\n\\n       val jobs = mutableListOf<Job>()\\n       for(i in difficulty.indices) {\\n           jobs.add(Job(difficulty[i], profit[i]))\\n       }\\n       // Most profitable job is the first.\\n       // Try to assign it to as many workers as we can.\\n       jobs.sortWith(Comparator { x, y -> y.profit.compareTo(x.profit) })\\n\\n       var w = 0\\n       var j = 0\\n       var sum = 0\\n       // We still have workers and jobs left.\\n       while(w < worker.size && j < jobs.size) {\\n           // The most profitable job can be handled by the most capable worker.\\n           if(jobs[j].difficulty <= worker[w]) \\n               sum += jobs[j].profit\\n               // Assign the job to the worker and pickup the next worker in line. \\n               // We\\'ll keep the same job since it is the most profitable so far.\\n               // We\\'ll try to assign it to the next worker in the next iteration.\\n               w += 1\\n           } else {\\n               // The most capable worker so far can not handle this job. No one else can.\\n               // Discard the job and pickup the next one in line.\\n               j += 1\\n           }\\n       }\\n\\n       return sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929649,
                "title": "java-treemap-solution-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924278,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& prof, vector<int>& worker) \\n    {\\n        int j,ans;\\n        j=0;\\n        ans=0;\\n\\n        vector<pair<int,int>> v;\\n\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],prof[i]});\\n        }    \\n\\n        sort(v.begin(),v.end());\\n        sort(worker.begin(),worker.end());\\n\\n        //for(int i=0;i<worker.size();i++)\\n        //{\\n        //    cout<<worker[i]<<\" \";\\n        //}\\n        //cout<<endl;\\n//\\n        //for(int i=0;i<v.size();i++)\\n        //{\\n        //    cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n        //}\\n\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            while(j<v.size() && v[j].first<=worker[i])\\n            {\\n                j++;\\n                v[j].second=max(v[j-1].second,v[j].second);\\n            }\\n\\n            if(j!=0)\\n            {\\n                ans+=v[j-1].second;\\n            }    \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& prof, vector<int>& worker) \\n    {\\n        int j,ans;\\n        j=0;\\n        ans=0;\\n\\n        vector<pair<int,int>> v;\\n\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],prof[i]});\\n        }    \\n\\n        sort(v.begin(),v.end());\\n        sort(worker.begin(),worker.end());\\n\\n        //for(int i=0;i<worker.size();i++)\\n        //{\\n        //    cout<<worker[i]<<\" \";\\n        //}\\n        //cout<<endl;\\n//\\n        //for(int i=0;i<v.size();i++)\\n        //{\\n        //    cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n        //}\\n\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            while(j<v.size() && v[j].first<=worker[i])\\n            {\\n                j++;\\n                v[j].second=max(v[j-1].second,v[j].second);\\n            }\\n\\n            if(j!=0)\\n            {\\n                ans+=v[j-1].second;\\n            }    \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3872181,
                "title": "c-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Array.Sort(difficulty, profit);\\n        Array.Sort(worker);\\n        \\n        int i = 0, j = 0, maxpro = 0, res = 0;\\n        \\n        while(j < worker.Length)\\n        {\\n            if(i < difficulty.Length && difficulty[i] <= worker[j])\\n            {\\n                maxpro = Math.Max(maxpro, profit[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                res += maxpro;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Array.Sort(difficulty, profit);\\n        Array.Sort(worker);\\n        \\n        int i = 0, j = 0, maxpro = 0, res = 0;\\n        \\n        while(j < worker.Length)\\n        {\\n            if(i < difficulty.Length && difficulty[i] <= worker[j])\\n            {\\n                maxpro = Math.Max(maxpro, profit[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                res += maxpro;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865355,
                "title": "easy-and-fast-max-heap-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.) Use of Priority queue to obtain the maximum profit job every time.\\n2.) sort the worker array and traverse it from right side to check for the maximum skill with maximum profit from priority queue.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n           \\n             priority_queue< pair<int,int>  > pq;\\n\\n             for(int i=0;i<profit.size();i++){\\n                   pq.push({profit[i],difficulty[i]});\\n             }\\n\\n             sort(worker.begin(),worker.end());\\n             int ans=0;\\n             int i=worker.size()-1;\\n\\n             while(i>=0 && !pq.empty()){\\n\\n                 int skill=worker[i];\\n\\n                 if(skill < pq.top().second)\\n                      pq.pop();\\n                 \\n                 else\\n                     ans += pq.top().first,i--;\\n\\n                     \\n\\n             }\\n\\n             \\n\\n\\n                return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n           \\n             priority_queue< pair<int,int>  > pq;\\n\\n             for(int i=0;i<profit.size();i++){\\n                   pq.push({profit[i],difficulty[i]});\\n             }\\n\\n             sort(worker.begin(),worker.end());\\n             int ans=0;\\n             int i=worker.size()-1;\\n\\n             while(i>=0 && !pq.empty()){\\n\\n                 int skill=worker[i];\\n\\n                 if(skill < pq.top().second)\\n                      pq.pop();\\n                 \\n                 else\\n                     ans += pq.top().first,i--;\\n\\n                     \\n\\n             }\\n\\n             \\n\\n\\n                return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857231,
                "title": "using-maxheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\n        maxHeap = []\\n        for d, p in zip(difficulty, profit):\\n            heappush(maxHeap, (-p, d))\\n\\n        sorted_worker = sorted(worker)\\n        maxProfit = 0\\n\\n        for w in sorted_worker[::-1]:\\n\\n            while maxHeap and w < maxHeap[0][1]:\\n                heappop(maxHeap)\\n            if not maxHeap:\\n                return maxProfit\\n            maxProfit += -maxHeap[0][0]\\n\\n        return maxProfit\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\n        maxHeap = []\\n        for d, p in zip(difficulty, profit):\\n            heappush(maxHeap, (-p, d))\\n\\n        sorted_worker = sorted(worker)\\n        maxProfit = 0\\n\\n        for w in sorted_worker[::-1]:\\n\\n            while maxHeap and w < maxHeap[0][1]:\\n                heappop(maxHeap)\\n            if not maxHeap:\\n                return maxProfit\\n            maxProfit += -maxHeap[0][0]\\n\\n        return maxProfit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853608,
                "title": "c-solution-in-o-w",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847464,
                "title": "c-sorting",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn(n) + mlog(m))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i].first = profit[i];\\n            v[i].second = difficulty[i];\\n        }\\n        sort(v.begin(),v.end());\\n        int i = n - 1;\\n        sort(worker.begin(),worker.end());\\n        int j = m - 1;\\n        int ans = 0;\\n        while(i >= 0)\\n        {\\n            while(j >= 0 && worker[j] >= v[i].second)\\n            {\\n                ans += v[i].first;\\n                j--;\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i].first = profit[i];\\n            v[i].second = difficulty[i];\\n        }\\n        sort(v.begin(),v.end());\\n        int i = n - 1;\\n        sort(worker.begin(),worker.end());\\n        int j = m - 1;\\n        int ans = 0;\\n        while(i >= 0)\\n        {\\n            while(j >= 0 && worker[j] >= v[i].second)\\n            {\\n                ans += v[i].first;\\n                j--;\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828435,
                "title": "easy-to-understand-easy-solution-better-approach",
                "content": "# Intuition\\nYou have to sort the difficulty and worker array if you want to complete in one iteration.\\n\\n\\n# Complexity\\n- Time complexity: O(N logN) + O(M logM)\\n\\n- Space complexity: O(N) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& wor) {\\n        int n = diff.size() , m = wor.size();\\n        vector<int> map(100001 , 0);       \\n        for(int i = 0 ; i < n ; i++){\\n            map[diff[i]] = max(map[diff[i]] , pro[i]);\\n        }\\n        sort(diff.begin() , diff.end());  \\n        sort(wor.begin() , wor.end());\\n        int i = 0 , j = 0 , ans = 0 , maxi = 0;\\n        while(i<m){\\n            while(j < n && wor[i] >= diff[j]){\\n                maxi = max(maxi , map[diff[j]]) ; j++;\\n            }\\n            ans += maxi;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& wor) {\\n        int n = diff.size() , m = wor.size();\\n        vector<int> map(100001 , 0);       \\n        for(int i = 0 ; i < n ; i++){\\n            map[diff[i]] = max(map[diff[i]] , pro[i]);\\n        }\\n        sort(diff.begin() , diff.end());  \\n        sort(wor.begin() , wor.end());\\n        int i = 0 , j = 0 , ans = 0 , maxi = 0;\\n        while(i<m){\\n            while(j < n && wor[i] >= diff[j]){\\n                maxi = max(maxi , map[diff[j]]) ; j++;\\n            }\\n            ans += maxi;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812917,
                "title": "c-simple-solution-sorting-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = profit.size(), ans = 0;\\n        vector<pair<int, int>> v;\\n\\n        for(int i = 0; i < n; i++)\\n            v.push_back({difficulty[i], profit[i]});\\n\\n        sort(v.begin(), v.end());\\n        for(int i = 1; i < n; i++)\\n            v[i].second = max(v[i].second, v[i - 1].second);\\n\\n        for(auto &i : worker)\\n            ans += helper(i, v);\\n\\n        return ans;\\n    }\\n\\n    int helper(int x, vector<pair<int, int>> &v)\\n    {\\n        int i = 0, j = v.size() - 1;\\n        int ans = -1;\\n        while(i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n\\n            if(v[mid].first <= x)\\n                ans = mid, i = mid + 1;\\n            else\\n                j = mid - 1;\\n        }\\n\\n        return ans == -1 ? 0 : v[ans].second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = profit.size(), ans = 0;\\n        vector<pair<int, int>> v;\\n\\n        for(int i = 0; i < n; i++)\\n            v.push_back({difficulty[i], profit[i]});\\n\\n        sort(v.begin(), v.end());\\n        for(int i = 1; i < n; i++)\\n            v[i].second = max(v[i].second, v[i - 1].second);\\n\\n        for(auto &i : worker)\\n            ans += helper(i, v);\\n\\n        return ans;\\n    }\\n\\n    int helper(int x, vector<pair<int, int>> &v)\\n    {\\n        int i = 0, j = v.size() - 1;\\n        int ans = -1;\\n        while(i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n\\n            if(v[mid].first <= x)\\n                ans = mid, i = mid + 1;\\n            else\\n                j = mid - 1;\\n        }\\n\\n        return ans == -1 ? 0 : v[ans].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811314,
                "title": "easy-c-linear-tc",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797057,
                "title": "using-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        int def;\\n        int pro;\\n        Pair(int def, int pro)\\n        {\\n           this.def = def;\\n           this.pro = pro;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n          int len = difficulty.length;\\n          Pair arr[] = new Pair[len];\\n          for(int i = 0;i<len;i++)\\n          {\\n              arr[i] = new Pair(difficulty[i], profit[i]);\\n          }\\n\\n          Arrays.sort(arr, (a, b)-> a.def-b.def);\\n          Arrays.sort(worker);\\n          int curMax = 0;\\n          int totalMax = 0;\\n          int index = 0;\\n          for(int i = 0;i<worker.length;i++)\\n          {\\n              int wk = worker[i];\\n              while(index < len && arr[index].def <= wk)\\n              {\\n                  curMax = Math.max(curMax, arr[index].pro);\\n                  index++;\\n              }\\n              totalMax += curMax;\\n          }\\n\\n          return totalMax;\\n\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int def;\\n        int pro;\\n        Pair(int def, int pro)\\n        {\\n           this.def = def;\\n           this.pro = pro;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n          int len = difficulty.length;\\n          Pair arr[] = new Pair[len];\\n          for(int i = 0;i<len;i++)\\n          {\\n              arr[i] = new Pair(difficulty[i], profit[i]);\\n          }\\n\\n          Arrays.sort(arr, (a, b)-> a.def-b.def);\\n          Arrays.sort(worker);\\n          int curMax = 0;\\n          int totalMax = 0;\\n          int index = 0;\\n          for(int i = 0;i<worker.length;i++)\\n          {\\n              int wk = worker[i];\\n              while(index < len && arr[index].def <= wk)\\n              {\\n                  curMax = Math.max(curMax, arr[index].pro);\\n                  index++;\\n              }\\n              totalMax += curMax;\\n          }\\n\\n          return totalMax;\\n\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787328,
                "title": "make-pair-of-diff-profit-then-sort-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> diffPro;\\n        for(int i=0;i<difficulty.size();i++) diffPro.push_back({difficulty[i],profit[i]});\\n        sort(diffPro.begin(),diffPro.end());\\n        vector<int> MaxArr; int maxi = 0;\\n        for(int i=0;i<diffPro.size();i++){\\n            maxi = max(maxi,diffPro[i].second);\\n            MaxArr.push_back(maxi);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++){\\n            auto it = upper_bound(diffPro.begin(),diffPro.end(),make_pair(worker[i], numeric_limits<int>::max()));\\n            if(it==diffPro.end()){\\n                ans += MaxArr[MaxArr.size()-1];\\n                continue;\\n            }\\n            int idx = it - diffPro.begin();\\n            idx--;\\n            if(idx<0) continue;\\n            if(idx==0 && worker[i]<diffPro[idx].first){\\n                continue;\\n            }\\n            ans += MaxArr[idx];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> diffPro;\\n        for(int i=0;i<difficulty.size();i++) diffPro.push_back({difficulty[i],profit[i]});\\n        sort(diffPro.begin(),diffPro.end());\\n        vector<int> MaxArr; int maxi = 0;\\n        for(int i=0;i<diffPro.size();i++){\\n            maxi = max(maxi,diffPro[i].second);\\n            MaxArr.push_back(maxi);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++){\\n            auto it = upper_bound(diffPro.begin(),diffPro.end(),make_pair(worker[i], numeric_limits<int>::max()));\\n            if(it==diffPro.end()){\\n                ans += MaxArr[MaxArr.size()-1];\\n                continue;\\n            }\\n            int idx = it - diffPro.begin();\\n            idx--;\\n            if(idx<0) continue;\\n            if(idx==0 && worker[i]<diffPro[idx].first){\\n                continue;\\n            }\\n            ans += MaxArr[idx];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785630,
                "title": "easy-sol-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>items;int n=profit.size();\\n        for(int i=0;i<n;i++)items.push_back({difficulty[i],profit[i]});\\n        sort(items.begin(),items.end());\\n        for(int i=0;i<n;i++)difficulty[i]=items[i].first;\\n        profit[0]=items[0].second;\\n        for(int i=1;i<n;i++)profit[i]=max(profit[i-1],items[i].second);\\n        int ans=0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int ind=upper_bound(difficulty.begin(),difficulty.end(),worker[i])-difficulty.begin();\\n            if(ind==0)ans+=0;\\n            else\\n            {\\n                ans+=profit[ind-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>items;int n=profit.size();\\n        for(int i=0;i<n;i++)items.push_back({difficulty[i],profit[i]});\\n        sort(items.begin(),items.end());\\n        for(int i=0;i<n;i++)difficulty[i]=items[i].first;\\n        profit[0]=items[0].second;\\n        for(int i=1;i<n;i++)profit[i]=max(profit[i-1],items[i].second);\\n        int ans=0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int ind=upper_bound(difficulty.begin(),difficulty.end(),worker[i])-difficulty.begin();\\n            if(ind==0)ans+=0;\\n            else\\n            {\\n                ans+=profit[ind-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785537,
                "title": "simple-java-self-explaining-two-pointers-without-using-map",
                "content": "\\n\\n# Approach\\n1. Sort jobs with reverse profit \\n2. Sort worker with ability\\n3. Maximze profit by assign all capable worker to high profit job, iterating from high -> low\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\n        int[][] jobs = new int[profit.length][2]; \\n        for (int i = 0; i < profit.length; i++) {\\n            jobs[i][0] = difficulty[i];\\n            jobs[i][1] = profit[i]; \\n        }\\n        Arrays.sort(jobs, (a, b) -> b[1] - a[1]); \\n        Arrays.sort(worker); \\n\\n        int a = 0; \\n        int b = worker.length - 1; \\n        int max = 0; \\n\\n        for (int i = 0; i < jobs.length; i++) {\\n            int diff = jobs[i][0]; \\n            \\n            while ( b >= 0 && worker[b] >= diff) {\\n                max += jobs[i][1]; \\n                b--; \\n            }\\n        }\\n\\n        return max; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\n        int[][] jobs = new int[profit.length][2]; \\n        for (int i = 0; i < profit.length; i++) {\\n            jobs[i][0] = difficulty[i];\\n            jobs[i][1] = profit[i]; \\n        }\\n        Arrays.sort(jobs, (a, b) -> b[1] - a[1]); \\n        Arrays.sort(worker); \\n\\n        int a = 0; \\n        int b = worker.length - 1; \\n        int max = 0; \\n\\n        for (int i = 0; i < jobs.length; i++) {\\n            int diff = jobs[i][0]; \\n            \\n            while ( b >= 0 && worker[b] >= diff) {\\n                max += jobs[i][1]; \\n                b--; \\n            }\\n        }\\n\\n        return max; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780633,
                "title": "a-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] d, int[] p, int[] w) {\\n        var dict = new Dictionary<int, int>();\\n        for (int i = 0; i < d.Length; i++)\\n        {\\n            if (dict.ContainsKey(d[i]))\\n                dict[d[i]] = Math.Max(p[i], dict[d[i]]);\\n            else dict[d[i]] = p[i];\\n        }\\n        dict = dict.OrderByDescending(x => x.Value).ToDictionary(x => x.Key, x => x.Value);\\n        int res = 0;\\n        foreach(var worker in w)\\n        {\\n            foreach(var item in dict)\\n            {\\n                if (worker >= item.Key) \\n                {\\n                    res += item.Value; break;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] d, int[] p, int[] w) {\\n        var dict = new Dictionary<int, int>();\\n        for (int i = 0; i < d.Length; i++)\\n        {\\n            if (dict.ContainsKey(d[i]))\\n                dict[d[i]] = Math.Max(p[i], dict[d[i]]);\\n            else dict[d[i]] = p[i];\\n        }\\n        dict = dict.OrderByDescending(x => x.Value).ToDictionary(x => x.Key, x => x.Value);\\n        int res = 0;\\n        foreach(var worker in w)\\n        {\\n            foreach(var item in dict)\\n            {\\n                if (worker >= item.Key) \\n                {\\n                    res += item.Value; break;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1717060,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1947375,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 2018415,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1805295,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1786439,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 2071436,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 2054711,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1851627,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1829082,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            }
        ]
    }
]