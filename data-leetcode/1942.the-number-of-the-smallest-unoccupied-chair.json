[
    {
        "title": "Merge BSTs to Create Single BST",
        "question_content": "You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value. In one operation, you can:\n\n\tSelect two distinct indices i and j such that the value stored at one of the leaves of trees[i] is equal to the root value of trees[j].\n\tReplace the leaf node in trees[i] with trees[j].\n\tRemove trees[j] from trees.\n\nReturn the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST.\nA BST (binary search tree) is a binary tree where each node satisfies the following property:\n\n\tEvery node in the node's left subtree has a value&nbsp;strictly less&nbsp;than the node's value.\n\tEvery node in the node's right subtree has a value&nbsp;strictly greater&nbsp;than the node's value.\n\nA leaf is a node that has no children.\n&nbsp;\nExample 1:\n\nInput: trees = [[2,1],[3,2,5],[5,4]]\nOutput: [3,2,5,1,null,4]\nExplanation:\nIn the first operation, pick i=1 and j=0, and merge trees[0] into trees[1].\nDelete trees[0], so trees = [[3,2,5,1],[5,4]].\nIn the second operation, pick i=0 and j=1, and merge trees[1] into trees[0].\nDelete trees[1], so trees = [[3,2,5,1,null,4]].\nThe resulting tree, shown above, is a valid BST, so return its root.\nExample 2:\n\nInput: trees = [[5,3,8],[3,2,6]]\nOutput: []\nExplanation:\nPick i=0 and j=1 and merge trees[1] into trees[0].\nDelete trees[1], so trees = [[5,3,8,2,6]].\nThe resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null.\n\nExample 3:\n\nInput: trees = [[5,4],[3]]\nOutput: []\nExplanation: It is impossible to perform any operations.\n\n&nbsp;\nConstraints:\n\n\tn == trees.length\n\t1 <= n <= 5 * 104\n\tThe number of nodes in each tree is in the range [1, 3].\n\tEach node in the input may have children but no grandchildren.\n\tNo two roots of trees have the same value.\n\tAll the trees in the input are valid BSTs.\n\t1 <= TreeNode.val <= 5 * 104.",
        "solutions": [
            {
                "id": 1330387,
                "title": "just-do-what-it-says",
                "content": "Not a hard problem - just long and a bit frustrating. I failed the hidden test case when we have only one tree...\\n\\n> Update: see an alternative below that combines trees in an arbitrary order.\\n\\n#### Approach 1: Build from root\\nThis solution identifies the topmost root, and then traverses from it, joining leaves with matching roots.\\n\\n1. Populate a hashmap {value: root} . All root values are guaranteed to be unique.\\n2. Count values among all trees.\\n3. Identify a root of the combined tree; it\\'s value must be counted only once.\\n4. Traverse from the root:\\n\\t- Check BST validity, like in [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/).\\n\\t- Join leaves with roots, matching leaf and root value using the map.\\n5. If the combined tree is valid, and it includes all roots - return the root of the combined tree.\\n\\n**C++**\\n```cpp\\nbool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }\\n    }\\n    return traverse(r->left, m, min_left, r->val) && traverse(r->right, m, r->val, max_right);\\n}    \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> m;\\n    unordered_map<int, int> cnt;\\n    for (auto &t : trees) {\\n        m[t->val] = t;\\n        ++cnt[t->val];\\n        ++cnt[t->left ? t->left->val : 0];\\n        ++cnt[t->right ? t->right->val : 0];\\n    }\\n    for (auto &t : trees)\\n        if (cnt[t->val] == 1)\\n            return traverse(t, m) && m.size() == 1 ? t : nullptr;\\n    return nullptr;\\n}\\n```\\n\\n#### Approach 2: Join all leaves\\nAs before, we map values to tree roots. Then, we collect *all* leaves that have a matching root.\\n\\nFinally, we combine leaves with matching roots, removing those roots from the map. In the end, one root (of the entire tree) should remain in the map.\\n\\nOne caveat here is that we need to make sure that the final tree includes all nodes. Because we combine trees in no specific order, we can have another disconnected tree with a loop.\\n\\n**C++**\\n```cpp\\nunordered_set<int> unique_vals;\\nunordered_map<int, TreeNode*> roots;\\nvector<TreeNode*> leaves;\\nvoid addLeaf(TreeNode* r) {\\n    if (r != nullptr) {\\n        unique_vals.insert(r->val);\\n        if (roots.count(r->val))\\n            leaves.push_back(r);    \\n    }\\n}    \\nint validNodes(TreeNode* r, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr || r->val <= min_left || r->val >= max_right) \\n        return 0;\\n    return 1 + validNodes(r->left, min_left, r->val) + validNodes(r->right, r->val, max_right);\\n} \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    for (auto &t : trees)\\n        roots[t->val] = t;\\n    for (auto &t : trees) {\\n        unique_vals.insert(t->val);\\n        addLeaf(t->left);\\n        addLeaf(t->right);\\n    }\\n    for (auto leaf : leaves) {\\n        auto it = roots.find(leaf->val);\\n        if (it == end(roots)) \\n            return nullptr;\\n        leaf->left = it->second->left;\\n        leaf->right = it->second->right;\\n        roots.erase(it);\\n    }\\n    return roots.size() == 1 && validNodes(begin(roots)->second) == unique_vals.size() ? begin(roots)->second : nullptr;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }\\n    }\\n    return traverse(r->left, m, min_left, r->val) && traverse(r->right, m, r->val, max_right);\\n}    \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> m;\\n    unordered_map<int, int> cnt;\\n    for (auto &t : trees) {\\n        m[t->val] = t;\\n        ++cnt[t->val];\\n        ++cnt[t->left ? t->left->val : 0];\\n        ++cnt[t->right ? t->right->val : 0];\\n    }\\n    for (auto &t : trees)\\n        if (cnt[t->val] == 1)\\n            return traverse(t, m) && m.size() == 1 ? t : nullptr;\\n    return nullptr;\\n}\\n```\n```cpp\\nunordered_set<int> unique_vals;\\nunordered_map<int, TreeNode*> roots;\\nvector<TreeNode*> leaves;\\nvoid addLeaf(TreeNode* r) {\\n    if (r != nullptr) {\\n        unique_vals.insert(r->val);\\n        if (roots.count(r->val))\\n            leaves.push_back(r);    \\n    }\\n}    \\nint validNodes(TreeNode* r, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr || r->val <= min_left || r->val >= max_right) \\n        return 0;\\n    return 1 + validNodes(r->left, min_left, r->val) + validNodes(r->right, r->val, max_right);\\n} \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    for (auto &t : trees)\\n        roots[t->val] = t;\\n    for (auto &t : trees) {\\n        unique_vals.insert(t->val);\\n        addLeaf(t->left);\\n        addLeaf(t->right);\\n    }\\n    for (auto leaf : leaves) {\\n        auto it = roots.find(leaf->val);\\n        if (it == end(roots)) \\n            return nullptr;\\n        leaf->left = it->second->left;\\n        leaf->right = it->second->right;\\n        roots.erase(it);\\n    }\\n    return roots.size() == 1 && validNodes(begin(roots)->second) == unique_vals.size() ? begin(roots)->second : nullptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330156,
                "title": "python-clean-in-order-traversal-solution-o-n-o-n",
                "content": "**Idea**\\n\\nWhen asked to validate BST, we naturally think about in-order traversal ([98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)). The question is how to do in-order traversal when we are given many separate trees.\\n\\nFirst of all, we want to find a root node to start the traversal from, and we can do so by finding the node without any incoming edge (`indeg = 0`). If there\\'s zero or more than one roots, we cannot create a single BST.\\n\\nTo traverse through nodes, we need to go from one BST to another. We achieve this with the help of a value-to-node map (`nodes`).\\n\\nThere are also two edges cases we need to check:\\n* There is no cycle\\n* We traverse through all nodes\\n\\nPlease see code below for more details =)\\n\\n</br>\\n\\n**Complexity**\\n\\n- Time complexity: `O(N)`\\n- Space complexity: `O(N)`\\n\\n</br>\\n\\n**Python**\\n\\n```Python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        nodes = {}\\n        indeg = collections.defaultdict(int)\\n        for t in trees:\\n            if t.val not in indeg:\\n                indeg[t.val] = 0\\n            if t.left:\\n                indeg[t.left.val] += 1\\n                if t.left.val not in nodes: nodes[t.left.val] = t.left\\n            if t.right:\\n                indeg[t.right.val] += 1\\n                if t.right.val not in nodes: nodes[t.right.val] = t.right\\n            nodes[t.val] = t\\n            \\n        # check single root\\n        sources = [k for k, v in indeg.items() if v == 0]\\n        if len(sources) != 1: return None\\n        \\n        self.cur = float(\\'-inf\\')\\n        self.is_invalid = False\\n        seen = set()\\n        def inorder(val):\\n            # check cycle\\n            if val in seen:\\n                self.is_invalid = True\\n                return\\n            seen.add(val)\\n            node = nodes[val]\\n            if node.left: node.left = inorder(node.left.val)\\n            # check inorder increasing\\n            if val <= self.cur:\\n                self.is_invalid = True\\n                return\\n            self.cur = val\\n            if node.right: node.right = inorder(node.right.val)\\n            return node\\n        \\n        root = inorder(sources[0])\\n        # check full traversal\\n        if len(seen) != len(nodes) or self.is_invalid:\\n            return None\\n        return root\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        nodes = {}\\n        indeg = collections.defaultdict(int)\\n        for t in trees:\\n            if t.val not in indeg:\\n                indeg[t.val] = 0\\n            if t.left:\\n                indeg[t.left.val] += 1\\n                if t.left.val not in nodes: nodes[t.left.val] = t.left\\n            if t.right:\\n                indeg[t.right.val] += 1\\n                if t.right.val not in nodes: nodes[t.right.val] = t.right\\n            nodes[t.val] = t\\n            \\n        # check single root\\n        sources = [k for k, v in indeg.items() if v == 0]\\n        if len(sources) != 1: return None\\n        \\n        self.cur = float(\\'-inf\\')\\n        self.is_invalid = False\\n        seen = set()\\n        def inorder(val):\\n            # check cycle\\n            if val in seen:\\n                self.is_invalid = True\\n                return\\n            seen.add(val)\\n            node = nodes[val]\\n            if node.left: node.left = inorder(node.left.val)\\n            # check inorder increasing\\n            if val <= self.cur:\\n                self.is_invalid = True\\n                return\\n            self.cur = val\\n            if node.right: node.right = inorder(node.right.val)\\n            return node\\n        \\n        root = inorder(sources[0])\\n        # check full traversal\\n        if len(seen) != len(nodes) or self.is_invalid:\\n            return None\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486253,
                "title": "java-easy-to-understand",
                "content": "```\\npublic TreeNode canMerge(List<TreeNode> trees) {\\n        //Collect the leaves\\n        Set<Integer> leaves = new HashSet();\\n         Map<Integer, TreeNode> map = new HashMap<>(); \\n        for(TreeNode tree : trees) {\\n             map.put(tree.val, tree);\\n            if(tree.left != null) {\\n                leaves.add(tree.left.val);\\n            }\\n            if(tree.right != null) {\\n                leaves.add(tree.right.val);\\n            }\\n        }\\n        \\n        //Decide the root of the resulting tree\\n        TreeNode result = null;\\n        for(TreeNode tree : trees) {\\n            if(!leaves.contains(tree.val) ) {\\n                result = tree;\\n                break;\\n            }\\n        }\\n        if(result == null) {\\n            return null;\\n        }\\n        \\n        return traverse(result, map, Integer.MIN_VALUE, Integer.MAX_VALUE) && map.size() == 1 ? result : null;\\n    }\\n    \\n    private boolean traverse(TreeNode root, Map<Integer, TreeNode> map, int min, int max) {\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        \\n        if(root.left == null && root.right == null) {\\n            if(map.containsKey(root.val) && root != map.get(root.val)) {\\n                TreeNode next = map.get(root.val);\\n                root.left = next.left;\\n                root.right = next.right;\\n                map.remove(root.val);\\n            }\\n        }\\n        return traverse(root.left, map, min, root.val) && traverse(root.right, map, root.val, max);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic TreeNode canMerge(List<TreeNode> trees) {\\n        //Collect the leaves\\n        Set<Integer> leaves = new HashSet();\\n         Map<Integer, TreeNode> map = new HashMap<>(); \\n        for(TreeNode tree : trees) {\\n             map.put(tree.val, tree);\\n            if(tree.left != null) {\\n                leaves.add(tree.left.val);\\n            }\\n            if(tree.right != null) {\\n                leaves.add(tree.right.val);\\n            }\\n        }\\n        \\n        //Decide the root of the resulting tree\\n        TreeNode result = null;\\n        for(TreeNode tree : trees) {\\n            if(!leaves.contains(tree.val) ) {\\n                result = tree;\\n                break;\\n            }\\n        }\\n        if(result == null) {\\n            return null;\\n        }\\n        \\n        return traverse(result, map, Integer.MIN_VALUE, Integer.MAX_VALUE) && map.size() == 1 ? result : null;\\n    }\\n    \\n    private boolean traverse(TreeNode root, Map<Integer, TreeNode> map, int min, int max) {\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        \\n        if(root.left == null && root.right == null) {\\n            if(map.containsKey(root.val) && root != map.get(root.val)) {\\n                TreeNode next = map.get(root.val);\\n                root.left = next.left;\\n                root.right = next.right;\\n                map.remove(root.val);\\n            }\\n        }\\n        return traverse(root.left, map, min, root.val) && traverse(root.right, map, root.val, max);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330145,
                "title": "python3-bfs-with-comments",
                "content": "```\\n# problem is pretty straightforward (as for hard one), but with different edge cases\\n#\\n# algo:\\n#   1. find the result tree root:\\n#       1.1. root should have a value that\\'s not in leaf of any subtree\\n#       1.2. there should be exactly one root\\n#   2. map all input subtrees to their root values, so we can find a subtree by value in constant time\\n#   3. run bfs (or dfs) from the result tree root (we found on step 1):\\n#       3.1. to build the result tree\\n#       3.2. with keeping left and right bounds, so we can check every node if it fits the BST\\n#       3.3. also with deleting all subtrees that have been used\\n#   4. return result tree if all subtrees have been used and all nodes fits the BST\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        leaf_values = set()\\n        root_by_value = {}\\n        \\n        for node in trees:                       # collect leaf values and fill \"root_by_value\" dict\\n            if node.left:\\n                leaf_values.add(node.left.val)\\n            if node.right:\\n                leaf_values.add(node.right.val)\\n            root_by_value[node.val] = node\\n            \\n        root = None\\n        for node in trees:\\n            if node.val not in leaf_values:\\n                if root is None:\\n                    root = node\\n                else:                           # we found more than one root, so return None\\n                    return None\\n\\n        if root is None:                        # the result tree root is not found, so return None\\n            return None\\n        \\n        del root_by_value[root.val]                     # the tree is used so delete \\n        queue = deque([(root, -math.inf, math.inf)])    # (current_node, left_bound, right_bound)\\n        while queue:                                    # standard iterative BFS with using queue\\n            node, left, right = queue.popleft()\\n            if not (left < node.val < right):           # check if node fits BST\\n                return None\\n\\n            if node.left:\\n                if node.left.val in root_by_value:               # if leaf value is root of some subtree\\n                    node.left = root_by_value[node.left.val]     # reassign leaf\\n                    del root_by_value[node.left.val]             # and delete subtree as used\\n                queue.append((node.left, left, node.val))        # add leaf to BFS\\n\\n            if node.right:\\n                if node.right.val in root_by_value:\\n                    node.right = root_by_value[node.right.val]\\n                    del root_by_value[node.right.val]\\n                queue.append((node.right, node.val, right))\\n\\n        return root if not root_by_value else None      # if no subtrees left, return the result tree\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n# problem is pretty straightforward (as for hard one), but with different edge cases\\n#\\n# algo:\\n#   1. find the result tree root:\\n#       1.1. root should have a value that\\'s not in leaf of any subtree\\n#       1.2. there should be exactly one root\\n#   2. map all input subtrees to their root values, so we can find a subtree by value in constant time\\n#   3. run bfs (or dfs) from the result tree root (we found on step 1):\\n#       3.1. to build the result tree\\n#       3.2. with keeping left and right bounds, so we can check every node if it fits the BST\\n#       3.3. also with deleting all subtrees that have been used\\n#   4. return result tree if all subtrees have been used and all nodes fits the BST\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        leaf_values = set()\\n        root_by_value = {}\\n        \\n        for node in trees:                       # collect leaf values and fill \"root_by_value\" dict\\n            if node.left:\\n                leaf_values.add(node.left.val)\\n            if node.right:\\n                leaf_values.add(node.right.val)\\n            root_by_value[node.val] = node\\n            \\n        root = None\\n        for node in trees:\\n            if node.val not in leaf_values:\\n                if root is None:\\n                    root = node\\n                else:                           # we found more than one root, so return None\\n                    return None\\n\\n        if root is None:                        # the result tree root is not found, so return None\\n            return None\\n        \\n        del root_by_value[root.val]                     # the tree is used so delete \\n        queue = deque([(root, -math.inf, math.inf)])    # (current_node, left_bound, right_bound)\\n        while queue:                                    # standard iterative BFS with using queue\\n            node, left, right = queue.popleft()\\n            if not (left < node.val < right):           # check if node fits BST\\n                return None\\n\\n            if node.left:\\n                if node.left.val in root_by_value:               # if leaf value is root of some subtree\\n                    node.left = root_by_value[node.left.val]     # reassign leaf\\n                    del root_by_value[node.left.val]             # and delete subtree as used\\n                queue.append((node.left, left, node.val))        # add leaf to BFS\\n\\n            if node.right:\\n                if node.right.val in root_by_value:\\n                    node.right = root_by_value[node.right.val]\\n                    del root_by_value[node.right.val]\\n                queue.append((node.right, node.val, right))\\n\\n        return root if not root_by_value else None      # if no subtrees left, return the result tree\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407162,
                "title": "c-simple-and-clean-solution-with-easy-detailed-explanation",
                "content": "**Explanation:**\\n1. First, for easy search and access, we map all our roots in an unordered_map roots: [value->root].\\n    We also put all leafs in a set `leaves` to be able to find our new root.\\n2. The result root will be the one which is not found in any trees leaves, because otherwise in the resulting tree there will be two nodes with the same value, and that\\'s impossible as we need each node to be strictly greater/less than parent.\\nSo `getRoot` function checks which root doesn\\'t appear in the leaves set.\\nThen we can remove the new root from the roots map.\\n3. Now, all we have to do is recursively find leaves that are in the roots node and merge trees.\\n\\tWe create a `tmp` node to keep the current node.\\n\\tIf we found a node that appears in the roots map, tmp = roots[root->val]. Otherwise, it stays `root`.\\n\\tWe can remove it from roots map and recursively do the same for left node and right node.\\n4. Last, is to check that our result is a valid BST and we used all trees given.\\n```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom) {\\n        if (!root) return true;\\n        if (root->val >= top || root->val <= bottom) return false; \\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n\\n    TreeNode* getTree(TreeNode* root) {\\n        if (!root) return NULL;\\n        TreeNode* tmp =  roots.count(root->val) ? roots[root->val]: root;\\n        roots.erase(root->val);\\n        root->left = getTree(tmp->left);\\n        root->right = getTree(tmp->right);\\n        return tmp;\\n    }\\n    \\n    TreeNode* getRoot(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            if (!leaves.count(root->val)) return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            roots[root->val] = root;\\n            if (root->left) leaves.insert(root->left->val);\\n            if (root->right) leaves.insert(root->right->val);\\n        }\\n        \\n        TreeNode* new_root = getRoot(trees);\\n        if (!new_root) return NULL;\\n        roots.erase(new_root->val);\\n        \\n        getTree(new_root);\\n        \\n        return isBST(new_root, 2147483648, -2147483649) && !roots.size() ? new_root : NULL;\\n            \\n    }\\n    \\nprivate:\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_set<int> leaves;\\n};\\n```\\n**like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom) {\\n        if (!root) return true;\\n        if (root->val >= top || root->val <= bottom) return false; \\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n\\n    TreeNode* getTree(TreeNode* root) {\\n        if (!root) return NULL;\\n        TreeNode* tmp =  roots.count(root->val) ? roots[root->val]: root;\\n        roots.erase(root->val);\\n        root->left = getTree(tmp->left);\\n        root->right = getTree(tmp->right);\\n        return tmp;\\n    }\\n    \\n    TreeNode* getRoot(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            if (!leaves.count(root->val)) return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            roots[root->val] = root;\\n            if (root->left) leaves.insert(root->left->val);\\n            if (root->right) leaves.insert(root->right->val);\\n        }\\n        \\n        TreeNode* new_root = getRoot(trees);\\n        if (!new_root) return NULL;\\n        roots.erase(new_root->val);\\n        \\n        getTree(new_root);\\n        \\n        return isBST(new_root, 2147483648, -2147483649) && !roots.size() ? new_root : NULL;\\n            \\n    }\\n    \\nprivate:\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_set<int> leaves;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330182,
                "title": "c-using-hash-maps-commented-explained",
                "content": "* Store the leaf nodes of all  the trees in a map with its parent Node address\\n* when we find current tree node value in the map we need to merge\\n* if we dont find the current node value in map then it is the node  which we should return \\n* when we merge a current tree x to another tree y then we check - \\n* if x is left child of y and maximum node value in the x is >=  y root node value then return NULL , else merge them and change the y minimum node value to x minimum node value\\n* if x is right child of y and the minimum node value in x is <= y root node value then return NULL, else merge them and change the y maximum node value to x  maximum value\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344318,
                "title": "c-90-faster-using-hashmap-explained",
                "content": "1. The root of merged tree will be that root node whose value is not equal to leaf node of any other tree and it has to be unique.\\n2. Build the tree by combining the leafs with matching roots.\\n3. Check if the all the BSTs are combined.\\n4. Check if tree formed is a valid BST.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330172,
                "title": "java-two-hashmaps",
                "content": "1. Use Map to store root value to root node\\n2. Use set to mark the deleted trees\\n3. Traverse the list of roots and check if left and right nodes can be replaced\\n4. Check if the new root forms valid BST\\n\\n**Special case**: root1 set root2 as child and root2 trying to set root1 as child\\nUse a map to maintain the new parent of tree when it is modified and check if we are trying to set the parent as child when traversing the trees\\n```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> set = new HashSet<>();\\n        Map<TreeNode, TreeNode> parent = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            map.put(root.val, root);\\n\\n        for (TreeNode root : trees) {\\n        \\t/* If left node is present as root somewhere in list, replace the left node with root */\\n            if (root.left != null && map.containsKey(root.left.val) && !set.contains(map.get(root.left.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != map.get(root.left.val)) {\\n                    root.left = map.get(root.left.val);\\n                    parent.put(map.get(root.left.val), root);\\n                    set.add(map.get(root.left.val));\\n                }\\n            }\\n            \\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (root.right != null && map.containsKey(root.right.val) && !set.contains(map.get(root.right.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                if (node != map.get(root.right.val)) {\\n                    root.right = map.get(root.right.val);\\n                    parent.put(map.get(root.right.val), root);\\n                    set.add(map.get(root.right.val));\\n                }\\n            }\\n        }\\n        \\n        /* There should be only one root */\\n        if (set.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!set.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n        \\n        return null;\\n    }\\n    \\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n        \\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> set = new HashSet<>();\\n        Map<TreeNode, TreeNode> parent = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            map.put(root.val, root);\\n\\n        for (TreeNode root : trees) {\\n        \\t/* If left node is present as root somewhere in list, replace the left node with root */\\n            if (root.left != null && map.containsKey(root.left.val) && !set.contains(map.get(root.left.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != map.get(root.left.val)) {\\n                    root.left = map.get(root.left.val);\\n                    parent.put(map.get(root.left.val), root);\\n                    set.add(map.get(root.left.val));\\n                }\\n            }\\n            \\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (root.right != null && map.containsKey(root.right.val) && !set.contains(map.get(root.right.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                if (node != map.get(root.right.val)) {\\n                    root.right = map.get(root.right.val);\\n                    parent.put(map.get(root.right.val), root);\\n                    set.add(map.get(root.right.val));\\n                }\\n            }\\n        }\\n        \\n        /* There should be only one root */\\n        if (set.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!set.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n        \\n        return null;\\n    }\\n    \\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n        \\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086103,
                "title": "just-find-the-root-simple-bfs-solution",
                "content": "![image](https://assets.leetcode.com/users/images/eda8df4e-9fc2-4522-927b-d4a3875085d4_1674391548.905983.png)\\n\\nJust You have to Find the root!\\nRoot cannot be the child of any node so simply by hashing and hashset you can find it.\\n\\n-> If more than two root occurs or no root occurs than simply return {} empty list \\n\\nElse start building the solution from top and keep strech it to the bottom ans at last just check if the final tree is BST or not (Validating a BST)\\n\\n\\nCode:\\n\\nclass Solution {\\npublic:\\n     bool check(TreeNode* root,int lb,int ub){\\n        if(root==NULL)return true;\\n        if(root->val<=lb||root->val>=ub)return false;\\n        \\n        bool left=check(root->left,lb,root->val);\\n        bool right=check(root->right,root->val,ub);\\n        return left&right;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n     unordered_set<int>st;\\n        unordered_map<int,TreeNode*>hash;\\n        unordered_set<TreeNode*>temp;\\n        for(auto it:trees){\\n            hash[it->val]=it;\\n            temp.insert(it);\\n            if(it->left)st.insert(it->left->val);\\n             if(it->right)st.insert(it->right->val);\\n        }\\n        TreeNode* root=NULL;\\n        int cnt=0;\\n        for(auto it:trees){\\n           if(st.find(it->val)==st.end()){\\n               cnt++;\\n               root=it;\\n               if(cnt>1)return {};\\n           } \\n        }\\n        temp.erase(root);\\n        queue<TreeNode*>que;\\n        if(root==NULL)return {};\\n        que.push(root);\\n        while(que.size()){\\n            int size=que.size();\\n            while(size--){\\n                TreeNode* node=que.front();\\n                que.pop();\\n                if(node->left==NULL&&node->right==NULL){\\n                   \\n                    if(temp.find(hash[node->val])!=temp.end()){\\n                        node->left=hash[node->val]->left;\\n                        node->right=hash[node->val]->right;\\n                        temp.erase(hash[node->val]);\\n                    }\\n                }\\n                if(node->left)que.push(node->left);\\n                if(node->right)que.push(node->right);\\n            }\\n        }\\n        if(temp.size())return {};\\n          if(check(root,INT_MIN,INT_MAX))return root;\\n          return {};\\n    }\\n};\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n     bool check(TreeNode* root,int lb,int ub){\\n        if(root==NULL)return true;\\n        if(root->val<=lb||root->val>=ub)return false;\\n        \\n        bool left=check(root->left,lb,root->val);\\n        bool right=check(root->right,root->val,ub);\\n        return left&right;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1989069,
                "title": "c-easy-and-simple-solution-merge-bsts-to-create-single-bst",
                "content": "**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F**\\n```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358113,
                "title": "c-most-intuitive",
                "content": "The most important thing to understand is the fact that the final root node will be the one which is not found in any trees leaves. After figuring this out, we just need to recursively merge the dependecies, and finally check if everything has been merged and if the resuting tree is a BST or not. \\n\\n```\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootMap; \\n    \\n    bool findBST(TreeNode* root, long left, long right){\\n        if(root == NULL) return true; \\n        int res = root->val > left && root->val < right; \\n        res = res && findBST(root->left, left, root->val)  && findBST(root->right, root->val, right); \\n        return res;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return findBST(root, LONG_MIN, LONG_MAX);     \\n    }\\n    \\n    TreeNode* mergeAll(TreeNode* root){ \\n        TreeNode* res =  rootMap.count(root->val)? rootMap[root->val]: root; \\n        rootMap.erase(root->val); \\n        if(res->left) root->left = mergeAll(res->left); \\n        if(res->right) root->right = mergeAll(res->right);\\n        return res; \\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_set<int> st ;\\n        for(auto x:trees){\\n            rootMap[x->val] = x;\\n            if(x->left) st.insert(x->left->val);\\n            if(x->right) st.insert(x->right->val);\\n        }\\n        TreeNode* root; \\n        for(auto x:trees){\\n            if(!st.count(x->val)){\\n                root = x;\\n                break ; \\n            }\\n        }\\n        mergeAll(root); \\n        return isValidBST(root) && (rootMap.size() == 0)? root: NULL; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootMap; \\n    \\n    bool findBST(TreeNode* root, long left, long right){\\n        if(root == NULL) return true; \\n        int res = root->val > left && root->val < right; \\n        res = res && findBST(root->left, left, root->val)  && findBST(root->right, root->val, right); \\n        return res;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return findBST(root, LONG_MIN, LONG_MAX);     \\n    }\\n    \\n    TreeNode* mergeAll(TreeNode* root){ \\n        TreeNode* res =  rootMap.count(root->val)? rootMap[root->val]: root; \\n        rootMap.erase(root->val); \\n        if(res->left) root->left = mergeAll(res->left); \\n        if(res->right) root->right = mergeAll(res->right);\\n        return res; \\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_set<int> st ;\\n        for(auto x:trees){\\n            rootMap[x->val] = x;\\n            if(x->left) st.insert(x->left->val);\\n            if(x->right) st.insert(x->right->val);\\n        }\\n        TreeNode* root; \\n        for(auto x:trees){\\n            if(!st.count(x->val)){\\n                root = x;\\n                break ; \\n            }\\n        }\\n        mergeAll(root); \\n        return isValidBST(root) && (rootMap.size() == 0)? root: NULL; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537226,
                "title": "just-do-what-is-says-explained-the-approach-in-detail-time-complexity-o-n",
                "content": "# Approach : \\nTime complexity : $$O(n)$$\\n\\nSo, first I have inserted all the leaf nodes to parent <key,value> pairs are stored. \\n\\n![image.png](https://assets.leetcode.com/users/images/8e5bc7c9-bfa8-4373-bffb-f8ea7caeec58_1684390579.3647506.png)\\n\\nThe the unordered map is stored to get the root of the tree having leaf value same as root2->val\\nHere in the image, 2 is root2 (tree[0]) and then I will find the root of the tree having a leaf node value as 2. So using unordered_map it becomes easy to find. So while searching I get the TreeNode* 3 (i.e. the root of leaf node value == 2)\\n\\n### Joining Part   : \\n\\nSo to join a bst 1 to another bst 2, i will check if I\\'m adding the bst1 to left of bst2, then I have to check if the right of bst1 if smaller than root value, if it is smaller then add the bst1 to bst2 or else return NULL.\\n\\n##### So in the Above example : \\nTaking (tree[0] and tree[1]) into consideration, tree[0] will be added to left of tree[1]. So I check if the right value of right of 2 is smaller than 3 (ie the root of tree[1]), here it does not exist so then add the tree[0] to tree[1].\\n\\n##### Below example : \\nTaking (tree[0] and tree[1]) into consideration, tree[1] will be added to left of tree[0].\\nSo I check if the right value of right of 3 (tree[1]) is smaller than 5 (ie the root of tree[1]), here the value if 6>5, so return NULL\\n\\n![image.png](https://assets.leetcode.com/users/images/199f02d4-47d5-4197-8bc1-65a03c88ce56_1684390990.772047.png)\\n\\n\\n###### Similarly, do the checks while adding the bst to right, check if the value of bst1\\'s left is greater than the root of bst2.\\n\\nAnd then finally after connecting the trees, check if there is only 1 single connected tree or not. If there is only one connected tree, then just check if it is a valid bst.\\n\\n# Code\\n```\\n// Here mp is the unordered_map where the leaf to parent is stored\\n\\n\\nclass Solution {\\npublic:\\n    bool isBSTHelper(TreeNode* root, long minVal, long maxVal) {\\n        if (root == NULL) return true;\\n        if(root->val <= minVal || root->val >= maxVal) return false;\\n        return isBSTHelper(root->left, minVal, root->val) && isBSTHelper(root->right, root->val, maxVal);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> mp;\\n//  trees -> parent\\n        unordered_map<TreeNode*,TreeNode*> par;\\n        // inserting values in parent\\n        for(auto t : trees){\\n            par[t] = t;\\n        }\\n        \\n        // inserting the values in mp\\n        for(int i =0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(tmp->left){ \\n                if(mp.find(tmp->left->val) == mp.end())\\n                    mp[tmp->left->val] = tmp;\\n                else return NULL;\\n            }\\n            if(tmp->right){ \\n                if(mp.find(tmp->right->val) == mp.end())\\n                    mp[tmp->right->val] = tmp;\\n                else return NULL;\\n            }\\n        }\\n        for(int i = 0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(mp.find(tmp->val) != mp.end()){\\n                TreeNode* root = mp[tmp->val];\\n                if(root->right && root->right->val == tmp->val){\\n                    int check = INT_MAX;\\n                    if(tmp->left){\\n                        check = tmp->left->val;\\n                    }\\n                    if(check > root->val){\\n                        root->right = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n                else if(root->left && root->left->val == tmp->val){\\n                    int check = 0;\\n                    if(tmp->right){\\n                        check = tmp->right->val;\\n                    }\\n                    if(check< root->val){\\n                        root->left = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n            }\\n        }\\n        vector<TreeNode*> ans;\\n        for(auto t : par){\\n            if(t.first == t.second){\\n                ans.push_back(t.first);\\n            }\\n        }\\n        if(ans.size() == 1){ \\n            if(isBSTHelper(ans[0],LONG_MIN, LONG_MAX))\\n                return ans[0];\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n###### Please upvote \\uD83E\\uDD79 !",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Here mp is the unordered_map where the leaf to parent is stored\\n\\n\\nclass Solution {\\npublic:\\n    bool isBSTHelper(TreeNode* root, long minVal, long maxVal) {\\n        if (root == NULL) return true;\\n        if(root->val <= minVal || root->val >= maxVal) return false;\\n        return isBSTHelper(root->left, minVal, root->val) && isBSTHelper(root->right, root->val, maxVal);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> mp;\\n//  trees -> parent\\n        unordered_map<TreeNode*,TreeNode*> par;\\n        // inserting values in parent\\n        for(auto t : trees){\\n            par[t] = t;\\n        }\\n        \\n        // inserting the values in mp\\n        for(int i =0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(tmp->left){ \\n                if(mp.find(tmp->left->val) == mp.end())\\n                    mp[tmp->left->val] = tmp;\\n                else return NULL;\\n            }\\n            if(tmp->right){ \\n                if(mp.find(tmp->right->val) == mp.end())\\n                    mp[tmp->right->val] = tmp;\\n                else return NULL;\\n            }\\n        }\\n        for(int i = 0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(mp.find(tmp->val) != mp.end()){\\n                TreeNode* root = mp[tmp->val];\\n                if(root->right && root->right->val == tmp->val){\\n                    int check = INT_MAX;\\n                    if(tmp->left){\\n                        check = tmp->left->val;\\n                    }\\n                    if(check > root->val){\\n                        root->right = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n                else if(root->left && root->left->val == tmp->val){\\n                    int check = 0;\\n                    if(tmp->right){\\n                        check = tmp->right->val;\\n                    }\\n                    if(check< root->val){\\n                        root->left = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n            }\\n        }\\n        vector<TreeNode*> ans;\\n        for(auto t : par){\\n            if(t.first == t.second){\\n                ans.push_back(t.first);\\n            }\\n        }\\n        if(ans.size() == 1){ \\n            if(isBSTHelper(ans[0],LONG_MIN, LONG_MAX))\\n                return ans[0];\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367650,
                "title": "split-problem-into-multiple-subproblems-and-solution-is-ready",
                "content": "This problem can be broken down into 4 subproblems - \\n1. How to find leave nodes & root nodes in constant time out of n BST\\n2. How to find a BST whoes root node is not a leaf node in any one of the BSTs\\n3. Given a BST (found in step 2), try to merge rest of BSTs to its left and right child\\n4. Find if given tree is BST or not. \\n\\nLets start 1 by 1 - \\n1. How to traverse leave nodes & root nodes in constant time out of n BST - \\n\\t* Why we need constant time search - \\n\\t\\t* For each BST\\'s root node we wanted to verify if root node is part of any BST\\'s leaf node or not. \\n\\t\\t* to find a BST whoes root node is not a leaf node in any one of the BSTs\\n\\t* We can leverage Map here keep track of both type queries\\n\\n2. How to find a BST whoes root node is not a leaf node in any one of the BSTs -\\n\\t* We can use above Map to perform this query. For each root node in List we can query in **leaves** Map if no leaves exists then it can become my combined BST root. \\n\\n3. Given a BST (found in step 2), try to merge rest of BSTs to its left and right child -\\n\\t* if left child(by value we will compare) is present in **roots** map then replace left child with this node from **roots** map\\n\\t* if right child (by value we will compare) is present in **roots** map then replace right child with this node from **roots** map.\\n\\t* recurse above 2 steps for each left & right child\\n\\t\\n4. Find if given tree is BST or not. \\n\\t* Multiple ways to do it. Either in-order traversal or comparing left & right with min/max. You can surely find answer for this on internet.\\n\\nBelow code snippet can be improved further but is just to give an idea how we can implement all 4 subproblems and stich them togather.\\n\\n```\\nclass Solution {\\n    // Map to hold leaves\\n    // It will help to query if any given root not is part of leaves node in any of the BST\\n    Map<Integer, List<TreeNode> > leaves = new HashMap<>();\\n    \\n    // Map to hold roots\\n    // It will help to query - give me any root node which matches given node \\n    // Mostly used for querying for left node matches with any root and right node matches any root\\n    Map<Integer, TreeNode> roots = new HashMap<>();\\n\\n    //Function to check if it can be merged or not\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n    \\n        // To queries nodes mulitple times in constant operation we will put them into Map\\n         for(TreeNode node: trees){\\n             // append to root map\\n            roots.put(node.val, node);\\n             \\n             // append to leaves map\\n            if(node.left != null){\\n                List<TreeNode> nodes = leaves.get(node.left.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.left.val, nodes);\\n            }\\n            if(node.right != null){\\n                List<TreeNode> nodes = leaves.get(node.right.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.right.val, nodes);\\n            }     \\n        }\\n\\n        // find a node which will become root of bst\\n        TreeNode bstRoot = null;\\n        for(TreeNode n: trees){\\n            if(!leaves.containsKey(n.val)){\\n                bstRoot = n;\\n                break;\\n            }\\n        }\\n        \\n        // if no unique root found we cannot merge it\\n        if(bstRoot == null)\\n            return null;\\n        \\n        // invoke merge operation\\n        merge(bstRoot);\\n        \\n        // at the end we will check only 1 tree should be remaining and it should be BST\\n        if (roots.size() == 1 && isValidBST(bstRoot, Integer.MIN_VALUE, Integer.MAX_VALUE) )\\n            return bstRoot;\\n        \\n        return null;\\n            \\n    }\\n    \\n    void merge(TreeNode node){\\n        if(node == null)\\n            return;\\n        if(node.left != null){\\n            // Find any root node which matches with left leaf node and then append it to my BST\\n            if(roots.containsKey(node.left.val)){\\n                node.left = roots.get(node.left.val);\\n                roots.remove(node.left.val);\\n            }\\n        }\\n        if(node.right != null){\\n            // Find any root node which matches with right leaf node and then append it to my BST\\n            // this duplicate code can be reduced by extracting a function\\n            if(roots.containsKey(node.right.val)){     \\n                node.right = roots.get(node.right.val);\\n                roots.remove(node.right.val);\\n            }\\n        }\\n        \\n        merge(node.left);\\n        merge(node.right);\\n    }\\n    \\n    boolean isValidBST(TreeNode n, int min, int max){\\n        if(n.val < min || n.val > max)\\n            return false;\\n        \\n        boolean l =true, r= true;\\n        \\n        if(n.left != null)\\n             l = isValidBST(n.left, min, n.val);\\n        if(n.right != null)\\n             r = isValidBST(n.right, n.val, max);\\n        \\n        return n.val>min && n.val < max & l && r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Map to hold leaves\\n    // It will help to query if any given root not is part of leaves node in any of the BST\\n    Map<Integer, List<TreeNode> > leaves = new HashMap<>();\\n    \\n    // Map to hold roots\\n    // It will help to query - give me any root node which matches given node \\n    // Mostly used for querying for left node matches with any root and right node matches any root\\n    Map<Integer, TreeNode> roots = new HashMap<>();\\n\\n    //Function to check if it can be merged or not\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n    \\n        // To queries nodes mulitple times in constant operation we will put them into Map\\n         for(TreeNode node: trees){\\n             // append to root map\\n            roots.put(node.val, node);\\n             \\n             // append to leaves map\\n            if(node.left != null){\\n                List<TreeNode> nodes = leaves.get(node.left.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.left.val, nodes);\\n            }\\n            if(node.right != null){\\n                List<TreeNode> nodes = leaves.get(node.right.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.right.val, nodes);\\n            }     \\n        }\\n\\n        // find a node which will become root of bst\\n        TreeNode bstRoot = null;\\n        for(TreeNode n: trees){\\n            if(!leaves.containsKey(n.val)){\\n                bstRoot = n;\\n                break;\\n            }\\n        }\\n        \\n        // if no unique root found we cannot merge it\\n        if(bstRoot == null)\\n            return null;\\n        \\n        // invoke merge operation\\n        merge(bstRoot);\\n        \\n        // at the end we will check only 1 tree should be remaining and it should be BST\\n        if (roots.size() == 1 && isValidBST(bstRoot, Integer.MIN_VALUE, Integer.MAX_VALUE) )\\n            return bstRoot;\\n        \\n        return null;\\n            \\n    }\\n    \\n    void merge(TreeNode node){\\n        if(node == null)\\n            return;\\n        if(node.left != null){\\n            // Find any root node which matches with left leaf node and then append it to my BST\\n            if(roots.containsKey(node.left.val)){\\n                node.left = roots.get(node.left.val);\\n                roots.remove(node.left.val);\\n            }\\n        }\\n        if(node.right != null){\\n            // Find any root node which matches with right leaf node and then append it to my BST\\n            // this duplicate code can be reduced by extracting a function\\n            if(roots.containsKey(node.right.val)){     \\n                node.right = roots.get(node.right.val);\\n                roots.remove(node.right.val);\\n            }\\n        }\\n        \\n        merge(node.left);\\n        merge(node.right);\\n    }\\n    \\n    boolean isValidBST(TreeNode n, int min, int max){\\n        if(n.val < min || n.val > max)\\n            return false;\\n        \\n        boolean l =true, r= true;\\n        \\n        if(n.left != null)\\n             l = isValidBST(n.left, min, n.val);\\n        if(n.right != null)\\n             r = isValidBST(n.right, n.val, max);\\n        \\n        return n.val>min && n.val < max & l && r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333876,
                "title": "java-o-n-using-two-hashmaps-optimized-40ms-explained-with-comments",
                "content": "Reference : https://leetcode.com/problems/merge-bsts-to-create-single-bst/discuss/1330172/Java-or-two-HashMaps\\n\\n```\\nclass Solution {\\n     public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> deletedRoots = new HashSet<>();\\n        Map<TreeNode, TreeNode> parentMap = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            rootMap.put(root.val, root);\\n\\n        for (TreeNode currentNode : trees) {\\n            /* If left node is present as root somewhere in list, replace the left node with root */\\n            if (currentNode.left != null && rootMap.containsKey(currentNode.left.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.left.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.left = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n\\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (currentNode.right != null && rootMap.containsKey(currentNode.right.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.right.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.right = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n        }\\n\\n        /* There should be only one root */\\n        if (deletedRoots.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!deletedRoots.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n\\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> deletedRoots = new HashSet<>();\\n        Map<TreeNode, TreeNode> parentMap = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            rootMap.put(root.val, root);\\n\\n        for (TreeNode currentNode : trees) {\\n            /* If left node is present as root somewhere in list, replace the left node with root */\\n            if (currentNode.left != null && rootMap.containsKey(currentNode.left.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.left.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.left = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n\\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (currentNode.right != null && rootMap.containsKey(currentNode.right.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.right.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.right = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n        }\\n\\n        /* There should be only one root */\\n        if (deletedRoots.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!deletedRoots.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n\\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330943,
                "title": "c-hash-map-detailed-comments",
                "content": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358695,
                "title": "don-t-think-too-much-c-time-o-n-space-o-n",
                "content": "# Intuition : Go in flow\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo what we do with separate nodes to make binary search tree.\\n\\n\\n# Approach : Brute force\\n<!-- Describe your approach to solving the problem. -->\\n> 1. Check the size of trees array if its 1 then just check that tree is `validBST` or not and return root;\\n> 2. Collect all the node in map except root of each tree in `val -> nodeAddress`.\\n> 3. Now create `root variable` with value `null` and loop through all tree heads. if that head value exist in map then update that values address with head address. \\n> 4. if not in map then store in `created root variable and check root should be assigned exactly 1 time if not then return null`.\\n> 5. Its time to make tree from root since we have collected correct value with node address in map.\\n> 6. Go through `makeTree` DFS function with root if left & right of node is null and that is exist in map  then update that address and `count++`.\\n> 7. if count and size of map is not same then return null.\\n> 8. Now, check `root is validBST or not` with [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/).\\n---\\n# Note : Corner cases steps\\n- Step 1 for only 1 tree in array\\n- Step 4 for completely diffrent trees that never match\\n- Step 7 loop between trees like tree1: [1, 2] and tree2: [2, 1]\\n\\n\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433286,
                "title": "java-o-n-solution",
                "content": "```\\npublic class Solution {\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        final int size = trees.size();\\n        final Map<Integer, TreeNode> roots = new HashMap<>(size);\\n        for (final TreeNode node : trees) {\\n            roots.put(node.val, node);\\n        }\\n        for (final TreeNode node : trees) {\\n            if (roots.containsKey(node.val)) {\\n                final TreeNode root = buildTree(roots, node);\\n                roots.put(root.val, root);\\n            }\\n        }\\n        if (roots.size() != 1) return null;\\n        final TreeNode root = roots.values().iterator().next();\\n        return isValid(root, Integer.MIN_VALUE, Integer.MAX_VALUE) ? root : null;\\n    }\\n\\n    private TreeNode buildTree(Map<Integer, TreeNode> roots, TreeNode node) {\\n        final TreeNode next = roots.remove(node.val);\\n        if (next != null) {\\n            if (next.left != null) node.left = buildTree(roots, next.left);\\n            if (next.right != null) node.right = buildTree(roots, next.right);\\n        }\\n        return node;\\n    }\\n\\n    private boolean isValid(TreeNode node, int min, int max) {\\n        if (node == null) return true;\\n        final int value = node.val;\\n        if (value <= min || max <= value) return false;\\n        return isValid(node.left, min, value) && isValid(node.right, value, max);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        final int size = trees.size();\\n        final Map<Integer, TreeNode> roots = new HashMap<>(size);\\n        for (final TreeNode node : trees) {\\n            roots.put(node.val, node);\\n        }\\n        for (final TreeNode node : trees) {\\n            if (roots.containsKey(node.val)) {\\n                final TreeNode root = buildTree(roots, node);\\n                roots.put(root.val, root);\\n            }\\n        }\\n        if (roots.size() != 1) return null;\\n        final TreeNode root = roots.values().iterator().next();\\n        return isValid(root, Integer.MIN_VALUE, Integer.MAX_VALUE) ? root : null;\\n    }\\n\\n    private TreeNode buildTree(Map<Integer, TreeNode> roots, TreeNode node) {\\n        final TreeNode next = roots.remove(node.val);\\n        if (next != null) {\\n            if (next.left != null) node.left = buildTree(roots, next.left);\\n            if (next.right != null) node.right = buildTree(roots, next.right);\\n        }\\n        return node;\\n    }\\n\\n    private boolean isValid(TreeNode node, int min, int max) {\\n        if (node == null) return true;\\n        final int value = node.val;\\n        if (value <= min || max <= value) return false;\\n        return isValid(node.left, min, value) && isValid(node.right, value, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331994,
                "title": "two-dfs",
                "content": "Let us call the input trees small trees, and the final BST the big tree.\\n\\nOne insight is that there can only be one such small tree that can be the topmost small tree in the final big tree . Because in the final big tree, except the topmost small tree, all other trees\\' root values appear in some leaves of other small trees. So if there exists a final big tree, then there is one and only one small tree whose root value is unique. This is a necessary condition. \\n\\nWe use two DFS. The 1st DFS writes down all leaves\\' occurrences, and use this info the decide which small tree is the topmost one. Then we use the second DFS to traverse and stitch the final tree at the same time.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (TreeNode* tree : trees) {\\n            roots[tree->val] = tree;\\n            dfs1(tree);\\n        }\\n        int rootVal = -1;\\n        for (auto [val, root] : roots) {\\n            if (leaves[val] == (root->left || root->right ? 0 : 1)) {\\n                if (rootVal == -1) {\\n                    rootVal = val;\\n                } else {\\n                    return nullptr;\\n                }\\n            }\\n        }\\n        if (rootVal == -1) {\\n            return nullptr;\\n        }\\n        TreeNode* ans = roots[rootVal];\\n        bool valid = dfs2(ans, INT_MIN, INT_MAX);\\n        return roots.size() == 1 && valid ? ans : nullptr;\\n    }\\n    \\nprivate:\\n    void dfs1(TreeNode* root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            ++leaves[root->val];\\n            return;\\n        }\\n        dfs1(root->left);\\n        dfs1(root->right);\\n    }\\n    bool dfs2(TreeNode* root, int l, int r) {\\n        assert(root != nullptr);\\n        if (root->val <= l || root->val >= r) {\\n            return false;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            if (auto iter = roots.find(root->val); iter != roots.end() && iter->second != root) {\\n                root->left = iter->second->left;\\n                root->right = iter->second->right;\\n                roots.erase(iter);\\n            }\\n        }\\n        if (root->left) {\\n            if (!dfs2(root->left, l, root->val)) {\\n                return false;\\n            }\\n        }\\n        if (root->right) {\\n            if (!dfs2(root->right, root->val, r)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_map<int, int> leaves;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (TreeNode* tree : trees) {\\n            roots[tree->val] = tree;\\n            dfs1(tree);\\n        }\\n        int rootVal = -1;\\n        for (auto [val, root] : roots) {\\n            if (leaves[val] == (root->left || root->right ? 0 : 1)) {\\n                if (rootVal == -1) {\\n                    rootVal = val;\\n                } else {\\n                    return nullptr;\\n                }\\n            }\\n        }\\n        if (rootVal == -1) {\\n            return nullptr;\\n        }\\n        TreeNode* ans = roots[rootVal];\\n        bool valid = dfs2(ans, INT_MIN, INT_MAX);\\n        return roots.size() == 1 && valid ? ans : nullptr;\\n    }\\n    \\nprivate:\\n    void dfs1(TreeNode* root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            ++leaves[root->val];\\n            return;\\n        }\\n        dfs1(root->left);\\n        dfs1(root->right);\\n    }\\n    bool dfs2(TreeNode* root, int l, int r) {\\n        assert(root != nullptr);\\n        if (root->val <= l || root->val >= r) {\\n            return false;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            if (auto iter = roots.find(root->val); iter != roots.end() && iter->second != root) {\\n                root->left = iter->second->left;\\n                root->right = iter->second->right;\\n                roots.erase(iter);\\n            }\\n        }\\n        if (root->left) {\\n            if (!dfs2(root->left, l, root->val)) {\\n                return false;\\n            }\\n        }\\n        if (root->right) {\\n            if (!dfs2(root->right, root->val, r)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_map<int, int> leaves;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330153,
                "title": "python-there-is-at-most-one-way-to-merge",
                "content": "**Explanation**\\n\\nThe fact that this is a strict BST, and we want all values to be distinct, makes our job much, much easier. This means that for each value v we find in any tree, there are two options:\\n1. v appears exactly once ever, or\\n2. v appears exactly twice: once as a root, and once as a leaf.\\n\\nThis means there is at most one way to merge the trees together. We want to process all of our trees, storing root values and child values in dictionaries and checking conflicts (values that are duplicated, but not in one of the two cases above). At the end, we try to merge all of our trees by repeatedly selecting any root and moving it to its final destination. We return true if we succeeded (i.e. if we have a valid BST, of the correct expected size).\\n\\n**Complexity**\\nTime and space complexity: `O(n)`. The code is also quite fast, since we try to break as quickly as possible if we see that we can\\'t merge the trees.\\n\\n**Python**\\n\\n```\\nclass Solution:\\n\\tdef canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n\\t\\tn = len(trees)\\n\\t\\tif n == 1: return trees[0]\\n\\n\\t\\tvalue_to_root = {}  # Map each integer root value to its node\\n\\t\\tappeared_as_middle_child = set()  # All values appearing in trees but not in a curr or leaf\\n\\t\\tself.saw_conflict = False  # If this is ever true, break out of function and return None\\n\\t\\tleaf_value_to_parent_node = {}\\n\\n\\t\\tdef is_leaf_node(curr: TreeNode) -> bool:\\n\\t\\t\\treturn curr.left is None and curr.right is None\\n\\n\\t\\tdef get_size(curr: TreeNode) -> int:  # DFS to count Binary Tree Size\\n\\t\\t\\tif curr is None: return 0\\n\\t\\t\\treturn 1 + get_size(curr.left) + get_size(curr.right)\\n\\n\\t\\tdef is_valid_bst(curr: TreeNode, lo=-math.inf, hi=math.inf) -> bool:  # Standard BST validation code\\n\\t\\t\\tif curr is None: return True\\n\\t\\t\\treturn all((lo < curr.val < hi,\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.left, lo, curr.val),\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.right, curr.val, hi)))\\n\\n\\t\\tdef process_child(child_node: TreeNode, parent: TreeNode) -> None:\\n\\t\\t\\tif child_node is None:\\n\\t\\t\\t\\treturn None\\n\\t\\t\\telif child_node.val in leaf_value_to_parent_node or child_node.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True  # Already saw this child node\\'s value in a non-root node\\n\\t\\t\\telif is_leaf_node(child_node):\\n\\t\\t\\t\\tleaf_value_to_parent_node[child_node.val] = parent\\n\\t\\t\\telif child_node.val in value_to_root:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tappeared_as_middle_child.add(child_node.val)\\n\\t\\t\\t\\tprocess_child(child_node.left, child_node)\\n\\t\\t\\t\\tprocess_child(child_node.right, child_node)\\n\\n\\t\\tdef process_root(curr_root: TreeNode) -> None:\\n\\t\\t\\tvalue_to_root[curr_root.val] = curr_root\\n\\n\\t\\t\\tif curr_root.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprocess_child(curr_root.left, curr_root)\\n\\t\\t\\t\\tprocess_child(curr_root.right, curr_root)\\n\\n\\t\\tfor root_here in trees:\\n\\t\\t\\tprocess_root(root_here)\\n\\t\\t\\tif self.saw_conflict: return None\\n\\n\\t\\tfinal_expected_size = len(leaf_value_to_parent_node) + len(appeared_as_middle_child) + 1\\n\\n\\t\\tfinal_root = None  # The root of our final BST will be stored here\\n\\t\\twhile value_to_root:\\n\\t\\t\\troot_val, root_node_to_move = value_to_root.popitem()\\n\\n\\t\\t\\tif root_val not in leaf_value_to_parent_node:  # Possibly found main root\\n\\t\\t\\t\\tif final_root is None:\\n\\t\\t\\t\\t\\tfinal_root = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Found two main roots\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnew_parent = leaf_value_to_parent_node.pop(root_val)\\n\\t\\t\\t\\tif new_parent.left is not None and new_parent.left.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.left = root_node_to_move\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telif new_parent.right is not None and new_parent.right.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.right = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Didn\\'t find a place to put this node\\n\\n\\t\\t# Didn\\'t find any candidates for main root, or have a cycle, or didn\\'t use all trees\\n\\t\\tif final_root is None or not is_valid_bst(final_root) or get_size(final_root) != final_expected_size:\\n\\t\\t\\treturn None\\n\\n\\t\\treturn final_root\\n```\\n\\nEdit: Most of the code is broken up into useful chunks of helper functions. This code also works with arbitrary BST\\'s of any size. Since the problem statement is currently a bit unclear about whether a 3-node, one-leaf BST is a valid input, the current code should still AC if the problem does get modified.\\n\\nAlso, a big thanks to @yaroslav-repeta for critiques on the code style.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n\\t\\tn = len(trees)\\n\\t\\tif n == 1: return trees[0]\\n\\n\\t\\tvalue_to_root = {}  # Map each integer root value to its node\\n\\t\\tappeared_as_middle_child = set()  # All values appearing in trees but not in a curr or leaf\\n\\t\\tself.saw_conflict = False  # If this is ever true, break out of function and return None\\n\\t\\tleaf_value_to_parent_node = {}\\n\\n\\t\\tdef is_leaf_node(curr: TreeNode) -> bool:\\n\\t\\t\\treturn curr.left is None and curr.right is None\\n\\n\\t\\tdef get_size(curr: TreeNode) -> int:  # DFS to count Binary Tree Size\\n\\t\\t\\tif curr is None: return 0\\n\\t\\t\\treturn 1 + get_size(curr.left) + get_size(curr.right)\\n\\n\\t\\tdef is_valid_bst(curr: TreeNode, lo=-math.inf, hi=math.inf) -> bool:  # Standard BST validation code\\n\\t\\t\\tif curr is None: return True\\n\\t\\t\\treturn all((lo < curr.val < hi,\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.left, lo, curr.val),\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.right, curr.val, hi)))\\n\\n\\t\\tdef process_child(child_node: TreeNode, parent: TreeNode) -> None:\\n\\t\\t\\tif child_node is None:\\n\\t\\t\\t\\treturn None\\n\\t\\t\\telif child_node.val in leaf_value_to_parent_node or child_node.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True  # Already saw this child node\\'s value in a non-root node\\n\\t\\t\\telif is_leaf_node(child_node):\\n\\t\\t\\t\\tleaf_value_to_parent_node[child_node.val] = parent\\n\\t\\t\\telif child_node.val in value_to_root:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tappeared_as_middle_child.add(child_node.val)\\n\\t\\t\\t\\tprocess_child(child_node.left, child_node)\\n\\t\\t\\t\\tprocess_child(child_node.right, child_node)\\n\\n\\t\\tdef process_root(curr_root: TreeNode) -> None:\\n\\t\\t\\tvalue_to_root[curr_root.val] = curr_root\\n\\n\\t\\t\\tif curr_root.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprocess_child(curr_root.left, curr_root)\\n\\t\\t\\t\\tprocess_child(curr_root.right, curr_root)\\n\\n\\t\\tfor root_here in trees:\\n\\t\\t\\tprocess_root(root_here)\\n\\t\\t\\tif self.saw_conflict: return None\\n\\n\\t\\tfinal_expected_size = len(leaf_value_to_parent_node) + len(appeared_as_middle_child) + 1\\n\\n\\t\\tfinal_root = None  # The root of our final BST will be stored here\\n\\t\\twhile value_to_root:\\n\\t\\t\\troot_val, root_node_to_move = value_to_root.popitem()\\n\\n\\t\\t\\tif root_val not in leaf_value_to_parent_node:  # Possibly found main root\\n\\t\\t\\t\\tif final_root is None:\\n\\t\\t\\t\\t\\tfinal_root = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Found two main roots\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnew_parent = leaf_value_to_parent_node.pop(root_val)\\n\\t\\t\\t\\tif new_parent.left is not None and new_parent.left.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.left = root_node_to_move\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telif new_parent.right is not None and new_parent.right.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.right = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Didn\\'t find a place to put this node\\n\\n\\t\\t# Didn\\'t find any candidates for main root, or have a cycle, or didn\\'t use all trees\\n\\t\\tif final_root is None or not is_valid_bst(final_root) or get_size(final_root) != final_expected_size:\\n\\t\\t\\treturn None\\n\\n\\t\\treturn final_root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561451,
                "title": "python-solution-beats-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\n        leaves = set()\\n        treeDict = {}\\n\\n        for tree in trees:\\n            treeDict[tree.val]=tree\\n            if tree.left:\\n                leaves.add(tree.left.val)\\n            if tree.right:\\n                leaves.add(tree.right.val)\\n\\n        root=None\\n\\n        for tree in trees:\\n            if tree.val not in leaves:\\n                root = tree\\n                break\\n        \\n        if not root:\\n            return None\\n        \\n        curleaves = {}\\n        if root.left:\\n            curleaves[root.left.val] = (-sys.maxsize,root.val,root,0)\\n\\n        if root.right:\\n            curleaves[root.right.val] = (root.val,sys.maxsize,root,1)\\n\\n        del treeDict[root.val]\\n\\n        while treeDict:\\n            findTree = False\\n            for leaf,(low,high,par,lor) in curleaves.items():\\n                if leaf in treeDict:\\n                    newTree = treeDict[leaf]\\n                    del curleaves[leaf]\\n\\n                    if newTree.left:\\n                        if low < newTree.left.val < high and newTree.left.val not in curleaves:\\n                            curleaves[newTree.left.val] = (low,newTree.val,newTree,0)\\n                        else:\\n                            return None\\n                    if newTree.right:\\n                        if low < newTree.right.val < high and newTree.right.val not in curleaves:\\n                            curleaves[newTree.right.val] = (newTree.val,high,newTree,1)\\n                        else:\\n                            return None\\n\\n                    if lor == 0:\\n                        par.left = newTree\\n                    else:\\n                        par.right = newTree\\n\\n                    findTree = True\\n                    del treeDict[newTree.val]\\n                    break\\n            if not findTree:\\n                return None\\n        return root\\n                    \\n             \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\n        leaves = set()\\n        treeDict = {}\\n\\n        for tree in trees:\\n            treeDict[tree.val]=tree\\n            if tree.left:\\n                leaves.add(tree.left.val)\\n            if tree.right:\\n                leaves.add(tree.right.val)\\n\\n        root=None\\n\\n        for tree in trees:\\n            if tree.val not in leaves:\\n                root = tree\\n                break\\n        \\n        if not root:\\n            return None\\n        \\n        curleaves = {}\\n        if root.left:\\n            curleaves[root.left.val] = (-sys.maxsize,root.val,root,0)\\n\\n        if root.right:\\n            curleaves[root.right.val] = (root.val,sys.maxsize,root,1)\\n\\n        del treeDict[root.val]\\n\\n        while treeDict:\\n            findTree = False\\n            for leaf,(low,high,par,lor) in curleaves.items():\\n                if leaf in treeDict:\\n                    newTree = treeDict[leaf]\\n                    del curleaves[leaf]\\n\\n                    if newTree.left:\\n                        if low < newTree.left.val < high and newTree.left.val not in curleaves:\\n                            curleaves[newTree.left.val] = (low,newTree.val,newTree,0)\\n                        else:\\n                            return None\\n                    if newTree.right:\\n                        if low < newTree.right.val < high and newTree.right.val not in curleaves:\\n                            curleaves[newTree.right.val] = (newTree.val,high,newTree,1)\\n                        else:\\n                            return None\\n\\n                    if lor == 0:\\n                        par.left = newTree\\n                    else:\\n                        par.right = newTree\\n\\n                    findTree = True\\n                    del treeDict[newTree.val]\\n                    break\\n            if not findTree:\\n                return None\\n        return root\\n                    \\n             \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709355,
                "title": "100-test-cases-passed-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> valToNode = new HashMap<>(); \\n    Map<Integer, Integer> count = new HashMap<>();      \\n\\n    for (TreeNode tree : trees) {\\n      valToNode.put(tree.val, tree);\\n      count.merge(tree.val, 1, Integer::sum);\\n      if (tree.left != null)\\n        count.merge(tree.left.val, 1, Integer::sum);\\n      if (tree.right != null)\\n        count.merge(tree.right.val, 1, Integer::sum);\\n    }\\n\\n    for (TreeNode tree : trees)\\n      if (count.get(tree.val) == 1) {\\n        if (isValidBST(tree, null, null, valToNode) && valToNode.size() <= 1)\\n          return tree;\\n        return null;\\n      }\\n\\n    return null;\\n  }\\n\\n  public boolean isValidBST(TreeNode tree, TreeNode minNode, TreeNode maxNode,\\n                             Map<Integer, TreeNode> valToNode) {\\n    if (tree == null)\\n      return true;\\n    if (minNode != null && tree.val <= minNode.val)\\n      return false;\\n    if (maxNode != null && tree.val >= maxNode.val)\\n      return false;\\n    if (tree.left == null && tree.right == null && valToNode.containsKey(tree.val)) {\\n      final int val = tree.val;\\n      tree.left = valToNode.get(val).left;\\n      tree.right = valToNode.get(val).right;\\n      valToNode.remove(val);\\n    }\\n\\n    return isValidBST(tree.left, minNode, tree, valToNode) &&\\n           isValidBST(tree.right, tree, maxNode, valToNode);\\n    }\\n}\\n    \\n\\n```",
                "solutionTags": [
                    "Array",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> valToNode = new HashMap<>(); \\n    Map<Integer, Integer> count = new HashMap<>();      \\n\\n    for (TreeNode tree : trees) {\\n      valToNode.put(tree.val, tree);\\n      count.merge(tree.val, 1, Integer::sum);\\n      if (tree.left != null)\\n        count.merge(tree.left.val, 1, Integer::sum);\\n      if (tree.right != null)\\n        count.merge(tree.right.val, 1, Integer::sum);\\n    }\\n\\n    for (TreeNode tree : trees)\\n      if (count.get(tree.val) == 1) {\\n        if (isValidBST(tree, null, null, valToNode) && valToNode.size() <= 1)\\n          return tree;\\n        return null;\\n      }\\n\\n    return null;\\n  }\\n\\n  public boolean isValidBST(TreeNode tree, TreeNode minNode, TreeNode maxNode,\\n                             Map<Integer, TreeNode> valToNode) {\\n    if (tree == null)\\n      return true;\\n    if (minNode != null && tree.val <= minNode.val)\\n      return false;\\n    if (maxNode != null && tree.val >= maxNode.val)\\n      return false;\\n    if (tree.left == null && tree.right == null && valToNode.containsKey(tree.val)) {\\n      final int val = tree.val;\\n      tree.left = valToNode.get(val).left;\\n      tree.right = valToNode.get(val).right;\\n      valToNode.remove(val);\\n    }\\n\\n    return isValidBST(tree.left, minNode, tree, valToNode) &&\\n           isValidBST(tree.right, tree, maxNode, valToNode);\\n    }\\n}\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347222,
                "title": "c-simple-hashmap-explained-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    //checking validity of final BST\\n    //***************************************************************************************\\n    bool checkBST(TreeNode *root, int left=0, int right =50001){\\n        \\n        if(root==NULL) return true;\\n        if(root->val >= right || root->val <= left) return false;\\n        \\n        bool leftSide=checkBST(root->left,left,root->val);\\n        bool rightSide=checkBST(root->right,root->val,right);\\n        \\n        return leftSide && rightSide;\\n    }\\n    \\n    \\n    \\n    //are all the trees placed in main bst?\\n    //***************************************************************************************\\n    bool allTreesPlaced(unordered_map<int,TreeNode*> &nodes, vector<TreeNode*>& trees){\\n        \\n        \\n        for(auto &itr : trees){\\n            if(nodes[itr->val]!=NULL) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    \\n    //to merge into bst of found parent root\\n    //***************************************************************************************\\n    void merge(TreeNode *root, unordered_map<int,TreeNode*> &umap){\\n        \\n        if(root==NULL) return;\\n        \\n        //in left\\n        if(root->left){\\n            //if it is to be replaced\\n            if(umap[root->left->val]!=NULL){\\n                root->left=umap[root->left->val];\\n                umap[root->left->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        //in right\\n        if(root->right){\\n            //if it is to be replaced\\n            if(umap[root->right->val]!=NULL){\\n                root->right=umap[root->right->val];\\n                umap[root->right->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        \\n        //repeat for children\\n        merge(root->left,umap);\\n        merge(root->right,umap);\\n        \\n        return;\\n    }\\n    \\n    \\n   \\n    //to find if can merge\\n    //if can do it\\n    //else send NULL\\n    //***************************************************************************************\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        \\n        \\n        //find start of final bst\\n        unordered_map<int,int> umap;\\n        \\n        for(auto &itr : trees){\\n            umap[itr->val]++;\\n            if(itr->left !=NULL) umap[itr->left->val]++;\\n            if(itr->right !=NULL) umap[itr->right->val]++;\\n       }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(umap[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        if(root==NULL) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //all nodes to be placed in root;\\n        unordered_map<int,TreeNode*> umap2;\\n        for(auto &itr : trees){\\n            umap2[itr->val]=itr;\\n        }\\n        umap2[root->val]=NULL;  //removed root one from to be placed ones\\n        merge(root,umap2);\\n        \\n        \\n        \\n        \\n        \\n        //if all not found place invalid\\n        if(!allTreesPlaced(umap2,trees)) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //check final BST valid or not\\n        if(!checkBST(root)) return NULL;\\n        \\n        \\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    //checking validity of final BST\\n    //***************************************************************************************\\n    bool checkBST(TreeNode *root, int left=0, int right =50001){\\n        \\n        if(root==NULL) return true;\\n        if(root->val >= right || root->val <= left) return false;\\n        \\n        bool leftSide=checkBST(root->left,left,root->val);\\n        bool rightSide=checkBST(root->right,root->val,right);\\n        \\n        return leftSide && rightSide;\\n    }\\n    \\n    \\n    \\n    //are all the trees placed in main bst?\\n    //***************************************************************************************\\n    bool allTreesPlaced(unordered_map<int,TreeNode*> &nodes, vector<TreeNode*>& trees){\\n        \\n        \\n        for(auto &itr : trees){\\n            if(nodes[itr->val]!=NULL) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    \\n    //to merge into bst of found parent root\\n    //***************************************************************************************\\n    void merge(TreeNode *root, unordered_map<int,TreeNode*> &umap){\\n        \\n        if(root==NULL) return;\\n        \\n        //in left\\n        if(root->left){\\n            //if it is to be replaced\\n            if(umap[root->left->val]!=NULL){\\n                root->left=umap[root->left->val];\\n                umap[root->left->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        //in right\\n        if(root->right){\\n            //if it is to be replaced\\n            if(umap[root->right->val]!=NULL){\\n                root->right=umap[root->right->val];\\n                umap[root->right->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        \\n        //repeat for children\\n        merge(root->left,umap);\\n        merge(root->right,umap);\\n        \\n        return;\\n    }\\n    \\n    \\n   \\n    //to find if can merge\\n    //if can do it\\n    //else send NULL\\n    //***************************************************************************************\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        \\n        \\n        //find start of final bst\\n        unordered_map<int,int> umap;\\n        \\n        for(auto &itr : trees){\\n            umap[itr->val]++;\\n            if(itr->left !=NULL) umap[itr->left->val]++;\\n            if(itr->right !=NULL) umap[itr->right->val]++;\\n       }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(umap[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        if(root==NULL) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //all nodes to be placed in root;\\n        unordered_map<int,TreeNode*> umap2;\\n        for(auto &itr : trees){\\n            umap2[itr->val]=itr;\\n        }\\n        umap2[root->val]=NULL;  //removed root one from to be placed ones\\n        merge(root,umap2);\\n        \\n        \\n        \\n        \\n        \\n        //if all not found place invalid\\n        if(!allTreesPlaced(umap2,trees)) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //check final BST valid or not\\n        if(!checkBST(root)) return NULL;\\n        \\n        \\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824005,
                "title": "c-one-map-for-root-one-set-for-leaf",
                "content": "class Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootmap;\\n    unordered_set<int> leafmap;\\n  \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n      \\n        for(auto it : trees) {\\n            rootmap[it->val] = it;\\n            if(it->left)\\n                leafmap.insert(it->left->val);\\n            if(it->right)\\n                leafmap.insert(it->right->val);\\n        }\\n        TreeNode* root = nullptr;\\n        for(auto it : trees) {\\n            if(leafmap.find(it->val) == leafmap.end())\\n                root = it;\\n        }\\n        if(helper(root, INT_MIN, INT_MAX)) {\\n            if(rootmap.size() == 1)\\n                return root;\\n        }\\n        return nullptr;\\n    }\\n    \\n    bool helper(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return true;\\n        if(root->val >= high || root->val <= low)\\n            return false;    \\n        if(root->left) {\\n            int cur = root->left->val;\\n            if(rootmap.find(cur) != rootmap.end()) {\\n                root->left = rootmap[cur];\\n                rootmap.erase(cur);\\n            }\\n        }\\n        \\n        if(root->right) {\\n            int cur = root->right->val;\\n            if(rootmap.find(cur) != rootmap.end()) {\\n                root->right = rootmap[cur];\\n                rootmap.erase(cur);\\n            }            \\n        }\\n        \\n         if(!helper(root->left, low, root->val))\\n            return false;\\n        \\n        if(!helper(root->right, root->val, high))\\n            return false;\\n        \\n     \\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootmap;\\n    unordered_set<int> leafmap;\\n  \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n      \\n        for(auto it : trees) {\\n            rootmap[it->val] = it;\\n            if(it->left)\\n                leafmap.insert(it->left->val);\\n            if(it->right)\\n                leafmap.insert(it->right->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1805468,
                "title": "c",
                "content": "\\'\\'\\'\\'class Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        set<int> temp;\\n        vector<int> temp2;\\n        for(int i=0;i<trees.size();i++)\\n        {   \\n           \\n             inorder(trees[i],temp);\\n        }\\n        for(auto c:temp)\\n        {\\n            temp2.push_back(c);\\n        }\\n        if(temp2.size()==0)return nullptr;\\n      TreeNode* root1=  convertToBST(temp2,0,temp2.size()-1);\\n        return root1;\\n        \\n    }\\n    void inorder(TreeNode* root,set<int>& temp)\\n    {\\n          if(root==NULL)return;\\n         inorder(root->left,temp);\\n        temp.insert(root->val);\\n        inorder(root->right,temp);\\n        \\n    }\\n    TreeNode* convertToBST(vector<int>& temp2,int low,int high)\\n    {\\n        if(low>high)\\n            return nullptr;\\n        int mid=(low+high)/2;\\n        TreeNode* root=new TreeNode(temp2[mid]);\\n        TreeNode* ltree=convertToBST(temp2,low,mid-1);\\n        TreeNode* rtree=convertToBST(temp2,mid+1,high);\\n        root->left=ltree;\\n        root->right=rtree;\\n        return root;\\n    }\\n};\\'\\'\\'\\'\\'\\n\\nPlease suggest ,what i am doing wrong here",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        set<int> temp;\\n        vector<int> temp2;\\n        for(int i=0;i<trees.size();i++)\\n        {   \\n           \\n             inorder(trees[i],temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1757102,
                "title": "python-a-tale-of-2-dicts-simple-dfs",
                "content": "Check for multiple root trees when done merging with DFS.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.roots = {}\\n        self.leaves = {}\\n        \\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        for tree in trees:\\n            self.generate_roots_and_leaves(tree)\\n        start = set(self.roots.keys()) - set(self.leaves.keys())\\n\\t\\t\\n\\t\\t# Check only 1 starting root else disjointed\\n        if len(start) != 1:\\n            return None\\n\\t\\t\\t\\n        start = self.roots[next(iter(start))]\\n        root = self.dfs(start)\\n        return root if len(self.roots) == 1 and self.is_valid_tree(root, float(\"inf\"), float(\"-inf\")) else None\\n\\n    def is_valid_tree(self, node, max_left, min_right):\\n        if node:\\n            if node.val < max_left and node.val > min_right:\\n                return all([self.is_valid_tree(node.left, min(node.val, max_left), min_right), self.is_valid_tree(node.right, max_left, max(min_right, node.val))])\\n            else:\\n                return False\\n        return True\\n           \\n    def generate_roots_and_leaves(self, tree):\\n        self.roots[tree.val] = tree\\n\\n        if tree.left:\\n            self.leaves[tree.left.val] = tree.left\\n        if tree.right:\\n            self.leaves[tree.right.val] = tree.right\\n            \\n    def dfs(self, tree):\\n        if tree:\\n            if tree.left and tree.left.val in self.roots:\\n                tree.left = self.roots[tree.left.val]\\n                del(self.roots[tree.left.val])\\n                self.dfs(tree.left)\\n\\n            if tree.right and tree.right.val in self.roots:\\n                tree.right = self.roots[tree.right.val]\\n                del(self.roots[tree.right.val])\\n                self.dfs(tree.right)\\n\\n        return tree\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.roots = {}\\n        self.leaves = {}\\n        \\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        for tree in trees:\\n            self.generate_roots_and_leaves(tree)\\n        start = set(self.roots.keys()) - set(self.leaves.keys())\\n\\t\\t\\n\\t\\t# Check only 1 starting root else disjointed\\n        if len(start) != 1:\\n            return None\\n\\t\\t\\t\\n        start = self.roots[next(iter(start))]\\n        root = self.dfs(start)\\n        return root if len(self.roots) == 1 and self.is_valid_tree(root, float(\"inf\"), float(\"-inf\")) else None\\n\\n    def is_valid_tree(self, node, max_left, min_right):\\n        if node:\\n            if node.val < max_left and node.val > min_right:\\n                return all([self.is_valid_tree(node.left, min(node.val, max_left), min_right), self.is_valid_tree(node.right, max_left, max(min_right, node.val))])\\n            else:\\n                return False\\n        return True\\n           \\n    def generate_roots_and_leaves(self, tree):\\n        self.roots[tree.val] = tree\\n\\n        if tree.left:\\n            self.leaves[tree.left.val] = tree.left\\n        if tree.right:\\n            self.leaves[tree.right.val] = tree.right\\n            \\n    def dfs(self, tree):\\n        if tree:\\n            if tree.left and tree.left.val in self.roots:\\n                tree.left = self.roots[tree.left.val]\\n                del(self.roots[tree.left.val])\\n                self.dfs(tree.left)\\n\\n            if tree.right and tree.right.val in self.roots:\\n                tree.right = self.roots[tree.right.val]\\n                del(self.roots[tree.right.val])\\n                self.dfs(tree.right)\\n\\n        return tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689069,
                "title": "using-two-hashmaps-roots-and-leaves",
                "content": "Idea is to use two hashmaps - \\n1. to store all the roots\\n2. to store all the leaf openings\\n\\nAfter this we can just scan through our trees and find if there are any openings. If we do, connect them together. We then also update our hashmaps by removing the opening as well as the root that got merged.\\n\\nFinally, we check whether the final remaining roots are only 1, and a valid BST. We also match the sizes as there were some test cases that had created cycles.\\n\\n```\\nclass Solution {\\n    Map<Integer, TreeNode> rootLookup;\\n    Map<String, TreeNode> openings;\\n\\n    private Map<Integer, TreeNode> buildLookup(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) lookup.put(tree.val, tree);\\n        return lookup;\\n    }\\n    \\n    private Map<String, TreeNode> buildOpenings(List<TreeNode> trees) {\\n        Map<String, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) {\\n            if(tree.left != null) lookup.put(tree.left.val + \"L\", tree);\\n            if(tree.right != null) lookup.put(tree.right.val + \"R\", tree);\\n        }\\n        return lookup;\\n    }\\n    \\n    private boolean isValidBST(TreeNode a, int min, int max) {\\n        if(a == null) return true;\\n        if(a.val <= min || a.val >= max) return false;\\n        return isValidBST(a.left, min, a.val) && isValidBST(a.right, a.val, max);\\n    }    \\n\\n    private TreeNode connectThemAll(List<TreeNode> trees, int expectedSize) {\\n        for(TreeNode tree: trees) {\\n            // meaning tree has already been merged\\n            if(!rootLookup.containsKey(tree.val)) continue;\\n            \\n            // check if there is any left leaf opening\\n            TreeNode leftChildOpening = openings.get(tree.val + \"L\");\\n            if(leftChildOpening != null) { \\n                leftChildOpening.left = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"L\");\\n                continue; \\n            }\\n            \\n            // check if there is any right leaf opening\\n            TreeNode rightChildOpening = openings.get(tree.val + \"R\");\\n            if(rightChildOpening != null) { \\n                rightChildOpening.right = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"R\");\\n                continue; \\n            }\\n        }\\n        \\n        if(rootLookup.size() != 1) return null;\\n        TreeNode root = rootLookup.entrySet().iterator().next().getValue();\\n        if(!isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE)) return null;\\n        \\n        // due to cycles, we need to also check for the size\\n        if(size(root) != expectedSize) return null;\\n\\n        return root;\\n    }\\n    \\n    // calculate the size of the tree\\n    private int size(TreeNode curr) {\\n        if(curr == null) return 0;\\n        return size(curr.left) + size(curr.right) + 1;\\n    }\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        rootLookup = buildLookup(trees);\\n        openings = buildOpenings(trees);\\n        Set<Integer> uniqueVals = new HashSet<>();\\n        for(TreeNode tree: trees) {\\n            uniqueVals.add(tree.val);\\n            if(tree.left != null) uniqueVals.add(tree.left.val);\\n            if(tree.right != null) uniqueVals.add(tree.right.val);\\n        }\\n        return connectThemAll(trees, uniqueVals.size());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, TreeNode> rootLookup;\\n    Map<String, TreeNode> openings;\\n\\n    private Map<Integer, TreeNode> buildLookup(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) lookup.put(tree.val, tree);\\n        return lookup;\\n    }\\n    \\n    private Map<String, TreeNode> buildOpenings(List<TreeNode> trees) {\\n        Map<String, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) {\\n            if(tree.left != null) lookup.put(tree.left.val + \"L\", tree);\\n            if(tree.right != null) lookup.put(tree.right.val + \"R\", tree);\\n        }\\n        return lookup;\\n    }\\n    \\n    private boolean isValidBST(TreeNode a, int min, int max) {\\n        if(a == null) return true;\\n        if(a.val <= min || a.val >= max) return false;\\n        return isValidBST(a.left, min, a.val) && isValidBST(a.right, a.val, max);\\n    }    \\n\\n    private TreeNode connectThemAll(List<TreeNode> trees, int expectedSize) {\\n        for(TreeNode tree: trees) {\\n            // meaning tree has already been merged\\n            if(!rootLookup.containsKey(tree.val)) continue;\\n            \\n            // check if there is any left leaf opening\\n            TreeNode leftChildOpening = openings.get(tree.val + \"L\");\\n            if(leftChildOpening != null) { \\n                leftChildOpening.left = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"L\");\\n                continue; \\n            }\\n            \\n            // check if there is any right leaf opening\\n            TreeNode rightChildOpening = openings.get(tree.val + \"R\");\\n            if(rightChildOpening != null) { \\n                rightChildOpening.right = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"R\");\\n                continue; \\n            }\\n        }\\n        \\n        if(rootLookup.size() != 1) return null;\\n        TreeNode root = rootLookup.entrySet().iterator().next().getValue();\\n        if(!isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE)) return null;\\n        \\n        // due to cycles, we need to also check for the size\\n        if(size(root) != expectedSize) return null;\\n\\n        return root;\\n    }\\n    \\n    // calculate the size of the tree\\n    private int size(TreeNode curr) {\\n        if(curr == null) return 0;\\n        return size(curr.left) + size(curr.right) + 1;\\n    }\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        rootLookup = buildLookup(trees);\\n        openings = buildOpenings(trees);\\n        Set<Integer> uniqueVals = new HashSet<>();\\n        for(TreeNode tree: trees) {\\n            uniqueVals.add(tree.val);\\n            if(tree.left != null) uniqueVals.add(tree.left.val);\\n            if(tree.right != null) uniqueVals.add(tree.right.val);\\n        }\\n        return connectThemAll(trees, uniqueVals.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411216,
                "title": "c-simple-approach-proof-based-explanation-code",
                "content": "\\n\\n**Important Observations**\\n1) **If any two leaves have same value, we can\\'t have a valid BST.**\\n\\tProof: Let say, two nodes, namely, node1 & node2 have same value.\\n\\t\\t\\t  WLOG, let node2 is in left subtree of node1. \\n\\t\\t\\t\\t  => node2->val < node1->val, \\n\\t\\t\\t\\t  {because left tree should contains nodes with strictly lesser value, according to the definition given in the question statement}\\n\\t\\t\\t\\t  => Thus, node2->val != node1->val (**Contradiction**)\\n\\n2) **There should be exactly one root, which does not have corresponding leaf node to merge with.**\\n\\tProof by contradiction: It we have two such roots, then we will have two head nodes of our merged BST, which is not possible.\\n\\t\\n\\n**Algorithm**\\n\\n1) Map root and leaf pointers to their values.\\n2) Find Head Node, and merge in arbitary order.\\n3) Check Validness of the BST\\n\\n\\n**Time Complexity**\\nO(m), where m is max tree node value. Here m<= 5*10^4.  \\nBut we can optimise it to O(n), where n is the number of tree nodes. Just use unordered_map instead of vectors root & leaf.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nint cnt = 0;\\nbool isValid(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n    if(!root) return true;\\n    cnt++;\\n    if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n        return false;\\n    return isValid(root->left, minNode, root) && isValid(root->right, root, maxNode);\\n}\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = 0;\\n        vector<TreeNode*> root(50001, nullptr),leaf(50001, nullptr);\\n        for(auto ptr:trees){\\n            root[ptr->val] = ptr;\\n            n++;\\n            if(ptr->left) {\\n                n++;\\n                if(leaf[ptr->left->val]) return nullptr; //from observation 1\\n                leaf[ptr->left->val] = ptr->left;\\n            }\\n            \\n            if(ptr->right){\\n                n++;\\n                if(leaf[ptr->right->val]) return nullptr;  //from observation 1              \\n                leaf[ptr->right->val] = ptr->right;\\n            }\\n        }\\n        TreeNode* head = nullptr;\\n        for(auto ptr : root){\\n            if(ptr){\\n                auto pp = leaf[ptr->val];\\n                if(!pp && !head) { head = ptr; continue;}  //from observation 2\\n                else if(!pp) return nullptr; //from observation 2\\n                // cout<<pp->val<<endl;\\n                pp->left  = ptr->left;    //merging\\n                pp->right = ptr->right;  //merging\\n            }\\n        }\\n        \\n        cnt = 0;\\n        bool ff = isValid(head, nullptr, nullptr);\\n        \\n        return ff && cnt== n-trees.size()+1? head : nullptr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nint cnt = 0;\\nbool isValid(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n    if(!root) return true;\\n    cnt++;\\n    if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n        return false;\\n    return isValid(root->left, minNode, root) && isValid(root->right, root, maxNode);\\n}\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = 0;\\n        vector<TreeNode*> root(50001, nullptr),leaf(50001, nullptr);\\n        for(auto ptr:trees){\\n            root[ptr->val] = ptr;\\n            n++;\\n            if(ptr->left) {\\n                n++;\\n                if(leaf[ptr->left->val]) return nullptr; //from observation 1\\n                leaf[ptr->left->val] = ptr->left;\\n            }\\n            \\n            if(ptr->right){\\n                n++;\\n                if(leaf[ptr->right->val]) return nullptr;  //from observation 1              \\n                leaf[ptr->right->val] = ptr->right;\\n            }\\n        }\\n        TreeNode* head = nullptr;\\n        for(auto ptr : root){\\n            if(ptr){\\n                auto pp = leaf[ptr->val];\\n                if(!pp && !head) { head = ptr; continue;}  //from observation 2\\n                else if(!pp) return nullptr; //from observation 2\\n                // cout<<pp->val<<endl;\\n                pp->left  = ptr->left;    //merging\\n                pp->right = ptr->right;  //merging\\n            }\\n        }\\n        \\n        cnt = 0;\\n        bool ff = isValid(head, nullptr, nullptr);\\n        \\n        return ff && cnt== n-trees.size()+1? head : nullptr;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1359112,
                "title": "concise-c-beats-99-single-map-single-dfs-roo-leaf-merge",
                "content": "Major observations:\\n1. Apart from unquie root values, we also need **unique leaf values**, otherwise we dont have unique node to mount the root to, and also this would break the bst contraints for **strict** ordering.\\n2. If a **root does not map to a leaf, it must be the root of final tree**\\n3. If multiple roots dont map to leaves, then we have disjoint trees/graphs\\n4. the **count of nodes in the final valid bst must be equal to the total unique node cnt**( this will eliminate loops, non valid bst, and even disjoint sets)\\n\\nSolution:\\n1. Create map of leaf node val to its reference( have used double pointer in code as we cant store references in map. Parent node pointer could also be used here). Basically during  merge, we need to update the child node pointers in trees to new pointers.\\n2. Now traverse the root nodes one by one and merge them to leaf nodes\\n3. Traverse the merged bst to validate the number of nodes\\n4. Use the above observations to find invalid usecases\\n\\n````\\n#define MIN 0\\n#define MAX 500001\\nclass Solution {\\n    unordered_map<int,TreeNode**> leaves;\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto ptr:trees){\\n            if(ptr->left){\\n                if(leaves.count(ptr->left->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->left->val]=&(ptr->left);\\n            }\\n            if(ptr->right){\\n                if(leaves.count(ptr->right->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->right->val]=&(ptr->right);\\n            }\\n        }\\n        int cnt=leaves.size();//cnt is the number of distinct nodes, distinct roots+ leaves\\n        for(auto ptr:trees){\\n            if(!leaves.count(ptr->val))cnt++;\\n        }\\n        TreeNode* ans=nullptr;\\n        for(auto root:trees){\\n            int val=root->val;\\n            if(leaves.find(val)!=leaves.end()){//merge\\n                auto leaf = leaves[val];\\n                *leaf=root;\\n                leaves.erase(val);\\n            }else{//root does not map to any leaf, so mark it ans\\n                if(ans!=nullptr)//multiple roots\\n                    return nullptr;\\n                ans=root;\\n            }\\n        }\\n        if(isValidBST(ans)!=cnt)return nullptr;\\n        return ans;\\n    }\\n    int isValidBST(TreeNode* root, int min=MIN, int max=MAX) {\\n        if(!root || root->val>=max || root->val<=min)return 0;\\n        return 1 + (isValidBST(root->left,min,root->val) + isValidBST(root->right,root->val,max));\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "````\\n#define MIN 0\\n#define MAX 500001\\nclass Solution {\\n    unordered_map<int,TreeNode**> leaves;\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto ptr:trees){\\n            if(ptr->left){\\n                if(leaves.count(ptr->left->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->left->val]=&(ptr->left);\\n            }\\n            if(ptr->right){\\n                if(leaves.count(ptr->right->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->right->val]=&(ptr->right);\\n            }\\n        }\\n        int cnt=leaves.size();//cnt is the number of distinct nodes, distinct roots+ leaves\\n        for(auto ptr:trees){\\n            if(!leaves.count(ptr->val))cnt++;\\n        }\\n        TreeNode* ans=nullptr;\\n        for(auto root:trees){\\n            int val=root->val;\\n            if(leaves.find(val)!=leaves.end()){//merge\\n                auto leaf = leaves[val];\\n                *leaf=root;\\n                leaves.erase(val);\\n            }else{//root does not map to any leaf, so mark it ans\\n                if(ans!=nullptr)//multiple roots\\n                    return nullptr;\\n                ans=root;\\n            }\\n        }\\n        if(isValidBST(ans)!=cnt)return nullptr;\\n        return ans;\\n    }\\n    int isValidBST(TreeNode* root, int min=MIN, int max=MAX) {\\n        if(!root || root->val>=max || root->val<=min)return 0;\\n        return 1 + (isValidBST(root->left,min,root->val) + isValidBST(root->right,root->val,max));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341795,
                "title": "python-simple-simulation-o-n-easy-to-understand-with-explanations",
                "content": "This description of this problem lists the steps to simulate the merging process. The only thing we need to do is to implement the whole process. Notably there are some edge cases, and also a few quick ways to check if there exists a valid solution. \\n\\nFrom the begining, we know that:\\n1. The final result is a BST, which can NOT have duplicated values across its nodes.\\n2. The are `n` trees initially and we can only merge nodes for `n-1` times, which means each node can at most be merged for `1` time.\\n\\nThe above information indicates that:\\n1. In the original trees, the maximum ocurring frequency of a duplicated value is 2, otherwise there must be duplicates in the final BST. \\n2. The number of 2-duplicated pairs must be exactly `n-1`, becasue each merging solves a duplicate.\\n\\nThe above 2 conditions can help us quickly rule out invalid cases and return `null` before the simulation process. Moreover, we need to figure out which nodes will be paired together and merged before the simulation process as well, so we traverse over all nodes in the original trees and create a mapping from each value to `a list of its locations` (the index of the tree it belongs to and its position in that tree). The information we need looks like: \\n```\\n {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n```\\nThe maximum length of such a list is 2, and the number of lists of length 2 is exactly `n-1`, as explained above.  For those nodes to be merged (whose value has a location list of length 2), one node must be `root` and the other must be `left/right` leaf of a tree, following the described merging process.\\n\\nSo the next step is to merge those nodes one by one, where we use a `deleted` array to mark which trees will be deleted after the merging process. since we will merge `n-1` tree, there will be only one remaining tree root undeleted in `trees`, which can be the final result only if it leads a valid `BST`. We then use inorder traversal to check if the tree rooted by the undeleted root is a valid BST and return the root if so. \\n\\nNotably, there is an edge case, e.g., in test case 465: \\n`[[1,null,3],[3,1],[4,2]]`\\nThe first 2 input trees forms a cycle and both will be deleted in the merging process. The algorithm will return `[[4,2]]`, which is indeed a valid BST but does not contain all origianl nodes. We can avoid this edge case by comparing the number of nodes in the final result to the number of original nodes after merging and deletion. \\n\\nThe complete code is as below: \\n\\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:        \\n        locs = defaultdict(list) # {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n        deleted = [False for i in range(len(trees))] # to mark the deleted roots        \\n        n_nodes = 0 # num of nodes in the original trees\\n        \\n        # find the location of each value and its position in a tree\\n        for i, node in enumerate(trees):            \\n            locs[node.val].append((i, \\'root\\'))\\n            n_nodes += 1\\n            if node.left:\\n                locs[node.left.val].append((i, \\'left\\'))\\n                n_nodes += 1\\n            if node.right:\\n                locs[node.right.val].append((i, \\'right\\'))  \\n                n_nodes += 1\\n        \\n        # check if max freq of dups is 2\\n        freq = {k : len(v) for k,v in locs.items()}        \\n        if max(freq.values()) > 2:\\n            return None\\n        # check if number of 2-dups is n-1\\n        freq_dist = Counter(freq.values())\\n        if freq_dist[2] != len(trees)-1:\\n            return None\\n        \\n        # simulate the merging process\\n        for k, v in locs.items():\\n            if len(v) == 2:\\n                ind1, pos1 = v[0]\\n                ind2, pos2 = v[1]\\n                \\n                # must be a root and a non-root\\n                if pos1 != \\'root\\' and pos2 != \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\' and pos2 == \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\': # hypothrically delete ind2-node and append it to ind1                 \\n                    deleted[ind1] = True\\n                    n_nodes -= 1 \\n                    if pos2 == \\'left\\':\\n                        trees[ind2].left = trees[ind1]\\n                    else:\\n                        trees[ind2].right = trees[ind1]                                            \\n                else:                    \\n                    deleted[ind2] = True\\n                    n_nodes -= 1 \\n                    if pos1 == \\'left\\':\\n                        trees[ind1].left = trees[ind2]\\n                    else:\\n                        trees[ind1].right = trees[ind2]\\n                    \\n        # a valid trees must have one and only one root undeleted after n-1 operations\\n        if sum(deleted) != len(trees)-1: \\n            return None\\n        \\n        for i, root in enumerate(trees):\\n            if not deleted[i]:\\n                is_valid_bst, n_final_nodes = self.isValidBST(root)                \\n                if is_valid_bst and n_final_nodes == n_nodes:\\n                    return root\\n            \\n        return None\\n        \\n    def isValidBST(self, root: TreeNode):\\n        stack = []\\n        prev_val = -float(\\'inf\\')\\n        n_nodes = 0\\n        \\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            n_nodes += 1\\n            if prev_val >= root.val: \\n                return False, -1 # if it\\'s not a valis BST, num of nodes does not matter\\n            \\n            prev_val = root.val\\n            root = root.right\\n            \\n        return True, n_nodes\\n```",
                "solutionTags": [],
                "code": "```\\n {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n```\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:        \\n        locs = defaultdict(list) # {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n        deleted = [False for i in range(len(trees))] # to mark the deleted roots        \\n        n_nodes = 0 # num of nodes in the original trees\\n        \\n        # find the location of each value and its position in a tree\\n        for i, node in enumerate(trees):            \\n            locs[node.val].append((i, \\'root\\'))\\n            n_nodes += 1\\n            if node.left:\\n                locs[node.left.val].append((i, \\'left\\'))\\n                n_nodes += 1\\n            if node.right:\\n                locs[node.right.val].append((i, \\'right\\'))  \\n                n_nodes += 1\\n        \\n        # check if max freq of dups is 2\\n        freq = {k : len(v) for k,v in locs.items()}        \\n        if max(freq.values()) > 2:\\n            return None\\n        # check if number of 2-dups is n-1\\n        freq_dist = Counter(freq.values())\\n        if freq_dist[2] != len(trees)-1:\\n            return None\\n        \\n        # simulate the merging process\\n        for k, v in locs.items():\\n            if len(v) == 2:\\n                ind1, pos1 = v[0]\\n                ind2, pos2 = v[1]\\n                \\n                # must be a root and a non-root\\n                if pos1 != \\'root\\' and pos2 != \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\' and pos2 == \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\': # hypothrically delete ind2-node and append it to ind1                 \\n                    deleted[ind1] = True\\n                    n_nodes -= 1 \\n                    if pos2 == \\'left\\':\\n                        trees[ind2].left = trees[ind1]\\n                    else:\\n                        trees[ind2].right = trees[ind1]                                            \\n                else:                    \\n                    deleted[ind2] = True\\n                    n_nodes -= 1 \\n                    if pos1 == \\'left\\':\\n                        trees[ind1].left = trees[ind2]\\n                    else:\\n                        trees[ind1].right = trees[ind2]\\n                    \\n        # a valid trees must have one and only one root undeleted after n-1 operations\\n        if sum(deleted) != len(trees)-1: \\n            return None\\n        \\n        for i, root in enumerate(trees):\\n            if not deleted[i]:\\n                is_valid_bst, n_final_nodes = self.isValidBST(root)                \\n                if is_valid_bst and n_final_nodes == n_nodes:\\n                    return root\\n            \\n        return None\\n        \\n    def isValidBST(self, root: TreeNode):\\n        stack = []\\n        prev_val = -float(\\'inf\\')\\n        n_nodes = 0\\n        \\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            n_nodes += 1\\n            if prev_val >= root.val: \\n                return False, -1 # if it\\'s not a valis BST, num of nodes does not matter\\n            \\n            prev_val = root.val\\n            root = root.right\\n            \\n        return True, n_nodes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332841,
                "title": "easy-c-implementation-stimulation",
                "content": "```c++\\nclass Solution {\\npublic:\\n    //first is maximum and second is minimum\\n    pair<bool,pair<int,int>> isvalidbst(TreeNode *root){\\n        if(root==NULL){\\n            return {true,{INT_MIN,INT_MAX}};\\n        }\\n        auto left = isvalidbst(root->left);\\n        auto right = isvalidbst(root->right);\\n        \\n        //min max\\n        int maxele = max(left.second.first,max(root->val,right.second.first));\\n        int minele = min(left.second.second,min(right.second.second,root->val));\\n        \\n        //return \\n        if(left.second.first < root->val&&right.second.second > root->val)\\n            return {left.first&right.first&true,{maxele,minele}};\\n        else return {false,{maxele,minele}};\\n    }\\n    //root\\n    TreeNode *par;\\n    \\n    //Join b with a\\n    //calculate leaves\\n    unordered_map<int,int>leaf;\\n    void dfs(TreeNode *curr){\\n        if(curr==NULL) return;\\n        if(curr->left==NULL&&curr->right==NULL){\\n            leaf[curr->val]++;\\n            return;\\n        }\\n        dfs(curr->left);\\n        dfs(curr->right);\\n    }\\n    unordered_map<int,TreeNode *>m;\\n    void make(TreeNode *curr){\\n        if(curr==NULL) return;\\n        //should able to merge\\n        if(curr->left==NULL&&curr->right==NULL){\\n            if(m.find(curr->val)==m.end()) return;\\n            TreeNode *b = m[curr->val];\\n            if(b==curr) return;\\n            curr->left = b->left;\\n            curr->right = b->right;\\n            m.erase(curr->val);\\n        }\\n        make(curr->left);\\n        make(curr->right);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {    \\n        if(trees.size()==1) return trees[0];\\n        //precalculate the leaves;\\n        for(int i = 0;i<trees.size();i++){\\n            m[trees[i]->val] = trees[i];\\n            dfs(trees[i]);\\n        }\\n        par = NULL;\\n        int count = 0;\\n        //Find the root \\n        for(int i = 0;i<trees.size();i++){\\n            int curr = trees[i]->val;\\n            if(leaf.find(curr)==leaf.end()){\\n                par = trees[i];\\n                break;\\n            }\\n        }\\n        \\n        //merge from the root\\n        make(par);\\n        \\n        //return root\\n        if(m.size() > 1) return NULL;\\n        auto check = isvalidbst(par);\\n        if(check.first==false) return NULL;\\n        return par;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    //first is maximum and second is minimum\\n    pair<bool,pair<int,int>> isvalidbst(TreeNode *root){\\n        if(root==NULL){\\n            return {true,{INT_MIN,INT_MAX}};\\n        }\\n        auto left = isvalidbst(root->left);\\n        auto right = isvalidbst(root->right);\\n        \\n        //min max\\n        int maxele = max(left.second.first,max(root->val,right.second.first));\\n        int minele = min(left.second.second,min(right.second.second,root->val));\\n        \\n        //return \\n        if(left.second.first < root->val&&right.second.second > root->val)\\n            return {left.first&right.first&true,{maxele,minele}};\\n        else return {false,{maxele,minele}};\\n    }\\n    //root\\n    TreeNode *par;\\n    \\n    //Join b with a\\n    //calculate leaves\\n    unordered_map<int,int>leaf;\\n    void dfs(TreeNode *curr){\\n        if(curr==NULL) return;\\n        if(curr->left==NULL&&curr->right==NULL){\\n            leaf[curr->val]++;\\n            return;\\n        }\\n        dfs(curr->left);\\n        dfs(curr->right);\\n    }\\n    unordered_map<int,TreeNode *>m;\\n    void make(TreeNode *curr){\\n        if(curr==NULL) return;\\n        //should able to merge\\n        if(curr->left==NULL&&curr->right==NULL){\\n            if(m.find(curr->val)==m.end()) return;\\n            TreeNode *b = m[curr->val];\\n            if(b==curr) return;\\n            curr->left = b->left;\\n            curr->right = b->right;\\n            m.erase(curr->val);\\n        }\\n        make(curr->left);\\n        make(curr->right);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {    \\n        if(trees.size()==1) return trees[0];\\n        //precalculate the leaves;\\n        for(int i = 0;i<trees.size();i++){\\n            m[trees[i]->val] = trees[i];\\n            dfs(trees[i]);\\n        }\\n        par = NULL;\\n        int count = 0;\\n        //Find the root \\n        for(int i = 0;i<trees.size();i++){\\n            int curr = trees[i]->val;\\n            if(leaf.find(curr)==leaf.end()){\\n                par = trees[i];\\n                break;\\n            }\\n        }\\n        \\n        //merge from the root\\n        make(par);\\n        \\n        //return root\\n        if(m.size() > 1) return NULL;\\n        auto check = isvalidbst(par);\\n        if(check.first==false) return NULL;\\n        return par;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332725,
                "title": "c-merge-using-dictionaries",
                "content": "```csharp\\npublic TreeNode CanMerge(IList<TreeNode> trees)\\n{\\n\\tDictionary<int, TreeNode> map = new Dictionary<int, TreeNode>();\\n\\tHashSet<TreeNode> visited = new HashSet<TreeNode>();\\n\\tDictionary<TreeNode, TreeNode> parentMap = new Dictionary<TreeNode, TreeNode>();\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tmap[tree.val] = tree;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tTreeNode parent = null;\\n\\t\\tif (parentMap.ContainsKey(tree))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[tree];\\n\\t\\t}\\n\\n\\t\\t// Check for left node\\n\\t\\tif (tree.left != null && map.ContainsKey(tree.left.val) && !visited.Contains(tree.left))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.left.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.left = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Check for right node\\n\\t\\tif (tree.right != null && map.ContainsKey(tree.right.val) && !visited.Contains(tree.right))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.right.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.right = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (visited.Count != trees.Count - 1)\\n\\t{\\n\\t\\treturn null;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tif (!visited.Contains(tree))\\n\\t\\t{\\n\\t\\t\\tif (isValidBST(tree))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn tree;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn null;\\n}\\n\\nprivate bool checkCycle(Dictionary<TreeNode, TreeNode> parentMap, TreeNode parent, TreeNode currentRoot)\\n{\\n\\tbool hasCycle = false;\\n\\n\\twhile (parent != null)\\n\\t{\\n\\t\\tif (parent == currentRoot)\\n\\t\\t{\\n\\t\\t\\thasCycle = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tif (parentMap.ContainsKey(parent))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[parent];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tparent = null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn hasCycle;\\n}\\n\\nprivate bool isValidBST(TreeNode root)\\n{\\n\\treturn Validate(root, long.MinValue, long.MaxValue);\\n}\\n\\nprivate bool Validate(TreeNode root, long min, long max)\\n{\\n\\tif (root == null)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif (root.val <= min || root.val >= max)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn Validate(root.left, min, root.val) && Validate(root.right, root.val, max);\\n} \\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic TreeNode CanMerge(IList<TreeNode> trees)\\n{\\n\\tDictionary<int, TreeNode> map = new Dictionary<int, TreeNode>();\\n\\tHashSet<TreeNode> visited = new HashSet<TreeNode>();\\n\\tDictionary<TreeNode, TreeNode> parentMap = new Dictionary<TreeNode, TreeNode>();\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tmap[tree.val] = tree;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tTreeNode parent = null;\\n\\t\\tif (parentMap.ContainsKey(tree))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[tree];\\n\\t\\t}\\n\\n\\t\\t// Check for left node\\n\\t\\tif (tree.left != null && map.ContainsKey(tree.left.val) && !visited.Contains(tree.left))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.left.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.left = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Check for right node\\n\\t\\tif (tree.right != null && map.ContainsKey(tree.right.val) && !visited.Contains(tree.right))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.right.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.right = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (visited.Count != trees.Count - 1)\\n\\t{\\n\\t\\treturn null;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tif (!visited.Contains(tree))\\n\\t\\t{\\n\\t\\t\\tif (isValidBST(tree))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn tree;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn null;\\n}\\n\\nprivate bool checkCycle(Dictionary<TreeNode, TreeNode> parentMap, TreeNode parent, TreeNode currentRoot)\\n{\\n\\tbool hasCycle = false;\\n\\n\\twhile (parent != null)\\n\\t{\\n\\t\\tif (parent == currentRoot)\\n\\t\\t{\\n\\t\\t\\thasCycle = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tif (parentMap.ContainsKey(parent))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[parent];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tparent = null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn hasCycle;\\n}\\n\\nprivate bool isValidBST(TreeNode root)\\n{\\n\\treturn Validate(root, long.MinValue, long.MaxValue);\\n}\\n\\nprivate bool Validate(TreeNode root, long min, long max)\\n{\\n\\tif (root == null)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif (root.val <= min || root.val >= max)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn Validate(root.left, min, root.val) && Validate(root.right, root.val, max);\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332564,
                "title": "javascript-dfs-adding-trees-on-the-go",
                "content": "**Idea**\\nBuild the tree from the top down.\\n**Issues**\\nThere are a couple edge cases that need to be considered. Namely, problems arise when:\\n* There are cycles, for example   [2,null,3] , [3,2,null]\\n* Some mini trees are not used at all\\n* The resulting tree is not a BST\\n\\n**Implementation**\\nOne dfs will determine the indegrees of each node and will place pointers in each node to their parent, such that replacing can be easy, even when currently at the node itself. The node with the indegree===0, is the main root, from which a second dfs will form the resulting tree. Finally, after each edge case has been dealt with, the root node will be returned.\\n\\n```\\nvar canMerge = function(trees) {\\n    let Node={},indeg={}\\n    // traverse the mini trees and put back pointers to their parents, also figure out the indegree of each node\\n    let dfs=(node,leftparent=null,rightparent=null)=>{\\n        if(!node)return\\n        indeg[node.val]=indeg[node.val]||Number(leftparent!==null||rightparent!==null)\\n        node.lp=leftparent,node.rp=rightparent\\n        dfs(node.left,node,null),dfs(node.right,null,node)\\n    }\\n    for(let root of trees)\\n        Node[root.val]=root,\\n        dfs(root)\\n    //there are a lot of potential roots=> no bueno\\n    if(Object.values(indeg).reduce((a,b)=>a+b)!=Object.keys(indeg).length-1)\\n        return null\\n    //find THE root\\n    let bigRoot,timesMerged=0\\n    for(let root of trees)\\n        if(indeg[root.val]===0)\\n            bigRoot=root\\n    // traverse the tree while replacing each leaf that can be replaced\\n    let rec=(node=bigRoot)=>{\\n        if(!node)\\n            return\\n        if(!node.left&&!node.right){\\n            let toadd=Node[node.val]\\n            Node[node.val]=undefined //invalidating the trees you already used\\n            if(toadd===undefined)\\n                return\\n            //make the change\\n            if(node.lp===null&&node.rp===null)\\n                return\\n            else if(node.lp!==null)\\n                node.lp.left=toadd\\n            else\\n                node.rp.right=toadd\\n            timesMerged++\\n            rec(toadd)\\n        }\\n        else\\n            rec(node.left),rec(node.right)\\n    }\\n    rec()\\n    var isValidBST = function(node,l=-Infinity,r=Infinity) { //l and r are the limits node.val should be within\\n        if(!node)\\n            return true\\n        if(node.val<l || node.val >r)\\n            return false\\n        return isValidBST(node.left,l,node.val-1)&&isValidBST(node.right,node.val+1,r)\\n    };\\n    //check if every item was used and if the result bst is valid \\n    return !isValidBST(bigRoot)||timesMerged!==trees.length-1?null:bigRoot\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nvar canMerge = function(trees) {\\n    let Node={},indeg={}\\n    // traverse the mini trees and put back pointers to their parents, also figure out the indegree of each node\\n    let dfs=(node,leftparent=null,rightparent=null)=>{\\n        if(!node)return\\n        indeg[node.val]=indeg[node.val]||Number(leftparent!==null||rightparent!==null)\\n        node.lp=leftparent,node.rp=rightparent\\n        dfs(node.left,node,null),dfs(node.right,null,node)\\n    }\\n    for(let root of trees)\\n        Node[root.val]=root,\\n        dfs(root)\\n    //there are a lot of potential roots=> no bueno\\n    if(Object.values(indeg).reduce((a,b)=>a+b)!=Object.keys(indeg).length-1)\\n        return null\\n    //find THE root\\n    let bigRoot,timesMerged=0\\n    for(let root of trees)\\n        if(indeg[root.val]===0)\\n            bigRoot=root\\n    // traverse the tree while replacing each leaf that can be replaced\\n    let rec=(node=bigRoot)=>{\\n        if(!node)\\n            return\\n        if(!node.left&&!node.right){\\n            let toadd=Node[node.val]\\n            Node[node.val]=undefined //invalidating the trees you already used\\n            if(toadd===undefined)\\n                return\\n            //make the change\\n            if(node.lp===null&&node.rp===null)\\n                return\\n            else if(node.lp!==null)\\n                node.lp.left=toadd\\n            else\\n                node.rp.right=toadd\\n            timesMerged++\\n            rec(toadd)\\n        }\\n        else\\n            rec(node.left),rec(node.right)\\n    }\\n    rec()\\n    var isValidBST = function(node,l=-Infinity,r=Infinity) { //l and r are the limits node.val should be within\\n        if(!node)\\n            return true\\n        if(node.val<l || node.val >r)\\n            return false\\n        return isValidBST(node.left,l,node.val-1)&&isValidBST(node.right,node.val+1,r)\\n    };\\n    //check if every item was used and if the result bst is valid \\n    return !isValidBST(bigRoot)||timesMerged!==trees.length-1?null:bigRoot\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331418,
                "title": "python-3-bfs-updating-lower-and-upper-bound-2844-ms",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        root = {}\\n        leaves = set()\\n        start = set()\\n        for tree in trees:\\n            if tree.left:\\n                leaves.add(tree.left.val)\\n            if tree.right:\\n                leaves.add(tree.right.val)\\n            root[tree.val] = tree\\n            start.add(tree.val)\\n        \\n        start = start.difference(leaves)\\n        \\n        if len(start) != 1: return None\\n        res = root[list(start)[0]]\\n        \\n        cnt = 1\\n        n = len(trees)\\n        q = deque([(res, float(\\'-inf\\'), float(\\'inf\\'))])\\n        \\n        while q and cnt < n:\\n            node, low, high = q.popleft()\\n            if node.left and node.left.val in root:\\n                h = min(high, node.val)\\n                tmp = root[node.left.val]\\n                if (not tmp.right or tmp.right.val < h) and (not tmp.left or tmp.left.val > low):\\n                    node.left = tmp\\n                    q.append((node.left, low, h))\\n                    cnt += 1\\n            if node.right and node.right.val in root:\\n                l = max(low, node.val)\\n                tmp = root[node.right.val]\\n                if (not tmp.right or tmp.right.val < h) and (not tmp.left or tmp.left.val > low):\\n                    node.right = tmp\\n                    q.append((node.right, l, high))\\n                    cnt += 1\\n        \\n        return res if cnt == n else None",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Binary Search Tree"
                ],
                "code": "class Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        root = {}",
                "codeTag": "Java"
            },
            {
                "id": 1330973,
                "title": "java-solution-using-hashmap-readable-code",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        //Map root value to tree\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode t : trees){\\n            map.put(t.val, t);\\n        }\\n        \\n        // Merge trees\\n        for(TreeNode t : trees){\\n            if(map.containsKey(t.val)){\\n                merger(t, map);\\n            }\\n        }\\n\\n        \\n        //After merging we should have only one tree left else return null\\n        if(map.size() != 1) return null;\\n        else {\\n            //Return the one tree left after merging\\n            for(int c : map.keySet()) {\\n                //Check if final tree is valid else return null\\n                if(isValidBST(map.get(c))){\\n                    return map.get(c);\\n                } else return null;\\n            }\\n        }\\n        \\n      return null;\\n        \\n        \\n    }\\n    \\n    void merger(TreeNode t, HashMap<Integer, TreeNode> map){\\n        map.remove(t.val); // Remove current tree to prevent cyclical merging For. 2->3(Right) and 3->2(Left)\\n        //Merge on left\\n        if(t.left != null && map.containsKey(t.left.val) ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.left.val), map);\\n            t.left = map.get(t.left.val);\\n            map.remove(t.left.val);\\n        }\\n        \\n        // Merge on right\\n        if(t.right!=null &&  map.containsKey(t.right.val)  ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.right.val), map);\\n            t.right = map.get(t.right.val);\\n            map.remove(t.right.val);\\n        }\\n        // Add tree back to map once right and left merge is complete\\n        map.put(t.val, t);\\n    }\\n    \\n    // Validate BST\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    public boolean helper(TreeNode root, long min, long max){\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        //Map root value to tree\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode t : trees){\\n            map.put(t.val, t);\\n        }\\n        \\n        // Merge trees\\n        for(TreeNode t : trees){\\n            if(map.containsKey(t.val)){\\n                merger(t, map);\\n            }\\n        }\\n\\n        \\n        //After merging we should have only one tree left else return null\\n        if(map.size() != 1) return null;\\n        else {\\n            //Return the one tree left after merging\\n            for(int c : map.keySet()) {\\n                //Check if final tree is valid else return null\\n                if(isValidBST(map.get(c))){\\n                    return map.get(c);\\n                } else return null;\\n            }\\n        }\\n        \\n      return null;\\n        \\n        \\n    }\\n    \\n    void merger(TreeNode t, HashMap<Integer, TreeNode> map){\\n        map.remove(t.val); // Remove current tree to prevent cyclical merging For. 2->3(Right) and 3->2(Left)\\n        //Merge on left\\n        if(t.left != null && map.containsKey(t.left.val) ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.left.val), map);\\n            t.left = map.get(t.left.val);\\n            map.remove(t.left.val);\\n        }\\n        \\n        // Merge on right\\n        if(t.right!=null &&  map.containsKey(t.right.val)  ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.right.val), map);\\n            t.right = map.get(t.right.val);\\n            map.remove(t.right.val);\\n        }\\n        // Add tree back to map once right and left merge is complete\\n        map.put(t.val, t);\\n    }\\n    \\n    // Validate BST\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    public boolean helper(TreeNode root, long min, long max){\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330285,
                "title": "beginner-friendly-c-solution-using-two-hash-maps-explained-commented",
                "content": "This may not be an optimal solution. But a solution easy to understand. \\n* Store the leaf nodes of all  the trees in a map with its parent Node address\\n* when we find current tree node value in the map we need to merge\\n* if we dont find the current node value in map then it is the node  which we should return \\n* when we merge a current tree x to another tree y then we check - \\n* if x is left child of y and maximum node value in the x is >=  y root node value then return NULL , else merge them and change the y minimum node value to x minimum node value\\n* if x is right child of y and the minimum node value in x is <= y root node value then return NULL, else merge them and change the y maximum node value to x  maximum value\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081370,
                "title": "map-tree-conditions-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA binary search tree that is valid is a graph of contracts of node relations. As such, we can use graphs and sets of tree node relations and utilize them to determine validity. Validity needs to agree on a node level, and as a whole tree, and so we use a map for trees and a map for leaves, along with a set for each as well. This then lets us uniquely determine the valid binary search tree, for which there must be only one organization for the result based on the problem description. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake a set of leaf values, tree values, a map of trees, a max tree and min tree value variable as needed for the problem, a min prob value and max prob value as needed for the problem. \\n\\nLoop such that \\n- For tree in trees \\n    - map tree value to tree in tree map \\n    - add tree value to tree values set \\n    - for each of the tree children \\n        - if leaf add to the leaves the child values \\n    - update max tree, min tree as needed related to tree.val \\n\\nBuild a root set as the difference of tree values set and leaves value set \\nSet root as \\n- None if len of root set is != 1 (non-unique valid bst) \\n- tree_map at root_set.pop() if len of root set is 1 \\n\\nValid conditions checked as follows \\n- If root is None\\n    - return None  \\n- elif root.left and root.right is None \\n    - return root if length of trees is 1 else None \\n- elif root.left and not root.right and root.val is not max_tree \\n    - return None    \\n- elif root.right and not root.left and root.val is not min_tree \\n    - return None \\n\\nIf root is None, no tree. If both left and right are None, no tree unless only one tree. If left and not right or right and not left and the root value is not the max or min tree respectively -> also none \\n\\nConsider child states as (low value limit, high value limit, parent node, side of placement of parent node). This then lets you understand each child state in relation to parent state, and allows for handedness. A left child will always use a parent value as the high limit, and a right child will always use the parent value as the low limit. \\n\\nIn all other cases, we now need to traverse \\n- Make a leaf map, set left to 0 and right to 1 \\n- If root.left add to leaf map at root.left.val the tree state of (min_prob, root.val, root, left) \\n- If root.right, add to leaf map at root.right.val the tree state of (root.val, max_prob, root, right) \\n- delete tree map at root value \\n- While you have a tree map \\n    - set tree exists to False \\n    - loop for leaf and leaf (child) state in leaf map items \\n        - if leaf in tree map  \\n            - set new_tree to tree_map at leaf \\n            - delete leaf_map at leaf \\n            - Each of the new_tree\\'s children must satisfy that they are in bounds of the leaf state (low < children value < high) and children value not in leaf map \\n            - For each child, if not satisfactory, return None. Otherwise, set leaf map at child value to appropriate leaf state\\n            - based on sidedness of child state, set parent on side to new tree \\n            - mark tree exists as True if a leaf was satisfied \\n            - delete tree map at new tree value \\n            - break out of loop \\n        - if leaf not in tree map, continue until leaf in tree map \\n    - if tree exists is False return None as no leaf was satisfied \\n- if loop completes, return root             \\n\\n# Complexity\\n- Time complexity : O(T) \\n    - O(T) loop trees at start \\n    - O(T) build root set \\n    - validity check in O(1) lets lower bound at O(2T) \\n    - O(T) loop tree map \\n        - O(L) leaf map items (at most 2 or 3 items each loop) \\n            - early check available inside \\n        - early check available oustide L loop\\n    - Total value is O(cT) where c is a constant -> O(T) \\n\\n- Space complexity : O(L + T) \\n    - Leaf set of size L \\n    - Tree values of size L \\n    - Tree map of size T -> T \\n    - Leaf map of size L -> LS (held at constant size by deletes / adds) \\n    - Total size is L + T \\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        # build set of leaves and map of trees \\n        # note that all tree roots are unique, but not necessarily leaves\\n        # find min and max tree for easier short circuits later \\n        leaves = set() \\n        tree_map = dict() \\n        tree_vals = set()\\n        max_tree = 0 \\n        min_tree = 10**5\\n        max_prob = 100000\\n        min_prob = 0 \\n        for tree in trees : \\n            # map each tree val uniquely \\n            tree_map[tree.val] = tree \\n            # add each to the tree val set \\n            tree_vals.add(tree.val)\\n            # then based on presence of leaves, add uniques as needed \\n            if tree.left : \\n                leaves.add(tree.left.val)\\n            if tree.right : \\n                leaves.add(tree.right.val) \\n            # and update maxima and minima of tree values \\n            max_tree, min_tree = max(max_tree, tree.val), min(min_tree, tree.val)\\n        \\n        # build root set from difference of tree vals with leaves \\n        root_set = tree_vals.difference(leaves)\\n        root = None if len(root_set) != 1 else tree_map[root_set.pop()]\\n            \\n        # if none are valid though, no trees are possible \\n        # invalid set ups are root is None or root is isolated and not solitary \\n        # else if isolated and solitary return root, otherwise return None \\n        # else if one side isolated and not matching maxima -> return None \\n        # otherwise, traverse tree for resolution \\n        if root is None : \\n            return None \\n        elif root.left is None and root.right is None : \\n            return root if len(trees) == 1 else None \\n        elif root.left and not root.right and root.val != max_tree : \\n            return None \\n        elif root.right and not root.left and root.val != min_tree : \\n            return None \\n        else : \\n            # make a map of leaves to nodes of leaf states \\n            # leaf states include low value, high value, parent value and handed-ness \\n            # assume left handed as 0 and right handed as 1 \\n            leaf_map = dict() \\n            # set variables for references minimizing overhead \\n            left = 0 \\n            right = 1 \\n            # if root has a left and right, we can utilize it in the leaf map \\n            # check left and right and record as needed \\n            if root.left : \\n                leaf_map[root.left.val] = (min_prob, root.val, root, left)\\n            if root.right : \\n                leaf_map[root.right.val] = (root.val, max_prob, root, right) \\n          \\n            # since root is now pinned, remove from map \\n            del tree_map[root.val]\\n    \\n            # while you have a tree map \\n            while tree_map : \\n                # determine if a tree exists succesfully for the selected item\\n                tree_exists = False \\n                # for leaf key, leaf state in leaf map items \\n                for leaf, (low, high, parent, side) in leaf_map.items() : \\n                    # if leaf in tree map \\n                    if leaf in tree_map : \\n                        # make a new tree based off of tree map via leaf value and update leaf map\\n                        new_tree = tree_map[leaf] \\n                        del leaf_map[leaf]\\n\\n                        # satisfy left and right in bounds of low and high of leaf state \\n                        # on failure to satisfy all, none satisfy, so may return None \\n                        if new_tree.left : \\n                            if low < new_tree.left.val < high and new_tree.left.val not in leaf_map : \\n                                leaf_map[new_tree.left.val] = (low, new_tree.val, new_tree, left)\\n                            else : \\n                                return None \\n\\n                        if new_tree.right : \\n                            if low < new_tree.right.val < high and new_tree.right.val not in leaf_map : \\n                                leaf_map[new_tree.right.val] = (new_tree.val, high, new_tree, right)\\n                            else : \\n                                return None \\n                    \\n                        # if side is left, place on left; otherwise place on right \\n                        if side == left : \\n                            parent.left = new_tree \\n                        else : \\n                            parent.right = new_tree\\n                    \\n                        # if a leaf was satisfied, mark as tree exists \\n                        # this may be superseded by failure of any future leaves still \\n                        tree_exists = True \\n                        # remove the value as needed from the tree map \\n                        del tree_map[new_tree.val]\\n                        # once one satisfaction is found, break for loop \\n                        break \\n                    else : \\n                        continue \\n                # at end of while loop before next iteration, if no leaves satisfied, return None \\n                if tree_exists == False : \\n                    return None \\n            # if all leaves satisfied, and all trees satisfied, tree constructed \\n            return root \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        # build set of leaves and map of trees \\n        # note that all tree roots are unique, but not necessarily leaves\\n        # find min and max tree for easier short circuits later \\n        leaves = set() \\n        tree_map = dict() \\n        tree_vals = set()\\n        max_tree = 0 \\n        min_tree = 10**5\\n        max_prob = 100000\\n        min_prob = 0 \\n        for tree in trees : \\n            # map each tree val uniquely \\n            tree_map[tree.val] = tree \\n            # add each to the tree val set \\n            tree_vals.add(tree.val)\\n            # then based on presence of leaves, add uniques as needed \\n            if tree.left : \\n                leaves.add(tree.left.val)\\n            if tree.right : \\n                leaves.add(tree.right.val) \\n            # and update maxima and minima of tree values \\n            max_tree, min_tree = max(max_tree, tree.val), min(min_tree, tree.val)\\n        \\n        # build root set from difference of tree vals with leaves \\n        root_set = tree_vals.difference(leaves)\\n        root = None if len(root_set) != 1 else tree_map[root_set.pop()]\\n            \\n        # if none are valid though, no trees are possible \\n        # invalid set ups are root is None or root is isolated and not solitary \\n        # else if isolated and solitary return root, otherwise return None \\n        # else if one side isolated and not matching maxima -> return None \\n        # otherwise, traverse tree for resolution \\n        if root is None : \\n            return None \\n        elif root.left is None and root.right is None : \\n            return root if len(trees) == 1 else None \\n        elif root.left and not root.right and root.val != max_tree : \\n            return None \\n        elif root.right and not root.left and root.val != min_tree : \\n            return None \\n        else : \\n            # make a map of leaves to nodes of leaf states \\n            # leaf states include low value, high value, parent value and handed-ness \\n            # assume left handed as 0 and right handed as 1 \\n            leaf_map = dict() \\n            # set variables for references minimizing overhead \\n            left = 0 \\n            right = 1 \\n            # if root has a left and right, we can utilize it in the leaf map \\n            # check left and right and record as needed \\n            if root.left : \\n                leaf_map[root.left.val] = (min_prob, root.val, root, left)\\n            if root.right : \\n                leaf_map[root.right.val] = (root.val, max_prob, root, right) \\n          \\n            # since root is now pinned, remove from map \\n            del tree_map[root.val]\\n    \\n            # while you have a tree map \\n            while tree_map : \\n                # determine if a tree exists succesfully for the selected item\\n                tree_exists = False \\n                # for leaf key, leaf state in leaf map items \\n                for leaf, (low, high, parent, side) in leaf_map.items() : \\n                    # if leaf in tree map \\n                    if leaf in tree_map : \\n                        # make a new tree based off of tree map via leaf value and update leaf map\\n                        new_tree = tree_map[leaf] \\n                        del leaf_map[leaf]\\n\\n                        # satisfy left and right in bounds of low and high of leaf state \\n                        # on failure to satisfy all, none satisfy, so may return None \\n                        if new_tree.left : \\n                            if low < new_tree.left.val < high and new_tree.left.val not in leaf_map : \\n                                leaf_map[new_tree.left.val] = (low, new_tree.val, new_tree, left)\\n                            else : \\n                                return None \\n\\n                        if new_tree.right : \\n                            if low < new_tree.right.val < high and new_tree.right.val not in leaf_map : \\n                                leaf_map[new_tree.right.val] = (new_tree.val, high, new_tree, right)\\n                            else : \\n                                return None \\n                    \\n                        # if side is left, place on left; otherwise place on right \\n                        if side == left : \\n                            parent.left = new_tree \\n                        else : \\n                            parent.right = new_tree\\n                    \\n                        # if a leaf was satisfied, mark as tree exists \\n                        # this may be superseded by failure of any future leaves still \\n                        tree_exists = True \\n                        # remove the value as needed from the tree map \\n                        del tree_map[new_tree.val]\\n                        # once one satisfaction is found, break for loop \\n                        break \\n                    else : \\n                        continue \\n                # at end of while loop before next iteration, if no leaves satisfied, return None \\n                if tree_exists == False : \\n                    return None \\n            # if all leaves satisfied, and all trees satisfied, tree constructed \\n            return root \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050610,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> valToNode;  // {val: node}\\n    unordered_map<int, int> count;            // {val: freq}\\n\\n    for (TreeNode* tree : trees) {\\n      valToNode[tree->val] = tree;\\n      ++count[tree->val];\\n      if (tree->left)\\n        ++count[tree->left->val];\\n      if (tree->right)\\n        ++count[tree->right->val];\\n    }\\n\\n    for (TreeNode* tree : trees)\\n      if (count[tree->val] == 1) {\\n        if (isValidBST(tree, nullptr, nullptr, valToNode) &&\\n            valToNode.size() <= 1)\\n          return tree;\\n        return nullptr;\\n      }\\n\\n    return nullptr;\\n  }\\n\\n private:\\n  bool isValidBST(TreeNode* tree, TreeNode* minNode, TreeNode* maxNode,\\n                  unordered_map<int, TreeNode*>& valToNode) {\\n    if (tree == nullptr)\\n      return true;\\n    if (minNode && tree->val <= minNode->val)\\n      return false;\\n    if (maxNode && tree->val >= maxNode->val)\\n      return false;\\n    if (!tree->left && !tree->right && valToNode.count(tree->val)) {\\n      const int val = tree->val;\\n      tree->left = valToNode[val]->left;\\n      tree->right = valToNode[val]->right;\\n      valToNode.erase(val);\\n    }\\n\\n    return isValidBST(tree->left, minNode, tree, valToNode) &&\\n           isValidBST(tree->right, tree, maxNode, valToNode);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> valToNode;  // {val: node}\\n    unordered_map<int, int> count;            // {val: freq}\\n\\n    for (TreeNode* tree : trees) {\\n      valToNode[tree->val] = tree;\\n      ++count[tree->val];\\n      if (tree->left)\\n        ++count[tree->left->val];\\n      if (tree->right)\\n        ++count[tree->right->val];\\n    }\\n\\n    for (TreeNode* tree : trees)\\n      if (count[tree->val] == 1) {\\n        if (isValidBST(tree, nullptr, nullptr, valToNode) &&\\n            valToNode.size() <= 1)\\n          return tree;\\n        return nullptr;\\n      }\\n\\n    return nullptr;\\n  }\\n\\n private:\\n  bool isValidBST(TreeNode* tree, TreeNode* minNode, TreeNode* maxNode,\\n                  unordered_map<int, TreeNode*>& valToNode) {\\n    if (tree == nullptr)\\n      return true;\\n    if (minNode && tree->val <= minNode->val)\\n      return false;\\n    if (maxNode && tree->val >= maxNode->val)\\n      return false;\\n    if (!tree->left && !tree->right && valToNode.count(tree->val)) {\\n      const int val = tree->val;\\n      tree->left = valToNode[val]->left;\\n      tree->right = valToNode[val]->right;\\n      valToNode.erase(val);\\n    }\\n\\n    return isValidBST(tree->left, minNode, tree, valToNode) &&\\n           isValidBST(tree->right, tree, maxNode, valToNode);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027705,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  bool checkValidBst(TreeNode* root, int mini,int maxi)\\n  {\\n      if (root==NULL) return true;\\n      if (root->val<=mini || root->val>=maxi) return false;\\n      return checkValidBst(root->left,mini,root->val) && checkValidBst(root->right,root->val,maxi);\\n  }\\n    TreeNode* helper(TreeNode* root, map<int,TreeNode*>&mp)\\n    {\\n        if (root==NULL) return NULL;\\n        if (mp.find(root->val)!=mp.end())\\n        {\\n            TreeNode* tree=mp[root->val];\\n            root->left=tree->left;\\n            root->right=tree->right;\\n            mp.erase(root->val);\\n        }\\n        if (root->left)\\n        root->left=helper(root->left,mp);\\n        if (root->right)\\n        root->right=helper(root->right,mp);\\n        return root;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        if (trees.size()==1) return trees[0];\\n        set<int>leaves;\\n        for (auto it:trees)\\n        {\\n            if (it->left) leaves.insert(it->left->val);\\n            if (it->right) leaves.insert(it->right->val);\\n        }\\n        TreeNode* root=NULL;\\n        for (auto it: trees)\\n        {\\n            if (leaves.find(it->val)==leaves.end())\\n            {\\n                root=it;\\n            }\\n        }\\n        if (root==NULL) return NULL;\\n        set<TreeNode*>rem;\\n        for (auto it: trees)\\n        {\\n            if (it->val!=root->val) rem.insert(it);\\n        }\\n        map<int,TreeNode*>mp;\\n        for (auto it: rem)\\n        {\\n            mp[it->val]=it;\\n        }\\n        TreeNode* ans=helper(root,mp);\\n\\n        if (checkValidBst(root,INT_MIN,INT_MAX) && mp.size()==0 ) return root;\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  bool checkValidBst(TreeNode* root, int mini,int maxi)\\n  {\\n      if (root==NULL) return true;\\n      if (root->val<=mini || root->val>=maxi) return false;\\n      return checkValidBst(root->left,mini,root->val) && checkValidBst(root->right,root->val,maxi);\\n  }\\n    TreeNode* helper(TreeNode* root, map<int,TreeNode*>&mp)\\n    {\\n        if (root==NULL) return NULL;\\n        if (mp.find(root->val)!=mp.end())\\n        {\\n            TreeNode* tree=mp[root->val];\\n            root->left=tree->left;\\n            root->right=tree->right;\\n            mp.erase(root->val);\\n        }\\n        if (root->left)\\n        root->left=helper(root->left,mp);\\n        if (root->right)\\n        root->right=helper(root->right,mp);\\n        return root;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        if (trees.size()==1) return trees[0];\\n        set<int>leaves;\\n        for (auto it:trees)\\n        {\\n            if (it->left) leaves.insert(it->left->val);\\n            if (it->right) leaves.insert(it->right->val);\\n        }\\n        TreeNode* root=NULL;\\n        for (auto it: trees)\\n        {\\n            if (leaves.find(it->val)==leaves.end())\\n            {\\n                root=it;\\n            }\\n        }\\n        if (root==NULL) return NULL;\\n        set<TreeNode*>rem;\\n        for (auto it: trees)\\n        {\\n            if (it->val!=root->val) rem.insert(it);\\n        }\\n        map<int,TreeNode*>mp;\\n        for (auto it: rem)\\n        {\\n            mp[it->val]=it;\\n        }\\n        TreeNode* ans=helper(root,mp);\\n\\n        if (checkValidBst(root,INT_MIN,INT_MAX) && mp.size()==0 ) return root;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009835,
                "title": "simple-easy-well-explained",
                "content": "Yess it\\'s just all about heavy and careful implimentation\\nfirst we need to mark all child and parent  here as we will mark parent by value of left and right child iff exists\\nso we will have a map\\n```\\nmap<int , TreeNode*> par  // child_values => parent\\n```\\nand for binary tree we need to have range of values each node covers \\n```\\nmap<TreeNode* ,pair<int,int>> range\\n```\\nand now just begin\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    #define f first\\n    #define s second\\n     bool check(TreeNode* root,int minl,int maxr)  // check valid tree\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n   \\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        map<int, TreeNode* > par;\\n        map<TreeNode* , pair<int,int>> range;\\n        for(auto i: trees) // mark parents and range for each root node\\n        {\\n            if(i->left) \\n            {\\n                par[i->left->val]=i;\\n                range[i].f = i->left->val;\\n            }else range[i].f=i->val;\\n            if(i->right)\\n            {\\n                par[i->right->val]=i;\\n                range[i].s = i->right->val;\\n            }else range[i].s=i->val;\\n        }\\n        \\n        TreeNode* root=NULL;\\n        int count=0;\\n        int n= trees.size();\\n        for(auto i: trees)\\n        {\\n            if(par.find(i->val)!=par.end())\\n            {\\n                if(i->val<par[i->val]->val)//left;\\n                {\\n                    if(range[i].s<par[i->val]->val)  // if  it\\'s range values are smaller than root\\n                    {\\n                        par[i->val]->left=i;\\n                        range[par[i->val]].f=range[i].f;// update the minimum value of range after adding the left child\\n                            count++;\\n                    }else return NULL; // else it\\'s not fit => so no use=> no solution \\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// do same thing for right child\\n                }else if(i->val>par[i->val]->val)//right;  \\n                {\\n                    if(range[i].s>par[i->val]->val)\\n                    {\\n                        par[i->val]->right=i;\\n                        range[par[i->val]].s=range[i].s;\\n                            count++;\\n                    }else return NULL;\\n                }\\n            }else\\n            {\\n                if(root==NULL) // only one root is possible if we encounter multiple so no solution\\n                {\\n                    root=i;\\n                    \\n                }else return NULL;\\n            }\\n        \\n        }\\n        if(check(root, INT_MIN, INT_MAX)==false) return NULL;  // juct check for surity so that it\\'s valid tree  of unique values\\n        return count==n-1? root: NULL;  // check that we merged n-1  time \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nmap<int , TreeNode*> par  // child_values => parent\\n```\n```\\nmap<TreeNode* ,pair<int,int>> range\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    #define f first\\n    #define s second\\n     bool check(TreeNode* root,int minl,int maxr)  // check valid tree\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n   \\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        map<int, TreeNode* > par;\\n        map<TreeNode* , pair<int,int>> range;\\n        for(auto i: trees) // mark parents and range for each root node\\n        {\\n            if(i->left) \\n            {\\n                par[i->left->val]=i;\\n                range[i].f = i->left->val;\\n            }else range[i].f=i->val;\\n            if(i->right)\\n            {\\n                par[i->right->val]=i;\\n                range[i].s = i->right->val;\\n            }else range[i].s=i->val;\\n        }\\n        \\n        TreeNode* root=NULL;\\n        int count=0;\\n        int n= trees.size();\\n        for(auto i: trees)\\n        {\\n            if(par.find(i->val)!=par.end())\\n            {\\n                if(i->val<par[i->val]->val)//left;\\n                {\\n                    if(range[i].s<par[i->val]->val)  // if  it\\'s range values are smaller than root\\n                    {\\n                        par[i->val]->left=i;\\n                        range[par[i->val]].f=range[i].f;// update the minimum value of range after adding the left child\\n                            count++;\\n                    }else return NULL; // else it\\'s not fit => so no use=> no solution \\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// do same thing for right child\\n                }else if(i->val>par[i->val]->val)//right;  \\n                {\\n                    if(range[i].s>par[i->val]->val)\\n                    {\\n                        par[i->val]->right=i;\\n                        range[par[i->val]].s=range[i].s;\\n                            count++;\\n                    }else return NULL;\\n                }\\n            }else\\n            {\\n                if(root==NULL) // only one root is possible if we encounter multiple so no solution\\n                {\\n                    root=i;\\n                    \\n                }else return NULL;\\n            }\\n        \\n        }\\n        if(check(root, INT_MIN, INT_MAX)==false) return NULL;  // juct check for surity so that it\\'s valid tree  of unique values\\n        return count==n-1? root: NULL;  // check that we merged n-1  time \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958516,
                "title": "well-commented",
                "content": "\\n# Code\\n```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917823,
                "title": "structured-code",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\n    void calc_min_max(vector<TreeNode*>& trees,vector<pair<int,int>>&min_max){\\n        for(int i=0;i<trees.size();i++){\\n            TreeNode* leftd=trees[i];\\n            TreeNode* rightd=trees[i];\\n            int currmin=INT_MAX,currmax=INT_MIN;\\n            while(leftd!=NULL){\\n                currmin=min(currmin,leftd->val);\\n                leftd=leftd->left;\\n            }\\n            while(rightd!=NULL){\\n                currmax=max(currmax,rightd->val);\\n                rightd=rightd->right;\\n            }\\n            min_max.push_back({currmin,currmax});\\n        }\\n    }\\n\\n    void calc_head_bst(vector<TreeNode*>&trees,int &head_ind,map<int,int>&tree_index){\\n        int sum=0;\\n        unordered_set<int>values;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]==NULL)continue;\\n            sum+=i;\\n            queue<TreeNode*>q;\\n            q.push(trees[i]);\\n            while(!q.empty()){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(trees[i]!=curr){\\n                    if(values.count(curr->val)!=0){\\n                        head_ind=-1;\\n                        return;\\n                    }\\n                    values.insert(curr->val);\\n                }\\n                if(curr->left==NULL&&curr->right==NULL&&curr!=trees[i]&&tree_index.count(curr->val)!=0){\\n                    sum-=tree_index[curr->val];\\n                }\\n                if(curr->left!=NULL)q.push(curr->left);\\n                if(curr->right!=NULL)q.push(curr->right);\\n            }\\n        }\\n        head_ind=sum;\\n    }\\n    \\n    TreeNode* buildTree(vector<TreeNode*>&trees,vector<pair<int,int>>&min_max,map<int,int>&tree_index,int &head){\\n        int n=trees.size();\\n        vector<int>vis(n,0);\\n        vis[head]=1;\\n        queue<pair<TreeNode*,pair<int,int>>>qpp;\\n        qpp.push({trees[head],{INT_MIN,INT_MAX}});\\n        \\n        while(!qpp.empty()){\\n            TreeNode* curr=qpp.front().first;\\n            int minReq=qpp.front().second.first;\\n            int maxLim=qpp.front().second.second;\\n            qpp.pop();\\n            \\n            if(curr->left==NULL&&curr->right==NULL){\\n                int curr_val=curr->val;\\n                if(tree_index.count(curr_val)!=0){\\n                    int index=tree_index[curr_val];\\n                    if(vis[index]==1&&index!=head){\\n                        return NULL;\\n                    }\\n                    vis[index]=1;\\n                    if(min_max[index].first<=minReq||min_max[index].second>=maxLim){\\n                        return NULL;\\n                    }\\n                    \\n                    curr->left=trees[index]->left;\\n                    curr->right=trees[index]->right;\\n                }\\n            }\\n            if(curr->left!=NULL){\\n                qpp.push({curr->left,{minReq,curr->val}});\\n            }\\n            if(curr->right!=NULL){\\n                qpp.push({curr->right,{curr->val,maxLim}});\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(i!=head&&!vis[i]){\\n                return NULL;\\n            }\\n        }\\n        return trees[head];\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>tree_index;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=NULL){\\n                tree_index[trees[i]->val]=i;\\n            }\\n        }\\n        //calculation min_max of each tree\\n        vector<pair<int,int>>min_max;\\n        calc_min_max(trees,min_max);\\n\\n        //calculating head of bst\\n        int head_ind=-1;\\n        calc_head_bst(trees,head_ind,tree_index);\\n        if(head_ind<0||head_ind>=trees.size())return NULL;\\n\\n        TreeNode* ans=buildTree(trees,min_max,tree_index,head_ind);\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\n    void calc_min_max(vector<TreeNode*>& trees,vector<pair<int,int>>&min_max){\\n        for(int i=0;i<trees.size();i++){\\n            TreeNode* leftd=trees[i];\\n            TreeNode* rightd=trees[i];\\n            int currmin=INT_MAX,currmax=INT_MIN;\\n            while(leftd!=NULL){\\n                currmin=min(currmin,leftd->val);\\n                leftd=leftd->left;\\n            }\\n            while(rightd!=NULL){\\n                currmax=max(currmax,rightd->val);\\n                rightd=rightd->right;\\n            }\\n            min_max.push_back({currmin,currmax});\\n        }\\n    }\\n\\n    void calc_head_bst(vector<TreeNode*>&trees,int &head_ind,map<int,int>&tree_index){\\n        int sum=0;\\n        unordered_set<int>values;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]==NULL)continue;\\n            sum+=i;\\n            queue<TreeNode*>q;\\n            q.push(trees[i]);\\n            while(!q.empty()){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(trees[i]!=curr){\\n                    if(values.count(curr->val)!=0){\\n                        head_ind=-1;\\n                        return;\\n                    }\\n                    values.insert(curr->val);\\n                }\\n                if(curr->left==NULL&&curr->right==NULL&&curr!=trees[i]&&tree_index.count(curr->val)!=0){\\n                    sum-=tree_index[curr->val];\\n                }\\n                if(curr->left!=NULL)q.push(curr->left);\\n                if(curr->right!=NULL)q.push(curr->right);\\n            }\\n        }\\n        head_ind=sum;\\n    }\\n    \\n    TreeNode* buildTree(vector<TreeNode*>&trees,vector<pair<int,int>>&min_max,map<int,int>&tree_index,int &head){\\n        int n=trees.size();\\n        vector<int>vis(n,0);\\n        vis[head]=1;\\n        queue<pair<TreeNode*,pair<int,int>>>qpp;\\n        qpp.push({trees[head],{INT_MIN,INT_MAX}});\\n        \\n        while(!qpp.empty()){\\n            TreeNode* curr=qpp.front().first;\\n            int minReq=qpp.front().second.first;\\n            int maxLim=qpp.front().second.second;\\n            qpp.pop();\\n            \\n            if(curr->left==NULL&&curr->right==NULL){\\n                int curr_val=curr->val;\\n                if(tree_index.count(curr_val)!=0){\\n                    int index=tree_index[curr_val];\\n                    if(vis[index]==1&&index!=head){\\n                        return NULL;\\n                    }\\n                    vis[index]=1;\\n                    if(min_max[index].first<=minReq||min_max[index].second>=maxLim){\\n                        return NULL;\\n                    }\\n                    \\n                    curr->left=trees[index]->left;\\n                    curr->right=trees[index]->right;\\n                }\\n            }\\n            if(curr->left!=NULL){\\n                qpp.push({curr->left,{minReq,curr->val}});\\n            }\\n            if(curr->right!=NULL){\\n                qpp.push({curr->right,{curr->val,maxLim}});\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(i!=head&&!vis[i]){\\n                return NULL;\\n            }\\n        }\\n        return trees[head];\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>tree_index;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=NULL){\\n                tree_index[trees[i]->val]=i;\\n            }\\n        }\\n        //calculation min_max of each tree\\n        vector<pair<int,int>>min_max;\\n        calc_min_max(trees,min_max);\\n\\n        //calculating head of bst\\n        int head_ind=-1;\\n        calc_head_bst(trees,head_ind,tree_index);\\n        if(head_ind<0||head_ind>=trees.size())return NULL;\\n\\n        TreeNode* ans=buildTree(trees,min_max,tree_index,head_ind);\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809888,
                "title": "beats-cpp-c-fastest-easy-to-unerstand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach :\\nTime complexity : O(n)\\n\\nSo, first I have inserted all the leaf nodes to parent <key,value> pairs are stored.\\n\\nThe the unordered map is stored to get the root of the tree having leaf value same as root2->val\\nHere in the image, 2 is root2 (tree[0]) and then I will find the root of the tree having a leaf node value as 2. So using unordered_map it becomes easy to find. So while searching I get the TreeNode* 3 (i.e. the root of leaf node value == 2)\\n\\nJoining Part :\\nSo to join a bst 1 to another bst 2, i will check if I\\'m adding the bst1 to left of bst2, then I have to check if the right of bst1 if smaller than root value, if it is smaller then add the bst1 to bst2 or else return NULL.\\n\\nSo in the Above example :\\nTaking (tree[0] and tree[1]) into consideration, tree[0] will be added to left of tree[1]. So I check if the right value of right of 2 is smaller than 3 (ie the root of tree[1]), here it does not exist so then add the tree[0] to tree[1].\\n\\nBelow example :\\nTaking (tree[0] and tree[1]) into consideration, tree[1] will be added to left of tree[0].\\nSo I check if the right value of right of 3 (tree[1]) is smaller than 5 (ie the root of tree[1]), here the value if 6>5, so return NULL\\n\\nSimilarly, do the checks while adding the bst to right, check if the value of bst1\\'s left is greater than the root of bst2.\\nAnd then finally after connecting the trees, check if there is only 1 single connected tree or not. If there is only one connected tree, then just check if it is a valid bst.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$  -->\\n\\n\\n> - Space complexity:O(N)\\n\\n---\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n---\\n\\n\\n---\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n         if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n         if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387203,
                "title": "just-implement-the-statements-given-in-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# UpVote\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        \\n        HashMap <Integer,TreeNode> map = new HashMap <Integer,TreeNode>();\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val))\\n            {\\n                return null;\\n            }\\n\\n            map.put(trees.get(i).val, trees.get(i));\\n        }\\n\\n        TreeNode root = trees.get(0);\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val) && dfs(trees.get(i), map))\\n            {\\n                root = trees.get(i);\\n\\n                map.put(root.val, root);\\n            }\\n        }\\n\\n        if(map.size() == 1 && root != null)\\n        {\\n            return check(root, Integer.MIN_VALUE, Integer.MAX_VALUE) == true ? root : null;\\n        }\\n\\n        return null;\\n    }\\n    \\n\\n    public boolean check(TreeNode root, int leftMin, int rightMin)\\n    {\\n        \\n        if(root == null)\\n        {\\n            return true;\\n        }\\n\\n        if(root.val <= leftMin || root.val >= rightMin)\\n        {\\n            return false;\\n        }\\n\\n        return check(root.left, leftMin, root.val) & check(root.right, root.val, rightMin);\\n    }\\n\\n    public boolean dfs(TreeNode node, HashMap <Integer,TreeNode> map)\\n    {\\n        boolean flag = false;\\n\\n        if(node.left != null)\\n        {\\n            if(map.containsKey(node.left.val))\\n            {\\n                node.left = map.get(node.left.val);\\n                map.remove(node.left.val);\\n                flag |= dfs(node.left, map);\\n                flag |= true;\\n            }\\n        }\\n        \\n        if(node.right != null)\\n        {\\n            if(map.containsKey(node.right.val))\\n            {\\n                node.right = map.get(node.right.val);\\n                map.remove(node.right.val);\\n                flag |= dfs(node.right, map);\\n                flag |= true;\\n            }\\n            \\n        }\\n\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        \\n        HashMap <Integer,TreeNode> map = new HashMap <Integer,TreeNode>();\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val))\\n            {\\n                return null;\\n            }\\n\\n            map.put(trees.get(i).val, trees.get(i));\\n        }\\n\\n        TreeNode root = trees.get(0);\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val) && dfs(trees.get(i), map))\\n            {\\n                root = trees.get(i);\\n\\n                map.put(root.val, root);\\n            }\\n        }\\n\\n        if(map.size() == 1 && root != null)\\n        {\\n            return check(root, Integer.MIN_VALUE, Integer.MAX_VALUE) == true ? root : null;\\n        }\\n\\n        return null;\\n    }\\n    \\n\\n    public boolean check(TreeNode root, int leftMin, int rightMin)\\n    {\\n        \\n        if(root == null)\\n        {\\n            return true;\\n        }\\n\\n        if(root.val <= leftMin || root.val >= rightMin)\\n        {\\n            return false;\\n        }\\n\\n        return check(root.left, leftMin, root.val) & check(root.right, root.val, rightMin);\\n    }\\n\\n    public boolean dfs(TreeNode node, HashMap <Integer,TreeNode> map)\\n    {\\n        boolean flag = false;\\n\\n        if(node.left != null)\\n        {\\n            if(map.containsKey(node.left.val))\\n            {\\n                node.left = map.get(node.left.val);\\n                map.remove(node.left.val);\\n                flag |= dfs(node.left, map);\\n                flag |= true;\\n            }\\n        }\\n        \\n        if(node.right != null)\\n        {\\n            if(map.containsKey(node.right.val))\\n            {\\n                node.right = map.get(node.right.val);\\n                map.remove(node.right.val);\\n                flag |= dfs(node.right, map);\\n                flag |= true;\\n            }\\n            \\n        }\\n\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239742,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn can_merge(trees: Vec<Option<Rc<RefCell<TreeNode>>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        use std::collections::{HashMap, HashSet};\\n        fn add_leaf(\\n            r: Option<Rc<RefCell<TreeNode>>>,\\n            leaves: &mut Vec<Option<Rc<RefCell<TreeNode>>>>,\\n            roots: &mut HashMap<i32, Option<Rc<RefCell<TreeNode>>>>,\\n            unique_vals: &mut HashSet<i32>,\\n        ) {\\n            if r.is_some() {\\n                let val = r.as_ref().unwrap().borrow().val;\\n                unique_vals.insert(val);\\n                if roots.contains_key(&val) {\\n                    leaves.push(r);\\n                }\\n            }\\n        }\\n\\n        fn valid_nodes(r: Option<Rc<RefCell<TreeNode>>>, min_left: i32, max_right: i32) -> usize {\\n            let val = r.as_ref().map(|r| r.borrow().val).unwrap_or(0);\\n            if r.is_none() || val <= min_left || val >= max_right {\\n                return 0;\\n            }\\n            let left = r.as_ref().unwrap().borrow().left.clone();\\n            let right = r.as_ref().unwrap().borrow().right.clone();\\n            let v_left = valid_nodes(left, min_left, val);\\n            let v_right = valid_nodes(right, val, max_right);\\n            1 + v_left + v_right\\n        }\\n\\n        let mut unique_vals = HashSet::new();\\n        let mut roots = HashMap::new();\\n        let mut leaves = Vec::new();\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            roots.insert(val, t.clone());\\n        }\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            let left = t.as_ref()?.borrow().left.clone();\\n            let right = t.as_ref()?.borrow().right.clone();\\n            unique_vals.insert(val);\\n            add_leaf(left, &mut leaves, &mut roots, &mut unique_vals);\\n            add_leaf(right, &mut leaves, &mut roots, &mut unique_vals);\\n        }\\n        for leaf in leaves {\\n            let val = leaf.as_ref()?.borrow().val;\\n            let root = roots.get_mut(&val)?;\\n            leaf.as_ref()?.borrow_mut().left = root.as_ref()?.borrow().left.clone();\\n            leaf.as_ref()?.borrow_mut().right = root.as_ref()?.borrow().right.clone();\\n            roots.remove(&val);\\n        }\\n        let first_node = roots.values().next().cloned()?;\\n        if roots.len() == 1 && valid_nodes(first_node.clone(), std::i32::MIN, std::i32::MAX) == unique_vals.len() {\\n            first_node\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn can_merge(trees: Vec<Option<Rc<RefCell<TreeNode>>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        use std::collections::{HashMap, HashSet};\\n        fn add_leaf(\\n            r: Option<Rc<RefCell<TreeNode>>>,\\n            leaves: &mut Vec<Option<Rc<RefCell<TreeNode>>>>,\\n            roots: &mut HashMap<i32, Option<Rc<RefCell<TreeNode>>>>,\\n            unique_vals: &mut HashSet<i32>,\\n        ) {\\n            if r.is_some() {\\n                let val = r.as_ref().unwrap().borrow().val;\\n                unique_vals.insert(val);\\n                if roots.contains_key(&val) {\\n                    leaves.push(r);\\n                }\\n            }\\n        }\\n\\n        fn valid_nodes(r: Option<Rc<RefCell<TreeNode>>>, min_left: i32, max_right: i32) -> usize {\\n            let val = r.as_ref().map(|r| r.borrow().val).unwrap_or(0);\\n            if r.is_none() || val <= min_left || val >= max_right {\\n                return 0;\\n            }\\n            let left = r.as_ref().unwrap().borrow().left.clone();\\n            let right = r.as_ref().unwrap().borrow().right.clone();\\n            let v_left = valid_nodes(left, min_left, val);\\n            let v_right = valid_nodes(right, val, max_right);\\n            1 + v_left + v_right\\n        }\\n\\n        let mut unique_vals = HashSet::new();\\n        let mut roots = HashMap::new();\\n        let mut leaves = Vec::new();\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            roots.insert(val, t.clone());\\n        }\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            let left = t.as_ref()?.borrow().left.clone();\\n            let right = t.as_ref()?.borrow().right.clone();\\n            unique_vals.insert(val);\\n            add_leaf(left, &mut leaves, &mut roots, &mut unique_vals);\\n            add_leaf(right, &mut leaves, &mut roots, &mut unique_vals);\\n        }\\n        for leaf in leaves {\\n            let val = leaf.as_ref()?.borrow().val;\\n            let root = roots.get_mut(&val)?;\\n            leaf.as_ref()?.borrow_mut().left = root.as_ref()?.borrow().left.clone();\\n            leaf.as_ref()?.borrow_mut().right = root.as_ref()?.borrow().right.clone();\\n            roots.remove(&val);\\n        }\\n        let first_node = roots.values().next().cloned()?;\\n        if roots.len() == 1 && valid_nodes(first_node.clone(), std::i32::MIN, std::i32::MAX) == unique_vals.len() {\\n            first_node\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3142584,
                "title": "c-hash-dfs-depth-first-search-leetcode-98-validate-binary-search-tree",
                "content": "# Code\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if (trees.size() == 1 ) return trees[0];\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            map_head_[trees[i]->val] = trees[i];\\n        }\\n\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            buildLeaf(trees[i]);\\n        }\\n\\n        if (map_head_.size() == 1) {\\n            auto result = map_head_.begin()->second;\\n\\n            if (isValidBST(result)) {\\n                return result;\\n            }\\n        }\\n\\n        return nullptr;\\n    }\\n\\nprivate:\\n    unordered_map<int, TreeNode*> map_head_;\\n    unordered_set<int> history_;\\n    int isValidBST_cnt_ = 0;\\n\\n    TreeNode* buildLeaf(TreeNode* head) {\\n        if (!head) {\\n            return nullptr;\\n        }\\n\\n        history_.insert(head->val);\\n\\n        if (!head->left && !head->right) {\\n            if (map_head_.count(head->val) &&  \\n                head != map_head_[head->val]) {\\n                auto treeRoot = map_head_[head->val];\\n                map_head_.erase(head->val);\\n                return treeRoot;\\n            }\\n        }\\n        head->left = buildLeaf(head->left);\\n        head->right = buildLeaf(head->right);\\n\\n        return head;\\n    }\\n\\n    //  leetCode 98. Validate Binary Search Tree\\n    bool isValidBST(TreeNode* head) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(head, prev) && isValidBST_cnt_ == history_.size();\\n    }\\n\\n    bool isValidBST(TreeNode* head, TreeNode*& prev) {\\n        if (!head) {\\n            return true;\\n        }\\n\\n        isValidBST_cnt_++;\\n\\n        if (!isValidBST(head->left, prev)) {\\n            return false;\\n        }\\n        \\n        if (prev && prev->val >= head->val) {\\n            return false;\\n        }\\n\\n        prev = head;\\n        return isValidBST(head->right, prev);\\n    }\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if (trees.size() == 1 ) return trees[0];\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            map_head_[trees[i]->val] = trees[i];\\n        }\\n\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            buildLeaf(trees[i]);\\n        }\\n\\n        if (map_head_.size() == 1) {\\n            auto result = map_head_.begin()->second;\\n\\n            if (isValidBST(result)) {\\n                return result;\\n            }\\n        }\\n\\n        return nullptr;\\n    }\\n\\nprivate:\\n    unordered_map<int, TreeNode*> map_head_;\\n    unordered_set<int> history_;\\n    int isValidBST_cnt_ = 0;\\n\\n    TreeNode* buildLeaf(TreeNode* head) {\\n        if (!head) {\\n            return nullptr;\\n        }\\n\\n        history_.insert(head->val);\\n\\n        if (!head->left && !head->right) {\\n            if (map_head_.count(head->val) &&  \\n                head != map_head_[head->val]) {\\n                auto treeRoot = map_head_[head->val];\\n                map_head_.erase(head->val);\\n                return treeRoot;\\n            }\\n        }\\n        head->left = buildLeaf(head->left);\\n        head->right = buildLeaf(head->right);\\n\\n        return head;\\n    }\\n\\n    //  leetCode 98. Validate Binary Search Tree\\n    bool isValidBST(TreeNode* head) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(head, prev) && isValidBST_cnt_ == history_.size();\\n    }\\n\\n    bool isValidBST(TreeNode* head, TreeNode*& prev) {\\n        if (!head) {\\n            return true;\\n        }\\n\\n        isValidBST_cnt_++;\\n\\n        if (!isValidBST(head->left, prev)) {\\n            return false;\\n        }\\n        \\n        if (prev && prev->val >= head->val) {\\n            return false;\\n        }\\n\\n        prev = head;\\n        return isValidBST(head->right, prev);\\n    }\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115463,
                "title": "swift-bfs",
                "content": "**BFS Approach (accepted answer)**\\n```\\nclass Solution {\\n    func canMerge(_ trees: [TreeNode?]) -> TreeNode? {\\n        var rootNodeLookup = [Int: TreeNode]()\\n        var childVals = Set<Int>()\\n        for tree in trees {\\n            guard let tree = tree else { continue }\\n            rootNodeLookup[tree.val] = tree\\n            if let left = tree.left, !childVals.insert(left.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n            if let right = tree.right, !childVals.insert(right.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n        }\\n        \\n        let potentialRoots = Set(rootNodeLookup.keys).subtracting(childVals)\\n        guard potentialRoots.count == 1 else { return nil } // Fail: not exactly one node is potential root\\n\\n        let rootNode = rootNodeLookup[potentialRoots.first!]!\\n        var leaves = [(rootNode, Int.min, Int.max)]\\n        var count = 0\\n        \\n        while !leaves.isEmpty {\\n            let oldLeaves = leaves\\n            leaves = []\\n            for entry in oldLeaves {\\n                let (leaf, lowerBound, upperBound) = entry\\n                guard lowerBound...upperBound ~= leaf.val else { return nil }  // Fail: current leaf value creates invalid BST\\n                if let rootNode = rootNodeLookup[leaf.val] {\\n                    if let left = rootNode.left {\\n                        leaf.left = left\\n                        leaves.append((left, lowerBound, min(upperBound, leaf.val)))\\n                    }\\n                    if let right = rootNode.right {\\n                        leaf.right = right\\n                        leaves.append((right, max(lowerBound, leaf.val), upperBound))\\n                    }\\n                    count += 1\\n                }\\n            }\\n        }\\n        \\n        return count == trees.count ? rootNode : nil\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func canMerge(_ trees: [TreeNode?]) -> TreeNode? {\\n        var rootNodeLookup = [Int: TreeNode]()\\n        var childVals = Set<Int>()\\n        for tree in trees {\\n            guard let tree = tree else { continue }\\n            rootNodeLookup[tree.val] = tree\\n            if let left = tree.left, !childVals.insert(left.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n            if let right = tree.right, !childVals.insert(right.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n        }\\n        \\n        let potentialRoots = Set(rootNodeLookup.keys).subtracting(childVals)\\n        guard potentialRoots.count == 1 else { return nil } // Fail: not exactly one node is potential root\\n\\n        let rootNode = rootNodeLookup[potentialRoots.first!]!\\n        var leaves = [(rootNode, Int.min, Int.max)]\\n        var count = 0\\n        \\n        while !leaves.isEmpty {\\n            let oldLeaves = leaves\\n            leaves = []\\n            for entry in oldLeaves {\\n                let (leaf, lowerBound, upperBound) = entry\\n                guard lowerBound...upperBound ~= leaf.val else { return nil }  // Fail: current leaf value creates invalid BST\\n                if let rootNode = rootNodeLookup[leaf.val] {\\n                    if let left = rootNode.left {\\n                        leaf.left = left\\n                        leaves.append((left, lowerBound, min(upperBound, leaf.val)))\\n                    }\\n                    if let right = rootNode.right {\\n                        leaf.right = right\\n                        leaves.append((right, max(lowerBound, leaf.val), upperBound))\\n                    }\\n                    count += 1\\n                }\\n            }\\n        }\\n        \\n        return count == trees.count ? rootNode : nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040147,
                "title": "simple-hash-map-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first have to map every child\\'s value with it\\'s parent tree pointer so that again iterating we can join these .\\nWe also have to check if formed tree is BSt or not by taking it\\'s preOrder and see if it is in increasing order or not also we have to count nodes before and after tree making as if we will have cycles then we will not include those nodes in final tree according to algorithm .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nds; // this will store pre order of nodes formed\\n    void preOrd(TreeNode* r){ // function to do preorder\\n        if(r == NULL) return;\\n        preOrd(r->left);\\n        nds.push_back(r->val);\\n        preOrd(r->right);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int nodes = 0; // this will store count of nodes \\n        map<int,TreeNode*> m; // for each value there will be 1 parent \\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];   nodes++;\\n            if(r->left){   nodes++;\\n                if(m.find(r->left->val) != m.end()) return NULL;\\n                m[r->left->val] = r;\\n            }\\n            if(r->right){   nodes++;\\n                if(m.find(r->right->val) != m.end()) return NULL;\\n                m[r->right->val] = r;\\n            }\\n        }\\n        TreeNode* ans = NULL; // initially ans is NULL\\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];\\n            if(m.find(r->val) == m.end()) continue; // if we do not find it\\'s parent then do not need to do anything\\n            // if we found it\\'s parent then we will replace values of it\\'s child\\n            if(m[r->val]->left && m[r->val]->left->val == r->val){ m[r->val]->left = r; trees[i] = NULL; }\\n            if(m[r->val]->right && m[r->val]->right->val == r->val){ m[r->val]->right = r; trees[i] = NULL; }\\n        }\\n        int cnt = 0; // this will count alone trees \\n        for(auto i: trees){\\n            if(i != NULL){\\n                ans = i;\\n                cnt++;\\n            }\\n        }\\n        if(cnt != 1) return NULL; // if not only 1 tree is made then we cannot form tree\\n        // Now we have to check for made tree is BST or not so do preorder and see if all nodes satisfy\\n        preOrd(ans); // do pre order\\n        // if after making successfull BST we will have nodes-(trees.size()-1) nodes count \\n        // so if we do not get this return NULL\\n        if(nodes-(trees.size()-1) != nds.size()) return NULL;\\n        // check for increasing order\\n        for(int i=0;i<nds.size()-1;i++){\\n            if(nds[i] >= nds[i+1]) return NULL;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nds; // this will store pre order of nodes formed\\n    void preOrd(TreeNode* r){ // function to do preorder\\n        if(r == NULL) return;\\n        preOrd(r->left);\\n        nds.push_back(r->val);\\n        preOrd(r->right);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int nodes = 0; // this will store count of nodes \\n        map<int,TreeNode*> m; // for each value there will be 1 parent \\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];   nodes++;\\n            if(r->left){   nodes++;\\n                if(m.find(r->left->val) != m.end()) return NULL;\\n                m[r->left->val] = r;\\n            }\\n            if(r->right){   nodes++;\\n                if(m.find(r->right->val) != m.end()) return NULL;\\n                m[r->right->val] = r;\\n            }\\n        }\\n        TreeNode* ans = NULL; // initially ans is NULL\\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];\\n            if(m.find(r->val) == m.end()) continue; // if we do not find it\\'s parent then do not need to do anything\\n            // if we found it\\'s parent then we will replace values of it\\'s child\\n            if(m[r->val]->left && m[r->val]->left->val == r->val){ m[r->val]->left = r; trees[i] = NULL; }\\n            if(m[r->val]->right && m[r->val]->right->val == r->val){ m[r->val]->right = r; trees[i] = NULL; }\\n        }\\n        int cnt = 0; // this will count alone trees \\n        for(auto i: trees){\\n            if(i != NULL){\\n                ans = i;\\n                cnt++;\\n            }\\n        }\\n        if(cnt != 1) return NULL; // if not only 1 tree is made then we cannot form tree\\n        // Now we have to check for made tree is BST or not so do preorder and see if all nodes satisfy\\n        preOrd(ans); // do pre order\\n        // if after making successfull BST we will have nodes-(trees.size()-1) nodes count \\n        // so if we do not get this return NULL\\n        if(nodes-(trees.size()-1) != nds.size()) return NULL;\\n        // check for increasing order\\n        for(int i=0;i<nds.size()-1;i++){\\n            if(nds[i] >= nds[i+1]) return NULL;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901518,
                "title": "depth-first-search-to-merge-binary-tree-python",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Indentify your root tree from where merging will being .\\n2. Now from remaining trees , apply helper function to merge.\\n3. If final tree is valid BST then return tree else return None.\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    is_merged = False\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if len(trees) == 1:\\n            return trees[0]\\n\\n        #Find List of Leaf Nodes\\n        all_leaves_node = set()\\n        for tree in trees :\\n            if tree.left :\\n                all_leaves_node.add(tree.left.val)\\n            if tree.right :\\n                all_leaves_node.add(tree.right.val)    \\n\\n        # Find start point - root node for all other tress\\n        root = None \\n        for tree in trees:\\n            if tree.val not in all_leaves_node:\\n                root = tree\\n\\n        #If we do not find any root node.   \\n        if root is None :\\n             return None \\n\\n        \\n        # List of Remaining trees except root node tree\\n        list_of_remaining_tree = []\\n        for tree in trees :\\n            if tree.val != root.val :\\n                list_of_remaining_tree.append(tree)\\n        \\n\\n        # Dictionary of root node value and tree\\n        root_tree_dictionary = {}\\n        for tree in list_of_remaining_tree:\\n             root_tree_dictionary[tree.val] = tree\\n\\n        #Perform Merging of Tree\\n        self.helper(root,root_tree_dictionary)\\n\\n        # Finally check if it is a valid BST \\n        if self.check_valid_bst(root , float(\\'-inf\\') , float(\\'inf\\')) \\\\\\n            and len(root_tree_dictionary) == 0:\\n                return root\\n        else:\\n            return None # If not a valid BST then return empty tree\\n       \\n             \\n    def helper(self, root , root_tree_dictionary):     \\n        if root is None :\\n            return None \\n\\n        #if root node is found in dictionary then peform merge \\n        if root.val in root_tree_dictionary:\\n            tree = root_tree_dictionary[root.val]\\n            root.left = tree.left\\n            root.right = tree.right \\n            root_tree_dictionary.pop(root.val)\\n                \\n        left = self.helper(root.left, root_tree_dictionary)\\n        right = self.helper(root.right, root_tree_dictionary)\\n    \\n    # Function for checking if it is a valid BST \\n    def check_valid_bst(self,root, min_value , max_value) :\\n            return not root or min_value < root.val < max_value and \\\\\\n                    self.check_valid_bst(root.left, min_value, root.val) and \\\\\\n                    self.check_valid_bst(root.right, root.val, max_value)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    is_merged = False\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if len(trees) == 1:\\n            return trees[0]\\n\\n        #Find List of Leaf Nodes\\n        all_leaves_node = set()\\n        for tree in trees :\\n            if tree.left :\\n                all_leaves_node.add(tree.left.val)\\n            if tree.right :\\n                all_leaves_node.add(tree.right.val)    \\n\\n        # Find start point - root node for all other tress\\n        root = None \\n        for tree in trees:\\n            if tree.val not in all_leaves_node:\\n                root = tree\\n\\n        #If we do not find any root node.   \\n        if root is None :\\n             return None \\n\\n        \\n        # List of Remaining trees except root node tree\\n        list_of_remaining_tree = []\\n        for tree in trees :\\n            if tree.val != root.val :\\n                list_of_remaining_tree.append(tree)\\n        \\n\\n        # Dictionary of root node value and tree\\n        root_tree_dictionary = {}\\n        for tree in list_of_remaining_tree:\\n             root_tree_dictionary[tree.val] = tree\\n\\n        #Perform Merging of Tree\\n        self.helper(root,root_tree_dictionary)\\n\\n        # Finally check if it is a valid BST \\n        if self.check_valid_bst(root , float(\\'-inf\\') , float(\\'inf\\')) \\\\\\n            and len(root_tree_dictionary) == 0:\\n                return root\\n        else:\\n            return None # If not a valid BST then return empty tree\\n       \\n             \\n    def helper(self, root , root_tree_dictionary):     \\n        if root is None :\\n            return None \\n\\n        #if root node is found in dictionary then peform merge \\n        if root.val in root_tree_dictionary:\\n            tree = root_tree_dictionary[root.val]\\n            root.left = tree.left\\n            root.right = tree.right \\n            root_tree_dictionary.pop(root.val)\\n                \\n        left = self.helper(root.left, root_tree_dictionary)\\n        right = self.helper(root.right, root_tree_dictionary)\\n    \\n    # Function for checking if it is a valid BST \\n    def check_valid_bst(self,root, min_value , max_value) :\\n            return not root or min_value < root.val < max_value and \\\\\\n                    self.check_valid_bst(root.left, min_value, root.val) and \\\\\\n                    self.check_valid_bst(root.right, root.val, max_value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884454,
                "title": "c-hashmap-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> root_mp, chld_mp;\\n        for(auto& n : trees) {\\n            if(n->left != nullptr) {\\n                if(chld_mp.find(n->left->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->left->val] = n->left;\\n            }\\n            if(n->right != nullptr) {\\n                if(chld_mp.find(n->right->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->right->val] = n->right;\\n            }\\n            root_mp[n->val] = n;\\n        }\\n\\n        TreeNode* res = nullptr;\\n        for(auto & [k, v] : root_mp) {\\n            if(chld_mp.find(k) == chld_mp.end()) {\\n                if(res != nullptr) return nullptr;\\n                res = v;\\n            }\\n        }\\n\\n        function<void(TreeNode*, TreeNode*, int, int)> dfs = [&](TreeNode* p, TreeNode* t, int l, int h) {\\n            if(t == nullptr) return;\\n            if(t->val <= l || t->val >= h) {\\n                res = nullptr;\\n                return;\\n            }\\n            int v = t->val;\\n            if(root_mp.find(v) == root_mp.end()) return;\\n            auto r = root_mp[v];\\n            root_mp.erase(r->val);\\n            if(p->left == t) p->left = r;\\n            else p->right = r;\\n            dfs(r, r->left, l, min(h, r->val));\\n            dfs(r, r->right, max(l, r->val), h);\\n        };\\n        if(res != nullptr) dfs(res, res->left, INT_MIN, res->val);\\n        if(res != nullptr) dfs(res, res->right, res->val, INT_MAX);\\n        return root_mp.size() == 1 ? res : nullptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> root_mp, chld_mp;\\n        for(auto& n : trees) {\\n            if(n->left != nullptr) {\\n                if(chld_mp.find(n->left->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->left->val] = n->left;\\n            }\\n            if(n->right != nullptr) {\\n                if(chld_mp.find(n->right->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->right->val] = n->right;\\n            }\\n            root_mp[n->val] = n;\\n        }\\n\\n        TreeNode* res = nullptr;\\n        for(auto & [k, v] : root_mp) {\\n            if(chld_mp.find(k) == chld_mp.end()) {\\n                if(res != nullptr) return nullptr;\\n                res = v;\\n            }\\n        }\\n\\n        function<void(TreeNode*, TreeNode*, int, int)> dfs = [&](TreeNode* p, TreeNode* t, int l, int h) {\\n            if(t == nullptr) return;\\n            if(t->val <= l || t->val >= h) {\\n                res = nullptr;\\n                return;\\n            }\\n            int v = t->val;\\n            if(root_mp.find(v) == root_mp.end()) return;\\n            auto r = root_mp[v];\\n            root_mp.erase(r->val);\\n            if(p->left == t) p->left = r;\\n            else p->right = r;\\n            dfs(r, r->left, l, min(h, r->val));\\n            dfs(r, r->right, max(l, r->val), h);\\n        };\\n        if(res != nullptr) dfs(res, res->left, INT_MIN, res->val);\\n        if(res != nullptr) dfs(res, res->right, res->val, INT_MAX);\\n        return root_mp.size() == 1 ? res : nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807443,
                "title": "python3",
                "content": "```\\nfrom typing import List, Optional\\n\\n\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.blacklist = set()\\n        self.value2node = {}\\n        self.operation_count = 0\\n\\n    def find_leaf(self, node, root):\\n        if not node:\\n            return\\n        \"\"\"\\n        Needs to make sure the only root node doesn\\'t get count as a leaf\\n        \"\"\"\\n        if not node.left and not node.right and node != root:\\n            self.blacklist.add(node.val)\\n        self.find_leaf(node.left, root)\\n        self.find_leaf(node.right, root)\\n\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        \"\"\"\\n        1. Find the root for the final BST:\\n            blacklist: all the leaf nodes\\n            whitelist: all the root nodes\\n\\n            This root node is unique. \\n\\n            Assume there are two nodes which are both roots, but neither of them exist in the leave nodes. \\n                Let\\'s say A is the final root and B is also can be the root(not exist in the leave nodes), the\\n                subtree with B as the root will not be able to merge into the final tree, but the problem require\\n                n - 1 operations for n trees, so all the subtree needs to be merged into the final big tree\\n\\n        2. build tree while checking if the bst is valid\\n            use recursive to return the validness of the bst\\n        3. Make sure all the tree have been used by count the times of merge operation and compare with the count of the trees\\n        \"\"\"\\n        root_count = 0\\n        return_root = None\\n\\n        for root in trees:\\n            self.find_leaf(root, root)\\n\\n        for root in trees:\\n            if root.val not in self.blacklist:\\n                return_root = root\\n                root_count += 1\\n            self.value2node[root.val] = root\\n\\n        # print(self.blacklist)\\n        # print(return_root)\\n        # print(self.value2node.keys())\\n\\n        if root_count != 1:\\n            return None\\n\\n        ok = self.build(return_root, float(\\'-inf\\'), float(\\'inf\\'), None, \\'\\')\\n        print(ok)\\n        print(self.operation_count)\\n        if ok and len(trees) - 1 == self.operation_count:\\n            return return_root\\n        else:\\n            return None\\n\\n    def build(self, node, min_v, max_v, parent, d) -> bool:\\n        if not node:\\n            return True\\n\\n        # print(min_v)\\n        # print(node.val)\\n        # print(max_v)\\n\\n        if node.val <= min_v or node.val >= max_v:\\n            return False\\n\\n        if node.left or node.right:\\n            return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                       node, \\'right\\')\\n        elif not node.left and not node.right and node.val in self.value2node:\\n            if d == \\'\\':\\n                \"\"\"\\n                When the root passed in with no direction, should just return True for this subtree\\n                \"\"\"\\n                return True\\n            self.operation_count += 1\\n            # print(node.val)\\n            if d == \\'left\\':\\n                parent.left = self.value2node[node.val]\\n                node = parent.left\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n            elif d == \\'right\\':\\n                parent.right = self.value2node[node.val]\\n                node = parent.right\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n        else:\\n            return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List, Optional\\n\\n\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.blacklist = set()\\n        self.value2node = {}\\n        self.operation_count = 0\\n\\n    def find_leaf(self, node, root):\\n        if not node:\\n            return\\n        \"\"\"\\n        Needs to make sure the only root node doesn\\'t get count as a leaf\\n        \"\"\"\\n        if not node.left and not node.right and node != root:\\n            self.blacklist.add(node.val)\\n        self.find_leaf(node.left, root)\\n        self.find_leaf(node.right, root)\\n\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        \"\"\"\\n        1. Find the root for the final BST:\\n            blacklist: all the leaf nodes\\n            whitelist: all the root nodes\\n\\n            This root node is unique. \\n\\n            Assume there are two nodes which are both roots, but neither of them exist in the leave nodes. \\n                Let\\'s say A is the final root and B is also can be the root(not exist in the leave nodes), the\\n                subtree with B as the root will not be able to merge into the final tree, but the problem require\\n                n - 1 operations for n trees, so all the subtree needs to be merged into the final big tree\\n\\n        2. build tree while checking if the bst is valid\\n            use recursive to return the validness of the bst\\n        3. Make sure all the tree have been used by count the times of merge operation and compare with the count of the trees\\n        \"\"\"\\n        root_count = 0\\n        return_root = None\\n\\n        for root in trees:\\n            self.find_leaf(root, root)\\n\\n        for root in trees:\\n            if root.val not in self.blacklist:\\n                return_root = root\\n                root_count += 1\\n            self.value2node[root.val] = root\\n\\n        # print(self.blacklist)\\n        # print(return_root)\\n        # print(self.value2node.keys())\\n\\n        if root_count != 1:\\n            return None\\n\\n        ok = self.build(return_root, float(\\'-inf\\'), float(\\'inf\\'), None, \\'\\')\\n        print(ok)\\n        print(self.operation_count)\\n        if ok and len(trees) - 1 == self.operation_count:\\n            return return_root\\n        else:\\n            return None\\n\\n    def build(self, node, min_v, max_v, parent, d) -> bool:\\n        if not node:\\n            return True\\n\\n        # print(min_v)\\n        # print(node.val)\\n        # print(max_v)\\n\\n        if node.val <= min_v or node.val >= max_v:\\n            return False\\n\\n        if node.left or node.right:\\n            return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                       node, \\'right\\')\\n        elif not node.left and not node.right and node.val in self.value2node:\\n            if d == \\'\\':\\n                \"\"\"\\n                When the root passed in with no direction, should just return True for this subtree\\n                \"\"\"\\n                return True\\n            self.operation_count += 1\\n            # print(node.val)\\n            if d == \\'left\\':\\n                parent.left = self.value2node[node.val]\\n                node = parent.left\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n            elif d == \\'right\\':\\n                parent.right = self.value2node[node.val]\\n                node = parent.right\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n        else:\\n            return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735280,
                "title": "c-hashmaps-with-explanation",
                "content": "This approach basically compares the leaves of every first tree with the root value of second tree stored in map and then append that second tree with the leaves of firsr tree.\\n```\\n//check for BST\\n    bool validate(TreeNode* root , pair<int,int>range){\\n        if(!root)\\n            return true;\\n        if( !(root->val > range.first && root->val < range.second) ){\\n            return false;\\n        }\\n\\n        bool left = validate(root->left , {range.first , root->val});\\n        bool right = validate(root->right, {root->val , range.second});\\n\\n        if(left && right){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        pair<int,int>range(INT_MIN , INT_MAX);\\n        return validate(root , range );\\n    }\\n    \\n    \\n    void solve(TreeNode* node , vector<TreeNode*>& trees ,unordered_map<int,int>&mp , int index){\\n        // if node is null\\n        if(!node)\\n            return;\\n        \\n        auto it = mp.find(node->val);\\n        // if we found same value of root as that of leaf\\n        //then append that root tree with leaf \\n        if(it != mp.end()){\\n            if(index == it->second || trees[it->second] == NULL)\\n                return;\\n            node->left = trees[it->second]->left;\\n            node->right = trees[it->second]->right;\\n            trees[it->second] = NULL;\\n            \\n            //then as we know that we added new children for this tree then check                   pair for these childrens too\\n            solve(node->left , trees , mp ,index);       \\n            solve(node->right , trees , mp , index);\\n        }\\n    }\\n    \\n\\t\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // if there is only 1 tree then return that tree\\n        if(trees.size() == 1)\\n            return trees[0];\\n        \\n        unordered_map<int,int>mp;\\n        \\n        /*store root value along with their index accorind to trees vector in map\\n         see example first\\n           value index\\n            2       0\\n            3       1\\n            5       2\\n            */\\n        for(int i=0 ; i< trees.size() ; i++){\\n            mp[trees[i]->val] = i;\\n        }\\n        \\n        //at the end if all all trees are merged then only one not null value will be           there is trees vector that will be the answer\\n        //but if there are more than one not null the means those not null values               couldn\\'t be merged\\n        /* Here we will compare the leaves of roots one by one wiht the map values \\n            if found then means there is a pair whose leaves and root is same, so                 that means they can be merged.\\n            When merged then means got appended with leaf node, then vector element               of that tree becomes null, as that tree is merged with another.\\n        */\\n        \\n        for(int i=0 ; i < trees.size() ; i++){\\n            if(!trees[i]){\\n                continue;\\n            }\\n            // as there are no children so leave it and move to next\\n            if(trees[i]->left == NULL && trees[i]->right == NULL){\\n                continue;\\n            }\\n            \\n            //search for left leaf  -  root pair \\n            solve(trees[i]->left , trees , mp , i);\\n            \\n            //search for right leaf -  root pair \\n            solve(trees[i]->right , trees , mp , i);\\n        }\\n        \\n        //--------------------------------------------------------------------------\\n        //check if all elements in trees vector except one are NULL\\n        // if not then those not NULL elements could not be merged\\n        int count=0;TreeNode* result=NULL;\\n        for(int i =0 ; i < trees.size() ;i++){\\n            \\n            if(trees[i]){\\n                result = trees[i];\\n                count++;\\n            }    \\n            if(count == 2)\\n                return NULL;\\n        }\\n        \\n        //check for BST\\n        if(!isValidBST(result))\\n            return NULL;\\n        \\n        return result;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/b9d98b12-ff5a-4f5f-aa16-f692b4a2ebc4_1666513935.780494.png)\\n",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\n//check for BST\\n    bool validate(TreeNode* root , pair<int,int>range){\\n        if(!root)\\n            return true;\\n        if( !(root->val > range.first && root->val < range.second) ){\\n            return false;\\n        }\\n\\n        bool left = validate(root->left , {range.first , root->val});\\n        bool right = validate(root->right, {root->val , range.second});\\n\\n        if(left && right){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        pair<int,int>range(INT_MIN , INT_MAX);\\n        return validate(root , range );\\n    }\\n    \\n    \\n    void solve(TreeNode* node , vector<TreeNode*>& trees ,unordered_map<int,int>&mp , int index){\\n        // if node is null\\n        if(!node)\\n            return;\\n        \\n        auto it = mp.find(node->val);\\n        // if we found same value of root as that of leaf\\n        //then append that root tree with leaf \\n        if(it != mp.end()){\\n            if(index == it->second || trees[it->second] == NULL)\\n                return;\\n            node->left = trees[it->second]->left;\\n            node->right = trees[it->second]->right;\\n            trees[it->second] = NULL;\\n            \\n            //then as we know that we added new children for this tree then check                   pair for these childrens too\\n            solve(node->left , trees , mp ,index);       \\n            solve(node->right , trees , mp , index);\\n        }\\n    }\\n    \\n\\t\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // if there is only 1 tree then return that tree\\n        if(trees.size() == 1)\\n            return trees[0];\\n        \\n        unordered_map<int,int>mp;\\n        \\n        /*store root value along with their index accorind to trees vector in map\\n         see example first\\n           value index\\n            2       0\\n            3       1\\n            5       2\\n            */\\n        for(int i=0 ; i< trees.size() ; i++){\\n            mp[trees[i]->val] = i;\\n        }\\n        \\n        //at the end if all all trees are merged then only one not null value will be           there is trees vector that will be the answer\\n        //but if there are more than one not null the means those not null values               couldn\\'t be merged\\n        /* Here we will compare the leaves of roots one by one wiht the map values \\n            if found then means there is a pair whose leaves and root is same, so                 that means they can be merged.\\n            When merged then means got appended with leaf node, then vector element               of that tree becomes null, as that tree is merged with another.\\n        */\\n        \\n        for(int i=0 ; i < trees.size() ; i++){\\n            if(!trees[i]){\\n                continue;\\n            }\\n            // as there are no children so leave it and move to next\\n            if(trees[i]->left == NULL && trees[i]->right == NULL){\\n                continue;\\n            }\\n            \\n            //search for left leaf  -  root pair \\n            solve(trees[i]->left , trees , mp , i);\\n            \\n            //search for right leaf -  root pair \\n            solve(trees[i]->right , trees , mp , i);\\n        }\\n        \\n        //--------------------------------------------------------------------------\\n        //check if all elements in trees vector except one are NULL\\n        // if not then those not NULL elements could not be merged\\n        int count=0;TreeNode* result=NULL;\\n        for(int i =0 ; i < trees.size() ;i++){\\n            \\n            if(trees[i]){\\n                result = trees[i];\\n                count++;\\n            }    \\n            if(count == 2)\\n                return NULL;\\n        }\\n        \\n        //check for BST\\n        if(!isValidBST(result))\\n            return NULL;\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716508,
                "title": "c-traverse-each-bst-leaf-node-with-help-of-a-hashtable-no-dfs-o-n-space-and-time",
                "content": "Some of the observations:\\n1. each BST root has unique value\\n2. let\\'s denote given BSTs with 1/2/3 nodes as BST-1/2/3. BST-1 cannot be used as leaf because no other root can attach to it. Only BST-2 and BST-3 leaf nodes can be used to attach another root.\\n3. in case two or more leaf nodes are equal, the result is invalid. Since merging with BSTs does not eliminate leaf from final tree, a tree with two or more equal nodes cannot be BST.\\n4. be careful with `cyclic merge`: a BST when merged to a parent tree, its leaf contains root value of the parent. For example [[10,5,12],[5,3,8],[3,null,10]]\\n\\nHere is the algorithm:\\nWe initialize a hashtable with given BSTs. Iterate on each leaf node, merge another BST and remove it from the hashtable when found. Equal leaf nodes at most can do 1 merge, as the non-first such leaf will not find the value from hashtable. `cyclic merge` components will disappear wholly from the hashtable. In the end, the hashtable might contain:\\n0 trees: `cyclic merge` exists and the whole BST disappeared, return NULL.\\n1 trees: `cyclic merge` might exist, or not. e.g., [[3,1],[1,3],[5,2,6]]. apply validBST() to count number of nodes in the result tree, when valid it should be total - (tree count - 1). \\n2 or more trees: cannot be merged as a single tree, return NULL;\\n```\\n\\t// return number of valid nodes in the tree\\n    int validBST(TreeNode* node, int lo, int hi) {\\n        if (node == NULL) {\\n            return 0;\\n        }\\n        \\n        if (!(lo < node->val && node->val < hi)) {\\n            return 0;\\n        }\\n        \\n        return 1 + validBST(node->left, lo, node->val) + validBST(node->right, node->val, hi);\\n    }\\n\\t\\n\\tTreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // root value -> tree\\n        unordered_map<int, TreeNode*> table;\\n        for (auto tree : trees) {\\n            table[tree->val] = tree;\\n        }\\n        \\n        // approach 2\\n        int total = 0; // count of nodes in all unmerged bsts\\n        int bsts = trees.size(); // coount of trees\\n        for (int i = 0; i < trees.size(); i++) {\\n            TreeNode* t = trees[i];\\n            int val;\\n            if (t->left) {\\n                val = t->left->val;\\n                if (table.find(val) != table.end()) {\\n                    t->left = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            if (t->right) {\\n                val = t->right->val;\\n                if (table.find(val) != table.end()) {\\n                    t->right = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            total++;\\n        }\\n        \\n        \\n        // size can be 0, 1, or more\\n        if (table.size() != 1) {\\n            return NULL;\\n        }\\n        \\n        \\n        TreeNode* tree = table.begin()->second;\\n        int cnt = validBST(tree, 0, 50001);\\n        return cnt == total - (bsts - 1) ? tree : NULL;\\n    }\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\t// return number of valid nodes in the tree\\n    int validBST(TreeNode* node, int lo, int hi) {\\n        if (node == NULL) {\\n            return 0;\\n        }\\n        \\n        if (!(lo < node->val && node->val < hi)) {\\n            return 0;\\n        }\\n        \\n        return 1 + validBST(node->left, lo, node->val) + validBST(node->right, node->val, hi);\\n    }\\n\\t\\n\\tTreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // root value -> tree\\n        unordered_map<int, TreeNode*> table;\\n        for (auto tree : trees) {\\n            table[tree->val] = tree;\\n        }\\n        \\n        // approach 2\\n        int total = 0; // count of nodes in all unmerged bsts\\n        int bsts = trees.size(); // coount of trees\\n        for (int i = 0; i < trees.size(); i++) {\\n            TreeNode* t = trees[i];\\n            int val;\\n            if (t->left) {\\n                val = t->left->val;\\n                if (table.find(val) != table.end()) {\\n                    t->left = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            if (t->right) {\\n                val = t->right->val;\\n                if (table.find(val) != table.end()) {\\n                    t->right = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            total++;\\n        }\\n        \\n        \\n        // size can be 0, 1, or more\\n        if (table.size() != 1) {\\n            return NULL;\\n        }\\n        \\n        \\n        TreeNode* tree = table.begin()->second;\\n        int cnt = validBST(tree, 0, 50001);\\n        return cnt == total - (bsts - 1) ? tree : NULL;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580139,
                "title": "c-dfs-solution-beats-90",
                "content": "```\\nclass Solution {\\n\\t//Map to store the index of the root, given its value\\n    unordered_map<int, int> mp; \\npublic:\\n\\t//Perform DFS and simultaneously build tree\\n    void dfs(vector<TreeNode*>& trees, vector<bool>& vis, TreeNode* node){\\n        if(node->left!=NULL && mp[node->left->val]>0){\\n            node->left = trees[mp[node->left->val]-1];\\n            vis[mp[node->left->val]-1] = true;\\n            mp[node->left->val] = 0;\\n            dfs(trees, vis, node->left);\\n        }\\n        if(node->right!=NULL && mp[node->right->val]>0){\\n            node->right = trees[mp[node->right->val]-1];\\n            vis[mp[node->right->val]-1] = true;\\n            mp[node->right->val] = 0;\\n            dfs(trees, vis, node->right);\\n        }\\n    }\\n    \\n\\t//Function to validate the BST formed. It checks for the conditions for a valid BST as given in question by doing DFS\\n    bool validate(TreeNode* root, int up = INT_MIN, int low = INT_MAX){\\n        if(root==NULL)\\n            return true;\\n        if(root->val >= low || root->val <= up)\\n            return false;\\n        return validate(root->left, up, root->val)&&validate(root->right, root->val, low);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> ump;\\n        for(int i=0; i<trees.size(); i++){\\n            if(trees[i]->left != NULL)\\n                ump[trees[i]->left->val] = 1;\\n            if(trees[i]->right != NULL)\\n                ump[trees[i]->right->val] = 1;\\n        }\\n        for(int i=0; i<trees.size(); i++)\\n            mp[trees[i]->val] = i+1;\\n        \\n        vector<bool> vis(trees.size(), false);\\n        TreeNode* root = NULL;\\n        for(int i=0; i<trees.size(); i++){\\n            if(!ump[trees[i]->val]){\\n                vis[i] = true;\\n                root = trees[i];\\n                break;\\n            }\\n        }\\n        if(root==NULL)\\n            return NULL;\\n        mp[root->val] = 0;\\n        dfs(trees, vis, root);\\n        \\n        for(int i=0; i<vis.size(); i++)\\n            if(!vis[i])\\n                return NULL;\\n        \\n        if(validate(root))\\n            return root;\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\t//Map to store the index of the root, given its value\\n    unordered_map<int, int> mp; \\npublic:\\n\\t//Perform DFS and simultaneously build tree\\n    void dfs(vector<TreeNode*>& trees, vector<bool>& vis, TreeNode* node){\\n        if(node->left!=NULL && mp[node->left->val]>0){\\n            node->left = trees[mp[node->left->val]-1];\\n            vis[mp[node->left->val]-1] = true;\\n            mp[node->left->val] = 0;\\n            dfs(trees, vis, node->left);\\n        }\\n        if(node->right!=NULL && mp[node->right->val]>0){\\n            node->right = trees[mp[node->right->val]-1];\\n            vis[mp[node->right->val]-1] = true;\\n            mp[node->right->val] = 0;\\n            dfs(trees, vis, node->right);\\n        }\\n    }\\n    \\n\\t//Function to validate the BST formed. It checks for the conditions for a valid BST as given in question by doing DFS\\n    bool validate(TreeNode* root, int up = INT_MIN, int low = INT_MAX){\\n        if(root==NULL)\\n            return true;\\n        if(root->val >= low || root->val <= up)\\n            return false;\\n        return validate(root->left, up, root->val)&&validate(root->right, root->val, low);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> ump;\\n        for(int i=0; i<trees.size(); i++){\\n            if(trees[i]->left != NULL)\\n                ump[trees[i]->left->val] = 1;\\n            if(trees[i]->right != NULL)\\n                ump[trees[i]->right->val] = 1;\\n        }\\n        for(int i=0; i<trees.size(); i++)\\n            mp[trees[i]->val] = i+1;\\n        \\n        vector<bool> vis(trees.size(), false);\\n        TreeNode* root = NULL;\\n        for(int i=0; i<trees.size(); i++){\\n            if(!ump[trees[i]->val]){\\n                vis[i] = true;\\n                root = trees[i];\\n                break;\\n            }\\n        }\\n        if(root==NULL)\\n            return NULL;\\n        mp[root->val] = 0;\\n        dfs(trees, vis, root);\\n        \\n        for(int i=0; i<vis.size(); i++)\\n            if(!vis[i])\\n                return NULL;\\n        \\n        if(validate(root))\\n            return root;\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573783,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        hashMap = defaultdict(int)\\n        \\n        def isValid(root: Optional[TreeNode], minimum: int, maximum: int) -> bool:\\n            if not root:\\n                return True\\n            if root.val <= minimum or root.val >= maximum:\\n                return False\\n            else:\\n                return isValid(root.left, minimum, root.val) and isValid(root.right, root.val, maximum)\\n            \\n        def helper(root: Optional[TreeNode], trees: List[TreeNode], minimum: int, maximum: int) -> Optional[TreeNode]:\\n            nonlocal hashMap\\n            if not root:\\n                return None\\n            if root.val in hashMap:\\n                x = hashMap[root.val]\\n                if isValid(trees[x - 1], minimum, maximum):\\n                    root = trees[x - 1]\\n                    del hashMap[root.val]\\n                else:\\n                    return root\\n            root.left = helper(root.left, trees, minimum, root.val);\\n            root.right = helper(root.right, trees, root.val, maximum)\\n            return root\\n        \\n        numTrees, hashMapAlt = len(trees), defaultdict(int)\\n        for i in range(numTrees):\\n            hashMap[trees[i].val] = i + 1\\n        for i in range(numTrees):\\n            hashMapAlt[trees[i].val] += 1\\n            if trees[i].left:\\n                hashMapAlt[trees[i].left.val] += 1\\n            if trees[i].right:\\n                hashMapAlt[trees[i].right.val] += 1\\n        root = None\\n        for treeNode in trees:\\n            if hashMapAlt[treeNode.val] == 1:\\n                if root is not None:\\n                    return None\\n                root = treeNode\\n        if not root:\\n            return None\\n        minimum, maximum = -float(\\'inf\\'), float(\\'inf\\')\\n        node = helper(root, trees, minimum, maximum)\\n        if len(hashMap) == 0:\\n            return node\\n        return None\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        hashMap = defaultdict(int)\\n        \\n        def isValid(root: Optional[TreeNode], minimum: int, maximum: int) -> bool:\\n            if not root:\\n                return True\\n            if root.val <= minimum or root.val >= maximum:\\n                return False\\n            else:\\n                return isValid(root.left, minimum, root.val) and isValid(root.right, root.val, maximum)\\n            \\n        def helper(root: Optional[TreeNode], trees: List[TreeNode], minimum: int, maximum: int) -> Optional[TreeNode]:\\n            nonlocal hashMap\\n            if not root:\\n                return None\\n            if root.val in hashMap:\\n                x = hashMap[root.val]\\n                if isValid(trees[x - 1], minimum, maximum):\\n                    root = trees[x - 1]\\n                    del hashMap[root.val]\\n                else:\\n                    return root\\n            root.left = helper(root.left, trees, minimum, root.val);\\n            root.right = helper(root.right, trees, root.val, maximum)\\n            return root\\n        \\n        numTrees, hashMapAlt = len(trees), defaultdict(int)\\n        for i in range(numTrees):\\n            hashMap[trees[i].val] = i + 1\\n        for i in range(numTrees):\\n            hashMapAlt[trees[i].val] += 1\\n            if trees[i].left:\\n                hashMapAlt[trees[i].left.val] += 1\\n            if trees[i].right:\\n                hashMapAlt[trees[i].right.val] += 1\\n        root = None\\n        for treeNode in trees:\\n            if hashMapAlt[treeNode.val] == 1:\\n                if root is not None:\\n                    return None\\n                root = treeNode\\n        if not root:\\n            return None\\n        minimum, maximum = -float(\\'inf\\'), float(\\'inf\\')\\n        node = helper(root, trees, minimum, maximum)\\n        if len(hashMap) == 0:\\n            return node\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467078,
                "title": "java-build-it-with-detailed-comments",
                "content": "```Java\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> root = new HashMap<>(); // root candidates\\n        Map<Integer, TreeNode> map = new HashMap<>(); // all nodes\\n        for (TreeNode t : trees){\\n            root.put(t.val, t);\\n            map.put(t.val, t);\\n        }\\n        for (TreeNode t : trees){ // root candidates can\\'t be a leave of some other nodes\\n            int L = t.left == null? 0 : t.left.val;\\n            int R = t.right== null? 0 : t.right.val;\\n            root.remove(L);\\n            root.remove(R);\\n        }\\n        if (root.size() != 1 || map.size() != trees.size()){ // we must have 1 node and no duplicate root values.\\n            return null;\\n        }\\n        int INF = (int)1e9;\\n        TreeNode r = root.values().iterator().next(); // this is our root\\n        return build(-INF, INF, r, map) && map.size() == 1? r : null; // try to build it, in the end, map should only have the root left.\\n    }\\n    \\n    private boolean build(int min, int max, TreeNode cur, Map<Integer, TreeNode> map){\\n        boolean ok = cur.val > min && cur.val < max; // must hold for BST\\n        if (cur.left != null){ // replace left node\\n            cur.left = map.getOrDefault(cur.left.val, cur.left);\\n            map.remove(cur.left.val);\\n            ok &= build(min, cur.val, cur.left, map);\\n        }\\n        if (cur.right != null){ // replace right node\\n            cur.right = map.getOrDefault(cur.right.val, cur.right);\\n            map.remove(cur.right.val);\\n            ok &= build(cur.val, max, cur.right, map);\\n        }\\n        return ok;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> root = new HashMap<>(); // root candidates\\n        Map<Integer, TreeNode> map = new HashMap<>(); // all nodes\\n        for (TreeNode t : trees){\\n            root.put(t.val, t);\\n            map.put(t.val, t);\\n        }\\n        for (TreeNode t : trees){ // root candidates can\\'t be a leave of some other nodes\\n            int L = t.left == null? 0 : t.left.val;\\n            int R = t.right== null? 0 : t.right.val;\\n            root.remove(L);\\n            root.remove(R);\\n        }\\n        if (root.size() != 1 || map.size() != trees.size()){ // we must have 1 node and no duplicate root values.\\n            return null;\\n        }\\n        int INF = (int)1e9;\\n        TreeNode r = root.values().iterator().next(); // this is our root\\n        return build(-INF, INF, r, map) && map.size() == 1? r : null; // try to build it, in the end, map should only have the root left.\\n    }\\n    \\n    private boolean build(int min, int max, TreeNode cur, Map<Integer, TreeNode> map){\\n        boolean ok = cur.val > min && cur.val < max; // must hold for BST\\n        if (cur.left != null){ // replace left node\\n            cur.left = map.getOrDefault(cur.left.val, cur.left);\\n            map.remove(cur.left.val);\\n            ok &= build(min, cur.val, cur.left, map);\\n        }\\n        if (cur.right != null){ // replace right node\\n            cur.right = map.getOrDefault(cur.right.val, cur.right);\\n            map.remove(cur.right.val);\\n            ok &= build(cur.val, max, cur.right, map);\\n        }\\n        return ok;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459260,
                "title": "c-hashmap-easy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n//     For keeping the track of BSTs\\n    unordered_map<int,int> mp;\\n   \\n//     Validate a BST\\n    bool isValid(TreeNode*root, int mini, int maxi){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val <= mini || root->val >= maxi){\\n            return false;\\n        }\\n        else{\\n            return isValid(root->left,mini,root->val) && isValid(root->right,root->val,maxi);\\n        }\\n    }\\n    \\n//     Helper function to Make the BST\\n     TreeNode* helper(TreeNode* root, vector<TreeNode*>& trees, int mini, int maxi){\\n        if(!root){\\n            return NULL;\\n        }\\n         \\n        if(mp.find(root->val)!=mp.end()){\\n            int x = mp[root->val];\\n            \\n            \\n            if(isValid(trees[x-1],mini,maxi)){\\n                root = trees[x-1];\\n                mp.erase(root->val);\\n            }\\n            else{\\n                return root;\\n            }\\n        }\\n        root->left = helper(root->left,trees,mini,root->val);\\n        root->right = helper(root->right,trees,root->val,maxi);\\n        \\n         return root;\\n    }\\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        for(int i = 0;i<n;i++){\\n            mp[trees[i]->val] = i+1;\\n        }\\n        unordered_map<int,int> mp1;\\n        \\n        for(int i = 0;i<n;i++){\\n            mp1[trees[i]->val]++;\\n            if(trees[i]->left){\\n                mp1[trees[i]->left->val]++;\\n            }\\n            if(trees[i]->right){\\n                mp1[trees[i]->right->val]++;\\n            }\\n        }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(mp1[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        \\n        if(!root){\\n            return NULL;\\n        }\\n        \\n        int mini = INT_MIN;\\n        int maxi = INT_MAX;\\n        auto y = helper(root,trees,mini,maxi);\\n        if(mp.size() == 0){\\n            return y;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n//     For keeping the track of BSTs\\n    unordered_map<int,int> mp;\\n   \\n//     Validate a BST\\n    bool isValid(TreeNode*root, int mini, int maxi){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val <= mini || root->val >= maxi){\\n            return false;\\n        }\\n        else{\\n            return isValid(root->left,mini,root->val) && isValid(root->right,root->val,maxi);\\n        }\\n    }\\n    \\n//     Helper function to Make the BST\\n     TreeNode* helper(TreeNode* root, vector<TreeNode*>& trees, int mini, int maxi){\\n        if(!root){\\n            return NULL;\\n        }\\n         \\n        if(mp.find(root->val)!=mp.end()){\\n            int x = mp[root->val];\\n            \\n            \\n            if(isValid(trees[x-1],mini,maxi)){\\n                root = trees[x-1];\\n                mp.erase(root->val);\\n            }\\n            else{\\n                return root;\\n            }\\n        }\\n        root->left = helper(root->left,trees,mini,root->val);\\n        root->right = helper(root->right,trees,root->val,maxi);\\n        \\n         return root;\\n    }\\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        for(int i = 0;i<n;i++){\\n            mp[trees[i]->val] = i+1;\\n        }\\n        unordered_map<int,int> mp1;\\n        \\n        for(int i = 0;i<n;i++){\\n            mp1[trees[i]->val]++;\\n            if(trees[i]->left){\\n                mp1[trees[i]->left->val]++;\\n            }\\n            if(trees[i]->right){\\n                mp1[trees[i]->right->val]++;\\n            }\\n        }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(mp1[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        \\n        if(!root){\\n            return NULL;\\n        }\\n        \\n        int mini = INT_MIN;\\n        int maxi = INT_MAX;\\n        auto y = helper(root,trees,mini,maxi);\\n        if(mp.size() == 0){\\n            return y;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446115,
                "title": "scala-i-believe-it-works-but-memory-limit-needs-to-be-adjusted",
                "content": "```\\n  object Solution {\\n\\n    def min(tree: TreeNode): Int = {\\n      if (tree.left == null) tree.value\\n      else min(tree.left)\\n    }\\n\\n    def max(tree: TreeNode): Int = {\\n      if (tree.right == null) tree.value\\n      else max(tree.right)\\n    }\\n\\n    def isBst(tree: TreeNode): Boolean = {\\n      if (tree == null) true\\n      else {\\n        val maxOnLeftLessThanRoot = if (tree.left == null) true else max(tree.left) < tree.value\\n        val minOnRightGreaterThanRoot = if (tree.right == null) true else min(tree.right) > tree.value\\n        isBst(tree.left) && isBst(tree.right) && maxOnLeftLessThanRoot && minOnRightGreaterThanRoot\\n      }\\n    }\\n\\n    def clone(tree: TreeNode): TreeNode = {\\n      if (tree == null) null\\n      else new TreeNode(tree.value, clone(tree.left), clone(tree.right))\\n    }\\n\\n    def merge(a: TreeNode, b: TreeNode): Option[TreeNode] = {\\n      if (a == null || b == null) None\\n      else if (a.value < b.value) {\\n        merge(a, b.left).map(new TreeNode(b.value, _, b.right))\\n      } else if (a.value > b.value) {\\n        merge(a, b.right).map(new TreeNode(b.value, b.left, _))\\n      } else Some(clone(a))\\n    }\\n    \\n    case class MergeFirst(result: TreeNode, found: Boolean, foundAt: Option[Int])\\n\\n    def mergeAny(tree: TreeNode, nodes: List[TreeNode]): Option[TreeNode] = {\\n      if (nodes.isEmpty) Some(tree)\\n      else {\\n        val MergeFirst(result, found, foundAt) = nodes.zipWithIndex.foldLeft(MergeFirst(tree, false, None)) {\\n          case (MergeFirst(a, false, _), (b, i)) =>\\n            val amb = merge(a, b)\\n            val bma = merge(b, a)\\n            if (amb.nonEmpty && isBst(amb.get)) MergeFirst(amb.get, true, Some(i))\\n            else if (bma.nonEmpty && isBst(bma.get)) MergeFirst(bma.get, true, Some(i))\\n            else MergeFirst(a, false, None)\\n          case (MergeFirst(r, true, fa), _) => MergeFirst(r, true, fa)\\n        }\\n\\n        if (!found) None\\n        else mergeAny(result, nodes.slice(0, foundAt.get) ::: nodes.slice(foundAt.get + 1, nodes.length))\\n      }\\n\\n    }\\n\\n    def canMerge(trees: List[TreeNode]): TreeNode = {\\n      val empty: TreeNode = null\\n      mergeAny(trees.head, trees.tail).getOrElse(empty)\\n    }\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  object Solution {\\n\\n    def min(tree: TreeNode): Int = {\\n      if (tree.left == null) tree.value\\n      else min(tree.left)\\n    }\\n\\n    def max(tree: TreeNode): Int = {\\n      if (tree.right == null) tree.value\\n      else max(tree.right)\\n    }\\n\\n    def isBst(tree: TreeNode): Boolean = {\\n      if (tree == null) true\\n      else {\\n        val maxOnLeftLessThanRoot = if (tree.left == null) true else max(tree.left) < tree.value\\n        val minOnRightGreaterThanRoot = if (tree.right == null) true else min(tree.right) > tree.value\\n        isBst(tree.left) && isBst(tree.right) && maxOnLeftLessThanRoot && minOnRightGreaterThanRoot\\n      }\\n    }\\n\\n    def clone(tree: TreeNode): TreeNode = {\\n      if (tree == null) null\\n      else new TreeNode(tree.value, clone(tree.left), clone(tree.right))\\n    }\\n\\n    def merge(a: TreeNode, b: TreeNode): Option[TreeNode] = {\\n      if (a == null || b == null) None\\n      else if (a.value < b.value) {\\n        merge(a, b.left).map(new TreeNode(b.value, _, b.right))\\n      } else if (a.value > b.value) {\\n        merge(a, b.right).map(new TreeNode(b.value, b.left, _))\\n      } else Some(clone(a))\\n    }\\n    \\n    case class MergeFirst(result: TreeNode, found: Boolean, foundAt: Option[Int])\\n\\n    def mergeAny(tree: TreeNode, nodes: List[TreeNode]): Option[TreeNode] = {\\n      if (nodes.isEmpty) Some(tree)\\n      else {\\n        val MergeFirst(result, found, foundAt) = nodes.zipWithIndex.foldLeft(MergeFirst(tree, false, None)) {\\n          case (MergeFirst(a, false, _), (b, i)) =>\\n            val amb = merge(a, b)\\n            val bma = merge(b, a)\\n            if (amb.nonEmpty && isBst(amb.get)) MergeFirst(amb.get, true, Some(i))\\n            else if (bma.nonEmpty && isBst(bma.get)) MergeFirst(bma.get, true, Some(i))\\n            else MergeFirst(a, false, None)\\n          case (MergeFirst(r, true, fa), _) => MergeFirst(r, true, fa)\\n        }\\n\\n        if (!found) None\\n        else mergeAny(result, nodes.slice(0, foundAt.get) ::: nodes.slice(foundAt.get + 1, nodes.length))\\n      }\\n\\n    }\\n\\n    def canMerge(trees: List[TreeNode]): TreeNode = {\\n      val empty: TreeNode = null\\n      mergeAny(trees.head, trees.tail).getOrElse(empty)\\n    }\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421173,
                "title": "97-tc-passed-intuitive-approach",
                "content": "**Only 3% cases are not passed.\\n If anyone can improve this code then you are most welcome.**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    static bool comp(TreeNode* root1, TreeNode* root2){\\n        return root1->val < root2->val;\\n    }\\n    pair<int, int> get(TreeNode* root){\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            auto it = st.top();\\n            st.pop();\\n            mini = min(mini, it->val);\\n            maxi = max(maxi, it->val);\\n            \\n            if(it->left) st.push(it->left);\\n            if(it->right) st.push(it->right);\\n        } \\n        \\n        return {mini, maxi};\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        sort(trees.begin(), trees.end(), comp);\\n        unordered_map<int, pair<TreeNode*, pair<int, int>>> mp;\\n        unordered_set<TreeNode*> vis;\\n        for(auto it: trees){\\n            mp[it->val] = make_pair(it, get(it));\\n        }\\n        \\n        for(int i = 0; i < trees.size(); i++){\\n            if(1){\\n                TreeNode* leaf1 = NULL;\\n                TreeNode* leaf2 = NULL;\\n                pair<int, int> range_leaf1, range_leaf2;\\n                TreeNode* root = trees[i];\\n                if(root->left && root->right){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                    \\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                else if(root->left){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                }\\n                else if(root->right){\\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                \\n                \\n                if(leaf1){\\n                    if(mp.find(leaf1->val) != mp.end()){\\n                        if((range_leaf1.first <= mp[leaf1->val].second.first) &&( mp[leaf1->val].second.second <= range_leaf1.second)){\\n                            trees[i]->left = mp[leaf1->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf1->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf1->val].second.second);\\n                            mp.erase(leaf1->val);\\n                        }\\n                    }\\n                }\\n                if(leaf2){\\n                    if(mp.find(leaf2->val) != mp.end()){\\n                        if((range_leaf2.first <= mp[leaf2->val].second.first) &&( mp[leaf2->val].second.second <= range_leaf2.second)){\\n                            trees[i]->right = mp[leaf2->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf2->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf2->val].second.second);\\n                            mp.erase(leaf2->val);\\n                        }\\n                    }\\n                }\\n                \\n                \\n            }\\n        }\\n        if(mp.size() > 1) return NULL;\\n        return mp.begin()->second.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    static bool comp(TreeNode* root1, TreeNode* root2){\\n        return root1->val < root2->val;\\n    }\\n    pair<int, int> get(TreeNode* root){\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            auto it = st.top();\\n            st.pop();\\n            mini = min(mini, it->val);\\n            maxi = max(maxi, it->val);\\n            \\n            if(it->left) st.push(it->left);\\n            if(it->right) st.push(it->right);\\n        } \\n        \\n        return {mini, maxi};\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        sort(trees.begin(), trees.end(), comp);\\n        unordered_map<int, pair<TreeNode*, pair<int, int>>> mp;\\n        unordered_set<TreeNode*> vis;\\n        for(auto it: trees){\\n            mp[it->val] = make_pair(it, get(it));\\n        }\\n        \\n        for(int i = 0; i < trees.size(); i++){\\n            if(1){\\n                TreeNode* leaf1 = NULL;\\n                TreeNode* leaf2 = NULL;\\n                pair<int, int> range_leaf1, range_leaf2;\\n                TreeNode* root = trees[i];\\n                if(root->left && root->right){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                    \\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                else if(root->left){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                }\\n                else if(root->right){\\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                \\n                \\n                if(leaf1){\\n                    if(mp.find(leaf1->val) != mp.end()){\\n                        if((range_leaf1.first <= mp[leaf1->val].second.first) &&( mp[leaf1->val].second.second <= range_leaf1.second)){\\n                            trees[i]->left = mp[leaf1->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf1->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf1->val].second.second);\\n                            mp.erase(leaf1->val);\\n                        }\\n                    }\\n                }\\n                if(leaf2){\\n                    if(mp.find(leaf2->val) != mp.end()){\\n                        if((range_leaf2.first <= mp[leaf2->val].second.first) &&( mp[leaf2->val].second.second <= range_leaf2.second)){\\n                            trees[i]->right = mp[leaf2->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf2->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf2->val].second.second);\\n                            mp.erase(leaf2->val);\\n                        }\\n                    }\\n                }\\n                \\n                \\n            }\\n        }\\n        if(mp.size() > 1) return NULL;\\n        return mp.begin()->second.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327830,
                "title": "c-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void build(TreeNode* r,  unordered_map<TreeNode*, vector<TreeNode*>>& conn, int& num) {\\n        for(auto* n: conn[r]) {\\n            build(n, conn, num);\\n            if(r->left && r->left->val == n->val) {\\n                r->left = n;\\n                ++num;\\n            }\\n            if(r->right && r->right->val == n->val) {\\n                r->right = n;\\n                ++num;\\n            }           \\n        }\\n    }\\n    \\n    void preorder(TreeNode* r, vector<int>& v) {\\n        if(!r) return;\\n        preorder(r->left, v);\\n        v.push_back(r->val);\\n        preorder(r->right, v);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n\\t\\t// Build a map that stores the val of each root as the key.\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto* n: trees) mp[n->val] = n;\\n        \\n\\t\\t// For each root in trees, find out the other roots that it can connect to.\\n        unordered_map<TreeNode*, vector<TreeNode*>> conn;\\n        for(auto* n: trees) {\\n            if(n->left && mp.count(n->left->val)) {\\n                conn[n].push_back(mp[n->left->val]);\\n                mp.erase(n->left->val);\\n            }\\n            if(n->right && mp.count(n->right->val)) {\\n                conn[n].push_back(mp[n->right->val]);\\n                mp.erase(n->right->val);\\n            }            \\n        }\\n        \\n\\t\\t// After finding the connections, there should be only one root that is left (the root of the result BST).\\n        if(mp.empty() || mp.size() > 1) return nullptr;\\n\\n\\t\\t// Build the tree, note that the tree should include all the roots in trees.\\n        TreeNode* r = mp.begin()->second;\\n        int num = 1;\\n        build(r, conn, num);\\n        if(num != trees.size()) return nullptr;\\n        \\n\\t\\t// Pre-order traversal to make sure the result binary tree is BST.\\n        vector<int> v;\\n        preorder(r, v);\\n        for(int i=1; i<v.size(); ++i) {\\n            if(v[i] <= v[i-1]) return nullptr;\\n        }\\n        return r;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void build(TreeNode* r,  unordered_map<TreeNode*, vector<TreeNode*>>& conn, int& num) {\\n        for(auto* n: conn[r]) {\\n            build(n, conn, num);\\n            if(r->left && r->left->val == n->val) {\\n                r->left = n;\\n                ++num;\\n            }\\n            if(r->right && r->right->val == n->val) {\\n                r->right = n;\\n                ++num;\\n            }           \\n        }\\n    }\\n    \\n    void preorder(TreeNode* r, vector<int>& v) {\\n        if(!r) return;\\n        preorder(r->left, v);\\n        v.push_back(r->val);\\n        preorder(r->right, v);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n\\t\\t// Build a map that stores the val of each root as the key.\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto* n: trees) mp[n->val] = n;\\n        \\n\\t\\t// For each root in trees, find out the other roots that it can connect to.\\n        unordered_map<TreeNode*, vector<TreeNode*>> conn;\\n        for(auto* n: trees) {\\n            if(n->left && mp.count(n->left->val)) {\\n                conn[n].push_back(mp[n->left->val]);\\n                mp.erase(n->left->val);\\n            }\\n            if(n->right && mp.count(n->right->val)) {\\n                conn[n].push_back(mp[n->right->val]);\\n                mp.erase(n->right->val);\\n            }            \\n        }\\n        \\n\\t\\t// After finding the connections, there should be only one root that is left (the root of the result BST).\\n        if(mp.empty() || mp.size() > 1) return nullptr;\\n\\n\\t\\t// Build the tree, note that the tree should include all the roots in trees.\\n        TreeNode* r = mp.begin()->second;\\n        int num = 1;\\n        build(r, conn, num);\\n        if(num != trees.size()) return nullptr;\\n        \\n\\t\\t// Pre-order traversal to make sure the result binary tree is BST.\\n        vector<int> v;\\n        preorder(r, v);\\n        for(int i=1; i<v.size(); ++i) {\\n            if(v[i] <= v[i-1]) return nullptr;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293703,
                "title": "c-topological-sort-based-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    bool is_valid_bst = true;\\n    pair<int, int> f(TreeNode* root) {\\n        pair<int, int> cv = {root->val, root->val};\\n        if(root->left)  {\\n            auto v = f(root->left);\\n            if(v.first >= root->val || v.second >= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        if(root->right)  {\\n            auto v = f(root->right);\\n            if(v.first <= root->val || v.second <= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        return cv;\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        unordered_map<int, int>  heads;\\n        for(int i=0;i<n;i++) {\\n            if(heads.find(trees[i]->val) != heads.end()) return nullptr;\\n            \\n            heads[trees[i]->val] = i;\\n        }\\n        \\n        vector<pair<int, int>> graph(n, {-1, -1});\\n        vector<pair<int, bool>> parent_list(n, {-1, false});\\n        for(int i=0;i<n;i++) {\\n            auto v = trees[i];\\n            if(v->left){ \\n                if(heads.find(v->left->val) != heads.end()){\\n                    graph[i].first =  heads[v->left->val];\\n                    parent_list[heads[v->left->val]] = {i, true}; \\n                }\\n            }\\n\\n            if(v->right){ \\n                if(heads.find(v->right->val) != heads.end()){\\n                    graph[i].second =  heads[v->right->val];\\n                    parent_list[heads[v->right->val]] = {i, false}; \\n                }\\n            }\\n        }\\n        \\n        vector<int> degrees(n);\\n        for(int i=0;i<n;i++){\\n            auto v = graph[i];\\n            degrees[i] = (v.first != -1) + (v.second != -1);\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;i++) {\\n            if(degrees[i] == 0) q.push(i);\\n        }\\n        \\n        int merge_count = 0;\\n        TreeNode* main_parent;\\n        while(!q.empty()) {\\n            int cti = q.front();\\n            q.pop();\\n            main_parent = trees[cti];\\n            \\n            pair<int, int> parent_info = parent_list[cti];\\n            int pi = parent_info.first;\\n            int is_left = parent_info.second;\\n            if(pi != -1){\\n                if(is_left){\\n                    trees[pi]->left = trees[cti];\\n                }else {\\n                    trees[pi]->right = trees[cti];\\n                }\\n                degrees[pi]--;\\n                merge_count++;\\n                \\n                if(degrees[pi] == 0) q.push(pi);\\n                \\n            }    \\n        }\\n        \\n        if(merge_count != n - 1) return nullptr;\\n\\n        f(main_parent);\\n        \\n        return is_valid_bst ? main_parent : nullptr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    bool is_valid_bst = true;\\n    pair<int, int> f(TreeNode* root) {\\n        pair<int, int> cv = {root->val, root->val};\\n        if(root->left)  {\\n            auto v = f(root->left);\\n            if(v.first >= root->val || v.second >= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        if(root->right)  {\\n            auto v = f(root->right);\\n            if(v.first <= root->val || v.second <= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        return cv;\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        unordered_map<int, int>  heads;\\n        for(int i=0;i<n;i++) {\\n            if(heads.find(trees[i]->val) != heads.end()) return nullptr;\\n            \\n            heads[trees[i]->val] = i;\\n        }\\n        \\n        vector<pair<int, int>> graph(n, {-1, -1});\\n        vector<pair<int, bool>> parent_list(n, {-1, false});\\n        for(int i=0;i<n;i++) {\\n            auto v = trees[i];\\n            if(v->left){ \\n                if(heads.find(v->left->val) != heads.end()){\\n                    graph[i].first =  heads[v->left->val];\\n                    parent_list[heads[v->left->val]] = {i, true}; \\n                }\\n            }\\n\\n            if(v->right){ \\n                if(heads.find(v->right->val) != heads.end()){\\n                    graph[i].second =  heads[v->right->val];\\n                    parent_list[heads[v->right->val]] = {i, false}; \\n                }\\n            }\\n        }\\n        \\n        vector<int> degrees(n);\\n        for(int i=0;i<n;i++){\\n            auto v = graph[i];\\n            degrees[i] = (v.first != -1) + (v.second != -1);\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;i++) {\\n            if(degrees[i] == 0) q.push(i);\\n        }\\n        \\n        int merge_count = 0;\\n        TreeNode* main_parent;\\n        while(!q.empty()) {\\n            int cti = q.front();\\n            q.pop();\\n            main_parent = trees[cti];\\n            \\n            pair<int, int> parent_info = parent_list[cti];\\n            int pi = parent_info.first;\\n            int is_left = parent_info.second;\\n            if(pi != -1){\\n                if(is_left){\\n                    trees[pi]->left = trees[cti];\\n                }else {\\n                    trees[pi]->right = trees[cti];\\n                }\\n                degrees[pi]--;\\n                merge_count++;\\n                \\n                if(degrees[pi] == 0) q.push(pi);\\n                \\n            }    \\n        }\\n        \\n        if(merge_count != n - 1) return nullptr;\\n\\n        f(main_parent);\\n        \\n        return is_valid_bst ? main_parent : nullptr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195014,
                "title": "java-simple-solution-using-hashmap-and-dfs",
                "content": "class Solution {\\n    int outputNumberOfNodes = 0;\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        HashMap<Integer, TreeNode> root = new HashMap<>();\\n        HashMap<Integer, TreeNode> child = new HashMap<>();\\n        \\n        int numberOfNode = 0;\\n        for (int i=0; i<trees.size(); i++) {\\n            root.put(trees.get(i).val, trees.get(i));\\n            numberOfNode++;\\n            \\n            if (trees.get(i).left != null) {\\n                child.put(trees.get(i).left.val, trees.get(i).left);\\n                numberOfNode++;\\n            }\\n            \\n            if (trees.get(i).right != null) {\\n                child.put(trees.get(i).right.val, trees.get(i).right);\\n                numberOfNode++;\\n            }\\n        }\\n        \\n        TreeNode node = null;\\n        for (int i=0; i<trees.size(); i++) {\\n            if (child.containsKey(trees.get(i).val)) {\\n                numberOfNode--;\\n                TreeNode first = child.get(trees.get(i).val);\\n                first.left = trees.get(i).left;\\n                first.right = trees.get(i).right;\\n            }\\n            else {\\n                if (node == null) {\\n                    node = trees.get(i);\\n                }\\n                else {\\n                    return null;\\n                }\\n            }\\n        }\\n        \\n        return (isValid(node, Integer.MIN_VALUE, Integer.MAX_VALUE) && numberOfNode == outputNumberOfNodes) ? node : null;\\n    }\\n    \\n    public boolean isValid(TreeNode root, int min, int max) {\\n        if (root == null) {\\n            return true;\\n        }\\n        \\n        outputNumberOfNodes++;\\n        if ((root.val <= min || root.val >= max)) {\\n            return false;\\n        }\\n        \\n        return (isValid(root.left, min, root.val) && isValid(root.right, root.val, max));\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int outputNumberOfNodes = 0;\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        HashMap<Integer, TreeNode> root = new HashMap<>();\\n        HashMap<Integer, TreeNode> child = new HashMap<>();\\n        \\n        int numberOfNode = 0;\\n        for (int i=0; i<trees.size(); i++) {\\n            root.put(trees.get(i).val, trees.get(i));\\n            numberOfNode++;\\n            \\n            if (trees.get(i).left != null) {\\n                child.put(trees.get(i).left.val, trees.get(i).left);\\n                numberOfNode++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2185575,
                "title": "python-observation-dfs-with-thought-process-when-being-asked-during-interviews",
                "content": "### Observation + DFS\\nFirst of all, let\\'s observe the constraints that might give hints to the solution. \\n* All of roots are unique. It means we can quickly locate which `root` to replace child with using hashmap, otherwise for the same value of child, we might have multiple choices.\\n* We need to do `n - 1` operations. It means the `roots` ends up with the only one root left which is the final root for the BST since we need remove one root from `roots` each time.\\n* The final number of `roots` is 1 means for each `roots[i]` except the final root, there is always a `roots[j]` such that either of children of `roots[j]` equals to the value of `roots[i]`. This is the most important key to crack this problem. So we can say the BST is not valid if this condition is not met.\\n* All of roots are valid BST. It means we can pick root from `roots` greedly as long as the value of either children is equals to the root.\\n\\nSo we can summary that the algorithm is that\\n1. Store the value of each root from `roots` in hashmap.\\n2. Iterate left and right child of each root and remove the corresponding root from `roots`\\n3. Return None if more than 1 root left in `roots`.\\n4. The left one is the final root we need to return\\n5. Replace the children of final root recursively.\\n\\nI started with interative way, and found it too difficult to write. The easiest way is to recursively replace the root, left and right children, then return the root.\\n\\nFianlly, pass in the range to the dfs as well, which is used to evaluate the BST property.\\n\\n```python\\ndef canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\troots = {tree.val: tree for tree in trees}\\n\\tfor tree in trees:\\n\\t\\tif tree.left and tree.left.val in roots:\\n\\t\\t\\troots.pop(tree.left.val)\\n\\t\\tif tree.right and tree.right.val in roots:\\n\\t\\t\\troots.pop(tree.right.val)\\n\\tif len(roots) != 1:     \\n\\t\\treturn None\\n\\t_, root = roots.popitem()\\n\\troots = {tree.val: tree for tree in trees}\\n\\t\\n\\tself.is_valid = True\\n\\tdef dfs(root, left, right):\\n\\t\\tif root:\\n\\t\\t\\tif root.val < left or root.val > right: \\n\\t\\t\\t\\tself.is_valid = False\\n\\t\\t\\t\\treturn None\\n\\t\\t\\tif root.val in roots:\\n\\t\\t\\t\\troot = roots.pop(root.val)\\n\\t\\t\\t\\troot.left = dfs(root.left, left, root.val - 1)\\n\\t\\t\\t\\troot.right = dfs(root.right, root.val + 1, right)\\n\\t\\treturn root \\n\\n\\tdfs(root, 0, float(\\'inf\\'))\\n\\treturn root if self.is_valid and not roots else None\\n```\\n\\n*Time Complexity*= **O(N)**\\n*Space Complexity* = **O(N)**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\ndef canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\troots = {tree.val: tree for tree in trees}\\n\\tfor tree in trees:\\n\\t\\tif tree.left and tree.left.val in roots:\\n\\t\\t\\troots.pop(tree.left.val)\\n\\t\\tif tree.right and tree.right.val in roots:\\n\\t\\t\\troots.pop(tree.right.val)\\n\\tif len(roots) != 1:     \\n\\t\\treturn None\\n\\t_, root = roots.popitem()\\n\\troots = {tree.val: tree for tree in trees}\\n\\t\\n\\tself.is_valid = True\\n\\tdef dfs(root, left, right):\\n\\t\\tif root:\\n\\t\\t\\tif root.val < left or root.val > right: \\n\\t\\t\\t\\tself.is_valid = False\\n\\t\\t\\t\\treturn None\\n\\t\\t\\tif root.val in roots:\\n\\t\\t\\t\\troot = roots.pop(root.val)\\n\\t\\t\\t\\troot.left = dfs(root.left, left, root.val - 1)\\n\\t\\t\\t\\troot.right = dfs(root.right, root.val + 1, right)\\n\\t\\treturn root \\n\\n\\tdfs(root, 0, float(\\'inf\\'))\\n\\treturn root if self.is_valid and not roots else None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2089038,
                "title": "simple-java-o-n-with-explanation-using-hashmap",
                "content": "```\\nclass Solution {\\n    int finalTreeCount = 0;  // This will be used for final reconciliation\\n\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); \\n        Map<Integer, TreeNode> leafMap = new HashMap<>();\\n        int count = 0; \\n        // Find all the root nodes and leaf nodes\\n        for (TreeNode x : trees) {\\n            count++;\\n            rootMap.put(x.val, x);\\n            if (x.left != null) {\\n                count++;\\n                leafMap.put(x.left.val, x.left);\\n            }\\n            if (x.right != null) {\\n                count++;\\n                leafMap.put(x.right.val, x.right);\\n            }\\n        }\\n\\t\\t\\n        TreeNode result = null;\\n        for (TreeNode x : trees) {\\n            \\n            if (leafMap.containsKey(x.val)) {\\n                count--; // decrement the count, as one node merged\\n                TreeNode l = leafMap.get(x.val);\\n                l.left = x.left;\\n                l.right = x.right;\\n            } else {\\n                if (result == null) {\\n                    result = x;\\n                } else {\\n                    return null; // if we have already one final tree, then getting another one is an error.\\n                }\\n            }\\n        }\\n        return (isValidBST(result) && count == finalTreeCount) ? result : null;\\n    }\\n    \\n    private boolean isValidBST(TreeNode x) {\\n        if (x == null) return false;\\n        \\n        Deque<TreeNode> stack = new LinkedList<>();\\n        TreeNode curr = x;\\n        TreeNode prev = null;\\n        while(curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            finalTreeCount++;\\n            \\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    int finalTreeCount = 0;  // This will be used for final reconciliation\\n\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); \\n        Map<Integer, TreeNode> leafMap = new HashMap<>();\\n        int count = 0; \\n        // Find all the root nodes and leaf nodes\\n        for (TreeNode x : trees) {\\n            count++;\\n            rootMap.put(x.val, x);\\n            if (x.left != null) {\\n                count++;\\n                leafMap.put(x.left.val, x.left);\\n            }\\n            if (x.right != null) {\\n                count++;\\n                leafMap.put(x.right.val, x.right);\\n            }\\n        }\\n\\t\\t\\n        TreeNode result = null;\\n        for (TreeNode x : trees) {\\n            \\n            if (leafMap.containsKey(x.val)) {\\n                count--; // decrement the count, as one node merged\\n                TreeNode l = leafMap.get(x.val);\\n                l.left = x.left;\\n                l.right = x.right;\\n            } else {\\n                if (result == null) {\\n                    result = x;\\n                } else {\\n                    return null; // if we have already one final tree, then getting another one is an error.\\n                }\\n            }\\n        }\\n        return (isValidBST(result) && count == finalTreeCount) ? result : null;\\n    }\\n    \\n    private boolean isValidBST(TreeNode x) {\\n        if (x == null) return false;\\n        \\n        Deque<TreeNode> stack = new LinkedList<>();\\n        TreeNode curr = x;\\n        TreeNode prev = null;\\n        while(curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            finalTreeCount++;\\n            \\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993949,
                "title": "c-with-comment-and-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //O(N) \\n    pair<bool,pair<int,int>> check_bst(TreeNode* king){ //<true,<min,max>> if it is bst\\n    pair<bool,pair<int,int>> l,r;\\n    if(!(king->left) and !(king->right)) return make_pair(true,make_pair(king->val,king->val));\\n    if((king->left) and (king->right) ){\\n        l=check_bst(king->left);\\n        r=check_bst(king->right);\\n        if(!l.first or !r.first or l.second.second>=king->val or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,r.second.second));\\n    }\\n    if((king->left) and !(king->right) ){\\n        l=check_bst(king->left);\\n        if(!l.first  or l.second.second>=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,king->val));\\n    }\\n    if(!(king->left) and (king->right) ){\\n        r=check_bst(king->right);\\n        if( !r.first  or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(king->val,r.second.second));\\n    }\\n        \\n    return make_pair(false,make_pair(king->val,king->val));\\n    }\\n    \\n    \\n    \\n    //O(N) make tree (use hash map for searching.)\\n    map<int,TreeNode*>  mp; // a mapping of head node value to head for tree in trees.   \\n    map<int,TreeNode*>::iterator itr;\\n    void maketree(TreeNode* king){\\n\\n    if(king->left) {\\n        itr= mp.find(king->left->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->left = itr->second;   //attach the tree itr->second as left subtree of king\\n            mp.erase(itr);\\n            maketree(king->left);\\n        }   \\n    }\\n    if(king->right) {\\n        itr= mp.find(king->right->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->right = itr->second;  //attach the tree itr->second as right subtree of king\\n            mp.erase(itr);\\n            maketree(king->right);\\n        }   \\n    }\\n    return;    \\n    }\\n      \\n    //return king as the head of merged tree, remove king from trees\\n    //return nullptr if failed\\n\\t//note: king is defined as the head of the final combined tree. \\n\\t//      No leaf node can have same value as king node.\\n    //O(N) using set\\n    TreeNode* find_king(vector<TreeNode*>& trees) {\\n    set<int> leaf;\\n    \\n    TreeNode* king;\\n    king=nullptr;\\n    vector<TreeNode*>::iterator t1,t2;\\n    \\n\\t//insert all the leaf values to set for speeding up of searching\\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if((*t1)->left) leaf.insert((*t1)->left->val);\\n    if((*t1)->right) leaf.insert((*t1)->right->val);   \\n    }\\n        \\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if(leaf.find((*t1)->val)==leaf.end()) {king=*t1;trees.erase(t1);return king;}   //O(1) due to hash \\n    }      \\n    return king;\\n    }\\n    \\n    //O(N) main program\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    int n=trees.size();\\n    vector<TreeNode*>::iterator t1;\\n    \\n        \\n    //find_king O(N)\\n    start();\\n    TreeNode* king;\\n    king=find_king(trees);\\n    if(king==nullptr) return nullptr; //no king\\n    cout<<\"find_king: \";stop();\\n    \\n    //maketree O(N) \\n    start();\\n    for(t1=trees.begin();t1!=trees.end();t1++){\\n    mp[(*t1)->val]=*t1;\\n    } \\n    maketree( king);\\n    cout<<\"maketree: \";stop();\\n    \\n    //check_bst O(N)\\n    start();\\n    if (mp.size()!=0) {cout<<\"cannot form single tree.\\\\n\";return nullptr;}\\n    if(!check_bst(king).first) {cout<<\"check_bst: \";stop();return nullptr;}\\n    cout<<\"check_bst: \";stop();\\n    \\n    return king;\\n    }\\n    \\n    \\n    //for timing purpose\\n    std::chrono::high_resolution_clock::time_point tstart  ; \\n    void start(){\\n    tstart = chrono::high_resolution_clock::now();    \\n    return;\\n    }\\n    void stop(){\\n    auto stop = chrono::high_resolution_clock::now();\\n    auto duration = chrono::duration_cast<chrono::microseconds>(stop - tstart);\\n    cout<<\"*\"<<duration.count()<<\" ms\\\\n\";\\n    return ;\\n    }\\n    void sleep(){\\n    /* Simulating a long, heavy operation. */\\n\\n    using namespace std::chrono_literals;\\n    std::this_thread::sleep_for(1732ms);\\n    }\\n};```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //O(N) \\n    pair<bool,pair<int,int>> check_bst(TreeNode* king){ //<true,<min,max>> if it is bst\\n    pair<bool,pair<int,int>> l,r;\\n    if(!(king->left) and !(king->right)) return make_pair(true,make_pair(king->val,king->val));\\n    if((king->left) and (king->right) ){\\n        l=check_bst(king->left);\\n        r=check_bst(king->right);\\n        if(!l.first or !r.first or l.second.second>=king->val or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,r.second.second));\\n    }\\n    if((king->left) and !(king->right) ){\\n        l=check_bst(king->left);\\n        if(!l.first  or l.second.second>=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,king->val));\\n    }\\n    if(!(king->left) and (king->right) ){\\n        r=check_bst(king->right);\\n        if( !r.first  or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(king->val,r.second.second));\\n    }\\n        \\n    return make_pair(false,make_pair(king->val,king->val));\\n    }\\n    \\n    \\n    \\n    //O(N) make tree (use hash map for searching.)\\n    map<int,TreeNode*>  mp; // a mapping of head node value to head for tree in trees.   \\n    map<int,TreeNode*>::iterator itr;\\n    void maketree(TreeNode* king){\\n\\n    if(king->left) {\\n        itr= mp.find(king->left->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->left = itr->second;   //attach the tree itr->second as left subtree of king\\n            mp.erase(itr);\\n            maketree(king->left);\\n        }   \\n    }\\n    if(king->right) {\\n        itr= mp.find(king->right->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->right = itr->second;  //attach the tree itr->second as right subtree of king\\n            mp.erase(itr);\\n            maketree(king->right);\\n        }   \\n    }\\n    return;    \\n    }\\n      \\n    //return king as the head of merged tree, remove king from trees\\n    //return nullptr if failed\\n\\t//note: king is defined as the head of the final combined tree. \\n\\t//      No leaf node can have same value as king node.\\n    //O(N) using set\\n    TreeNode* find_king(vector<TreeNode*>& trees) {\\n    set<int> leaf;\\n    \\n    TreeNode* king;\\n    king=nullptr;\\n    vector<TreeNode*>::iterator t1,t2;\\n    \\n\\t//insert all the leaf values to set for speeding up of searching\\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if((*t1)->left) leaf.insert((*t1)->left->val);\\n    if((*t1)->right) leaf.insert((*t1)->right->val);   \\n    }\\n        \\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if(leaf.find((*t1)->val)==leaf.end()) {king=*t1;trees.erase(t1);return king;}   //O(1) due to hash \\n    }      \\n    return king;\\n    }\\n    \\n    //O(N) main program\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    int n=trees.size();\\n    vector<TreeNode*>::iterator t1;\\n    \\n        \\n    //find_king O(N)\\n    start();\\n    TreeNode* king;\\n    king=find_king(trees);\\n    if(king==nullptr) return nullptr; //no king\\n    cout<<\"find_king: \";stop();\\n    \\n    //maketree O(N) \\n    start();\\n    for(t1=trees.begin();t1!=trees.end();t1++){\\n    mp[(*t1)->val]=*t1;\\n    } \\n    maketree( king);\\n    cout<<\"maketree: \";stop();\\n    \\n    //check_bst O(N)\\n    start();\\n    if (mp.size()!=0) {cout<<\"cannot form single tree.\\\\n\";return nullptr;}\\n    if(!check_bst(king).first) {cout<<\"check_bst: \";stop();return nullptr;}\\n    cout<<\"check_bst: \";stop();\\n    \\n    return king;\\n    }\\n    \\n    \\n    //for timing purpose\\n    std::chrono::high_resolution_clock::time_point tstart  ; \\n    void start(){\\n    tstart = chrono::high_resolution_clock::now();    \\n    return;\\n    }\\n    void stop(){\\n    auto stop = chrono::high_resolution_clock::now();\\n    auto duration = chrono::duration_cast<chrono::microseconds>(stop - tstart);\\n    cout<<\"*\"<<duration.count()<<\" ms\\\\n\";\\n    return ;\\n    }\\n    void sleep(){\\n    /* Simulating a long, heavy operation. */\\n\\n    using namespace std::chrono_literals;\\n    std::this_thread::sleep_for(1732ms);\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 1984182,
                "title": "c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int nax = 5e4 + 1;\\n    bool validate(TreeNode* root, int left, int right, vector<bool>& vis) {\\n        if (root == nullptr) return true;\\n        vis[root->val] = false;\\n        if (root->val <= left || root->val >= right) return false;\\n        return validate(root->left, left, root->val, vis) & validate(root->right, root->val, right, vis);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        vector<TreeNode*> roots(nax, nullptr);\\n        for (TreeNode* r : trees) {\\n            roots[r->val] = r;\\n        }\\n        vector<bool> notRoot(nax);\\n        vector<bool> vis(nax);\\n        for (TreeNode* r : trees) {\\n            vis[r->val] = true;\\n            if (r->left != nullptr) {\\n                vis[r->left->val] = true;\\n            }\\n            if (r->right != nullptr) {\\n                vis[r->right->val] = true;\\n            } \\n        }\\n        for (TreeNode* r : trees) {\\n            if (r->left != nullptr) {\\n                int val = r->left->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->left;\\n                    r->left = roots[val];\\n                    notRoot[val] = true;\\n                }\\n            }\\n            if (r->right != nullptr) {\\n                int val = r->right->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->right;\\n                    r->right = roots[val];\\n                    notRoot[val] = true;\\n                } \\n            }\\n        }\\n        int count = 0;\\n        TreeNode* root = nullptr;\\n        for (TreeNode* r : trees) {\\n            if (!notRoot[r->val]) {\\n                ++count;\\n                root = r;\\n            }\\n        }\\n        if (count > 1) return nullptr;\\n        if (!validate(root, -nax - 1, nax + 1, vis)) return nullptr;\\n        for (int i = 0; i < nax; i++) {\\n            if (vis[i]) return nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int nax = 5e4 + 1;\\n    bool validate(TreeNode* root, int left, int right, vector<bool>& vis) {\\n        if (root == nullptr) return true;\\n        vis[root->val] = false;\\n        if (root->val <= left || root->val >= right) return false;\\n        return validate(root->left, left, root->val, vis) & validate(root->right, root->val, right, vis);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        vector<TreeNode*> roots(nax, nullptr);\\n        for (TreeNode* r : trees) {\\n            roots[r->val] = r;\\n        }\\n        vector<bool> notRoot(nax);\\n        vector<bool> vis(nax);\\n        for (TreeNode* r : trees) {\\n            vis[r->val] = true;\\n            if (r->left != nullptr) {\\n                vis[r->left->val] = true;\\n            }\\n            if (r->right != nullptr) {\\n                vis[r->right->val] = true;\\n            } \\n        }\\n        for (TreeNode* r : trees) {\\n            if (r->left != nullptr) {\\n                int val = r->left->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->left;\\n                    r->left = roots[val];\\n                    notRoot[val] = true;\\n                }\\n            }\\n            if (r->right != nullptr) {\\n                int val = r->right->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->right;\\n                    r->right = roots[val];\\n                    notRoot[val] = true;\\n                } \\n            }\\n        }\\n        int count = 0;\\n        TreeNode* root = nullptr;\\n        for (TreeNode* r : trees) {\\n            if (!notRoot[r->val]) {\\n                ++count;\\n                root = r;\\n            }\\n        }\\n        if (count > 1) return nullptr;\\n        if (!validate(root, -nax - 1, nax + 1, vis)) return nullptr;\\n        for (int i = 0; i < nax; i++) {\\n            if (vis[i]) return nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960168,
                "title": "python-clean-code",
                "content": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        map = {t.val: t for t in trees}\\n        parents = set(map).difference(\\n            kid.val for t in trees for kid in (t.left, t.right) if kid\\n        )\\n        if len(parents) != 1:\\n            return None\\n\\n        root = map.pop(parents.pop())\\n\\n        q = deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        while q:\\n            node, left, right = q.popleft()\\n            if not left < node.val < right:\\n                return\\n\\n            if node.left:\\n                node.left = map.pop(node.left.val, node.left)\\n                q.append((node.left, left, node.val))\\n\\n            if node.right:\\n                node.right = map.pop(node.right.val, node.right)\\n                q.append((node.right, node.val, right))\\n        if not map:\\n            return root\\n```",
                "solutionTags": [
                    "Queue",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        map = {t.val: t for t in trees}\\n        parents = set(map).difference(\\n            kid.val for t in trees for kid in (t.left, t.right) if kid\\n        )\\n        if len(parents) != 1:\\n            return None\\n\\n        root = map.pop(parents.pop())\\n\\n        q = deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        while q:\\n            node, left, right = q.popleft()\\n            if not left < node.val < right:\\n                return\\n\\n            if node.left:\\n                node.left = map.pop(node.left.val, node.left)\\n                q.append((node.left, left, node.val))\\n\\n            if node.right:\\n                node.right = map.pop(node.right.val, node.right)\\n                q.append((node.right, node.val, right))\\n        if not map:\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958073,
                "title": "python-100-faster-use-dict-with-detailed-comment",
                "content": "**Idea**\\nFirst we build a leaf-value-to-root dict. If we found two leaves with the same value, return None.\\nThen we iterate the trees, if a tree has same value with other leaf(by checking if tree.val is in the dict), it can be merged into it. Otherwise it\\'s our root tree!\\nAfter we finish merging, check if the tree is a valid bst and node count is right.\\nDone.\\n\\n**Some Questions**\\n* Should we check if there are circles in the tree?\\n\\t* technically, yes. However, we have already make sure that won\\'t happen.\\n\\t* think these two cases: [[1,null,3],[3,1],[4,2]] and [[1,null,3],[3,1]]\\n\\t\\t* if circle appears, we will get an incomplete tree after the merging process, node counting will help us check it out.\\n\\t\\t* if circle appears during the merge, it won\\'t be the root node, so we don\\'t need to worry about infinite recursion during node counting\\n\\n**Complexity**\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        # check if root is a valid bst\\n        # l < root.val < r\\n        def _is_validate(root, l, r):\\n            if root is None:\\n                return True\\n            if root.val <= l or root.val >= r:\\n                return False\\n            if not _is_validate(root.left, l, min(root.val, r)):\\n                return False\\n            if not _is_validate(root.right, max(l, root.val), r):\\n                return False\\n            return True\\n        \\n        # calculate node count of root\\n        def _node_cnt(root):\\n            if root is None:\\n                return 0\\n            return 1 + _node_cnt(root.left) + _node_cnt(root.right)\\n        \\n        # m : {key : (root, direction)}\\n        # key if val of the leaf node, val is it\\'s root\\n        m = {}\\n        _total_node_cnt = 0\\n        for root in trees:\\n            _total_node_cnt += 1\\n            if root.left:\\n                if root.left.val in m:\\n                    # if there are two leaf nodes with the same val, trees cannot merge into one valid bst.\\n                    # because leaf values must STRICTLY less or greater than root.\\n                    return None\\n                m[root.left.val] = (root, \\'l\\')\\n                _total_node_cnt += 1\\n            if root.right:\\n                if root.right.val in m:\\n                    return None\\n                m[root.right.val] = (root, \\'r\\')\\n                _total_node_cnt += 1\\n        \\n        ret = None\\n        for root in trees:\\n            if root.val in m:\\n                # root can be merged into other tree\\n                r, dir_ = m[root.val]\\n                if dir_ == \\'l\\':\\n                    r.left = root\\n                else:\\n                    r.right = root\\n                # merge success, two nodes are merged into one.\\n                _total_node_cnt -= 1\\n            elif ret is not None:\\n                # only one tree(\"root tree\") cannot be merged, return None\\n                return None\\n            else:\\n                # if root cannot merge into other tree, we know it\\'s root of the answer\\n                ret = root\\n\\n        return ret if ret and _node_cnt(ret) == _total_node_cnt and _is_validate(ret, -999999, 999999) else None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        # check if root is a valid bst\\n        # l < root.val < r\\n        def _is_validate(root, l, r):\\n            if root is None:\\n                return True\\n            if root.val <= l or root.val >= r:\\n                return False\\n            if not _is_validate(root.left, l, min(root.val, r)):\\n                return False\\n            if not _is_validate(root.right, max(l, root.val), r):\\n                return False\\n            return True\\n        \\n        # calculate node count of root\\n        def _node_cnt(root):\\n            if root is None:\\n                return 0\\n            return 1 + _node_cnt(root.left) + _node_cnt(root.right)\\n        \\n        # m : {key : (root, direction)}\\n        # key if val of the leaf node, val is it\\'s root\\n        m = {}\\n        _total_node_cnt = 0\\n        for root in trees:\\n            _total_node_cnt += 1\\n            if root.left:\\n                if root.left.val in m:\\n                    # if there are two leaf nodes with the same val, trees cannot merge into one valid bst.\\n                    # because leaf values must STRICTLY less or greater than root.\\n                    return None\\n                m[root.left.val] = (root, \\'l\\')\\n                _total_node_cnt += 1\\n            if root.right:\\n                if root.right.val in m:\\n                    return None\\n                m[root.right.val] = (root, \\'r\\')\\n                _total_node_cnt += 1\\n        \\n        ret = None\\n        for root in trees:\\n            if root.val in m:\\n                # root can be merged into other tree\\n                r, dir_ = m[root.val]\\n                if dir_ == \\'l\\':\\n                    r.left = root\\n                else:\\n                    r.right = root\\n                # merge success, two nodes are merged into one.\\n                _total_node_cnt -= 1\\n            elif ret is not None:\\n                # only one tree(\"root tree\") cannot be merged, return None\\n                return None\\n            else:\\n                # if root cannot merge into other tree, we know it\\'s root of the answer\\n                ret = root\\n\\n        return ret if ret and _node_cnt(ret) == _total_node_cnt and _is_validate(ret, -999999, 999999) else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842567,
                "title": "c-solution",
                "content": "\\'\\'\\'\\nvoid helper(TreeNode* root, map<int, TreeNode*> &mp, set<int> &s)\\n    {\\n        if(root==NULL)\\n            return ;\\n        if(mp.size()==1)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            if(mp.find(root->left->val)!=mp.end())\\n            {\\n                root->left = mp[root->left->val];\\n                 mp.erase(root->left->val);\\n            }\\n           \\n        }\\n        if(root->right!=NULL)\\n        {\\n            if(mp.find(root->right->val)!=mp.end())\\n            {\\n                root->right = mp[root->right->val];\\n                mp.erase(root->right->val);\\n            }\\n        }\\n        helper(root->left, mp, s);\\n        helper(root->right, mp, s);\\n        \\n    }\\n    void isBST(TreeNode* root, int &prev, bool &flag)\\n    {\\n        if(root==NULL)\\n            return;\\n        isBST(root->left, prev, flag);\\n        if(prev!=-1)\\n        {\\n            if(prev>=root->val)\\n            {\\n                flag = false;\\n                return;\\n            }\\n            \\n        }\\n        prev = root->val;\\n        isBST(root->right, prev, flag);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    \\n        map<int, TreeNode*> mp;\\n        set<int> s;\\n        int i, n;\\n        n = trees.size();\\n        if(n==0)\\n            return NULL;\\n        if(n==1)\\n            return trees[0];\\n        for(i=0; i<n; i++)\\n        {\\n            TreeNode* temp = trees[i];\\n            if(temp!=NULL)\\n            {\\n                mp[temp->val] = temp;\\n            }\\n            if(temp->left)\\n            {\\n                s.insert(temp->left->val);\\n            }\\n            if(temp->right)\\n            {\\n                s.insert(temp->right->val);\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        for(i=0; i<n; i++)\\n        {\\n            if(s.find(trees[i]->val)==s.end())\\n            {\\n                root= trees[i];\\n                break;\\n            }\\n        }\\n        helper(root, mp, s);\\n        if(mp.size()!=1)\\n            return NULL;\\n        bool flag = true;\\n        int prev = -1;\\n        isBST(root, prev , flag);\\n        if(flag)\\n            return root;\\n        else\\n            return NULL;\\n        \\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "\\'\\'\\'\\nvoid helper(TreeNode* root, map<int, TreeNode*> &mp, set<int> &s)\\n    {\\n        if(root==NULL)\\n            return ;\\n        if(mp.size()==1)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            if(mp.find(root->left->val)!=mp.end())\\n            {\\n                root->left = mp[root->left->val];\\n                 mp.erase(root->left->val);\\n            }\\n           \\n        }\\n        if(root->right!=NULL)\\n        {\\n            if(mp.find(root->right->val)!=mp.end())\\n            {\\n                root->right = mp[root->right->val];\\n                mp.erase(root->right->val);\\n            }\\n        }\\n        helper(root->left, mp, s);\\n        helper(root->right, mp, s);\\n        \\n    }\\n    void isBST(TreeNode* root, int &prev, bool &flag)\\n    {\\n        if(root==NULL)\\n            return;\\n        isBST(root->left, prev, flag);\\n        if(prev!=-1)\\n        {\\n            if(prev>=root->val)\\n            {\\n                flag = false;\\n                return;\\n            }\\n            \\n        }\\n        prev = root->val;\\n        isBST(root->right, prev, flag);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    \\n        map<int, TreeNode*> mp;\\n        set<int> s;\\n        int i, n;\\n        n = trees.size();\\n        if(n==0)\\n            return NULL;\\n        if(n==1)\\n            return trees[0];\\n        for(i=0; i<n; i++)\\n        {\\n            TreeNode* temp = trees[i];\\n            if(temp!=NULL)\\n            {\\n                mp[temp->val] = temp;\\n            }\\n            if(temp->left)\\n            {\\n                s.insert(temp->left->val);\\n            }\\n            if(temp->right)\\n            {\\n                s.insert(temp->right->val);\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        for(i=0; i<n; i++)\\n        {\\n            if(s.find(trees[i]->val)==s.end())\\n            {\\n                root= trees[i];\\n                break;\\n            }\\n        }\\n        helper(root, mp, s);\\n        if(mp.size()!=1)\\n            return NULL;\\n        bool flag = true;\\n        int prev = -1;\\n        isBST(root, prev , flag);\\n        if(flag)\\n            return root;\\n        else\\n            return NULL;\\n        \\n    }\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1834916,
                "title": "intuitive-c-hashing-bst",
                "content": "It is simple for the trees that have only one node. they will not effect the overall tree after merging all the trees. But we just need to check if there is a possible place for them to be merged. If not, we return NULL.\\n\\nThe second observation is after merging 2 trees, one leaf node gets removed and count of trees also reduces by 1. \\n\\nThe third observation is after removing single noded trees, all the leave nodes must be unique. why? if it is not. there will be 2 instances of the node with same count in the final tree. \\n\\nWe create the final tree and check if the final tree is valid or not ( both BST properties and whether the final tree contains all the unique keys given as input)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode * root){\\n       return root->right==NULL and root->left==NULL; \\n    }\\n    \\n    bool addLeaves(TreeNode * root, unordered_map<int, TreeNode*> &map, unordered_set<int> &set){\\n       set.insert(root->val);\\n       if(isLeaf(root)){\\n          if(map.find(root->val)!=map.end()) {\\n              return false;\\n          }\\n          map[root->val] = root;\\n           return true;\\n       }\\n       else{\\n           if(root->left!=NULL){\\n               if(!addLeaves(root->left, map, set)){\\n                   return false;\\n               }\\n           }\\n           if(root->right!=NULL){\\n               if(!addLeaves(root->right, map, set)){\\n                   return false;\\n               }\\n           }\\n           return true;\\n       }\\n    }\\n    void merge(unordered_map<int, TreeNode *> &map, TreeNode * root){\\n        map[root->val]->left = root->left;\\n        map[root->val]->right = root->right;\\n        map.erase(map.find(root->val));\\n    }\\n    int countNodes(TreeNode * root){\\n        if(root==NULL){\\n           return 0; \\n        }\\n        else{\\n            return 1+countNodes(root->left) + countNodes(root->right);\\n        }\\n    }\\n    \\n    pair<int, int> isValid(TreeNode * root){\\n        if(isLeaf(root)){\\n            return {root->val, root->val};\\n        }\\n        \\n        else{\\n            int mn_, mx_;\\n            mn_ = root->val;\\n            mx_ = root->val;\\n            \\n            if(root->left!=NULL){\\n                pair<int, int> l = isValid(root->left);\\n                if(l.first==-1){\\n                    return l;\\n                }\\n                if(l.second>=root->val){\\n                   return {-1, -1} ;\\n                }\\n                else{\\n                    mn_ = l.first;\\n                }\\n            }\\n            if(root->right!=NULL){\\n                pair<int, int> r = isValid(root->right);\\n                if(r.first ==-1){\\n                    return r;\\n                }\\n                if(r.first<=root->val){\\n                    return  {-1, -1};\\n                }\\n                else{\\n                    mx_ = r.second;\\n                }\\n            }\\n            \\n            return {mn_, mx_};\\n        }\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& tree) {\\n        int n = tree.size();\\n        if(n==1){\\n            return tree[0];\\n        }\\n        int count = n;\\n        unordered_map<int, TreeNode*> leaves;\\n        unordered_set<int> all;\\n        for(int i=0;i<n;i++){\\n           if(!isLeaf(tree[i])) {\\n               if(!addLeaves(tree[i], leaves, all)){\\n                   return NULL;\\n               }\\n           }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(isLeaf(tree[i])){\\n                if(leaves.find(tree[i]->val)==leaves.end()){\\n                    return NULL;\\n                }\\n                else{\\n                    tree[i] = NULL;\\n                    count--;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            TreeNode * root = tree[i];\\n            if(root==NULL){\\n                continue;\\n            }\\n            if(leaves.find(root->val)!=leaves.end()){\\n                cout<<root->val<<endl;\\n                merge(leaves, root);\\n                count--;\\n                tree[i] = NULL;\\n            }\\n        }\\n        if(count!=1) {return NULL;}\\n        TreeNode * r =NULL;\\n        for(int i=0;i<n;i++){\\n            if(tree[i]!=NULL){\\n               r = tree[i] ;\\n                break;\\n            }\\n        }\\n        if(isValid(r).first!=-1 and countNodes(r)==all.size())\\n            return r;\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode * root){\\n       return root->right==NULL and root->left==NULL; \\n    }\\n    \\n    bool addLeaves(TreeNode * root, unordered_map<int, TreeNode*> &map, unordered_set<int> &set){\\n       set.insert(root->val);\\n       if(isLeaf(root)){\\n          if(map.find(root->val)!=map.end()) {\\n              return false;\\n          }\\n          map[root->val] = root;\\n           return true;\\n       }\\n       else{\\n           if(root->left!=NULL){\\n               if(!addLeaves(root->left, map, set)){\\n                   return false;\\n               }\\n           }\\n           if(root->right!=NULL){\\n               if(!addLeaves(root->right, map, set)){\\n                   return false;\\n               }\\n           }\\n           return true;\\n       }\\n    }\\n    void merge(unordered_map<int, TreeNode *> &map, TreeNode * root){\\n        map[root->val]->left = root->left;\\n        map[root->val]->right = root->right;\\n        map.erase(map.find(root->val));\\n    }\\n    int countNodes(TreeNode * root){\\n        if(root==NULL){\\n           return 0; \\n        }\\n        else{\\n            return 1+countNodes(root->left) + countNodes(root->right);\\n        }\\n    }\\n    \\n    pair<int, int> isValid(TreeNode * root){\\n        if(isLeaf(root)){\\n            return {root->val, root->val};\\n        }\\n        \\n        else{\\n            int mn_, mx_;\\n            mn_ = root->val;\\n            mx_ = root->val;\\n            \\n            if(root->left!=NULL){\\n                pair<int, int> l = isValid(root->left);\\n                if(l.first==-1){\\n                    return l;\\n                }\\n                if(l.second>=root->val){\\n                   return {-1, -1} ;\\n                }\\n                else{\\n                    mn_ = l.first;\\n                }\\n            }\\n            if(root->right!=NULL){\\n                pair<int, int> r = isValid(root->right);\\n                if(r.first ==-1){\\n                    return r;\\n                }\\n                if(r.first<=root->val){\\n                    return  {-1, -1};\\n                }\\n                else{\\n                    mx_ = r.second;\\n                }\\n            }\\n            \\n            return {mn_, mx_};\\n        }\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& tree) {\\n        int n = tree.size();\\n        if(n==1){\\n            return tree[0];\\n        }\\n        int count = n;\\n        unordered_map<int, TreeNode*> leaves;\\n        unordered_set<int> all;\\n        for(int i=0;i<n;i++){\\n           if(!isLeaf(tree[i])) {\\n               if(!addLeaves(tree[i], leaves, all)){\\n                   return NULL;\\n               }\\n           }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(isLeaf(tree[i])){\\n                if(leaves.find(tree[i]->val)==leaves.end()){\\n                    return NULL;\\n                }\\n                else{\\n                    tree[i] = NULL;\\n                    count--;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            TreeNode * root = tree[i];\\n            if(root==NULL){\\n                continue;\\n            }\\n            if(leaves.find(root->val)!=leaves.end()){\\n                cout<<root->val<<endl;\\n                merge(leaves, root);\\n                count--;\\n                tree[i] = NULL;\\n            }\\n        }\\n        if(count!=1) {return NULL;}\\n        TreeNode * r =NULL;\\n        for(int i=0;i<n;i++){\\n            if(tree[i]!=NULL){\\n               r = tree[i] ;\\n                break;\\n            }\\n        }\\n        if(isValid(r).first!=-1 and countNodes(r)==all.size())\\n            return r;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1819537,
                "title": "simple-solution",
                "content": "class Solution {\\npublic:\\n    bool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }\\n    }\\n    return traverse(r->left, m, min_left, r->val) && traverse(r->right, m, r->val, max_right);\\n}    \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> m;\\n    unordered_map<int, int> cnt;\\n    for (auto &t : trees) {\\n        m[t->val] = t;\\n        ++cnt[t->val];\\n        ++cnt[t->left ? t->left->val : 0];\\n        ++cnt[t->right ? t->right->val : 0];\\n    }\\n    for (auto &t : trees)\\n        if (cnt[t->val] == 1)\\n            return traverse(t, m) && m.size() == 1 ? t : nullptr;\\n    return nullptr;\\n}\\n};",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1780958,
                "title": "java-simple-bfs",
                "content": "~~~java\\n\\nclass Solution {\\n    Map<Integer, TreeNode> rootVals = new HashMap<>();\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        TreeNode root = findRoot(trees);\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        for (TreeNode t : trees) {\\n            rootVals.put(t.val, t);\\n        }\\n        \\n        bfs(root);\\n        \\n        if (!isValidBST(root) || rootVals.size() != 1) {\\n            return null;\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private TreeNode findRoot(List<TreeNode> trees) {\\n        TreeNode root = null;\\n        Map<Integer, Integer> valCnts = new HashMap<>();\\n        for (TreeNode t : trees) {\\n            valCnts.put(t.val, valCnts.getOrDefault(t.val, 0) + 1);\\n            if (t.left != null) {\\n                valCnts.put(t.left.val, valCnts.getOrDefault(t.left.val, 0) + 1);\\n            }\\n            if (t.right != null) {\\n                valCnts.put(t.right.val, valCnts.getOrDefault(t.right.val, 0) + 1);\\n            }\\n        }\\n        \\n        for (TreeNode t : trees) {\\n            if (valCnts.get(t.val) == 1) {\\n                if (root == null) {\\n                    root = t;\\n                } else {\\n                    return null;\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private void bfs(TreeNode root) {\\n        Queue<TreeNode> q = new ArrayDeque<>();\\n        q.offer(root);\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode parent = q.poll();\\n                if (parent.left != null && rootVals.containsKey(parent.left.val)) {\\n                    TreeNode toConnect = rootVals.get(parent.left.val);\\n                    rootVals.remove(toConnect.val);\\n                    parent.left = toConnect;\\n                    q.offer(parent.left);\\n                }\\n                if (parent.right != null && rootVals.containsKey(parent.right.val)) {\\n                    TreeNode toConnect = rootVals.get(parent.right.val);\\n                    rootVals.remove(toConnect.val);\\n                    parent.right = toConnect;\\n                    q.offer(parent.right);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    private boolean isValidBST(TreeNode root, int min, int max) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val <= min || root.val >= max) {\\n            return false;\\n        }\\n        \\n        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer, TreeNode> rootVals = new HashMap<>();\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        TreeNode root = findRoot(trees);\\n        if (root == null) {\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1780098,
                "title": "javascript-hashmaps-root-to-value-mapping",
                "content": "A few things to keep in mind:\\n* **All root values are unique.**\\n* **To create a valid BST, all root values (except the final root) must map to exactly one leaf value (there cannot be multiple leaf values which are the same)**\\n----\\n1. Map roots to their matching leaves. Also keep track of the total count of nodes.\\n  This total count would have counted every single node once, so after joining into a valid BST, exactly n - 1 nodes would have been counted twice. \\n  So, we subtract n - 1 from our nodes count.\\n2. Get the root which doesn\\'t map to any leaf node, this is the final root.\\n3. Merge all the leaves -> roots together.\\n4. Validate the final tree. \\n----\\n**Time Complexity: O(n) 516ms\\nSpace Complexity: O(n) 79.1MB**\\n\\n```\\nvar canMerge = function(trees) {\\n  let leaves = new Map(), roots = new Set(), nodesCnt = 0, n = trees.length;\\n\\n  // map roots to matching leaves\\n  for (let tree of trees) {\\n    roots.add(tree.val);\\n    nodesCnt++;\\n    if (tree.left) {\\n      leaves.set(tree.left.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n    if (tree.right) {\\n      leaves.set(tree.right.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n  }\\n  nodesCnt = nodesCnt - (n - 1); // there are exactly n - 1 overlapping nodes counted\\n  \\n  // get the finalRoot\\n  let finalRoot = null;\\n  for (let tree of trees) {\\n    if (!leaves.has(tree.val)) {\\n      finalRoot = tree;\\n    }\\n  }\\n  \\n  for (let tree of trees) {\\n    if (tree !== finalRoot && leaves.has(tree.val)) {\\n      let leafParent = leaves.get(tree.val);\\n      if (leafParent.left && leafParent.left.val === tree.val) {\\n        leafParent.left = tree;\\n      } else {\\n        leafParent.right = tree;\\n      }\\n      roots.delete(tree.val); // after merging, delete the root. There should be exactly 1 root left at the end.\\n    }\\n  }\\n  // must be one root left, and node count must equal the total nodes\\n  return roots.size === 1 && countNodes(finalRoot) === nodesCnt ? finalRoot : null;\\n};\\n\\nfunction countNodes(root, min = -Infinity, max = Infinity) {\\n  if (!root) return 0;\\n  if (root.val <= min || root.val >= max) return 0;\\n  return 1 + countNodes(root.left, min, root.val) + countNodes(root.right, root.val, max);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canMerge = function(trees) {\\n  let leaves = new Map(), roots = new Set(), nodesCnt = 0, n = trees.length;\\n\\n  // map roots to matching leaves\\n  for (let tree of trees) {\\n    roots.add(tree.val);\\n    nodesCnt++;\\n    if (tree.left) {\\n      leaves.set(tree.left.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n    if (tree.right) {\\n      leaves.set(tree.right.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n  }\\n  nodesCnt = nodesCnt - (n - 1); // there are exactly n - 1 overlapping nodes counted\\n  \\n  // get the finalRoot\\n  let finalRoot = null;\\n  for (let tree of trees) {\\n    if (!leaves.has(tree.val)) {\\n      finalRoot = tree;\\n    }\\n  }\\n  \\n  for (let tree of trees) {\\n    if (tree !== finalRoot && leaves.has(tree.val)) {\\n      let leafParent = leaves.get(tree.val);\\n      if (leafParent.left && leafParent.left.val === tree.val) {\\n        leafParent.left = tree;\\n      } else {\\n        leafParent.right = tree;\\n      }\\n      roots.delete(tree.val); // after merging, delete the root. There should be exactly 1 root left at the end.\\n    }\\n  }\\n  // must be one root left, and node count must equal the total nodes\\n  return roots.size === 1 && countNodes(finalRoot) === nodesCnt ? finalRoot : null;\\n};\\n\\nfunction countNodes(root, min = -Infinity, max = Infinity) {\\n  if (!root) return 0;\\n  if (root.val <= min || root.val >= max) return 0;\\n  return 1 + countNodes(root.left, min, root.val) + countNodes(root.right, root.val, max);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1728235,
                "title": "go-inorder-traversal",
                "content": "Each BST can be considered a node in the merged tree, where leaves are edges toward other BSTs. With this viewpoint, construction of the tree (from the BSTs) is possible only if there is a single node (BST) which does not have an in-degree of zero.\\n\\nAt this point there may still not be a valid solution: two BSTs may point to each-other (`[2,1]`, `[1,2]`). To keep track of this, we mark each node as seen in a map.\\n\\nFinally, to validate the tree at the same time as its being constructed, merge BSTs in-order.\\n\\nFor this exercise I tried working with pointers to pointers just to practice. It could easily be replaced with more simple `if n.Left != nil` statements.\\n\\n```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tindeg := make(map[int]int)\\n\\tnodes := make(map[int]*TreeNode)\\n\\n\\t// Helper for maybe counting indegrees / adding to global nodes map\\n\\tmaybeAdd := func(n *TreeNode) {\\n\\t\\tif n == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tindeg[n.Val]++\\n\\t\\tif _, exists := nodes[n.Val]; !exists {\\n\\t\\t\\tnodes[n.Val] = n\\n\\t\\t}\\n\\t}\\n\\t// Count in-degrees and collect nodes into the nodes map\\n\\tfor _, t := range trees {\\n\\t\\tif _, exists := indeg[t.Val]; !exists {\\n\\t\\t\\tindeg[t.Val] = 0\\n\\t\\t}\\n\\t\\tnodes[t.Val] = t // overrides leaf node (if any)\\n\\t\\tmaybeAdd(t.Left)\\n\\t\\tmaybeAdd(t.Right)\\n\\t}\\n\\n\\t// Only one node should have an indegree of zero - the root\\n\\tvar root *TreeNode\\n\\tfor v, deg := range indeg {\\n\\t\\tif deg == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif root != nil {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\troot = nodes[v]\\n\\t}\\n\\n\\t// Perform inorder traversal of nodes, ensuring that each node is the node\\n\\t// in the nodes map. This will override leaf node addresses with the roots\\n\\t// they should be attached to\\n\\tseen := make(map[int]bool)\\n\\tmin := math.MinInt32\\n\\tvar inorder func(n **TreeNode) bool\\n\\tinorder = func(n **TreeNode) bool {\\n\\t\\tif (*n) == nil {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tseen[(*n).Val] = true\\n\\n\\t\\t// Replace current node (which may be a leaf) with 1. root, 2. leaf\\n\\t\\t// If it is the root itself, then this is a no-op\\n\\t\\tif m, exists := nodes[(*n).Val]; exists {\\n\\t\\t\\t*n = m // Replace pointers to this node with the map entry\\n\\t\\t}\\n\\n\\t\\tif !inorder(&((*n).Left)) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Check current node against min value\\n\\t\\tif (*n).Val <= min {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Update lower bound based on the currently visited node\\n\\t\\t// this will work because we are performing in-order traversal\\n\\t\\tmin = (*n).Val\\n\\n\\t\\treturn inorder(&(*n).Right)\\n\\t}\\n\\n\\tif !inorder(&root) || len(seen) != len(nodes) {\\n\\t\\treturn nil\\n\\t}\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tindeg := make(map[int]int)\\n\\tnodes := make(map[int]*TreeNode)\\n\\n\\t// Helper for maybe counting indegrees / adding to global nodes map\\n\\tmaybeAdd := func(n *TreeNode) {\\n\\t\\tif n == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tindeg[n.Val]++\\n\\t\\tif _, exists := nodes[n.Val]; !exists {\\n\\t\\t\\tnodes[n.Val] = n\\n\\t\\t}\\n\\t}\\n\\t// Count in-degrees and collect nodes into the nodes map\\n\\tfor _, t := range trees {\\n\\t\\tif _, exists := indeg[t.Val]; !exists {\\n\\t\\t\\tindeg[t.Val] = 0\\n\\t\\t}\\n\\t\\tnodes[t.Val] = t // overrides leaf node (if any)\\n\\t\\tmaybeAdd(t.Left)\\n\\t\\tmaybeAdd(t.Right)\\n\\t}\\n\\n\\t// Only one node should have an indegree of zero - the root\\n\\tvar root *TreeNode\\n\\tfor v, deg := range indeg {\\n\\t\\tif deg == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif root != nil {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\troot = nodes[v]\\n\\t}\\n\\n\\t// Perform inorder traversal of nodes, ensuring that each node is the node\\n\\t// in the nodes map. This will override leaf node addresses with the roots\\n\\t// they should be attached to\\n\\tseen := make(map[int]bool)\\n\\tmin := math.MinInt32\\n\\tvar inorder func(n **TreeNode) bool\\n\\tinorder = func(n **TreeNode) bool {\\n\\t\\tif (*n) == nil {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tseen[(*n).Val] = true\\n\\n\\t\\t// Replace current node (which may be a leaf) with 1. root, 2. leaf\\n\\t\\t// If it is the root itself, then this is a no-op\\n\\t\\tif m, exists := nodes[(*n).Val]; exists {\\n\\t\\t\\t*n = m // Replace pointers to this node with the map entry\\n\\t\\t}\\n\\n\\t\\tif !inorder(&((*n).Left)) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Check current node against min value\\n\\t\\tif (*n).Val <= min {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Update lower bound based on the currently visited node\\n\\t\\t// this will work because we are performing in-order traversal\\n\\t\\tmin = (*n).Val\\n\\n\\t\\treturn inorder(&(*n).Right)\\n\\t}\\n\\n\\tif !inorder(&root) || len(seen) != len(nodes) {\\n\\t\\treturn nil\\n\\t}\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668572,
                "title": "java-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n List<Integer>  list = new ArrayList<>();\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Set<Integer> allVals = new HashSet<>();\\n        Set<Integer> set = new HashSet<>();\\n        HashMap<Integer,TreeNode> roots = new HashMap<>();\\n        for(TreeNode node : trees){\\n            roots.put(node.val,node);\\n            allVals.add(node.val);\\n            if(node.left!=null){\\n                set.add(node.left.val);\\n                allVals.add(node.left.val);\\n            }\\n            if(node.right!=null){\\n                set.add(node.right.val);\\n                allVals.add(node.right.val);\\n            }\\n        }\\n        Set<Integer> possibleRoots = new HashSet<>();\\n        for(TreeNode node : trees){\\n            if(!set.contains(node.val)){\\n                possibleRoots.add(node.val);\\n            }\\n        }\\n        if(possibleRoots.size()>1 || possibleRoots.isEmpty()){\\n            return null;\\n        }\\n        Integer root = possibleRoots.iterator().next();\\n        TreeNode mainRoot = roots.get(root);\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(roots.get(root));\\n        Set<Integer> visited = new HashSet<>();\\n        while(!queue.isEmpty()){\\n            TreeNode curr = queue.poll();\\n            if(curr!=null && !visited.contains(curr.val)){\\n                visited.add(curr.val);\\n                if(curr.left!=null && roots.containsKey(curr.left.val)){\\n                    curr.left = roots.get(curr.left.val);\\n                }\\n                if(curr.right!=null && roots.containsKey(curr.right.val)){\\n                    curr.right = roots.get(curr.right.val);\\n                }\\n                roots.remove(curr.val);\\n                queue.add(curr.left);\\n                queue.add(curr.right);\\n            }\\n        }\\n        dfs(mainRoot);\\n        for(int i =0;i+1<list.size();i++){\\n            if(list.get(i)>=list.get(i+1)){\\n                return null;\\n            }\\n        }\\n        Set<Integer> lVals = new HashSet<>(list);\\n        for(int num : allVals){\\n            if(!lVals.contains(num)){\\n                return null;\\n            }\\n        }\\n        return mainRoot;\\n    }\\n   \\n    \\n    void dfs(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        dfs(root.left);\\n        list.add(root.val);\\n        dfs(root.right);\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n List<Integer>  list = new ArrayList<>();\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Set<Integer> allVals = new HashSet<>();\\n        Set<Integer> set = new HashSet<>();\\n        HashMap<Integer,TreeNode> roots = new HashMap<>();\\n        for(TreeNode node : trees){\\n            roots.put(node.val,node);\\n            allVals.add(node.val);\\n            if(node.left!=null){\\n                set.add(node.left.val);\\n                allVals.add(node.left.val);\\n            }\\n            if(node.right!=null){\\n                set.add(node.right.val);\\n                allVals.add(node.right.val);\\n            }\\n        }\\n        Set<Integer> possibleRoots = new HashSet<>();\\n        for(TreeNode node : trees){\\n            if(!set.contains(node.val)){\\n                possibleRoots.add(node.val);\\n            }\\n        }\\n        if(possibleRoots.size()>1 || possibleRoots.isEmpty()){\\n            return null;\\n        }\\n        Integer root = possibleRoots.iterator().next();\\n        TreeNode mainRoot = roots.get(root);\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(roots.get(root));\\n        Set<Integer> visited = new HashSet<>();\\n        while(!queue.isEmpty()){\\n            TreeNode curr = queue.poll();\\n            if(curr!=null && !visited.contains(curr.val)){\\n                visited.add(curr.val);\\n                if(curr.left!=null && roots.containsKey(curr.left.val)){\\n                    curr.left = roots.get(curr.left.val);\\n                }\\n                if(curr.right!=null && roots.containsKey(curr.right.val)){\\n                    curr.right = roots.get(curr.right.val);\\n                }\\n                roots.remove(curr.val);\\n                queue.add(curr.left);\\n                queue.add(curr.right);\\n            }\\n        }\\n        dfs(mainRoot);\\n        for(int i =0;i+1<list.size();i++){\\n            if(list.get(i)>=list.get(i+1)){\\n                return null;\\n            }\\n        }\\n        Set<Integer> lVals = new HashSet<>(list);\\n        for(int num : allVals){\\n            if(!lVals.contains(num)){\\n                return null;\\n            }\\n        }\\n        return mainRoot;\\n    }\\n   \\n    \\n    void dfs(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        dfs(root.left);\\n        list.add(root.val);\\n        dfs(root.right);\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668267,
                "title": "easy-hash-map-bfs-implementation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool valid(TreeNode* x,int mn=INT_MIN,int mx=INT_MAX){\\n        if(!x) return 1;\\n        if(x->val<=mn or x->val>=mx) return 0;\\n        return (valid(x->left,mn,x->val)&valid(x->right,x->val,mx));\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        map<int,TreeNode*>t;\\n        map<int,int>cnt;\\n        for(TreeNode* x: trees){\\n            if(x) t[x->val]=x,cnt[x->val]++;\\n            if(x->left) cnt[x->left->val]++;\\n            if(x->right) cnt[x->right->val]++;\\n        }\\n        for(auto x: cnt){\\n            if(x.second==1 and t.count(x.first)){\\n                TreeNode* ans = t[x.first];\\n                queue<TreeNode*>q;\\n                q.push(ans);\\n                while(q.size()){\\n                    TreeNode* f=q.front();\\n                    q.pop();\\n                    if(!(f->left) and !(f->right)){\\n                        if(t.count(f->val) and t[f->val]!=f){\\n                            f->left=t[f->val]->left;\\n                            f->right=t[f->val]->right;\\n                            t.erase(f->val);\\n                        }\\n                    }\\n                    if(f->left) q.push(f->left);\\n                    if(f->right) q.push(f->right);\\n                }\\n                if(valid(ans)&&t.size()==1) return ans;   // check if the BST is valid or not\\n            }\\n        }\\n        TreeNode *tmp = NULL;\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(TreeNode* x,int mn=INT_MIN,int mx=INT_MAX){\\n        if(!x) return 1;\\n        if(x->val<=mn or x->val>=mx) return 0;\\n        return (valid(x->left,mn,x->val)&valid(x->right,x->val,mx));\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        map<int,TreeNode*>t;\\n        map<int,int>cnt;\\n        for(TreeNode* x: trees){\\n            if(x) t[x->val]=x,cnt[x->val]++;\\n            if(x->left) cnt[x->left->val]++;\\n            if(x->right) cnt[x->right->val]++;\\n        }\\n        for(auto x: cnt){\\n            if(x.second==1 and t.count(x.first)){\\n                TreeNode* ans = t[x.first];\\n                queue<TreeNode*>q;\\n                q.push(ans);\\n                while(q.size()){\\n                    TreeNode* f=q.front();\\n                    q.pop();\\n                    if(!(f->left) and !(f->right)){\\n                        if(t.count(f->val) and t[f->val]!=f){\\n                            f->left=t[f->val]->left;\\n                            f->right=t[f->val]->right;\\n                            t.erase(f->val);\\n                        }\\n                    }\\n                    if(f->left) q.push(f->left);\\n                    if(f->right) q.push(f->right);\\n                }\\n                if(valid(ans)&&t.size()==1) return ans;   // check if the BST is valid or not\\n            }\\n        }\\n        TreeNode *tmp = NULL;\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654034,
                "title": "javascript-solution",
                "content": "```\\nvar canMerge = function (trees) {\\n  mergeTrees(trees);\\n  const unmerged = trees.filter((p) => !p.merged);\\n  return unmerged.length > 1 ? null : unmerged[0];\\n};\\n\\nfunction mergeTrees(trees) {\\n  const leaves = extractAllLeaves(trees);\\n  for (let child of trees) {\\n    const possibleParents = leaves.get(child.val);\\n    if (!possibleParents) {\\n      continue;\\n    }\\n    for (let entry of possibleParents) {\\n      const root = entry.root;\\n      const leaf = entry.leaf;\\n      if (leaf == child || leaf == null) {\\n        continue;\\n      }\\n      tryMerge(root, leaf, child);\\n    }\\n  }\\n}\\n\\nfunction extractAllLeaves(trees) {\\n  const allLeaves = new Map();\\n  for (let tree of trees) {\\n    extractLeaves(tree);\\n    for (let [k, v] of tree.leaves.entries()) {\\n      allLeaves.set(k, (allLeaves.get(k) ?? []).concat(v));\\n    }\\n  }\\n  return allLeaves;\\n}\\nfunction tryMerge(parent, leaf, child) {\\n  if (!parent.ultimateRoot) {\\n    parent.ultimateRoot = parent;\\n  }\\n\\n  merge(parent, leaf, child);\\n\\n  if (validBst(parent.ultimateRoot)) {\\n    parent.ultimateRoot.leaves.delete(leaf.val);\\n    for (let [k, v] of child.leaves) {\\n      parent.ultimateRoot.leaves.set(k, v);\\n    }\\n  } else {\\n    undoMerge(leaf, child);\\n  }\\n}\\n\\nfunction validBst(\\n  root,\\n  min = Number.NEGATIVE_INFINITY,\\n  max = Number.POSITIVE_INFINITY\\n) {\\n  if (!root) return true;\\n  if (root.val <= min || root.val >= max) return false;\\n  return (\\n    validBst(root.left, min, Math.min(root.val, max)) &&\\n    validBst(root.right, Math.max(root.val, min), max)\\n  );\\n}\\n\\nfunction undoMerge(leaf, child) {\\n  leaf.left = null;\\n  leaf.right = null;\\n  child.ultimateRoot = child;\\n  child.merged = false;\\n}\\n\\nfunction merge(parent, leaf, child) {\\n  leaf.left = child.left;\\n  leaf.right = child.right;\\n  child.ultimateRoot = parent;\\n  child.merged = true;\\n}\\n\\nfunction extractLeaves(root) {\\n  if (root.leaves) return;\\n  root.leaves = new Map();\\n  dfs(root);\\n  function dfs(node) {\\n    if (!node) return;\\n    if (!node.left && !node.right) {\\n      root.leaves.set(node.val, { root, leaf: node });\\n    }\\n    dfs(node.left);\\n    dfs(node.right);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canMerge = function (trees) {\\n  mergeTrees(trees);\\n  const unmerged = trees.filter((p) => !p.merged);\\n  return unmerged.length > 1 ? null : unmerged[0];\\n};\\n\\nfunction mergeTrees(trees) {\\n  const leaves = extractAllLeaves(trees);\\n  for (let child of trees) {\\n    const possibleParents = leaves.get(child.val);\\n    if (!possibleParents) {\\n      continue;\\n    }\\n    for (let entry of possibleParents) {\\n      const root = entry.root;\\n      const leaf = entry.leaf;\\n      if (leaf == child || leaf == null) {\\n        continue;\\n      }\\n      tryMerge(root, leaf, child);\\n    }\\n  }\\n}\\n\\nfunction extractAllLeaves(trees) {\\n  const allLeaves = new Map();\\n  for (let tree of trees) {\\n    extractLeaves(tree);\\n    for (let [k, v] of tree.leaves.entries()) {\\n      allLeaves.set(k, (allLeaves.get(k) ?? []).concat(v));\\n    }\\n  }\\n  return allLeaves;\\n}\\nfunction tryMerge(parent, leaf, child) {\\n  if (!parent.ultimateRoot) {\\n    parent.ultimateRoot = parent;\\n  }\\n\\n  merge(parent, leaf, child);\\n\\n  if (validBst(parent.ultimateRoot)) {\\n    parent.ultimateRoot.leaves.delete(leaf.val);\\n    for (let [k, v] of child.leaves) {\\n      parent.ultimateRoot.leaves.set(k, v);\\n    }\\n  } else {\\n    undoMerge(leaf, child);\\n  }\\n}\\n\\nfunction validBst(\\n  root,\\n  min = Number.NEGATIVE_INFINITY,\\n  max = Number.POSITIVE_INFINITY\\n) {\\n  if (!root) return true;\\n  if (root.val <= min || root.val >= max) return false;\\n  return (\\n    validBst(root.left, min, Math.min(root.val, max)) &&\\n    validBst(root.right, Math.max(root.val, min), max)\\n  );\\n}\\n\\nfunction undoMerge(leaf, child) {\\n  leaf.left = null;\\n  leaf.right = null;\\n  child.ultimateRoot = child;\\n  child.merged = false;\\n}\\n\\nfunction merge(parent, leaf, child) {\\n  leaf.left = child.left;\\n  leaf.right = child.right;\\n  child.ultimateRoot = parent;\\n  child.merged = true;\\n}\\n\\nfunction extractLeaves(root) {\\n  if (root.leaves) return;\\n  root.leaves = new Map();\\n  dfs(root);\\n  function dfs(node) {\\n    if (!node) return;\\n    if (!node.left && !node.right) {\\n      root.leaves.set(node.val, { root, leaf: node });\\n    }\\n    dfs(node.left);\\n    dfs(node.right);\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653163,
                "title": "python-translation-of-votrubac-s-just-do-what-it-says",
                "content": "Giving full credit to: https://leetcode.com/problems/merge-bsts-to-create-single-bst/discuss/1330387/Just-do-what-it-says\\n\\n```\\nclass Solution:\\n    def traverse(self, node, dct, lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n        if not node:\\n            return True\\n        val = node.val\\n        if not (lower < val < upper):\\n            return False\\n        if not node.left and not node.right:\\n            if val in dct:\\n                node.left = dct[val].left\\n                node.right = dct[val].right\\n                del dct[val]\\n        return self.traverse(node.left, dct, lower, val) and self.traverse(node.right, dct, val, upper)\\n\\t\\t\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        valCnt, rootDct = defaultdict(int), {}\\n        for t in trees:\\n            rootDct[t.val] = t\\n            valCnt[t.val] += 1\\n            for c in (t.left, t.right):\\n                if c:\\n                    valCnt[c.val] += 1\\n        for t in trees:\\n            if valCnt[t.val] == 1:\\n                if self.traverse(t, rootDct) and len(rootDct) <= 1:\\n                    return t\\n                else:\\n                    return None\\n        return None  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def traverse(self, node, dct, lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n        if not node:\\n            return True\\n        val = node.val\\n        if not (lower < val < upper):\\n            return False\\n        if not node.left and not node.right:\\n            if val in dct:\\n                node.left = dct[val].left\\n                node.right = dct[val].right\\n                del dct[val]\\n        return self.traverse(node.left, dct, lower, val) and self.traverse(node.right, dct, val, upper)\\n\\t\\t\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        valCnt, rootDct = defaultdict(int), {}\\n        for t in trees:\\n            rootDct[t.val] = t\\n            valCnt[t.val] += 1\\n            for c in (t.left, t.right):\\n                if c:\\n                    valCnt[c.val] += 1\\n        for t in trees:\\n            if valCnt[t.val] == 1:\\n                if self.traverse(t, rootDct) and len(rootDct) <= 1:\\n                    return t\\n                else:\\n                    return None\\n        return None  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598315,
                "title": "java-solution-using-hashtables-and-priority-queue",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n/*\\n\\nURL = https://leetcode.com/problems/merge-bsts-to-create-single-bst/ \\n1932. Merge BSTs to Create Single BST\\n\\nLet us leverage the invariant that node values in the node\\'s LST have value STRICTLY LESS than the root\\'s value\\nand nodes in the right subtree have value STRICTLY MORE than node\\'s value\\n\\nNote : we may be able to form \\n\\nHINT : leverage a hashmap\\n    -> store the min values and max values of BSTs ( seen in other problems ) \\n    \\nCOMPLEXITY\\nTime = ___\\nSpace = ___\\n\\nNode vals are known to be positives in range of [1,50000]\\n[[3],[3,1]] is luckily invalid anyways!\\n\\nTEST CASES\\n(A)[[2,1],[3,2,5],[5,4]] \\n(B) [[3],[4,3]]\\n    [4,3] = expected\\n(C)\\n(D)\\n(E)\\n\\nAlso this is a list, so deletion may or may not be possible. But a hashmap conversion also entails alacrity as well\\nNo two roots have same value -> we are in luck here too!\\nReturn null if a root is not able to be ascertained as well.\\nCount number of trees too ( hey you queue root ste handles this ! ) \\n\\n\\nRemember that we must maintain the count of operatinos here too\\n\\nStrategies : Hashtable, Queue, BFS ( Fringe-esque manner ) or DFS ( fringe-esque manner )\\n            I am unsure how binary search could help here though?\\n\\nYou forgot the case where the root may not even possess two children nodes ( e.g. 2L1 )\\nIn this case, we may get an overlap ( e.g. 2R3 )\\nThis is still a valid operation, and the fringe may have involved the root here as well. Exert caution now!\\n\\n*/\\nclass Solution \\n{\\n    \\n    public class Wrapper\\n    {\\n        public TreeNode node;\\n        public int min;\\n        public int max;\\n        \\n        public Wrapper()\\n        {\\n            this.node = null;\\n            min = 0;\\n            max = 50001; // ma of 50,000\\n            // min = Integer.MIN_VALUE;\\n            // max = Integer.MAX_VALUE;\\n        }\\n        \\n        // The \"this\" keyword is really a self-referential pointer in the hiding\\n        public Wrapper(TreeNode node, int min, int max)\\n        {\\n            this.node = node;\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    \\n    // Range Info hashmap should be based on integers ... NOT on node addresses ( can cause a trip up with fringe analysis : leaf(1) != root(1) case ) \\n    public TreeNode canMerge(List<TreeNode> trees) \\n    {\\n        TreeNode newRoot = null;\\n        List<Wrapper> fringe = new ArrayList<Wrapper>();\\n        Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n        HashMap<Integer, Wrapper> rangeInfo = new HashMap<Integer, Wrapper>();\\n        Set<Integer> rootSet = new HashSet<Integer>();\\n        \\n        if(trees == null || trees.size() == 0)\\n        {\\n            return null;\\n        }\\n        int n = trees.size();\\n        \\n        // [1] Initialize the HASHMAP with initialize range info for all rooted nodes\\n        // [2] In same for loop, add the nodes to the queue as well\\n        for(int i = 0; i < n; ++i)\\n        {\\n            TreeNode cur = trees.get(i);\\n            Wrapper metadata = new Wrapper();\\n            if(cur != null && !rangeInfo.containsKey(cur.val))\\n            {\\n                metadata.node = cur;\\n                if(cur.left != null)\\n                {\\n                    metadata.min = cur.left.val;\\n                }\\n                if(cur.right != null)\\n                {\\n                    metadata.max = cur.right.val;\\n                }\\n                rangeInfo.put(cur.val, metadata);\\n            }\\n            toExplore.add(cur);\\n        }\\n        // toExplore.add(toExplore.poll()); // Just add the first node to the end ( as we are already there anyways ) \\n        // System.out.printf(\"toExplore size = %d\\\\n\", toExplore.size());\\n        \\n        // [3] Initialize the fringe and first root node, along with the root set\\n        // Make sure the fringe itself is properly initialized here : we pass in these values later, depending on direction of add as well\\n        // Oh and make sure the root is part of the fringe set as well : hey we could get a bad case as well\\n        // But the root case begets much caution too ... as this fringe is not guaranteed its emptiness\\n        // One possibility : go fill that up, if possible , and then proceed with the legitimate fringe as expected\\n        // Wait we need not add the root to the fringe -> as the root trees differ, and a fringe must be a leaf\\n        // But what if the root HAS no leaves? \\n        // Well that is a special case indeed. Is in itself a frige at this point\\n        \\n        \\n        newRoot = toExplore.peek();\\n        if(newRoot.left == null && newRoot.right == null)\\n        {\\n            fringe.add(rangeInfo.get(newRoot.val));\\n        }\\n        if(newRoot.left != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n        }\\n        if(newRoot.right != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n        }\\n        \\n        // [4] The meat of our algorithm here\\n//         List<Wrapper> fringe = new ArrayList<Wrapper>();\\n//         Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n//         HashMap<TreeNode, Wrapper> rangeInfo = new HashMap<TreeNode, Wrapper>();\\n//         Set<TreeNode> rootSet = new HashSet<TreeNode>();\\n        \\n        // Handle null pointer exception later\\n        while(!toExplore.isEmpty())\\n        {\\n            while(!fringe.isEmpty())\\n            {\\n                // If either children are null : well hey, they are infinites too. Leverage that as well.\\n                // System.out.printf(\"Evaluating fringe\\\\n\");\\n                Wrapper fringeWrapper = fringe.remove(0);\\n                TreeNode fringeNode = fringeWrapper.node; \\n                if(fringeNode == newRoot)\\n                {\\n                    // System.out.printf(\"Fringe = new root\\\\n\");\\n                    continue; // ignore this case\\n                }\\n                // Go remove a former root, if we end up adding it anyways!\\n                if(rootSet.contains(fringeNode.val))\\n                {\\n                    // System.out.printf(\"Removing node [%d] from root set\\\\n\", fringeNode.val);\\n                    rootSet.remove(fringeNode.val);\\n                }\\n                int fringeMin = fringeWrapper.min;\\n                int fringeMax = fringeWrapper.max;\\n                if(rangeInfo.containsKey(fringeNode.val))\\n                {\\n                    // Now perform range tests , as an appends is a possibility here\\n                    // remember this : the append in itself is just the hashmaps left and right too : why not just port that over?\\n                    Wrapper connecteeMeta = rangeInfo.get(fringeNode.val);\\n                    TreeNode connectee = connecteeMeta.node;\\n                    int connecteeMin = connecteeMeta.min;\\n                    int connecteeMax = connecteeMeta.max;\\n                    \\n                    // Not sure about handling -INT_MIN, INT_MAX cases though. A bit lost there in the connection setup\\n                    // Handle as single child or dual child cases instead ( you incorporated flag values 0,50001 for this ) \\n                    // wait a second .. on the fringe, you may have a case where it has a flag as well. Shit\\n                    // If not, early halt with a null root\\n                    if(connecteeMin == 0 && connecteeMax == 50001)\\n                    {\\n                        // Either a left insert or a right inserst case here for a singleton root child :-O\\n                        // So just continue : this passes anyways!\\n                    }    \\n                    else if(connecteeMin == 0)\\n                    {\\n                        // System.out.printf(\"here @ connectee right single child case \\\\n\");\\n                        if(connecteeMax >= fringeMax)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else if ( connecteeMax == 50001)\\n                    {\\n                        if(connecteeMin <= fringeMin)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else\\n                    {\\n                         if (!( fringeMin <= connecteeMin && connecteeMax <= fringeMax ))\\n                         {\\n                            return null;\\n                         }\\n                    }\\n                                          \\n\\n                    // Wrapper fringeMeta = rangeInfo.get(fringeNode.val);\\n                    Wrapper fringeMeta = fringeWrapper;\\n                    fringeNode.left = connectee.left;\\n                    fringeNode.right = connectee.right;\\n                    TreeNode lst = fringeNode.left;\\n                    TreeNode rst = fringeNode.right;    \\n                    // System.out.printf(\"Removing fringe node val from range info = %d\\\\n\", fringeNode.val);\\n                    rangeInfo.remove(fringeNode.val); // we kick this mini BST out cuz it was concatenated here\\n                    \\n                    // Add the new fringe nodes now\\n                    // Update your fringe wrappers too! \\n                    if(lst != null) \\n                    {\\n                        Wrapper lstMeta = new Wrapper();\\n                        lstMeta.node = lst;\\n                        lstMeta.max = fringeNode.val;\\n                        if(fringeMeta.min < lst.val)\\n                            lstMeta.min = Math.max(0, fringeMeta.min);\\n                        else\\n                            lstMeta.min = 0;\\n                        fringe.add(lstMeta);\\n                    }\\n                    if(rst != null)\\n                    {\\n                        Wrapper rstMeta = new Wrapper();\\n                        rstMeta.node = rst;\\n                        rstMeta.min = fringeNode.val;\\n                        if(fringeMeta.max > rst.val)\\n                            rstMeta.max = Math.min(50001, fringeMeta.max);\\n                        else\\n                            rstMeta.max = 50001;\\n                        fringe.add(rstMeta);\\n                    }\\n                    \\n                    // Go update the root node\\'s range information now\\n                    // Note : aways update according to the fringe valies anyways : as the depths represent a property too!\\n                    // Oh but the root might also have a flag too. Be careful!\\n                    // RUN TIME BUG HERE\\n                    Wrapper rootMeta = rangeInfo.get(newRoot.val);\\n                    // Your trip up is taking place here!\\n                    if(connecteeMin != 0)\\n                        rootMeta.min = Math.min(rootMeta.min, connecteeMin);\\n                    if(connecteeMax != 50001)\\n                        rootMeta.max = Math.max(rootMeta.max, connecteeMax);\\n                    \\n                    // Check if we need a new root node now\\n                    if(fringe.isEmpty())\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // Grow a seperate subtree, as the root set is empty here\\n            // If node in to explore has already been checked : go ahead and skip it.\\n            if(fringe.isEmpty())\\n            {\\n                if(!rootSet.contains(newRoot.val))\\n                {\\n                    rootSet.add(newRoot.val);\\n                }\\n\\n                while(true)\\n                {\\n                    // Incorporate terminating condition into loop logic\\n                    // We have a bug here BTW, as the root set was already added ahead of time. Prevent said add? \\n                    // Also the check is performed at incorrect location possibly? \\n                    if(toExplore.size() == rootSet.size())\\n                    {\\n                        if(rootSet.size() != 1)\\n                        {\\n                            return null;\\n                        }\\n                        return newRoot;               \\n                    }\\n                    TreeNode candidate = toExplore.remove();\\n                    if(candidate == newRoot)\\n                    {\\n                        toExplore.add(candidate);\\n                    }\\n                    else\\n                    {\\n                        if(!rangeInfo.containsKey(candidate.val))\\n                        {\\n                            continue;\\n                        }\\n                        else\\n                        {\\n                            newRoot = candidate;\\n                            toExplore.add(candidate);\\n                            break;\\n                        }\\n                    }\\n                }\\n                // Oh yeah we need a new fringe here too!\\n                // Amend this later on !\\n                if(newRoot.left == null && newRoot.right == null)\\n                {\\n                    fringe.add(rangeInfo.get(newRoot.val));\\n                }\\n                if(newRoot.left != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n                }\\n                if(newRoot.right != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n                }\\n            }\\n        }\\n        if(rootSet.size() != 1)\\n        {\\n            return null;\\n        }\\n        return newRoot;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n/*\\n\\nURL = https://leetcode.com/problems/merge-bsts-to-create-single-bst/ \\n1932. Merge BSTs to Create Single BST\\n\\nLet us leverage the invariant that node values in the node\\'s LST have value STRICTLY LESS than the root\\'s value\\nand nodes in the right subtree have value STRICTLY MORE than node\\'s value\\n\\nNote : we may be able to form \\n\\nHINT : leverage a hashmap\\n    -> store the min values and max values of BSTs ( seen in other problems ) \\n    \\nCOMPLEXITY\\nTime = ___\\nSpace = ___\\n\\nNode vals are known to be positives in range of [1,50000]\\n[[3],[3,1]] is luckily invalid anyways!\\n\\nTEST CASES\\n(A)[[2,1],[3,2,5],[5,4]] \\n(B) [[3],[4,3]]\\n    [4,3] = expected\\n(C)\\n(D)\\n(E)\\n\\nAlso this is a list, so deletion may or may not be possible. But a hashmap conversion also entails alacrity as well\\nNo two roots have same value -> we are in luck here too!\\nReturn null if a root is not able to be ascertained as well.\\nCount number of trees too ( hey you queue root ste handles this ! ) \\n\\n\\nRemember that we must maintain the count of operatinos here too\\n\\nStrategies : Hashtable, Queue, BFS ( Fringe-esque manner ) or DFS ( fringe-esque manner )\\n            I am unsure how binary search could help here though?\\n\\nYou forgot the case where the root may not even possess two children nodes ( e.g. 2L1 )\\nIn this case, we may get an overlap ( e.g. 2R3 )\\nThis is still a valid operation, and the fringe may have involved the root here as well. Exert caution now!\\n\\n*/\\nclass Solution \\n{\\n    \\n    public class Wrapper\\n    {\\n        public TreeNode node;\\n        public int min;\\n        public int max;\\n        \\n        public Wrapper()\\n        {\\n            this.node = null;\\n            min = 0;\\n            max = 50001; // ma of 50,000\\n            // min = Integer.MIN_VALUE;\\n            // max = Integer.MAX_VALUE;\\n        }\\n        \\n        // The \"this\" keyword is really a self-referential pointer in the hiding\\n        public Wrapper(TreeNode node, int min, int max)\\n        {\\n            this.node = node;\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    \\n    // Range Info hashmap should be based on integers ... NOT on node addresses ( can cause a trip up with fringe analysis : leaf(1) != root(1) case ) \\n    public TreeNode canMerge(List<TreeNode> trees) \\n    {\\n        TreeNode newRoot = null;\\n        List<Wrapper> fringe = new ArrayList<Wrapper>();\\n        Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n        HashMap<Integer, Wrapper> rangeInfo = new HashMap<Integer, Wrapper>();\\n        Set<Integer> rootSet = new HashSet<Integer>();\\n        \\n        if(trees == null || trees.size() == 0)\\n        {\\n            return null;\\n        }\\n        int n = trees.size();\\n        \\n        // [1] Initialize the HASHMAP with initialize range info for all rooted nodes\\n        // [2] In same for loop, add the nodes to the queue as well\\n        for(int i = 0; i < n; ++i)\\n        {\\n            TreeNode cur = trees.get(i);\\n            Wrapper metadata = new Wrapper();\\n            if(cur != null && !rangeInfo.containsKey(cur.val))\\n            {\\n                metadata.node = cur;\\n                if(cur.left != null)\\n                {\\n                    metadata.min = cur.left.val;\\n                }\\n                if(cur.right != null)\\n                {\\n                    metadata.max = cur.right.val;\\n                }\\n                rangeInfo.put(cur.val, metadata);\\n            }\\n            toExplore.add(cur);\\n        }\\n        // toExplore.add(toExplore.poll()); // Just add the first node to the end ( as we are already there anyways ) \\n        // System.out.printf(\"toExplore size = %d\\\\n\", toExplore.size());\\n        \\n        // [3] Initialize the fringe and first root node, along with the root set\\n        // Make sure the fringe itself is properly initialized here : we pass in these values later, depending on direction of add as well\\n        // Oh and make sure the root is part of the fringe set as well : hey we could get a bad case as well\\n        // But the root case begets much caution too ... as this fringe is not guaranteed its emptiness\\n        // One possibility : go fill that up, if possible , and then proceed with the legitimate fringe as expected\\n        // Wait we need not add the root to the fringe -> as the root trees differ, and a fringe must be a leaf\\n        // But what if the root HAS no leaves? \\n        // Well that is a special case indeed. Is in itself a frige at this point\\n        \\n        \\n        newRoot = toExplore.peek();\\n        if(newRoot.left == null && newRoot.right == null)\\n        {\\n            fringe.add(rangeInfo.get(newRoot.val));\\n        }\\n        if(newRoot.left != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n        }\\n        if(newRoot.right != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n        }\\n        \\n        // [4] The meat of our algorithm here\\n//         List<Wrapper> fringe = new ArrayList<Wrapper>();\\n//         Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n//         HashMap<TreeNode, Wrapper> rangeInfo = new HashMap<TreeNode, Wrapper>();\\n//         Set<TreeNode> rootSet = new HashSet<TreeNode>();\\n        \\n        // Handle null pointer exception later\\n        while(!toExplore.isEmpty())\\n        {\\n            while(!fringe.isEmpty())\\n            {\\n                // If either children are null : well hey, they are infinites too. Leverage that as well.\\n                // System.out.printf(\"Evaluating fringe\\\\n\");\\n                Wrapper fringeWrapper = fringe.remove(0);\\n                TreeNode fringeNode = fringeWrapper.node; \\n                if(fringeNode == newRoot)\\n                {\\n                    // System.out.printf(\"Fringe = new root\\\\n\");\\n                    continue; // ignore this case\\n                }\\n                // Go remove a former root, if we end up adding it anyways!\\n                if(rootSet.contains(fringeNode.val))\\n                {\\n                    // System.out.printf(\"Removing node [%d] from root set\\\\n\", fringeNode.val);\\n                    rootSet.remove(fringeNode.val);\\n                }\\n                int fringeMin = fringeWrapper.min;\\n                int fringeMax = fringeWrapper.max;\\n                if(rangeInfo.containsKey(fringeNode.val))\\n                {\\n                    // Now perform range tests , as an appends is a possibility here\\n                    // remember this : the append in itself is just the hashmaps left and right too : why not just port that over?\\n                    Wrapper connecteeMeta = rangeInfo.get(fringeNode.val);\\n                    TreeNode connectee = connecteeMeta.node;\\n                    int connecteeMin = connecteeMeta.min;\\n                    int connecteeMax = connecteeMeta.max;\\n                    \\n                    // Not sure about handling -INT_MIN, INT_MAX cases though. A bit lost there in the connection setup\\n                    // Handle as single child or dual child cases instead ( you incorporated flag values 0,50001 for this ) \\n                    // wait a second .. on the fringe, you may have a case where it has a flag as well. Shit\\n                    // If not, early halt with a null root\\n                    if(connecteeMin == 0 && connecteeMax == 50001)\\n                    {\\n                        // Either a left insert or a right inserst case here for a singleton root child :-O\\n                        // So just continue : this passes anyways!\\n                    }    \\n                    else if(connecteeMin == 0)\\n                    {\\n                        // System.out.printf(\"here @ connectee right single child case \\\\n\");\\n                        if(connecteeMax >= fringeMax)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else if ( connecteeMax == 50001)\\n                    {\\n                        if(connecteeMin <= fringeMin)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else\\n                    {\\n                         if (!( fringeMin <= connecteeMin && connecteeMax <= fringeMax ))\\n                         {\\n                            return null;\\n                         }\\n                    }\\n                                          \\n\\n                    // Wrapper fringeMeta = rangeInfo.get(fringeNode.val);\\n                    Wrapper fringeMeta = fringeWrapper;\\n                    fringeNode.left = connectee.left;\\n                    fringeNode.right = connectee.right;\\n                    TreeNode lst = fringeNode.left;\\n                    TreeNode rst = fringeNode.right;    \\n                    // System.out.printf(\"Removing fringe node val from range info = %d\\\\n\", fringeNode.val);\\n                    rangeInfo.remove(fringeNode.val); // we kick this mini BST out cuz it was concatenated here\\n                    \\n                    // Add the new fringe nodes now\\n                    // Update your fringe wrappers too! \\n                    if(lst != null) \\n                    {\\n                        Wrapper lstMeta = new Wrapper();\\n                        lstMeta.node = lst;\\n                        lstMeta.max = fringeNode.val;\\n                        if(fringeMeta.min < lst.val)\\n                            lstMeta.min = Math.max(0, fringeMeta.min);\\n                        else\\n                            lstMeta.min = 0;\\n                        fringe.add(lstMeta);\\n                    }\\n                    if(rst != null)\\n                    {\\n                        Wrapper rstMeta = new Wrapper();\\n                        rstMeta.node = rst;\\n                        rstMeta.min = fringeNode.val;\\n                        if(fringeMeta.max > rst.val)\\n                            rstMeta.max = Math.min(50001, fringeMeta.max);\\n                        else\\n                            rstMeta.max = 50001;\\n                        fringe.add(rstMeta);\\n                    }\\n                    \\n                    // Go update the root node\\'s range information now\\n                    // Note : aways update according to the fringe valies anyways : as the depths represent a property too!\\n                    // Oh but the root might also have a flag too. Be careful!\\n                    // RUN TIME BUG HERE\\n                    Wrapper rootMeta = rangeInfo.get(newRoot.val);\\n                    // Your trip up is taking place here!\\n                    if(connecteeMin != 0)\\n                        rootMeta.min = Math.min(rootMeta.min, connecteeMin);\\n                    if(connecteeMax != 50001)\\n                        rootMeta.max = Math.max(rootMeta.max, connecteeMax);\\n                    \\n                    // Check if we need a new root node now\\n                    if(fringe.isEmpty())\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // Grow a seperate subtree, as the root set is empty here\\n            // If node in to explore has already been checked : go ahead and skip it.\\n            if(fringe.isEmpty())\\n            {\\n                if(!rootSet.contains(newRoot.val))\\n                {\\n                    rootSet.add(newRoot.val);\\n                }\\n\\n                while(true)\\n                {\\n                    // Incorporate terminating condition into loop logic\\n                    // We have a bug here BTW, as the root set was already added ahead of time. Prevent said add? \\n                    // Also the check is performed at incorrect location possibly? \\n                    if(toExplore.size() == rootSet.size())\\n                    {\\n                        if(rootSet.size() != 1)\\n                        {\\n                            return null;\\n                        }\\n                        return newRoot;               \\n                    }\\n                    TreeNode candidate = toExplore.remove();\\n                    if(candidate == newRoot)\\n                    {\\n                        toExplore.add(candidate);\\n                    }\\n                    else\\n                    {\\n                        if(!rangeInfo.containsKey(candidate.val))\\n                        {\\n                            continue;\\n                        }\\n                        else\\n                        {\\n                            newRoot = candidate;\\n                            toExplore.add(candidate);\\n                            break;\\n                        }\\n                    }\\n                }\\n                // Oh yeah we need a new fringe here too!\\n                // Amend this later on !\\n                if(newRoot.left == null && newRoot.right == null)\\n                {\\n                    fringe.add(rangeInfo.get(newRoot.val));\\n                }\\n                if(newRoot.left != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n                }\\n                if(newRoot.right != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n                }\\n            }\\n        }\\n        if(rootSet.size() != 1)\\n        {\\n            return null;\\n        }\\n        return newRoot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564445,
                "title": "java-easy-solution-0-ms-faster-than-100-00",
                "content": "\\tprivate int sum = 0 ;\\n\\t\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (low == high) return low;\\n\\n        if (low <= root.val && high <= root.val) {\\n            // look up left\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);\\n\\n        } else if (low >= root.val && high >= root.val){\\n            // look up right\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        } else {\\n            // look up all\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);  rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n    private boolean isInBetween(TreeNode node, int low, int high){\\n        return node != null && node.val >= low && node.val <= high;\\n    }",
                "solutionTags": [],
                "code": "\\tprivate int sum = 0 ;\\n\\t\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (low == high) return low;\\n\\n        if (low <= root.val && high <= root.val) {\\n            // look up left\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);\\n\\n        } else if (low >= root.val && high >= root.val){\\n            // look up right\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        } else {\\n            // look up all\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);  rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n    private boolean isInBetween(TreeNode node, int low, int high){\\n        return node != null && node.val >= low && node.val <= high;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1561096,
                "title": "javascript-map-and-stack-100-faster",
                "content": "```\\nvar canMerge = function(trees) {\\n    let map = new Map(), leaves = [];\\n\\n    for (const tree of trees)\\n        map.set(tree.val, tree);\\n\\n    var addLeafNodes = (node, lowerBound, upperBound) => {\\n        node.right && leaves.push([node, \"right\", node.val, upperBound]);\\n        node.left && leaves.push([node, \"left\", lowerBound, node.val]);\\n    };\\n    \\n    var dfs = (root, child) =>\\n        root[child] === null ? root.val : dfs(root[child], child);\\n\\n    while (trees.length) {\\n        const cur = map.get(trees.pop().val);\\n        \\n        if (!cur) continue;\\n\\n        addLeafNodes(cur, -50001, 50001);\\n\\n        while (leaves.length) {\\n            const [node, child, lowerBound, upperBound] = leaves.pop();\\n            \\n            if (map.has(node[child].val)) {\\n                const leaf = map.get(node[child].val),\\n                      leftMostVal = dfs(leaf, \"left\"),\\n                      rightMostVal = dfs(leaf, \"right\");\\n\\n                if (upperBound > rightMostVal && lowerBound < leftMostVal) {\\n                    node[child] = leaf;\\n                    addLeafNodes(leaf, lowerBound, upperBound);\\n                    map.delete(leaf.val);\\n                }\\n            }\\n        }\\n    }\\n\\n    return map.size > 1 ? null : [...map][0][1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canMerge = function(trees) {\\n    let map = new Map(), leaves = [];\\n\\n    for (const tree of trees)\\n        map.set(tree.val, tree);\\n\\n    var addLeafNodes = (node, lowerBound, upperBound) => {\\n        node.right && leaves.push([node, \"right\", node.val, upperBound]);\\n        node.left && leaves.push([node, \"left\", lowerBound, node.val]);\\n    };\\n    \\n    var dfs = (root, child) =>\\n        root[child] === null ? root.val : dfs(root[child], child);\\n\\n    while (trees.length) {\\n        const cur = map.get(trees.pop().val);\\n        \\n        if (!cur) continue;\\n\\n        addLeafNodes(cur, -50001, 50001);\\n\\n        while (leaves.length) {\\n            const [node, child, lowerBound, upperBound] = leaves.pop();\\n            \\n            if (map.has(node[child].val)) {\\n                const leaf = map.get(node[child].val),\\n                      leftMostVal = dfs(leaf, \"left\"),\\n                      rightMostVal = dfs(leaf, \"right\");\\n\\n                if (upperBound > rightMostVal && lowerBound < leftMostVal) {\\n                    node[child] = leaf;\\n                    addLeafNodes(leaf, lowerBound, upperBound);\\n                    map.delete(leaf.val);\\n                }\\n            }\\n        }\\n    }\\n\\n    return map.size > 1 ? null : [...map][0][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474222,
                "title": "sime-easy-to-understand-o-n-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if(trees.size() == 0)\\n            return NULL;\\n        unordered_map<int, TreeNode*> rootMap;\\n        unordered_set<int> nodeSet;\\n        for(TreeNode* root : trees)\\n        {\\n            nodeSet.insert(root->val);\\n            if(rootMap.find(root->val)!=rootMap.end())\\n                return NULL;\\n            rootMap[root->val] = root;\\n            if(root->left)\\n                nodeSet.insert(root->left->val);\\n            if(root->right)\\n                nodeSet.insert(root->right->val);\\n        }\\n        for(TreeNode* root : trees)\\n        {\\n            if(root->left)\\n            {\\n                if(rootMap.find(root->left->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->left->val] == NULL)\\n                        return NULL;\\n                    root->left = rootMap[root->left->val];\\n                    rootMap[root->left->val] = NULL;\\n                }\\n            }\\n            if(root->right)\\n            {\\n                if(rootMap.find(root->right->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->right->val] == NULL)\\n                        return NULL;\\n                    root->right = rootMap[root->right->val];\\n                    rootMap[root->right->val] = NULL;\\n                }\\n            }\\n        }\\n        TreeNode* newRoot = NULL;\\n        for(TreeNode* root : trees)\\n        {\\n            if(rootMap[root->val])\\n            {\\n                if(newRoot)\\n                    return NULL;\\n                newRoot = root;\\n            }\\n        }\\n        if(newRoot == NULL)\\n            return NULL;\\n        if(!verifyBST(newRoot, INT_MIN, INT_MAX))\\n            return NULL;\\n        if(!verifyCount(newRoot, nodeSet))\\n            return NULL;\\n        if(nodeSet.size() >0)\\n            return NULL;\\n        return newRoot;\\n\\n    }\\n    bool verifyBST(TreeNode* root, int mn, int mx)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(root->val < mn || root->val > mx)\\n            return false;\\n        return verifyBST(root->left, mn, min(mx, root->val)) && verifyBST(root->right, max(mn, root->val), mx);\\n    }\\n\\n    bool verifyCount(TreeNode* root, unordered_set<int>& nodeSet)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(nodeSet.find(root->val) == nodeSet.end())\\n            return false;\\n        nodeSet.erase(root->val);\\n        return verifyCount(root->left, nodeSet) && verifyCount(root->right, nodeSet);\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if(trees.size() == 0)\\n            return NULL;\\n        unordered_map<int, TreeNode*> rootMap;\\n        unordered_set<int> nodeSet;\\n        for(TreeNode* root : trees)\\n        {\\n            nodeSet.insert(root->val);\\n            if(rootMap.find(root->val)!=rootMap.end())\\n                return NULL;\\n            rootMap[root->val] = root;\\n            if(root->left)\\n                nodeSet.insert(root->left->val);\\n            if(root->right)\\n                nodeSet.insert(root->right->val);\\n        }\\n        for(TreeNode* root : trees)\\n        {\\n            if(root->left)\\n            {\\n                if(rootMap.find(root->left->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->left->val] == NULL)\\n                        return NULL;\\n                    root->left = rootMap[root->left->val];\\n                    rootMap[root->left->val] = NULL;\\n                }\\n            }\\n            if(root->right)\\n            {\\n                if(rootMap.find(root->right->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->right->val] == NULL)\\n                        return NULL;\\n                    root->right = rootMap[root->right->val];\\n                    rootMap[root->right->val] = NULL;\\n                }\\n            }\\n        }\\n        TreeNode* newRoot = NULL;\\n        for(TreeNode* root : trees)\\n        {\\n            if(rootMap[root->val])\\n            {\\n                if(newRoot)\\n                    return NULL;\\n                newRoot = root;\\n            }\\n        }\\n        if(newRoot == NULL)\\n            return NULL;\\n        if(!verifyBST(newRoot, INT_MIN, INT_MAX))\\n            return NULL;\\n        if(!verifyCount(newRoot, nodeSet))\\n            return NULL;\\n        if(nodeSet.size() >0)\\n            return NULL;\\n        return newRoot;\\n\\n    }\\n    bool verifyBST(TreeNode* root, int mn, int mx)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(root->val < mn || root->val > mx)\\n            return false;\\n        return verifyBST(root->left, mn, min(mx, root->val)) && verifyBST(root->right, max(mn, root->val), mx);\\n    }\\n\\n    bool verifyCount(TreeNode* root, unordered_set<int>& nodeSet)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(nodeSet.find(root->val) == nodeSet.end())\\n            return false;\\n        nodeSet.erase(root->val);\\n        return verifyCount(root->left, nodeSet) && verifyCount(root->right, nodeSet);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441258,
                "title": "c-greedy-like-solution",
                "content": "```\\nbool compareAffinity(pair<TreeNode*, int> &a, pair<TreeNode*, int> &b){\\n    return (a.second < b.second);\\n}\\n\\nclass Solution {\\n    unordered_map<int, TreeNode*> setOfTrees;\\n    \\n    void dfs(TreeNode* &curr, TreeNode* root){\\n        if(curr == NULL)\\n            return;\\n        \\n        if(curr->left == NULL && curr->right == NULL){\\n            if(setOfTrees.find(curr->val) != setOfTrees.end() && setOfTrees[curr->val] != curr \\n               && setOfTrees[curr->val] != root){\\n                curr = setOfTrees[curr->val];\\n                setOfTrees.erase(curr->val);\\n            }\\n        }\\n        \\n        dfs(curr->left, root);\\n        dfs(curr->right, root);\\n    }\\n    \\n    int leafAffinity(TreeNode* curr){\\n        if(curr == NULL)\\n            return 0;\\n        \\n        if(curr->left == NULL && curr->right == NULL && \\n                setOfTrees.find(curr->val) != setOfTrees.end()){\\n            return 1;\\n        }\\n        \\n        return leafAffinity(curr->left) + leafAffinity(curr->right);\\n    }\\n\\n    bool isBST(TreeNode* node, int min, int max)\\n    {\\n        if (node==NULL)\\n            return true;\\n\\n        if (node->val < min || node->val > max)\\n            return false;\\n\\n        return isBST(node->left, min, node->val-1) && \\n                isBST(node->right, node->val+1, max); \\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto t: trees)\\n            setOfTrees[t->val] = t;\\n        \\n        vector<pair<TreeNode*, int>> treesT;\\n        \\n        for(auto t: trees)\\n            treesT.push_back(make_pair(t, leafAffinity(t)));\\n        \\n        sort(treesT.begin(), treesT.end(), compareAffinity);\\n        \\n        for(int i=0; i<treesT.size(); i++){\\n            if(setOfTrees.find(treesT[i].first->val) != setOfTrees.end())\\n                dfs(treesT[i].first, treesT[i].first);\\n        }\\n        \\n        if(setOfTrees.size() > 1)\\n            return NULL;\\n        \\n        if(isBST(setOfTrees.begin()->second, INT_MIN, INT_MAX))\\n            return setOfTrees.begin()->second;\\n        else return NULL;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool compareAffinity(pair<TreeNode*, int> &a, pair<TreeNode*, int> &b){\\n    return (a.second < b.second);\\n}\\n\\nclass Solution {\\n    unordered_map<int, TreeNode*> setOfTrees;\\n    \\n    void dfs(TreeNode* &curr, TreeNode* root){\\n        if(curr == NULL)\\n            return;\\n        \\n        if(curr->left == NULL && curr->right == NULL){\\n            if(setOfTrees.find(curr->val) != setOfTrees.end() && setOfTrees[curr->val] != curr \\n               && setOfTrees[curr->val] != root){\\n                curr = setOfTrees[curr->val];\\n                setOfTrees.erase(curr->val);\\n            }\\n        }\\n        \\n        dfs(curr->left, root);\\n        dfs(curr->right, root);\\n    }\\n    \\n    int leafAffinity(TreeNode* curr){\\n        if(curr == NULL)\\n            return 0;\\n        \\n        if(curr->left == NULL && curr->right == NULL && \\n                setOfTrees.find(curr->val) != setOfTrees.end()){\\n            return 1;\\n        }\\n        \\n        return leafAffinity(curr->left) + leafAffinity(curr->right);\\n    }\\n\\n    bool isBST(TreeNode* node, int min, int max)\\n    {\\n        if (node==NULL)\\n            return true;\\n\\n        if (node->val < min || node->val > max)\\n            return false;\\n\\n        return isBST(node->left, min, node->val-1) && \\n                isBST(node->right, node->val+1, max); \\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto t: trees)\\n            setOfTrees[t->val] = t;\\n        \\n        vector<pair<TreeNode*, int>> treesT;\\n        \\n        for(auto t: trees)\\n            treesT.push_back(make_pair(t, leafAffinity(t)));\\n        \\n        sort(treesT.begin(), treesT.end(), compareAffinity);\\n        \\n        for(int i=0; i<treesT.size(); i++){\\n            if(setOfTrees.find(treesT[i].first->val) != setOfTrees.end())\\n                dfs(treesT[i].first, treesT[i].first);\\n        }\\n        \\n        if(setOfTrees.size() > 1)\\n            return NULL;\\n        \\n        if(isBST(setOfTrees.begin()->second, INT_MIN, INT_MAX))\\n            return setOfTrees.begin()->second;\\n        else return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437247,
                "title": "open-only-to-read-approach-tle-473-474-test-case-passed",
                "content": "Problem: https://leetcode.com/problems/merge-bsts-to-create-single-bst/\\nApproach:\\nTime Complexity: O(n)  \\nAuxillary Space: O(n)\\n**Note: This approach was not able to pass all test cases but its optimzation will if you are able to optimize it do let me know. Thank you !** \\nHere first we traverse the trees vector and for each particular bst we try to merge it with another bst which has same root->val equal to one of the leaves value.\\nNow we try to combining the current root leave by new bst by assigning left and right of new root then  we also check for valid bst for its child.\\nIt may be possible that the after merging the new subtree it is not following the property of bst.\\n\\n**Merging:**\\nHere while traversing through a tree we are checking if its current not is not a root of other tree.\\nIf found we assign new root child to current node and mark the node which is merged in merge vector so that we don\\'t process it again and update that root value in mp.\\nWhenever merging is successful we increment counter, as we have valid answer only when all n-1 nodes are merged.\\n\\n**Checking Valid Bst:**\\n* We first assume that our root value can be in between range lower and higher (INT_MIN and INT_MAX for root).\\nThen at each step we check the root value is in range.\\nThen we check this recursively for each child.\\n* For left subtree all the values in it should be less than root value so the lower is equal to INT_MIN but higher is equal to root value.\\n* For right child subtree all the values in it should be more than the root value so the lower is equal to root value and higher is equal to INT_MAX.\\n\\n**Helper datastructures:**\\n* Here one map which store root value and its corresponding index in trees vector. (mp)\\n* A vector is used to track which bst are merged and avoid their processing. (merge)\\n* A counter variable which is used to count the number of bst which are merged. (count)\\n* A bool variable if at any instance if after merging the tree is not following bst property the it should inform this and stop further recursive calls. (flag) \\n\\n**Code:**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    vector<bool> merge;\\n    int count=0;\\n    bool flag=true;\\n    void validBst(int l,int h,TreeNode *root,vector<TreeNode*>&trees)\\n    {\\n        if(!flag) return;\\n        if(!root) return;\\n        //if root val in present in mp then there is another root with same value in trees vector \\n        if(mp.find(root->val)!=mp.end()&&root->left==nullptr&&root->right==nullptr)\\n        {\\n            \\n            int idx=mp[root->val];\\n            TreeNode* temp=trees[idx];\\n            if(temp!=root)// if the bst only contains 1 element i.e root to avoid unneccsary count \\n            {\\n                count++;\\n                root->left=temp->left;\\n                root->right=temp->right;\\n                trees[idx]=root;\\n                merge[idx]=false;\\n            }\\n        }\\n        if(l<root->val&&root->val<h)// checking for valid bst\\n        {\\n            validBst(l,root->val,root->left,trees);\\n            if(!flag) return;\\n            validBst(root->val,h,root->right,trees);\\n            return;\\n        }\\n        flag=false; // if not valid bst\\n        return;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n=trees.size();\\n        merge=vector<bool>(n,true); // to keep track of merge bst\\n        for(int i=0;i<n;i++) // Store index of root->val \\n        {\\n            mp[trees[i]->val]=i;\\n        }\\n        for(int i=0;i<n;i++) //traverse trees vector\\n        {\\n            if(!flag)\\n                break;\\n            if(!merge[i]) continue;// Do not process merged bst\\n            validBst(INT_MIN,INT_MAX,trees[i],trees);\\n        }\\n        if(count+1==n&&flag)// count equal to number of trees merged\\n        {\\n            count=0;\\n            TreeNode * temp;\\n            for(int i=0;i<n;i++)\\n            {// If tree is not merge then it must the root of the main in which other trees are merge\\n                if(merge[i]) {\\n                    temp=trees[i];\\n                    count++;\\n                    if(count>1)// then it means more than one tree is left unmerged\\n                        return nullptr;\\n                    }           \\n            }\\n            return temp;\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    vector<bool> merge;\\n    int count=0;\\n    bool flag=true;\\n    void validBst(int l,int h,TreeNode *root,vector<TreeNode*>&trees)\\n    {\\n        if(!flag) return;\\n        if(!root) return;\\n        //if root val in present in mp then there is another root with same value in trees vector \\n        if(mp.find(root->val)!=mp.end()&&root->left==nullptr&&root->right==nullptr)\\n        {\\n            \\n            int idx=mp[root->val];\\n            TreeNode* temp=trees[idx];\\n            if(temp!=root)// if the bst only contains 1 element i.e root to avoid unneccsary count \\n            {\\n                count++;\\n                root->left=temp->left;\\n                root->right=temp->right;\\n                trees[idx]=root;\\n                merge[idx]=false;\\n            }\\n        }\\n        if(l<root->val&&root->val<h)// checking for valid bst\\n        {\\n            validBst(l,root->val,root->left,trees);\\n            if(!flag) return;\\n            validBst(root->val,h,root->right,trees);\\n            return;\\n        }\\n        flag=false; // if not valid bst\\n        return;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n=trees.size();\\n        merge=vector<bool>(n,true); // to keep track of merge bst\\n        for(int i=0;i<n;i++) // Store index of root->val \\n        {\\n            mp[trees[i]->val]=i;\\n        }\\n        for(int i=0;i<n;i++) //traverse trees vector\\n        {\\n            if(!flag)\\n                break;\\n            if(!merge[i]) continue;// Do not process merged bst\\n            validBst(INT_MIN,INT_MAX,trees[i],trees);\\n        }\\n        if(count+1==n&&flag)// count equal to number of trees merged\\n        {\\n            count=0;\\n            TreeNode * temp;\\n            for(int i=0;i<n;i++)\\n            {// If tree is not merge then it must the root of the main in which other trees are merge\\n                if(merge[i]) {\\n                    temp=trees[i];\\n                    count++;\\n                    if(count>1)// then it means more than one tree is left unmerged\\n                        return nullptr;\\n                    }           \\n            }\\n            return temp;\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416434,
                "title": "simple-efficient-c-greedy-verification",
                "content": "1) Each of (1-3)-BSTs produced by any valid decomposition of a valid BST is bound to have unique roots and unique children. Therefore, the original BST can be reconstructed by greedily replacing leaves with input/intermediate BSTs.\\n2) Verify that we ended up with one valid BST containing all unique input nodes once.\\n\\nO(bst_count)\\n\\n```\\nclass Solution {\\n    static constexpr int n = 50001;\\n    int counts[n]{};\\n    \\n    bool is_valid(TreeNode *t, int l, int r) {\\n        if (t == nullptr)\\n            return true;\\n        --counts[t->val];\\n        return t->val > l && t->val < r\\n            && is_valid(t->left, l, t->val)\\n            && is_valid(t->right, t->val, r);\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode *roots[n]{}, *root = nullptr;\\n        for (auto *tree : trees) {\\n            roots[tree->val] = tree;\\n            counts[tree->val] = 1;\\n            if (tree->left != nullptr)\\n                counts[tree->left->val] = 1;\\n            if (tree->right != nullptr)\\n                counts[tree->right->val] = 1;\\n        }\\n        for (auto *tree : trees) {\\n            if (tree->left != nullptr && roots[tree->left->val] != nullptr) {\\n                tree->left = roots[tree->left->val];\\n                roots[tree->left->val] = nullptr;\\n            }\\n            if (tree->right != nullptr && roots[tree->right->val] != nullptr) {\\n                tree->right = roots[tree->right->val];\\n                roots[tree->right->val] = nullptr;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i)\\n            if (roots[i] != nullptr) {\\n                if (root != nullptr)\\n                    return nullptr;\\n                root = roots[i];\\n            }\\n        return is_valid(root, 0, n)\\n            && all_of(counts, counts + n, [] (int x) { return x == 0; })\\n            ? root\\n            : nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static constexpr int n = 50001;\\n    int counts[n]{};\\n    \\n    bool is_valid(TreeNode *t, int l, int r) {\\n        if (t == nullptr)\\n            return true;\\n        --counts[t->val];\\n        return t->val > l && t->val < r\\n            && is_valid(t->left, l, t->val)\\n            && is_valid(t->right, t->val, r);\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode *roots[n]{}, *root = nullptr;\\n        for (auto *tree : trees) {\\n            roots[tree->val] = tree;\\n            counts[tree->val] = 1;\\n            if (tree->left != nullptr)\\n                counts[tree->left->val] = 1;\\n            if (tree->right != nullptr)\\n                counts[tree->right->val] = 1;\\n        }\\n        for (auto *tree : trees) {\\n            if (tree->left != nullptr && roots[tree->left->val] != nullptr) {\\n                tree->left = roots[tree->left->val];\\n                roots[tree->left->val] = nullptr;\\n            }\\n            if (tree->right != nullptr && roots[tree->right->val] != nullptr) {\\n                tree->right = roots[tree->right->val];\\n                roots[tree->right->val] = nullptr;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i)\\n            if (roots[i] != nullptr) {\\n                if (root != nullptr)\\n                    return nullptr;\\n                root = roots[i];\\n            }\\n        return is_valid(root, 0, n)\\n            && all_of(counts, counts + n, [] (int x) { return x == 0; })\\n            ? root\\n            : nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414959,
                "title": "python-stack-o-n",
                "content": "it is a good problem on the tree construction.\\nso, this question states that we need to add the root of another tree to the current tree if it have any leaf node whose value is equal to the value of root.\\nthis also tell us that there is only one root that occur once , inorder to make only one bst . if there are more than one root present that occur only once than we can not make the single bst or tree.\\nthe second thing that we want to take care is that if the tree formed has used all the root or not.\\nthe third thing is that the tree formed is valid or not .\\nAPPORACH ->\\nso for taking the care of first case we use two list frequency and the root dict.\\nif the value of the any node is one we will increase the value of unique nodes(a varible that will store it) and take its corrosponding root as  our tree\\'s root that we will return at the end . but if that varible storing the unique root is not equal to 1  then we can not make the single tree.\\nfor the second case we will use the varible that will have the number of roots , and decrement the count by 1.\\ncode->\\n```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        def valid(t):\\n            l=[]\\n            def tr (t):\\n                if t!=None:\\n                    tr (t.left)\\n                    l.append(t.val)\\n                    tr (t.right)\\n            tr (t)\\n            # checking the inorder traversal is sorted or not \\n            for i in range(len(l)-1):\\n                if (l[i]<l[i+1]):\\n                    pass\\n                else:\\n                    return False \\n            return True\\n        # f for frequency and d for roots storing\\n        d , f=defaultdict(int), defaultdict(int)\\n        for i in range(len(trees)):\\n            if trees[i]==None:continue\\n            d[trees[i].val] =trees[i]\\n            f[trees[i].val]+=1\\n\\n            if trees[i].left!=None:\\n                f[trees[i].left.val]+=1\\n                \\n            if trees[i].right!=None:\\n                f[trees[i].right.val]+=1\\n        rc=0 # it is for unique root count\\n        mc=len(d) # the number of roots left \\n        l=[]\\n        for i in f.keys():\\n            if f[i]==1 and d[i]!=0:\\n                rc+=1\\n                root=d[i]\\n                d[i]=0\\n                mc-=1\\n        if rc!=1:return None \\n        if root.left!=None:\\n            l.append((root,\"l\",root.left.val))\\n        if root.right !=None:\\n            l.append((root,\"r\",root.right.val))\\n        #single tree formation    \\n        while l:\\n            p,s,va=l.pop()\\n            curr=-1\\n            if d[va]!=0:\\n                if s==\"l\":\\n                    p.left=d[va]\\n                    curr=p.left\\n                    \\n                else:\\n                    p.right =d[va]\\n                    curr=p.right\\n                d[va]=0\\n                mc-=1\\n            if curr==-1:\\n                continue \\n            if curr.left!=None:\\n                l.append((curr,\"l\",curr.left.val))\\n                \\n            if curr.right!=None:\\n                l.append((curr,\"r\",curr.right.val))\\n                \\n        if mc==0 and valid (root):return root\\n        return None \\n                \\n                  \\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        def valid(t):\\n            l=[]\\n            def tr (t):\\n                if t!=None:\\n                    tr (t.left)\\n                    l.append(t.val)\\n                    tr (t.right)\\n            tr (t)\\n            # checking the inorder traversal is sorted or not \\n            for i in range(len(l)-1):\\n                if (l[i]<l[i+1]):\\n                    pass\\n                else:\\n                    return False \\n            return True\\n        # f for frequency and d for roots storing\\n        d , f=defaultdict(int), defaultdict(int)\\n        for i in range(len(trees)):\\n            if trees[i]==None:continue\\n            d[trees[i].val] =trees[i]\\n            f[trees[i].val]+=1\\n\\n            if trees[i].left!=None:\\n                f[trees[i].left.val]+=1\\n                \\n            if trees[i].right!=None:\\n                f[trees[i].right.val]+=1\\n        rc=0 # it is for unique root count\\n        mc=len(d) # the number of roots left \\n        l=[]\\n        for i in f.keys():\\n            if f[i]==1 and d[i]!=0:\\n                rc+=1\\n                root=d[i]\\n                d[i]=0\\n                mc-=1\\n        if rc!=1:return None \\n        if root.left!=None:\\n            l.append((root,\"l\",root.left.val))\\n        if root.right !=None:\\n            l.append((root,\"r\",root.right.val))\\n        #single tree formation    \\n        while l:\\n            p,s,va=l.pop()\\n            curr=-1\\n            if d[va]!=0:\\n                if s==\"l\":\\n                    p.left=d[va]\\n                    curr=p.left\\n                    \\n                else:\\n                    p.right =d[va]\\n                    curr=p.right\\n                d[va]=0\\n                mc-=1\\n            if curr==-1:\\n                continue \\n            if curr.left!=None:\\n                l.append((curr,\"l\",curr.left.val))\\n                \\n            if curr.right!=None:\\n                l.append((curr,\"r\",curr.right.val))\\n                \\n        if mc==0 and valid (root):return root\\n        return None \\n                \\n                  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410066,
                "title": "python3-recursive-tree-building-solution",
                "content": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        roots, leaves, loners, n = {}, {}, set(), len(trees)\\n        if n == 1:\\n            return trees[0]\\n        for tree in trees:\\n            if not tree.left and not tree.right:\\n                loners.add(tree.val)\\n                continue\\n            roots[tree.val] = tree\\n            for node in [tree.left, tree.right]:\\n                if node:\\n                    if node.val in leaves:\\n                        return None\\n                    leaves[node.val] = node\\n                \\n        for loner in loners:\\n            if loner not in leaves and loner not in roots:\\n                return None\\n            \\n        orphan = None\\n        for val, tree in roots.items():\\n            if val not in leaves:\\n                if orphan:\\n                    return None\\n                orphan = tree\\n        if not orphan:\\n            return None\\n        \\n        def build(node, small, big):\\n            nonlocal roots\\n            if not node:\\n                return True\\n            if small >= node.val or node.val >= big:\\n                return False\\n            \\n            if node.val in roots:\\n                node.left, node.right = roots[node.val].left, roots[node.val].right\\n                del roots[node.val]\\n            return build(node.left, small, node.val) and build(node.right, node.val, big)\\n        del roots[orphan.val]\\n        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)\\n        return orphan if result and not roots.keys() else None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        roots, leaves, loners, n = {}, {}, set(), len(trees)\\n        if n == 1:\\n            return trees[0]\\n        for tree in trees:\\n            if not tree.left and not tree.right:\\n                loners.add(tree.val)\\n                continue\\n            roots[tree.val] = tree\\n            for node in [tree.left, tree.right]:\\n                if node:\\n                    if node.val in leaves:\\n                        return None\\n                    leaves[node.val] = node\\n                \\n        for loner in loners:\\n            if loner not in leaves and loner not in roots:\\n                return None\\n            \\n        orphan = None\\n        for val, tree in roots.items():\\n            if val not in leaves:\\n                if orphan:\\n                    return None\\n                orphan = tree\\n        if not orphan:\\n            return None\\n        \\n        def build(node, small, big):\\n            nonlocal roots\\n            if not node:\\n                return True\\n            if small >= node.val or node.val >= big:\\n                return False\\n            \\n            if node.val in roots:\\n                node.left, node.right = roots[node.val].left, roots[node.val].right\\n                del roots[node.val]\\n            return build(node.left, small, node.val) and build(node.right, node.val, big)\\n        del roots[orphan.val]\\n        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)\\n        return orphan if result and not roots.keys() else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345851,
                "title": "python-using-dictionaries-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nimport collections\\ndef inorder(root, par, treeNode):\\n    if root==None:\\n        return []\\n    l = inorder(root.left, root, treeNode)\\n    r = inorder(root.right, root, treeNode)\\n    if len(l)==0 and len(r)==0:\\n        return [(root.val, treeNode, par, True)]\\n    return l+[(root.val, treeNode, par, False)]+r\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        if len(trees)==1:\\n            return trees[0]\\n        leafToNode = {}\\n        minMaxVal = {}\\n        rootToLeaf = collections.defaultdict(list)\\n        for t in trees:\\n            x = inorder(t, None, t)\\n            for a, b, c, d in x:\\n                if d and c!=None:\\n                    if a in leafToNode:\\n                        return None\\n                    leafToNode[a] = [b, c]\\n                    rootToLeaf[t].append(a)\\n            minMaxVal[t] = [x[0][0], x[-1][0]]\\n        ans = None\\n        for t in trees:\\n            if t.val in leafToNode:\\n                treeNode, par = leafToNode[t.val]\\n                if t.val<par.val:\\n                    if minMaxVal[t][1]>=par.val:\\n                        return None\\n                    else:\\n                        par.left = t\\n                else:\\n                    if minMaxVal[t][0]<=par.val:\\n                        return None\\n                    else:\\n                        par.right = t\\n                if t.val>treeNode.val:\\n                    if minMaxVal[t][0]<=treeNode.val: return None\\n                    minMaxVal[treeNode][1] = max(minMaxVal[t][1], minMaxVal[treeNode][1])\\n                else:\\n                    if minMaxVal[t][1]>=treeNode.val: return None\\n                    minMaxVal[treeNode][0] = min(minMaxVal[t][0], minMaxVal[treeNode][0])\\n                for leaf in rootToLeaf[t]:\\n                    if leaf in leafToNode:\\n                        leafToNode[leaf][0] = treeNode\\n                del leafToNode[t.val]\\n            elif ans==None:\\n                ans = t\\n            else:\\n                return None\\n        return ans\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        if len(trees)==1:\\n            return trees[0]\\n        leafToNode = {}",
                "codeTag": "Java"
            },
            {
                "id": 1344093,
                "title": "slower-but-simpler-we-can-do-naive-merging-and-compare-with-sorting",
                "content": "If BSTs can be merged, it will end up being a valid BST, which means that we can do a in-order traversal to get the sorted elements.\\nTherefore, we can simply try our best to merge, and see if the final in-order traversal result matches the sorted values.\\n\\n- With a valid final BST, all the values will be unique.\\n- We still need to implement merging correctly, but we don\\'t have to maitain extra info during merging, e.g. the min_left value of a node.\\n- Since we do extra sorting, the time complexity will be O(NlgN) instead of O(N).\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void merge(TreeNode *child, unordered_map<int, TreeNode*> &roots) {\\n        if (!child)\\n            return;\\n        if (roots.count(child->val) == 0)\\n            return;\\n        TreeNode *r = roots[child->val];\\n        child->left = r->left;\\n        child->right = r->right;\\n        roots.erase(child->val);\\n        merge(r->left, roots);\\n        merge(r->right, roots);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> roots;\\n        unordered_map<int, int> cnt;\\n        for (auto &t : trees) {\\n            roots[t->val] = t;\\n            ++cnt[t->val];\\n            ++cnt[t->left ? t->left->val : 0];\\n            ++cnt[t->right ? t->right->val : 0];\\n        }\\n        TreeNode *ans = nullptr;\\n        for (auto &t : trees) {\\n            if (cnt[t->val] == 1) {\\n                roots.erase(t->val);\\n                merge(t->left, roots);\\n                merge(t->right, roots);\\n                ans = t;\\n                break;\\n            }\\n        }\\n        if (!ans)\\n            return nullptr;\\n\\n        vector<int> trav;\\n        traverse(ans, trav);\\n        set<int> uniqs;\\n        for (auto &t : trees) {\\n            uniqs.insert(t->val);\\n            if (t->left) uniqs.insert(t->left->val);\\n            if (t->right) uniqs.insert(t->right->val);\\n        }\\n        vector<int> uniq_vec(uniqs.begin(), uniqs.end());\\n        std::sort(uniq_vec.begin(), uniq_vec.end());\\n        if (trav != uniq_vec)\\n            return nullptr;\\n\\n        return ans;\\n    }\\n    void traverse(TreeNode *r, vector<int> &v) {\\n        if (r->left)\\n            traverse(r->left, v);\\n        v.push_back(r->val);\\n        if (r->right)\\n            traverse(r->right, v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void merge(TreeNode *child, unordered_map<int, TreeNode*> &roots) {\\n        if (!child)\\n            return;\\n        if (roots.count(child->val) == 0)\\n            return;\\n        TreeNode *r = roots[child->val];\\n        child->left = r->left;\\n        child->right = r->right;\\n        roots.erase(child->val);\\n        merge(r->left, roots);\\n        merge(r->right, roots);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> roots;\\n        unordered_map<int, int> cnt;\\n        for (auto &t : trees) {\\n            roots[t->val] = t;\\n            ++cnt[t->val];\\n            ++cnt[t->left ? t->left->val : 0];\\n            ++cnt[t->right ? t->right->val : 0];\\n        }\\n        TreeNode *ans = nullptr;\\n        for (auto &t : trees) {\\n            if (cnt[t->val] == 1) {\\n                roots.erase(t->val);\\n                merge(t->left, roots);\\n                merge(t->right, roots);\\n                ans = t;\\n                break;\\n            }\\n        }\\n        if (!ans)\\n            return nullptr;\\n\\n        vector<int> trav;\\n        traverse(ans, trav);\\n        set<int> uniqs;\\n        for (auto &t : trees) {\\n            uniqs.insert(t->val);\\n            if (t->left) uniqs.insert(t->left->val);\\n            if (t->right) uniqs.insert(t->right->val);\\n        }\\n        vector<int> uniq_vec(uniqs.begin(), uniqs.end());\\n        std::sort(uniq_vec.begin(), uniq_vec.end());\\n        if (trav != uniq_vec)\\n            return nullptr;\\n\\n        return ans;\\n    }\\n    void traverse(TreeNode *r, vector<int> &v) {\\n        if (r->left)\\n            traverse(r->left, v);\\n        v.push_back(r->val);\\n        if (r->right)\\n            traverse(r->right, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339875,
                "title": "c-1932-merge-bsts-to-create-single-bst",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> freq; \\n        stack<TreeNode*> stk; \\n        \\n        for (auto& tree : trees) {\\n            stk.push(tree); \\n            while (stk.size()) {\\n                TreeNode* node = stk.top(); stk.pop(); \\n                if (node) {\\n                    ++freq[node->val]; \\n                    stk.push(node->left); \\n                    stk.push(node->right); \\n                }\\n            }\\n        }\\n        \\n        int cnt = 0; \\n        TreeNode* root = NULL; \\n        unordered_map<int, TreeNode*> mp; \\n        \\n        for (auto& tree : trees) {\\n            mp[tree->val] = tree; \\n            if (freq[tree->val] & 1) {\\n                ++cnt; \\n                root = tree; \\n            }\\n        }\\n        \\n        if (cnt != 1) return NULL; \\n        \\n        stk.push(root); \\n        int total = trees.size(); \\n        while (stk.size()) {\\n            TreeNode* node = stk.top(); stk.pop(); \\n            if (node->left && !node->left->left && !node->left->right && mp.count(node->left->val)) {\\n                node->left = mp[node->left->val]; \\n                --total; \\n            }\\n            if (node->right && !node->right->left && !node->right->right && mp.count(node->right->val)) {\\n                node->right = mp[node->right->val]; \\n                --total; \\n            }\\n            if (node->left) stk.push(node->left); \\n            if (node->right) stk.push(node->right); \\n        }\\n        \\n        if (total != 1) return NULL; \\n        \\n        int prev = INT_MIN; \\n        TreeNode* node = root; \\n        while (stk.size() || node) {\\n            if (node) {\\n                stk.push(node); \\n                node = node->left; \\n            } else {\\n                node = stk.top(); stk.pop(); \\n                if (prev >= node->val) return NULL; \\n                prev = node->val; \\n                node = node->right; \\n            }\\n        }\\n        return root; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> freq; \\n        stack<TreeNode*> stk; \\n        \\n        for (auto& tree : trees) {\\n            stk.push(tree); \\n            while (stk.size()) {\\n                TreeNode* node = stk.top(); stk.pop(); \\n                if (node) {\\n                    ++freq[node->val]; \\n                    stk.push(node->left); \\n                    stk.push(node->right); \\n                }\\n            }\\n        }\\n        \\n        int cnt = 0; \\n        TreeNode* root = NULL; \\n        unordered_map<int, TreeNode*> mp; \\n        \\n        for (auto& tree : trees) {\\n            mp[tree->val] = tree; \\n            if (freq[tree->val] & 1) {\\n                ++cnt; \\n                root = tree; \\n            }\\n        }\\n        \\n        if (cnt != 1) return NULL; \\n        \\n        stk.push(root); \\n        int total = trees.size(); \\n        while (stk.size()) {\\n            TreeNode* node = stk.top(); stk.pop(); \\n            if (node->left && !node->left->left && !node->left->right && mp.count(node->left->val)) {\\n                node->left = mp[node->left->val]; \\n                --total; \\n            }\\n            if (node->right && !node->right->left && !node->right->right && mp.count(node->right->val)) {\\n                node->right = mp[node->right->val]; \\n                --total; \\n            }\\n            if (node->left) stk.push(node->left); \\n            if (node->right) stk.push(node->right); \\n        }\\n        \\n        if (total != 1) return NULL; \\n        \\n        int prev = INT_MIN; \\n        TreeNode* node = root; \\n        while (stk.size() || node) {\\n            if (node) {\\n                stk.push(node); \\n                node = node->left; \\n            } else {\\n                node = stk.top(); stk.pop(); \\n                if (prev >= node->val) return NULL; \\n                prev = node->val; \\n                node = node->right; \\n            }\\n        }\\n        return root; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339448,
                "title": "need-help-on-this-tle",
                "content": "What i am trying to do is map root value to address for easy access. Then, for every root, i dfs to its leaves and try to find if map contains a root with value same as the leaf. If yes, i merge and continue dfs on the updated tree. However, i have noticed in cases like\\n[5,4] [6,5] [7,6] [8,7], my code keeps on iterating the tree on every addition in vain. What can i do to stop it? I read tuts here, but i am having problem grasping them and i am more concerned about the problem of my solution since that is what came in my head. THANKYOU\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, TreeNode*> mp;\\n    bool getout=false;\\npublic:\\n    \\n    bool validateBST(TreeNode* root,int min=INT_MIN,int max=INT_MAX)\\n    {\\n        if(!root)\\n            return true;\\n        \\n        return (root->val > min && root->val < max && validateBST(root->left,min,root->val) && validateBST(root->right,root->val,max));\\n    }\\n    bool isLeaf(TreeNode* root)\\n    {\\n        if(!root->left && !root->right)\\n            return true;\\n        return false;\\n    }\\n    void dfs(TreeNode* root,int forbiddenVal)\\n    {\\n        if(!root)\\n            return;\\n        if(root->left && isLeaf(root->left) && forbiddenVal!=root->left->val && mp.find(root->left->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->left->val);\\n            TreeNode *child = root->left,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n            \\n        }\\n        dfs(root->left,forbiddenVal);\\n        if(root->right && isLeaf(root->right) && forbiddenVal!=root->right->val && mp.find(root->right->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->right->val);\\n            TreeNode *child = root->right,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n        }\\n        dfs(root->right,forbiddenVal);\\n    }\\n    \\n    //MAIN FUNC\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        for(int i=0;i<trees.size();i++)\\n        {\\n            mp.insert({trees[i]->val,trees[i]});\\n        }\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            if(mp.find(trees[i]->val)!=mp.end())\\n                dfs(trees[i],trees[i]->val);\\n            //if(!validBST)\\n        }\\n        \\n        if(mp.size()!=1 or !validateBST(mp.begin()->second))\\n            return NULL;\\n        \\n        return mp.begin()->second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, TreeNode*> mp;\\n    bool getout=false;\\npublic:\\n    \\n    bool validateBST(TreeNode* root,int min=INT_MIN,int max=INT_MAX)\\n    {\\n        if(!root)\\n            return true;\\n        \\n        return (root->val > min && root->val < max && validateBST(root->left,min,root->val) && validateBST(root->right,root->val,max));\\n    }\\n    bool isLeaf(TreeNode* root)\\n    {\\n        if(!root->left && !root->right)\\n            return true;\\n        return false;\\n    }\\n    void dfs(TreeNode* root,int forbiddenVal)\\n    {\\n        if(!root)\\n            return;\\n        if(root->left && isLeaf(root->left) && forbiddenVal!=root->left->val && mp.find(root->left->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->left->val);\\n            TreeNode *child = root->left,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n            \\n        }\\n        dfs(root->left,forbiddenVal);\\n        if(root->right && isLeaf(root->right) && forbiddenVal!=root->right->val && mp.find(root->right->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->right->val);\\n            TreeNode *child = root->right,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n        }\\n        dfs(root->right,forbiddenVal);\\n    }\\n    \\n    //MAIN FUNC\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        for(int i=0;i<trees.size();i++)\\n        {\\n            mp.insert({trees[i]->val,trees[i]});\\n        }\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            if(mp.find(trees[i]->val)!=mp.end())\\n                dfs(trees[i],trees[i]->val);\\n            //if(!validBST)\\n        }\\n        \\n        if(mp.size()!=1 or !validateBST(mp.begin()->second))\\n            return NULL;\\n        \\n        return mp.begin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338716,
                "title": "python3-build-tree-and-check-for-order",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        freq = defaultdict(int)\\n        for tree in trees: \\n            stack = [tree]\\n            while stack: \\n                x = stack.pop()\\n                if x: \\n                    freq[x.val] += 1\\n                    stack.append(x.left)\\n                    stack.append(x.right)\\n        \\n        cnt, root = 0, None\\n        mp = {}\\n        for tree in trees: \\n            if freq[tree.val] & 1: cnt, root = cnt+1, tree\\n            mp[tree.val] = tree\\n        if cnt != 1: return None \\n        \\n        stack = [(root, None, 0)]\\n        total = len(trees)\\n        while stack: \\n            node, parent, left = stack.pop()\\n            if not node.left and not node.right and node.val in mp: \\n                total -= 1\\n                if not parent: \\n                    if len(trees) > 1: return None \\n                    return root\\n                if left: parent.left = node = mp[node.val]\\n                else: parent.right = node = mp[node.val]\\n            if node.left: stack.append((node.left, node, 1))\\n            if node.right: stack.append((node.right, node, 0))\\n        \\n        if total > 1: return None \\n        \\n        # in-order traversal \\n        prev = -inf\\n        node = root \\n        stack = []\\n        while stack or node: \\n            if node: \\n                stack.append(node)\\n                node = node.left \\n            else: \\n                node = stack.pop()\\n                if prev >= node.val: return None\\n                prev = node.val\\n                node = node.right\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        freq = defaultdict(int)\\n        for tree in trees: \\n            stack = [tree]\\n            while stack: \\n                x = stack.pop()\\n                if x: \\n                    freq[x.val] += 1\\n                    stack.append(x.left)\\n                    stack.append(x.right)\\n        \\n        cnt, root = 0, None\\n        mp = {}\\n        for tree in trees: \\n            if freq[tree.val] & 1: cnt, root = cnt+1, tree\\n            mp[tree.val] = tree\\n        if cnt != 1: return None \\n        \\n        stack = [(root, None, 0)]\\n        total = len(trees)\\n        while stack: \\n            node, parent, left = stack.pop()\\n            if not node.left and not node.right and node.val in mp: \\n                total -= 1\\n                if not parent: \\n                    if len(trees) > 1: return None \\n                    return root\\n                if left: parent.left = node = mp[node.val]\\n                else: parent.right = node = mp[node.val]\\n            if node.left: stack.append((node.left, node, 1))\\n            if node.right: stack.append((node.right, node, 0))\\n        \\n        if total > 1: return None \\n        \\n        # in-order traversal \\n        prev = -inf\\n        node = root \\n        stack = []\\n        while stack or node: \\n            if node: \\n                stack.append(node)\\n                node = node.left \\n            else: \\n                node = stack.pop()\\n                if prev >= node.val: return None\\n                prev = node.val\\n                node = node.right\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336378,
                "title": "literally-do-what-it-says-clear-python-solution",
                "content": "Simple solution, but with one small trick.\\n\\nWhat we do is just select a root, then verify it\\'s a BST or not using standard way;\\nIf it can form a BST, we\\'ll construct this BST (you can also construct the BST during verification as we will only verify once).\\nWhen we verify or construct BST, we use a reverse query {root value->tree index} from td to quickly find the corresponding tree.\\nThe trick is how to select the root node.\\n\\nAs mentioned in question, if we want to merge all BST to one BST, all root nodes of small BSTs must **appear twice** (as someone else\\'s leaf node) except one node, this node is the root of merged BST.\\n\\nWe use a counter dict **cnt**, which remembers how many times a node appears, then we just need find the node with cnt[val]==1.\\nLeaf node will also have cnt[val]==1 as it\\'s not someone\\'s parent, but it\\'s not a root node from trees[i].\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        minval=-1\\n        maxval=5*(10**4)+1\\n        td={}\\n        def check_bst(root,curr_set,minv,maxv):\\n            if(root is None):\\n                return True\\n            if(root.val<minv or root.val>maxv):\\n                return False\\n            a1=True\\n            if(root.left is not None):\\n                if(root.left.val not in td):# end of search, finish construct left\\n                    if(root.left.val<minv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.left.val]\\n                    curr_set.add(i)\\n                    lnode=trees[i]\\n                    root.left=lnode\\n                    a1=check_bst(lnode,curr_set,minv,root.val-1)\\n                \\n            a2=True\\n            if(root.right is not None):\\n                if(root.right.val not in td):\\n                    if(root.right.val>maxv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.right.val]\\n                    curr_set.add(i)\\n                    rnode=trees[i]\\n                    root.right=rnode\\n                    a2=check_bst(rnode,curr_set,root.val+1,maxv)\\n            if(a1 == True and a2 == True):\\n                return True\\n            return False\\n        cnt={}\\n        for i,tree in enumerate(trees):\\n            val=tree.val\\n            if(val not in cnt):\\n                cnt[val]=0\\n            cnt[val]+=1\\n            \\n            lval=None\\n            rval=None\\n            if(tree.left is not None):\\n                lval=tree.left.val\\n                if(lval not in cnt):\\n                    cnt[lval]=0\\n                cnt[lval]+=1\\n            if(tree.right is not None):\\n                rval=tree.right.val\\n                if(rval not in cnt):\\n                    cnt[rval]=0\\n                cnt[rval]+=1\\n            \\n            td[val]=i\\n        for i,tree in enumerate(trees):\\n            #try trees[i] as root\\n            st=set()\\n            st.add(i)\\n            if(cnt[tree.val]==1):#only one root has count==1, other root count>=2\\n                rslt = check_bst(tree,st,minval,maxval)\\n                if(rslt == True and len(st)==len(trees)):\\n                    #build_bst(tree)\\n                    return tree\\n                else:\\n                    return None\\n        return None\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        minval=-1\\n        maxval=5*(10**4)+1\\n        td={}\\n        def check_bst(root,curr_set,minv,maxv):\\n            if(root is None):\\n                return True\\n            if(root.val<minv or root.val>maxv):\\n                return False\\n            a1=True\\n            if(root.left is not None):\\n                if(root.left.val not in td):# end of search, finish construct left\\n                    if(root.left.val<minv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.left.val]\\n                    curr_set.add(i)\\n                    lnode=trees[i]\\n                    root.left=lnode\\n                    a1=check_bst(lnode,curr_set,minv,root.val-1)\\n                \\n            a2=True\\n            if(root.right is not None):\\n                if(root.right.val not in td):\\n                    if(root.right.val>maxv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.right.val]\\n                    curr_set.add(i)\\n                    rnode=trees[i]\\n                    root.right=rnode\\n                    a2=check_bst(rnode,curr_set,root.val+1,maxv)\\n            if(a1 == True and a2 == True):\\n                return True\\n            return False\\n        cnt={}\\n        for i,tree in enumerate(trees):\\n            val=tree.val\\n            if(val not in cnt):\\n                cnt[val]=0\\n            cnt[val]+=1\\n            \\n            lval=None\\n            rval=None\\n            if(tree.left is not None):\\n                lval=tree.left.val\\n                if(lval not in cnt):\\n                    cnt[lval]=0\\n                cnt[lval]+=1\\n            if(tree.right is not None):\\n                rval=tree.right.val\\n                if(rval not in cnt):\\n                    cnt[rval]=0\\n                cnt[rval]+=1\\n            \\n            td[val]=i\\n        for i,tree in enumerate(trees):\\n            #try trees[i] as root\\n            st=set()\\n            st.add(i)\\n            if(cnt[tree.val]==1):#only one root has count==1, other root count>=2\\n                rslt = check_bst(tree,st,minval,maxval)\\n                if(rslt == True and len(st)==len(trees)):\\n                    #build_bst(tree)\\n                    return tree\\n                else:\\n                    return None\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336000,
                "title": "wrong-answer",
                "content": "For the input - [[2,null,3],[1,null,3],[3,2]]\\nWhy isn\\'t the following a correct answer - [1,null,3,2,null,null,3] ? It\\'s a valid BST.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1335819,
                "title": "python-stack-99-99",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        # trivial, single BST\\n        if len(trees) == 1:\\n            return trees[0]\\n        # build a dictionary of tree by root\\n        treesByRoot = dict()\\n        # keep track of all leaves\\n        leafSet = set()\\n        # put single nodes root-leaves separately\\n        singles = set()\\n        # sort out all trees populate 3 strucutures above\\n        for root in trees:\\n            if root.left is None and root.right is None:\\n                singles.add(root.val)\\n            else:\\n                treesByRoot[root.val] = root\\n                if root.left is not None:\\n                    if root.left.val in leafSet:\\n                        return None\\n                    leafSet.add(root.left.val)\\n\\n                if root.right is not None:\\n                    if root.right.val in leafSet:\\n                        return None\\n                    leafSet.add(root.right.val)\\n        # any single node must be a leaf somewhere, sanity check\\n        # single tree case was eliminated at the beginning\\n        if not singles.issubset(leafSet):\\n            return None\\n        \\n        # find a root of the resulting tree, must be on leaf anywhere and must be only one such root\\n        resultRoot = None\\n        for root in trees:\\n            if root.val not in leafSet:\\n                if resultRoot is None:\\n                    resultRoot = root\\n                else:\\n                    # second root found, impossible to build a tree\\n                    return None\\n        # no root found, impossible to build a tree\\n        if resultRoot is None:\\n            return None\\n        # remove the tree from the root dic\\n        del treesByRoot[resultRoot.val]\\n        # use a stack to walk down the tree and grow the brachnes as needed\\n        # also keep track of lower/upper bounds to make sure our BST is valid\\n        st = [(resultRoot, -math.inf, math.inf)]\\n        while st:\\n            # get the last subtree\\n            cur, lb, ub = st.pop()\\n            # grow the left branch if possible\\n            if cur.left is not None:\\n                v = cur.left.val\\n                if v <= lb or v >= ub:\\n                    # BST bound violation\\n                    return None\\n                try:\\n                    # grow the left branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.left = t\\n                    # put the new branch to the stack, with new upper bound as it grew left\\n                    st.append((t, lb, cur.val))\\n                except KeyError:\\n                    pass\\n            # analogous for the right\\n            if cur.right is not None:\\n                v = cur.right.val\\n                if v <= lb or v >= ub:\\n                    return None\\n                try:\\n                    # grow the right branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.right = t\\n                    # put the new branch to the stack, with new upper lower as it grew right\\n                    st.append((t, cur.val, ub))\\n                except KeyError:\\n                    pass\\n                \\n        \\n        # if not all subtrees are used, then no single BST result\\n        if treesByRoot:\\n            return None\\n        else:\\n            return resultRoot\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        # trivial, single BST\\n        if len(trees) == 1:\\n            return trees[0]\\n        # build a dictionary of tree by root\\n        treesByRoot = dict()\\n        # keep track of all leaves\\n        leafSet = set()\\n        # put single nodes root-leaves separately\\n        singles = set()\\n        # sort out all trees populate 3 strucutures above\\n        for root in trees:\\n            if root.left is None and root.right is None:\\n                singles.add(root.val)\\n            else:\\n                treesByRoot[root.val] = root\\n                if root.left is not None:\\n                    if root.left.val in leafSet:\\n                        return None\\n                    leafSet.add(root.left.val)\\n\\n                if root.right is not None:\\n                    if root.right.val in leafSet:\\n                        return None\\n                    leafSet.add(root.right.val)\\n        # any single node must be a leaf somewhere, sanity check\\n        # single tree case was eliminated at the beginning\\n        if not singles.issubset(leafSet):\\n            return None\\n        \\n        # find a root of the resulting tree, must be on leaf anywhere and must be only one such root\\n        resultRoot = None\\n        for root in trees:\\n            if root.val not in leafSet:\\n                if resultRoot is None:\\n                    resultRoot = root\\n                else:\\n                    # second root found, impossible to build a tree\\n                    return None\\n        # no root found, impossible to build a tree\\n        if resultRoot is None:\\n            return None\\n        # remove the tree from the root dic\\n        del treesByRoot[resultRoot.val]\\n        # use a stack to walk down the tree and grow the brachnes as needed\\n        # also keep track of lower/upper bounds to make sure our BST is valid\\n        st = [(resultRoot, -math.inf, math.inf)]\\n        while st:\\n            # get the last subtree\\n            cur, lb, ub = st.pop()\\n            # grow the left branch if possible\\n            if cur.left is not None:\\n                v = cur.left.val\\n                if v <= lb or v >= ub:\\n                    # BST bound violation\\n                    return None\\n                try:\\n                    # grow the left branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.left = t\\n                    # put the new branch to the stack, with new upper bound as it grew left\\n                    st.append((t, lb, cur.val))\\n                except KeyError:\\n                    pass\\n            # analogous for the right\\n            if cur.right is not None:\\n                v = cur.right.val\\n                if v <= lb or v >= ub:\\n                    return None\\n                try:\\n                    # grow the right branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.right = t\\n                    # put the new branch to the stack, with new upper lower as it grew right\\n                    st.append((t, cur.val, ub))\\n                except KeyError:\\n                    pass\\n                \\n        \\n        # if not all subtrees are used, then no single BST result\\n        if treesByRoot:\\n            return None\\n        else:\\n            return resultRoot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335528,
                "title": "c-solution-but-messy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int counter=0;\\n    bool isbst(TreeNode* root, int maxi, int mini){\\n        if(root==nullptr) return true;\\n        counter++;\\n        if(root->val> maxi || root->val < mini) return false;\\n        \\n        \\n        bool ans= isbst(root->left, root->val, mini) && isbst(root->right, maxi,root->val);\\n        return ans;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        unordered_map<int,pair<int ,TreeNode*> > mp;  //left, right node map\\n        unordered_map<int,int> mp2; //to count unique nodes so that we can check at the end the size of bst returned by ans\\n        int total=0;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=nullptr){\\n                if(mp2[trees[i]->val]==0) total++;\\n                mp2[trees[i]->val]=1; //help in counting unique nodes\\n                if(trees[i]->left){\\n                    if(mp2[trees[i]->left->val]==0) total++;\\n                    mp2[trees[i]->left->val]=1;\\n                    if(mp[trees[i]->left->val].first!=0){\\n                        return nullptr; //if already exist in map return nullptr\\n                    }\\n                    mp[trees[i]->left->val].first=1;\\n                    mp[trees[i]->left->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->left->val) return nullptr; //checks whether there is a loop ((null,1,3), (3,1,null),(2,4)) type loop\\n                }\\n                if(trees[i]->right){\\n                    if(mp2[trees[i]->right->val]==0) total++;\\n                    mp2[trees[i]->right->val]=1;\\n                    \\n                    if(mp[trees[i]->right->val].first!=0){\\n                        return nullptr;\\n                    }\\n                    mp[trees[i]->right->val].first=2;\\n                    mp[trees[i]->right->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->right->val) return nullptr;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        int cont=0;\\n\\n        TreeNode* ans=nullptr;\\n        for(int i=0;i<trees.size(); i++){\\n            if(mp[trees[i]->val].first==0){\\n                ans=trees[i];\\n                cont++;\\n            }\\n            else if(mp[trees[i]->val].first==1){\\n                mp[trees[i]->val].second->left=trees[i];\\n                mp[trees[i]->val].first=0;\\n            }\\n            else if(mp[trees[i]->val].first==2){\\n                mp[trees[i]->val].second->right=trees[i];\\n                 mp[trees[i]->val].first=0;\\n            }\\n            \\n            if(cont>=2) return nullptr;\\n        }\\n        \\n        if(isbst(ans,500000,-1)){\\n            if(total!=counter) return nullptr;\\n                return ans;\\n        } \\n        \\n        \\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int counter=0;\\n    bool isbst(TreeNode* root, int maxi, int mini){\\n        if(root==nullptr) return true;\\n        counter++;\\n        if(root->val> maxi || root->val < mini) return false;\\n        \\n        \\n        bool ans= isbst(root->left, root->val, mini) && isbst(root->right, maxi,root->val);\\n        return ans;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        unordered_map<int,pair<int ,TreeNode*> > mp;  //left, right node map\\n        unordered_map<int,int> mp2; //to count unique nodes so that we can check at the end the size of bst returned by ans\\n        int total=0;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=nullptr){\\n                if(mp2[trees[i]->val]==0) total++;\\n                mp2[trees[i]->val]=1; //help in counting unique nodes\\n                if(trees[i]->left){\\n                    if(mp2[trees[i]->left->val]==0) total++;\\n                    mp2[trees[i]->left->val]=1;\\n                    if(mp[trees[i]->left->val].first!=0){\\n                        return nullptr; //if already exist in map return nullptr\\n                    }\\n                    mp[trees[i]->left->val].first=1;\\n                    mp[trees[i]->left->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->left->val) return nullptr; //checks whether there is a loop ((null,1,3), (3,1,null),(2,4)) type loop\\n                }\\n                if(trees[i]->right){\\n                    if(mp2[trees[i]->right->val]==0) total++;\\n                    mp2[trees[i]->right->val]=1;\\n                    \\n                    if(mp[trees[i]->right->val].first!=0){\\n                        return nullptr;\\n                    }\\n                    mp[trees[i]->right->val].first=2;\\n                    mp[trees[i]->right->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->right->val) return nullptr;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        int cont=0;\\n\\n        TreeNode* ans=nullptr;\\n        for(int i=0;i<trees.size(); i++){\\n            if(mp[trees[i]->val].first==0){\\n                ans=trees[i];\\n                cont++;\\n            }\\n            else if(mp[trees[i]->val].first==1){\\n                mp[trees[i]->val].second->left=trees[i];\\n                mp[trees[i]->val].first=0;\\n            }\\n            else if(mp[trees[i]->val].first==2){\\n                mp[trees[i]->val].second->right=trees[i];\\n                 mp[trees[i]->val].first=0;\\n            }\\n            \\n            if(cont>=2) return nullptr;\\n        }\\n        \\n        if(isbst(ans,500000,-1)){\\n            if(total!=counter) return nullptr;\\n                return ans;\\n        } \\n        \\n        \\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334278,
                "title": "easy-to-understand-java-solution-bfs-looping",
                "content": "```\\nint prev = Integer.MIN_VALUE;\\n    public boolean isValid(TreeNode root){\\n        if(root != null){\\n            if(!isValid(root.left)) return false;\\n            if(root.val<=prev) return false;\\n            prev=root.val;\\n            return isValid(root.right);\\n        }\\n        return true;\\n    }\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode node:trees)\\n            map.put(node.val, node);\\n        Set<Integer> merged = new HashSet<>(); // If root is already merged with other, can\\'t use that\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                Set<Integer> set = new HashSet<>(); // If child is already one of the roots \\n                set.add(node.val);\\n                Queue<TreeNode> queue = new LinkedList<>();\\n                queue.add(node);\\n                while(!queue.isEmpty()){\\n                    TreeNode n = queue.remove();\\n                    if(n.left!=null && map.containsKey(n.left.val) && !set.contains(n.left.val) && !merged.contains(n.left.val)){\\n                        n.left = map.get(n.left.val);\\n                        set.add(n.left.val);\\n                        merged.add(n.left.val);\\n                        queue.add(n.left);\\n                    }\\n                    if(n.right!=null && map.containsKey(n.right.val) && !set.contains(n.right.val) && !merged.contains(n.right.val)){\\n                        n.right=map.get(n.right.val);\\n                        set.add(n.right.val);\\n                        merged.add(n.right.val);\\n                        queue.add(n.right);\\n                    }\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        TreeNode ans=null;\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                cnt++;\\n                ans=node;\\n            }\\n            if(cnt>1) return null;\\n        }\\n        System.out.println(cnt);\\n        if(isValid(ans)) return ans;\\n        System.out.println(\"Invalid\");\\n        return null;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nint prev = Integer.MIN_VALUE;\\n    public boolean isValid(TreeNode root){\\n        if(root != null){\\n            if(!isValid(root.left)) return false;\\n            if(root.val<=prev) return false;\\n            prev=root.val;\\n            return isValid(root.right);\\n        }\\n        return true;\\n    }\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode node:trees)\\n            map.put(node.val, node);\\n        Set<Integer> merged = new HashSet<>(); // If root is already merged with other, can\\'t use that\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                Set<Integer> set = new HashSet<>(); // If child is already one of the roots \\n                set.add(node.val);\\n                Queue<TreeNode> queue = new LinkedList<>();\\n                queue.add(node);\\n                while(!queue.isEmpty()){\\n                    TreeNode n = queue.remove();\\n                    if(n.left!=null && map.containsKey(n.left.val) && !set.contains(n.left.val) && !merged.contains(n.left.val)){\\n                        n.left = map.get(n.left.val);\\n                        set.add(n.left.val);\\n                        merged.add(n.left.val);\\n                        queue.add(n.left);\\n                    }\\n                    if(n.right!=null && map.containsKey(n.right.val) && !set.contains(n.right.val) && !merged.contains(n.right.val)){\\n                        n.right=map.get(n.right.val);\\n                        set.add(n.right.val);\\n                        merged.add(n.right.val);\\n                        queue.add(n.right);\\n                    }\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        TreeNode ans=null;\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                cnt++;\\n                ans=node;\\n            }\\n            if(cnt>1) return null;\\n        }\\n        System.out.println(cnt);\\n        if(isValid(ans)) return ans;\\n        System.out.println(\"Invalid\");\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1334013,
                "title": "easy-java-with-comments-36ms",
                "content": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> mapRoots  = new HashMap<>();\\n        Map<Integer, TreeNode> mapLeaves  = new HashMap<>();\\n        \\n        //check all trees and hashMap all available roots and leaves \\n        for(TreeNode node : trees){\\n            mapRoots.put(node.val, node);\\n            if(node.left != null){\\n                if(mapLeaves.containsKey(node.left.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.left.val, node.left);\\n            }\\n            if(node.right != null){\\n                if(mapLeaves.containsKey(node.right.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.right.val, node.right);\\n            }\\n        }\\n        \\n        TreeNode rootRes = null;\\n        int count = trees.size();\\n        \\n        //find potential root-result of the merged entire tree\\n        //that is node without any references from the parent leaf nodes\\n        for(TreeNode node : trees){\\n            if(!mapLeaves.containsKey(node.val)){ \\n                rootRes = node;\\n                break;\\n            }     \\n        }\\n        \\n        //if there are no nodes like that -> abnormal BST\\n        if(rootRes==null)\\n            return rootRes;\\n          \\n        Queue<TreeNode> q = new LinkedList<>();\\n        \\n        //put root-result leaves into queue\\n        if(rootRes.left != null)\\n            q.offer(rootRes.left);\\n        if(rootRes.right != null)\\n            q.offer(rootRes.right);\\n        count--;\\n        \\n        while(!q.isEmpty()){\\n            //get leaf from the queue and check if there is correponding available root\\n            TreeNode leaf = q.poll();\\n            TreeNode root = mapRoots.get(leaf.val);\\n            if(root != null){\\n                //there is root matched to leaf, so let\\'s merge it\\n                count--;\\n                leaf.left  = root.left;\\n                leaf.right = root.right;\\n                //add new leaves into the queue\\n                if(root.left != null)\\n                    q.offer(root.left);\\n                if(root.right != null)\\n                    q.offer(root.right);\\n            }\\n        }\\n        \\n        prev=0;\\n        //if we have merged all inputed trees and that is valid BST by values, then return rootRes\\n        return count==0 && recSanity(rootRes) ? rootRes : null;\\n    }\\n    \\n    private int prev;\\n    private boolean recSanity(TreeNode node){\\n        if(node==null)\\n            return true;\\n\\n        if(!recSanity(node.left))\\n            return false;\\n\\n        if(prev >= node.val)\\n            return false;\\n        prev = node.val;\\n        \\n        return  recSanity(node.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> mapRoots  = new HashMap<>();\\n        Map<Integer, TreeNode> mapLeaves  = new HashMap<>();\\n        \\n        //check all trees and hashMap all available roots and leaves \\n        for(TreeNode node : trees){\\n            mapRoots.put(node.val, node);\\n            if(node.left != null){\\n                if(mapLeaves.containsKey(node.left.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.left.val, node.left);\\n            }\\n            if(node.right != null){\\n                if(mapLeaves.containsKey(node.right.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.right.val, node.right);\\n            }\\n        }\\n        \\n        TreeNode rootRes = null;\\n        int count = trees.size();\\n        \\n        //find potential root-result of the merged entire tree\\n        //that is node without any references from the parent leaf nodes\\n        for(TreeNode node : trees){\\n            if(!mapLeaves.containsKey(node.val)){ \\n                rootRes = node;\\n                break;\\n            }     \\n        }\\n        \\n        //if there are no nodes like that -> abnormal BST\\n        if(rootRes==null)\\n            return rootRes;\\n          \\n        Queue<TreeNode> q = new LinkedList<>();\\n        \\n        //put root-result leaves into queue\\n        if(rootRes.left != null)\\n            q.offer(rootRes.left);\\n        if(rootRes.right != null)\\n            q.offer(rootRes.right);\\n        count--;\\n        \\n        while(!q.isEmpty()){\\n            //get leaf from the queue and check if there is correponding available root\\n            TreeNode leaf = q.poll();\\n            TreeNode root = mapRoots.get(leaf.val);\\n            if(root != null){\\n                //there is root matched to leaf, so let\\'s merge it\\n                count--;\\n                leaf.left  = root.left;\\n                leaf.right = root.right;\\n                //add new leaves into the queue\\n                if(root.left != null)\\n                    q.offer(root.left);\\n                if(root.right != null)\\n                    q.offer(root.right);\\n            }\\n        }\\n        \\n        prev=0;\\n        //if we have merged all inputed trees and that is valid BST by values, then return rootRes\\n        return count==0 && recSanity(rootRes) ? rootRes : null;\\n    }\\n    \\n    private int prev;\\n    private boolean recSanity(TreeNode node){\\n        if(node==null)\\n            return true;\\n\\n        if(!recSanity(node.left))\\n            return false;\\n\\n        if(prev >= node.val)\\n            return false;\\n        prev = node.val;\\n        \\n        return  recSanity(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333368,
                "title": "python-it-is-not-the-best-solution-but-at-least-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        def isValidBST(root: TreeNode) -> bool:\\n            def recursive(root, minimum, maximum):\\n                if root == None:\\n                    return True\\n                elif minimum < root.val < maximum:\\n                    return recursive(root.left, minimum, root.val) and recursive(root.right, root.val, maximum)\\n                else:\\n                    return False\\n            return recursive(root, float(\"-inf\"), float(\"+inf\"))\\n        \\n        # If two trees have the same values we need to return None because it is not possible to build a bst\\n        trees_values = set()\\n        for tree in trees:\\n            a = [tree.val]\\n            if tree.left != None:\\n                a.append(tree.left.val)\\n            if tree.right != None:\\n                a.append(tree.right.val)\\n            \\n            a.sort()\\n            \\n            if tuple(a) in trees_values:\\n                return None\\n            else:\\n                trees_values.add(tuple(a))\\n        \\n        # Obtain the children\\n        children = {}\\n        for i, tree in enumerate(trees):\\n            if tree.left != None:\\n                if tree.left.val in children:\\n                    return None\\n                else:\\n                    children[tree.left.val] = [\"l\", i]\\n            \\n            if tree.right != None:\\n                if tree.right.val in children:\\n                    return None\\n                else:\\n                    children[tree.right.val] = [\"r\", i]\\n        \\n        # Swap childrens with roots of other trees\\n        possible_roots = set([i for i in range(len(trees))])\\n        for i, tree in enumerate(trees):\\n            if tree.val in children:\\n                p, index = children[tree.val]\\n                if p == \"l\":\\n                    trees[index].left = tree\\n                else:\\n                    trees[index].right = tree\\n                \\n                # The root that we are checking can\\'t be our root\\n                possible_roots.remove(i)\\n                \\n        \\n        # There can be only a unique solution\\n        if len(possible_roots) == 1:\\n            index = possible_roots.pop()\\n            # Check if BST\\n            if isValidBST(trees[index]):\\n                return trees[index]\\n            \\n        return None\\n        \\n                \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        def isValidBST(root: TreeNode) -> bool:\\n            def recursive(root, minimum, maximum):\\n                if root == None:\\n                    return True\\n                elif minimum < root.val < maximum:\\n                    return recursive(root.left, minimum, root.val) and recursive(root.right, root.val, maximum)\\n                else:\\n                    return False\\n            return recursive(root, float(\"-inf\"), float(\"+inf\"))\\n        \\n        # If two trees have the same values we need to return None because it is not possible to build a bst\\n        trees_values = set()\\n        for tree in trees:\\n            a = [tree.val]\\n            if tree.left != None:\\n                a.append(tree.left.val)\\n            if tree.right != None:\\n                a.append(tree.right.val)\\n            \\n            a.sort()\\n            \\n            if tuple(a) in trees_values:\\n                return None\\n            else:\\n                trees_values.add(tuple(a))\\n        \\n        # Obtain the children\\n        children = {}\\n        for i, tree in enumerate(trees):\\n            if tree.left != None:\\n                if tree.left.val in children:\\n                    return None\\n                else:\\n                    children[tree.left.val] = [\"l\", i]\\n            \\n            if tree.right != None:\\n                if tree.right.val in children:\\n                    return None\\n                else:\\n                    children[tree.right.val] = [\"r\", i]\\n        \\n        # Swap childrens with roots of other trees\\n        possible_roots = set([i for i in range(len(trees))])\\n        for i, tree in enumerate(trees):\\n            if tree.val in children:\\n                p, index = children[tree.val]\\n                if p == \"l\":\\n                    trees[index].left = tree\\n                else:\\n                    trees[index].right = tree\\n                \\n                # The root that we are checking can\\'t be our root\\n                possible_roots.remove(i)\\n                \\n        \\n        # There can be only a unique solution\\n        if len(possible_roots) == 1:\\n            index = possible_roots.pop()\\n            # Check if BST\\n            if isValidBST(trees[index]):\\n                return trees[index]\\n            \\n        return None\\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332382,
                "title": "python-3-short-and-simple-with-comments",
                "content": "**Key insight about binary search trees**\\n1) There cannot be repeated values\\n2) We can build a binary seach tree recursively keeping track of the lower bound and upper bound of values while connecting nodes\\n```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {t.val: t for t in trees}                   # Map of val -> tree that we will extract all nodes from\\n        c = Counter()\\n        for t in trees: \\n            if t.left: c[t.left.val] += 1\\n            if t.right: c[t.right.val] += 1\\n        if any(v > 1 for v in c.values()): return None  # BST has no repeated values\\n        \\n        roots = [t for t in trees if t.val not in c]    # Root value cannot be a leaf value because BST has no repeated values\\n        if len(roots) != 1: return None                 # We can only have one root\\n        root = m.pop(roots[0].val)                      # Remove root from map\\n        \\n        def build(n, lb, rb):                           # Recursive function to build out tree\\n            if (n.left and n.left.val < lb) or (n.right and n.right.val > rb): return False  \\n            if n.left and n.left.val in m: \\n                n.left = m.pop(n.left.val)\\n                if not build(n.left, lb, n.val): return False\\n            if n.right and n.right.val in m: \\n                n.right = m.pop(n.right.val)\\n                if not build(n.right, n.val, rb): return False\\n            return True\\n        \\n        if not build(root, -inf, inf) or m: return None # If build ever returns False or there are still nodes in m, somethings not right\\n        return root",
                "solutionTags": [],
                "code": "class Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {t.val: t for t in trees}",
                "codeTag": "Java"
            },
            {
                "id": 1332164,
                "title": "go-poorly-implemented-answer-verification-causes-correct-solution-to-time-out",
                "content": "I found it took ~4s to verify the correctness of my returned tree for a huge test case, while the actually runtime of my code only took less than a second. As a result, my solution exceeded time limit.\\n\\nHad to translate my Go code to Python to pass all test cases.\\n\\nPlease fix!\\n\\nGo:\\n```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tvalToNode := make(map[int]*TreeNode)\\n\\tvalCounter := make(map[int]int)\\n\\tn := len(trees)\\n\\tops := n - 1 // should take exactly n-1 operations\\n\\n\\tfor _, t := range trees {\\n\\t\\tvalToNode[t.Val] = t\\n\\t\\tvalCounter[t.Val] = 1\\n\\t}\\n\\tfor _, t := range trees {\\n\\t\\tif t.Left != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Left.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Left.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif t.Right != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Right.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Right.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar root *TreeNode\\n\\tfor val, node := range valToNode {\\n\\t\\tif valCounter[val] == 1 {\\n\\t\\t\\troot = node\\n\\t\\t}\\n\\t}\\n\\n\\tstack := make([]*TreeNode, 0)\\n\\tprev := math.MinInt32\\n\\tnode := root\\n\\tfor node != nil || len(stack) != 0 {\\n\\t\\tfor node != nil {\\n\\t\\t\\tstack = append(stack, node)\\n\\t\\t\\tif node.Left != nil {\\n\\t\\t\\t\\tif child, ok := valToNode[node.Left.Val]; ok {\\n\\t\\t\\t\\t\\tnode.Left = child\\n\\t\\t\\t\\t\\tops--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.Left\\n\\t\\t}\\n\\t\\tnode = stack[len(stack)-1]\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t\\tif node.Val <= prev {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\tprev = node.Val\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tif child, ok := valToNode[node.Right.Val]; ok {\\n\\t\\t\\t\\tnode.Right = child\\n\\t\\t\\t\\tops--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnode = node.Right\\n\\t}\\n\\n\\tif ops > 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\treturn root\\n}\\n```\\n\\nPython:\\n```python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {}\\n        cnt = collections.Counter()\\n        l = len(trees)\\n        ops = l-1\\n        \\n        for t in trees:\\n            m[t.val] = t\\n            cnt[t.val] += 1\\n            \\n        for t in trees:\\n            if t.left:\\n                cnt[t.left.val] += 1\\n            if t.right:\\n                cnt[t.right.val] += 1\\n        \\n        root = None\\n        for k, v in m.items():\\n            if cnt[k] == 1:\\n                root = v\\n        \\n        stack = list()\\n        prev = -2147483648\\n        node = root\\n        while node or len(stack) != 0:\\n            while node:\\n                stack.append(node)\\n                if node.left and node.left.val in m:\\n                    node.left = m[node.left.val]\\n                    ops -= 1\\n                node = node.left\\n            node = stack.pop()\\n            if node.val <= prev:\\n                return None\\n            prev = node.val\\n            if node.right and node.right.val in m:\\n                node.right = m[node.right.val]\\n                ops -= 1\\n            node = node.right\\n                    \\n        if ops > 0:\\n            return None\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tvalToNode := make(map[int]*TreeNode)\\n\\tvalCounter := make(map[int]int)\\n\\tn := len(trees)\\n\\tops := n - 1 // should take exactly n-1 operations\\n\\n\\tfor _, t := range trees {\\n\\t\\tvalToNode[t.Val] = t\\n\\t\\tvalCounter[t.Val] = 1\\n\\t}\\n\\tfor _, t := range trees {\\n\\t\\tif t.Left != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Left.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Left.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif t.Right != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Right.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Right.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar root *TreeNode\\n\\tfor val, node := range valToNode {\\n\\t\\tif valCounter[val] == 1 {\\n\\t\\t\\troot = node\\n\\t\\t}\\n\\t}\\n\\n\\tstack := make([]*TreeNode, 0)\\n\\tprev := math.MinInt32\\n\\tnode := root\\n\\tfor node != nil || len(stack) != 0 {\\n\\t\\tfor node != nil {\\n\\t\\t\\tstack = append(stack, node)\\n\\t\\t\\tif node.Left != nil {\\n\\t\\t\\t\\tif child, ok := valToNode[node.Left.Val]; ok {\\n\\t\\t\\t\\t\\tnode.Left = child\\n\\t\\t\\t\\t\\tops--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.Left\\n\\t\\t}\\n\\t\\tnode = stack[len(stack)-1]\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t\\tif node.Val <= prev {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\tprev = node.Val\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tif child, ok := valToNode[node.Right.Val]; ok {\\n\\t\\t\\t\\tnode.Right = child\\n\\t\\t\\t\\tops--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnode = node.Right\\n\\t}\\n\\n\\tif ops > 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\treturn root\\n}\\n```\n```python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {}\\n        cnt = collections.Counter()\\n        l = len(trees)\\n        ops = l-1\\n        \\n        for t in trees:\\n            m[t.val] = t\\n            cnt[t.val] += 1\\n            \\n        for t in trees:\\n            if t.left:\\n                cnt[t.left.val] += 1\\n            if t.right:\\n                cnt[t.right.val] += 1\\n        \\n        root = None\\n        for k, v in m.items():\\n            if cnt[k] == 1:\\n                root = v\\n        \\n        stack = list()\\n        prev = -2147483648\\n        node = root\\n        while node or len(stack) != 0:\\n            while node:\\n                stack.append(node)\\n                if node.left and node.left.val in m:\\n                    node.left = m[node.left.val]\\n                    ops -= 1\\n                node = node.left\\n            node = stack.pop()\\n            if node.val <= prev:\\n                return None\\n            prev = node.val\\n            if node.right and node.right.val in m:\\n                node.right = m[node.right.val]\\n                ops -= 1\\n            node = node.right\\n                    \\n        if ops > 0:\\n            return None\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331256,
                "title": "c-hash-map-commented-code",
                "content": "```\\nclass Solution {\\n    //check if tree is BST or not\\n    bool isvalidBST(TreeNode* root,int mn,int mx){\\n        if(root==nullptr) return true;\\n        if(root->val<=mn || root->val>=mx) return false;\\n        return isvalidBST(root->left,mn,root->val) && isvalidBST(root->right,root->val,mx) ;\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> m1;\\n        vector<int> m2(50001,0);\\n        \\n        // store ptr corresponding to values\\n        // store values cnt, so can take cnt=1 as root;\\n        for(int i=0;i<trees.size();i++){\\n            m1[trees[i]->val]=trees[i];\\n            m2[trees[i]->val]++;\\n            if(trees[i]->left!=nullptr) m2[trees[i]->left->val]++;\\n            if((trees[i]->right!=nullptr)) m2[trees[i]->right->val]++;\\n        }\\n        // find one root such that cnt=1; So, nonode can be merged with this.\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            if(m2[trees[i]->val]==1){\\n                root=trees[i];\\n                break;\\n            }\\n        }\\n        \\n        // making Tree\\n        queue<TreeNode*> leaves;\\n        leaves.push(root);\\n        while(!leaves.empty() && !m1.empty()){\\n            // get one leaf on current tree\\n            TreeNode* leaf = leaves.front(); leaves.pop();\\n            auto it= leaf==nullptr?end(m1):m1.find(leaf->val);\\n            \\n            // if we can\\'t attach to it\\n            if(it==end(m1)) continue;\\n            \\n            // add left, right to current tree leaf\\n            leaf->left=it->second->left;\\n            leaf->right=it->second->right;\\n            \\n            // erase used trees\\n            m1.erase(it);\\n            \\n            // put new leaves made in queue \\n            if(leaf->left!=nullptr) leaves.push(leaf->left);\\n            if((leaf->right!=nullptr)) leaves.push(leaf->right);\\n        }\\n        \\n        // check if every root is used and tree made is BST\\n        return (m1.empty() && isvalidBST(root,INT_MIN,INT_MAX))?root:nullptr;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //check if tree is BST or not\\n    bool isvalidBST(TreeNode* root,int mn,int mx){\\n        if(root==nullptr) return true;\\n        if(root->val<=mn || root->val>=mx) return false;\\n        return isvalidBST(root->left,mn,root->val) && isvalidBST(root->right,root->val,mx) ;\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> m1;\\n        vector<int> m2(50001,0);\\n        \\n        // store ptr corresponding to values\\n        // store values cnt, so can take cnt=1 as root;\\n        for(int i=0;i<trees.size();i++){\\n            m1[trees[i]->val]=trees[i];\\n            m2[trees[i]->val]++;\\n            if(trees[i]->left!=nullptr) m2[trees[i]->left->val]++;\\n            if((trees[i]->right!=nullptr)) m2[trees[i]->right->val]++;\\n        }\\n        // find one root such that cnt=1; So, nonode can be merged with this.\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            if(m2[trees[i]->val]==1){\\n                root=trees[i];\\n                break;\\n            }\\n        }\\n        \\n        // making Tree\\n        queue<TreeNode*> leaves;\\n        leaves.push(root);\\n        while(!leaves.empty() && !m1.empty()){\\n            // get one leaf on current tree\\n            TreeNode* leaf = leaves.front(); leaves.pop();\\n            auto it= leaf==nullptr?end(m1):m1.find(leaf->val);\\n            \\n            // if we can\\'t attach to it\\n            if(it==end(m1)) continue;\\n            \\n            // add left, right to current tree leaf\\n            leaf->left=it->second->left;\\n            leaf->right=it->second->right;\\n            \\n            // erase used trees\\n            m1.erase(it);\\n            \\n            // put new leaves made in queue \\n            if(leaf->left!=nullptr) leaves.push(leaf->left);\\n            if((leaf->right!=nullptr)) leaves.push(leaf->right);\\n        }\\n        \\n        // check if every root is used and tree made is BST\\n        return (m1.empty() && isvalidBST(root,INT_MIN,INT_MAX))?root:nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330874,
                "title": "c-bottom-up-approach-post-order-traversal-unordered-map",
                "content": "class Solution {\\npublic:\\n\\n    unordered_map<int,TreeNode*> mapping;\\n    bool bst=true;\\n    TreeNode* merge(TreeNode*root,TreeNode*actual_root,int left=INT_MIN,int right=INT_MAX){\\n        if(!root){\\n            return nullptr;\\n        }\\n        if(!bst){\\n            return root;\\n        }\\n        if(root->val<=left or root->val>=right){\\n            bst=false;\\n            return root;\\n        }\\n        root->left=merge(root->left,actual_root,left,root->val);\\n        root->right=merge(root->right,actual_root,root->val,right);\\n        if(!root->left and !root->right){\\n            if(mapping.find(root->val)!=mapping.end() and mapping.at(root->val)!=root and mapping.at(root->val)!=actual_root){\\n                root=mapping[root->val];\\n                mapping.erase(root->val);\\n                return merge(root,actual_root,left,right);\\n            }\\n            \\n        }\\n        return root;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto&it:trees){\\n            mapping[it->val]=it;\\n        }\\n        TreeNode*ans=nullptr;\\n        for(auto&it:mapping){\\n            merge(it.second,it.second);\\n            ans=it.second;\\n            if(!bst){\\n                return nullptr;\\n            }\\n        }\\n        if(mapping.size()>1){\\n            return nullptr;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    unordered_map<int,TreeNode*> mapping;\\n    bool bst=true;\\n    TreeNode* merge(TreeNode*root,TreeNode*actual_root,int left=INT_MIN,int right=INT_MAX){\\n        if(!root){\\n            return nullptr;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1330811,
                "title": "c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_map<TreeNode*,pair<int,int>>vals;\\n        for(int i=0;i<trees.size();i++){\\n            int right=trees[i]->right==NULL?trees[i]->val:trees[i]->right->val;\\n            int left=trees[i]->left==NULL?trees[i]->val:trees[i]->left->val;\\n            vals[trees[i]]=make_pair(left,right);\\n            \\n            if(trees[i]->left){\\n                mp[trees[i]->left->val]=trees[i];\\n            }\\n            if(trees[i]->right){\\n                mp[trees[i]->right->val]=trees[i];\\n            }\\n        }\\n        bool flag=0;\\n        // int count=0;\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            // cout<<trees[i]->val<<endl;\\n            if(mp.find(trees[i]->val)!=mp.end()){\\n                TreeNode* node=mp[trees[i]->val];\\n                if(trees[i]->val<node->val){\\n                    int check=vals[trees[i]].second;\\n                    // cout<<check<<endl;\\n                    if(check<node->val){\\n                        node->left=trees[i];\\n                        vals[node].first=vals[trees[i]].first;\\n                    }\\n                    else return NULL;\\n                }\\n                else{\\n                   int check=vals[trees[i]].first;\\n                    \\n                    if(check>node->val){\\n                        node->right=trees[i];\\n                        vals[node].second=vals[trees[i]].second;\\n                    }\\n                    else return NULL;\\n                }\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                if(flag) return NULL;\\n                else{\\n                    flag=1;\\n                    root=trees[i];\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_map<TreeNode*,pair<int,int>>vals;\\n        for(int i=0;i<trees.size();i++){\\n            int right=trees[i]->right==NULL?trees[i]->val:trees[i]->right->val;\\n            int left=trees[i]->left==NULL?trees[i]->val:trees[i]->left->val;\\n            vals[trees[i]]=make_pair(left,right);\\n            \\n            if(trees[i]->left){\\n                mp[trees[i]->left->val]=trees[i];\\n            }\\n            if(trees[i]->right){\\n                mp[trees[i]->right->val]=trees[i];\\n            }\\n        }\\n        bool flag=0;\\n        // int count=0;\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            // cout<<trees[i]->val<<endl;\\n            if(mp.find(trees[i]->val)!=mp.end()){\\n                TreeNode* node=mp[trees[i]->val];\\n                if(trees[i]->val<node->val){\\n                    int check=vals[trees[i]].second;\\n                    // cout<<check<<endl;\\n                    if(check<node->val){\\n                        node->left=trees[i];\\n                        vals[node].first=vals[trees[i]].first;\\n                    }\\n                    else return NULL;\\n                }\\n                else{\\n                   int check=vals[trees[i]].first;\\n                    \\n                    if(check>node->val){\\n                        node->right=trees[i];\\n                        vals[node].second=vals[trees[i]].second;\\n                    }\\n                    else return NULL;\\n                }\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                if(flag) return NULL;\\n                else{\\n                    flag=1;\\n                    root=trees[i];\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1330540,
                "title": "o-n-time-and-space-find-bst-root-and-build-it-recursively-python",
                "content": "### Approach\\nThree main steps:\\n1. All root values should be at leaf of some tree in given trees, except exactly one. This one is the root of the BST we want to build. We can find this BST root with the help of a few map data structures that will take O(n) space.\\n2. Start building the BST recursively from the BST root. Mark the merged trees as deleted, which will also help detect any cycles.\\n3. Check to make sure that all trees except the BST root are marked as deleted and the BST we built is valid.\\n\\n### Time and Space Complexity\\n* `O(n)` time\\n\\t* We have to do a constant number of passes over the given trees list, each pass taking `O(1)` time\\n* `O(n)` space\\n\\t* We use 3 maps and a set each taking `O(n)` space, \\n\\t* We also use `O(n)` stack space to build the BST recursively\\n```\\n            \\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        val2root = defaultdict()    # to find root tree node from value\\n        rootIndex = defaultdict()   # to find index of a root in trees from value\\n        leaf2root = defaultdict()   # to find tree to replace the leaf with\\n        deleted = set()             # to track deleted tree indices\\n        \\n        # build the data structures\\n        for idx, tree in enumerate(trees):\\n            if tree.left:\\n                leaf2root[tree.left.val] = tree\\n            if tree.right:\\n                leaf2root[tree.right.val] = tree\\n            rootIndex[tree.val] = idx\\n            val2root[tree.val] = tree\\n        \\n        # find the root of the bst to build\\n\\n        bst_root = [tree for tree in trees if tree.val not in leaf2root]\\n        \\n        if not bst_root: return None        # found no bst root\\n        if len(bst_root) > 1: return None   # found more than one bst roots\\n        \\n        def build(node):\\n            assert(node)\\n            # build left if valid\\n            if node.left and node.left.val in val2root:\\n                if rootIndex[node.left.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.left = val2root[node.left.val]\\n                deleted.add(rootIndex[node.left.val])\\n                build(node.left)\\n                \\n            # build right if valid\\n            if node.right and node.right.val in val2root:\\n                if rootIndex[node.right.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.right = val2root[node.right.val]     \\n                deleted.add(rootIndex[node.right.val])\\n                build(node.right)\\n        \\n        try:\\n            build(bst_root[0])\\n        except:\\n            return None\\n        \\n        def isValidBST(root: TreeNode, minVal = -math.inf, maxVal = math.inf) -> bool:\\n            return not root or minVal < root.val < maxVal and \\\\\\n                    isValidBST(root.left, minVal, root.val) and \\\\\\n                    isValidBST(root.right, root.val, maxVal)\\n    \\n        survivors = sum([1 for i in range(len(trees)) if i not in deleted])\\n        \\n        return bst_root[0] if survivors == 1 and isValidBST(bst_root[0]) else None\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n            \\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        val2root = defaultdict()    # to find root tree node from value\\n        rootIndex = defaultdict()   # to find index of a root in trees from value\\n        leaf2root = defaultdict()   # to find tree to replace the leaf with\\n        deleted = set()             # to track deleted tree indices\\n        \\n        # build the data structures\\n        for idx, tree in enumerate(trees):\\n            if tree.left:\\n                leaf2root[tree.left.val] = tree\\n            if tree.right:\\n                leaf2root[tree.right.val] = tree\\n            rootIndex[tree.val] = idx\\n            val2root[tree.val] = tree\\n        \\n        # find the root of the bst to build\\n\\n        bst_root = [tree for tree in trees if tree.val not in leaf2root]\\n        \\n        if not bst_root: return None        # found no bst root\\n        if len(bst_root) > 1: return None   # found more than one bst roots\\n        \\n        def build(node):\\n            assert(node)\\n            # build left if valid\\n            if node.left and node.left.val in val2root:\\n                if rootIndex[node.left.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.left = val2root[node.left.val]\\n                deleted.add(rootIndex[node.left.val])\\n                build(node.left)\\n                \\n            # build right if valid\\n            if node.right and node.right.val in val2root:\\n                if rootIndex[node.right.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.right = val2root[node.right.val]     \\n                deleted.add(rootIndex[node.right.val])\\n                build(node.right)\\n        \\n        try:\\n            build(bst_root[0])\\n        except:\\n            return None\\n        \\n        def isValidBST(root: TreeNode, minVal = -math.inf, maxVal = math.inf) -> bool:\\n            return not root or minVal < root.val < maxVal and \\\\\\n                    isValidBST(root.left, minVal, root.val) and \\\\\\n                    isValidBST(root.right, root.val, maxVal)\\n    \\n        survivors = sum([1 for i in range(len(trees)) if i not in deleted])\\n        \\n        return bst_root[0] if survivors == 1 and isValidBST(bst_root[0]) else None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1330363,
                "title": "c-using-map-with-explanation",
                "content": "### Intuition\\nFor true to be valid, following conditions must be true:\\n* tree must have only 1 root.\\n* tree must be BST.\\n* tree must include all the nodes.\\n\\n### Solution\\n- maintain a map with node values to node for all child nodes. This map will help up find parent, given any value.\\n- find root, root won\\'t have any parent.\\n- iterate though the trees and update parent of each tree.\\n- finally validate that root is a bst and contains all nodes.\\n\\n### Complexity\\n- Time:` O(|trees|)`\\n- Space: `O(|trees|)`\\n\\n### Code\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> child; // child node value to pointer map\\n        // add all child nodes to map\\n        for(auto &tree: trees) {\\n            if (tree->left) {\\n                child[tree->left->val] = tree->left;\\n            }\\n            if (tree->right) {\\n                child[tree->right->val] = tree->right;\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        // parent of tree node is child[tree.val]\\n        // update parent->left as tree->left && parent->right as tree->right\\n        for(auto &tree: trees) {\\n            if (!child.count(tree->val)) { // root node won\\'t be a child\\n                if (root != NULL) { // there can\\'t be 2 root nodes\\n                    return NULL;\\n                }\\n                root = tree;\\n                continue;\\n            }\\n            child[tree->val]->left = tree->left;\\n            child[tree->val]->right = tree->right;\\n        }\\n        if (isValidBST(root, child)) {\\n            return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    // regular BST validation + check if all nodes are visited\\n    // child.size() should contain all nodes except root node\\n    // total visited nodes must equal child.size()+1\\n    bool isValidBST(TreeNode* root, unordered_map<int, TreeNode*>& child) {\\n        int visited = 0;\\n        stack<TreeNode*> s;\\n        long long curMin = INT_MIN;\\n        curMin--;\\n        while(root!=NULL || !s.empty()) {\\n            while(root!=NULL) {\\n                visited++;\\n                s.push(root);\\n                root = root->left;\\n            }\\n            if (curMin >= s.top()->val) {\\n                return false;\\n            }\\n            curMin = s.top()->val;\\n            root = s.top()->right;\\n            s.pop();\\n        }\\n        return visited == child.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> child; // child node value to pointer map\\n        // add all child nodes to map\\n        for(auto &tree: trees) {\\n            if (tree->left) {\\n                child[tree->left->val] = tree->left;\\n            }\\n            if (tree->right) {\\n                child[tree->right->val] = tree->right;\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        // parent of tree node is child[tree.val]\\n        // update parent->left as tree->left && parent->right as tree->right\\n        for(auto &tree: trees) {\\n            if (!child.count(tree->val)) { // root node won\\'t be a child\\n                if (root != NULL) { // there can\\'t be 2 root nodes\\n                    return NULL;\\n                }\\n                root = tree;\\n                continue;\\n            }\\n            child[tree->val]->left = tree->left;\\n            child[tree->val]->right = tree->right;\\n        }\\n        if (isValidBST(root, child)) {\\n            return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    // regular BST validation + check if all nodes are visited\\n    // child.size() should contain all nodes except root node\\n    // total visited nodes must equal child.size()+1\\n    bool isValidBST(TreeNode* root, unordered_map<int, TreeNode*>& child) {\\n        int visited = 0;\\n        stack<TreeNode*> s;\\n        long long curMin = INT_MIN;\\n        curMin--;\\n        while(root!=NULL || !s.empty()) {\\n            while(root!=NULL) {\\n                visited++;\\n                s.push(root);\\n                root = root->left;\\n            }\\n            if (curMin >= s.top()->val) {\\n                return false;\\n            }\\n            curMin = s.top()->val;\\n            root = s.top()->right;\\n            s.pop();\\n        }\\n        return visited == child.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1716619,
                "content": [
                    {
                        "username": "saransh24",
                        "content": " `class Solution {\\nprivate:\\n    void convertInDll(TreeNode* root,TreeNode* &head){\\n        if(!root) return;\\n\\n        convertInDll(root->right,head);\\n        root->right = head;\\n        if(head) head->left = root;\\n        head = root;\\n        convertInDll(root->left,head);\\n    }\\n\\n    TreeNode* mergeDll(TreeNode* l1,TreeNode* l2){\\n        TreeNode* head=NULL;\\n        TreeNode* tail=NULL;\\n\\n        while(l1 && l2){\\n            if(l1->val < l2->val){\\n                if(!head){\\n                    head=l1;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n                else{\\n                    tail->right=l1;\\n                    l1->left=tail;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n            }\\n            else{\\n                if(!head){\\n                    head=l2;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n                else{\\n                    tail->right=l2;\\n                    l2->left=tail;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n            }\\n        }\\n\\n        while(l1){\\n            if(!head){\\n                head=l1;\\n                tail=l1;\\n                l1=l1->right;\\n            }\\n            else{\\n                tail->right=l1;\\n                l1->left=tail;\\n                tail=l1;\\n                l1=l1->right;    \\n            }\\n            \\n        }\\n        while(l2){\\n            if(!head){\\n                head=l2;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n            else{\\n                tail->right=l2;\\n                l2->left=tail;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n        }\\n\\n        return head;\\n    }\\n\\n    int count(TreeNode* head){\\n        int n=0;\\n        TreeNode* temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->right;\\n        }\\n        return n;\\n    }\\n\\n    TreeNode* convertDllToBST(TreeNode* &head,int n){\\n        if(n<=0 || !head) return NULL;\\n\\n        TreeNode* left = convertDllToBST(head,n/2);\\n\\n        TreeNode* root = head;\\n        root->left=left;\\n        head=head->right;\\n\\n        root->right = convertDllToBST(head,n-(n/2)-1);\\n\\n        return root;\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode* l1=NULL;\\n        int i=0;\\n        // while(i<trees.size() && trees[i]==NULL) i++;\\n        // if(i==trees.size()) return NULL;\\n        while(i<trees.size()){\\n            TreeNode* root = trees[i++];\\n            TreeNode* head=NULL;\\n            convertInDll(root,head);\\n            head->left=NULL;\\n            l1 = mergeDll(l1,head);\\n        }\\n        return convertDllToBST(l1,count(l1));\\n    }\\n};`\\n\\nPlease tell what is wrong in this code"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "If u got this question in a interview, they don\\'t want to hire u."
                    },
                    {
                        "username": "SprihaAnand",
                        "content": "why is the testcase \\n[[6,4],[7,6],[5,null,7]] returning emty array?"
                    }
                ]
            },
            {
                "id": 2003145,
                "content": [
                    {
                        "username": "saransh24",
                        "content": " `class Solution {\\nprivate:\\n    void convertInDll(TreeNode* root,TreeNode* &head){\\n        if(!root) return;\\n\\n        convertInDll(root->right,head);\\n        root->right = head;\\n        if(head) head->left = root;\\n        head = root;\\n        convertInDll(root->left,head);\\n    }\\n\\n    TreeNode* mergeDll(TreeNode* l1,TreeNode* l2){\\n        TreeNode* head=NULL;\\n        TreeNode* tail=NULL;\\n\\n        while(l1 && l2){\\n            if(l1->val < l2->val){\\n                if(!head){\\n                    head=l1;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n                else{\\n                    tail->right=l1;\\n                    l1->left=tail;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n            }\\n            else{\\n                if(!head){\\n                    head=l2;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n                else{\\n                    tail->right=l2;\\n                    l2->left=tail;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n            }\\n        }\\n\\n        while(l1){\\n            if(!head){\\n                head=l1;\\n                tail=l1;\\n                l1=l1->right;\\n            }\\n            else{\\n                tail->right=l1;\\n                l1->left=tail;\\n                tail=l1;\\n                l1=l1->right;    \\n            }\\n            \\n        }\\n        while(l2){\\n            if(!head){\\n                head=l2;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n            else{\\n                tail->right=l2;\\n                l2->left=tail;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n        }\\n\\n        return head;\\n    }\\n\\n    int count(TreeNode* head){\\n        int n=0;\\n        TreeNode* temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->right;\\n        }\\n        return n;\\n    }\\n\\n    TreeNode* convertDllToBST(TreeNode* &head,int n){\\n        if(n<=0 || !head) return NULL;\\n\\n        TreeNode* left = convertDllToBST(head,n/2);\\n\\n        TreeNode* root = head;\\n        root->left=left;\\n        head=head->right;\\n\\n        root->right = convertDllToBST(head,n-(n/2)-1);\\n\\n        return root;\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode* l1=NULL;\\n        int i=0;\\n        // while(i<trees.size() && trees[i]==NULL) i++;\\n        // if(i==trees.size()) return NULL;\\n        while(i<trees.size()){\\n            TreeNode* root = trees[i++];\\n            TreeNode* head=NULL;\\n            convertInDll(root,head);\\n            head->left=NULL;\\n            l1 = mergeDll(l1,head);\\n        }\\n        return convertDllToBST(l1,count(l1));\\n    }\\n};`\\n\\nPlease tell what is wrong in this code"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "If u got this question in a interview, they don\\'t want to hire u."
                    },
                    {
                        "username": "SprihaAnand",
                        "content": "why is the testcase \\n[[6,4],[7,6],[5,null,7]] returning emty array?"
                    }
                ]
            },
            {
                "id": 2000607,
                "content": [
                    {
                        "username": "saransh24",
                        "content": " `class Solution {\\nprivate:\\n    void convertInDll(TreeNode* root,TreeNode* &head){\\n        if(!root) return;\\n\\n        convertInDll(root->right,head);\\n        root->right = head;\\n        if(head) head->left = root;\\n        head = root;\\n        convertInDll(root->left,head);\\n    }\\n\\n    TreeNode* mergeDll(TreeNode* l1,TreeNode* l2){\\n        TreeNode* head=NULL;\\n        TreeNode* tail=NULL;\\n\\n        while(l1 && l2){\\n            if(l1->val < l2->val){\\n                if(!head){\\n                    head=l1;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n                else{\\n                    tail->right=l1;\\n                    l1->left=tail;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n            }\\n            else{\\n                if(!head){\\n                    head=l2;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n                else{\\n                    tail->right=l2;\\n                    l2->left=tail;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n            }\\n        }\\n\\n        while(l1){\\n            if(!head){\\n                head=l1;\\n                tail=l1;\\n                l1=l1->right;\\n            }\\n            else{\\n                tail->right=l1;\\n                l1->left=tail;\\n                tail=l1;\\n                l1=l1->right;    \\n            }\\n            \\n        }\\n        while(l2){\\n            if(!head){\\n                head=l2;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n            else{\\n                tail->right=l2;\\n                l2->left=tail;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n        }\\n\\n        return head;\\n    }\\n\\n    int count(TreeNode* head){\\n        int n=0;\\n        TreeNode* temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->right;\\n        }\\n        return n;\\n    }\\n\\n    TreeNode* convertDllToBST(TreeNode* &head,int n){\\n        if(n<=0 || !head) return NULL;\\n\\n        TreeNode* left = convertDllToBST(head,n/2);\\n\\n        TreeNode* root = head;\\n        root->left=left;\\n        head=head->right;\\n\\n        root->right = convertDllToBST(head,n-(n/2)-1);\\n\\n        return root;\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode* l1=NULL;\\n        int i=0;\\n        // while(i<trees.size() && trees[i]==NULL) i++;\\n        // if(i==trees.size()) return NULL;\\n        while(i<trees.size()){\\n            TreeNode* root = trees[i++];\\n            TreeNode* head=NULL;\\n            convertInDll(root,head);\\n            head->left=NULL;\\n            l1 = mergeDll(l1,head);\\n        }\\n        return convertDllToBST(l1,count(l1));\\n    }\\n};`\\n\\nPlease tell what is wrong in this code"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "If u got this question in a interview, they don\\'t want to hire u."
                    },
                    {
                        "username": "SprihaAnand",
                        "content": "why is the testcase \\n[[6,4],[7,6],[5,null,7]] returning emty array?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if String Is Decomposable Into Value-Equal Substrings",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Confirmation Rate",
        "question_content": "<p>Table: <code>Signups</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\nuser_id is the column of unique values for this table.\nEach row contains information about the signup time for the user with ID user_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Confirmations</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n| action         | ENUM     |\n+----------------+----------+\n(user_id, time_stamp) is the primary key (combination of columns with unique values) for this table.\nuser_id is a foreign key (reference column) to the Signups table.\naction is an ENUM (category) of the type (&#39;confirmed&#39;, &#39;timeout&#39;)\nEach row of this table indicates that the user with ID user_id requested a confirmation message at time_stamp and that confirmation message was either confirmed (&#39;confirmed&#39;) or expired without confirming (&#39;timeout&#39;).\n</pre>\n\n<p>&nbsp;</p>\n\n<p>The <strong>confirmation rate</strong> of a user is the number of <code>&#39;confirmed&#39;</code> messages divided by the total number of requested confirmation messages. The confirmation rate of a user that did not request any confirmation messages is <code>0</code>. Round the confirmation rate to <strong>two decimal</strong> places.</p>\n\n<p>Write a solution to find the <strong>confirmation rate</strong> of each user.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nSignups table:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 3       | 2020-03-21 10:16:13 |\n| 7       | 2020-01-04 13:57:59 |\n| 2       | 2020-07-29 23:09:44 |\n| 6       | 2020-12-09 10:39:37 |\n+---------+---------------------+\nConfirmations table:\n+---------+---------------------+-----------+\n| user_id | time_stamp          | action    |\n+---------+---------------------+-----------+\n| 3       | 2021-01-06 03:30:46 | timeout   |\n| 3       | 2021-07-14 14:00:00 | timeout   |\n| 7       | 2021-06-12 11:57:29 | confirmed |\n| 7       | 2021-06-13 12:58:28 | confirmed |\n| 7       | 2021-06-14 13:59:27 | confirmed |\n| 2       | 2021-01-22 00:00:00 | confirmed |\n| 2       | 2021-02-28 23:59:59 | timeout   |\n+---------+---------------------+-----------+\n<strong>Output:</strong> \n+---------+-------------------+\n| user_id | confirmation_rate |\n+---------+-------------------+\n| 6       | 0.00              |\n| 3       | 0.00              |\n| 7       | 1.00              |\n| 2       | 0.50              |\n+---------+-------------------+\n<strong>Explanation:</strong> \nUser 6 did not request any confirmation messages. The confirmation rate is 0.\nUser 3 made 2 requests and both timed out. The confirmation rate is 0.\nUser 7 made 3 requests and all were confirmed. The confirmation rate is 1.\nUser 2 made 2 requests where one was confirmed and the other timed out. The confirmation rate is 1 / 2 = 0.5.\n</pre>\n",
        "solutions": [
            {
                "id": 3563481,
                "title": "92-beats-easy-code-with-explanation-must-read",
                "content": "\\n\\n# Approach\\n- left join `Signups` table with `Confirmations` table group by user_id.\\n- we have to display `user_id` and `confirmation_rate` :\\n1. user_id will be simply displayed.\\n2. to display confirmation_rate , we need to find average using aggregation function avg(), here using if clause we specified that if action is `confirmed` we count it as 1 and else if `null or timeout` we will count it as 0. \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n\\n```\\n# Request\\n**Please upvote if you find it helpful**\\n![meme.png](https://assets.leetcode.com/users/images/647f77b9-8a52-41d1-9fde-104782a9fc5b_1685122990.4751306.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3580090,
                "title": "attention-coders-step-by-step-explanation-with-optimum-approach-beats-96",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe problem asks us to calculate the confirmation rate for each user. The confirmation rate is determined by the number of confirmed actions divided by the total number of actions for each user.\\n# Approach\\n1. We start by selecting the user_id column from the Signups table and calculate the confirmation rate using the AVG function.\\n1. In the calculation of the confirmation rate, we use a conditional statement (IF) to check if the action in the Confirmations table is \\'confirmed\\'. If it is, we assign a value of 1; otherwise, we assign a value of 0.\\n1. We round the calculated average confirmation rate to two decimal places using the ROUND function.\\n1. To associate signups with their respective confirmations, we perform a left join between the Signups and Confirmations tables using the user_id column.\\n1. Finally, we group the results by user_id using the GROUP BY clause to get the confirmation rate for each individual user.\\n# Complexity\\n- Time complexity:\\nThe time complexity of your solution depends on the size of the tables involved and the indexes available. In this case, we need to scan through the tables and perform calculations for each user. Therefore, the time complexity can be considered $$O(N)$$, where N is the total number of rows in the tables.\\n\\n- Space complexity:\\nThe space complexity is determined by the number of distinct user_id values and the size of the result set. As the query processes the data, it needs memory to store the intermediate results during the join and aggregation. So, the space complexity can be considered $$O(M)$$, where M is the number of distinct user_id values.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT s.user_id, \\n  ROUND(AVG(IF(c.action=\\'confirmed\\',1,0)),2) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c using (user_id)\\nGROUP BY s.user_id\\n\\n```\\n\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/e9808694-53da-4edd-9db3-a64e3c4ec816_1685477644.632369.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT s.user_id, \\n  ROUND(AVG(IF(c.action=\\'confirmed\\',1,0)),2) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c using (user_id)\\nGROUP BY s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341952,
                "title": "avg-case-when-for-any-sql",
                "content": "```\\nSELECT \\n  s.user_id,\\n  ROUND(AVG(CASE WHEN action = \\'confirmed\\' THEN 1.00 ELSE 0.00 END),2) AS confirmation_rate\\nFROM Signups s LEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n  s.user_id,\\n  ROUND(AVG(CASE WHEN action = \\'confirmed\\' THEN 1.00 ELSE 0.00 END),2) AS confirmation_rate\\nFROM Signups s LEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863062,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT S.user_id, ROUND(AVG(CASE WHEN (C.action=\\'confirmed\\') THEN 1 \\n\\nELSE 0 END),2) AS confirmation_rate FROM Signups S LEFT OUTER JOIN \\n\\nConfirmations C ON S.user_id=C.user_id GROUP BY S.user_id\\n\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/769071e5-3113-490f-8742-b2a4d76e302d_1691214514.690642.jpeg)\\n\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT S.user_id, ROUND(AVG(CASE WHEN (C.action=\\'confirmed\\') THEN 1 \\n\\nELSE 0 END),2) AS confirmation_rate FROM Signups S LEFT OUTER JOIN \\n\\nConfirmations C ON S.user_id=C.user_id GROUP BY S.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3692519,
                "title": "sum-count-round",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse left join and conditional stmts\\n\\n\\n# Code\\n```\\nselect s.user_id,round(sum(if(c.action=\"confirmed\",1,0)) / count(*),2) \\nas confirmation_rate from Signups s \\nleft join Confirmations c on s.user_id=c.user_id \\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id,round(sum(if(c.action=\"confirmed\",1,0)) / count(*),2) \\nas confirmation_rate from Signups s \\nleft join Confirmations c on s.user_id=c.user_id \\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1599081,
                "title": "mysql-simple-sum-and-left-join",
                "content": "\\n```\\nselect\\n    s.user_id,\\n    ifnull(round(sum(action=\\'confirmed\\')/sum(action=\\'confirmed\\' or action=\\'timeout\\'), 2), 0) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    s.user_id,\\n    ifnull(round(sum(action=\\'confirmed\\')/sum(action=\\'confirmed\\' or action=\\'timeout\\'), 2), 0) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3558663,
                "title": "clean-implementation-using-left-join-group-by-cast-round",
                "content": "Honestly, this problem took a lot of my time searching the right commands and implementing them. Follow along to understand what I learned during implementation! \\n\\n# Code\\n``` MS_SQL []\\nSELECT              s.user_id,\\nROUND(CAST(COUNT(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE NULL END) AS FLOAT) / COUNT(*), 2) as confirmation_rate\\nFROM                Signups s\\nLEFT JOIN     Confirmations c\\nON                  s.user_id = c.user_id\\nGROUP BY            s.user_id\\n```\\n# Approach\\n\\n1. Since we need **all the values including NULL**, we have to use a `LEFT JOIN` with all values from Signups table.\\n2. For the purpose of finding `COUNT`, we have to group the id. Therefore, we use a `GROUP BY on s.user_id`.\\n3. To find the required **confirmation rate**, divide the rows with `action = \\'confirmed\\'` by all the rows for the grouped s.user_id.\\n4. To find the rows with a given value, we use \\n`COUNT(CASE WHEN <condition> THEN x ELSE y END)`\\n5. Do not use `ELSE 0`. COUNT returns the count of rows with a value and \\'0\\' is a value. So the output will be nothing but **COUNT(*)**. \\n6. The `output of INT / INT is INT`. Therefore, we have to cast/convert one of the value to a FLOAT/DECIMAL/NUMERIC. We do that using \\n`CAST(val as FLOAT)`\\n7. Finally, round the value to 2 decimal places using\\n`ROUND(val, 2)`\\n\\n##### I like checking out other approaches, drop in your approach for me and others to refer!",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "``` MS_SQL []\\nSELECT              s.user_id,\\nROUND(CAST(COUNT(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE NULL END) AS FLOAT) / COUNT(*), 2) as confirmation_rate\\nFROM                Signups s\\nLEFT JOIN     Confirmations c\\nON                  s.user_id = c.user_id\\nGROUP BY            s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1408103,
                "title": "mysql-left-join",
                "content": "\\n```\\nSELECT \\n    user_id,\\n    ROUND(AVG(IF(action = \\'confirmed\\', 1, 0)), 2) AS confirmation_rate\\nFROM Signups LEFT JOIN Confirmations USING (user_id)\\nGROUP BY 1\\nORDER BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    user_id,\\n    ROUND(AVG(IF(action = \\'confirmed\\', 1, 0)), 2) AS confirmation_rate\\nFROM Signups LEFT JOIN Confirmations USING (user_id)\\nGROUP BY 1\\nORDER BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710142,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nselect s.user_id ,CASE WHEN c.time_stamp is NULL  then 0.00\\nelse ROUND(sum(c.action=\\'confirmed\\')/COUNT(*),2)\\nEND AS confirmation_rate \\nfrom Signups s\\nleft join Confirmations  c\\non s.user_id =c.user_id \\ngroup by s.user_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id ,CASE WHEN c.time_stamp is NULL  then 0.00\\nelse ROUND(sum(c.action=\\'confirmed\\')/COUNT(*),2)\\nEND AS confirmation_rate \\nfrom Signups s\\nleft join Confirmations  c\\non s.user_id =c.user_id \\ngroup by s.user_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3534393,
                "title": "easy-ms-sql-server-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![image.png](https://assets.leetcode.com/users/images/85e59c3a-bbf9-4f97-a68b-8b4b8486c91f_1684323045.7926881.png)\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n  s.user_id,\\n  ROUND(SUM(CASE\\n    WHEN c.action = \\'confirmed\\' THEN 1\\n    WHEN s.time_stamp IS NULL THEN 0.00\\n    ELSE 0\\n  END) / COUNT(*), 2) AS confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\n  ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n  s.user_id,\\n  ROUND(SUM(CASE\\n    WHEN c.action = \\'confirmed\\' THEN 1\\n    WHEN s.time_stamp IS NULL THEN 0.00\\n    ELSE 0\\n  END) / COUNT(*), 2) AS confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\n  ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067334,
                "title": "beats-99-32-solutions",
                "content": "# Complexity\\n- Time complexity: 1096ms\\n- Space complexity: 0.00MB\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n      ROUND((AVG(CASE\\n          WHEN action=\\'confirmed\\' THEN 1\\n          ELSE 0\\n          END)),2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id=c.user_id\\nGROUP BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n      ROUND((AVG(CASE\\n          WHEN action=\\'confirmed\\' THEN 1\\n          ELSE 0\\n          END)),2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id=c.user_id\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3802930,
                "title": "using-round-and-case-when",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id,\\nROUND(AVG(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END),2) \\nAS confirmation_rate from Confirmations\\nright join Signups using (user_id)  \\ngroup by user_id  \\n```\\n![1qivbn.jpg](https://assets.leetcode.com/users/images/a169dbd7-b34d-4a99-8359-a8a813239d9a_1689869293.2703924.jpeg)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id,\\nROUND(AVG(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END),2) \\nAS confirmation_rate from Confirmations\\nright join Signups using (user_id)  \\ngroup by user_id  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3634650,
                "title": "heh-simple-solution-using-agregate-functions",
                "content": "\\n```\\nselect s.user_id, round(avg(case when(c.action=\\'confirmed\\') then 1 else 0 end),2) as confirmation_rate from Signups s left join Confirmations c \\non s.user_id=c.user_id group by s.user_id\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect s.user_id, round(avg(case when(c.action=\\'confirmed\\') then 1 else 0 end),2) as confirmation_rate from Signups s left join Confirmations c \\non s.user_id=c.user_id group by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028966,
                "title": "mysql-easy-solution-left-join-case-when",
                "content": "\\n# Approach\\n\\nAs we are interested in confirmation rate of all the users\\nfrom the signups table , we should prefer using left join here to include every single user_id at the end group by user_id \\'s for individual result\\n\\n-- for calculating confirmation - \\n\\nformula is = total confimed / total request\\n\\n(where total request = total confirmed + total timeout)\\n\\neach grouped by user_id \\'s\\n\\nif you find this Helpful , Please Upvote !!\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect s.user_id ,\\n\\nRound(\\n \\n  sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*)\\n  ,2\\n) as confirmation_rate\\n\\nfrom signups s left join\\nconfirmations c on s.user_id = c.user_id\\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect s.user_id ,\\n\\nRound(\\n \\n  sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*)\\n  ,2\\n) as confirmation_rate\\n\\nfrom signups s left join\\nconfirmations c on s.user_id = c.user_id\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817972,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\n\\nselect\\ns.user_id,\\nround(sum(case when action = \\'confirmed\\' then 1 else 0 end) / count(1) , 2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id group by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\n\\nselect\\ns.user_id,\\nround(sum(case when action = \\'confirmed\\' then 1 else 0 end) / count(1) , 2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id group by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3723160,
                "title": "easy-code-my-solution",
                "content": "\\n# Code\\n```\\nselect s.user_id, CASE WHEN c.time_stamp is null\\nthen 0.00\\nelse round(sum(c.action=\\'confirmed\\')/count(*),2)\\nend as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id, CASE WHEN c.time_stamp is null\\nthen 0.00\\nelse round(sum(c.action=\\'confirmed\\')/count(*),2)\\nend as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608649,
                "title": "mysql-solution-for-confirmation-rate-problem",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThe solution uses a JOIN operation to combine the Signups and Confirmations tables based on the user_id column. It then calculates the confirmation rate for each user by dividing the count of confirmed requests by the total count of requests. The solution handles cases where a user has not made any confirmation requests by considering a total count of 1 and a confirmed count of 0.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. The main query selects the user_id column from the Signups table and performs a LEFT JOIN with a subquery.\\r\\n1. The subquery calculates the total count of confirmation requests (total_count) and the count of confirmed requests (confirmed_count) for each user in the Confirmations table using GROUP BY and the COUNT and SUM functions.\\r\\n1. The COALESCE function is used to handle NULL values in the counts and replace them with appropriate default values (1 for total count and 0 for confirmed count).\\r\\n1. The confirmation rate is then calculated by dividing the confirmed count by the total count, and the result is rounded to two decimal places using the ROUND function.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nThe time complexity of the solution depends on the size of the Signups and Confirmations tables. Let\\'s assume n is the number of rows in the Signups table and m is the number of rows in the Confirmations table. The subquery in the JOIN operation has a complexity of O(m), and the JOIN operation itself has a complexity of O(n + m). Overall, the time complexity of the solution can be considered as O(n + m).\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nThe space complexity of the solution is determined by the size of the result set. Since the query returns the confirmation rate for each user, the space required to store the result will be proportional to the number of users. Therefore, the space complexity can be considered as O(n), where n is the number of users.\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\n# SELECT s.user_id, IFNULL(CONF.confirmation_rate, 0) AS confirmation_rate\\r\\n# FROM Signups AS s\\r\\n# LEFT JOIN (\\r\\n#     SELECT c.user_id, COUNT(c.action) AS total_requests,\\r\\n#            SUM(c.action = \\'confirmed\\') / COUNT(c.action) AS confirmation_rate\\r\\n#     FROM Confirmations AS c\\r\\n#     GROUP BY c.user_id\\r\\n# ) AS CONF ON s.user_id = CONF.user_id;\\r\\n\\r\\nSELECT\\r\\n    s.user_id,\\r\\n    ROUND(COALESCE(c.confirmed_count, 0) / COALESCE(c.total_count, 1), 2) AS confirmation_rate\\r\\nFROM\\r\\n    Signups s\\r\\nLEFT JOIN\\r\\n    (\\r\\n        SELECT\\r\\n            user_id,\\r\\n            COUNT(*) AS total_count,\\r\\n            SUM(action = \\'confirmed\\') AS confirmed_count\\r\\n        FROM\\r\\n            Confirmations\\r\\n        GROUP BY\\r\\n            user_id\\r\\n    ) c ON s.user_id = c.user_id;\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below\\r\\n# SELECT s.user_id, IFNULL(CONF.confirmation_rate, 0) AS confirmation_rate\\r\\n# FROM Signups AS s\\r\\n# LEFT JOIN (\\r\\n#     SELECT c.user_id, COUNT(c.action) AS total_requests,\\r\\n#            SUM(c.action = \\'confirmed\\') / COUNT(c.action) AS confirmation_rate\\r\\n#     FROM Confirmations AS c\\r\\n#     GROUP BY c.user_id\\r\\n# ) AS CONF ON s.user_id = CONF.user_id;\\r\\n\\r\\nSELECT\\r\\n    s.user_id,\\r\\n    ROUND(COALESCE(c.confirmed_count, 0) / COALESCE(c.total_count, 1), 2) AS confirmation_rate\\r\\nFROM\\r\\n    Signups s\\r\\nLEFT JOIN\\r\\n    (\\r\\n        SELECT\\r\\n            user_id,\\r\\n            COUNT(*) AS total_count,\\r\\n            SUM(action = \\'confirmed\\') AS confirmed_count\\r\\n        FROM\\r\\n            Confirmations\\r\\n        GROUP BY\\r\\n            user_id\\r\\n    ) c ON s.user_id = c.user_id;\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587478,
                "title": "postgres-oracle-easy-solution-through-coalesce-statement-beats-35",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy solution that uses Coalesce and aggregate functions in postgres/oracle dbms. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach consists of two main parts - \\n\\n1.  Firsly we take out \"statuses\" - whether our user is confirmed or not. Because our `Confirmations` table does not contain all possible users, we are using auxiliary table - `Signups`. And then we simply need to perform `LEFT JOIN`.\\n2. Secondly we group our result by using aggregate function and `COALESCE`. This function is just a straightforward way of `CASE` - if we do not have the appropriate confirmation action (**NULL**) then this function will return 0.\\n\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT \\n  s.user_id, \\n  COALESCE(\\n    ROUND(AVG(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END), 2),\\n    0\\n  ) AS confirmation_rate\\nFROM \\n  Signups s \\n  LEFT OUTER JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n\\n```",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT \\n  s.user_id, \\n  COALESCE(\\n    ROUND(AVG(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END), 2),\\n    0\\n  ) AS confirmation_rate\\nFROM \\n  Signups s \\n  LEFT OUTER JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585274,
                "title": "same-query-for-3-db-using-left-join-and-switch-case",
                "content": "1. left join needed to list down each singups entry.\\n2. group by signup user_id so that we can process per user_id available in signups\\n3. use switch case to count confirmed event as 1, else 0.\\n\\n# Code\\n```\\nselect s.user_id,round(avg(case when c.action=\\'confirmed\\' then 1.00 else 0.00 end),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect s.user_id,round(avg(case when c.action=\\'confirmed\\' then 1.00 else 0.00 end),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575298,
                "title": "easy-to-understand-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id,\\nround(avg(case when action=\"confirmed\" then 1.00 else 0.00 end),2)\\nas confirmation_rate \\nfrom signups s left join confirmations c on s.user_id=c.user_id\\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id,\\nround(avg(case when action=\"confirmed\" then 1.00 else 0.00 end),2)\\nas confirmation_rate \\nfrom signups s left join confirmations c on s.user_id=c.user_id\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007488,
                "title": "using-left-join-case-window-function",
                "content": "\\n\\n\\n# Code\\n```\\nSELECT DISTINCT s.user_id\\n\\t,round(sum(CASE \\n\\t\\t\\t\\tWHEN c.action = \\'confirmed\\'\\n\\t\\t\\t\\t\\tTHEN 1\\n\\t\\t\\t\\tELSE 0\\n\\t\\t\\t\\tEND) OVER (PARTITION BY user_id) / count(*) OVER (PARTITION BY user_id), 2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT s.user_id\\n\\t,round(sum(CASE \\n\\t\\t\\t\\tWHEN c.action = \\'confirmed\\'\\n\\t\\t\\t\\t\\tTHEN 1\\n\\t\\t\\t\\tELSE 0\\n\\t\\t\\t\\tEND) OVER (PARTITION BY user_id) / count(*) OVER (PARTITION BY user_id), 2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981207,
                "title": "easy-to-understand-solution-with-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Perform a LEFT JOIN between the Signups table and the Confirmations table using user_id as the matching column.\\n2. Calculate the total number of \\'confirmed\\' messages for each user and the total number of requested confirmation messages for each user using SUM and COUNT functions respectively.\\n3. Use the IFNULL function to handle cases where a user did not request any confirmation messages (set confirmation rate to 0.00).\\n4. Use the ROUND function to round the confirmation rate to two decimal places.\\n5. Group the results by user_id.\\n\\n\\n# Complexity\\n- Time complexity: **O(N + M)**, where** N** is the number of rows in the Signups table and **M** is the number of rows in the Confirmations table.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**, where **N** is the number of rows in the Signups table\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT s.user_id,\\n       IFNULL(\\n           ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(c.user_id), 2),\\n           0.00\\n       ) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.user_id,\\n       IFNULL(\\n           ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(c.user_id), 2),\\n           0.00\\n       ) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847760,
                "title": "beats-89-76-of-users-with-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect S.user_id\\n, round(\\n    avg(case when action = \\'confirmed\\' then 1 else 0 end),\\n    2) as confirmation_rate\\nfrom Signups S left join Confirmations C on \\nS.user_id=C.user_id\\ngroup by S.user_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect S.user_id\\n, round(\\n    avg(case when action = \\'confirmed\\' then 1 else 0 end),\\n    2) as confirmation_rate\\nfrom Signups S left join Confirmations C on \\nS.user_id=C.user_id\\ngroup by S.user_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600882,
                "title": "simple-sql-solution-sss",
                "content": "# Code\\n```\\nSelect \\n    s.user_id, \\n    round(avg(case when c.action = \\'confirmed\\' then 1.00 else 0.00 end), 2) as confirmation_rate\\nfrom signups s left\\njoin confirmations c \\n#on s.user_id = c.user_id\\nusing (user_id)\\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect \\n    s.user_id, \\n    round(avg(case when c.action = \\'confirmed\\' then 1.00 else 0.00 end), 2) as confirmation_rate\\nfrom signups s left\\njoin confirmations c \\n#on s.user_id = c.user_id\\nusing (user_id)\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3574094,
                "title": "easy-join-and-sub-query-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect s.user_id,case \\nwhen c.confirmation_rate is null then 0 else c.confirmation_rate \\nend as confirmation_rate\\nfrom signups s left join ( \\nselect user_id, round(avg(rate),2) confirmation_rate from\\n(select *, case\\nwhen action=\"timeout\" then 0 else 1 \\nend as rate\\nfrom confirmations)a\\ngroup by user_id)c on s.user_id=c.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect s.user_id,case \\nwhen c.confirmation_rate is null then 0 else c.confirmation_rate \\nend as confirmation_rate\\nfrom signups s left join ( \\nselect user_id, round(avg(rate),2) confirmation_rate from\\n(select *, case\\nwhen action=\"timeout\" then 0 else 1 \\nend as rate\\nfrom confirmations)a\\ngroup by user_id)c on s.user_id=c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564592,
                "title": "sql-round-coalesce-sum-count-left-join-easy-solution",
                "content": "# Intuition\\nFirst, we connected the Signups table with the Confirmations table using a left join. The main work is to prepare the confirmation_rate column. After grouping user_ids, the number of those whose action is \"confirmed\" is divided by the total number of actions. then we coalesce the partition so that it doesn\\'t return null. we round the division so that it returns with 2 digits of precision after the point\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/8f01bd92-266b-4d07-852b-bdb8978c67b5_1685095384.4712029.png)\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\ns.user_id,\\nround(coalesce(sum(case when action = \\'confirmed\\' then 1 end) / count(action) ,0),2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id\\ngroup by s.user_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\ns.user_id,\\nround(coalesce(sum(case when action = \\'confirmed\\' then 1 end) / count(action) ,0),2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id\\ngroup by s.user_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3547166,
                "title": "mysql-easy-and-clean-sum-join",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect\\ns.user_id,\\nround(sum(case when action = \\'confirmed\\' then 1 else 0 end) / count(1) , 2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id\\ngroup by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect\\ns.user_id,\\nround(sum(case when action = \\'confirmed\\' then 1 else 0 end) / count(1) , 2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id\\ngroup by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519921,
                "title": "easy-to-understand-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\n\\nselect \\n    a.user_id, \\n\\n    case when b.user_id is null then 0\\n    else \\n    round(sum(case when action = \\'confirmed\\' then 1 else 0 end) / cast(count(b.user_id) as float),2 )\\n    end as confirmation_rate\\n\\n\\nfrom signups a\\nleft join confirmations b\\non a.user_id = b.user_id\\n\\ngroup by a.user_id, b.user_id\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n\\nselect \\n    a.user_id, \\n\\n    case when b.user_id is null then 0\\n    else \\n    round(sum(case when action = \\'confirmed\\' then 1 else 0 end) / cast(count(b.user_id) as float),2 )\\n    end as confirmation_rate\\n\\n\\nfrom signups a\\nleft join confirmations b\\non a.user_id = b.user_id\\n\\ngroup by a.user_id, b.user_id\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438572,
                "title": "solution-with-simple-join-count-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nWITH CTE AS (\\r\\n      SELECT\\r\\n        user_id,\\r\\n        (COUNT(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE NULL END) / \\r\\n        CAST(COUNT(user_id) AS DECIMAL(10,2))) [confirmation_rate]\\r\\n      FROM\\r\\n        Confirmations\\r\\n      GROUP BY\\r\\n        user_id\\r\\n)\\r\\nSELECT\\r\\n  T2.user_id,\\r\\n  ROUND(ISNULL([confirmation_rate],0),2) [confirmation_rate]\\r\\nFROM\\r\\n  CTE T1\\r\\nRIGHT JOIN\\r\\n  Signups T2 ON T1.user_id = T2.user_id\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nWITH CTE AS (\\r\\n      SELECT\\r\\n        user_id,\\r\\n        (COUNT(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE NULL END) / \\r\\n        CAST(COUNT(user_id) AS DECIMAL(10,2))) [confirmation_rate]\\r\\n      FROM\\r\\n        Confirmations\\r\\n      GROUP BY\\r\\n        user_id\\r\\n)\\r\\nSELECT\\r\\n  T2.user_id,\\r\\n  ROUND(ISNULL([confirmation_rate],0),2) [confirmation_rate]\\r\\nFROM\\r\\n  CTE T1\\r\\nRIGHT JOIN\\r\\n  Signups T2 ON T1.user_id = T2.user_id\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431167,
                "title": "mysql-with-cte-sum-case-statement-left-join-group-by-good-luck",
                "content": "```\\n# Write your MySQL query statement below\\n/**\\nTwo Tables: Signups/Confirmations\\n\\nuser_id is the primary key for Signups table.\\nSignups table contains information about the signup time for the user with ID user_id.\\n\\n(user_id, time_stamp) is the primary key for Confirmations table.\\nConfirmations table indicates that the user with ID user_id requested a confirmation message at time_stamp and that confirmation message was either confirmed (\\'confirmed\\') or expired without confirming (\\'timeout\\').\\n\\nPROBLEM: \\n    find the confirmation rate of each user\\n    confirmation rate of a user is the number of \\'confirmed\\' messages divided by the total number of requested confirmation messages.\\n    ROUND(,2)\\n    \\nSTEPS:\\n    WITH CTE find the number of userid who action is confirmed and total no\\n    SUM(CASE statement) & COUNT(no of actions)\\n    ROUND(,2)\\n    IFNULL(,0)\\n*/\\n\\nWITH CTE AS\\n(\\nSELECT \\n    user_id,\\n    SUM(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END) AS totalConfirmed,\\n    COUNT(action) AS totalAction\\nFROM Confirmations\\nGROUP BY user_id\\n)\\n\\nSELECT\\n    S.user_id,\\n    ROUND(IFNULL(SUM(totalConfirmed/totalAction),0),2) AS confirmation_rate\\nFROM Signups S\\nLEFT JOIN CTE C\\nON S.user_id = C.user_id\\nGROUP BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n/**\\nTwo Tables: Signups/Confirmations\\n\\nuser_id is the primary key for Signups table.\\nSignups table contains information about the signup time for the user with ID user_id.\\n\\n(user_id, time_stamp) is the primary key for Confirmations table.\\nConfirmations table indicates that the user with ID user_id requested a confirmation message at time_stamp and that confirmation message was either confirmed (\\'confirmed\\') or expired without confirming (\\'timeout\\').\\n\\nPROBLEM: \\n    find the confirmation rate of each user\\n    confirmation rate of a user is the number of \\'confirmed\\' messages divided by the total number of requested confirmation messages.\\n    ROUND(,2)\\n    \\nSTEPS:\\n    WITH CTE find the number of userid who action is confirmed and total no\\n    SUM(CASE statement) & COUNT(no of actions)\\n    ROUND(,2)\\n    IFNULL(,0)\\n*/\\n\\nWITH CTE AS\\n(\\nSELECT \\n    user_id,\\n    SUM(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END) AS totalConfirmed,\\n    COUNT(action) AS totalAction\\nFROM Confirmations\\nGROUP BY user_id\\n)\\n\\nSELECT\\n    S.user_id,\\n    ROUND(IFNULL(SUM(totalConfirmed/totalAction),0),2) AS confirmation_rate\\nFROM Signups S\\nLEFT JOIN CTE C\\nON S.user_id = C.user_id\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260389,
                "title": "mysql-solution-without-case-end",
                "content": "```\\nselect s.user_id, round(ifnull(sum(c.action = \\'confirmed\\') / count(c.action), 0), 2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id, round(ifnull(sum(c.action = \\'confirmed\\') / count(c.action), 0), 2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060181,
                "title": "must-know-mysql-avg-queries-for-interviews",
                "content": "These types of questions are pretty common in interviews, please do pay attention to the easy solutions like using AVG specially when the interviwer needs quick answers\\n\\n```\\nselect \\n    s.user_id,\\n    ifnull(round(avg(action = \\'confirmed\\'),2),0) as confirmation_rate\\nfrom Signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    s.user_id,\\n    ifnull(round(avg(action = \\'confirmed\\'),2),0) as confirmation_rate\\nfrom Signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1483341,
                "title": "simple-mysql-solution",
                "content": "```\\nselect s.user_id,round(avg(case when action=\\'confirmed\\' then 1 else 0 end),2)\\nas confirmation_rate from Signups s left join Confirmations c on s.user_id = c.user_id  group by s.user_id",
                "solutionTags": [],
                "code": "```\\nselect s.user_id,round(avg(case when action=\\'confirmed\\' then 1 else 0 end),2)\\nas confirmation_rate from Signups s left join Confirmations c on s.user_id = c.user_id  group by s.user_id",
                "codeTag": "Unknown"
            },
            {
                "id": 3981879,
                "title": "best-solutions-more-easy-to-understand",
                "content": "Here is my solution guys :)\\r\\n\\r\\n# Code\\r\\n```\\r\\nWITH cte AS (\\r\\n    SELECT a.user_id,\\r\\n           CASE WHEN b.action = \\'confirmed\\' THEN 1 ELSE 0 END AS confirmed_user,\\r\\n           CASE WHEN b.action = \\'timeout\\' THEN 1 ELSE 0 END AS timeout_user\\r\\n    FROM Signups a\\r\\n    LEFT JOIN Confirmations b ON a.user_id = b.user_id\\r\\n),\\r\\ncte2 AS (\\r\\n    SELECT user_id, \\r\\n           SUM(confirmed_user) AS total_confirmed,\\r\\n           SUM(timeout_user) AS total_timeout,\\r\\n           SUM(confirmed_user + timeout_user) AS total_request\\r\\n    FROM cte\\r\\n    GROUP BY user_id\\r\\n)\\r\\nSELECT user_id, \\r\\n       ROUND(SUM(IFNULL(total_confirmed / total_request, 0)), 2) AS CONFIRMATION_RATE\\r\\nFROM cte2\\r\\nGROUP BY user_id;\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\nWITH cte AS (\\r\\n    SELECT a.user_id,\\r\\n           CASE WHEN b.action = \\'confirmed\\' THEN 1 ELSE 0 END AS confirmed_user,\\r\\n           CASE WHEN b.action = \\'timeout\\' THEN 1 ELSE 0 END AS timeout_user\\r\\n    FROM Signups a\\r\\n    LEFT JOIN Confirmations b ON a.user_id = b.user_id\\r\\n),\\r\\ncte2 AS (\\r\\n    SELECT user_id, \\r\\n           SUM(confirmed_user) AS total_confirmed,\\r\\n           SUM(timeout_user) AS total_timeout,\\r\\n           SUM(confirmed_user + timeout_user) AS total_request\\r\\n    FROM cte\\r\\n    GROUP BY user_id\\r\\n)\\r\\nSELECT user_id, \\r\\n       ROUND(SUM(IFNULL(total_confirmed / total_request, 0)), 2) AS CONFIRMATION_RATE\\r\\nFROM cte2\\r\\nGROUP BY user_id;\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926112,
                "title": "beats-98-users",
                "content": "# Intuition\\n<!-- The best way was to visualize the entire data as 1 dataset after joining -->\\n\\n# Approach\\n<!-- once the data was readble, start making iff statement to match the requirement -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- I did it first with sum and count and case statement. Later used iif and avg to reduce time complexity  -->\\n\\n- Space complexity:\\n<!-- use the right functions to reduce the space and time complexity -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect s.user_id,round(avg(iif(c.action=\\'confirmed\\',cast(1 as float),0)),2) as confirmation_rate \\nfrom Signups s\\nleft join\\nConfirmations c\\non s.user_id=c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect s.user_id,round(avg(iif(c.action=\\'confirmed\\',cast(1 as float),0)),2) as confirmation_rate \\nfrom Signups s\\nleft join\\nConfirmations c\\non s.user_id=c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3615663,
                "title": "join-sub-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect su.user_id,confirmation_rate =\\nROUND((select count(*)from Confirmations sub \\n where su.user_id=sub.user_id and sub.action=\\'confirmed\\' )/(count(*)+0.0),2)\\nfrom Signups su left outer join Confirmations cu\\non su.user_id=cu.user_id\\ngroup by su.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect su.user_id,confirmation_rate =\\nROUND((select count(*)from Confirmations sub \\n where su.user_id=sub.user_id and sub.action=\\'confirmed\\' )/(count(*)+0.0),2)\\nfrom Signups su left outer join Confirmations cu\\non su.user_id=cu.user_id\\ngroup by su.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591566,
                "title": "easy-mysql-solution-with-explanation-best-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We need to find the number of times when the action=\\'confirmed\\' out of the total number of actions.\\n- For that, we take **average with an if condition such that the value is 1 if action=\\'confirmed\\' and 0 otherwise, and then round the answer upto 2 decimals**.\\n-  We then group the output by the user_id in the Signups table so that it includess all the users.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In the SELECT statement, we retrieve the user_id from Signups and the confirmation_rate from Conifrmations such that the **confirmation_rate is equal to the number of times when the action=\\'confirmed\\' out of the total number of actions.**\\n2. In the FROM statement, we take a **LEFT OUTER JOIN on user_id with Signups on the LEFT SIDE** so that every user who ever signed up is included in the output.\\n3. The **GROUP BY clause** groups the action according to the user_id of all the users who signed up.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT S.user_id, ROUND(AVG(if(C.action=\\'confirmed\\',1,0)),2) as confirmation_rate\\nFROM Signups as S LEFT OUTER JOIN Confirmations as C\\nON S.user_id = C.user_id\\nGROUP BY S.user_id;\\n```\\n# Note\\nPlease upvote if you find my solution helpful. If you have any doubts, suggestion or want to discuss any solution, comment it. If you wish to discuss other related topics, feel free to message me on LinkedIn, https://leetcode.com/prathams29/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT S.user_id, ROUND(AVG(if(C.action=\\'confirmed\\',1,0)),2) as confirmation_rate\\nFROM Signups as S LEFT OUTER JOIN Confirmations as C\\nON S.user_id = C.user_id\\nGROUP BY S.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495670,
                "title": "oracle-simple-solution-using-avg-case-when",
                "content": "\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT T1.USER_ID, \\nROUND(AVG(CASE WHEN T2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS T1\\nLEFT JOIN\\nCONFIRMATIONS T2\\nON T1.USER_ID = T2.USER_ID\\nGROUP BY T1.USER_ID;\\n\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT T1.USER_ID, \\nROUND(AVG(CASE WHEN T2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS T1\\nLEFT JOIN\\nCONFIRMATIONS T2\\nON T1.USER_ID = T2.USER_ID\\nGROUP BY T1.USER_ID;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3470141,
                "title": "with-case-and-average-method",
                "content": "# Intuition\\nJoin the both the tables(Signups and Confirmation) and find the total confirmation and signups\\n# Approach\\nAfter left joining both the tables use CASE to get the user_id with count of confirmations and then find the average to get the confirmation rate\\n\\n\\n# Code\\n```\\nselect s.user_id as user_id,\\n      ROUND(AVG(case WHEN action =\\'confirmed\\' THEN 1.00 ELSE 0.00 END),2) as confirmation_rate\\nfrom Signups s\\nLEFT JOIN Confirmations c ON\\ns.user_id = c.user_id\\ngroup by user_id\\n\\n```\\n\\n# Another Method\\nI am adding an another way of approch to get confirmation_rate using with and case expression\\n\\nHere finding a table with total confirmation count and total signups for each user and joining both the tables (Signups and Confirmation).\\n\\n# Code\\n```\\nWITH  confirmation_rate_table as \\n\\t(select s.user_id as user_id, count(action) as total_signups,\\n      SUM(case WHEN action =\\'confirmed\\' THEN 1.00 ELSE 0.00 END) as confirmation_count\\n  from Signups s\\n  LEFT JOIN Confirmations c ON\\n  s.user_id = c.user_id\\n  group by user_id)\\n\\n SELECT user_id, \\n  (case WHEN confirmation_count != 0 then (confirmation_count/total_signups) ELSE 0 END) as confirmation_rate\\nfrom  confirmation_rate_table\\n\\n```\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id as user_id,\\n      ROUND(AVG(case WHEN action =\\'confirmed\\' THEN 1.00 ELSE 0.00 END),2) as confirmation_rate\\nfrom Signups s\\nLEFT JOIN Confirmations c ON\\ns.user_id = c.user_id\\ngroup by user_id\\n\\n```\n```\\nWITH  confirmation_rate_table as \\n\\t(select s.user_id as user_id, count(action) as total_signups,\\n      SUM(case WHEN action =\\'confirmed\\' THEN 1.00 ELSE 0.00 END) as confirmation_count\\n  from Signups s\\n  LEFT JOIN Confirmations c ON\\n  s.user_id = c.user_id\\n  group by user_id)\\n\\n SELECT user_id, \\n  (case WHEN confirmation_count != 0 then (confirmation_count/total_signups) ELSE 0 END) as confirmation_rate\\nfrom  confirmation_rate_table\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788268,
                "title": "mysql-easy-to-understand-beats-95",
                "content": "```\\nselect \\n    s.user_id,\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end)/count(*),2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect \\n    s.user_id,\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end)/count(*),2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1749757,
                "title": "mysql-quick-and-simple-solution-with-left-join",
                "content": "```\\nselect\\n    s.user_id,\\n    round( sum(case when action=\"confirmed\" then 1 else 0 end) / count(1), 2) confirmation_rate\\nfrom Signups s\\nleft join Confirmations c on s.user_id = c.user_id\\ngroup by s.user_id;\\n```\\n\\nResults:\\n![image](https://assets.leetcode.com/users/images/4eed6f16-4612-4328-8ed0-b74c70090dd9_1644144960.9699397.png)\\n",
                "solutionTags": [],
                "code": "```\\nselect\\n    s.user_id,\\n    round( sum(case when action=\"confirmed\" then 1 else 0 end) / count(1), 2) confirmation_rate\\nfrom Signups s\\nleft join Confirmations c on s.user_id = c.user_id\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1698726,
                "title": "easy-mysql-solution-left-join-group-by",
                "content": "SELECT s.user_id,\\nROUND(IFNULL(SUM(CASE WHEN c.action = \"confirmed\" THEN 1 ELSE 0 END)/\\nCOUNT(c.time_stamp),0),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c\\nON s.user_id = c.user_id \\nGROUP BY s.user_id",
                "solutionTags": [],
                "code": "SELECT s.user_id,\\nROUND(IFNULL(SUM(CASE WHEN c.action = \"confirmed\" THEN 1 ELSE 0 END)/\\nCOUNT(c.time_stamp),0),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c\\nON s.user_id = c.user_id \\nGROUP BY s.user_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1698029,
                "title": "one-subquery",
                "content": "```\\nselect \\n    user_id,\\n    round(avg(case when action = \\'confirmed\\' then 1 else 0 end),2) as confirmation_rate\\n\\nfrom(select \\n    s.user_id,\\n    c.action\\nfrom Signups as s left join Confirmations as c on s.user_id = c.user_id    \\n    ) as temp\\n    \\ngroup by user_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    user_id,\\n    round(avg(case when action = \\'confirmed\\' then 1 else 0 end),2) as confirmation_rate\\n\\nfrom(select \\n    s.user_id,\\n    c.action\\nfrom Signups as s left join Confirmations as c on s.user_id = c.user_id    \\n    ) as temp\\n    \\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688529,
                "title": "solution",
                "content": "select s.user_id as user_id, ifnull(confirmation_rate,0) as confirmation_rate\\nfrom Signups s\\nleft join\\n(select user_id, round(sum(case action when \"confirmed\" then 1 else 0 end)/count(user_id),2) as confirmation_rate\\nfrom Confirmations\\ngroup by user_id) t\\non s.user_id = t.user_id",
                "solutionTags": [],
                "code": "select s.user_id as user_id, ifnull(confirmation_rate,0) as confirmation_rate\\nfrom Signups s\\nleft join\\n(select user_id, round(sum(case action when \"confirmed\" then 1 else 0 end)/count(user_id),2) as confirmation_rate\\nfrom Confirmations\\ngroup by user_id) t\\non s.user_id = t.user_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1667894,
                "title": "avg-action-confirmed-easy-sql",
                "content": "```\\n\\nselect\\nuser_id,\\nifnull(round(avg(action = \\'confirmed\\'),2),0.00) as confirmation_rate\\nfrom \\nSignups s \\nleft join Confirmations c\\nusing(user_id)\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nselect\\nuser_id,\\nifnull(round(avg(action = \\'confirmed\\'),2),0.00) as confirmation_rate\\nfrom \\nSignups s \\nleft join Confirmations c\\nusing(user_id)\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1594905,
                "title": "simple-join-and-case",
                "content": "```\\nSELECT\\n    s.user_id,\\n    CAST(SUM(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(*) AS DECIMAL(10,2)) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c  ON s.user_id = c.user_id\\nGROUP BY user_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    s.user_id,\\n    CAST(SUM(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(*) AS DECIMAL(10,2)) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c  ON s.user_id = c.user_id\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502070,
                "title": "should-time-stamp-in-signups-alway-be-earlier-than-that-in-confirmations",
                "content": "I had a where clause in my original answer\\n`WHERE sign.time_stamp<=comf.time_stamp OR comf.time_stamp is NULL`\\nbecause logically a user should sign up first then can be able to request confirmation. It failed in the test case below\\n```\\n{\"headers\": {\"Signups\": [\"user_id\", \"time_stamp\"],\\n             \"Confirmations\": [\"user_id\", \"time_stamp\", \"action\"]}, \\n    \"rows\": {\"Signups\": [[14, \"2020-02-26 17:32:52\"], [10, \"2021-07-28 03:12:22\"], \\n                        [5, \"2021-09-14 08:34:18\"], [6, \"2021-03-25 11:31:06\"], \\n                        [7, \"2021-01-31 08:00:29\"], [3, \"2020-12-02 18:04:14\"], \\n                        [8, \"2020-03-07 20:51:35\"]], \\n            \"Confirmations\": [[5, \"2021-10-11 13:40:45\", \"confirmed\"], \\n                        [5, \"2020-01-15 22:35:44\", \"timeout\"], \\n                        [10, \"2021-12-20 00:54:03\", \"confirmed\"], \\n                        [6, \"2020-05-13 14:14:30\", \"confirmed\"], \\n                        [8, \"2021-09-09 04:00:12\", \"confirmed\"], \\n                        [14, \"2021-07-20 17:53:59\", \"timeout\"], \\n                        [14, \"2021-12-19 11:44:53\", \"timeout\"]]\\n                }\\n    }\\n```\\n\\nWhat should be the confirmation rate for user #5, `1.00` or `0.50`? Can anyone help me understand the probelm statement?",
                "solutionTags": [],
                "code": "```\\n{\"headers\": {\"Signups\": [\"user_id\", \"time_stamp\"],\\n             \"Confirmations\": [\"user_id\", \"time_stamp\", \"action\"]}, \\n    \"rows\": {\"Signups\": [[14, \"2020-02-26 17:32:52\"], [10, \"2021-07-28 03:12:22\"], \\n                        [5, \"2021-09-14 08:34:18\"], [6, \"2021-03-25 11:31:06\"], \\n                        [7, \"2021-01-31 08:00:29\"], [3, \"2020-12-02 18:04:14\"], \\n                        [8, \"2020-03-07 20:51:35\"]], \\n            \"Confirmations\": [[5, \"2021-10-11 13:40:45\", \"confirmed\"], \\n                        [5, \"2020-01-15 22:35:44\", \"timeout\"], \\n                        [10, \"2021-12-20 00:54:03\", \"confirmed\"], \\n                        [6, \"2020-05-13 14:14:30\", \"confirmed\"], \\n                        [8, \"2021-09-09 04:00:12\", \"confirmed\"], \\n                        [14, \"2021-07-20 17:53:59\", \"timeout\"], \\n                        [14, \"2021-12-19 11:44:53\", \"timeout\"]]\\n                }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492555,
                "title": "mysql-solution",
                "content": "```\\nselect s.user_id, round(ifnull(sum(case when action is null then 0\\n                         when action = \\'confirmed\\' then 1\\n                         else 0 end)/count(action), 0),2) as confirmation_rate\\nfrom Signups s \\nleft join Confirmations c \\non s.user_id = c.user_id \\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id, round(ifnull(sum(case when action is null then 0\\n                         when action = \\'confirmed\\' then 1\\n                         else 0 end)/count(action), 0),2) as confirmation_rate\\nfrom Signups s \\nleft join Confirmations c \\non s.user_id = c.user_id \\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092492,
                "title": "simple-solution-to-relatively-tough-probelem",
                "content": "# Intuition\\nThink of calculating  an action score for each user \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nwith cte as (select Signups.user_id, action, \\ncase \\n     \\n    when action = \\'confirmed\\' then 1\\n    else 0\\n    end\\nas action_score \\nfrom Signups left outer join Confirmations on Signups.user_id=Confirmations.user_id)\\n\\nselect user_id, round(sum(action_score)/count(*),2) as confirmation_rate from cte group by user_id order by confirmation_rate\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nwith cte as (select Signups.user_id, action, \\ncase \\n     \\n    when action = \\'confirmed\\' then 1\\n    else 0\\n    end\\nas action_score \\nfrom Signups left outer join Confirmations on Signups.user_id=Confirmations.user_id)\\n\\nselect user_id, round(sum(action_score)/count(*),2) as confirmation_rate from cte group by user_id order by confirmation_rate\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092309,
                "title": "simple-pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    confirmations[\\'confirmation_rate\\'] = confirmations[\\'action\\'].apply(lambda x:1 if x == \\'confirmed\\' else 0)\\n    avg_conf = confirmations[[\\'user_id\\',\\'confirmation_rate\\']].groupby(\\'user_id\\')[\\'confirmation_rate\\'].mean().round(2).reset_index()\\n    output = pd.merge(signups[\\'user_id\\'],avg_conf,how=\\'left\\').fillna(0)  \\n    return output\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    confirmations[\\'confirmation_rate\\'] = confirmations[\\'action\\'].apply(lambda x:1 if x == \\'confirmed\\' else 0)\\n    avg_conf = confirmations[[\\'user_id\\',\\'confirmation_rate\\']].groupby(\\'user_id\\')[\\'confirmation_rate\\'].mean().round(2).reset_index()\\n    output = pd.merge(signups[\\'user_id\\'],avg_conf,how=\\'left\\').fillna(0)  \\n    return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4092246,
                "title": "solution-with-one-select-using-avg-and-case-when",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple solution using few select.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe use of case when is important to work with the AVG() function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* work with MySql, Oracle and SQL Server */\\nSELECT S.user_id,\\n        ROUND(AVG(CASE WHEN C.action = \\'confirmed\\' THEN 1.0 ELSE 0.0 END),2) as confirmation_rate \\nFROM Signups S\\n        LEFT JOIN Confirmations C ON S.user_id = C.user_id\\nGROUP BY S.user_id \\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n/* work with MySql, Oracle and SQL Server */\\nSELECT S.user_id,\\n        ROUND(AVG(CASE WHEN C.action = \\'confirmed\\' THEN 1.0 ELSE 0.0 END),2) as confirmation_rate \\nFROM Signups S\\n        LEFT JOIN Confirmations C ON S.user_id = C.user_id\\nGROUP BY S.user_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091739,
                "title": "beats-98-of-the-users",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT s.user_id, IFNULL (ROUND(SUM(IF(c.action = \"confirmed\",1,0))/COUNT(c.action),2),0) confirmation_rate\\n\\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY 1",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT s.user_id, IFNULL (ROUND(SUM(IF(c.action = \"confirmed\",1,0))/COUNT(c.action),2),0) confirmation_rate\\n\\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY 1",
                "codeTag": "Unknown"
            },
            {
                "id": 4090700,
                "title": "easy-solution-using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect user_id , round(sum(case when action = \"confirmed\" then 1 else 0 end)/count(*),2) as confirmation_rate from \\n\\n        (select s.user_id , c.action from Signups s left join Confirmations c on s.user_id = c.user_id) as sd group by user_id;\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect user_id , round(sum(case when action = \"confirmed\" then 1 else 0 end)/count(*),2) as confirmation_rate from \\n\\n        (select s.user_id , c.action from Signups s left join Confirmations c on s.user_id = c.user_id) as sd group by user_id;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090673,
                "title": "using-left-join-case-when",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id,\\nround(count(case when action = \\'confirmed\\' then 1 end)/\\ncount(s.user_id),2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non c.user_id = s.user_id\\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id,\\nround(count(case when action = \\'confirmed\\' then 1 end)/\\ncount(s.user_id),2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non c.user_id = s.user_id\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090165,
                "title": "oracle-pandas-95-faster-beats-clean-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Oracle Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nselect s.user_id ,round(avg(case when c.action=\\'confirmed\\' then 1 else 0 end),2) confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```\\n\\n# Pandas Code\\n```\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    confirmations = confirmations.groupby(\\'user_id\\').agg(\\n        confirmation_rate = (\\'action\\',lambda x:round(mean([i==\\'confirmed\\' for i in x]),2))\\n    ).reset_index()\\n    return signups.merge(confirmations,\\'left\\',\\'user_id\\').fillna(0)[[\\'user_id\\',\\'confirmation_rate\\']]\\n```\\n\\n",
                "solutionTags": [
                    "Oracle",
                    "Pandas"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nselect s.user_id ,round(avg(case when c.action=\\'confirmed\\' then 1 else 0 end),2) confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```\n```\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    confirmations = confirmations.groupby(\\'user_id\\').agg(\\n        confirmation_rate = (\\'action\\',lambda x:round(mean([i==\\'confirmed\\' for i in x]),2))\\n    ).reset_index()\\n    return signups.merge(confirmations,\\'left\\',\\'user_id\\').fillna(0)[[\\'user_id\\',\\'confirmation_rate\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4089717,
                "title": "straight-forward-solution-beats-100",
                "content": "\\n```\\nselect\\n    a.user_id, case when b.confirmed_count/a.total_count is null then 0 else round(1.0*b.confirmed_count/a.total_count, 2) end as confirmation_rate\\nfrom (\\n    select\\n        s.user_id, count(c.action) total_count\\n    from signups s\\n    left join confirmations c\\n    on s.user_id = c.user_id\\n    group by  s.user_id\\n) a\\nleft join\\n(\\n    select\\n        s.user_id, c.action, count(*) confirmed_count\\n    from signups s\\n    left join confirmations c\\n    on s.user_id = c.user_id\\n    group by  s.user_id, c.action\\n    having c.action = \\'confirmed\\'\\n) b\\non a.user_id = b.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect\\n    a.user_id, case when b.confirmed_count/a.total_count is null then 0 else round(1.0*b.confirmed_count/a.total_count, 2) end as confirmation_rate\\nfrom (\\n    select\\n        s.user_id, count(c.action) total_count\\n    from signups s\\n    left join confirmations c\\n    on s.user_id = c.user_id\\n    group by  s.user_id\\n) a\\nleft join\\n(\\n    select\\n        s.user_id, c.action, count(*) confirmed_count\\n    from signups s\\n    left join confirmations c\\n    on s.user_id = c.user_id\\n    group by  s.user_id, c.action\\n    having c.action = \\'confirmed\\'\\n) b\\non a.user_id = b.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088604,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id\\n    , ROUND(AVG(IF(c.action = \"confirmed\", 1, 0)), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id\\n    , ROUND(AVG(IF(c.action = \"confirmed\", 1, 0)), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088105,
                "title": "complex-solution-took-me-1-hour-to-solve-upvote-please",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect s.user_id,round(nvl(rpj.con,0)/NVL(NULLIF(nvl(rpj.con,0)+nvl(rpj.tim,0),0), 1),2) confirmation_rate\\nfrom (select r.user_id,r.con,rp.tim from (select user_id,count(*) con from (select * from confirmations where action=\\'confirmed\\') p group by user_id) r\\nfull outer join\\n(select user_id,count(*) tim from (select * from confirmations where action=\\'timeout\\') p group by user_id) rp on r.user_id=rp.user_id) rpj\\nright join\\nsignups s on s.user_id=rpj.user_id\\n;\\n\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect s.user_id,round(nvl(rpj.con,0)/NVL(NULLIF(nvl(rpj.con,0)+nvl(rpj.tim,0),0), 1),2) confirmation_rate\\nfrom (select r.user_id,r.con,rp.tim from (select user_id,count(*) con from (select * from confirmations where action=\\'confirmed\\') p group by user_id) r\\nfull outer join\\n(select user_id,count(*) tim from (select * from confirmations where action=\\'timeout\\') p group by user_id) rp on r.user_id=rp.user_id) rpj\\nright join\\nsignups s on s.user_id=rpj.user_id\\n;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086710,
                "title": "easy-beast-86",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nleft joins\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(coalesce(C.confirmed/(coalesce(T.timeouts, 0) + C.confirmed),0),2) as confirmation_rate\\nfrom Signups s\\nleft join (select \\nuser_id, count(action) as timeouts \\nfrom Confirmations where action = \\'timeout\\'\\nGroup by user_id\\n) as T on s.user_id = T.user_id\\nleft join (Select \\nuser_id, count(action) as confirmed\\nfrom Confirmations where action = \\'confirmed\\'\\nGroup by user_id\\n) as C on C.user_id = s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(coalesce(C.confirmed/(coalesce(T.timeouts, 0) + C.confirmed),0),2) as confirmation_rate\\nfrom Signups s\\nleft join (select \\nuser_id, count(action) as timeouts \\nfrom Confirmations where action = \\'timeout\\'\\nGroup by user_id\\n) as T on s.user_id = T.user_id\\nleft join (Select \\nuser_id, count(action) as confirmed\\nfrom Confirmations where action = \\'confirmed\\'\\nGroup by user_id\\n) as C on C.user_id = s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086154,
                "title": "beats-97-92-solutions",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf you dont have function \"If\" in your dbms.\\n# Complexity\\n- Time complexity: 1121ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, \\nround(coalesce(sum(case when action=\\'confirmed\\' then 1 else 0 end)/sum(case when action is not null then 1 else null end),0), 2) as confirmation_rate \\nfrom Signups s \\nleft join Confirmations c on s.user_id=c.user_id\\ngroup by s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, \\nround(coalesce(sum(case when action=\\'confirmed\\' then 1 else 0 end)/sum(case when action is not null then 1 else null end),0), 2) as confirmation_rate \\nfrom Signups s \\nleft join Confirmations c on s.user_id=c.user_id\\ngroup by s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086138,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085962,
                "title": "pandas-solution-straightforward-but-only-45",
                "content": "# Intuition\\nSQL mindset. Join first, assign values to generated confirmation_rate column. then calculate the average and round.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n  df = pd.merge(signups, confirmations, how = \\'left\\', on = \\'user_id\\')\\n  df.loc[df[\\'action\\'] == \\'confirmed\\', \\'confirmation_rate\\'] = 1\\n  df.loc[df[\\'action\\'] != \\'confirmed\\', \\'confirmation_rate\\'] = 0\\n  grouped = df[[\\'user_id\\', \\'confirmation_rate\\']].groupby(\\'user_id\\').mean().reset_index().round(2)\\n  return grouped\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n  df = pd.merge(signups, confirmations, how = \\'left\\', on = \\'user_id\\')\\n  df.loc[df[\\'action\\'] == \\'confirmed\\', \\'confirmation_rate\\'] = 1\\n  df.loc[df[\\'action\\'] != \\'confirmed\\', \\'confirmation_rate\\'] = 0\\n  grouped = df[[\\'user_id\\', \\'confirmation_rate\\']].groupby(\\'user_id\\').mean().reset_index().round(2)\\n  return grouped\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4083171,
                "title": "left-join-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id, \\nROUND(AVG(CASE\\nWHEN c.action=\\'confirmed\\' THEN 1\\nELSE 0\\nEND),2) AS confirmation_rate\\nFROM Signups s \\nLEFT JOIN Confirmations c\\nON s.user_id=c.user_id\\nGROUP BY user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id, \\nROUND(AVG(CASE\\nWHEN c.action=\\'confirmed\\' THEN 1\\nELSE 0\\nEND),2) AS confirmation_rate\\nFROM Signups s \\nLEFT JOIN Confirmations c\\nON s.user_id=c.user_id\\nGROUP BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081835,
                "title": "built-using-basics",
                "content": "with table2 as(\\nwith table1 as(\\nselect s.user_id , count(action) over(partition by c.user_id) as tot , case\\nwhen action = \\'timeout\\' then 0\\nwhen action = \\'confirmed\\' then 1\\nend as act\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id)\\nselect distinct user_id , tot, sum(act) over(partition by user_id) as action from table1)\\nselect user_id , round(ifnull(action / tot,0),2) as confirmation_rate\\nfrom table2;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "with table2 as(\\nwith table1 as(\\nselect s.user_id , count(action) over(partition by c.user_id) as tot , case\\nwhen action = \\'timeout\\' then 0\\nwhen action = \\'confirmed\\' then 1\\nend as act\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id)\\nselect distinct user_id , tot, sum(act) over(partition by user_id) as action from table1)\\nselect user_id , round(ifnull(action / tot,0),2) as confirmation_rate\\nfrom table2;",
                "codeTag": "Unknown"
            },
            {
                "id": 4079977,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT t1.user_id,\\n  IFNULL(\\n    ROUND(\\n      (\\n        (SELECT COUNT(t2.user_id) FROM Confirmations t2 WHERE t2.user_id = t1.user_id AND t2.action = \\'confirmed\\') /\\n        (SELECT COUNT(t3.user_id) FROM Confirmations t3 WHERE t3.user_id = t1.user_id)\\n      ),\\n      2  -- Number of decimal places\\n    ),\\n    0\\n  ) AS confirmation_rate\\nFROM Signups t1;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT t1.user_id,\\n  IFNULL(\\n    ROUND(\\n      (\\n        (SELECT COUNT(t2.user_id) FROM Confirmations t2 WHERE t2.user_id = t1.user_id AND t2.action = \\'confirmed\\') /\\n        (SELECT COUNT(t3.user_id) FROM Confirmations t3 WHERE t3.user_id = t1.user_id)\\n      ),\\n      2  -- Number of decimal places\\n    ),\\n    0\\n  ) AS confirmation_rate\\nFROM Signups t1;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079397,
                "title": "easiest-way-to-solve-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect a.user_id,round(avg(if(b.action = \"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups a \\nleft join Confirmations b on a.user_id = b.user_id\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a.user_id,round(avg(if(b.action = \"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups a \\nleft join Confirmations b on a.user_id = b.user_id\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079215,
                "title": "left-join-in-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg( CASE WHEN c.action = \\'confirmed\\' THEN 1.0 ELSE 0.0 END),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg( CASE WHEN c.action = \\'confirmed\\' THEN 1.0 ELSE 0.0 END),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078667,
                "title": "sql-left-join-and-group-by",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id, \\n    round(\\n        avg(\\n            CASE\\n                WHEN c.action = \\'confirmed\\' THEN 1.0\\n                ELSE 0.0\\n            END\\n        )\\n        , 2\\n    ) as confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON c.user_id = s.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id, \\n    round(\\n        avg(\\n            CASE\\n                WHEN c.action = \\'confirmed\\' THEN 1.0\\n                ELSE 0.0\\n            END\\n        )\\n        , 2\\n    ) as confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON c.user_id = s.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078618,
                "title": "handle-plsql-not-able-to-divide-by-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nwith cte as (\\nselect \\ns.user_id \\n, count(case when c.action = \\'confirmed\\' then c.action end) confirmed\\n, count(c.action) actions \\nfrom signups s left join confirmations c on s.user_id = c.user_id\\ngroup by s.user_id\\n)\\nselect user_id\\n, case when actions = 0 then 0.00 else round(confirmed/actions,2) end confirmation_rate\\nfrom cte\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nwith cte as (\\nselect \\ns.user_id \\n, count(case when c.action = \\'confirmed\\' then c.action end) confirmed\\n, count(c.action) actions \\nfrom signups s left join confirmations c on s.user_id = c.user_id\\ngroup by s.user_id\\n)\\nselect user_id\\n, case when actions = 0 then 0.00 else round(confirmed/actions,2) end confirmation_rate\\nfrom cte\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078227,
                "title": "that-s-hell-of-a-solution-for-me",
                "content": "# Code\\n```\\nWITH conf AS (\\n    SELECT user_id, COUNT(*) AS num\\n    FROM Confirmations \\n    GROUP BY user_id, action\\n    HAVING action = \\'confirmed\\'\\n),\\nwhole AS (\\n    SELECT user_id, COUNT(*) AS num\\n    FROM Signups s LEFT JOIN Confirmations c USING(user_id)\\n    GROUP BY s.user_id\\n)\\n\\nSELECT user_id, ROUND(COALESCE(c.num/w.num,0),2) AS confirmation_rate\\nFROM whole w LEFT JOIN conf c USING (user_id)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH conf AS (\\n    SELECT user_id, COUNT(*) AS num\\n    FROM Confirmations \\n    GROUP BY user_id, action\\n    HAVING action = \\'confirmed\\'\\n),\\nwhole AS (\\n    SELECT user_id, COUNT(*) AS num\\n    FROM Signups s LEFT JOIN Confirmations c USING(user_id)\\n    GROUP BY s.user_id\\n)\\n\\nSELECT user_id, ROUND(COALESCE(c.num/w.num,0),2) AS confirmation_rate\\nFROM whole w LEFT JOIN conf c USING (user_id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078185,
                "title": "beats-98-56-solutions-2-ways-easy-code-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. LEFT JOIN ```Signups``` table with ```Confirmations``` table on ```user_id```.\\n2. GROUP BY ```user_id```.\\n3. To display user_id we can simply use ```user_id``` field from ```Singup``` table.\\n4. To calculate ```confirmation_rate```, we can use below 2 approachs (in a way both are same):\\n    -  1st Approcah: Using ```AVG()```, ```ROUND``` and ```CASE```\\n        -  It counts how many times a user\\'s actions were \\'confirmed\\' (which have a value of 1) and counts how many total actions that user took. Then, it calculates the average of those 1s and 0s, which gives the percentage of \\'confirmed\\' actions. And finally, it rounds that percentage to two decimal places using ```ROUND``` function.\\n        - `ROUND(AVG(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END), 2) as confirmation_rate`\\n        \\n    -  2nd Approcah: Using ```coalesce()```, ```COUNT```, ```ROUND``` and ```CASE```\\n        - Here, we are calulating confirmation rate for a user by finding the ratio of the number of \\'confirmed\\' actions to the total number of actions that user has taken. Also, to handles cases where there are no actions like in case of ```user_id = 6```, ```coalesce``` fuction is being used. Finally, it rounds that percentage to two decimal places using ```ROUND``` function.\\n        - `ROUND(coalesce(COUNT(CASE WHEN c.action = \\'confirmed\\' THEN 1 END)/COUNT(action),0), 2) as confirmation_rate`\\n\\n# Complexity\\n- Time complexity: 1042 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0.00MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Solution 1\\nSELECT s.user_id, \\n        ROUND(AVG(\\n            CASE \\n                WHEN c.action = \\'confirmed\\' \\n                THEN 1 ELSE 0 \\n            END), 2) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n# Solution 2\\nSELECT s.user_id, \\n        ROUND(\\n            COALESCE(\\n                COUNT(CASE WHEN c.action = \\'confirmed\\' THEN 1 END)\\n                /COUNT(action),0), 2) \\n        as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```Signups```\n```Confirmations```\n```user_id```\n```user_id```\n```user_id```\n```Singup```\n```confirmation_rate```\n```AVG()```\n```ROUND```\n```CASE```\n```ROUND```\n```coalesce()```\n```COUNT```\n```ROUND```\n```CASE```\n```user_id = 6```\n```coalesce```\n```ROUND```\n```\\n# Solution 1\\nSELECT s.user_id, \\n        ROUND(AVG(\\n            CASE \\n                WHEN c.action = \\'confirmed\\' \\n                THEN 1 ELSE 0 \\n            END), 2) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n# Solution 2\\nSELECT s.user_id, \\n        ROUND(\\n            COALESCE(\\n                COUNT(CASE WHEN c.action = \\'confirmed\\' THEN 1 END)\\n                /COUNT(action),0), 2) \\n        as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077706,
                "title": "pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    df = signups.merge(confirmations, how = \\'left\\', on=\\'user_id\\')\\n    df1 = df.groupby(\\'user_id\\')[\\'action\\'].apply(lambda x: (x ==\\'confirmed\\').sum()/len(x) if not x.empty else 0).round(2).reset_index(name=\\'confirmation_rate\\')\\n    return df1\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    df = signups.merge(confirmations, how = \\'left\\', on=\\'user_id\\')\\n    df1 = df.groupby(\\'user_id\\')[\\'action\\'].apply(lambda x: (x ==\\'confirmed\\').sum()/len(x) if not x.empty else 0).round(2).reset_index(name=\\'confirmation_rate\\')\\n    return df1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4077020,
                "title": "another-solution",
                "content": "an  easy solution of the novice for novices....\\n  \\n  \\n\\t\\t   select aa.user_id, \\n\\t\\t\\t\\t\\tcase when bb.confirmation_rate is null then 0\\n\\t\\t\\t\\t\\telse bb.confirmation_rate end as confirmation_rate\\n\\t\\t\\tfrom Signups aa\\n\\t\\t\\tleft outer join\\n\\t\\t\\t(\\n\\n\\t\\t\\t\\tselect user_id, \\n\\t\\t\\t\\t\\t   round(nvl(sum(case when action= \\'confirmed\\' then 1 else 0 end)/count(action),0),2) as confirmation_rate\\n\\t\\t\\t\\tfrom Confirmations\\n\\t\\t\\t\\tgroup by user_id\\n\\t\\t\\t) bb\\n\\t\\t\\ton aa.user_id = bb.user_id\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "an  easy solution of the novice for novices....\\n  \\n  \\n\\t\\t   select aa.user_id, \\n\\t\\t\\t\\t\\tcase when bb.confirmation_rate is null then 0\\n\\t\\t\\t\\t\\telse bb.confirmation_rate end as confirmation_rate\\n\\t\\t\\tfrom Signups aa\\n\\t\\t\\tleft outer join\\n\\t\\t\\t(\\n\\n\\t\\t\\t\\tselect user_id, \\n\\t\\t\\t\\t\\t   round(nvl(sum(case when action= \\'confirmed\\' then 1 else 0 end)/count(action),0),2) as confirmation_rate\\n\\t\\t\\t\\tfrom Confirmations\\n\\t\\t\\t\\tgroup by user_id\\n\\t\\t\\t) bb\\n\\t\\t\\ton aa.user_id = bb.user_id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4074438,
                "title": "mssql",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    s.user_id,\\n    round(\\n        case\\n             when isnull(conf,0)+isnull(timeout,0)=0\\n                then 0\\n                else 1.0*conf/(conf+timeout)\\n        end\\n    , 2) as confirmation_rate\\nfrom Signups s\\nleft join (\\n    select\\n        user_id,\\n        sum(case when action=\\'timeout\\' then 1 else 0 end) as timeout,\\n        sum(case when action=\\'confirmed\\' then 1 else 0 end) as conf\\n    from Confirmations\\n    group by user_id\\n) as aa\\non s.user_id=aa.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    s.user_id,\\n    round(\\n        case\\n             when isnull(conf,0)+isnull(timeout,0)=0\\n                then 0\\n                else 1.0*conf/(conf+timeout)\\n        end\\n    , 2) as confirmation_rate\\nfrom Signups s\\nleft join (\\n    select\\n        user_id,\\n        sum(case when action=\\'timeout\\' then 1 else 0 end) as timeout,\\n        sum(case when action=\\'confirmed\\' then 1 else 0 end) as conf\\n    from Confirmations\\n    group by user_id\\n) as aa\\non s.user_id=aa.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074385,
                "title": "beats-99-32",
                "content": "# Complexity\\n- Time complexity: 1082ms\\n - Space complexity: 0.00MB\\n\\n# Code\\n```\\nSELECT\\n    s.user_id,\\n    IFNULL(ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*),2),0) AS confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    s.user_id,\\n    IFNULL(ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*),2),0) AS confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073621,
                "title": "easy-mysql-solution",
                "content": "\\n\\n# Code\\n```\\nselect s.user_id, \\n-- confirmations\\nround((sum(case when action = \\'confirmed\\' then 1 else 0 end))  \\n/\\n-- total\\n(sum(case when action=\"a\" then 0 else 1 end )),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\nusing(user_id)\\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id, \\n-- confirmations\\nround((sum(case when action = \\'confirmed\\' then 1 else 0 end))  \\n/\\n-- total\\n(sum(case when action=\"a\" then 0 else 1 end )),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\nusing(user_id)\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072827,
                "title": "sql-query-to-calculate-user-confirmation-rates",
                "content": "# Intuition\\nThe problem involves calculating a confirmation rate for users based on their signups and confirmation actions in a database. We need to join the \"Signups\" and \"Confirmations\" tables and calculate the confirmation rate for each user.\\n\\n# Approach\\nWe\\'ll use a SQL query to join the \"Signups\" table (aliased as \\'s\\') with the \"Confirmations\" table (aliased as \\'c\\') using the \\'user_id\\' as the common key.\\n\\nIn the SELECT statement, we\\'ll calculate the confirmation rate for each user using a CASE statement. If there are confirmation actions (\\'confirmed\\') for a user, we\\'ll calculate the rate as the count of \\'confirmed\\' actions divided by the total count of actions. We\\'ll round the result to two decimal places. If there are no confirmation actions, we\\'ll set the rate to 0.\\n\\nWe\\'ll use DISTINCT to ensure we get only unique user_id and confirmation_rate pairs.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this SQL query depends on the size of the \"Signups\" and \"Confirmations\" tables and the efficiency of the database engine\\'s query execution. In general, it would be $$O(N*M)$$, where N is the number of rows in the \"Signups\" table, and M is the number of rows in the \"Confirmations\" table.\\n\\n- Space complexity:\\nThe space complexity is primarily determined by the memory used to store the result set. In this case, the result set will have a row for each user with their user_id and confirmation_rate, so the space complexity is $$O(N)$$, where N is the number of distinct users in the \"Signups\" table.\\n\\n# Code\\n```\\nSELECT DISTINCT s.user_id,\\n        CASE \\n            WHEN c.action IS NULL THEN 0\\n            WHEN c.action IS NOT NULL THEN ROUND((SELECT count(action)\\n                                          FROM Confirmations\\n                                          WHERE user_id = s.user_id\\n                                          AND action = \\'confirmed\\') / \\n                                          (SELECT count(action)\\n                                           FROM Confirmations\\n                                           WHERE user_id = s.user_id), 2)\\n        END AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT DISTINCT s.user_id,\\n        CASE \\n            WHEN c.action IS NULL THEN 0\\n            WHEN c.action IS NOT NULL THEN ROUND((SELECT count(action)\\n                                          FROM Confirmations\\n                                          WHERE user_id = s.user_id\\n                                          AND action = \\'confirmed\\') / \\n                                          (SELECT count(action)\\n                                           FROM Confirmations\\n                                           WHERE user_id = s.user_id), 2)\\n        END AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072700,
                "title": "beats-96-86-of-users-with-mysql",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nwith cte1 as(\\nselect s.user_id, c.action from Signups s left join Confirmations c on s.user_id = c.user_id),\\n\\ncte2 as(\\nselect *,\\ncount(user_id) over(partition by user_id) as cnt,\\n# case when action = \\'timeout\\' then 1 else 0 end as timeout_flag,\\ncase when action = \\'confirmed \\' then 1 else 0 end as conf_flag\\nfrom cte1),\\n\\ncte3 as(\\nselect user_id, round(sum(conf_flag) /count(user_id),2) as confirmation_rate from cte2 group by user_id)\\n\\nselect * from cte3\\n# select user_id, sum(confirmation_rate) as confirmation_rate from cte3 group by user_id\\n# order by confirmation_rate\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte1 as(\\nselect s.user_id, c.action from Signups s left join Confirmations c on s.user_id = c.user_id),\\n\\ncte2 as(\\nselect *,\\ncount(user_id) over(partition by user_id) as cnt,\\n# case when action = \\'timeout\\' then 1 else 0 end as timeout_flag,\\ncase when action = \\'confirmed \\' then 1 else 0 end as conf_flag\\nfrom cte1),\\n\\ncte3 as(\\nselect user_id, round(sum(conf_flag) /count(user_id),2) as confirmation_rate from cte2 group by user_id)\\n\\nselect * from cte3\\n# select user_id, sum(confirmation_rate) as confirmation_rate from cte3 group by user_id\\n# order by confirmation_rate\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070733,
                "title": "left-join-group-by-and-coalesce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first count all action per user signup, join and count. \\nsecond, search for confirmed action per user, use case when\\nthird, group by left table field, (Signups.user_id). \\nnote:\\n    it did not work if you group by right table. Confirmations.user_id\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect \\n  s.user_id, \\n  coalesce(\\n    round(sum(\\n      case when c.action = \\'confirmed\\' then 1 else 0 end\\n    ) / count(c.action),2), \\n    0.00\\n  ) confirmation_rate \\nfrom \\n  Signups s \\n  left join Confirmations c on s.user_id = c.user_id \\ngroup by \\n  s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect \\n  s.user_id, \\n  coalesce(\\n    round(sum(\\n      case when c.action = \\'confirmed\\' then 1 else 0 end\\n    ) / count(c.action),2), \\n    0.00\\n  ) confirmation_rate \\nfrom \\n  Signups s \\n  left join Confirmations c on s.user_id = c.user_id \\ngroup by \\n  s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070287,
                "title": "99-beats-using-case-and-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to create a new column turning \"timeout\" to 0 and \"confirmed\" to 1. Then use COALESCE to turn null into 0 as well. The SUM() function calculate the total number of confirmed case for each user id, and COUNT() function calculate the total number of sign ups for each user id. GROUP at the end to show the outcome\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n  ROUND((SUM(COALESCE(CASE WHEN action IN (\\'timeout\\')\\n    THEN \\'0\\'\\n    WHEN action = \\'confirmed\\'\\n    THEN \\'1\\'\\n  END  ,0))) /\\n  COUNT(s.user_id),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations As c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n  ROUND((SUM(COALESCE(CASE WHEN action IN (\\'timeout\\')\\n    THEN \\'0\\'\\n    WHEN action = \\'confirmed\\'\\n    THEN \\'1\\'\\n  END  ,0))) /\\n  COUNT(s.user_id),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations As c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070277,
                "title": "use-case-when-and-left-join",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n  ROUND((SUM(COALESCE(CASE WHEN action IN (\\'timeout\\')\\n    THEN \\'0\\'\\n    WHEN action = \\'confirmed\\'\\n    THEN \\'1\\'\\n  END  ,0))) /\\n  COUNT(s.user_id),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations As c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n  ROUND((SUM(COALESCE(CASE WHEN action IN (\\'timeout\\')\\n    THEN \\'0\\'\\n    WHEN action = \\'confirmed\\'\\n    THEN \\'1\\'\\n  END  ,0))) /\\n  COUNT(s.user_id),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations As c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070087,
                "title": "case-count-group-with-cte",
                "content": "# Intuition\\n The idea is to create a new table that has everybody\\'s confirmation rate with the use of CTE\\n\\n# Approach\\n\\n- `Count (user_id)` to find out how many requests made by each `user_id`\\n- then use `count` with a `case` to find out the number of confirmed sessions\\n- Divide the two in a new column to to find the confirmation_rate\\n\\n# Complexity\\n- Time complexity:\\n99.7% better\\n\\n- Space complexity:\\n0 MBS\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n-- find confirmation rate of each user \\n\\nwith details as (\\nselect user_id, \\n       count(user_id) as no_of_requests, \\n      -- count(case when action =\\'timeout\\' then 0 end) as no_timeout,\\n       count(case when action =\\'confirmed\\' then 1 end) as no_confirmed,\\n       round(count(case when action =\\'confirmed\\' then 1 end)  / count(user_id),2) as confirmation_rate\\n\\nfrom confirmations \\ngroup by 1\\n\\n) select s.user_id\\n         ,case when confirmation_rate is null then 0 else confirmation_rate end as confirmation_rate\\n\\n   from signups s\\n   left join details d\\n   on s.user_id = d.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n-- find confirmation rate of each user \\n\\nwith details as (\\nselect user_id, \\n       count(user_id) as no_of_requests, \\n      -- count(case when action =\\'timeout\\' then 0 end) as no_timeout,\\n       count(case when action =\\'confirmed\\' then 1 end) as no_confirmed,\\n       round(count(case when action =\\'confirmed\\' then 1 end)  / count(user_id),2) as confirmation_rate\\n\\nfrom confirmations \\ngroup by 1\\n\\n) select s.user_id\\n         ,case when confirmation_rate is null then 0 else confirmation_rate end as confirmation_rate\\n\\n   from signups s\\n   left join details d\\n   on s.user_id = d.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069585,
                "title": "ms-sql-server-solution",
                "content": "SELECT s.user_id, ROUND(SUM(CAST(IIF(c.action = \\'confirmed\\',1,0) AS FLOAT)) / CAST(COUNT(s.user_id) AS FLOAT), 2) AS confirmation_rate FROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id;",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "SELECT s.user_id, ROUND(SUM(CAST(IIF(c.action = \\'confirmed\\',1,0) AS FLOAT)) / CAST(COUNT(s.user_id) AS FLOAT), 2) AS confirmation_rate FROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 4065724,
                "title": "confirmation-rate-solution-in-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nROUND & AVG keywords\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M)\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT S.USER_ID, ROUND(AVG(IF(C.ACTION = \"CONFIRMED\", 1, 0)), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\nGROUP BY USER_ID\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/0c7be364-2a58-4c35-bbb0-9a795c37c3e9_1695147832.9752522.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT S.USER_ID, ROUND(AVG(IF(C.ACTION = \"CONFIRMED\", 1, 0)), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\nGROUP BY USER_ID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064165,
                "title": "96-beats-using-only-left-join",
                "content": "\\n# Approach\\nLeft Join signups table with confirmation table. However, we create confirmation table twice, one for calculating total number of success (here confirmations) and another for calculating the total number of requests. The Coalesce function is applied so as to return confirmation_rate as zero when there is no confirmation at all.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, Coalesce(round(T.number_confirmed/U.total_requested, 2),0) as confirmation_rate\\nfrom Signups s Left Join (select user_id, count(*) as number_confirmed from Confirmations where action = \\'confirmed\\' group by user_id) T on s.user_id = T.user_id Left Join (select user_id, count(*) as total_requested from Confirmations group by user_id) as U on s.user_id = U.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, Coalesce(round(T.number_confirmed/U.total_requested, 2),0) as confirmation_rate\\nfrom Signups s Left Join (select user_id, count(*) as number_confirmed from Confirmations where action = \\'confirmed\\' group by user_id) T on s.user_id = T.user_id Left Join (select user_id, count(*) as total_requested from Confirmations group by user_id) as U on s.user_id = U.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4063186,
                "title": "mysql-solution-beats-97-75",
                "content": "# Approach\\nFirst we **left** join Signups and Confirmations, then we substitute the `timeout`, `null` and `confirmed` in `Confirmations` for `0` and `1`.\\n\\nThen we round the average of action (1s and 0s) to 2 decimals.\\nWe group by userid when averaging.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, ROUND(AVG(action), 2) AS confirmation_rate FROM (\\n  SELECT Signups.user_id, CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END AS action FROM Signups\\n  LEFT JOIN Confirmations ON Confirmations.user_id = Signups.user_id\\n) AS t\\nGROUP BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, ROUND(AVG(action), 2) AS confirmation_rate FROM (\\n  SELECT Signups.user_id, CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END AS action FROM Signups\\n  LEFT JOIN Confirmations ON Confirmations.user_id = Signups.user_id\\n) AS t\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062999,
                "title": "using-cte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWith nom as (Select user_id, count(*) as usercount from Confirmations where action = \\'confirmed\\' group by user_id),\\ndenom as (Select user_id, count(*) as totalcount from Confirmations group by user_id),\\nconf_rate as (Select nom.user_id ,  usercount/totalcount as rate from nom join denom on nom.user_id = denom.user_id)\\nSelect s.user_id , case when c.rate is null then 0.00 else round(c.rate,2) end as confirmation_rate\\nfrom Signups s \\nleft join conf_rate c on s.user_id = c.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWith nom as (Select user_id, count(*) as usercount from Confirmations where action = \\'confirmed\\' group by user_id),\\ndenom as (Select user_id, count(*) as totalcount from Confirmations group by user_id),\\nconf_rate as (Select nom.user_id ,  usercount/totalcount as rate from nom join denom on nom.user_id = denom.user_id)\\nSelect s.user_id , case when c.rate is null then 0.00 else round(c.rate,2) end as confirmation_rate\\nfrom Signups s \\nleft join conf_rate c on s.user_id = c.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061702,
                "title": "top-90-simple-solution-with-left-join",
                "content": "# Explanation\\nFirst we are selecting the user id since we want to know the confirmation rate of each user. Then we select the rounded average of whether or not the action is confirmed in the confirmations table. If the action is confirmed, we return 1, otherwise zero. This list of numbers is what we are taking the average of. We use LEFT JOIN between the Signups table and Confirmations table on the user id. Then we group by user id to get ony one result for every user_id. **Make sure to like if you found this useful**.\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id, ROUND(AVG(if(c.action = \\'confirmed\\', 1, 0)), 2) AS confirmation_rate\\nFROM Signups AS s LEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\nGROUP BY user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id, ROUND(AVG(if(c.action = \\'confirmed\\', 1, 0)), 2) AS confirmation_rate\\nFROM Signups AS s LEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\nGROUP BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060723,
                "title": "simple-soln-using-grp-by-left-join-and-avg-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id,ifnull(round(avg(action=\\'confirmed\\'),2),0) confirmation_rate from signups s left join confirmations c on c.user_id=s.user_id group by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id,ifnull(round(avg(action=\\'confirmed\\'),2),0) confirmation_rate from signups s left join confirmations c on c.user_id=s.user_id group by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060143,
                "title": "easy-solution-using-aggregation-and-left-joins",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect Signups.user_id,  ROUND(AVG(IF(Confirmations.action=\\'confirmed\\',1,0)),2) as confirmation_rate  from Signups left join Confirmations  on Signups.user_id=Confirmations.user_id\\ngroup by Signups.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Signups.user_id,  ROUND(AVG(IF(Confirmations.action=\\'confirmed\\',1,0)),2) as confirmation_rate  from Signups left join Confirmations  on Signups.user_id=Confirmations.user_id\\ngroup by Signups.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059947,
                "title": "simple-beginner-friendly-using-temp-table-beats-80-of-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a temp table from Confimations containing user_id and count of confirmed actions.\\n2. Left join signups and temp table on user_id and divide confirmed count by total count.\\n3. Used coalesce to handle null values and round to make output up to two decimal places\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cnf as (\\n  select user_id, case when action = \\'confirmed\\' then 1 else 0 end as cnt\\n  from Confirmations\\n)\\nselect s.user_id, round(coalesce(sum(cnt) / count(1), 0),2) as confirmation_rate\\nfrom Signups s\\nleft join cnf c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cnf as (\\n  select user_id, case when action = \\'confirmed\\' then 1 else 0 end as cnt\\n  from Confirmations\\n)\\nselect s.user_id, round(coalesce(sum(cnt) / count(1), 0),2) as confirmation_rate\\nfrom Signups s\\nleft join cnf c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057047,
                "title": "beats-99-69",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith t as(\\nSELECT c.user_id as c_user,s.user_id as s_user, (case when action =\"timeout\" THEN \\'0\\'\\n                        when action =\"confirmed\" THEN \\'1\\' \\n                     END) AS cr\\nFROM signups s\\nleft join confirmations c\\nON s.user_id = c.user_id)\\n\\nSELECT s_user AS user_id , ifnull(ROUND(sum(cr)/count(c_user),2),0) as confirmation_rate\\nfrom t\\ngroup by s_user\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith t as(\\nSELECT c.user_id as c_user,s.user_id as s_user, (case when action =\"timeout\" THEN \\'0\\'\\n                        when action =\"confirmed\" THEN \\'1\\' \\n                     END) AS cr\\nFROM signups s\\nleft join confirmations c\\nON s.user_id = c.user_id)\\n\\nSELECT s_user AS user_id , ifnull(ROUND(sum(cr)/count(c_user),2),0) as confirmation_rate\\nfrom t\\ngroup by s_user\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056955,
                "title": "using-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect s.user_id,CASE WHEN c.time_stamp IS NULL THEN 0.00\\nELSE Round(SUM(c.action=\\'confirmed\\')/count(*),2) END AS confirmation_rate\\nFrom signups s\\nleft join confirmations c\\non s.user_id=c.user_id\\ngroup by user_id \\nORDER BY  USER_id DESC\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id,CASE WHEN c.time_stamp IS NULL THEN 0.00\\nELSE Round(SUM(c.action=\\'confirmed\\')/count(*),2) END AS confirmation_rate\\nFrom signups s\\nleft join confirmations c\\non s.user_id=c.user_id\\ngroup by user_id \\nORDER BY  USER_id DESC\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056568,
                "title": "easiest-way-to-solve-using-window-function",
                "content": "\\n\\n# Code\\n```\\nSELECT distinct a.user_id,\\n       ROUND(AVG(CASE WHEN b.action = \\'confirmed\\' THEN 1 ELSE 0 END)\\n          OVER (PARTITION BY user_id),2) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations b ON a.user_id = b.user_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT distinct a.user_id,\\n       ROUND(AVG(CASE WHEN b.action = \\'confirmed\\' THEN 1 ELSE 0 END)\\n          OVER (PARTITION BY user_id),2) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations b ON a.user_id = b.user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055431,
                "title": "sql-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith conf_rate as (select c.user_id, \\n\\n ( \\n     \\n    ROUND(( COUNT(CASE WHEN c.action = \\'confirmed\\' THEN c.user_id END )\\n     / (COUNT(c.user_id) ) ) , 2)\\n \\n \\n ) AS confirmation_rate\\nfrom Confirmations c\\nGROUP BY c.user_id\\n\\n\\n)\\n\\nselect s.user_id, IFNULL(cr.confirmation_rate, 0) AS confirmation_rate from Signups s\\nleft OUTER JOIN conf_rate cr on cr.user_id = s.user_id \\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith conf_rate as (select c.user_id, \\n\\n ( \\n     \\n    ROUND(( COUNT(CASE WHEN c.action = \\'confirmed\\' THEN c.user_id END )\\n     / (COUNT(c.user_id) ) ) , 2)\\n \\n \\n ) AS confirmation_rate\\nfrom Confirmations c\\nGROUP BY c.user_id\\n\\n\\n)\\n\\nselect s.user_id, IFNULL(cr.confirmation_rate, 0) AS confirmation_rate from Signups s\\nleft OUTER JOIN conf_rate cr on cr.user_id = s.user_id \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055097,
                "title": "beats-100-00-join-case-when-statement",
                "content": "# Code\\n\\n\\n```sql []\\nselect\\na.user_id,\\nround(coalesce(sum(\\n        case when b.action = \\'confirmed\\' \\n            then 1 \\n          else 0 \\n        end)/count(b.action), 0),2) as confirmation_rate \\nfrom\\nSignups a\\nleft join Confirmations b\\non a.user_id = b.user_id\\ngroup by a.user_id\\norder by 1\\n```\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql []\\nselect\\na.user_id,\\nround(coalesce(sum(\\n        case when b.action = \\'confirmed\\' \\n            then 1 \\n          else 0 \\n        end)/count(b.action), 0),2) as confirmation_rate \\nfrom\\nSignups a\\nleft join Confirmations b\\non a.user_id = b.user_id\\ngroup by a.user_id\\norder by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054342,
                "title": "simple-approach-without-using-cte",
                "content": "# Code\\n```\\nselect s.user_id, \\nround(sum(case \\nwhen c.action = \\'confirmed\\'\\nthen 1 else 0 end)/count(*),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c on c.user_id=s.user_id\\ngroup by user_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id, \\nround(sum(case \\nwhen c.action = \\'confirmed\\'\\nthen 1 else 0 end)/count(*),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c on c.user_id=s.user_id\\ngroup by user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053821,
                "title": "explanation-and-solution-beats-100",
                "content": "\\n# Approach\\nUsing IFNULL to detect Null values in the confirmation_rate and replace it with 0.\\n\\nAction = \"confirmed\" finds all \"confirmed\" action and avg() counts the average of it after that I rounded them to 2 decimal place by Round(avg(),2) to satisfied the required result and test cases.\\n\\nGroup by user_id so it did not show any duplication of the user_id\\n\\n# Code\\n```\\nSelect S.user_id, IFNULL(Round(avg(action = \"confirmed\"),2),0) as confirmation_rate\\nFrom Signups as S\\nLeft Join Confirmations as C On S.user_id = C.user_id\\nGroup by S.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect S.user_id, IFNULL(Round(avg(action = \"confirmed\"),2),0) as confirmation_rate\\nFrom Signups as S\\nLeft Join Confirmations as C On S.user_id = C.user_id\\nGroup by S.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053655,
                "title": "confirmation-rate-mysql",
                "content": "\\n\\n# Approach\\nPlease upvote if you like the approach\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect user_id, round(sum(action_confirmed)/count(action),2) as confirmation_rate\\nFrom (\\nselect s.user_id,\\ncase when action=\\'confirmed\\' then 1  \\n     when NULLIF(c.action, 0.00) IS NULL then 0 \\n     else 0 end as action_confirmed , \\ncase when action is null then 0 else action end as action\\nfrom Signups s left join Confirmations c on s.user_id=c.user_id \\n)a\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect user_id, round(sum(action_confirmed)/count(action),2) as confirmation_rate\\nFrom (\\nselect s.user_id,\\ncase when action=\\'confirmed\\' then 1  \\n     when NULLIF(c.action, 0.00) IS NULL then 0 \\n     else 0 end as action_confirmed , \\ncase when action is null then 0 else action end as action\\nfrom Signups s left join Confirmations c on s.user_id=c.user_id \\n)a\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053223,
                "title": "beats-83-easy-solution-using-left-join-case-statement",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT \\n  s.user_id,\\n  ROUND(SUM(CASE \\n              WHEN action = \"timeout\" OR action IS NULL \\n              THEN 0 ELSE 1 END)/COUNT(*),2) AS confirmation_rate \\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT \\n  s.user_id,\\n  ROUND(SUM(CASE \\n              WHEN action = \"timeout\" OR action IS NULL \\n              THEN 0 ELSE 1 END)/COUNT(*),2) AS confirmation_rate \\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052999,
                "title": "99-13-beats-using-subquery",
                "content": "\\n# Code\\n```\\nSELECT s.user_id, ROUND(COALESCE(cr.confirmation_rate, 0),2) AS confirmation_rate\\nFROM\\n(SELECT cc.user_id, (cc.total_confirmed/ca.total_action) AS confirmation_rate\\nFROM (SELECT user_id, COUNT(user_id) AS total_action \\n      FROM confirmations\\n      GROUP BY user_id) AS ca\\nINNER JOIN (SELECT user_id, action, COUNT(action) AS total_confirmed \\n            FROM confirmations\\n            WHERE action = \"confirmed\"\\n            GROUP BY user_id, action) AS cc\\nON ca.user_id = cc.user_id\\nGROUP BY cc.user_id) AS cr\\nRIGHT JOIN signups s\\nON s.user_id = cr.user_id\\nORDER BY confirmation_rate ASC\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.user_id, ROUND(COALESCE(cr.confirmation_rate, 0),2) AS confirmation_rate\\nFROM\\n(SELECT cc.user_id, (cc.total_confirmed/ca.total_action) AS confirmation_rate\\nFROM (SELECT user_id, COUNT(user_id) AS total_action \\n      FROM confirmations\\n      GROUP BY user_id) AS ca\\nINNER JOIN (SELECT user_id, action, COUNT(action) AS total_confirmed \\n            FROM confirmations\\n            WHERE action = \"confirmed\"\\n            GROUP BY user_id, action) AS cc\\nON ca.user_id = cc.user_id\\nGROUP BY cc.user_id) AS cr\\nRIGHT JOIN signups s\\nON s.user_id = cr.user_id\\nORDER BY confirmation_rate ASC\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049851,
                "title": "cte-method-99-6",
                "content": "# Intuition\\nUse CTE (Common Table Expression) to create temporary tables and make queries on these tables.\\n\\n# Approach\\n- `ct` table: count the numbers of each user\\'s confirmed messages.\\n- `tt` table: count the numbers of each user\\'s total messages.\\n- `cf` table: calculate the confirmation_rate of each user.\\n- Finally, `signups` left join `cf` to collect all users\\' id, and used CASE to fill out the NULL one with 0.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH ct AS (SELECT user_id, action, COUNT(*) AS num\\n        FROM confirmations\\n        WHERE action = \\'confirmed\\'\\n        GROUP BY user_id, action),\\n     tt AS (SELECT user_id, COUNT(*) AS total\\n        FROM confirmations\\n        GROUP BY user_id),\\n     cf AS (SELECT ct.user_id AS user_id, ROUND(ct.num / tt.total,2) AS rate\\n        FROM ct\\n        JOIN tt\\n        ON ct.user_id = tt.user_id)\\n\\nSELECT s.user_id AS user_id,\\n        CASE \\n            WHEN cf.rate IS NULL THEN 0 \\n            ELSE cf.rate \\n        END AS confirmation_rate\\nFROM signups s\\nLEFT JOIN cf\\nON s.user_id = cf.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH ct AS (SELECT user_id, action, COUNT(*) AS num\\n        FROM confirmations\\n        WHERE action = \\'confirmed\\'\\n        GROUP BY user_id, action),\\n     tt AS (SELECT user_id, COUNT(*) AS total\\n        FROM confirmations\\n        GROUP BY user_id),\\n     cf AS (SELECT ct.user_id AS user_id, ROUND(ct.num / tt.total,2) AS rate\\n        FROM ct\\n        JOIN tt\\n        ON ct.user_id = tt.user_id)\\n\\nSELECT s.user_id AS user_id,\\n        CASE \\n            WHEN cf.rate IS NULL THEN 0 \\n            ELSE cf.rate \\n        END AS confirmation_rate\\nFROM signups s\\nLEFT JOIN cf\\nON s.user_id = cf.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049301,
                "title": "oracle-solution-with-egg-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect \\n    s.user_id, nvl(c.con_rate,0) confirmation_rate \\nfrom \\n    Signups s \\n    left join \\n    (select user_id, \\n    round(sum(decode(action, \\'confirmed\\', 1, 0)) / count(action),2) con_rate\\n    from Confirmations\\n    group by user_id\\n    ) c\\non s.user_id = c.user_id\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect \\n    s.user_id, nvl(c.con_rate,0) confirmation_rate \\nfrom \\n    Signups s \\n    left join \\n    (select user_id, \\n    round(sum(decode(action, \\'confirmed\\', 1, 0)) / count(action),2) con_rate\\n    from Confirmations\\n    group by user_id\\n    ) c\\non s.user_id = c.user_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047854,
                "title": "case-coalesce-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> work out the columns needed to calculate the rate, so count of actions per user, count of confirmations per user.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT s.user_id,\\ncoalesce(ROUND((SUM(CASE\\n              WHEN action = \\'confirmed\\' THEN 1.00\\n              ELSE 0.00\\n            END)/COUNT(c.action)), 2), 0)AS confirmation_rate\\nFROM Confirmations c\\nRIGHT JOIN Signups s\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT s.user_id,\\ncoalesce(ROUND((SUM(CASE\\n              WHEN action = \\'confirmed\\' THEN 1.00\\n              ELSE 0.00\\n            END)/COUNT(c.action)), 2), 0)AS confirmation_rate\\nFROM Confirmations c\\nRIGHT JOIN Signups s\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046584,
                "title": "simple-and-intuitive-mysql-code-beats-91",
                "content": "## Intuition\\n- Simply merge two tables by user_id\\n- By definition,  the confirmation rate is the number of \\'confirmed\\' messages divided by the total number of requested confirmation messages. \\n- We can separately calculate \\n    - the number of \\'confirmed\\' messages by ``` sum(if(action = \\'confirmed\\',1,0) ```\\n    - the total number of requested confirmation messages by ```count(action)```\\n- The very last thing is simply to divided these two numbers: ``` sum(if(action = \\'confirmed\\',1,0))/count(action) ```\\n### Additional notes\\n- Use COALESCE function to capture the cases where the total number of requests is 0\\n- round the confirmation rate to two digits using ROUND function \\n\\n\\n# Hope you like it!!!\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(COALESCE(sum(if(action = \\'confirmed\\',1,0))/count(action),0),2) as confirmation_rate from signups as s\\nleft join confirmations as c \\non s.user_id = c.user_id\\ngroup by s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "``` sum(if(action = \\'confirmed\\',1,0) ```\n```count(action)```\n``` sum(if(action = \\'confirmed\\',1,0))/count(action) ```\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(COALESCE(sum(if(action = \\'confirmed\\',1,0))/count(action),0),2) as confirmation_rate from signups as s\\nleft join confirmations as c \\non s.user_id = c.user_id\\ngroup by s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043949,
                "title": "not-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect user_id , round(sum(x)/count(user_id),2) confirmation_rate from (\\n     select s.user_id, action,\\n         ( CASE\\n          when action = \\'confirmed\\' then 1 else 0 end) x\\n     from Signups s left join Confirmations C \\n    on s.user_id = c.user_id) a\\ngroup by user_id\\norder by confirmation_rate\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect user_id , round(sum(x)/count(user_id),2) confirmation_rate from (\\n     select s.user_id, action,\\n         ( CASE\\n          when action = \\'confirmed\\' then 1 else 0 end) x\\n     from Signups s left join Confirmations C \\n    on s.user_id = c.user_id) a\\ngroup by user_id\\norder by confirmation_rate\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043139,
                "title": "mysql-solution",
                "content": "# Code\\n```\\nwith ft as (\\n    select s.user_id, action\\n    from Signups s\\n    left join Confirmations c\\n    on s.user_id = c.user_id\\n)\\nselect user_id, \\n    round(avg(if(action = \\'confirmed\\', 1, 0)), 2) as confirmation_rate\\nfrom ft\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith ft as (\\n    select s.user_id, action\\n    from Signups s\\n    left join Confirmations c\\n    on s.user_id = c.user_id\\n)\\nselect user_id, \\n    round(avg(if(action = \\'confirmed\\', 1, 0)), 2) as confirmation_rate\\nfrom ft\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040249,
                "title": "97-04-beats-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect s.user_id,round(sum(case when action = \\'confirmed\\' then 1 else 0 end)/count(s.user_id),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect s.user_id,round(sum(case when action = \\'confirmed\\' then 1 else 0 end)/count(s.user_id),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039419,
                "title": "sql-if-xxx-1-0-0-0",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\\'confirmed\\', 1, 0)), 2) as confirmation_rate\\nfrom signups as s\\nleft join confirmations as c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\\'confirmed\\', 1, 0)), 2) as confirmation_rate\\nfrom signups as s\\nleft join confirmations as c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039417,
                "title": "sql-case-when-xxx-then-x-else-y-end",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(case when action = \\'confirmed\\' then 1.00 else 0.00 end), 2) as confirmation_rate\\nfrom signups as s\\nleft join confirmations as c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(case when action = \\'confirmed\\' then 1.00 else 0.00 end), 2) as confirmation_rate\\nfrom signups as s\\nleft join confirmations as c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038274,
                "title": "beats-91-80-very-simple-mysql-querry-with-end-to-end-code-breakdown-explanation",
                "content": "# Intuition\\n1. **Main Query Structure:**\\n   - Your main query starts with a SELECT statement to retrieve specific columns from your result set.\\n   - You\\'re selecting `T1.USER_ID` (from the Signups table) and a calculated value `IFNULL(ROUND(T2.CONFIRMATION_RATE, 2), 0)` as `CONFIRMATION_RATE`.\\n\\n2. **The Subquery (T2):**\\n   - The subquery calculates the confirmation rate for each user in the Confirmations table. It groups the data by `USER_ID`.\\n   - Inside the subquery:\\n     - You use a conditional SUM to count the number of \\'confirmed\\' actions for each user.\\n     - You use COUNT to count all actions (both \\'confirmed\\' and \\'timeout\\') for each user.\\n     - You calculate the confirmation rate by dividing the count of \\'confirmed\\' actions by the total count of actions. The `IFNULL` function handles the case where a user didn\\'t have any actions, setting their rate to 0.\\n\\n3. **Left Join (T1 LEFT JOIN T2):**\\n   - You perform a LEFT JOIN between the Signups table (`T1`) and the subquery result (`T2`) using the `USER_ID` column as the joining condition.\\n   - This LEFT JOIN ensures that all users from the Signups table are included in the result, even if they didn\\'t have any confirmation actions in the Confirmations table.\\n\\n4. **Rounding and Handling NULLs:**\\n   - The `ROUND` function rounds the `CONFIRMATION_RATE` to two decimal places.\\n   - The `IFNULL` function ensures that users who didn\\'t have any confirmation actions (resulting in NULL in the subquery) have their `CONFIRMATION_RATE` set to 0 in the final result.\\n\\nOverall, your SQL code is well-structured and efficiently calculates the confirmation rate for each user, rounding it to two decimal places, and handling cases where users had no confirmation actions. It produces a result that meets the requirements of the problem statement.\\n\\n# Approach\\n1. **Main Query Structure:**\\n   - Your main query begins with a SELECT statement to specify the columns you want in the result.\\n   - You\\'re selecting `T1.USER_ID` from the Signups table and a calculated value `IFNULL(ROUND(T2.CONFIRMATION_RATE, 2), 0)` as `CONFIRMATION_RATE`.\\n\\n2. **Subquery for Confirmation Rates (T2):**\\n   - Inside the subquery:\\n     - You calculate the confirmation rate for each user in the Confirmations table.\\n     - The subquery groups the data by `USER_ID`, creating a separate calculation for each user.\\n     - You use a conditional SUM to count the number of \\'confirmed\\' actions for each user.\\n     - You use COUNT to count all actions (both \\'confirmed\\' and \\'timeout\\') for each user.\\n     - You calculate the confirmation rate by dividing the count of \\'confirmed\\' actions by the total count of actions.\\n     - The `IFNULL` function handles cases where a user didn\\'t have any actions, setting their rate to 0.\\n\\n3. **Left Join (T1 LEFT JOIN T2):**\\n   - You perform a LEFT JOIN operation between the Signups table (`T1`) and the subquery result (`T2`) using the `USER_ID` column as the joining condition.\\n   - This LEFT JOIN ensures that all users from the Signups table are included in the result, even if they didn\\'t have any confirmation actions in the Confirmations table.\\n\\n4. **Rounding and Handling NULLs:**\\n   - In the SELECT statement, you apply the `ROUND` function to round the `CONFIRMATION_RATE` to two decimal places.\\n   - The `IFNULL` function is used to handle cases where users had no confirmation actions in the subquery, which would result in NULL values. In such cases, their `CONFIRMATION_RATE` is set to 0 in the final result.\\n\\nThis approach efficiently calculates the confirmation rate for each user, rounds it to two decimal places, and ensures that users without any confirmation actions are considered with a confirmation rate of 0. The query structure is well-organized and meets the requirements of the problem statement.\\n\\n# Complexity\\nThe complexity of your SQL query can be analyzed in terms of time and space complexity:\\n\\n1. **Time Complexity**:\\n\\n   - **Subquery**: The subquery calculates the confirmation rate for each user by grouping and aggregating data from the Confirmations table. The time complexity of this subquery is O(N), where N is the number of rows in the Confirmations table.\\n\\n   - **Join Operation**: The LEFT JOIN operation between the Signups table and the subquery result also has a time complexity of O(N), where N is the number of rows in the Signups table.\\n\\n   - **Overall Time Complexity**: The overall time complexity of your query is primarily determined by the subquery and the join operation. It is O(N) in the worst case, where N is the number of rows in the larger of the two tables (Confirmations or Signups).\\n\\n2. **Space Complexity**:\\n\\n   - **Subquery Result**: The subquery result includes the calculated confirmation rates for each user. The space complexity of storing this result is also O(N), where N is the number of distinct users.\\n\\n   - **Final Result**: The final result of your query consists of the user IDs and their corresponding confirmation rates, which is also O(N) in terms of space complexity.\\n\\nIn summary, your SQL query has a time complexity of O(N) and a space complexity of O(N), where N represents the number of distinct users in the dataset. The query efficiently processes the data to calculate the confirmation rates while using memory proportional to the number of distinct users.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT T1.USER_ID, IFNULL(ROUND(T2.CONFIRMATION_RATE,2), 0) AS CONFIRMATION_RATE\\nFROM\\n  SIGNUPS T1 LEFT JOIN (\\n              SELECT\\n                USER_ID,\\n                IFNULL(SUM(CASE WHEN ACTION=\\'CONFIRMED\\' THEN 1 ELSE 0 END) / COUNT(USER_ID), 0) AS CONFIRMATION_RATE\\n              FROM\\n                CONFIRMATIONS\\n              GROUP BY\\n                USER_ID\\n  )T2\\n  USING(USER_ID)\\n;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT T1.USER_ID, IFNULL(ROUND(T2.CONFIRMATION_RATE,2), 0) AS CONFIRMATION_RATE\\nFROM\\n  SIGNUPS T1 LEFT JOIN (\\n              SELECT\\n                USER_ID,\\n                IFNULL(SUM(CASE WHEN ACTION=\\'CONFIRMED\\' THEN 1 ELSE 0 END) / COUNT(USER_ID), 0) AS CONFIRMATION_RATE\\n              FROM\\n                CONFIRMATIONS\\n              GROUP BY\\n                USER_ID\\n  )T2\\n  USING(USER_ID)\\n;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035082,
                "title": "99-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT\\n    s.user_id, ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/(COUNT(*)),2) AS confirmation_rate\\nFROM\\n    Signups s LEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    s.user_id, ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/(COUNT(*)),2) AS confirmation_rate\\nFROM\\n    Signups s LEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035075,
                "title": "using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s \\nleft join Confirmations as c \\non s.user_id= c.user_id \\ngroup by user_id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s \\nleft join Confirmations as c \\non s.user_id= c.user_id \\ngroup by user_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035000,
                "title": "this-is-the-correct-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nSELECT Table1.USER_ID,\\nROUND(AVG(CASE WHEN Table2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS Table1\\nleft JOIN\\nCONFIRMATIONS Table2\\nON Table1.USER_ID = Table2.USER_ID\\nGROUP BY Table1.USER_ID;\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n\\nSELECT Table1.USER_ID,\\nROUND(AVG(CASE WHEN Table2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS Table1\\nleft JOIN\\nCONFIRMATIONS Table2\\nON Table1.USER_ID = Table2.USER_ID\\nGROUP BY Table1.USER_ID;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034999,
                "title": "this-is-the-correct-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nSELECT Table1.USER_ID,\\nROUND(AVG(CASE WHEN Table2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS Table1\\nleft JOIN\\nCONFIRMATIONS Table2\\nON Table1.USER_ID = Table2.USER_ID\\nGROUP BY Table1.USER_ID;\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n\\nSELECT Table1.USER_ID,\\nROUND(AVG(CASE WHEN Table2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS Table1\\nleft JOIN\\nCONFIRMATIONS Table2\\nON Table1.USER_ID = Table2.USER_ID\\nGROUP BY Table1.USER_ID;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034403,
                "title": "mysql",
                "content": "\\n\\n# Code\\n```\\nSELECT S.USER_ID, \\nIFNULL(ROUND(( (SELECT COUNT(*) FROM CONFIRMATIONS C2 WHERE C2.USER_ID = S.USER_ID AND C2.ACTION = \\'CONFIRMED\\') / (SELECT COUNT(*) FROM CONFIRMATIONS C2 WHERE C2.USER_ID = S.USER_ID) ), 2), 0) AS CONFIRMATION_RATE\\nFROM SIGNUPS S LEFT OUTER JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\nGROUP BY S.USER_ID; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT S.USER_ID, \\nIFNULL(ROUND(( (SELECT COUNT(*) FROM CONFIRMATIONS C2 WHERE C2.USER_ID = S.USER_ID AND C2.ACTION = \\'CONFIRMED\\') / (SELECT COUNT(*) FROM CONFIRMATIONS C2 WHERE C2.USER_ID = S.USER_ID) ), 2), 0) AS CONFIRMATION_RATE\\nFROM SIGNUPS S LEFT OUTER JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\nGROUP BY S.USER_ID; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034088,
                "title": "confirmation-rate",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030953,
                "title": "ms-pl-and-my-sql-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet Average and round it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEach Language has its own way of `if`, `iif`, but `CASE WHEN` works for all them\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nYou can use first code example for any provided SQL lang.\\nthe second and third ones are for `MySQL` and `T-SQL`\\n``` SQL []\\n/* Write your PL/SQL query statement below */\\nSELECT\\n  s.user_id,\\n  round(avg(\\n    CASE\\n      WHEN action=\\'confirmed\\' THEN 1\\n      ELSE 0.0\\n    END), 2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```\\n``` SQL []\\n# Write your MySQL query statement below\\nSELECT\\n  s.user_id,\\n  round(avg(if(c.action=\"confirmed\",1,0)),2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```\\n``` SQL []\\n/* Write your T-SQL query statement below */\\nSELECT\\n  s.user_id,\\n  round(avg(iif(c.action=\\'confirmed\\', 1, 0.0)), 2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "``` SQL []\\n/* Write your PL/SQL query statement below */\\nSELECT\\n  s.user_id,\\n  round(avg(\\n    CASE\\n      WHEN action=\\'confirmed\\' THEN 1\\n      ELSE 0.0\\n    END), 2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```\n``` SQL []\\n# Write your MySQL query statement below\\nSELECT\\n  s.user_id,\\n  round(avg(if(c.action=\"confirmed\",1,0)),2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```\n``` SQL []\\n/* Write your T-SQL query statement below */\\nSELECT\\n  s.user_id,\\n  round(avg(iif(c.action=\\'confirmed\\', 1, 0.0)), 2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030485,
                "title": "easy-solution-brute-force",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT s.user_id, \\n    ROUND(\\n        IFNULL(\\n        (SELECT COUNT(IF(action=\"confirmed\", 1, NULL))/COUNT(*) FROM confirmations WHERE user_id = s.user_id),\\n             0),\\n         2) \\n    as confirmation_rate \\nFROM signups s;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT s.user_id, \\n    ROUND(\\n        IFNULL(\\n        (SELECT COUNT(IF(action=\"confirmed\", 1, NULL))/COUNT(*) FROM confirmations WHERE user_id = s.user_id),\\n             0),\\n         2) \\n    as confirmation_rate \\nFROM signups s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028609,
                "title": "confirmation-rate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect distinct\\n    s.user_id,\\n    round(\\n    coalesce(\\n    coalesce(\\n    (\\n        select\\n            count(c1.user_id)\\n        from\\n            confirmations c1\\n        where\\n            c1.action in (\\'confirmed\\') and\\n            c1.user_id = c.user_id\\n    ),0) /\\n    coalesce(\\n    (\\n        select\\n            count(c1.user_id)\\n        from\\n            confirmations c1\\n        where\\n            c1.user_id = c.user_id\\n    ),0),0),2) as confirmation_rate\\nfrom\\n    signups s left join\\n    confirmations c \\n    on s.user_id = c.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect distinct\\n    s.user_id,\\n    round(\\n    coalesce(\\n    coalesce(\\n    (\\n        select\\n            count(c1.user_id)\\n        from\\n            confirmations c1\\n        where\\n            c1.action in (\\'confirmed\\') and\\n            c1.user_id = c.user_id\\n    ),0) /\\n    coalesce(\\n    (\\n        select\\n            count(c1.user_id)\\n        from\\n            confirmations c1\\n        where\\n            c1.user_id = c.user_id\\n    ),0),0),2) as confirmation_rate\\nfrom\\n    signups s left join\\n    confirmations c \\n    on s.user_id = c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028581,
                "title": "beats-68-73-of-users-with-ms-sql-server",
                "content": "# Intuition\\nTo divide each result set into smaller tables and then join them together to get the final result.\\n\\n# Approach\\n1. create a table with alias \\'a\\' from confirmations where action = \\'confirmed\\' with column as confirmed_action_count\\n2. create a table with alias \\'b\\' from confirmations with column as action_count where there is no where clause\\n3. inner join tables \\'a\\' and \\'b\\' to create a table \\'c\\' by now you will have columns user_id, confirmed_action_count, action_count under table called \\'c\\'\\n4. create a table with alias \\'d\\' from signups do a left join with the \\'c\\' table and calculate the confirmation_rate as per the provided logic. I\\'ve used cast function to convert the columns to float to get the decimal values, the isnull function is to convert the null from left join to 0. And, round function is to round the final result upto 2 decimals.\\n\\nPls up vote if this logic helped you understand the problem in a easier way.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect d.user_id, \\nround(isnull(cast(confirmed_action_count as float) / cast(action_count as float),0),2) confirmation_rate\\nfrom signups d\\nleft join\\n(select a.user_id, confirmed_action_count, action_count\\nfrom \\n(select user_id,count(*) confirmed_action_count\\nfrom confirmations\\nwhere action = \\'confirmed\\'\\ngroup by user_id\\n) a\\njoin \\n(select user_id,count(*) action_count\\nfrom confirmations\\ngroup by user_id\\n) b\\non a.user_id = b.user_id) c\\non d.user_id = c.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect d.user_id, \\nround(isnull(cast(confirmed_action_count as float) / cast(action_count as float),0),2) confirmation_rate\\nfrom signups d\\nleft join\\n(select a.user_id, confirmed_action_count, action_count\\nfrom \\n(select user_id,count(*) confirmed_action_count\\nfrom confirmations\\nwhere action = \\'confirmed\\'\\ngroup by user_id\\n) a\\njoin \\n(select user_id,count(*) action_count\\nfrom confirmations\\ngroup by user_id\\n) b\\non a.user_id = b.user_id) c\\non d.user_id = c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024558,
                "title": "using-cte-and-case-function-beats-92-34-of-users-with-mysql",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith base as (\\nselect s.user_id,s.time_stamp as signup_time,c.time_stamp as confirmation_time, c.action,\\ncase when c.action = \\'confirmed\\' then 1 else 0 end as is_confirmed,\\n1 as requests\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id)\\n\\nselect user_id, round(sum(is_confirmed)/sum(requests),2) as confirmation_rate\\nfrom base \\ngroup by 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith base as (\\nselect s.user_id,s.time_stamp as signup_time,c.time_stamp as confirmation_time, c.action,\\ncase when c.action = \\'confirmed\\' then 1 else 0 end as is_confirmed,\\n1 as requests\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id)\\n\\nselect user_id, round(sum(is_confirmed)/sum(requests),2) as confirmation_rate\\nfrom base \\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023946,
                "title": "with-left-join-group-by-easy-solution-beats-92",
                "content": "\\n# Approach\\nFirst, perform left join Signups with Confirmations table and group by user_id to calculate average of action=\\'confirmed\\', round up to 2 decimal places.\\n\\nYou need to write ifnull condition to handle null values.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(ifnull(avg(c.action=\\'confirmed\\'), 0), 2) as confirmation_rate \\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(ifnull(avg(c.action=\\'confirmed\\'), 0), 2) as confirmation_rate \\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022833,
                "title": "using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id,round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate from Signups as s \\nleft join Confirmations as c\\non s.user_id = c.user_id\\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id,round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate from Signups as s \\nleft join Confirmations as c\\non s.user_id = c.user_id\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021922,
                "title": "cte-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nwith cte1 as (SELECT user_id,\\ncount(*) as a\\nfrom confirmations\\ngroup by user_id),\\ncte as( select user_id, count(action) as b\\nfrom confirmations\\nwhere action like \\'confirmed\\' \\ngroup by user_id ),\\ncte2 as (Select a.user_id, isnull(a,0) as a, isnull(b,0) as b\\nfrom Signups as a\\nLeft join cte1 as b \\non a.user_id = b.user_id\\nleft join cte as c\\non a.user_id = c.user_id)\\n\\nselect user_id, case \\nwhen  a = 0 then 0\\nelse round(b*1.00/a,2) \\nend as confirmation_rate\\nfrom cte2 \\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith cte1 as (SELECT user_id,\\ncount(*) as a\\nfrom confirmations\\ngroup by user_id),\\ncte as( select user_id, count(action) as b\\nfrom confirmations\\nwhere action like \\'confirmed\\' \\ngroup by user_id ),\\ncte2 as (Select a.user_id, isnull(a,0) as a, isnull(b,0) as b\\nfrom Signups as a\\nLeft join cte1 as b \\non a.user_id = b.user_id\\nleft join cte as c\\non a.user_id = c.user_id)\\n\\nselect user_id, case \\nwhen  a = 0 then 0\\nelse round(b*1.00/a,2) \\nend as confirmation_rate\\nfrom cte2 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020797,
                "title": "mysql-solution-beats-99-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate total transactions and count where transactions were confirmed. The ratio is confirmation rate\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLinear\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith main as\\n(\\nselect \\n    s.user_id\\n    ,count(distinct c.time_stamp) as tot_txns\\n    ,count(case when c.action = \\'confirmed\\' then 1 else null end) as confirmed_txns\\nfrom    \\n    Signups s\\nleft join \\n    Confirmations c\\non  s.user_id = c.user_id    \\ngroup by\\n    s.user_id\\n)\\n\\nselect\\n    user_id\\n    ,case when confirmed_txns = 0 then 0 else round(confirmed_txns / tot_txns,2) end as confirmation_rate \\nfrom main\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith main as\\n(\\nselect \\n    s.user_id\\n    ,count(distinct c.time_stamp) as tot_txns\\n    ,count(case when c.action = \\'confirmed\\' then 1 else null end) as confirmed_txns\\nfrom    \\n    Signups s\\nleft join \\n    Confirmations c\\non  s.user_id = c.user_id    \\ngroup by\\n    s.user_id\\n)\\n\\nselect\\n    user_id\\n    ,case when confirmed_txns = 0 then 0 else round(confirmed_txns / tot_txns,2) end as confirmation_rate \\nfrom main\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018683,
                "title": "easy-solution-using-left-join-and-case-expression",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id, ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(*), 2) confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id, ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(*), 2) confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016756,
                "title": "confirmation-rate-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect s.user_id,round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate from Signups as s left join confirmations as c on s.user_id = c.user_id group by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect s.user_id,round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate from Signups as s left join confirmations as c on s.user_id = c.user_id group by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016416,
                "title": "surprisingly-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thoughts is just following the logic from task descriptions\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThat is: SUM of \\'confirmed\\' divided by COUNT of actions, using ROUND to get formatted decimal points, and COALESCE for \\'null\\' to 0.\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect \\n  s.user_id, \\n  coalesce(\\n    round(sum(c.action=\\'confirmed\\')/count(c.action), 2), 0\\n  ) as confirmation_rate\\nfrom signups s \\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n  s.user_id, \\n  coalesce(\\n    round(sum(c.action=\\'confirmed\\')/count(c.action), 2), 0\\n  ) as confirmation_rate\\nfrom signups s \\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013994,
                "title": "super-simplified-using-subquery-and-left-join-ms-sql-server",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT s.user_id, \\nROUND(ISNULL(c.confirmation_rate, 0), 2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN  (\\n                SELECT \\n                user_id, \\n                AVG(\\n                    CASE \\n                        WHEN action = \\'confirmed\\' THEN 1.00\\n                        ELSE 0.00\\n                    END\\n                    ) as confirmation_rate\\n                FROM Confirmations\\n                GROUP BY user_id\\n            ) c\\nON s.user_id = c.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT s.user_id, \\nROUND(ISNULL(c.confirmation_rate, 0), 2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN  (\\n                SELECT \\n                user_id, \\n                AVG(\\n                    CASE \\n                        WHEN action = \\'confirmed\\' THEN 1.00\\n                        ELSE 0.00\\n                    END\\n                    ) as confirmation_rate\\n                FROM Confirmations\\n                GROUP BY user_id\\n            ) c\\nON s.user_id = c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013815,
                "title": "naive-solution-without-using-case-when",
                "content": "# Intuition\\nFind confirmed in a table, find total in other table, join and find ratio of two.\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nselect x.user_id, round(confirm/total,2) confirmation_rate from (select s.user_id, count(*) total from\\nsignups s left join confirmations c on s.user_id = c.user_id group by s.user_id) x\\njoin\\n(select s.user_id, count(c.user_id) confirm from signups s left join (select * from confirmations where action = \\'confirmed\\') c on s.user_id = c.user_id group by s.user_id) y on x.user_id = y.user_id;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nselect x.user_id, round(confirm/total,2) confirmation_rate from (select s.user_id, count(*) total from\\nsignups s left join confirmations c on s.user_id = c.user_id group by s.user_id) x\\njoin\\n(select s.user_id, count(c.user_id) confirm from signups s left join (select * from confirmations where action = \\'confirmed\\') c on s.user_id = c.user_id group by s.user_id) y on x.user_id = y.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013747,
                "title": "turn-2-string-conditions-into-0-1-and-use-avg-to-calculate-the-rate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n(select user_id, 0 as confirmation_rate from Signups\\nwhere user_id not in(select distinct user_id from Confirmations))\\nunion\\n(select user_id, round(AVG(num),2) as confirmation_rate\\nfrom (select user_id,\\ncase when action=\\'timeout\\' then 0 else 1 end as num\\nfrom Confirmations) as temp\\ngroup by user_id)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n(select user_id, 0 as confirmation_rate from Signups\\nwhere user_id not in(select distinct user_id from Confirmations))\\nunion\\n(select user_id, round(AVG(num),2) as confirmation_rate\\nfrom (select user_id,\\ncase when action=\\'timeout\\' then 0 else 1 end as num\\nfrom Confirmations) as temp\\ngroup by user_id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013312,
                "title": "first-post",
                "content": "# Intuition\\n1. Problem is really simple we simply need to find out the mean confirmed actions, we can use AVG() function.\\n2. Then if we need to find out about each user_id we use group by\\n3. And finally we need to include every user_id irrespective of submitting any request or not so we will do left join on SIGNUPS to include every user_id.\\n\\n# Approach\\nApproach 1:\\n1. First I started by simple select user_id, then we use a IF(condition,if_true then this value,if_false then this value) -> to return 1 for confirmed and 0 for everything else simple.\\n2. Then we input all this into an AVG() function and apply left join on SIGNUPS table so that each and every user_id is include in the result set irrespective of if it has submitted a confirmation request or not. \\n3. Then we go back to the select statement and there specify which user_id we need to use, if we use confiramtion\\'s c.user_id then only the user id which submitted a request will appear in the result set and it will exclude user_id = 6 because it never submitted a confirmation request but we are specified to return a 0 for a user_id which didn\\'t send a confirmation request so we\\'ll use SIGNUPS s.user_id it will include all the userids \\n4. Finally we will group by the same user_id and we\\'ll get the result.  \\n\\nApproach 2:\\n1. We can do the same by using CASE,SUM,COUNT; if someone is not familiar with the IF() function. Q U E R Y -> SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*)\\n2. Logic is the same here, only different functions are used.\\n# Complexity\\nTo be honest I don\\'t really have any knowledge about time and complexitiy :), but i do try to optimize my queries wherever i can. \\n\\n# Code\\n```\\nApproach 1:\\nselect s.user_id, \\nround(avg(if(c.action = \\'confirmed\\',1,0)),2) as confirmation_rate\\nfrom Signups s left join Confirmations c \\non s.user_id = c.user_id \\ngroup by s.user_id\\n```\\n```\\nApproach 2:\\nselect s.user_id, sum(case when c.action = \\'confirmed\\' then 1 else 0 end)/count(*) as confirmation_rate\\nfrom Signups s left join Confirmations c \\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nApproach 1:\\nselect s.user_id, \\nround(avg(if(c.action = \\'confirmed\\',1,0)),2) as confirmation_rate\\nfrom Signups s left join Confirmations c \\non s.user_id = c.user_id \\ngroup by s.user_id\\n```\n```\\nApproach 2:\\nselect s.user_id, sum(case when c.action = \\'confirmed\\' then 1 else 0 end)/count(*) as confirmation_rate\\nfrom Signups s left join Confirmations c \\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013229,
                "title": "simple-2-liner-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012109,
                "title": "easy-solution-no-cte",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id, \\n    COALESCE(ROUND(sum(if(c.action=\\'confirmed\\',1,0))/count(c.user_id),2),0) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\n    USING (user_id)\\nGROUP BY s.user_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id, \\n    COALESCE(ROUND(sum(if(c.action=\\'confirmed\\',1,0))/count(c.user_id),2),0) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\n    USING (user_id)\\nGROUP BY s.user_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012099,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPlease Upvote if this solution seemed helpful.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as (Select user_id, count(*) as confirmed_action\\nfrom confirmations\\nwhere action =\\'confirmed\\'\\ngroup by user_id),\\n\\ncte2 as\\n(Select user_id, count(*) as total_action\\nfrom confirmations\\ngroup by user_id)\\n\\nSelect s.user_id, round(coalesce (c.confirmed_action/c2.total_action,0),2) as confirmation_rate\\nfrom signups as s left join cte as c \\non s.user_id = c.user_id left join cte2 as c2\\non c.user_id = c2.user_id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as (Select user_id, count(*) as confirmed_action\\nfrom confirmations\\nwhere action =\\'confirmed\\'\\ngroup by user_id),\\n\\ncte2 as\\n(Select user_id, count(*) as total_action\\nfrom confirmations\\ngroup by user_id)\\n\\nSelect s.user_id, round(coalesce (c.confirmed_action/c2.total_action,0),2) as confirmation_rate\\nfrom signups as s left join cte as c \\non s.user_id = c.user_id left join cte2 as c2\\non c.user_id = c2.user_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009066,
                "title": "ms-sql-server-solution-should-work-in-any-other-sql-db-engine",
                "content": "# Intuition\\nCreate a total_count and a count_of_confirmed. Return the \\ncount_of_confirmed divided by total_count\\n\\n# Approach\\nI did it as I described before, only had to check on how to do a floating point division that also only had 2 decimal places.\\n\\n\\n# Code\\n```\\nWITH val AS\\n(\\n SELECT s.user_id \\n        , count(CASE WHEN c.action=\\'confirmed\\' THEN c.action ELSE NULL END) AS count_confirmed\\n        , count(c.action) AS count_all\\n FROM signups s\\n LEFT JOIN confirmations c ON s.user_id = c.user_id\\n GROUP BY s.user_id\\n)\\nSELECT user_id\\n     , CASE WHEN count_confirmed = 0 THEN 0\\n       ELSE CAST(CAST(count_confirmed AS NUMERIC) / count_all AS NUMERIC(10,2))\\n       END AS confirmation_rate\\n FROM val;\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nWITH val AS\\n(\\n SELECT s.user_id \\n        , count(CASE WHEN c.action=\\'confirmed\\' THEN c.action ELSE NULL END) AS count_confirmed\\n        , count(c.action) AS count_all\\n FROM signups s\\n LEFT JOIN confirmations c ON s.user_id = c.user_id\\n GROUP BY s.user_id\\n)\\nSELECT user_id\\n     , CASE WHEN count_confirmed = 0 THEN 0\\n       ELSE CAST(CAST(count_confirmed AS NUMERIC) / count_all AS NUMERIC(10,2))\\n       END AS confirmation_rate\\n FROM val;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007503,
                "title": "simple-solution-with-and-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncalculate confirmation rate for all users and merge with users who signup.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith q as (\\nselect user_id, round(sum(IF(action=\\'confirmed\\', 1, 0)) / count(user_id), 2) confirmation_rate\\nfrom confirmations a\\ngroup by user_id\\n),\\nw as (\\n  select distinct user_id\\n  from signups\\n)\\nselect user_id, ifnull(confirmation_rate, 0) confirmation_rate from w\\nleft join q\\nusing(user_id)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith q as (\\nselect user_id, round(sum(IF(action=\\'confirmed\\', 1, 0)) / count(user_id), 2) confirmation_rate\\nfrom confirmations a\\ngroup by user_id\\n),\\nw as (\\n  select distinct user_id\\n  from signups\\n)\\nselect user_id, ifnull(confirmation_rate, 0) confirmation_rate from w\\nleft join q\\nusing(user_id)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007434,
                "title": "mysql-detailed-explaination-easy",
                "content": "## Intuition\\nTo calculate the confirmation rate for each user, we need to consider the \\'confirmed\\' and \\'timeout\\' actions for each user in the \"Confirmations\" table. We can achieve this by joining the \"Signups\" and \"Confirmations\" tables and then calculating the ratio of \\'confirmed\\' actions to the total number of actions for each user.\\n\\n## Approach\\n```sql\\n-- Write your MySQL query statement below\\nselect s.user_id , round(ifnull(count(case when action = \\'confirmed\\' then 1 else NULL end) / count(action), 0), 2) as confirmation_rate\\nfrom Signups as s \\nleft join Confirmations as c \\non s.user_id = c.user_id \\ngroup by s.user_id;\\n```\\n\\n## Query Explanation\\nWe start by performing a `LEFT JOIN` between the \"Signups\" and \"Confirmations\" tables, using the \"user_id\" column as the join condition. This join combines each user\\'s sign-up information with their confirmation records (if any). \\n\\nNext, we use conditional aggregation to count the number of \\'confirmed\\' actions for each user (`count(case when action = \\'confirmed\\' then 1 else NULL end)`) and the total number of actions (`count(action)`). We then calculate the confirmation rate by dividing the count of \\'confirmed\\' actions by the total count of actions for each user. We use the `ROUND` function to round the result to two decimal places.\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\n-- Write your MySQL query statement below\\nselect s.user_id , round(ifnull(count(case when action = \\'confirmed\\' then 1 else NULL end) / count(action), 0), 2) as confirmation_rate\\nfrom Signups as s \\nleft join Confirmations as c \\non s.user_id = c.user_id \\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006699,
                "title": "ms-sql-server-solution",
                "content": "\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT A.user_id, ROUND((SELECT COUNT(C.user_id) FROM Confirmations C WHERE C.action = \\'confirmed\\' AND  C.user_id = A.user_id)*1.0/COUNT(A.user_id),2) AS confirmation_rate\\nFROM Signups A\\nLEFT JOIN Confirmations B\\nON A.user_id = B.user_id\\nGROUP BY A.user_id ORDER BY confirmation_rate\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT A.user_id, ROUND((SELECT COUNT(C.user_id) FROM Confirmations C WHERE C.action = \\'confirmed\\' AND  C.user_id = A.user_id)*1.0/COUNT(A.user_id),2) AS confirmation_rate\\nFROM Signups A\\nLEFT JOIN Confirmations B\\nON A.user_id = B.user_id\\nGROUP BY A.user_id ORDER BY confirmation_rate\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000002,
                "title": "attention-here-different-from-others-solution-using-ifnull-round-and-sum",
                "content": "PLEASE UPVOTE IF MY SOLUTION IS HELPFUL \\n\\n# Code\\n```\\nselect s.user_id , ifnull(round(sum(action = \\'confirmed\\')/count(*),2), 0.00) as confirmation_rate\\nfrom Signups s \\nleft join Confirmations c on s.user_id = c.user_id \\ngroup by s.user_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id , ifnull(round(sum(action = \\'confirmed\\')/count(*),2), 0.00) as confirmation_rate\\nfrom Signups s \\nleft join Confirmations c on s.user_id = c.user_id \\ngroup by s.user_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998483,
                "title": "best-solution-using-window-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSelect user_id , \\nRound(IFNULL(confirmed/total,0),2) as confirmation_rate\\nfrom (\\nSelect s.user_id,\\nsum(case when action = \\'confirmed\\' then 1  else 0 end) as confirmed,\\ncount(action) as total\\nfrom signups s\\nleft outer join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n) a  group by 1\\norder by confirmation_rate\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect user_id , \\nRound(IFNULL(confirmed/total,0),2) as confirmation_rate\\nfrom (\\nSelect s.user_id,\\nsum(case when action = \\'confirmed\\' then 1  else 0 end) as confirmed,\\ncount(action) as total\\nfrom signups s\\nleft outer join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n) a  group by 1\\norder by confirmation_rate\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998431,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSelect user_id , \\nRound(IFNULL(confirmed/total,0),2) as confirmation_rate\\nfrom (\\nSelect s.user_id,\\nsum(case when action = \\'confirmed\\' then 1  else 0 end) as confirmed,\\ncount(action) as total\\nfrom signups s\\nleft outer join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n) a\\norder by confirmation_rate\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect user_id , \\nRound(IFNULL(confirmed/total,0),2) as confirmation_rate\\nfrom (\\nSelect s.user_id,\\nsum(case when action = \\'confirmed\\' then 1  else 0 end) as confirmed,\\ncount(action) as total\\nfrom signups s\\nleft outer join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n) a\\norder by confirmation_rate\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996504,
                "title": "beats-97-using-ctes-and-flag",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n--main cte joins both table to ge user_id, actinon and flagged action to check if confirmed\\nwith main as(\\n  select \\n    a.user_id,\\n    b.action,\\n    case \\n      when action=\\'confirmed\\' then 1\\n      else 0\\n    end as action_flag\\n  from signups a\\n  left join confirmations b\\n  on a.user_id=b.user_id\\n),\\n--t_cnt cte counts the total count of action by each user\\nt_cnt as(\\nselect \\n  a.user_id,\\n  count(b.action) total_action_cnt\\nfrom signups a\\nleft join confirmations b \\non a.user_id=b.user_id \\ngroup by a.user_id)\\n\\n--just calculating rest needed.\\nselect \\n  m.user_id,\\n  case when t.total_action_cnt <> 0 then round(cast(sum(m.action_flag) as float)/t.total_action_cnt,2) \\n  else 0 end as confirmation_rate\\nfrom main m\\ninner join t_cnt t\\non m.user_id=t.user_id\\ngroup by m.user_id,t.total_action_cnt;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n--main cte joins both table to ge user_id, actinon and flagged action to check if confirmed\\nwith main as(\\n  select \\n    a.user_id,\\n    b.action,\\n    case \\n      when action=\\'confirmed\\' then 1\\n      else 0\\n    end as action_flag\\n  from signups a\\n  left join confirmations b\\n  on a.user_id=b.user_id\\n),\\n--t_cnt cte counts the total count of action by each user\\nt_cnt as(\\nselect \\n  a.user_id,\\n  count(b.action) total_action_cnt\\nfrom signups a\\nleft join confirmations b \\non a.user_id=b.user_id \\ngroup by a.user_id)\\n\\n--just calculating rest needed.\\nselect \\n  m.user_id,\\n  case when t.total_action_cnt <> 0 then round(cast(sum(m.action_flag) as float)/t.total_action_cnt,2) \\n  else 0 end as confirmation_rate\\nfrom main m\\ninner join t_cnt t\\non m.user_id=t.user_id\\ngroup by m.user_id,t.total_action_cnt;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996498,
                "title": "solution-using-round-count-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT cts.user_id,ROUND(COUNT (CASE WHEN cts.action=\\'confirmed\\' THEN 1 ELSE NULL END)/CAST(COUNT(cts.user_id) AS DECIMAL(10,2)) ,2)AS confirmation_rate   \\nFROM (select s.user_id,c.action  FROM Signups s LEFT JOIN Confirmations c ON s.user_id=c.user_id) AS cts \\nGROUP BY cts.user_id;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT cts.user_id,ROUND(COUNT (CASE WHEN cts.action=\\'confirmed\\' THEN 1 ELSE NULL END)/CAST(COUNT(cts.user_id) AS DECIMAL(10,2)) ,2)AS confirmation_rate   \\nFROM (select s.user_id,c.action  FROM Signups s LEFT JOIN Confirmations c ON s.user_id=c.user_id) AS cts \\nGROUP BY cts.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3995357,
                "title": "easy-mysql-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\n\\nSELECT s_up.user_id , \\nROUND(SUM(CASE\\n   WHEN action = \"confirmed\" THEN 1\\n   ELSE 0\\nEND)/ COUNT(s_up.user_id ),2) AS confirmation_rate\\nFROM Signups s_up\\nLEFT JOIN Confirmations conf\\nON s_up.user_id = conf.user_id\\nGROUP BY s_up.user_id \\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\n\\nSELECT s_up.user_id , \\nROUND(SUM(CASE\\n   WHEN action = \"confirmed\" THEN 1\\n   ELSE 0\\nEND)/ COUNT(s_up.user_id ),2) AS confirmation_rate\\nFROM Signups s_up\\nLEFT JOIN Confirmations conf\\nON s_up.user_id = conf.user_id\\nGROUP BY s_up.user_id \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994152,
                "title": "calculation-without-using-case-or-subqueries",
                "content": "pair in mind that \\n```\\nROUND(SUM(action = \\'confirmed\\') / COUNT(user_id), 2)\\n```\\nis the same as \\n```\\nROUND(AVG(action = \\'confirmed\\'), 2)\\n```\\n\\n# Code\\n```\\nSELECT\\n    user_id,\\n    IFNULL(\\n        ROUND(AVG(action = \\'confirmed\\'), 2)\\n    , 0) AS confirmation_rate\\nFROM\\n    Signups\\nLEFT JOIN\\n    Confirmations USING(user_id)\\nGROUP BY user_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\nROUND(SUM(action = \\'confirmed\\') / COUNT(user_id), 2)\\n```\n```\\nROUND(AVG(action = \\'confirmed\\'), 2)\\n```\n```\\nSELECT\\n    user_id,\\n    IFNULL(\\n        ROUND(AVG(action = \\'confirmed\\'), 2)\\n    , 0) AS confirmation_rate\\nFROM\\n    Signups\\nLEFT JOIN\\n    Confirmations USING(user_id)\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3993994,
                "title": "beats-100",
                "content": "# Approach\\nIn this query:\\n\\nWe use the SUM and COUNT functions to calculate the total number of confirmed messages and the total number of requested confirmation messages for each user within the JOINed data.\\n\\nWe use the CASE statement to count confirmed messages.\\n\\nTo handle cases where a user didn\\'t request any confirmation messages (denominator being 0), we use NULLIF to avoid division by zero and IFNULL to return 0 as the confirmation rate in such cases.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n       IFNULL(ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(*), 0), 2), 0) as confirmation_rate \\nFROM Signups as s\\nLEFT JOIN Confirmations as c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n       IFNULL(ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(*), 0), 2), 0) as confirmation_rate \\nFROM Signups as s\\nLEFT JOIN Confirmations as c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991966,
                "title": "using-unions-mysql",
                "content": "``` mysql\\nselect user_id, 0 as confirmation_rate from Signups where user_id not in \\n(\\n    select user_id from Confirmations\\n)\\n\\nunion\\n\\nselect user_id, round(sum(if(action=\\'confirmed\\',1,0))/count(action), 2)  as confirmation_rate from Confirmations\\ngroup by user_id;\\n\\n```",
                "solutionTags": [],
                "code": "``` mysql\\nselect user_id, 0 as confirmation_rate from Signups where user_id not in \\n(\\n    select user_id from Confirmations\\n)\\n\\nunion\\n\\nselect user_id, round(sum(if(action=\\'confirmed\\',1,0))/count(action), 2)  as confirmation_rate from Confirmations\\ngroup by user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989892,
                "title": "sql-solution",
                "content": "\\n\\n# Code\\n```\\nSELECT s.user_id, \\n    ROUND(AVG(\\n        CASE \\n            WHEN (c.action=\\'confirmed\\') THEN 1 \\n            ELSE 0 \\n        END),\\n    2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.user_id, \\n    ROUND(AVG(\\n        CASE \\n            WHEN (c.action=\\'confirmed\\') THEN 1 \\n            ELSE 0 \\n        END),\\n    2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2017044,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1883879,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1906306,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1576198,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1976268,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1969793,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2071979,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2070893,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2063275,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2057643,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2017044,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1883879,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1906306,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1576198,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1976268,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1969793,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2071979,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2070893,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2063275,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2057643,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2056306,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2053941,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2049002,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2046927,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2043773,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2042174,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2035629,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2024904,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2024269,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2021469,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2015971,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 2015052,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1993948,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1969294,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1958983,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1958503,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1931188,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1913477,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1866770,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1860583,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Words You Can Type",
        "question_content": "<p>There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.</p>\n\n<p>Given a string <code>text</code> of words separated by a single space (no leading or trailing spaces) and a string <code>brokenLetters</code> of all <strong>distinct</strong> letter keys that are broken, return <em>the <strong>number of words</strong> in</em> <code>text</code> <em>you can fully type using this keyboard</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;hello world&quot;, brokenLetters = &quot;ad&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We cannot type &quot;world&quot; because the &#39;d&#39; key is broken.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;leet code&quot;, brokenLetters = &quot;lt&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We cannot type &quot;leet&quot; because the &#39;l&#39; and &#39;t&#39; keys are broken.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;leet code&quot;, brokenLetters = &quot;e&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> We cannot type either word because the &#39;e&#39; key is broken.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= brokenLetters.length &lt;= 26</code></li>\n\t<li><code>text</code> consists of words separated by a single space without any leading or trailing spaces.</li>\n\t<li>Each word only consists of lowercase English letters.</li>\n\t<li><code>brokenLetters</code> consists of <strong>distinct</strong> lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1344926,
                "title": "hash-set-or-array",
                "content": "#### Array\\nUsing a boolean array instead of hash set. See the original hash set solution below.\\n\\n**C++**\\n```cpp\\nint canBeTypedWords(string text, string brokenLetters) {\\n    bool broken[26] = {};\\n    for (auto ch : brokenLetters)\\n        broken[ch - \\'a\\'] = true;\\n    int res = 0, cnt = 0;\\n    for (auto ch : text)\\n        if (ch == \\' \\') {\\n            res += cnt == 0;\\n            cnt = 0;\\n        }\\n        else\\n            cnt += broken[ch - \\'a\\'];\\n    return res + (cnt == 0);\\n}\\n```\\n\\n#### Hash Set\\n**C++**\\n```cpp\\nint canBeTypedWords(string text, string brokenLetters) {\\n    unordered_set<int> broken(begin(brokenLetters), end(brokenLetters));\\n    int res = 0;\\n    for (int i = 0, cnt = 0; i <= text.size(); ++i)\\n        if (i == text.size() || text[i] == \\' \\') {\\n            res += cnt == 0;\\n            cnt = 0;\\n        }\\n        else if(cnt == 0)\\n            cnt += broken.count(text[i]);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint canBeTypedWords(string text, string brokenLetters) {\\n    bool broken[26] = {};\\n    for (auto ch : brokenLetters)\\n        broken[ch - \\'a\\'] = true;\\n    int res = 0, cnt = 0;\\n    for (auto ch : text)\\n        if (ch == \\' \\') {\\n            res += cnt == 0;\\n            cnt = 0;\\n        }\\n        else\\n            cnt += broken[ch - \\'a\\'];\\n    return res + (cnt == 0);\\n}\\n```\n```cpp\\nint canBeTypedWords(string text, string brokenLetters) {\\n    unordered_set<int> broken(begin(brokenLetters), end(brokenLetters));\\n    int res = 0;\\n    for (int i = 0, cnt = 0; i <= text.size(); ++i)\\n        if (i == text.size() || text[i] == \\' \\') {\\n            res += cnt == 0;\\n            cnt = 0;\\n        }\\n        else if(cnt == 0)\\n            cnt += broken.count(text[i]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345078,
                "title": "c-self-expalanatory-o-n-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<int> ch(26,0);\\n\\t\\t// store the broken letters in ch vector\\n        for(char c: brokenLetters){\\n            ch[c-\\'a\\']=1;\\n        }\\n        int cnt=0,ans=0;\\n\\t\\t//traversing the text string\\n        for(int i=0;i<text.length();i++){\\n\\t\\t    //if char is \\' \\' means that we got a new word\\n            if(text[i]==\\' \\'){\\n\\t\\t\\t    // cnt remain 0 means that there is no broken letter in this word\\n                if(cnt==0) ans++;\\n                cnt=0; //reinitialize cnt to 0 as new word start from here\\n            }else if(ch[text[i]-\\'a\\']==1){ //if char is present in ch then just increment the cnt\\n                    cnt++;\\n            }\\n        }\\n\\t\\t//for last word in string\\n        if(cnt==0) ans++;\\n        return ans;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<int> ch(26,0);\\n\\t\\t// store the broken letters in ch vector\\n        for(char c: brokenLetters){\\n            ch[c-\\'a\\']=1;\\n        }\\n        int cnt=0,ans=0;\\n\\t\\t//traversing the text string\\n        for(int i=0;i<text.length();i++){\\n\\t\\t    //if char is \\' \\' means that we got a new word\\n            if(text[i]==\\' \\'){\\n\\t\\t\\t    // cnt remain 0 means that there is no broken letter in this word\\n                if(cnt==0) ans++;\\n                cnt=0; //reinitialize cnt to 0 as new word start from here\\n            }else if(ch[text[i]-\\'a\\']==1){ //if char is present in ch then just increment the cnt\\n                    cnt++;\\n            }\\n        }\\n\\t\\t//for last word in string\\n        if(cnt==0) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345025,
                "title": "bit-mask-o-n",
                "content": "**Approach:**\\n`mask` of a string means it will create a mask which will tell what are the characters persent in it.\\n```\\nLet\\'s say mask = xxxxx  ( binary representation, where x will be either 0 or 1 )\\n\\t\\t\\t\\t \\u2191\\u2191\\u2191\\u2191\\u2191\\n\\t\\t\\t\\t edbca\\nSo if any character will be persent, it\\'s corresponding bit will become 1 in mask.\\n\\nSay word is \"accd\" , here \\'a\\', \\'c\\', \\'d\\' characters persent so its mask will be\\n00...01101\\n\\u2191\\u2191...\\u2191\\u2191\\u2191\\u2191\\u2191\\n--...edcba\\n```\\n\\n* Create a mask of broken word\\n* Create mask of `curr` current word\\n* Whenever we encounter a space ` ` means current word is completed\\n* 1.  So compare mask of broken word and current word\\n* 2. If any word in broken word and current word is common then we can not type that word\\n* 3. So increase the count of word which can be typed only when there is no common character ``` i.e ( curr & broken) == 0```\\n* 4. Finally don\\'t forget to reset your current mask\\n\\n\\n**C++ Code**\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int mask(string s)\\n    {\\n        int ans = 0;\\n        for(int i=0;i<s.size();i++)\\n            ans = ans | (1<<(int(s[i] - \\'a\\')));\\n        return ans;\\n    }\\n    int canBeTypedWords(string text, string brokenL) {\\n        int broken = mask(brokenL);\\n        int ans = 0, curr = 0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i] == \\' \\')\\n            {\\n                if((curr & broken) == 0) ans++;\\n                curr = 0;\\n            }\\n            else\\n                curr = curr | ( 1 <<(text[i]-\\'a\\'));\\n        }\\n        if((curr & broken) == 0) ans++;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python Code**\\nThanks to @495 for python solution\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        def bitset(word):\\n            masks = [1 << (ord(x)-ord(\\'a\\')) for x in word]\\n            return functools.reduce(lambda a,b: a|b, masks, 0)\\n        \\n        brokenSet = bitset(brokenLetters)\\n        return sum(1 for word in text.split() if bitset(word) & brokenSet == 0)\\n```",
                "solutionTags": [],
                "code": "```\\nLet\\'s say mask = xxxxx  ( binary representation, where x will be either 0 or 1 )\\n\\t\\t\\t\\t \\u2191\\u2191\\u2191\\u2191\\u2191\\n\\t\\t\\t\\t edbca\\nSo if any character will be persent, it\\'s corresponding bit will become 1 in mask.\\n\\nSay word is \"accd\" , here \\'a\\', \\'c\\', \\'d\\' characters persent so its mask will be\\n00...01101\\n\\u2191\\u2191...\\u2191\\u2191\\u2191\\u2191\\u2191\\n--...edcba\\n```\n``` i.e ( curr & broken) == 0```\n```cpp\\nclass Solution {\\npublic:\\n    int mask(string s)\\n    {\\n        int ans = 0;\\n        for(int i=0;i<s.size();i++)\\n            ans = ans | (1<<(int(s[i] - \\'a\\')));\\n        return ans;\\n    }\\n    int canBeTypedWords(string text, string brokenL) {\\n        int broken = mask(brokenL);\\n        int ans = 0, curr = 0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i] == \\' \\')\\n            {\\n                if((curr & broken) == 0) ans++;\\n                curr = 0;\\n            }\\n            else\\n                curr = curr | ( 1 <<(text[i]-\\'a\\'));\\n        }\\n        if((curr & broken) == 0) ans++;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        def bitset(word):\\n            masks = [1 << (ord(x)-ord(\\'a\\')) for x in word]\\n            return functools.reduce(lambda a,b: a|b, masks, 0)\\n        \\n        brokenSet = bitset(brokenLetters)\\n        return sum(1 for word in text.split() if bitset(word) & brokenSet == 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344940,
                "title": "java-python-3-easy-code-w-brief-analysis",
                "content": "**Method 1: HashSet**\\n\\n```java\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> no = new HashSet<>();\\n        for (char c : brokenLetters.toCharArray()) {\\n            no.add(c);\\n        }\\n        int cnt = 0;\\n        outer:\\n        for (String word : text.split(\"\\\\\\\\s\")) {\\n            for (char c : word.toCharArray()) {\\n                if (no.contains(c)) {\\n                    continue outer;\\n                }\\n            }\\n            ++cnt;\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        no, cnt = set(brokenLetters), 0\\n        for word in text.split():\\n            if all(c not in no for c in word):\\n                cnt += 1\\n        return cnt\\n```\\n\\n----\\n\\n\\nCredit to **@midingoyi** for the following code:\\n\\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        \\n        def fun(s: Set) -> int:\\n            return 0 if set(brokenLetters).intersection(s) else 1\\n        \\n        word_sets = map(set, text.split())\\n        return sum((map(fun, word_sets))) \\n```\\n\\n---\\n\\n**Method 2: Bit Manipulation**\\n\\n```java\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int cnt = 0, mask = 0;\\n        for (int i = 0; i < brokenLetters.length(); ++i) {\\n            mask |= 1 << brokenLetters.charAt(i) - \\'a\\';\\n        }\\n        final int broken = mask;\\n        for (String word : text.split(\"\\\\\\\\s\")) {\\n            if (word.chars().allMatch(c -> (broken & (1 << c - \\'a\\')) == 0)) {\\n                ++cnt;\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n\\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        mask = functools.reduce(lambda x, y: x | 1 << ord(y) - ord(\\'a\\'), brokenLetters, 0)\\n        return sum(1 for word in text.split() if all(((1 << ord(c) - ord(\\'a\\')) & mask) == 0 for c in word))\\n```\\n\\n----\\n\\n**Analysis:**\\n\\nTime: `O(m * n)`, space: `O(brokenLetters)` (or `O(1)` if regard `brokenLetters` as constant), where `m` is the average size of the words, `n` is the # of words in the `text` and `brokenLetters` is the size of the brokenLetters.\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> no = new HashSet<>();\\n        for (char c : brokenLetters.toCharArray()) {\\n            no.add(c);\\n        }\\n        int cnt = 0;\\n        outer:\\n        for (String word : text.split(\"\\\\\\\\s\")) {\\n            for (char c : word.toCharArray()) {\\n                if (no.contains(c)) {\\n                    continue outer;\\n                }\\n            }\\n            ++cnt;\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        no, cnt = set(brokenLetters), 0\\n        for word in text.split():\\n            if all(c not in no for c in word):\\n                cnt += 1\\n        return cnt\\n```\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        \\n        def fun(s: Set) -> int:\\n            return 0 if set(brokenLetters).intersection(s) else 1\\n        \\n        word_sets = map(set, text.split())\\n        return sum((map(fun, word_sets))) \\n```\n```java\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int cnt = 0, mask = 0;\\n        for (int i = 0; i < brokenLetters.length(); ++i) {\\n            mask |= 1 << brokenLetters.charAt(i) - \\'a\\';\\n        }\\n        final int broken = mask;\\n        for (String word : text.split(\"\\\\\\\\s\")) {\\n            if (word.chars().allMatch(c -> (broken & (1 << c - \\'a\\')) == 0)) {\\n                ++cnt;\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        mask = functools.reduce(lambda x, y: x | 1 << ord(y) - ord(\\'a\\'), brokenLetters, 0)\\n        return sum(1 for word in text.split() if all(((1 << ord(c) - ord(\\'a\\')) & mask) == 0 for c in word))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1355349,
                "title": "easy-fast-python-solutions-2-approaches-28ms-32ms-faster-than-93",
                "content": "# Easy, Fast Python Solutions (2 Approaches - 28ms, 32ms; Faster than 93%)\\n## Approach 1 - Using Sets\\n**Runtime: 28 ms, faster than 93% of Python3 online submissions for Maximum Number of Words You Can Type.**\\n**Memory Usage: 14.4 MB**\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        length = len(text)\\n        brokenLetters = set(brokenLetters)\\n\\n        for word in text:\\n            for char in word:\\n                if char in brokenLetters:\\n                    length -= 1\\n                    break\\n\\t\\t\\t\\t\\t\\n        return length\\n```\\n\\n\\n## Approach 2 - Using Lists\\n**Runtime: 32 ms, faster than 82% of Python3 online submissions for Maximum Number of Words You Can Type.**\\n**Memory Usage: 14.4 MB**\\n\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        length = len(text)\\n        brokenLetters = list(brokenLetters)\\n\\t\\t\\n        for i in text:\\n            temp = 0\\n            for j in i:\\n                if j in brokenLetters:\\n                    temp -= 1\\n                    break\\n            if temp < 0:\\n                length -= 1\\n\\t\\t\\t\\t\\n        return length\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        length = len(text)\\n        brokenLetters = set(brokenLetters)\\n\\n        for word in text:\\n            for char in word:\\n                if char in brokenLetters:\\n                    length -= 1\\n                    break\\n\\t\\t\\t\\t\\t\\n        return length\\n```\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        length = len(text)\\n        brokenLetters = list(brokenLetters)\\n\\t\\t\\n        for i in text:\\n            temp = 0\\n            for j in i:\\n                if j in brokenLetters:\\n                    temp -= 1\\n                    break\\n            if temp < 0:\\n                length -= 1\\n\\t\\t\\t\\t\\n        return length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344961,
                "title": "simple-c-code-no-hash-no-stringstream-explained-with-intuition",
                "content": "**Intuition:**\\nThe word which is just ended, if that contains any letter of \\'brokenLetter\\' string, we do not increment the result in that case, and if it does not contain any letter of \\'brokenLetter\\' string, we increment the result.\\n```\\nint canBeTypedWords(string text, string bl) \\n{\\n\\tbool isBadWord = 0; //Initially, we assume the word can be typed, so it is not a bad word.\\n\\tint res =0; //this will store result i.e. no of words that can be typed.\\n\\tfor (int i=0; i<text.length(); i++)  //we traverse the whole text string\\n\\t{\\n\\t    //and if we find any character of brokenLetter in current word, it becomes a bad word, \\n        //so res is not updated in this case.\\n\\t\\tfor (int j=0; j<bl.length(); j++) \\n\\t\\t\\tif (text[i]==bl[j])  isBadWord = 1;\\n\\t\\t\\t\\n\\t\\t//However if we hit space or hit the end of the string\\n\\t\\tif (text[i]==\\' \\' || i==text.length()-1)\\n\\t\\t{\\n\\t\\t\\tif (isBadWord==0) res++;  //if the word just ended is not bad word, increase the result by one\\n\\t\\t\\telse isBadWord=0;  //else reset isBadWord = 0 for the next word.\\n\\t\\t}\\n\\t}\\n\\treturn res;     //return the result.\\n}\\n```\\nIf we use STL string find function:\\n```\\nint canBeTypedWords(string text, string bl) \\n{\\n\\tbool isBadWord = 0; //Initially, we assume the word can be typed, so it is not a bad word.\\n\\tint res =0; //this will store result i.e. no of words that can be typed.\\n\\tfor (int i=0; i<text.length(); i++)  //we traverse the whole text string\\n\\t{\\n\\t    //and if we find any character of brokenLetter in current word, it becomes a bad word, \\n        //so res is not updated in this case.\\n\\t\\tif(bl.find(text[i]) != string::npos) isBadWord = 1; \\n        \\n\\t\\t//However if we hit space or hit the end of the string\\n\\t\\tif (text[i]==\\' \\' || i==text.length()-1)\\n\\t\\t{\\n\\t\\t\\tif (isBadWord==0) res++;  //if the word just ended is not bad word, increase the result by one\\n\\t\\t\\telse isBadWord=0;  //else reset isBadWord = 0 for the next word.\\n\\t\\t}\\n\\t}\\n\\treturn res;     //return the result.\\n}\\n```\\n**Please Upvote if found Helpful, so that other coders can get benefit too!**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nint canBeTypedWords(string text, string bl) \\n{\\n\\tbool isBadWord = 0; //Initially, we assume the word can be typed, so it is not a bad word.\\n\\tint res =0; //this will store result i.e. no of words that can be typed.\\n\\tfor (int i=0; i<text.length(); i++)  //we traverse the whole text string\\n\\t{\\n\\t    //and if we find any character of brokenLetter in current word, it becomes a bad word, \\n        //so res is not updated in this case.\\n\\t\\tfor (int j=0; j<bl.length(); j++) \\n\\t\\t\\tif (text[i]==bl[j])  isBadWord = 1;\\n\\t\\t\\t\\n\\t\\t//However if we hit space or hit the end of the string\\n\\t\\tif (text[i]==\\' \\' || i==text.length()-1)\\n\\t\\t{\\n\\t\\t\\tif (isBadWord==0) res++;  //if the word just ended is not bad word, increase the result by one\\n\\t\\t\\telse isBadWord=0;  //else reset isBadWord = 0 for the next word.\\n\\t\\t}\\n\\t}\\n\\treturn res;     //return the result.\\n}\\n```\n```\\nint canBeTypedWords(string text, string bl) \\n{\\n\\tbool isBadWord = 0; //Initially, we assume the word can be typed, so it is not a bad word.\\n\\tint res =0; //this will store result i.e. no of words that can be typed.\\n\\tfor (int i=0; i<text.length(); i++)  //we traverse the whole text string\\n\\t{\\n\\t    //and if we find any character of brokenLetter in current word, it becomes a bad word, \\n        //so res is not updated in this case.\\n\\t\\tif(bl.find(text[i]) != string::npos) isBadWord = 1; \\n        \\n\\t\\t//However if we hit space or hit the end of the string\\n\\t\\tif (text[i]==\\' \\' || i==text.length()-1)\\n\\t\\t{\\n\\t\\t\\tif (isBadWord==0) res++;  //if the word just ended is not bad word, increase the result by one\\n\\t\\t\\telse isBadWord=0;  //else reset isBadWord = 0 for the next word.\\n\\t\\t}\\n\\t}\\n\\treturn res;     //return the result.\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345084,
                "title": "java-1-line",
                "content": "```java\\npublic int canBeTypedWords(String text, String broken) {\\n   return (int) Arrays.stream(text.split(\" \")).filter(s -> s.chars().allMatch(c -> broken.indexOf(c) == -1)).count();\\n}",
                "solutionTags": [],
                "code": "```java\\npublic int canBeTypedWords(String text, String broken) {\\n   return (int) Arrays.stream(text.split(\" \")).filter(s -> s.chars().allMatch(c -> broken.indexOf(c) == -1)).count();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1345057,
                "title": "c-stringstream-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<int> ch(26,0);\\n        //store the broken letters\\n        for(char c: brokenLetters){\\n            ch[c-\\'a\\']=1;\\n        }\\n        // breaking text into word using string stream\\n        stringstream s(text); // Used for breaking words\\n        string word; // to store individual words\\n  \\n        int count = 0,flag=0;\\n        while (s >> word){\\n            flag=0;\\n            for(char &c: word){\\n                //if the word contains a broken letter mark flag=1\\n                if(ch[c-\\'a\\']==1){\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            //if flag is 0 which means that there is no broken letter in word so increase the count\\n            if(flag==0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<int> ch(26,0);\\n        //store the broken letters\\n        for(char c: brokenLetters){\\n            ch[c-\\'a\\']=1;\\n        }\\n        // breaking text into word using string stream\\n        stringstream s(text); // Used for breaking words\\n        string word; // to store individual words\\n  \\n        int count = 0,flag=0;\\n        while (s >> word){\\n            flag=0;\\n            for(char &c: word){\\n                //if the word contains a broken letter mark flag=1\\n                if(ch[c-\\'a\\']==1){\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            //if flag is 0 which means that there is no broken letter in word so increase the count\\n            if(flag==0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353222,
                "title": "python-3-easy-1-line-using-set",
                "content": "1-line version. Count it if there is no common characters between the word and the broken letters:\\n```\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(not set(word) & set(brokenLetters) for word in text.split())\\n```\\n\\nLonger version. Equivalent to above, but may be easier to understand:\\n```\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        for word in text.split():\\n            if not set(word) & set(brokenLetters):\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(not set(word) & set(brokenLetters) for word in text.split())\\n```\n```\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        for word in text.split():\\n            if not set(word) & set(brokenLetters):\\n                res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1347370,
                "title": "c-set-commented",
                "content": "```\\n\\n    int canBeTypedWords(string text, string broken) {\\n        \\n        int n = text.length(), m = broken.length();\\n        int i = 0, j = 0;\\n        int res = 0;\\n        \\n        unordered_set<char> s;\\n        //putting broken into set for easy access\\n        for(char c : broken) s.insert(c);\\n        \\n        //looping through text\\n        while(i<n){\\n        int cnt = 0;\\n        //looping through words\\n        while(i<n && text[i]!=\\' \\'){\\n            char c = text[i];\\n            //if any character in the word is broken \\n            if(s.find(c)!=s.end())\\n                cnt++;\\n            i++;\\n        }\\n        //if no broken char found in word\\n        if(cnt==0) res++;\\n            \\n        i++;\\n        }\\n        \\n        return res;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    int canBeTypedWords(string text, string broken) {\\n        \\n        int n = text.length(), m = broken.length();\\n        int i = 0, j = 0;\\n        int res = 0;\\n        \\n        unordered_set<char> s;\\n        //putting broken into set for easy access\\n        for(char c : broken) s.insert(c);\\n        \\n        //looping through text\\n        while(i<n){\\n        int cnt = 0;\\n        //looping through words\\n        while(i<n && text[i]!=\\' \\'){\\n            char c = text[i];\\n            //if any character in the word is broken \\n            if(s.find(c)!=s.end())\\n                cnt++;\\n            i++;\\n        }\\n        //if no broken char found in word\\n        if(cnt==0) res++;\\n            \\n        i++;\\n        }\\n        \\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1346183,
                "title": "c-o-n-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        \\n        vector<int> vec(26,0);\\n        for(int i=0;i<brokenLetters.size();i++)\\n        {\\n            vec[brokenLetters[i]-\\'a\\']=1;\\n        }\\n        int count = 0;\\n        bool flag = true;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\')\\n            {\\n                if(flag==true)              // if flag=true, i.e. the word before space is not broken, so count++; \\n                    count++;\\n                \\n                flag = true;\\n            }\\n            else\\n            {\\n                if(vec[text[i]-\\'a\\']!=0)\\n                {\\n                    flag = false;           //if char found, flag = false, word cannot be counted\\n                }\\n            }\\n            \\n        }\\n        if(flag==true)           // for the last word\\n            count++;\\n        return count;\\n    }\\n};\\n```\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(1) // constant array of size 26\\n\\n\\nPlz upvote if you like it.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        \\n        vector<int> vec(26,0);\\n        for(int i=0;i<brokenLetters.size();i++)\\n        {\\n            vec[brokenLetters[i]-\\'a\\']=1;\\n        }\\n        int count = 0;\\n        bool flag = true;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\')\\n            {\\n                if(flag==true)              // if flag=true, i.e. the word before space is not broken, so count++; \\n                    count++;\\n                \\n                flag = true;\\n            }\\n            else\\n            {\\n                if(vec[text[i]-\\'a\\']!=0)\\n                {\\n                    flag = false;           //if char found, flag = false, word cannot be counted\\n                }\\n            }\\n            \\n        }\\n        if(flag==true)           // for the last word\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344880,
                "title": "easy-c-o-n-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string broken) {\\n        \\n        //store the current broken letters  in an array \\n        vector<int> freq(26,0);\\n        for(int i=0;i<broken.length();i++)\\n            freq[broken[i]-\\'a\\']++;\\n        \\n        //stores if the current word in text is broken or not\\n        bool isBroken=false;\\n        //the words which we can type\\n        int count=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==\\' \\')\\n            {\\n                //the previous can be typed\\n                if(!isBroken)\\n                    count++;\\n                isBroken=false;\\n                \\n            }\\n            else{\\n                //if the word contains a broken letter mark isBroken=true\\n                if(freq[text[i]-\\'a\\']!=0)\\n                    isBroken=true;\\n            }\\n        }\\n        //for the last word in text\\n        if(!isBroken)\\n            count++;\\n        return count;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string broken) {\\n        \\n        //store the current broken letters  in an array \\n        vector<int> freq(26,0);\\n        for(int i=0;i<broken.length();i++)\\n            freq[broken[i]-\\'a\\']++;\\n        \\n        //stores if the current word in text is broken or not\\n        bool isBroken=false;\\n        //the words which we can type\\n        int count=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==\\' \\')\\n            {\\n                //the previous can be typed\\n                if(!isBroken)\\n                    count++;\\n                isBroken=false;\\n                \\n            }\\n            else{\\n                //if the word contains a broken letter mark isBroken=true\\n                if(freq[text[i]-\\'a\\']!=0)\\n                    isBroken=true;\\n            }\\n        }\\n        //for the last word in text\\n        if(!isBroken)\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349839,
                "title": "easy-java-1ms-100-comments",
                "content": "```\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n\\t    //split text into separate words without spaces\\n        String[] words = text.split(\" \");    \\n        int[] buf = new int[\\'z\\'-\\'a\\'+1];\\n        int res=words.length;\\n        \\n\\t\\t//store all broken characters\\n        for(char ch : brokenLetters.toCharArray())\\n            buf[ch-\\'a\\']=1;\\n        \\n\\t\\t//check word-by-word\\n        for(String word : words)\\n            for(char ch : word.toCharArray()) // check character by character\\n                if(buf[ch-\\'a\\']!=0){ //if we face character from broken list, then  reduce RES and stop checking this word\\n                    res--;\\n                    break;\\n                }   \\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n\\t    //split text into separate words without spaces\\n        String[] words = text.split(\" \");    \\n        int[] buf = new int[\\'z\\'-\\'a\\'+1];\\n        int res=words.length;\\n        \\n\\t\\t//store all broken characters\\n        for(char ch : brokenLetters.toCharArray())\\n            buf[ch-\\'a\\']=1;\\n        \\n\\t\\t//check word-by-word\\n        for(String word : words)\\n            for(char ch : word.toCharArray()) // check character by character\\n                if(buf[ch-\\'a\\']!=0){ //if we face character from broken list, then  reduce RES and stop checking this word\\n                    res--;\\n                    break;\\n                }   \\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345133,
                "title": "c-solution-using-stringstream-and-set",
                "content": "Step by step procedure:\\n1. Atfirst, we store all the characters of the **broken** string in the set.\\n2. Using stringstream, we can access each word from **text** string.\\n3. We will increment the **cnt** variable for each word in the string text and check whether each character in **word** string is present in set,if it is present then decrement the **cnt**(which indicates that word includes atleast 1 broken character).\\n4. Finally return the **cnt** variable which indicates number of words in the string **text** that can be fullytped.\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string broken){\\n        set<char>s;\\n        int cnt=0;\\n        for(int i=0;i<broken.length();i++)\\n\\t\\t{\\n            s.insert(broken[i]);\\n        }\\n        stringstream ss(text);\\n        string word;\\n        while(ss >> word)\\n\\t\\t{\\n            cnt++;\\n           for(int i=0;i<word.length();i++)\\n\\t\\t   {\\n              if(s.find(word[i])!=s.end())\\n\\t\\t\\t  {\\n                  cnt--;\\n                  break;\\n              }\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nDo upvote,if you find it helpful !!!!",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string broken){\\n        set<char>s;\\n        int cnt=0;\\n        for(int i=0;i<broken.length();i++)\\n\\t\\t{\\n            s.insert(broken[i]);\\n        }\\n        stringstream ss(text);\\n        string word;\\n        while(ss >> word)\\n\\t\\t{\\n            cnt++;\\n           for(int i=0;i<word.length();i++)\\n\\t\\t   {\\n              if(s.find(word[i])!=s.end())\\n\\t\\t\\t  {\\n                  cnt--;\\n                  break;\\n              }\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777876,
                "title": "python-3-simple-set-intersection-2-lines-beats-89",
                "content": "```python3 []\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        broken = set(brokenLetters)\\n        return sum(not set(w) & broken for w in text.split())\\n```\\n```python3 []\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res, broken = 0, set(brokenLetters)\\n        for w in text.split():\\n            if not set(w) & broken:\\n                res += 1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        broken = set(brokenLetters)\\n        return sum(not set(w) & broken for w in text.split())\\n```\n```python3 []\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res, broken = 0, set(brokenLetters)\\n        for w in text.split():\\n            if not set(w) & broken:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580360,
                "title": "java-string-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String arr[] = text.split(\" \");\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<brokenLetters.length();j++){\\n                if(arr[i].contains(Character.toString(brokenLetters.charAt(j)))){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return arr.length-count;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String arr[] = text.split(\" \");\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<brokenLetters.length();j++){\\n                if(arr[i].contains(Character.toString(brokenLetters.charAt(j)))){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return arr.length-count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771234,
                "title": "easy-cpp-code-beginner-friendly-no-complex-coding",
                "content": "```\"leet code\", brokenLetters = \"lt\"``` //EXAMPLE WE ARE TAKING\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<string> temp;\\n        istringstream ss(text);\\n        string word;\\n        while( ss >> word ) temp.push_back(word);\\n        bool freq[26] = {false};\\n        for( auto c : brokenLetters ) freq[c-\\'a\\'] = true;\\n        int totalword = temp.size();\\n        for( int i = 0 ; i < temp.size() ; i++ )\\n        {\\n            for( auto c : temp[i] )\\n                if( freq[c-\\'a\\'] )\\n                {\\n                    totalword--;\\n                    break;\\n                }\\n        }\\n        return totalword;\\n    }\\n};\\n```\\n**STEP 1** - FROM STRING \"TEXT\" FILTER OUT WORDS OUT OF WHOLE SENTENCES ( **SPLIT FUNCTION C++**) AND STORING THEM IN VECTOR\\n```\\nvector<string> temp;\\n        istringstream ss(text);\\n        string word;\\n\\t\\twhile( ss >> word ) temp.push_back(word);\\n```\\nOUTPUT OF THESE 4 LINES WOULD LIKE BE VECTOR [ \"leet\", \"code\"]\\n**STEP 2** MAINTAIN AN ARRAY FOR THE BROKEN LETTER OF KEYBOARD\\n```\\n        bool freq[26] = {false};\\n        for( auto c : brokenLetters ) freq[c-\\'a\\'] = true;\\n```\\nAN ARRAY IS BEING ALLOTTED WITH SIZE OF 26 (REPRESENTING ALL 26 ENGLISH ALPHABETS) INITIALLY FALSE BUT AFTER STEP 2 , **TRUE** IS PLACED WHERE THE RESPECTIVE BROKEN APLHABETS PRESENT.\\n\\n**STEP 3** FINALLY THE LAST STEP , HERE WE ARE JUST ITERATIVE OVER TEMP VECTOR( OBTAINED FROM STEP 1) THAT WHICH WORD CONTAINS THE FORBIDDEN APLHABETS, USING **IF** LOOP FOR CHECKING EACH LETTER WITH THE FREQ ARRAY AND IS FOUND THEN BREAK INNER LOOP THERE ITSELF AND DECREASE THE COUNT OF TOTALWORDS AND CONTINUING WITH THE REST OF THE WORDS\\n```\\n        int totalword = temp.size();\\n        for( int i = 0 ; i < temp.size() ; i++ )\\n        {\\n            for( auto c : temp[i] )\\n                if( freq[c-\\'a\\'] )\\n                {\\n                    totalword--;\\n                    break;\\n                }\\n        }\\n        return totalword;\\n```\\nThank you if you have stayed this far. I tried my best to keep it simple and if someone want to discuss please let me know. Keep working hard . Do solve more programming question everyday.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\"leet code\", brokenLetters = \"lt\"```\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<string> temp;\\n        istringstream ss(text);\\n        string word;\\n        while( ss >> word ) temp.push_back(word);\\n        bool freq[26] = {false};\\n        for( auto c : brokenLetters ) freq[c-\\'a\\'] = true;\\n        int totalword = temp.size();\\n        for( int i = 0 ; i < temp.size() ; i++ )\\n        {\\n            for( auto c : temp[i] )\\n                if( freq[c-\\'a\\'] )\\n                {\\n                    totalword--;\\n                    break;\\n                }\\n        }\\n        return totalword;\\n    }\\n};\\n```\n```\\nvector<string> temp;\\n        istringstream ss(text);\\n        string word;\\n\\t\\twhile( ss >> word ) temp.push_back(word);\\n```\n```\\n        bool freq[26] = {false};\\n        for( auto c : brokenLetters ) freq[c-\\'a\\'] = true;\\n```\n```\\n        int totalword = temp.size();\\n        for( int i = 0 ; i < temp.size() ; i++ )\\n        {\\n            for( auto c : temp[i] )\\n                if( freq[c-\\'a\\'] )\\n                {\\n                    totalword--;\\n                    break;\\n                }\\n        }\\n        return totalword;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414751,
                "title": "simple-string-tokenizer-java-sol",
                "content": "```\\nimport java.io.*;\\nimport java.util.*;\\nclass Solution \\n{\\n    public int canBeTypedWords(String text, String broken) \\n    {\\n        StringTokenizer st = new StringTokenizer(text);\\n        int cnt=0;\\n        while(st.hasMoreTokens())\\n        {\\n            String wd=st.nextToken();\\n            cnt+=check(wd,broken);\\n        }\\n        return cnt;\\n    }\\n    public int check(String wd, String broken)\\n    {\\n        for(int i=0;i<broken.length();i++)\\n        {\\n            for(int j=0;j<wd.length();j++)\\n            {\\n                if(wd.charAt(j)==broken.charAt(i))\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.io.*;\\nimport java.util.*;\\nclass Solution \\n{\\n    public int canBeTypedWords(String text, String broken) \\n    {\\n        StringTokenizer st = new StringTokenizer(text);\\n        int cnt=0;\\n        while(st.hasMoreTokens())\\n        {\\n            String wd=st.nextToken();\\n            cnt+=check(wd,broken);\\n        }\\n        return cnt;\\n    }\\n    public int check(String wd, String broken)\\n    {\\n        for(int i=0;i<broken.length();i++)\\n        {\\n            for(int j=0;j<wd.length();j++)\\n            {\\n                if(wd.charAt(j)==broken.charAt(i))\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407834,
                "title": "c-c-simple-and-easy-solution-0ms-faster-than-100",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<char> broken(26, 0);\\n        for (auto c : brokenLetters) broken[c - \\'a\\']++;\\n        \\n        \\n        int res = 0, count = 0;\\n        for (int i = 0; i < text.size(); i++) {\\n            if (text[i] == \\' \\') {\\n                if (count == 0) res++; // end of word and no broken letters\\n                count = 0;\\n                continue;\\n            }\\n            \\n            if (broken[text[i] - \\'a\\']) count++;\\n        }\\n        \\n        if (!count) res++; // For last word\\n        \\n        return res;\\n    }\\n};\\n```\\n**C:**\\n```\\nint canBeTypedWords(char * text, char * brokenLetters) {\\n    int broken[26] = {0};\\n    char* ptr = brokenLetters;\\n    while (*ptr) broken[*ptr++ - \\'a\\']++;\\n\\n    ptr = text;\\n    int res = 0, count = 0;\\n    while (*ptr) {\\n        if (*ptr == \\' \\') {\\n            if (count == 0) res++; // end of word and no broken letters\\n            count = 0;\\n            ptr++;\\n            continue;\\n        }\\n        \\n        if (broken[*ptr - \\'a\\']) count++;\\n        ptr++;\\n    }\\n\\n    if (!count) res++; // For last word\\n\\n    return res;\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<char> broken(26, 0);\\n        for (auto c : brokenLetters) broken[c - \\'a\\']++;\\n        \\n        \\n        int res = 0, count = 0;\\n        for (int i = 0; i < text.size(); i++) {\\n            if (text[i] == \\' \\') {\\n                if (count == 0) res++; // end of word and no broken letters\\n                count = 0;\\n                continue;\\n            }\\n            \\n            if (broken[text[i] - \\'a\\']) count++;\\n        }\\n        \\n        if (!count) res++; // For last word\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nint canBeTypedWords(char * text, char * brokenLetters) {\\n    int broken[26] = {0};\\n    char* ptr = brokenLetters;\\n    while (*ptr) broken[*ptr++ - \\'a\\']++;\\n\\n    ptr = text;\\n    int res = 0, count = 0;\\n    while (*ptr) {\\n        if (*ptr == \\' \\') {\\n            if (count == 0) res++; // end of word and no broken letters\\n            count = 0;\\n            ptr++;\\n            continue;\\n        }\\n        \\n        if (broken[*ptr - \\'a\\']) count++;\\n        ptr++;\\n    }\\n\\n    if (!count) res++; // For last word\\n\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346740,
                "title": "python-straightforward-solution",
                "content": "```\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        \"\"\"\\n        :type text: str\\n        :type brokenLetters: str\\n        :rtype: int\\n        \"\"\"\\n        text = text.split(\" \")\\n        if not brokenLetters:\\n            return len(text)\\n        \\n        brokenLetters = set(brokenLetters)\\n        ans = 0\\n        for word in text:\\n            new_set = set(word)\\n            if not new_set.intersection(brokenLetters):\\n                ans += 1     \\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        \"\"\"\\n        :type text: str\\n        :type brokenLetters: str\\n        :rtype: int\\n        \"\"\"\\n        text = text.split(\" \")\\n        if not brokenLetters:\\n            return len(text)\\n        \\n        brokenLetters = set(brokenLetters)\\n        ans = 0\\n        for word in text:\\n            new_set = set(word)\\n            if not new_set.intersection(brokenLetters):\\n                ans += 1     \\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369997,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n  n: length of the text\\n  m: length of brokenLetters\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check_letters(char c, string s)\\n    {\\n        for (int i = 0; i < s.size(); i++)\\n            if (s[i] == c)\\n                return true;\\n        return false;\\n    }\\n\\n    int canBeTypedWords(string text, string brokenLetters) {\\n    string word;\\n    vector<string> words;\\n    for (int i = 0; i < text.size(); i++)\\n    {\\n        if (text[i] != \\' \\')\\n            word.push_back(text[i]);\\n        if (text[i] == \\' \\' || i == text.size() - 1)\\n        {\\n            words.push_back(word);\\n            word = \"\";\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        bool letter_present = false;\\n        for (int j = 0; j < brokenLetters.size(); j++)\\n            if (check_letters(brokenLetters[j], words[i]))\\n            {\\n                letter_present = true;\\n                break;\\n            }\\n        if (!letter_present)\\n            count++;\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check_letters(char c, string s)\\n    {\\n        for (int i = 0; i < s.size(); i++)\\n            if (s[i] == c)\\n                return true;\\n        return false;\\n    }\\n\\n    int canBeTypedWords(string text, string brokenLetters) {\\n    string word;\\n    vector<string> words;\\n    for (int i = 0; i < text.size(); i++)\\n    {\\n        if (text[i] != \\' \\')\\n            word.push_back(text[i]);\\n        if (text[i] == \\' \\' || i == text.size() - 1)\\n        {\\n            words.push_back(word);\\n            word = \"\";\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        bool letter_present = false;\\n        for (int j = 0; j < brokenLetters.size(); j++)\\n            if (check_letters(brokenLetters[j], words[i]))\\n            {\\n                letter_present = true;\\n                break;\\n            }\\n        if (!letter_present)\\n            count++;\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165112,
                "title": "1-ms-java-solution-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    int ans = 0;\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> set = new HashSet();\\n        for (char c : brokenLetters.toCharArray()) set.add(c);\\n\\n        String [] arr = text.split(\" \");\\n\\n        for (int i = 0; i < arr.length; i++) traverse(arr[i], set);\\n        return ans;\\n    }\\n\\n    public void traverse(String s, Set<Character> set) {\\n        for (int i = 0; i < s.length(); i++) \\n            if (set.contains(s.charAt(i))) return;\\n        ans++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> set = new HashSet();\\n        for (char c : brokenLetters.toCharArray()) set.add(c);\\n\\n        String [] arr = text.split(\" \");\\n\\n        for (int i = 0; i < arr.length; i++) traverse(arr[i], set);\\n        return ans;\\n    }\\n\\n    public void traverse(String s, Set<Character> set) {\\n        for (int i = 0; i < s.length(); i++) \\n            if (set.contains(s.charAt(i))) return;\\n        ans++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102510,
                "title": "c-solution-using-hashset-char-and-two-foreach-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing HashSet was the first idea to detect any letters in the brokenLetters since all the letters are unique and there is no need to keep track of the frequency of any of them.  \\n\\nAs for the option of iterating through all letters in text, I chose to use the string.Split() for simpler code of checking each word in the text and each letter of the word - thus using two ForEach loops.\\n\\nThe count of all words that can be typed without any of the broken letters, I chose to use a boolean flag to determine whether to count or not.\\n\\nThe final count value is the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI initialized the HashSet, simply passing the brokenLetters string as the argument of instantiation syntax of the set.\\n\\nI then split the text into an array of strings, each element representing a word.\\n\\nUsing two foreach loops (not using for loop since  index of the letters is not needed), iterate through the array using the outer forloop and iterate through all letters of a given word the inner forloop.  If any one of the broken letters is found, the boolean flag is used to exclude the particular word from being counted.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CanBeTypedWords(string text, string brokenLetters) {\\n\\n        var set = new HashSet<char>(brokenLetters);\\n        bool isBroken = false;\\n        int count = 0;\\n\\n        string[] arr = text.Split(\" \");\\n        \\n        foreach (var s in arr)\\n        {\\n            isBroken = false;\\n            foreach (var c in s)\\n            {\\n                if (set.Contains(c)) isBroken = true;\\n            }\\n            if (!isBroken) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CanBeTypedWords(string text, string brokenLetters) {\\n\\n        var set = new HashSet<char>(brokenLetters);\\n        bool isBroken = false;\\n        int count = 0;\\n\\n        string[] arr = text.Split(\" \");\\n        \\n        foreach (var s in arr)\\n        {\\n            isBroken = false;\\n            foreach (var c in s)\\n            {\\n                if (set.Contains(c)) isBroken = true;\\n            }\\n            if (!isBroken) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832369,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, b: str) -> int:\\n        output = 0\\n        text = text.split()\\n        brokenLetters = list(b)\\n        for elem in text:\\n            if any(v in brokenLetters for v in elem):\\n                continue\\n            else:\\n                output += 1\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, b: str) -> int:\\n        output = 0\\n        text = text.split()\\n        brokenLetters = list(b)\\n        for elem in text:\\n            if any(v in brokenLetters for v in elem):\\n                continue\\n            else:\\n                output += 1\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554624,
                "title": "4-ms-ez-java-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String bl) {\\n        String[] list = text.split(\" \");\\n        String[] chars = bl.split(\"\");\\n        int ans = 0;\\n        for(String ls: list) {\\n            for(int j = 0; j != bl.length(); ++j) {\\n                if (ls.contains(chars[j])) {\\n                    ans--;\\n                    break;\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String bl) {\\n        String[] list = text.split(\" \");\\n        String[] chars = bl.split(\"\");\\n        int ans = 0;\\n        for(String ls: list) {\\n            for(int j = 0; j != bl.length(); ++j) {\\n                if (ls.contains(chars[j])) {\\n                    ans--;\\n                    break;\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227006,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 1;\\n        boolean isBad = false;\\n        for (char c : text.toCharArray()) {\\n            if (c == \\' \\') {\\n                isBad = false;\\n                count++;\\n            } else {\\n                if (!isBad && brokenLetters.indexOf(c) != -1) {\\n                    isBad = true;\\n                    count--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 1;\\n        boolean isBad = false;\\n        for (char c : text.toCharArray()) {\\n            if (c == \\' \\') {\\n                isBad = false;\\n                count++;\\n            } else {\\n                if (!isBad && brokenLetters.indexOf(c) != -1) {\\n                    isBad = true;\\n                    count--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195713,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int arr[26]={0};\\n        \\n        for(int i=0;i<brokenLetters.length();i++)\\n        {\\n            arr[brokenLetters[i]-\\'a\\']++;\\n        }\\n        \\n        int count=0,n=text.length();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(text[i]==\\' \\' || ( i==n-1 && arr[text[i]-\\'a\\']==0))\\n                  count++;\\n            else if(arr[text[i]-\\'a\\'] !=0)\\n                {\\n                    while(text[i]!=\\' \\' &&  i!=n-1)\\n                        i++;\\n                }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int arr[26]={0};\\n        \\n        for(int i=0;i<brokenLetters.length();i++)\\n        {\\n            arr[brokenLetters[i]-\\'a\\']++;\\n        }\\n        \\n        int count=0,n=text.length();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(text[i]==\\' \\' || ( i==n-1 && arr[text[i]-\\'a\\']==0))\\n                  count++;\\n            else if(arr[text[i]-\\'a\\'] !=0)\\n                {\\n                    while(text[i]!=\\' \\' &&  i!=n-1)\\n                        i++;\\n                }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184099,
                "title": "javascript-easy",
                "content": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    \\n    let count = 0;\\n    let arrs = text.split(\\' \\');\\n    let hash = {};\\n    \\n    for(let i=0; i<brokenLetters.length; i++) {\\n        hash[brokenLetters[i]] = true;\\n    }\\n    \\n    for(let i=0; i<arrs.length; i++) {\\n        let word = arrs[i];\\n        let flag = true;\\n        for(let j=0; j<word.length; j++) {\\n            let letter = word[j];\\n            if(hash[letter]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag == true) {\\n            count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    \\n    let count = 0;\\n    let arrs = text.split(\\' \\');\\n    let hash = {};\\n    \\n    for(let i=0; i<brokenLetters.length; i++) {\\n        hash[brokenLetters[i]] = true;\\n    }\\n    \\n    for(let i=0; i<arrs.length; i++) {\\n        let word = arrs[i];\\n        let flag = true;\\n        for(let j=0; j<word.length; j++) {\\n            let letter = word[j];\\n            if(hash[letter]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag == true) {\\n            count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860723,
                "title": "python-45-ms-solution-good-for-beginners",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        words = text.split()\\n        count = 0\\n        flag = 0\\n        for i in words:\\n            for j in brokenLetters:\\n                if j in i:\\n                    flag = 1\\n                    break\\n            if flag == 0:\\n                count += 1\\n            flag = 0\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        words = text.split()\\n        count = 0\\n        flag = 0\\n        for i in words:\\n            for j in brokenLetters:\\n                if j in i:\\n                    flag = 1\\n                    break\\n            if flag == 0:\\n                count += 1\\n            flag = 0\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1562882,
                "title": "javascript-easy-3-line-solution-w-explanation",
                "content": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    const lettersArr = brokenLetters.split(\\'\\') \\n    const checker = word => !lettersArr.some(letter => word.includes(letter)); \\n    return text.split(\\' \\').filter(checker).length\\n};\\n```\\n\\n1. ``    const lettersArr = brokenLetters.split(\\'\\') `` split string of broken letters into an array of letters\\n2. ``const checker = word => !lettersArr.some(letter => word.includes(letter)); `` function to check if a word includes letters from the lettersArr\\n3. `` return text.split(\\' \\').filter(checker).length;`` split string into array of words, filter it using the checker function, and return the length",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    const lettersArr = brokenLetters.split(\\'\\') \\n    const checker = word => !lettersArr.some(letter => word.includes(letter)); \\n    return text.split(\\' \\').filter(checker).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347140,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int c=0,k=1;\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,bool>map;\\n        for(auto i:brokenLetters)\\n            map[i]=true;\\n        \\n        for(int i=0;i<text.length();i++)\\n            if(text[i]==\\' \\')\\n                k++;\\n        \\n        stringstream iss(text);\\n        string word;\\n        \\n        while(iss >> word) {\\n            for(int i=0;i<word.size();i++){\\n               if(map[word[i]]==true){\\n                    k--;\\n                     break;   \\n               }\\n            } \\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c=0,k=1;\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,bool>map;\\n        for(auto i:brokenLetters)\\n            map[i]=true;\\n        \\n        for(int i=0;i<text.length();i++)\\n            if(text[i]==\\' \\')\\n                k++;\\n        \\n        stringstream iss(text);\\n        string word;\\n        \\n        while(iss >> word) {\\n            for(int i=0;i<word.size();i++){\\n               if(map[word[i]]==true){\\n                    k--;\\n                     break;   \\n               }\\n            } \\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345012,
                "title": "java-hashset",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenLettersSet=new HashSet<>();\\n        for (char brokenLetter: brokenLetters.toCharArray()){\\n            brokenLettersSet.add(brokenLetter);\\n        }\\n        boolean curCan=true;\\n        int res=0;\\n        for (char ch:text.toCharArray()){\\n            if (ch==\\' \\'){\\n                if (curCan){\\n                    res++;\\n                } else {\\n                    curCan=true;\\n                }\\n            }\\n            if (brokenLettersSet.contains(ch)){\\n                curCan=false;\\n            }\\n        }\\n        if (curCan){\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenLettersSet=new HashSet<>();\\n        for (char brokenLetter: brokenLetters.toCharArray()){\\n            brokenLettersSet.add(brokenLetter);\\n        }\\n        boolean curCan=true;\\n        int res=0;\\n        for (char ch:text.toCharArray()){\\n            if (ch==\\' \\'){\\n                if (curCan){\\n                    res++;\\n                } else {\\n                    curCan=true;\\n                }\\n            }\\n            if (brokenLettersSet.contains(ch)){\\n                curCan=false;\\n            }\\n        }\\n        if (curCan){\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344924,
                "title": "c-break-the-text-into-words-and-check-for-each-word",
                "content": "- Break the text string with spaces and store in an vector / array\\n- For each word in the array traverse through each character and check if in the brokenLetters\\n\\n```\\nclass Solution {\\npublic:\\n  vector<string> breakWithSpaces(string str) {\\n    vector<string> words;\\n    string word = \"\";\\n    for(auto x : str) {\\n        if(x == \\' \\') {\\n            words.push_back(word);\\n            word = \"\";\\n        }\\n        else {\\n            word = word + x;\\n        }\\n    }\\n    words.push_back(word);\\n    return words;\\n  }\\n  \\n  int canBeTypedWords(string text, string brokenLetters) {\\n    vector<string> words;\\n    int wordCount = 0;\\n    words = breakWithSpaces(text);\\n    \\n    for(int i = 0; i < words.size(); i++) {\\n      bool cantPrint = false;\\n      \\n      for(char textLetter : words[i]) {\\n        for(char brokenLetter : brokenLetters){\\n          if(brokenLetter == textLetter) {\\n            cantPrint = true;\\n            break;\\n          }\\n        }\\n      }\\n      \\n      if(!cantPrint)\\n          wordCount++;\\n    }\\n    return wordCount;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<string> breakWithSpaces(string str) {\\n    vector<string> words;\\n    string word = \"\";\\n    for(auto x : str) {\\n        if(x == \\' \\') {\\n            words.push_back(word);\\n            word = \"\";\\n        }\\n        else {\\n            word = word + x;\\n        }\\n    }\\n    words.push_back(word);\\n    return words;\\n  }\\n  \\n  int canBeTypedWords(string text, string brokenLetters) {\\n    vector<string> words;\\n    int wordCount = 0;\\n    words = breakWithSpaces(text);\\n    \\n    for(int i = 0; i < words.size(); i++) {\\n      bool cantPrint = false;\\n      \\n      for(char textLetter : words[i]) {\\n        for(char brokenLetter : brokenLetters){\\n          if(brokenLetter == textLetter) {\\n            cantPrint = true;\\n            break;\\n          }\\n        }\\n      }\\n      \\n      if(!cantPrint)\\n          wordCount++;\\n    }\\n    return wordCount;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344918,
                "title": "c-easy-to-understand",
                "content": "In this we will find the strings before spaces (for the last string we have to take care).\\nfor every string just check if the characters of brokenLetters are present or not.\\nif not present then increment the count.\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        string a=\"\";\\n        int count=0;\\n//         check for every string before space\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\')\\n              {\\n               \\n                int flag=1;\\n//                 checking for every string if the character of brokenLetters are present or not.\\n                 for(int j=0;j<brokenLetters.size();j++)\\n                 {\\n                     for(int k=0;k<a.size();k++)\\n                     {\\n                         if(brokenLetters[j]==a[k])\\n                            { flag=0;\\n                              break;\\n                            }\\n                     }\\n                     if(flag==0)\\n                     break;\\n                 }\\n                cout<<flag<<endl;\\n                if(flag==1)\\n                    count++;\\n                 a=\"\";\\n              }\\n            else a=a+text[i];\\n        }\\n//         this is for the last string \\n//        as there is not space at last/\\n                 int flag=1;\\n                 for(int j=0;j<brokenLetters.size();j++)\\n                 {\\n                     for(int k=0;k<a.size();k++)\\n                     {\\n                         if(brokenLetters[j]==a[k])\\n                            { flag=0;\\n                              break;\\n                            }\\n                     }\\n                     if(flag==0)\\n                     break;\\n                 }\\n                cout<<flag<<endl;\\n                if(flag==1)\\n                    count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        string a=\"\";\\n        int count=0;\\n//         check for every string before space\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\')\\n              {\\n               \\n                int flag=1;\\n//                 checking for every string if the character of brokenLetters are present or not.\\n                 for(int j=0;j<brokenLetters.size();j++)\\n                 {\\n                     for(int k=0;k<a.size();k++)\\n                     {\\n                         if(brokenLetters[j]==a[k])\\n                            { flag=0;\\n                              break;\\n                            }\\n                     }\\n                     if(flag==0)\\n                     break;\\n                 }\\n                cout<<flag<<endl;\\n                if(flag==1)\\n                    count++;\\n                 a=\"\";\\n              }\\n            else a=a+text[i];\\n        }\\n//         this is for the last string \\n//        as there is not space at last/\\n                 int flag=1;\\n                 for(int j=0;j<brokenLetters.size();j++)\\n                 {\\n                     for(int k=0;k<a.size();k++)\\n                     {\\n                         if(brokenLetters[j]==a[k])\\n                            { flag=0;\\n                              break;\\n                            }\\n                     }\\n                     if(flag==0)\\n                     break;\\n                 }\\n                cout<<flag<<endl;\\n                if(flag==1)\\n                    count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3177076,
                "title": "o-n-solution-with-set-explanation-python-faster-than-others",
                "content": "\\n```\\ncounter = 0\\nfor i in text.split():\\n    #{\\'a\\',\\'b\\'}.intersection(\\'a\\') is equal to {\\'a\\'} \\n    #according to this if this expression returned empty set then we\\'ll increment\\n    if set(brokenLetters).intersection(set(i)) == set():\\n        counter+=1\\nreturn counter\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ncounter = 0\\nfor i in text.split():\\n    #{\\'a\\',\\'b\\'}.intersection(\\'a\\') is equal to {\\'a\\'} \\n    #according to this if this expression returned empty set then we\\'ll increment\\n    if set(brokenLetters).intersection(set(i)) == set():\\n        counter+=1\\nreturn counter\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2971347,
                "title": "p3-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(1 for word in text.split() if len(set(word) & set(brokenLetters)) == 0 )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(1 for word in text.split() if len(set(word) & set(brokenLetters)) == 0 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711818,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int brokenLettersIdx [26] = {};\\n        int canTypeWords = 0;\\n        for (char c : brokenLetters) {\\n            brokenLettersIdx[c-\\'a\\'] = 1;\\n        }\\n\\t\\t\\n        for (int i = 0; i < text.length(); i++) {\\n            int brk = 0;\\n            while (i < text.length() && text[i] != \\' \\') {\\n                if (brokenLettersIdx[text[i]-\\'a\\'] == 1) {\\n                    brk++;\\n                }\\n                i++;\\n            }\\n            if (brk == 0) {\\n                canTypeWords++;\\n            }\\n        }\\n        return canTypeWords;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int brokenLettersIdx [26] = {};\\n        int canTypeWords = 0;\\n        for (char c : brokenLetters) {\\n            brokenLettersIdx[c-\\'a\\'] = 1;\\n        }\\n\\t\\t\\n        for (int i = 0; i < text.length(); i++) {\\n            int brk = 0;\\n            while (i < text.length() && text[i] != \\' \\') {\\n                if (brokenLettersIdx[text[i]-\\'a\\'] == 1) {\\n                    brk++;\\n                }\\n                i++;\\n            }\\n            if (brk == 0) {\\n                canTypeWords++;\\n            }\\n        }\\n        return canTypeWords;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553716,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashset***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(Constant)***\\n\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string str, string bad) {\\n        \\n        int n = str.size();\\n        \\n        // insert the not working characters into set\\n        \\n        unordered_set<char> s;\\n        \\n        for(auto x : bad)\\n        {\\n            s.insert(x);\\n        }\\n        \\n        int count = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            bool flag = true;\\n            \\n            while(i < n && str[i] != \\' \\')\\n            {\\n                // if any of the character in word is not working mark flag to false\\n                \\n                if(s.count(str[i]))\\n                {\\n                    flag = false;\\n                }\\n                \\n                i++;\\n            }\\n            \\n            // if all the characters in the word are working\\n            \\n            if(flag)\\n            {\\n                count++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string str, string bad) {\\n        \\n        int n = str.size();\\n        \\n        // insert the not working characters into set\\n        \\n        unordered_set<char> s;\\n        \\n        for(auto x : bad)\\n        {\\n            s.insert(x);\\n        }\\n        \\n        int count = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            bool flag = true;\\n            \\n            while(i < n && str[i] != \\' \\')\\n            {\\n                // if any of the character in word is not working mark flag to false\\n                \\n                if(s.count(str[i]))\\n                {\\n                    flag = false;\\n                }\\n                \\n                i++;\\n            }\\n            \\n            // if all the characters in the word are working\\n            \\n            if(flag)\\n            {\\n                count++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501634,
                "title": "python-faster-than-95-86-less-memory-than-95-74",
                "content": "This is a simple solution in Python 3, which invokes a list comprehension. Details in docstring:\\n\\n```python\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        \"\"\"\\n        This function looks at the number of words which can be typed, when\\n        considering the broken letters. The function firstly assigns output as \\n        0, followed by splitting the text into words, and the brokenLetters into a \\n        List. For each element in the text, if any brokenLetter element exists\\n        within the element, no value is increased on output, otherwise output is\\n        incremented by 1.\\n        \\n        :param text: the text to be evaluated. (str)\\n        :param brokenLetters: the letters which are broken. (str)\\n        :returns output: the number of words which can be formed. (int)\\n        \"\"\"\\n        output = 0\\n        text = text.split()\\n        brokenLetters = list(brokenLetters)\\n        for elem in text:\\n            if any(v in brokenLetters for v in elem):\\n                continue\\n            else:\\n                output += 1\\n        return output",
                "solutionTags": [],
                "code": "This is a simple solution in Python 3, which invokes a list comprehension. Details in docstring:\\n\\n```python\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        \"\"\"\\n        This function looks at the number of words which can be typed, when\\n        considering the broken letters. The function firstly assigns output as \\n        0, followed by splitting the text into words, and the brokenLetters into a \\n        List. For each element in the text, if any brokenLetter element exists\\n        within the element, no value is increased on output, otherwise output is\\n        incremented by 1.\\n        \\n        :param text: the text to be evaluated. (str)\\n        :param brokenLetters: the letters which are broken. (str)\\n        :returns output: the number of words which can be formed. (int)\\n        \"\"\"\\n        output = 0\\n        text = text.split()\\n        brokenLetters = list(brokenLetters)\\n        for elem in text:\\n            if any(v in brokenLetters for v in elem):\\n                continue\\n            else:\\n                output += 1\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 2279972,
                "title": "python-set",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        brokenLetters = set(brokenLetters)\\n        res = 0\\n        for word in text.split():\\n            if set(word) - brokenLetters == set(word):\\n                res += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        brokenLetters = set(brokenLetters)\\n        res = 0\\n        for word in text.split():\\n            if set(word) - brokenLetters == set(word):\\n                res += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2236748,
                "title": "using-set-properties",
                "content": "\\tclass Solution:\\n\\t\\tdef canBeTypedWords(self, text: str, bL: str) -> int:\\n\\t\\t\\treturn sum(1 for w in text.split() if not set(w)&set(bL))",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef canBeTypedWords(self, text: str, bL: str) -> int:\\n\\t\\t\\treturn sum(1 for w in text.split() if not set(w)&set(bL))",
                "codeTag": "Java"
            },
            {
                "id": 1793557,
                "title": "java-2-methods-explained",
                "content": "**Idea:**\\n* Convert `brokenLetters` to a set of chars\\n* Split text into words and if any word contains a broken letter then that can\\'t be typed\\n\\n**Method 1:** Using split\\n> **T/S:** O(m + n)/O(m + n), where m = size(text), n = size(brokenLetters)\\n```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\tvar broken = setOf(brokenLetters);\\n\\tvar words = text.split(\" \");\\n\\tvar count = words.length;\\n\\t\\n\\tfor (var word : words)\\n\\t\\tfor (var i = 0; i < word.length(); i++)\\n\\t\\t\\tif (broken.contains(word.charAt(i))) {\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\treturn count;\\n}\\n\\nprivate Set<Character> setOf(String brokenLetters) {\\n\\tvar broken = new HashSet<Character>();\\n\\tfor (var i = 0; i < brokenLetters.length(); i++)\\n\\t\\tbroken.add(brokenLetters.charAt(i));\\n\\treturn broken;\\n}\\n```\\n\\n**Method 2:** Without using `split`\\n> **T/S:** O(m + n)/O(n)\\n```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\tvar broken = setOf(brokenLetters);\\n\\tvar count = 0;\\n\\n\\tfor (var i = 0; i < text.length(); i++) {\\n\\t\\tvar hasBrokenLetter = false;\\n\\t\\t\\n\\t\\twhile (i < text.length() && !Character.isSpaceChar(text.charAt(i)))\\n\\t\\t\\tif (broken.contains(text.charAt(i++)) && !hasBrokenLetter)\\n\\t\\t\\t\\thasBrokenLetter = true;\\n\\t\\t\\n\\t\\tif (!hasBrokenLetter)\\n\\t\\t\\tcount++;\\n\\t}\\n\\treturn count;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\tvar broken = setOf(brokenLetters);\\n\\tvar words = text.split(\" \");\\n\\tvar count = words.length;\\n\\t\\n\\tfor (var word : words)\\n\\t\\tfor (var i = 0; i < word.length(); i++)\\n\\t\\t\\tif (broken.contains(word.charAt(i))) {\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\treturn count;\\n}\\n\\nprivate Set<Character> setOf(String brokenLetters) {\\n\\tvar broken = new HashSet<Character>();\\n\\tfor (var i = 0; i < brokenLetters.length(); i++)\\n\\t\\tbroken.add(brokenLetters.charAt(i));\\n\\treturn broken;\\n}\\n```\n```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\tvar broken = setOf(brokenLetters);\\n\\tvar count = 0;\\n\\n\\tfor (var i = 0; i < text.length(); i++) {\\n\\t\\tvar hasBrokenLetter = false;\\n\\t\\t\\n\\t\\twhile (i < text.length() && !Character.isSpaceChar(text.charAt(i)))\\n\\t\\t\\tif (broken.contains(text.charAt(i++)) && !hasBrokenLetter)\\n\\t\\t\\t\\thasBrokenLetter = true;\\n\\t\\t\\n\\t\\tif (!hasBrokenLetter)\\n\\t\\t\\tcount++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1685655,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        s=[]\\n        text=text.split()\\n        for i in text:\\n            for j in i:\\n                if j in brokenLetters:\\n                    break\\n            else:\\n                s.append(i)\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        s=[]\\n        text=text.split()\\n        for i in text:\\n            for j in i:\\n                if j in brokenLetters:\\n                    break\\n            else:\\n                s.append(i)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575386,
                "title": "c-faster-than-100-explanation",
                "content": "Concepts used\\n* In c++ all strings are terminatd by \\'\\\\0\\'\\n* If a broken letter is encountered next letters of word will not matter\\n```c++\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        std::vector<int> bl(27);\\n        for(auto &&i : brokenLetters){\\n            if(i == \\' \\') continue;\\n            bl[(i-\\'a\\')]++;\\n        }\\n\\t\\t\\n        int w = 0;\\n\\t\\t// note \\'<=\\'\\n        for(int i=0; i<=text.length();i++){\\n            if(text[i] == \\' \\' || text[i] == \\'\\\\0\\'){\\n                w++;\\n                continue;\\n            }\\n\\n            if(bl[text[i]-\\'a\\']!=0){    //broken letter\\n                while(i < text.length()){\\n                    if(text[i]==\\' \\') {break;}\\n                    i++;\\n                }\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        std::vector<int> bl(27);\\n        for(auto &&i : brokenLetters){\\n            if(i == \\' \\') continue;\\n            bl[(i-\\'a\\')]++;\\n        }\\n\\t\\t\\n        int w = 0;\\n\\t\\t// note \\'<=\\'\\n        for(int i=0; i<=text.length();i++){\\n            if(text[i] == \\' \\' || text[i] == \\'\\\\0\\'){\\n                w++;\\n                continue;\\n            }\\n\\n            if(bl[text[i]-\\'a\\']!=0){    //broken letter\\n                while(i < text.length()){\\n                    if(text[i]==\\' \\') {break;}\\n                    i++;\\n                }\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507535,
                "title": "2-line-solutions-in-python",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        return len(text) - sum(any(c in w for c in brokenLetters) for w in text)\\n```\\nnot quite different with `set`:\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        bls = set(brokenLetters)\\n        return sum(not set(w) & bls for w in text.split())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        return len(text) - sum(any(c in w for c in brokenLetters) for w in text)\\n```\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        bls = set(brokenLetters)\\n        return sum(not set(w) & bls for w in text.split())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484560,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar canBeTypedWords = function(text, brokenLetters) {\\n\\t\\tconst textSplit = text.split(\\' \\');\\n\\t\\tconst brokenLetterSplit =  brokenLetters.split(\\'\\');\\n\\n\\t\\treturn textSplit.filter(word => {\\n\\t\\t\\treturn brokenLetterSplit.every(broken => !word.includes(broken));\\n\\t\\t}).length;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar canBeTypedWords = function(text, brokenLetters) {\\n\\t\\tconst textSplit = text.split(\\' \\');\\n\\t\\tconst brokenLetterSplit =  brokenLetters.split(\\'\\');\\n\\n\\t\\treturn textSplit.filter(word => {\\n\\t\\t\\treturn brokenLetterSplit.every(broken => !word.includes(broken));\\n\\t\\t}).length;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1400472,
                "title": "c-o-n-commented-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int ans=0, n=text.size();\\n        bool flag=true;\\n        unordered_map<char,int> m;\\n        //count frequency of  brokenLetters\\n        for(auto i:brokenLetters) m[i]++;\\n        \\n        for(int i=0;i<n;i++){\\n            if(m[text[i]]>0)  //if char found in map, flag = false, word cannot be counted\\n                flag=false;\\n            else if(text[i]==\\' \\')\\n            {\\n                if(flag)    // if flag=true, i.e. the word before space is not broken, so ans++; \\n                    ans++;\\n                flag=true;\\n            }\\n            \\n        }\\n        \\n        if(flag)   // for the last word\\n            ans++;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nTime Complexity - O(N)\\n\\nPlz upvote if you like it.\\nHappy Coding!\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int ans=0, n=text.size();\\n        bool flag=true;\\n        unordered_map<char,int> m;\\n        //count frequency of  brokenLetters\\n        for(auto i:brokenLetters) m[i]++;\\n        \\n        for(int i=0;i<n;i++){\\n            if(m[text[i]]>0)  //if char found in map, flag = false, word cannot be counted\\n                flag=false;\\n            else if(text[i]==\\' \\')\\n            {\\n                if(flag)    // if flag=true, i.e. the word before space is not broken, so ans++; \\n                    ans++;\\n                flag=true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1370603,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int canBeTypedWords(String t, String b) {\\n        t=t.trim();\\n        String a[]=new String[t.length()];\\n        int i,j=0,k=0;\\n        for(i=0;i<t.length();i++)\\n        {\\n            if(t.charAt(i)==\\' \\')\\n            {\\n                a[j++]=t.substring(k,i);\\n                k=i+1;\\n            }\\n        }\\n        a[j++]=t.substring(k);\\n        for(i=0;i<b.length();i++)\\n        {\\n            for(k=0;k<j;k++)\\n            {\\n                if(a[k].contains(String.valueOf(b.charAt(i))))\\n                {\\n                    a[k]=\"\";\\n                }\\n            }\\n        }\\n        k=0;\\n        for(i=0;i<j;i++)\\n        {\\n            if(a[i].length()==0)\\n                k++;\\n        }\\n        return j-k;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int canBeTypedWords(String t, String b) {\\n        t=t.trim();\\n        String a[]=new String[t.length()];\\n        int i,j=0,k=0;\\n        for(i=0;i<t.length();i++)\\n        {\\n            if(t.charAt(i)==\\' \\')\\n            {\\n                a[j++]=t.substring(k,i);\\n                k=i+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1358762,
                "title": "map-approach-simple-and-concise",
                "content": "So i basically saved the character which are defected in a map then traversed the initial string and if no defective is found then count++ and finally returned count\\n\\n```\\nint canBeTypedWords(string t, string s) \\n    {\\n        int count=0;\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n            m[s[i]]++;\\n        bool check=true;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==\\' \\')\\n            {\\n                if(check)\\n                    count++;\\n                check=true;\\n            }\\n            else if(m[t[i]]>0)\\n                check=false;\\n        }\\n        if(check)\\n            count++;\\n        return count;\\n    }\\n```\\nthe last count++ is done because there will not be any \\' \\' empty char in end to check if it is correct or not \\n\\n\\n\\nI hope you understood the aboce code and query can be asked in comment section i will be happy to answer that\\n\\nDo UPVOTE if you understood the code \\nHappy Leetcoding:)",
                "solutionTags": [],
                "code": "```\\nint canBeTypedWords(string t, string s) \\n    {\\n        int count=0;\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n            m[s[i]]++;\\n        bool check=true;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==\\' \\')\\n            {\\n                if(check)\\n                    count++;\\n                check=true;\\n            }\\n            else if(m[t[i]]>0)\\n                check=false;\\n        }\\n        if(check)\\n            count++;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1357399,
                "title": "swift-variant-of-solution",
                "content": "*<- Please vote if my solution was helpful to you.*\\n```\\nclass Solution {\\n    func canBeTypedWords(_ text: String, _ brokenLetters: String) -> Int {\\n\\t\\tvar arr = text.split(separator: \" \")    \\n        for char in brokenLetters {\\n            arr = arr.filter {!$0.contains(char)}    \\n        }\\n        return arr.count\\t\\t\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func canBeTypedWords(_ text: String, _ brokenLetters: String) -> Int {\\n\\t\\tvar arr = text.split(separator: \" \")    \\n        for char in brokenLetters {\\n            arr = arr.filter {!$0.contains(char)}    \\n        }\\n        return arr.count\\t\\t\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353581,
                "title": "c-one-line-linq",
                "content": "```\\npublic int CanBeTypedWords2(string text, string brokenLetters) \\n        => text.Split(\\' \\').Count(w => !w.Intersect(brokenLetters).Any());        \\n```",
                "solutionTags": [],
                "code": "```\\npublic int CanBeTypedWords2(string text, string brokenLetters) \\n        => text.Split(\\' \\').Count(w => !w.Intersect(brokenLetters).Any());        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347787,
                "title": "rust-solution-with-array",
                "content": "```\\nimpl Solution {\\n    pub fn can_be_typed_words(text: String, broken_letters: String) -> i32 {\\n        let broken_hash = broken_letters\\n            .into_bytes()\\n            .iter()\\n            .fold([false; 26], |mut acc, &b| {\\n                acc[(b - b\\'a\\') as usize] = true;\\n                acc\\n            });\\n\\n        text.split_ascii_whitespace()\\n            .filter(|&s| {\\n                s.as_bytes()\\n                    .iter()\\n                    .all(|&b| !broken_hash[(b - b\\'a\\') as usize])\\n            })\\n            .count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_be_typed_words(text: String, broken_letters: String) -> i32 {\\n        let broken_hash = broken_letters\\n            .into_bytes()\\n            .iter()\\n            .fold([false; 26], |mut acc, &b| {\\n                acc[(b - b\\'a\\') as usize] = true;\\n                acc\\n            });\\n\\n        text.split_ascii_whitespace()\\n            .filter(|&s| {\\n                s.as_bytes()\\n                    .iter()\\n                    .all(|&b| !broken_hash[(b - b\\'a\\') as usize])\\n            })\\n            .count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347135,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n      \\n    void jiyan(string s,vector<string>&v){\\n        string st;\\n                \\n        for(auto i:s){\\n            if(i==\\' \\'){\\n                v.push_back(st);\\n                st=\"\";\\n            }\\n            else\\n                st+=i;\\n        }\\n        v.push_back(st);\\n        \\n    }\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,bool>map;\\n        for(auto i:brokenLetters)\\n            map[i]=true;\\n        vector<string>v;\\n        jiyan(text,v);\\n        int k=v.size();\\n        for(auto i:v)\\n            for(auto j:i)\\n                if(map[j]){\\n                    k--;break;\\n                }\\n             \\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      \\n    void jiyan(string s,vector<string>&v){\\n        string st;\\n                \\n        for(auto i:s){\\n            if(i==\\' \\'){\\n                v.push_back(st);\\n                st=\"\";\\n            }\\n            else\\n                st+=i;\\n        }\\n        v.push_back(st);\\n        \\n    }\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,bool>map;\\n        for(auto i:brokenLetters)\\n            map[i]=true;\\n        vector<string>v;\\n        jiyan(text,v);\\n        int k=v.size();\\n        for(auto i:v)\\n            for(auto j:i)\\n                if(map[j]){\\n                    k--;break;\\n                }\\n             \\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345353,
                "title": "easy-and-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String br) {\\n        String ar[]=text.split(\" \");\\n        int c=0,j=0;\\n        while(j<ar.length)\\n            {\\n        for(int i=0;i<br.length();i++)\\n        {\\n            char ch=br.charAt(i);\\n            \\n                if(ar[j].contains(ch+\"\"))\\n                {\\n                    c++;\\n\\n                    break;\\n                }\\n                    \\n            }\\n                 j++;\\n        }\\n        return ar.length-c;\\n        \\n    }\\n}\\n```\\n**Please upvote if you like it :)**\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String br) {\\n        String ar[]=text.split(\" \");\\n        int c=0,j=0;\\n        while(j<ar.length)\\n            {\\n        for(int i=0;i<br.length();i++)\\n        {\\n            char ch=br.charAt(i);\\n            \\n                if(ar[j].contains(ch+\"\"))\\n                {\\n                    c++;\\n\\n                    break;\\n                }\\n                    \\n            }\\n                 j++;\\n        }\\n        return ar.length-c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344929,
                "title": "c-using-stringstream",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char> st(begin(brokenLetters), end(brokenLetters));\\n        \\n        int count = 0;\\n        stringstream ss(text);\\n        \\n        string word;\\n        bool found = true;\\n        while(ss >> word) {\\n            found = true;\\n            for(char &ch : word) {\\n                if(st.find(ch) != end(st)) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if(found) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char> st(begin(brokenLetters), end(brokenLetters));\\n        \\n        int count = 0;\\n        stringstream ss(text);\\n        \\n        string word;\\n        bool found = true;\\n        while(ss >> word) {\\n            found = true;\\n            for(char &ch : word) {\\n                if(st.find(ch) != end(st)) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if(found) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344873,
                "title": "a-few-solutions",
                "content": "Return the count of filtered words from the input `text` which do *not* contain any characters from the array of broken letters `A`, ie. we use an unordered set `X` for O(1) lookups.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun canBeTypedWords(text: String, A: String): Int {\\n        var X = A.toCharArray().toSet()\\n        return text.split(\" \").filter{ it.toCharArray().all{ !X.contains(it) } }.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet canBeTypedWords = (text, A, X = new Set(A)) => text.split(\\' \\').filter(word => word.split(\\'\\').every(c => !X.has(c))).length;\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, A: str) -> int:\\n        X = set(A)\\n        return len([word for word in text.split(\\' \\') if all(c not in X for c in word)])\\n```\\n\\n*C++* (emplace back)\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<char>;\\n    int canBeTypedWords(string text, string A, VS words = {}, int cnt = 0) {\\n        Set X{ A.begin(), A.end() };\\n        istringstream is{ text };\\n        for (string word; is >> word; words.emplace_back(word));\\n        for (auto& word: words)\\n            cnt += all_of(word.begin(), word.end(), [&](auto c) { return X.find(c) == X.end(); });\\n        return cnt;\\n    }\\n};\\n```\\n\\n*C++* (istream iterator)\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<char>;\\n    int canBeTypedWords(string text, string A, VS words = {}, int cnt = 0) {\\n        Set X{ A.begin(), A.end() };\\n        istringstream is{ text };\\n        copy(istream_iterator<string>(is), istream_iterator<string>(), back_inserter(words));\\n        for (auto& word: words)\\n            cnt += all_of(word.begin(), word.end(), [&](auto c) { return X.find(c) == X.end(); });\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun canBeTypedWords(text: String, A: String): Int {\\n        var X = A.toCharArray().toSet()\\n        return text.split(\" \").filter{ it.toCharArray().all{ !X.contains(it) } }.size\\n    }\\n}\\n```\n```\\nlet canBeTypedWords = (text, A, X = new Set(A)) => text.split(\\' \\').filter(word => word.split(\\'\\').every(c => !X.has(c))).length;\\n```\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, A: str) -> int:\\n        X = set(A)\\n        return len([word for word in text.split(\\' \\') if all(c not in X for c in word)])\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<char>;\\n    int canBeTypedWords(string text, string A, VS words = {}, int cnt = 0) {\\n        Set X{ A.begin(), A.end() };\\n        istringstream is{ text };\\n        for (string word; is >> word; words.emplace_back(word));\\n        for (auto& word: words)\\n            cnt += all_of(word.begin(), word.end(), [&](auto c) { return X.find(c) == X.end(); });\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<char>;\\n    int canBeTypedWords(string text, string A, VS words = {}, int cnt = 0) {\\n        Set X{ A.begin(), A.end() };\\n        istringstream is{ text };\\n        copy(istream_iterator<string>(is), istream_iterator<string>(), back_inserter(words));\\n        for (auto& word: words)\\n            cnt += all_of(word.begin(), word.end(), [&](auto c) { return X.find(c) == X.end(); });\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344871,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        #making a list of words from text string\\n        words = text.split()\\n        \\n        #counting total words\\n        res = len(words)\\n        \\n        for word in words:\\n            for brokenLetter in brokenLetters:\\n                \\n                #if the word contains a brokenletter reduce the total count by one\\n                if brokenLetter in word:\\n                    res -= 1\\n                    break\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        #making a list of words from text string\\n        words = text.split()\\n        \\n        #counting total words\\n        res = len(words)\\n        \\n        for word in words:\\n            for brokenLetter in brokenLetters:\\n                \\n                #if the word contains a brokenletter reduce the total count by one\\n                if brokenLetter in word:\\n                    res -= 1\\n                    break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023364,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        count = 0\\n\\n        for word in text.split(\" \"):\\n            check = True\\n            for char in brokenLetters:\\n                if char in word:\\n                    check = False\\n            \\n            if check:\\n                count += 1\\n        \\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        count = 0\\n\\n        for word in text.split(\" \"):\\n            check = True\\n            for char in brokenLetters:\\n                if char in word:\\n                    check = False\\n            \\n            if check:\\n                count += 1\\n        \\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842028,
                "title": "golang",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunc canBeTypedWords(text string, brokenLetters string) int {\\n  badLetters := 0\\n  i := 0\\n  ans := 0\\n\\n  for i < len(text) {\\n    if strings.ContainsAny(brokenLetters, string(text[i])) {\\n      badLetters++\\n    }\\n    if text[i] == 32 || i == len(text)-1 {\\n      if badLetters == 0 {\\n        ans++\\n      }\\n      badLetters = 0\\n    }\\n    i++\\n  }\\n  return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String"
                ],
                "code": "```\\nfunc canBeTypedWords(text string, brokenLetters string) int {\\n  badLetters := 0\\n  i := 0\\n  ans := 0\\n\\n  for i < len(text) {\\n    if strings.ContainsAny(brokenLetters, string(text[i])) {\\n      badLetters++\\n    }\\n    if text[i] == 32 || i == len(text)-1 {\\n      if badLetters == 0 {\\n        ans++\\n      }\\n      badLetters = 0\\n    }\\n    i++\\n  }\\n  return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3645405,
                "title": "easy-beginners-approach",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] temp= text.split(\" \");\\n        HashSet<Integer> set= new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++){\\n            char c= brokenLetters.charAt(i);\\n            for(int j=0;j<temp.length;j++){\\n                \\n                if(temp[j].contains(Character.toString(c))) set.add(j);\\n            }\\n        }\\n\\nreturn temp.length-set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] temp= text.split(\" \");\\n        HashSet<Integer> set= new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++){\\n            char c= brokenLetters.charAt(i);\\n            for(int j=0;j<temp.length;j++){\\n                \\n                if(temp[j].contains(Character.toString(c))) set.add(j);\\n            }\\n        }\\n\\nreturn temp.length-set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573705,
                "title": "maximum-number-of-words-you-can-type-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int i, j, flag=0, count=0;\\n        for(i=0 ; i<text.length() ; i++)\\n        {\\n            if(text[i]==\\' \\' && flag==0)\\n            {\\n                count++;\\n            }\\n            else if(text[i]==\\' \\')\\n            {\\n                flag=0;\\n            }\\n            else if(flag==0)\\n            {\\n                for(j=0 ; j<brokenLetters.length() ; j++)\\n                {\\n                    if(text[i]==brokenLetters[j])\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        if(flag==0)\\n            count++;\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/95d945e2-387e-4255-96b8-951335a2c9fe_1685331837.093088.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int i, j, flag=0, count=0;\\n        for(i=0 ; i<text.length() ; i++)\\n        {\\n            if(text[i]==\\' \\' && flag==0)\\n            {\\n                count++;\\n            }\\n            else if(text[i]==\\' \\')\\n            {\\n                flag=0;\\n            }\\n            else if(flag==0)\\n            {\\n                for(j=0 ; j<brokenLetters.length() ; j++)\\n                {\\n                    if(text[i]==brokenLetters[j])\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        if(flag==0)\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340498,
                "title": "java-using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n   int c=0,ans=0;\\n  for(String s:text.split(\" \")){\\n        ArrayList<Character> aa=new ArrayList<>();\\n        c=0;\\n      for(char ch:s.toCharArray()){\\n         aa.add(ch);\\n      }\\n      for(char ch:brokenLetters.toCharArray()){\\n          if(aa.contains(ch))\\n          c++;\\n      }\\n      if(c==0)\\n      ans++;\\n\\n  }\\n  return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n   int c=0,ans=0;\\n  for(String s:text.split(\" \")){\\n        ArrayList<Character> aa=new ArrayList<>();\\n        c=0;\\n      for(char ch:s.toCharArray()){\\n         aa.add(ch);\\n      }\\n      for(char ch:brokenLetters.toCharArray()){\\n          if(aa.contains(ch))\\n          c++;\\n      }\\n      if(c==0)\\n      ans++;\\n\\n  }\\n  return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221440,
                "title": "python-without-using-set",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ans = 0\\n        \\n        for i in text.split(\" \"):\\n            for j in i:\\n                if j in brokenLetters:\\n                    ans -= 1\\n                    break\\n            ans += 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ans = 0\\n        \\n        for i in text.split(\" \"):\\n            for j in i:\\n                if j in brokenLetters:\\n                    ans -= 1\\n                    break\\n            ans += 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680080,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\n   public:\\n    int canBeTypedWords(string text, string letters) {\\n        bool hash[26] = {0};\\n        int i, count = 0;\\n        for (i = 0; i < letters.size(); i++) hash[letters[i] - \\'a\\'] = true;\\n\\n        bool flag = true;\\n        for (i = 0; i < text.length(); i++) {\\n            if (text[i] == \\' \\') {\\n                if (flag) count++;\\n                flag = true;\\n            } else if (hash[text[i] - \\'a\\'])\\n                flag = false;\\n        }\\n        return i == text.length() && flag ? count + 1 : count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int canBeTypedWords(string text, string letters) {\\n        bool hash[26] = {0};\\n        int i, count = 0;\\n        for (i = 0; i < letters.size(); i++) hash[letters[i] - \\'a\\'] = true;\\n\\n        bool flag = true;\\n        for (i = 0; i < text.length(); i++) {\\n            if (text[i] == \\' \\') {\\n                if (flag) count++;\\n                flag = true;\\n            } else if (hash[text[i] - \\'a\\'])\\n                flag = false;\\n        }\\n        return i == text.length() && flag ? count + 1 : count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645033,
                "title": "cpp-o-n-simple-loop-with-comments-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int brokenLettersIdx [26] = {};\\n        int canTypeWords = 0;\\n\\t\\t// Indexing the broken keys\\n        for (char c : brokenLetters) {\\n            brokenLettersIdx[c-\\'a\\'] = 1;\\n        }\\n\\t\\t\\n\\t\\t// - Looping through words\\n\\t\\t// - For each word, count the number of broken keys\\n\\t\\t// - 1. If number of broken keys == 0\\n\\t\\t// -     Increments canTypeWords by one\\n\\t\\t//-  2. Otherwise continue\\n        for (int i = 0; i < text.length(); i++) {\\n            int brk = 0;\\n            while (i < text.length() && text[i] != \\' \\') {\\n                if (brokenLettersIdx[text[i]-\\'a\\'] == 1) {\\n                    brk++;\\n                }\\n                i++;\\n            }\\n            if (brk == 0) {\\n                canTypeWords++;\\n            }\\n        }\\n        return canTypeWords;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int brokenLettersIdx [26] = {};\\n        int canTypeWords = 0;\\n\\t\\t// Indexing the broken keys\\n        for (char c : brokenLetters) {\\n            brokenLettersIdx[c-\\'a\\'] = 1;\\n        }\\n\\t\\t\\n\\t\\t// - Looping through words\\n\\t\\t// - For each word, count the number of broken keys\\n\\t\\t// - 1. If number of broken keys == 0\\n\\t\\t// -     Increments canTypeWords by one\\n\\t\\t//-  2. Otherwise continue\\n        for (int i = 0; i < text.length(); i++) {\\n            int brk = 0;\\n            while (i < text.length() && text[i] != \\' \\') {\\n                if (brokenLettersIdx[text[i]-\\'a\\'] == 1) {\\n                    brk++;\\n                }\\n                i++;\\n            }\\n            if (brk == 0) {\\n                canTypeWords++;\\n            }\\n        }\\n        return canTypeWords;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604394,
                "title": "c-beginner-friendly-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int len1=text.length();\\n        int len2=brokenLetters.length();\\n        unordered_map<char,int> mp;\\n        int count=0;\\n        int flag=-1;\\n        int point=0;\\n        for(int i=0;i<len2;i++)\\n        {\\n            mp[brokenLetters[i]]++;\\n        }\\n        for(int i=0;i<len1;i++)\\n        {\\n            if(mp.find(text[i])!=mp.end())\\n                flag=1;\\n            if(text[i]==\\' \\'&& flag==-1)\\n            {\\n                flag=-1;\\n                count++;\\n            }\\n            else if(text[i]==\\' \\'&& flag==1)\\n            {\\n                flag=-1;\\n            }\\n        }\\n        if(flag==-1)\\n            count++;\\n        return count;\\n    }\\n};\\n```\\nplease upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int len1=text.length();\\n        int len2=brokenLetters.length();\\n        unordered_map<char,int> mp;\\n        int count=0;\\n        int flag=-1;\\n        int point=0;\\n        for(int i=0;i<len2;i++)\\n        {\\n            mp[brokenLetters[i]]++;\\n        }\\n        for(int i=0;i<len1;i++)\\n        {\\n            if(mp.find(text[i])!=mp.end())\\n                flag=1;\\n            if(text[i]==\\' \\'&& flag==-1)\\n            {\\n                flag=-1;\\n                count++;\\n            }\\n            else if(text[i]==\\' \\'&& flag==1)\\n            {\\n                flag=-1;\\n            }\\n        }\\n        if(flag==-1)\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572527,
                "title": "c-without-map-most-optimal-code",
                "content": "```\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<bool> broken(26, false);\\n        for(int i=0; i<brokenLetters.size(); i++){\\n            broken[brokenLetters[i] - \\'a\\'] = true;\\n        }\\n        bool t = true;\\n        int ans=0;\\n        \\n        for(int i=0; i<text.size(); i++){\\n            \\n            if(isspace(text[i])){\\n                if(t == true) ans++;\\n                 t = true;\\n            }\\n            else if(broken[text[i] - \\'a\\']) t = false;          \\n        }\\n        if(t) ans++;\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<bool> broken(26, false);\\n        for(int i=0; i<brokenLetters.size(); i++){\\n            broken[brokenLetters[i] - \\'a\\'] = true;\\n        }\\n        bool t = true;\\n        int ans=0;\\n        \\n        for(int i=0; i<text.size(); i++){\\n            \\n            if(isspace(text[i])){\\n                if(t == true) ans++;\\n                 t = true;\\n            }\\n            else if(broken[text[i] - \\'a\\']) t = false;          \\n        }\\n        if(t) ans++;\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563220,
                "title": "i-bet-you-will-not-find-this-solution-anywhere",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        text+= \" \";\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        for(int i = 0;i<brokenLetters.length();i++){\\n            hm.put(brokenLetters.charAt(i),hm.getOrDefault(brokenLetters.charAt(i),0)+1);\\n        }\\n        int count = 0;\\n        int ans = 0;\\n        for(int i = 0;i<text.length();i++){\\n            char ch = text.charAt(i);\\n            if(hm.containsKey(ch)){\\n                count++;\\n            }\\n            if((ch == \\' \\' && count == 0) ||(text.charAt(i) == \\' \\') && (count == 0)){\\n                ans+= 1;\\n            }\\n            if(ch == \\' \\' && count!=0){\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        text+= \" \";\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        for(int i = 0;i<brokenLetters.length();i++){\\n            hm.put(brokenLetters.charAt(i),hm.getOrDefault(brokenLetters.charAt(i),0)+1);\\n        }\\n        int count = 0;\\n        int ans = 0;\\n        for(int i = 0;i<text.length();i++){\\n            char ch = text.charAt(i);\\n            if(hm.containsKey(ch)){\\n                count++;\\n            }\\n            if((ch == \\' \\' && count == 0) ||(text.charAt(i) == \\' \\') && (count == 0)){\\n                ans+= 1;\\n            }\\n            if(ch == \\' \\' && count!=0){\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510079,
                "title": "python-solution-with-sets",
                "content": "\\n\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ans = 0\\n        brSet = set(brokenLetters)\\n        for w in text.split():\\n            if brSet.isdisjoint(set(w)):\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ans = 0\\n        brSet = set(brokenLetters)\\n        for w in text.split():\\n            if brSet.isdisjoint(set(w)):\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455654,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        text+=\" \";\\n        string res;\\n        bool istrue;\\n        vector<string>sk;\\n        for(auto i:text){\\n            if(isalpha(i)){\\n                res+=i;\\n            }\\n            else{\\n                for(auto j:brokenLetters){\\n                    auto found=res.find(j);\\n                    if(found!=string::npos){\\n                        istrue=false;\\n                        break;\\n                    }\\n                    else{\\n                        istrue=true;\\n                    }\\n                }\\n                if(istrue==true){\\n                    sk.push_back(res);\\n                }\\n                \\n                res.clear();\\n            }\\n        }\\n        \\n  \\n        count=sk.size();\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        text+=\" \";\\n        string res;\\n        bool istrue;\\n        vector<string>sk;\\n        for(auto i:text){\\n            if(isalpha(i)){\\n                res+=i;\\n            }\\n            else{\\n                for(auto j:brokenLetters){\\n                    auto found=res.find(j);\\n                    if(found!=string::npos){\\n                        istrue=false;\\n                        break;\\n                    }\\n                    else{\\n                        istrue=true;\\n                    }\\n                }\\n                if(istrue==true){\\n                    sk.push_back(res);\\n                }\\n                \\n                res.clear();\\n            }\\n        }\\n        \\n  \\n        count=sk.size();\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373075,
                "title": "typescript-javascript-a-one-liner-with-fastest-runtime-100-00",
                "content": "As you\\'re having multiple characters to check a condition against, consider using *Array.prototype.some()*.\\n```\\nfunction canBeTypedWords(text: string, brokenLetters: string): number {\\n  return text.split(\\' \\').reduce((prev, cur) => brokenLetters.split(\\'\\').some(a => cur.indexOf(a) > -1) ? prev : prev + 1, 0);\\n}\\n```\\nLet me know if you have any questions. Please hit upvote if you find it useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nfunction canBeTypedWords(text: string, brokenLetters: string): number {\\n  return text.split(\\' \\').reduce((prev, cur) => brokenLetters.split(\\'\\').some(a => cur.indexOf(a) > -1) ? prev : prev + 1, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2369790,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int n=brokenLetters.size();\\n        int bl[26]={0};\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bl[brokenLetters[i]-\\'a\\']++;\\n        }\\n        int flag=0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n                if(text[i]!=\\' \\' && bl[text[i]-\\'a\\']==1)\\n                {\\n                    flag=1;\\n                }\\n                else if(text[i]==\\' \\')\\n                {\\n                    if(flag==0)\\n                    {\\n                        count++;\\n                    }\\n                    flag=0;\\n                }\\n        }\\n        if(flag==0)\\n        {\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int n=brokenLetters.size();\\n        int bl[26]={0};\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bl[brokenLetters[i]-\\'a\\']++;\\n        }\\n        int flag=0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n                if(text[i]!=\\' \\' && bl[text[i]-\\'a\\']==1)\\n                {\\n                    flag=1;\\n                }\\n                else if(text[i]==\\' \\')\\n                {\\n                    if(flag==0)\\n                    {\\n                        count++;\\n                    }\\n                    flag=0;\\n                }\\n        }\\n        if(flag==0)\\n        {\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276401,
                "title": "c-sets-logical-approach",
                "content": "![image](https://assets.leetcode.com/users/images/4dcc4554-7549-48fe-bdc7-b97fa0e53493_1657706859.8209372.png)\\n\\n**n==bl.size() && m==t.size()\\nT->O(n * logn +m * log n) && S->O(n) **\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint canBeTypedWords(string t, string bl) {\\n\\t\\t\\tset<char>s;\\n\\t\\t\\tbool f=true;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(auto i:bl)s.insert(i);\\n\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\tif(t[i]==\\' \\'){\\n\\t\\t\\t\\t\\tif(f)count++;\\n\\t\\t\\t\\t\\tf=true;\\n\\t\\t\\t\\t}    \\n\\t\\t\\t\\tif(s.find(t[i])!=s.end())f=false;\\n\\t\\t\\t}\\n\\t\\t\\tif(f)count++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint canBeTypedWords(string t, string bl) {\\n\\t\\t\\tset<char>s;\\n\\t\\t\\tbool f=true;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(auto i:bl)s.insert(i);\\n\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\tif(t[i]==\\' \\'){\\n\\t\\t\\t\\t\\tif(f)count++;\\n\\t\\t\\t\\t\\tf=true;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2208909,
                "title": "python-1-liner",
                "content": "```py\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return len([i for i in text.split(\\' \\') if len(set(i).intersection(brokenLetters))==0])\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return len([i for i in text.split(\\' \\') if len(set(i).intersection(brokenLetters))==0])\\n",
                "codeTag": "Java"
            },
            {
                "id": 2152951,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum (1 for word in text.split() if all(char not in list(brokenLetters) for char in word))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum (1 for word in text.split() if all(char not in list(brokenLetters) for char in word))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125075,
                "title": "javascript-2-liners-regexp",
                "content": "**Long Vers.**\\n```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let regexp=\"[\"+brokenLetters+\"]\\\\+\"\\n    let word=text.split(\" \"), count=0;\\n    for(let i=0; i<word.length; i++){\\n        let work=true;\\n\\t\\t// if matches, means word[i] contains malfunction letters.\\n        if(word[i].match(regexp)){work=false};\\n        if(work){count++};\\n    }\\n    return count;\\n};\\n```\\n\\n**Short Vers.**\\n```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let word=text.split(\" \");\\n\\t// accumulate wordcount that doesn\\'t match.\\n    return word.reduce((acc, curr)=>acc+!curr.match(\"[\"+brokenLetters+\"]\\\\+\"), 0);\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let regexp=\"[\"+brokenLetters+\"]\\\\+\"\\n    let word=text.split(\" \"), count=0;\\n    for(let i=0; i<word.length; i++){\\n        let work=true;\\n\\t\\t// if matches, means word[i] contains malfunction letters.\\n        if(word[i].match(regexp)){work=false};\\n        if(work){count++};\\n    }\\n    return count;\\n};\\n```\n```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let word=text.split(\" \");\\n\\t// accumulate wordcount that doesn\\'t match.\\n    return word.reduce((acc, curr)=>acc+!curr.match(\"[\"+brokenLetters+\"]\\\\+\"), 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2094848,
                "title": "java-solution-very-easy",
                "content": "```\\nclass Solution {\\n\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        HashSet<Character> set = new HashSet<>();\\n        for (int i = 0; i < brokenLetters.length(); i++) set.add(brokenLetters.charAt(i));\\n        String res[] = text.split(\" \");\\n        for (String s : res) {\\n            for (char ch : s.toCharArray()) {\\n                if (set.contains(ch)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res.length - count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        HashSet<Character> set = new HashSet<>();\\n        for (int i = 0; i < brokenLetters.length(); i++) set.add(brokenLetters.charAt(i));\\n        String res[] = text.split(\" \");\\n        for (String s : res) {\\n            for (char ch : s.toCharArray()) {\\n                if (set.contains(ch)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res.length - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093968,
                "title": "c-simple-fast-solution-0ms",
                "content": "Hi guys! \\nHere\\'s my solution for this problem. It\\'s pretty straight forward and the code is commented in detail. \\nIt works like a charm for space & time complexity (0ms and 6mb), so I decided to share it.\\nHope you enjoy! \\n\\n```\\nint canBeTypedWords(string text, string broken) {\\n        \\n        //as every word is separated by a single space, the total number of words is the number of spaces + 1\\n        int n_words = count(text.begin(), text.end(), \\' \\')+1; \\n        \\n        //we iterate through all of the chars in the text string\\n        for(int i = 0; i < text.length(); i++){\\n            \\n            //and for all of the chars in the broken string\\n            for(int j = 0;  j < broken.length(); j++)\\n                \\n                if(text[i] == broken[j]){\\n                    //if any chars is in common we reduce the number of words by 1 \\n                    n_words--; \\n                    \\n                    //and we iterate i until it finds the next word or the end of the string.\\n                    for(; i < text.length() && text[i] != \\' \\'; i++);\\n                }\\n                    \\n        }\\n        //we just return the number of words left. \\n        return n_words;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint canBeTypedWords(string text, string broken) {\\n        \\n        //as every word is separated by a single space, the total number of words is the number of spaces + 1\\n        int n_words = count(text.begin(), text.end(), \\' \\')+1; \\n        \\n        //we iterate through all of the chars in the text string\\n        for(int i = 0; i < text.length(); i++){\\n            \\n            //and for all of the chars in the broken string\\n            for(int j = 0;  j < broken.length(); j++)\\n                \\n                if(text[i] == broken[j]){\\n                    //if any chars is in common we reduce the number of words by 1 \\n                    n_words--; \\n                    \\n                    //and we iterate i until it finds the next word or the end of the string.\\n                    for(; i < text.length() && text[i] != \\' \\'; i++);\\n                }\\n                    \\n        }\\n        //we just return the number of words left. \\n        return n_words;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084515,
                "title": "java-using-set",
                "content": "```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n        int i=0;\\n        String[] arr=text.split(\" \");\\n        Set<Character>st=new HashSet<>();\\n        for(char c:brokenLetters.toCharArray()){\\n\\n            st.add(c);\\n        }\\n        for(String s:arr){\\n\\n            if(cont(s,st)){\\n\\n                i++;\\n            }\\n        }\\n        return i;\\n        \\n    }\\n    boolean cont(String s,Set<Character>st){\\n\\n        for(char c:s.toCharArray()){\\n\\n            if(st.contains(c)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n        int i=0;\\n        String[] arr=text.split(\" \");\\n        Set<Character>st=new HashSet<>();\\n        for(char c:brokenLetters.toCharArray()){\\n\\n            st.add(c);\\n        }\\n        for(String s:arr){\\n\\n            if(cont(s,st)){\\n\\n                i++;\\n            }\\n        }\\n        return i;\\n        \\n    }\\n    boolean cont(String s,Set<Character>st){\\n\\n        for(char c:s.toCharArray()){\\n\\n            if(st.contains(c)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2054075,
                "title": "java-easy-hash-map-count-break",
                "content": "**Brute Force**\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] splt = text.split(\" \");\\n        for(String s :splt){\\n            boolean flag = true;\\n            for(char c : brokenLetters.toCharArray()){\\n                if(s.contains(Character.toString(c))){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n```java\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int result = 0;\\n        int count = 0;\\n        String[] splt = text.split(\" \");\\n        Map<Character,Integer> map = new HashMap<>();\\n\\t\\t// Store broken Letter in the hashmap\\n        for(Character c : brokenLetters.toCharArray()){\\n            map.put(c, 1);\\n        }\\n\\t\\t// pick one by one String and compare with the map\\n        for(String s : splt){\\n            for(int i = 0; i < s.length(); i++){\\n                char c = s.charAt(i);\\n\\t\\t\\t\\t// if break letter contains then break loop \\n                if(map.containsKey(c)){\\n                    count = 0;\\n                    break;\\n                }else{\\n                    count++;\\n                }\\n            }\\n\\t\\t\\t// check length of word and count is same or not.\\n\\t\\t\\t// if same count 1 with the result\\n            if(count == s.length()){\\n                result++;\\n                count = 0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**More Optimized**\\n\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] splt = text.split(\" \");\\n        int count  = 0;\\n        Map<Character,Integer> map = new HashMap<>();\\n        \\n        for(Character c : brokenLetters.toCharArray()){\\n            map.put(c,1);\\n        }\\n\\n        for(String s : splt){\\n            boolean flag = true;\\n            for(int i = 0;i < s.length(); i++){\\n                if(map.containsKey(s.charAt(i))){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                count++;\\n            }\\n        }\\n        return count;\\n        }  \\n    }",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] splt = text.split(\" \");\\n        for(String s :splt){\\n            boolean flag = true;\\n            for(char c : brokenLetters.toCharArray()){\\n                if(s.contains(Character.toString(c))){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int result = 0;\\n        int count = 0;\\n        String[] splt = text.split(\" \");\\n        Map<Character,Integer> map = new HashMap<>();\\n\\t\\t// Store broken Letter in the hashmap\\n        for(Character c : brokenLetters.toCharArray()){\\n            map.put(c, 1);\\n        }\\n\\t\\t// pick one by one String and compare with the map\\n        for(String s : splt){\\n            for(int i = 0; i < s.length(); i++){\\n                char c = s.charAt(i);\\n\\t\\t\\t\\t// if break letter contains then break loop \\n                if(map.containsKey(c)){\\n                    count = 0;\\n                    break;\\n                }else{\\n                    count++;\\n                }\\n            }\\n\\t\\t\\t// check length of word and count is same or not.\\n\\t\\t\\t// if same count 1 with the result\\n            if(count == s.length()){\\n                result++;\\n                count = 0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886112,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        HashSet<Character>hs=new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++)\\n            hs.add(brokenLetters.charAt(i));\\n        String s=\"\";\\n        int v=0,count=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            char ch=text.charAt(i);\\n            if(hs.contains(ch))\\n                v=1;\\n            if(ch==\\' \\')\\n            {\\n                if(v==0)\\n                    ++count;\\n                v=0;\\n            }\\n        }\\n        if(v==0)\\n            ++count;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        HashSet<Character>hs=new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++)\\n            hs.add(brokenLetters.charAt(i));\\n        String s=\"\";\\n        int v=0,count=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            char ch=text.charAt(i);\\n            if(hs.contains(ch))\\n                v=1;\\n            if(ch==\\' \\')\\n            {\\n                if(v==0)\\n                    ++count;\\n                v=0;\\n            }\\n        }\\n        if(v==0)\\n            ++count;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845569,
                "title": "c-simple-code-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>uset;\\n        for(char c : brokenLetters) uset.insert(c);\\n        int ans = 0;\\n        int isBroken = 0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(uset.find(text[i]) != uset.end())\\n                isBroken = 1;\\n            if(text[i] == \\' \\' || i == text.size()-1)\\n            {\\n                if(isBroken) isBroken = 0;\\n                else ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>uset;\\n        for(char c : brokenLetters) uset.insert(c);\\n        int ans = 0;\\n        int isBroken = 0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(uset.find(text[i]) != uset.end())\\n                isBroken = 1;\\n            if(text[i] == \\' \\' || i == text.size()-1)\\n            {\\n                if(isBroken) isBroken = 0;\\n                else ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717468,
                "title": "beginner-friendly-java-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String words[] = text.split(\" \");\\n        int count = 0;\\n        for(String word : words){\\n            for(int i=0; i<word.length(); i++){\\n                if(brokenLetters.contains(word.charAt(i) + \"\")){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return words.length - count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String words[] = text.split(\" \");\\n        int count = 0;\\n        for(String word : words){\\n            for(int i=0; i<word.length(); i++){\\n                if(brokenLetters.contains(word.charAt(i) + \"\")){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return words.length - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684385,
                "title": "rust-set-filter",
                "content": "```rust\\nimpl Solution {\\n    pub fn can_be_typed_words(text: String, broken_letters: String) -> i32 {\\n        let set = broken_letters.chars().collect::<std::collections::HashSet<_>>();\\n        \\n        text.split_whitespace().filter(|word| word.chars().all(|c| !set.contains(&c))).count() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn can_be_typed_words(text: String, broken_letters: String) -> i32 {\\n        let set = broken_letters.chars().collect::<std::collections::HashSet<_>>();\\n        \\n        text.split_whitespace().filter(|word| word.chars().all(|c| !set.contains(&c))).count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1673731,
                "title": "2-c-solutions-using-string-stream-class-and-hashmaps",
                "content": "*The time complexity of both the solutions is O(text.size())*\\n\\n**Solution 1: Using Simple string methods and maps**\\n*SC = O(brokenletters.size())*\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>us(brokenLetters.begin(), brokenLetters.end());\\n        int ans = 0;\\n        int i = 0;\\n        \\n        while(i<text.size()){\\n            int flag = true;\\n            while(i<text.size() and text[i] !=\\' \\'){\\n                if(us.find(text[i]) != us.end()){\\n                    flag = false;\\n                }\\n                i++;\\n            }\\n            \\n            if(flag){\\n                ans++;\\n            }\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution 2: Using Stringstream class and map**\\n*SC = O(text.size() + brokenLetter.size())*\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>us(brokenLetters.begin(), brokenLetters.end());\\n        int ans = 0;\\n        \\n        stringstream str(text);\\n        \\n        while(1){\\n            string word;\\n            getline(str, word, \\' \\');\\n            \\n            if(word.empty()){\\n                break;\\n            }\\n            \\n            else{\\n                int flag = true;\\n                for(char x: word){\\n                    if(us.find(x) != us.end()){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag){\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n***Feel free to ask any doubts regarding the second approach and do upvote if you liked it***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>us(brokenLetters.begin(), brokenLetters.end());\\n        int ans = 0;\\n        int i = 0;\\n        \\n        while(i<text.size()){\\n            int flag = true;\\n            while(i<text.size() and text[i] !=\\' \\'){\\n                if(us.find(text[i]) != us.end()){\\n                    flag = false;\\n                }\\n                i++;\\n            }\\n            \\n            if(flag){\\n                ans++;\\n            }\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>us(brokenLetters.begin(), brokenLetters.end());\\n        int ans = 0;\\n        \\n        stringstream str(text);\\n        \\n        while(1){\\n            string word;\\n            getline(str, word, \\' \\');\\n            \\n            if(word.empty()){\\n                break;\\n            }\\n            \\n            else{\\n                int flag = true;\\n                for(char x: word){\\n                    if(us.find(x) != us.end()){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag){\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665398,
                "title": "c-runtime-0-ms-memory-usage-7-2-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int ret = 0;\\n        bool isBroken;\\n        std::vector<string> words;\\n        std::vector<char> chars;\\n        split(words, text);\\n        for(char& b : brokenLetters)\\n            chars.push_back(b);\\n        \\n        for(string& w : words) {\\n            isBroken = false;\\n            for(char& s : w) {\\n                if (isBroken)\\n                    break;\\n                for(char& c : chars) {\\n                    if(c==s) {\\n                        ret++;\\n                        isBroken = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return words.size()-ret;\\n    }\\n    void split(vector<string>& words, string& text){\\n        string tmp;\\n        for(int i=0; i<text.size(); i++){\\n            if(text[i] != \\' \\')\\n                tmp+=text[i];\\n            else{\\n                words.push_back(tmp);\\n                tmp=\"\";\\n            }\\n        }\\n        words.push_back(tmp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int ret = 0;\\n        bool isBroken;\\n        std::vector<string> words;\\n        std::vector<char> chars;\\n        split(words, text);\\n        for(char& b : brokenLetters)\\n            chars.push_back(b);\\n        \\n        for(string& w : words) {\\n            isBroken = false;\\n            for(char& s : w) {\\n                if (isBroken)\\n                    break;\\n                for(char& c : chars) {\\n                    if(c==s) {\\n                        ret++;\\n                        isBroken = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return words.size()-ret;\\n    }\\n    void split(vector<string>& words, string& text){\\n        string tmp;\\n        for(int i=0; i<text.size(); i++){\\n            if(text[i] != \\' \\')\\n                tmp+=text[i];\\n            else{\\n                words.push_back(tmp);\\n                tmp=\"\";\\n            }\\n        }\\n        words.push_back(tmp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645193,
                "title": "java-runtime-2ms-faster-than-80-2",
                "content": "Approach:\\n1. Use inner for loop \\'j\\' to check if it reached the end of \\'brokenLetters\\' string. It means that the current word being checked from \\'words[]\\', doesnot have any of the characters from broken letters.\\nThen, increment count for each iteration.\\n2. Count represents the count of words that have passed the check. Hence, return \\'count\\' as output.\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {        \\n        String words[] = text.split(\" \");\\n        if (brokenLetters.length() == 0) {\\n              return words.length;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < brokenLetters.length(); j++) {\\n              if (words[i].indexOf(brokenLetters.charAt(j)) != -1){\\n                  break;\\n              }\\n              if (j == brokenLetters.length() - 1){\\n                  count++;\\n              }\\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {        \\n        String words[] = text.split(\" \");\\n        if (brokenLetters.length() == 0) {\\n              return words.length;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < brokenLetters.length(); j++) {\\n              if (words[i].indexOf(brokenLetters.charAt(j)) != -1){\\n                  break;\\n              }\\n              if (j == brokenLetters.length() - 1){\\n                  count++;\\n              }\\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619928,
                "title": "faster-than-97-24ms-python-3",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        for word in text.split():\\n            for ch in brokenLetters:\\n                if ch in word:\\n                    break\\n            else:\\n                res+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        for word in text.split():\\n            for ch in brokenLetters:\\n                if ch in word:\\n                    break\\n            else:\\n                res+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588371,
                "title": "python-easy-solution-with-explanation",
                "content": "Here in this code we first break the text sentence into single words and store it in a list .\\nThen we iterate over every word from that list , and check if any letter from that particular word lies in the brokenLetters or not .\\nIf any letter does not lie from that word in the brokenLetters string then we increase the count value and return the count value at the end .\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        l=list(map(str,text.split()))\\n        count=0\\n        for i in l:\\n            flag=True\\n            for j in i:\\n                if j in brokenLetters:\\n                    flag=False\\n                    break\\n            if flag==True:\\n                count+=1\\n        return(count)\\n```\\nIf u understood the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        l=list(map(str,text.split()))\\n        count=0\\n        for i in l:\\n            flag=True\\n            for j in i:\\n                if j in brokenLetters:\\n                    flag=False\\n                    break\\n            if flag==True:\\n                count+=1\\n        return(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486175,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        HashSet<Character> set = new HashSet<>();\\n        for (char c : brokenLetters.toCharArray())\\n            set.add(c);\\n        \\n        String[] subText = text.split(\" \");\\n        for (String singleText : subText) {\\n            int check = 0;\\n            for (char c : singleText.toCharArray()) {\\n                if (set.contains(c)) {\\n                    check = 1;\\n                    break;\\n                } \\n            }\\n            if (check == 0)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        HashSet<Character> set = new HashSet<>();\\n        for (char c : brokenLetters.toCharArray())\\n            set.add(c);\\n        \\n        String[] subText = text.split(\" \");\\n        for (String singleText : subText) {\\n            int check = 0;\\n            for (char c : singleText.toCharArray()) {\\n                if (set.contains(c)) {\\n                    check = 1;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1482884,
                "title": "java-o-n-2",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String words[] = text.split(\" \");\\n        char bks[] = brokenLetters.toCharArray();\\n        int count = words.length;\\n        \\n        for(int i=0;i<bks.length;i++)\\n            for(int j=0;j<words.length;j++)\\n                if(words[j].indexOf(bks[i]) != -1){\\n                    words[j] = \"\";\\n                    count--;\\n                }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String words[] = text.split(\" \");\\n        char bks[] = brokenLetters.toCharArray();\\n        int count = words.length;\\n        \\n        for(int i=0;i<bks.length;i++)\\n            for(int j=0;j<words.length;j++)\\n                if(words[j].indexOf(bks[i]) != -1){\\n                    words[j] = \"\";\\n                    count--;\\n                }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481620,
                "title": "easy-java-solution",
                "content": "***please upvote if you find this helpful.***\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        \\n        int count = 0;\\n        String[] arr = text.split(\" \");\\n        HashSet<Character> hs = new HashSet<>();\\n        \\n        for(int i=0;i<brokenLetters.length();i++) {\\n            hs.add(brokenLetters.charAt(i));\\n        }\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            \\n            String str = arr[i];\\n            boolean canForm = true;\\n            \\n            for(int j=0;j<str.length();j++) {\\n                \\n                if(hs.contains(str.charAt(j))) {\\n                 canForm = false;\\n                 }\\n            \\n                if(j == str.length()-1 && canForm) {\\n                  count++;\\n                  }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        \\n        int count = 0;\\n        String[] arr = text.split(\" \");\\n        HashSet<Character> hs = new HashSet<>();\\n        \\n        for(int i=0;i<brokenLetters.length();i++) {\\n            hs.add(brokenLetters.charAt(i));\\n        }\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            \\n            String str = arr[i];\\n            boolean canForm = true;\\n            \\n            for(int j=0;j<str.length();j++) {\\n                \\n                if(hs.contains(str.charAt(j))) {\\n                 canForm = false;\\n                 }\\n            \\n                if(j == str.length()-1 && canForm) {\\n                  count++;\\n                  }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475917,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String arr[] = text.split(\" \");\\n        for(String s:arr) {\\n            for(char c:brokenLetters.toCharArray()) {\\n                if(s.contains(Character.toString(c))) {\\n                    count++;\\n                    break;\\n                }     \\n            }\\n        }\\n        return arr.length - count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String arr[] = text.split(\" \");\\n        for(String s:arr) {\\n            for(char c:brokenLetters.toCharArray()) {\\n                if(s.contains(Character.toString(c))) {\\n                    count++;\\n                    break;\\n                }     \\n            }\\n        }\\n        return arr.length - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472671,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function (text, brokenLetters) {\\n  let a = text.split(\" \");\\n  let b = brokenLetters.split(\"\");\\n  let c = new Set();\\n\\n  for (let i = 0; i < a.length; i++) {\\n    for (let j = 0; j < b.length; j++) {\\n      if (a[i].includes(b[j])) {\\n        c.add(i);\\n      }\\n    }\\n  }\\n\\n  return a.length - c.size;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function (text, brokenLetters) {\\n  let a = text.split(\" \");\\n  let b = brokenLetters.split(\"\");\\n  let c = new Set();\\n\\n  for (let i = 0; i < a.length; i++) {\\n    for (let j = 0; j < b.length; j++) {\\n      if (a[i].includes(b[j])) {\\n        c.add(i);\\n      }\\n    }\\n  }\\n\\n  return a.length - c.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461200,
                "title": "javascript-without-array-iterate-over-string",
                "content": "Felt like doing this one without the usual `.split(\\' \\')`. \\n\\n```\\n    let wordCount = 0\\n    let hasBroken = false\\n    let word = \\'\\'\\n    \\n    for(let i = 0; i < text.length; i++) {\\n        if(text[i] !== \\' \\') {\\n            word += text[i]\\n            \\n            if(!hasBroken && brokenLetters.includes(text[i])) {\\n                hasBroken = true\\n            }\\n            \\n            if(i < text.length - 1) {\\n                continue\\n            }\\n        }\\n        \\n        if(word.length && !hasBroken) {\\n            wordCount++\\n        }\\n        \\n        word = \\'\\'\\n        hasBroken = false\\n    }\\n    \\n    return wordCount\\n```",
                "solutionTags": [],
                "code": "```\\n    let wordCount = 0\\n    let hasBroken = false\\n    let word = \\'\\'\\n    \\n    for(let i = 0; i < text.length; i++) {\\n        if(text[i] !== \\' \\') {\\n            word += text[i]\\n            \\n            if(!hasBroken && brokenLetters.includes(text[i])) {\\n                hasBroken = true\\n            }\\n            \\n            if(i < text.length - 1) {\\n                continue\\n            }\\n        }\\n        \\n        if(word.length && !hasBroken) {\\n            wordCount++\\n        }\\n        \\n        word = \\'\\'\\n        hasBroken = false\\n    }\\n    \\n    return wordCount\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1443923,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        List<String> list=new ArrayList<>();\\n\\t\\tString[] textSplit= text.split(\" \");\\n\\t\\tfor (String x : textSplit) {\\n\\t\\t\\tfor(char c:brokenLetters.toCharArray()) {\\n\\t\\t\\t\\tint index=x.indexOf(c);\\n\\t\\t\\t\\tif(index!=-1) {\\n\\t\\t\\t\\t\\tlist.add(x);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return Math.abs(list.size()-textSplit.length);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        List<String> list=new ArrayList<>();\\n\\t\\tString[] textSplit= text.split(\" \");\\n\\t\\tfor (String x : textSplit) {\\n\\t\\t\\tfor(char c:brokenLetters.toCharArray()) {\\n\\t\\t\\t\\tint index=x.indexOf(c);\\n\\t\\t\\t\\tif(index!=-1) {\\n\\t\\t\\t\\t\\tlist.add(x);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return Math.abs(list.size()-textSplit.length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442067,
                "title": "java-solution-without-string-methods-7ms-with-string-methods-1ms",
                "content": "Without string methods\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int table[] = new int[26];\\n        \\n        for(int i=0; i<brokenLetters.length(); ++i)\\n            table[brokenLetters.charAt(i) % 97]++;\\n        \\n        int len = 0, i = 0, k = 0, ans = 0;\\n        \\n        while(i < text.length()) {\\n            if(text.charAt(i) == \\' \\') {\\n                if(len == i-k)\\n                    ans++;\\n\\n                k = i+1;\\n                len = 0;\\n            }\\n                \\n            else if(table[text.charAt(i) % 97] == 0)\\n                len++;\\n            \\n            i++;\\n        }\\n        \\n        if(len == i-k)\\n            ans++;\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nWith string methods\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {        \\n        char temp[] = brokenLetters.toCharArray();\\n        int ans = 0;\\n        \\n        for(String str : text.split(\" \")) {\\n            boolean flag = false;\\n            \\n            for(int i=0; i<temp.length; ++i) {\\n                if(str.indexOf(temp[i]) >= 0) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(!flag)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int table[] = new int[26];\\n        \\n        for(int i=0; i<brokenLetters.length(); ++i)\\n            table[brokenLetters.charAt(i) % 97]++;\\n        \\n        int len = 0, i = 0, k = 0, ans = 0;\\n        \\n        while(i < text.length()) {\\n            if(text.charAt(i) == \\' \\') {\\n                if(len == i-k)\\n                    ans++;\\n\\n                k = i+1;\\n                len = 0;\\n            }\\n                \\n            else if(table[text.charAt(i) % 97] == 0)\\n                len++;\\n            \\n            i++;\\n        }\\n        \\n        if(len == i-k)\\n            ans++;\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {        \\n        char temp[] = brokenLetters.toCharArray();\\n        int ans = 0;\\n        \\n        for(String str : text.split(\" \")) {\\n            boolean flag = false;\\n            \\n            for(int i=0; i<temp.length; ++i) {\\n                if(str.indexOf(temp[i]) >= 0) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(!flag)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431260,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ls,c=text.split(),0\\n        for i in ls:\\n            for j in brokenLetters:\\n                if j in i:\\n\\t\\t\\t\\t\\tbreak\\n            else:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ls,c=text.split(),0\\n        for i in ls:\\n            for j in brokenLetters:\\n                if j in i:\\n\\t\\t\\t\\t\\tbreak\\n            else:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406833,
                "title": "java-hash-set-simple-easysolution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        HashSet<Character>set= new HashSet<>();\\n        for(char c:brokenLetters.toCharArray())\\n            set.add(c);\\n        \\n        text+=\" \";\\n        String[]arr= text.split(\" \");\\n        int res=0;\\n        for(var s:arr)\\n        {\\n            int c=0;\\n            for(var ch:s.toCharArray())\\n            {\\n                if(set.contains(ch))\\n                {c=1;\\n                 break;}\\n            }\\n            if(c==0)\\n                res++;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        HashSet<Character>set= new HashSet<>();\\n        for(char c:brokenLetters.toCharArray())\\n            set.add(c);\\n        \\n        text+=\" \";\\n        String[]arr= text.split(\" \");\\n        int res=0;\\n        for(var s:arr)\\n        {\\n            int c=0;\\n            for(var ch:s.toCharArray())\\n            {\\n                if(set.contains(ch))\\n                {c=1;\\n                 break;}",
                "codeTag": "Java"
            },
            {
                "id": 1399715,
                "title": "java-easy-to-understand",
                "content": "```\\n public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenSet = new HashSet<>();\\n        String[] words = text.split(\" \");\\n        int count = words.length;\\n        \\n        if(brokenLetters.length() == 0) {\\n            return count;\\n        }\\n        \\n        for(char ch: brokenLetters.toCharArray()) {\\n            brokenSet.add(ch);\\n        }\\n        \\n        for(String word: words) {\\n            for(char ch: word.toCharArray()) {\\n                if(brokenSet.contains(ch)) {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\t\\n\\t\\n\\t\\n\\tTime Complexity - O(m * n) (m is the size of text and n is the size of word with maximum length in text)\\n\\tSpace complexity - O(n) - n is the size of brokenLetters",
                "solutionTags": [],
                "code": "```\\n public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenSet = new HashSet<>();\\n        String[] words = text.split(\" \");\\n        int count = words.length;\\n        \\n        if(brokenLetters.length() == 0) {\\n            return count;\\n        }\\n        \\n        for(char ch: brokenLetters.toCharArray()) {\\n            brokenSet.add(ch);\\n        }\\n        \\n        for(String word: words) {\\n            for(char ch: word.toCharArray()) {\\n                if(brokenSet.contains(ch)) {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\t\\n\\t\\n\\t\\n\\tTime Complexity - O(m * n) (m is the size of text and n is the size of word with maximum length in text)\\n\\tSpace complexity - O(n) - n is the size of brokenLetters",
                "codeTag": "Unknown"
            },
            {
                "id": 1390945,
                "title": "kotlin-in-one-line",
                "content": "```\\nclass Solution {\\n    fun canBeTypedWords(text: String, brokenLetters: String): Int {\\n        return text.split(\" \").filter { word -> word.none { ch ->  brokenLetters.contains(ch) }}.count()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun canBeTypedWords(text: String, brokenLetters: String): Int {\\n        return text.split(\" \").filter { word -> word.none { ch ->  brokenLetters.contains(ch) }}.count()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381862,
                "title": "javascript-easy-and-faster-than-98-64ms",
                "content": "Let me know if you have any doubts. I try to answer/help.\\n\\nPlease upvote if you liked the solution.\\n```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n  const textArr = text.split(\\' \\');\\n  const brokenLettersArr = [...brokenLetters];\\n  return textArr.filter((e) => {\\n    return brokenLettersArr.every((letter) => !e.includes(letter));\\n  }).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n  const textArr = text.split(\\' \\');\\n  const brokenLettersArr = [...brokenLetters];\\n  return textArr.filter((e) => {\\n    return brokenLettersArr.every((letter) => !e.includes(letter));\\n  }).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378877,
                "title": "python-easy-code-using-set",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        result = len(text.split())\\n        set2 = set(brokenLetters)\\n        for i in text.split():\\n            set1 = set(i)\\n            if set1&set2:result -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        result = len(text.split())\\n        set2 = set(brokenLetters)\\n        for i in text.split():\\n            set1 = set(i)\\n            if set1&set2:result -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372781,
                "title": "c-easy-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int words=0;\\n        for(int i=1;i<text.length();i++)\\n        {\\n            if((text[i]==\\' \\'&&text[i-1]!=\\' \\')||(i==(text.length()-1)))\\n            {\\n                words++;\\n            }\\n        }\\n            for(int i=0;i<text.length();i++)\\n            {\\n                int j=0;\\n                while(j<brokenLetters.length())\\n                {\\n                    if(text[i]==brokenLetters[j])\\n                    {\\n                        words--;\\n                        while(text[i]!=\\' \\'&&i<text.length())\\n                            i++;\\n                    }\\n                    j++;\\n                }\\n            }\\n        \\n        return words;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int words=0;\\n        for(int i=1;i<text.length();i++)\\n        {\\n            if((text[i]==\\' \\'&&text[i-1]!=\\' \\')||(i==(text.length()-1)))\\n            {\\n                words++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1361373,
                "title": "cpp-o-n-unordered-sets-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char> b;\\n        for(char c:brokenLetters ){\\n            b.insert(c);\\n        }\\n        int count=0, n=text.size();\\n        int defects=0;\\n        for(int i=0; i<n; i++){\\n            \\n            \\n            if(b.find(text[i])!=b.end()){\\n                defects++;\\n            }\\n            if(text[i]==\\' \\' || i==n-1){\\n                if(defects==0)count++;\\n                defects=0;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char> b;\\n        for(char c:brokenLetters ){\\n            b.insert(c);\\n        }\\n        int count=0, n=text.size();\\n        int defects=0;\\n        for(int i=0; i<n; i++){\\n            \\n            \\n            if(b.find(text[i])!=b.end()){\\n                defects++;\\n            }\\n            if(text[i]==\\' \\' || i==n-1){\\n                if(defects==0)count++;\\n                defects=0;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354007,
                "title": "simple-python-with-for-loop",
                "content": "```\\n\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        \"\"\"\\n        :type text: str\\n        :type brokenLetters: str\\n        :rtype: int\\n        \"\"\"\\n        res = len(text.split())\\n        \\n        for w in text.split():\\n            for c in brokenLetters:\\n                if c in w:\\n                    res -= 1\\n                    break\\n                \\n        return res \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        \"\"\"\\n        :type text: str\\n        :type brokenLetters: str\\n        :rtype: int\\n        \"\"\"\\n        res = len(text.split())\\n        \\n        for w in text.split():\\n            for c in brokenLetters:\\n                if c in w:\\n                    res -= 1\\n                    break\\n                \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351411,
                "title": "shrt",
                "content": "```\\n    public int CanBeTypedWords(string text, string brokenLetters)\\n        => text.Split(\\' \\').Count(w => !w.Any(brokenLetters.Contains));\\n```",
                "solutionTags": [],
                "code": "```\\n    public int CanBeTypedWords(string text, string brokenLetters)\\n        => text.Split(\\' \\').Count(w => !w.Any(brokenLetters.Contains));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347802,
                "title": "javascript-intuitive-100-faster-60-ms",
                "content": "Runtime: 60 ms, faster than 100.00% of JavaScript online submissions for Maximum Number of Words You Can Type.\\nMemory Usage: 40.5 MB, less than 100.00% of JavaScript online submissions for Maximum Number of Words You Can Type.\\n\\n```\\n// Break sentence into words and filter out words that pass the test\\nconst canBeTypedWords = (text, broken) =>\\n\\ttext.split(\\' \\').filter((word) => isValidWord(word, broken)).length;\\n\\nconst isValidWord = (word, broken) =>\\n\\t[...word].some((char) => broken.includes(char)) === true;\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Break sentence into words and filter out words that pass the test\\nconst canBeTypedWords = (text, broken) =>\\n\\ttext.split(\\' \\').filter((word) => isValidWord(word, broken)).length;\\n\\nconst isValidWord = (word, broken) =>\\n\\t[...word].some((char) => broken.includes(char)) === true;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347592,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        map<char, int> brokenmp;\\n        for(auto i: brokenLetters){\\n            brokenmp[i] = 1;\\n        }\\n        int counter = 0;\\n        string space = \"\";\\n        for(int i=0; i<text.size(); i++){\\n           if(brokenmp[text[i]] == 1 & text[i] != \\' \\' & space != \"broken\"){\\n               space = \"broken\";\\n           }else if(text[i] == \\' \\'){\\n               if(space != \"broken\"){\\n                   counter += 1;\\n               }\\n               space = \"\";\\n           } \\n           if(i+1==text.size() & space != \"broken\"){\\n               counter += 1;\\n           } \\n        }\\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        map<char, int> brokenmp;\\n        for(auto i: brokenLetters){\\n            brokenmp[i] = 1;\\n        }\\n        int counter = 0;\\n        string space = \"\";\\n        for(int i=0; i<text.size(); i++){\\n           if(brokenmp[text[i]] == 1 & text[i] != \\' \\' & space != \"broken\"){\\n               space = \"broken\";\\n           }else if(text[i] == \\' \\'){\\n               if(space != \"broken\"){\\n                   counter += 1;\\n               }\\n               space = \"\";\\n           } \\n           if(i+1==text.size() & space != \"broken\"){\\n               counter += 1;\\n           } \\n        }\\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347412,
                "title": "python3-two-lines-using-set",
                "content": "```python\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        brokenLetters = set(brokenLetters)\\n        return sum(len(brokenLetters.intersection(t)) == 0 for t in text.split())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        brokenLetters = set(brokenLetters)\\n        return sum(len(brokenLetters.intersection(t)) == 0 for t in text.split())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1346394,
                "title": "why-software-guys-are-too-cheap-to-afford-a-working-keyboard",
                "content": "```scala\\n  def canBeTypedWords(text: String, bl: String): Int = {\\n\\n    val set = bl.toCharArray().toSet\\n    import scala.util.control.Breaks._\\n    text.split(\" \").count(x => {\\n      var ok = true \\n      breakable{\\n        x.toCharArray().foreach(c=>{\\n          if(set contains c){\\n            ok = false \\n            break()\\n          }\\n        })\\n        \\n      }\\n      ok\\n    })\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def canBeTypedWords(text: String, bl: String): Int = {\\n\\n    val set = bl.toCharArray().toSet\\n    import scala.util.control.Breaks._\\n    text.split(\" \").count(x => {\\n      var ok = true \\n      breakable{\\n        x.toCharArray().foreach(c=>{\\n          if(set contains c){\\n            ok = false \\n            break()\\n          }\\n        })\\n        \\n      }\\n      ok\\n    })\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1346066,
                "title": "python-solution-with-any",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        l= list(brokenLetters)\\n        wrds= text.strip().split()\\n        c=0\\n        for i in wrds:\\n            if any(item in l for item in i):\\n                pass\\n            else:\\n                c=c+1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        l= list(brokenLetters)\\n        wrds= text.strip().split()\\n        c=0\\n        for i in wrds:\\n            if any(item in l for item in i):\\n                pass\\n            else:\\n                c=c+1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345844,
                "title": "java-solution-using-indexoff-with-comments",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String s[]=text.split(\" \");   //get words from str \\n        int count=0,fin=0;        \\n     for(int i=0;i<s.length;i++)  // eg take hello\\n    {     count=0;\\n        for(char c1:brokenLetters.toCharArray())  //check each character from borkenLetter \"ad\" taking  char \\'a\\' first\\n          {     \\n             if(s[i].indexOf(c1)==-1)  //if char \\'a\\' not found in hello\\n              count++;                  // increase count\\n           }\\n         if(count==brokenLetters.length()) \\n//main condition check if both the chars \\'a\\' && \\'d\\' are not present in hello then increease fin++;\\n             fin++;\\n        }\\n        return fin;\\n    }\\n}\\n```\\n**Hope It Helps.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String s[]=text.split(\" \");   //get words from str \\n        int count=0,fin=0;        \\n     for(int i=0;i<s.length;i++)  // eg take hello\\n    {     count=0;\\n        for(char c1:brokenLetters.toCharArray())  //check each character from borkenLetter \"ad\" taking  char \\'a\\' first\\n          {     \\n             if(s[i].indexOf(c1)==-1)  //if char \\'a\\' not found in hello\\n              count++;                  // increase count\\n           }\\n         if(count==brokenLetters.length()) \\n//main condition check if both the chars \\'a\\' && \\'d\\' are not present in hello then increease fin++;\\n             fin++;\\n        }\\n        return fin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345677,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String b) {\\n        boolean a[] = new boolean[26];\\n        for(char x:b.toCharArray()){a[x-\\'a\\']=true;}\\n        text+=\" \";\\n        boolean should=true;\\n        int res=0;\\n        for(char x:text.toCharArray()){\\n            if(x==\\' \\'){\\n                if(should){res++;}\\n                should=true;\\n            }\\n            else{\\n                if(a[x-\\'a\\']){should=false;}\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String b) {\\n        boolean a[] = new boolean[26];\\n        for(char x:b.toCharArray()){a[x-\\'a\\']=true;}\\n        text+=\" \";\\n        boolean should=true;\\n        int res=0;\\n        for(char x:text.toCharArray()){\\n            if(x==\\' \\'){\\n                if(should){res++;}\\n                should=true;\\n            }\\n            else{\\n                if(a[x-\\'a\\']){should=false;}\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345478,
                "title": "unordered-map-o-n-c",
                "content": "int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,int> mp;\\n        int count=0;\\n        for(int i=0;i<brokenLetters.size();i++)\\n            mp[brokenLetters[i]]++;\\n        bool ok=true;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\'){\\n                if(ok)\\n                count++;\\n                else\\n                ok=true;\\n            }\\n            else{\\n                if(mp.find(text[i])!=mp.end())\\n                    ok=false;\\n            }\\n        }\\n        if(ok)\\n            count++;\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,int> mp;\\n        int count=0;\\n        for(int i=0;i<brokenLetters.size();i++)\\n            mp[brokenLetters[i]]++;\\n        bool ok=true;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\'){\\n                if(ok)\\n                count++;\\n                else\\n                ok=true;\\n            }\\n            else{\\n                if(mp.find(text[i])!=mp.end())\\n                    ok=false;\\n            }\\n        }\\n        if(ok)\\n            count++;\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1345272,
                "title": "java-o-1-space",
                "content": "```\\nclass Solution {\\n\\tpublic int canBeTypedWords(String text, String brokenLetters) {\\n\\t\\tString words[] = text.split(\" \");\\n\\t\\tchar frequency[] = new char[26];\\n\\t\\tint count = 0;\\n\\n\\t\\tfor (char c: brokenLetters.toCharArray()) {\\n\\t\\t\\tfrequency[c - \\'a\\']++;\\n\\t\\t}\\n\\n\\t\\tfor (String word: words) {\\n\\t\\t\\tboolean flag = false;\\n\\n\\t\\t\\tfor (char c: word.toCharArray()) {\\n\\t\\t\\t\\tif (frequency[c - \\'a\\'] == 1) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!flag) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic int canBeTypedWords(String text, String brokenLetters) {\\n\\t\\tString words[] = text.split(\" \");\\n\\t\\tchar frequency[] = new char[26];\\n\\t\\tint count = 0;\\n\\n\\t\\tfor (char c: brokenLetters.toCharArray()) {\\n\\t\\t\\tfrequency[c - \\'a\\']++;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1345034,
                "title": "easy-and-best-solution-c-less-memory-used",
                "content": "```\\n//PLEASE UPVOTE IF YOU LIKE IT\\n\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int len=text.length();\\n        int len1=brokenLetters.length();\\n        vector<int> mp(26,0);\\n        for(int i=0;i<len1;i++)\\n        {\\n            mp[brokenLetters[i]-\\'a\\']=1;      \\n        }\\n        int count=0;\\n        int flag=1;\\n        for(int i=0;i<len;i++)\\n        {\\n            flag=1;\\n            char ch=text[i];\\n            while(ch!=\\' \\' and i<len)\\n            {\\n                 \\n                if(mp[text[i]-\\'a\\']==1)\\n                {\\n                   flag=0; \\n                }\\n                 i++; \\n                ch=text[i];\\n            }\\n            if(flag==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//PLEASE UPVOTE IF YOU LIKE IT\\n\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int len=text.length();\\n        int len1=brokenLetters.length();\\n        vector<int> mp(26,0);\\n        for(int i=0;i<len1;i++)\\n        {\\n            mp[brokenLetters[i]-\\'a\\']=1;      \\n        }\\n        int count=0;\\n        int flag=1;\\n        for(int i=0;i<len;i++)\\n        {\\n            flag=1;\\n            char ch=text[i];\\n            while(ch!=\\' \\' and i<len)\\n            {\\n                 \\n                if(mp[text[i]-\\'a\\']==1)\\n                {\\n                   flag=0; \\n                }\\n                 i++; \\n                ch=text[i];\\n            }\\n            if(flag==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344993,
                "title": "java-brute-force-approach",
                "content": "```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\t// split into words based on whitespaces (question specifies using just 1 whitespace to mark out words)\\n\\tString[] words = text.split(\" \");\\n\\tint c = words.length;\\n\\tfor (String word : words) {\\n\\t\\tfor (char curr : brokenLetters.toCharArray()) {\\n\\t\\t// doesn\\'t contain the word, decrement and stop iterating\\n\\t\\t\\tif (word.contains(curr + \"\")) {\\n\\t\\t\\t\\tc--;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn c;\\n    }\\n```\\nA direct approach that I took in midst of attempting the competition. This may not be the optimal approach, just an ordinary 1st attempt instinctive solution.\\n\\nOptimised Brute-force, using a hashset to record all broken letters\\n```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n        // split into words based on whitespaces (question specifies using just 1 whitespace to mark out words)\\n        String[] words = text.split(\" \");\\n        int c = words.length;\\n\\t\\t// cache all broken letters \\n        HashSet<Character> letters = new HashSet<>();\\n        for (int i = 0; i < brokenLetters.length(); i++) letters.add(brokenLetters.charAt(i));\\n\\t\\t// Iterate, technically should be O(n) runtime\\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                if (letters.contains(word.charAt(i))){\\n                    c--;\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n}\\n```\\nRuntime: O(n), Space: O(n)",
                "solutionTags": [],
                "code": "```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\t// split into words based on whitespaces (question specifies using just 1 whitespace to mark out words)\\n\\tString[] words = text.split(\" \");\\n\\tint c = words.length;\\n\\tfor (String word : words) {\\n\\t\\tfor (char curr : brokenLetters.toCharArray()) {\\n\\t\\t// doesn\\'t contain the word, decrement and stop iterating\\n\\t\\t\\tif (word.contains(curr + \"\")) {\\n\\t\\t\\t\\tc--;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn c;\\n    }\\n```\n```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n        // split into words based on whitespaces (question specifies using just 1 whitespace to mark out words)\\n        String[] words = text.split(\" \");\\n        int c = words.length;\\n\\t\\t// cache all broken letters \\n        HashSet<Character> letters = new HashSet<>();\\n        for (int i = 0; i < brokenLetters.length(); i++) letters.add(brokenLetters.charAt(i));\\n\\t\\t// Iterate, technically should be O(n) runtime\\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                if (letters.contains(word.charAt(i))){\\n                    c--;\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344945,
                "title": "java-easy-self-explained",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String str[]=text.split(\" \");\\n        int count=0;\\n        for(String a:str){\\n            for(Character b:brokenLetters.toCharArray()){\\n                if(a.indexOf(b)!=-1){\\n                    count++;\\n                    break;\\n                }\\n         return str.length-count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String str[]=text.split(\" \");\\n        int count=0;\\n        for(String a:str){\\n            for(Character b:brokenLetters.toCharArray()){\\n                if(a.indexOf(b)!=-1){\\n                    count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1344942,
                "title": "using-stringstream-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string br) {\\n        set<char>st;\\n        for(auto a:br)\\n        {\\n            st.insert(a);\\n        }\\n        \\n        stringstream s(text);\\n        string word;  \\n        int count = 0;\\n        while (s >> word)\\n        {\\n            bool flag=0;\\n            for(auto a:word)\\n            {\\n                if(st.find(a)!=st.end())\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)count++;\\n        }\\n        return count;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string br) {\\n        set<char>st;\\n        for(auto a:br)\\n        {\\n            st.insert(a);\\n        }\\n        \\n        stringstream s(text);\\n        string word;  \\n        int count = 0;\\n        while (s >> word)\\n        {\\n            bool flag=0;\\n            for(auto a:word)\\n            {\\n                if(st.find(a)!=st.end())\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)count++;\\n        }\\n        return count;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344904,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] words = text.split(\"\\\\\\\\s+\");\\n        HashSet<Character> set = new HashSet<>();\\n        \\n        for(int i = 0; i < brokenLetters.length(); i++){\\n            set.add(brokenLetters.charAt(i));\\n        }\\n        \\n        outerloop:\\n        for(int i = 0; i < words.length; i++){\\n            for(int j = 0; j < words[i].length(); j++){\\n                if(set.contains(words[i].charAt(j))){\\n                    continue outerloop;\\n                }\\n            }\\n            count++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] words = text.split(\"\\\\\\\\s+\");\\n        HashSet<Character> set = new HashSet<>();\\n        \\n        for(int i = 0; i < brokenLetters.length(); i++){\\n            set.add(brokenLetters.charAt(i));\\n        }\\n        \\n        outerloop:\\n        for(int i = 0; i < words.length; i++){\\n            for(int j = 0; j < words[i].length(); j++){\\n                if(set.contains(words[i].charAt(j))){\\n                    continue outerloop;\\n                }\\n            }\\n            count++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344901,
                "title": "python-one-liner",
                "content": "```python\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(sum([l in set(brokenLetters) for l in word]) == 0 for word in text.split(\\' \\'))\\n```\\n\\n- Couldn\\'t solve problem 3 in the contest so I came up with this",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(sum([l in set(brokenLetters) for l in word]) == 0 for word in text.split(\\' \\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083631,
                "title": "c-100-faster-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\tint canBeTypedWords(string text, string brokenLetters) {\\n\\n\\t\\tint hash[26] = {0};\\n\\n\\t\\tfor (int i = 0; i < brokenLetters.size(); ++i)\\n\\t\\t{\\n\\t\\t\\thash[brokenLetters[i] - 97] = 1;\\n\\t\\t}\\n\\n\\n\\t\\tint index = 0;\\n\\n\\t\\tint ans = 0;\\n\\n\\t\\tint inputSize = text.size();\\n\\n\\t\\twhile (index < inputSize) {\\n\\n\\t\\t\\tif (text[index] == \\' \\') {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if (hash[text[index] - 97]) {\\n\\t\\t\\t\\twhile (text[index] != \\' \\' && index < inputSize) {\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (index == inputSize) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if (index == inputSize - 1) {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tindex++;\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\tint canBeTypedWords(string text, string brokenLetters) {\\n\\n\\t\\tint hash[26] = {0};\\n\\n\\t\\tfor (int i = 0; i < brokenLetters.size(); ++i)\\n\\t\\t{\\n\\t\\t\\thash[brokenLetters[i] - 97] = 1;\\n\\t\\t}\\n\\n\\n\\t\\tint index = 0;\\n\\n\\t\\tint ans = 0;\\n\\n\\t\\tint inputSize = text.size();\\n\\n\\t\\twhile (index < inputSize) {\\n\\n\\t\\t\\tif (text[index] == \\' \\') {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if (hash[text[index] - 97]) {\\n\\t\\t\\t\\twhile (text[index] != \\' \\' && index < inputSize) {\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (index == inputSize) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if (index == inputSize - 1) {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tindex++;\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080611,
                "title": "easy-cpp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string s, string bb) {\\n        int cnt=0,i=0,n=s.size();;\\n        unordered_map<char,int>mp;\\n        for(auto i:bb) mp[i]++;\\n        while(i<n){\\n            int flag=0;\\n            while(s[i]!=\\' \\' and i<n){\\n                if(mp.find(s[i])!=mp.end()) flag=1;\\n                i++;\\n            }\\n            i++;\\n            if(flag==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string s, string bb) {\\n        int cnt=0,i=0,n=s.size();;\\n        unordered_map<char,int>mp;\\n        for(auto i:bb) mp[i]++;\\n        while(i<n){\\n            int flag=0;\\n            while(s[i]!=\\' \\' and i<n){\\n                if(mp.find(s[i])!=mp.end()) flag=1;\\n                i++;\\n            }\\n            i++;\\n            if(flag==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079350,
                "title": "check-each-individual-word-for-the-presence-of-broken-letters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] str=text.split(\" \");\\n        int count=0;\\n        for(int i=0;i<str.length;i++)\\n        {\\n            count++;\\n            for(int j=0;j<brokenLetters.length();j++)\\n            {\\n                if(str[i].indexOf(brokenLetters.charAt(j))!=-1)\\n                {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] str=text.split(\" \");\\n        int count=0;\\n        for(int i=0;i<str.length;i++)\\n        {\\n            count++;\\n            for(int j=0;j<brokenLetters.length();j++)\\n            {\\n                if(str[i].indexOf(brokenLetters.charAt(j))!=-1)\\n                {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073677,
                "title": "minimum-memory-and-speedy-with-set-on-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        l = text.split(\\' \\')\\n        br = set(brokenLetters)\\n        for i in l:\\n            s_i = set(i)\\n            if len(s_i - br) == len(s_i):\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        l = text.split(\\' \\')\\n        br = set(brokenLetters)\\n        for i in l:\\n            s_i = set(i)\\n            if len(s_i - br) == len(s_i):\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070193,
                "title": "sample-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to count the number of words in a given text that can be typed using a keyboard, given a set of broken letters. A word is considered typable if it does not contain any of the broken letters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Split the input text into an array of words using the space character as the delimiter. Store the array of words in the strs variable.\\n\\n2. Convert the brokenLetters string into a character array chars.\\n\\n3. Initialize a variable total to store the total number of typable words. Set total initially to the total number of words in the strs array.\\n\\n4. Iterate through each word str in the strs array.\\n\\n5. For each word, iterate through each character ch in the chars array.\\n\\n6. Check if the character ch exists in the word str using the indexOf method. If it exists (i.e., str.indexOf(ch) != -1), it means the word contains a broken letter. In this case, decrement the total count and break out of the inner loop.\\n\\n7. After processing all words, return the final value of total, which represents the count of words that can be typed without using any broken letters.\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere **n** is the number of words in the input text (length of strs), and **m** is the average length of a word.\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere **m** is the length of the brokenLetters string.\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        var strs = text.split(\" \");\\n        var chars = brokenLetters.toCharArray();\\n        var total = strs.length;\\n\\n        for (var str : strs){\\n            for (var ch : chars){\\n                if (str.indexOf(ch) != -1){\\n                    total--;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return total;\\n    }\\n}\\n```\\n![Frame 76.png](https://assets.leetcode.com/users/images/1d20c9ee-8051-42a7-949c-86dcc074ca85_1695245121.4193192.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        var strs = text.split(\" \");\\n        var chars = brokenLetters.toCharArray();\\n        var total = strs.length;\\n\\n        for (var str : strs){\\n            for (var ch : chars){\\n                if (str.indexOf(ch) != -1){\\n                    total--;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070101,
                "title": "beautiful-solution-using-stringstream-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        int map[26]={0};\\n        for(const auto& x:brokenLetters){\\n            map[x-\\'a\\']++;\\n        }\\n        stringstream s(text);\\n        string word;\\n        while(s>>word){\\n            bool isCan=true;\\n            for(char letter:word){\\n                if(map[letter-\\'a\\']>0){\\n                    isCan=false;\\n                    break;\\n                }\\n            }\\n            if(isCan){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        int map[26]={0};\\n        for(const auto& x:brokenLetters){\\n            map[x-\\'a\\']++;\\n        }\\n        stringstream s(text);\\n        string word;\\n        while(s>>word){\\n            bool isCan=true;\\n            for(char letter:word){\\n                if(map[letter-\\'a\\']>0){\\n                    isCan=false;\\n                    break;\\n                }\\n            }\\n            if(isCan){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060693,
                "title": "a-little-complex-but-fast-with-for-3x-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 43ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 42.24MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let Arr = [];\\n    let counter = 0;\\n    let condition = false;\\n    Arr = text.split(\" \");\\n    for(let i = 0;i < Arr.length;i++){\\n        for(let k = 0;k < Arr[i].length;k++){\\n            for(let j = 0;j < brokenLetters.length;j++){\\n                if(Arr[i][k] == brokenLetters[j]){\\n                    counter++;\\n                    condition = true;\\n                    break;\\n                }\\n            }\\n            if(condition == true){\\n                condition = false;\\n                break;\\n            }\\n        }\\n    }\\n    return Arr.length - counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let Arr = [];\\n    let counter = 0;\\n    let condition = false;\\n    Arr = text.split(\" \");\\n    for(let i = 0;i < Arr.length;i++){\\n        for(let k = 0;k < Arr[i].length;k++){\\n            for(let j = 0;j < brokenLetters.length;j++){\\n                if(Arr[i][k] == brokenLetters[j]){\\n                    counter++;\\n                    condition = true;\\n                    break;\\n                }\\n            }\\n            if(condition == true){\\n                condition = false;\\n                break;\\n            }\\n        }\\n    }\\n    return Arr.length - counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057620,
                "title": "java-intuitive-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenSet = new HashSet();\\n        for (int i = 0; i < brokenLetters.length(); i++) {\\n            brokenSet.add(brokenLetters.charAt(i));\\n        }\\n\\n        String[] strSplit = text.split(\" \");\\n        int count = strSplit.length;\\n        for (String s : strSplit) {\\n            for (int i = 0; i < s.length(); i++) {\\n                if (brokenSet.contains(s.charAt(i))) {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenSet = new HashSet();\\n        for (int i = 0; i < brokenLetters.length(); i++) {\\n            brokenSet.add(brokenLetters.charAt(i));\\n        }\\n\\n        String[] strSplit = text.split(\" \");\\n        int count = strSplit.length;\\n        for (String s : strSplit) {\\n            for (int i = 0; i < s.length(); i++) {\\n                if (brokenSet.contains(s.charAt(i))) {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056624,
                "title": "python-one-liner-beats-92-35-runtime-100-00-memory",
                "content": "# Python3 Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(1 for i in text.split(\\' \\') if not any(j in i for j in brokenLetters))\\n```\\n\\n![Screenshot 2023-09-17 222614.png](https://assets.leetcode.com/users/images/2e3477dc-502f-4eba-b318-9ac589ded0ed_1694969808.1623027.png)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(1 for i in text.split(\\' \\') if not any(j in i for j in brokenLetters))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054256,
                "title": "beats-91-38-of-users-with-python",
                "content": "# Intuition\\n![Screen Shot 2566-09-17 at 10.10.41.png](https://assets.leetcode.com/users/images/1d6b8eda-02c1-4db9-862d-c2dca8578709_1694927553.975569.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        cound = 0\\n        for i in text.split():\\n            soft_cound = 0\\n            for j in brokenLetters:\\n                if j not in i:\\n                    soft_cound+=1\\n            if len(brokenLetters) == soft_cound:\\n                cound+=1\\n        return cound\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        cound = 0\\n        for i in text.split():\\n            soft_cound = 0\\n            for j in brokenLetters:\\n                if j not in i:\\n                    soft_cound+=1\\n            if len(brokenLetters) == soft_cound:\\n                cound+=1\\n        return cound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052847,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) \\n    {\\n        String[] arr=text.split(\" \");\\n        int n=arr.length;\\n        int total=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            HashMap<Character,Integer> map=new HashMap<>();\\n            int m=arr[i].length();\\n            String s=arr[i];\\n            for(int j=0;j<m;j++)\\n            {\\n                map.put(s.charAt(j),map.getOrDefault(s.charAt(j),0)+1);\\n            }\\n            for(int k=0;k<brokenLetters.length();k++)\\n            {\\n                if(!map.containsKey(brokenLetters.charAt(k)))\\n                {\\n                   count++; \\n                }\\n            }\\n            if(count==brokenLetters.length())\\n            {\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) \\n    {\\n        String[] arr=text.split(\" \");\\n        int n=arr.length;\\n        int total=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            HashMap<Character,Integer> map=new HashMap<>();\\n            int m=arr[i].length();\\n            String s=arr[i];\\n            for(int j=0;j<m;j++)\\n            {\\n                map.put(s.charAt(j),map.getOrDefault(s.charAt(j),0)+1);\\n            }\\n            for(int k=0;k<brokenLetters.length();k++)\\n            {\\n                if(!map.containsKey(brokenLetters.charAt(k)))\\n                {\\n                   count++; \\n                }\\n            }\\n            if(count==brokenLetters.length())\\n            {\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048921,
                "title": "multiple-approach-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc canBeTypedWords(text string, brokenLetters string) int {\\n    // chekc if brokerLetters sub string present in the text string\\n    // divide text into multiple sub array based on delimeter\\n    // newText := strings.Split(text, \" \")\\n    // count:=0\\n    // for _,word := range newText {\\n    //     // found := false\\n    //     if strings.ContainsAny(brokenLetters, word) {\\n    //         count++\\n    //     }\\n    //     // for _, char := range word {\\n    //     //     for _, bl := range brokenLetters {\\n    //     //         if char == bl {\\n    //     //             count++\\n    //     //             found = true\\n    //     //             break\\n    //     //         }\\n    //     //     }\\n    //     //     if found == true {\\n    //     //         break\\n    //     //     }\\n    //     // }\\n    // }\\n    // return len(newText) - count\\n\\n\\tbrokenMap := make(map[string]bool)\\n\\tfor _, v := range brokenLetters {\\n\\t\\tif _, ok := brokenMap[fmt.Sprintf(\"%c\", v)]; !ok {\\n\\t\\t\\tbrokenMap[fmt.Sprintf(\"%c\", v)] = true\\n\\t\\t}\\n\\t}\\n\\n\\tcount := 0\\n\\tallcount := 1\\n\\tvar alreadyProcessed = false\\n\\tfor i := 0; i < len(text); i++ {\\n\\t\\t// skip first iteration\\n\\t\\tif string(text[i]) == \" \" {\\n\\t\\t\\tallcount++\\n\\t\\t\\talreadyProcessed = false\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif alreadyProcessed == false {\\n\\t\\t\\tif _, ok := brokenMap[string(text[i])]; ok {\\n\\t\\t\\t\\talreadyProcessed = true\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\treturn allcount - count\\n\\n\\n    // prevIndex := -1\\n    // var found bool\\n    // for _,v := range brokenLetters {\\n    //     for index,b := range newText {\\n    //         if prevIndex == index {\\n    //             continue\\n    //         }\\n    //         // // if v belongs to text then we can not type\\n    //         for _,p := range b {\\n    //             if v == p {\\n    //                 count++\\n    //                 prevIndex = index\\n    //                 found = true\\n    //                 break\\n    //             }\\n    //         }\\n    //         if found == true {\\n    //             break\\n    //         }\\n    //     }\\n    // }\\n    // if (len(newText) - count) <0 {\\n    //     return 0\\n    // }\\n    // return len(newText) - count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canBeTypedWords(text string, brokenLetters string) int {\\n    // chekc if brokerLetters sub string present in the text string\\n    // divide text into multiple sub array based on delimeter\\n    // newText := strings.Split(text, \" \")\\n    // count:=0\\n    // for _,word := range newText {\\n    //     // found := false\\n    //     if strings.ContainsAny(brokenLetters, word) {\\n    //         count++\\n    //     }\\n    //     // for _, char := range word {\\n    //     //     for _, bl := range brokenLetters {\\n    //     //         if char == bl {\\n    //     //             count++\\n    //     //             found = true\\n    //     //             break\\n    //     //         }\\n    //     //     }\\n    //     //     if found == true {\\n    //     //         break\\n    //     //     }\\n    //     // }\\n    // }\\n    // return len(newText) - count\\n\\n\\tbrokenMap := make(map[string]bool)\\n\\tfor _, v := range brokenLetters {\\n\\t\\tif _, ok := brokenMap[fmt.Sprintf(\"%c\", v)]; !ok {\\n\\t\\t\\tbrokenMap[fmt.Sprintf(\"%c\", v)] = true\\n\\t\\t}\\n\\t}\\n\\n\\tcount := 0\\n\\tallcount := 1\\n\\tvar alreadyProcessed = false\\n\\tfor i := 0; i < len(text); i++ {\\n\\t\\t// skip first iteration\\n\\t\\tif string(text[i]) == \" \" {\\n\\t\\t\\tallcount++\\n\\t\\t\\talreadyProcessed = false\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif alreadyProcessed == false {\\n\\t\\t\\tif _, ok := brokenMap[string(text[i])]; ok {\\n\\t\\t\\t\\talreadyProcessed = true\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\treturn allcount - count\\n\\n\\n    // prevIndex := -1\\n    // var found bool\\n    // for _,v := range brokenLetters {\\n    //     for index,b := range newText {\\n    //         if prevIndex == index {\\n    //             continue\\n    //         }\\n    //         // // if v belongs to text then we can not type\\n    //         for _,p := range b {\\n    //             if v == p {\\n    //                 count++\\n    //                 prevIndex = index\\n    //                 found = true\\n    //                 break\\n    //             }\\n    //         }\\n    //         if found == true {\\n    //             break\\n    //         }\\n    //     }\\n    // }\\n    // if (len(newText) - count) <0 {\\n    //     return 0\\n    // }\\n    // return len(newText) - count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047816,
                "title": "89-runtime-97-memory-without-set",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/92f1b25a-d6dc-45e1-b736-71ee360b103f_1694782201.0270524.png)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        counter: int = 0\\n\\n        for word in text.split():\\n            for char in word:\\n                if char in brokenLetters:\\n                    break\\n            else:\\n                counter += 1\\n\\n        return counter\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        counter: int = 0\\n\\n        for word in text.split():\\n            for char in word:\\n                if char in brokenLetters:\\n                    break\\n            else:\\n                counter += 1\\n\\n        return counter\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046553,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function(text, brokenLetters) {\\n  let count=0;\\n  text=text.split(\" \");\\n  const len=text.length;\\n  for(let i=0;i<len;i++){\\n    inner:for(let j=0;j<brokenLetters.length;j++){\\n      if(text[i].includes(brokenLetters[j])){\\n         count++;\\n         break inner;\\n      }\\n    }\\n  }\\n  return len-count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function(text, brokenLetters) {\\n  let count=0;\\n  text=text.split(\" \");\\n  const len=text.length;\\n  for(let i=0;i<len;i++){\\n    inner:for(let j=0;j<brokenLetters.length;j++){\\n      if(text[i].includes(brokenLetters[j])){\\n         count++;\\n         break inner;\\n      }\\n    }\\n  }\\n  return len-count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039511,
                "title": "python-solution-using-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        size = len(text)\\n        broken_map = Counter(brokenLetters)\\n        hash_map = Counter(text)\\n\\n\\n        for word in text:\\n            broken = False\\n            for c in word:\\n                if c in broken_map:\\n                    broken = True\\n                    break\\n\\n            if broken:\\n                size -= 1\\n        return size\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        size = len(text)\\n        broken_map = Counter(brokenLetters)\\n        hash_map = Counter(text)\\n\\n\\n        for word in text:\\n            broken = False\\n            for c in word:\\n                if c in broken_map:\\n                    broken = True\\n                    break\\n\\n            if broken:\\n                size -= 1\\n        return size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029958,
                "title": "java-less-optimize-solution-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2) --> Worst Case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(text.length())\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean check(String str, String s){\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++) set.add(s.charAt(i));\\n\\n        for(int i=0; i<str.length(); i++){\\n            if(set.contains(str.charAt(i))) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String [] arr = text.split(\" \");\\n\\n        int count=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(check(arr[i], brokenLetters)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    boolean check(String str, String s){\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++) set.add(s.charAt(i));\\n\\n        for(int i=0; i<str.length(); i++){\\n            if(set.contains(str.charAt(i))) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String [] arr = text.split(\" \");\\n\\n        int count=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(check(arr[i], brokenLetters)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022411,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] arr = text.split(\" \");\\n        \\n        for(String str : arr) {\\n            boolean contains = false;\\n            for(int i = 0; i < str.length(); i++) {\\n                if(brokenLetters.contains(String.valueOf(str.charAt(i)))) {\\n                    contains = true;\\n                    break;\\n                }\\n            }\\n            if(!contains) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] arr = text.split(\" \");\\n        \\n        for(String str : arr) {\\n            boolean contains = false;\\n            for(int i = 0; i < str.length(); i++) {\\n                if(brokenLetters.contains(String.valueOf(str.charAt(i)))) {\\n                    contains = true;\\n                    break;\\n                }\\n            }\\n            if(!contains) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021995,
                "title": "solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        c=0\\n        l=text.split()\\n        f=1\\n        for i in l:\\n            for j in i:\\n                if j in brokenLetters:\\n                    f=0\\n                    break\\n            if(f):\\n                c+=1\\n            f=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        c=0\\n        l=text.split()\\n        f=1\\n        for i in l:\\n            for j in i:\\n                if j in brokenLetters:\\n                    f=0\\n                    break\\n            if(f):\\n                c+=1\\n            f=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020077,
                "title": "the-fastest-in-dart",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n * m)\\n- Space complexity:\\nO(n * m)\\n# Code\\n```\\nclass Solution {\\n  int canBeTypedWords(String text, String brokenLetters) {\\n  int count=0;\\n  List<String> ls=text.split(\\' \\');\\n  List<String> lsa=brokenLetters.split(\\'\\');\\n  for(String s in ls)\\n  {\\n    int c=lsa.length;\\n      for(String ss in lsa)\\n      {\\n\\n          if(!s.contains(ss))\\n          c--;\\n         \\n      }\\n      if(c==0)\\n      count++;\\n\\n  }\\n  return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int canBeTypedWords(String text, String brokenLetters) {\\n  int count=0;\\n  List<String> ls=text.split(\\' \\');\\n  List<String> lsa=brokenLetters.split(\\'\\');\\n  for(String s in ls)\\n  {\\n    int c=lsa.length;\\n      for(String ss in lsa)\\n      {\\n\\n          if(!s.contains(ss))\\n          c--;\\n         \\n      }\\n      if(c==0)\\n      count++;\\n\\n  }\\n  return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018912,
                "title": "c-beats-100-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<bool>arr(26,false);\\n        for(int i = 0;i < brokenLetters.length();i++)\\n            arr[brokenLetters[i] - \\'a\\'] = true;\\n        int ans = 0;\\n        for(int j = 0;j < text.length();j++){\\n            bool flag = true;\\n            while(j < text.length() && text[j] != \\' \\')\\n                if(arr[text[j++] - \\'a\\'])\\n                    flag = false;\\n            if(flag)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<bool>arr(26,false);\\n        for(int i = 0;i < brokenLetters.length();i++)\\n            arr[brokenLetters[i] - \\'a\\'] = true;\\n        int ans = 0;\\n        for(int j = 0;j < text.length();j++){\\n            bool flag = true;\\n            while(j < text.length() && text[j] != \\' \\')\\n                if(arr[text[j++] - \\'a\\'])\\n                    flag = false;\\n            if(flag)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014886,
                "title": "2ms-easy-code-string",
                "content": "# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n    int count = 0;\\n        String[] words = text.split(\" \");\\n        \\n        for (String word : words) {\\n            boolean canType = true;\\n            for (char c : brokenLetters.toCharArray()) {\\n                if (word.indexOf(c) != -1) {\\n                    canType = false;\\n                    break; // No need to continue checking if a broken letter is found in the word\\n                }\\n            }\\n            if (canType) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n    int count = 0;\\n        String[] words = text.split(\" \");\\n        \\n        for (String word : words) {\\n            boolean canType = true;\\n            for (char c : brokenLetters.toCharArray()) {\\n                if (word.indexOf(c) != -1) {\\n                    canType = false;\\n                    break; // No need to continue checking if a broken letter is found in the word\\n                }\\n            }\\n            if (canType) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007663,
                "title": "my-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  public int canBeTypedWords(String text, String brokenLetters) {\\n    String[] splited = text.split(\"\\\\\\\\s+\");\\n    int response = splited.length;\\n\\n    for (String word : splited) {\\n      for (char ch : brokenLetters.toCharArray()) {\\n        if (word.indexOf(ch) != -1) {\\n          response--;\\n          break;\\n        }\\n      }\\n    }\\n\\n    return response;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int canBeTypedWords(String text, String brokenLetters) {\\n    String[] splited = text.split(\"\\\\\\\\s+\");\\n    int response = splited.length;\\n\\n    for (String word : splited) {\\n      for (char ch : brokenLetters.toCharArray()) {\\n        if (word.indexOf(ch) != -1) {\\n          response--;\\n          break;\\n        }\\n      }\\n    }\\n\\n    return response;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006097,
                "title": "one-line-solution-using-list-comprehensions-and-intersections-of-sets",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return  len(text.split(\\' \\')) - sum([1 for w in text.split(\\' \\') if len(set(brokenLetters).intersection(set(w))) != 0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return  len(text.split(\\' \\')) - sum([1 for w in text.split(\\' \\') if len(set(brokenLetters).intersection(set(w))) != 0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996801,
                "title": "beats-100-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        unordered_map<char,int>v;\\n        for(int i=0;i<brokenLetters.length();i++)\\n        {\\n            v[brokenLetters[i]]++;\\n        }\\n        string temp=\"\";\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\' || i==text.size()-1)\\n            {\\n                int flag=0;\\n                if(i==text.size()-1)\\n                {\\n                    temp+=text[i];\\n                }\\n                for(int i=0;i<temp.size();i++)\\n                {\\n                    if(v[temp[i]]==1)\\n                    {\\n                        flag=1;\\n                        break;\\n\\n                    }\\n                      \\n                }\\n                if(flag==0) count++;\\n                temp=\"\";\\n            }\\n            else \\n            {\\n                temp+=text[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        unordered_map<char,int>v;\\n        for(int i=0;i<brokenLetters.length();i++)\\n        {\\n            v[brokenLetters[i]]++;\\n        }\\n        string temp=\"\";\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\' || i==text.size()-1)\\n            {\\n                int flag=0;\\n                if(i==text.size()-1)\\n                {\\n                    temp+=text[i];\\n                }\\n                for(int i=0;i<temp.size();i++)\\n                {\\n                    if(v[temp[i]]==1)\\n                    {\\n                        flag=1;\\n                        break;\\n\\n                    }\\n                      \\n                }\\n                if(flag==0) count++;\\n                temp=\"\";\\n            }\\n            else \\n            {\\n                temp+=text[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992700,
                "title": "set-easy-just-read-it-it-once-you-will-get-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> hs= new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++){\\n          char ch=brokenLetters.charAt(i);\\n          hs.add(ch);          \\n        }\\n        int count= 0 ;        \\n        String[]a =text.split(\" \") ;\\n        for(int i = 0 ; i<a.length;i++){\\n            String s= a[i]; \\n            for(int j=0 ; j<s.length();j++){\\n                if(hs.contains(s.charAt(j))){\\n                    count++; \\n                    break; \\n                }                \\n            }             \\n        }\\n        return a.length-count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> hs= new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++){\\n          char ch=brokenLetters.charAt(i);\\n          hs.add(ch);          \\n        }\\n        int count= 0 ;        \\n        String[]a =text.split(\" \") ;\\n        for(int i = 0 ; i<a.length;i++){\\n            String s= a[i]; \\n            for(int j=0 ; j<s.length();j++){\\n                if(hs.contains(s.charAt(j))){\\n                    count++; \\n                    break; \\n                }                \\n            }             \\n        }\\n        return a.length-count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988486,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        a=list(text.split(\\' \\'))\\n        b=0\\n        c=[]\\n        for i in brokenLetters :\\n            if i not in c :\\n                c.append(i)\\n        for i in range(0,len(a)) :\\n            d=0\\n            for j in range(0,len(c)) :\\n                if c[j] in a[i] :\\n                    d+=1\\n                if d>=1 :\\n                    break\\n            if d==0 :\\n                b+=1\\n        return b\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        a=list(text.split(\\' \\'))\\n        b=0\\n        c=[]\\n        for i in brokenLetters :\\n            if i not in c :\\n                c.append(i)\\n        for i in range(0,len(a)) :\\n            d=0\\n            for j in range(0,len(c)) :\\n                if c[j] in a[i] :\\n                    d+=1\\n                if d>=1 :\\n                    break\\n            if d==0 :\\n                b+=1\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984109,
                "title": "java-bruteforce-solution-maximum-number-of-words-you-can-type",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] typedWord = text.split(\" \");\\n        int total = typedWord.length;\\n        for(int i=0; i<typedWord.length; i++){\\n            for(int j=0; j<brokenLetters.length(); j++){\\n                if(typedWord[i].contains(brokenLetters.charAt(j)+\"\")){\\n                    total--;\\n                    break;\\n                }\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] typedWord = text.split(\" \");\\n        int total = typedWord.length;\\n        for(int i=0; i<typedWord.length; i++){\\n            for(int j=0; j<brokenLetters.length(); j++){\\n                if(typedWord[i].contains(brokenLetters.charAt(j)+\"\")){\\n                    total--;\\n                    break;\\n                }\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974841,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a hashmap of broken letters and iterate over the letters of the word in the given text, if a letter is found in hashmap then it is not possible to type. assume all the words are possible to type when you start, and subtract words which are not possible on the go.\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        \\n        String[] words = text.split(\" \");\\n        int totalWordsPossible = words.length;\\n\\n        if(brokenLetters.length() ==0 ){\\n            return totalWordsPossible;\\n        }\\n\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<brokenLetters.length(); i++){\\n            char letter = brokenLetters.charAt(i);\\n            map.put(letter, map.getOrDefault(letter, 0)+1);\\n        }\\n\\n        for( String word : words){         \\n            for( Character letter : word.toCharArray()){         \\n                if(map.containsKey(letter)){               \\n                    totalWordsPossible--;\\n                    break;\\n                }      \\n            }       \\n        }\\n\\n        return totalWordsPossible;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        \\n        String[] words = text.split(\" \");\\n        int totalWordsPossible = words.length;\\n\\n        if(brokenLetters.length() ==0 ){\\n            return totalWordsPossible;\\n        }\\n\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<brokenLetters.length(); i++){\\n            char letter = brokenLetters.charAt(i);\\n            map.put(letter, map.getOrDefault(letter, 0)+1);\\n        }\\n\\n        for( String word : words){         \\n            for( Character letter : word.toCharArray()){         \\n                if(map.containsKey(letter)){               \\n                    totalWordsPossible--;\\n                    break;\\n                }      \\n            }       \\n        }\\n\\n        return totalWordsPossible;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1779437,
                "content": [
                    {
                        "username": "harishp13",
                        "content": "class Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n          String s[] = text.split(\" \");\\n        int c = s.length;\\n        for (int i = 0; i < s.length; i++) {\\n            String l = s[i];\\n            int o=0;\\n            for (int m = 0; m < brokenLetters.length(); m++) {\\n                for (int j = 0; j < l.length(); j++) {\\n                    if (l.charAt(j) == brokenLetters.charAt(m))\\n                        o++;\\n                }\\n                }if(o!=0){\\n                c--;\\n            }\\n        }return c;\\n    }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Add Minimum Number of Rungs",
        "question_content": "<p>You are given a <strong>strictly increasing</strong> integer array <code>rungs</code> that represents the <strong>height</strong> of rungs on a ladder. You are currently on the <strong>floor</strong> at height <code>0</code>, and you want to reach the last rung.</p>\n\n<p>You are also given an integer <code>dist</code>. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is <strong>at most</strong> <code>dist</code>. You are able to insert rungs at any positive <strong>integer</strong> height if a rung is not already there.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of rungs that must be added to the ladder in order for you to climb to the last rung.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> rungs = [1,3,5,10], dist = 2\n<strong>Output:</strong> 2\n<strong>Explanation:\n</strong>You currently cannot reach the last rung.\nAdd rungs at heights 7 and 8 to climb this ladder. \nThe ladder will now have rungs at [1,3,5,<u>7</u>,<u>8</u>,10].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> rungs = [3,6,8,10], dist = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\nThis ladder can be climbed without adding additional rungs.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> rungs = [3,4,6,7], dist = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nYou currently cannot reach the first rung from the ground.\nAdd a rung at height 1 to climb this ladder.\nThe ladder will now have rungs at [<u>1</u>,3,4,6,7].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rungs.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= rungs[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= dist &lt;= 10<sup>9</sup></code></li>\n\t<li><code>rungs</code> is <strong>strictly increasing</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1344941,
                "title": "java-c-python-straight-forward",
                "content": "# **Explanation**\\nCompare the previous height `pre` and the current height `a`,\\nwe need `(a - pre - 1) / dist` extra rungs.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int addRungs(int[] A, int dist) {\\n        int pre = 0, res = 0;\\n        for (int a: A) {\\n            res += (a - pre - 1) / dist;\\n            pre = a;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int addRungs(vector<int>& A, int dist) {\\n        int pre = 0, res = 0;\\n        for (int a: A) {\\n            res += (a - pre - 1) / dist;\\n            pre = a;\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def addRungs(self, A, dist):\\n        pre = res = 0\\n        for a in A:\\n            res += (a - pre - 1) / dist\\n            pre = a\\n        return res\\n```\\n**Python 1-line for fun**\\n```py\\n    def addRungs(self, A, dist):\\n        return sum((b - a - 1) / dist for a, b in zip([0] + A, A))\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int addRungs(int[] A, int dist) {\\n        int pre = 0, res = 0;\\n        for (int a: A) {\\n            res += (a - pre - 1) / dist;\\n            pre = a;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int addRungs(vector<int>& A, int dist) {\\n        int pre = 0, res = 0;\\n        for (int a: A) {\\n            res += (a - pre - 1) / dist;\\n            pre = a;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def addRungs(self, A, dist):\\n        pre = res = 0\\n        for a in A:\\n            res += (a - pre - 1) / dist\\n            pre = a\\n        return res\\n```\n```py\\n    def addRungs(self, A, dist):\\n        return sum((b - a - 1) / dist for a, b in zip([0] + A, A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344878,
                "title": "divide-gaps-by-dist",
                "content": "The only trick here is to use division, as the gap between two rungs could be large. We will get TLE if we add rungs one-by-one.\\n\\n**Java**\\n```java\\npublic int addRungs(int[] rungs, int dist) {\\n    int res = (rungs[0] - 1) / dist;\\n    for (int i = 1; i < rungs.length; ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n}\\n```\\n**C++**\\n```cpp\\nint addRungs(vector<int>& rungs, int dist) {\\n    int res = (rungs[0] - 1) / dist;\\n    for (int i = 1; i < rungs.size(); ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        return sum((a - b - 1) // dist for a, b in zip(rungs, [0] + rungs))\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```java\\npublic int addRungs(int[] rungs, int dist) {\\n    int res = (rungs[0] - 1) / dist;\\n    for (int i = 1; i < rungs.length; ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n}\\n```\n```cpp\\nint addRungs(vector<int>& rungs, int dist) {\\n    int res = (rungs[0] - 1) / dist;\\n    for (int i = 1; i < rungs.size(); ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        return sum((a - b - 1) // dist for a, b in zip(rungs, [0] + rungs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344925,
                "title": "java-python-3-accumulate-the-division-of-gap-1-by-dist-w-brief-explanation",
                "content": "If any `gap` between nieghboring rungs is\\n1. no greater than `dist`, need `0` rung;\\n2. greater than `dist` by `1 ~ dist`, need `1` rung, by `dist + 1 ~ 2 * dist`, need `2` rungs...\\n\\nWe can conclude that **for any `gap`, we nned `(gap - 1) / dist` rungs.**\\n```java\\n    public int addRungs(int[] rungs, int dist) {\\n        int cnt = 0, prev = 0;\\n        for (int cur : rungs) {\\n            cnt += (cur - prev - 1) / dist;\\n            prev = cur;\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        cnt = prev = 0\\n        for cur in rungs:\\n            cnt += (cur - prev - 1) // dist\\n            prev = cur\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int addRungs(int[] rungs, int dist) {\\n        int cnt = 0, prev = 0;\\n        for (int cur : rungs) {\\n            cnt += (cur - prev - 1) / dist;\\n            prev = cur;\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        cnt = prev = 0\\n        for cur in rungs:\\n            cnt += (cur - prev - 1) // dist\\n            prev = cur\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344937,
                "title": "c-simple-math-solution-commented-explained",
                "content": "*  if you can\\'t reach the curr rung from the previoud one  using the given dist, then calculate the number of rungs you need .\\n*   number of rungs = (diff)/dist , where diff is the difference between current to the previous height\\n*   if the diff%dist ==0 then number of rungs decreases by one\\n*   for example if rungs=[4] number of rungs are 1 but not 2 (i.e., [2,4])\\n    \\n    \\n   - Time complexity -O(n)\\n  \\xA0space complexity O(1)\\n```\\nclass Solution {\\npublic:\\n    \\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count=0;\\n        \\n        //represents the previous height\\n        int prevHeight=0;\\n        int diff;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            diff=rungs[i]-prevHeight;\\n            if(diff>dist)\\n            {\\n                //the number of rungs needed to be inserted\\n                count+=(diff)/dist;\\n                //if the diference is divided by dist with 0 remainder then count may count-1 are needed\\n                //for example  [4] dist=2 here , (4-0)/2 =2 but (4-0)%2 == 0 so count decreases (count-1) the ans is [2,4]\\n                if((diff)%dist==0)\\n                    count--;\\n            }\\n            prevHeight=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count=0;\\n        \\n        //represents the previous height\\n        int prevHeight=0;\\n        int diff;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            diff=rungs[i]-prevHeight;\\n            if(diff>dist)\\n            {\\n                //the number of rungs needed to be inserted\\n                count+=(diff)/dist;\\n                //if the diference is divided by dist with 0 remainder then count may count-1 are needed\\n                //for example  [4] dist=2 here , (4-0)/2 =2 but (4-0)%2 == 0 so count decreases (count-1) the ans is [2,4]\\n                if((diff)%dist==0)\\n                    count--;\\n            }\\n            prevHeight=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345138,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist){\\n        int cnt=0;\\n        for(int i=rungs.size()-1;i>=0;i--){\\n           int j=(i!=0)?(rungs[i]-rungs[i-1]):rungs[i];\\n           if(j>dist){\\n               cnt+=((j-1)/dist);\\n\\t\\t\\t   //or\\n\\t\\t\\t   //cnt+=(j/dist)-1;\\n               //if(j%dist > 0) cnt++;\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist){\\n        int cnt=0;\\n        for(int i=rungs.size()-1;i>=0;i--){\\n           int j=(i!=0)?(rungs[i]-rungs[i-1]):rungs[i];\\n           if(j>dist){\\n               cnt+=((j-1)/dist);\\n\\t\\t\\t   //or\\n\\t\\t\\t   //cnt+=(j/dist)-1;\\n               //if(j%dist > 0) cnt++;\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700794,
                "title": "easy-c-solution-by-dividing-with-gaps-each-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int pre=0,c=0;\\n        int n=rungs.size();\\n        for(int i=0;i<n;i++){\\n            c+=(rungs[i]-pre-1)/dist;\\n            pre=rungs[i];\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int pre=0,c=0;\\n        int n=rungs.size();\\n        for(int i=0;i<n;i++){\\n            c+=(rungs[i]-pre-1)/dist;\\n            pre=rungs[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1346425,
                "title": "it-should-be-tagged-as-easy-instead-of-medium",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n = rungs.size();\\n        vector<int>arr(n+1,0);\\n        for(int i=1;i<=n;i++) arr[i] = rungs[i-1];\\n        \\n        int count = 0;\\n        for(int i=1;i<=n;i++){\\n            if(arr[i] - arr[i-1] > dist){\\n                int diff = arr[i]-arr[i-1];\\n                count += diff/dist;\\n                if(diff%dist == 0) count--;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n = rungs.size();\\n        vector<int>arr(n+1,0);\\n        for(int i=1;i<=n;i++) arr[i] = rungs[i-1];\\n        \\n        int count = 0;\\n        for(int i=1;i<=n;i++){\\n            if(arr[i] - arr[i-1] > dist){\\n                int diff = arr[i]-arr[i-1];\\n                count += diff/dist;\\n                if(diff%dist == 0) count--;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362810,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int addRungs(vector<int>& a, int d) \\n   {\\n        int n=a.size();\\n        int c=0;\\n        if(a[0]>d)\\n            c+=(a[0]-1)/d;       \\n        for(int i=1;i<n;i++)\\n        {\\n            if((a[i]-a[i-1])>d)\\n            {\\n                c+=(a[i]-a[i-1]-1)/d;\\n            }\\n        }\\n        return c;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int addRungs(vector<int>& a, int d) \\n   {\\n        int n=a.size();\\n        int c=0;\\n        if(a[0]>d)\\n            c+=(a[0]-1)/d;       \\n        for(int i=1;i<n;i++)\\n        {\\n            if((a[i]-a[i-1])>d)\\n            {\\n                c+=(a[i]-a[i-1]-1)/d;\\n            }\\n        }\\n        return c;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757807,
                "title": "c-solution-o-n-solution-beginner-friendly",
                "content": "``` Very easy solution . Beginner friendly```\\n``` Time complexity :- O(n)```\\n``` Space complexity :- O(1)```\\n```\\n int addRungs(vector<int>& a, int d) {\\n        int n=a.size();\\n        int c=0;\\n        if(a[0]>d)\\n            c+=(a[0]-1)/d;        // If the first element is greater than d(distance).\\n        for(int i=1;i<n;i++)\\n        {\\n            if((a[i]-a[i-1])>d)\\n            {\\n                c+=(a[i]-a[i-1]-1)/d;\\n            }\\n        }\\n        return c;          // Returned the count.\\n    }\\n```\\n``` If you like my approach then hit the like button.```",
                "solutionTags": [],
                "code": "``` Very easy solution . Beginner friendly```\n``` Time complexity :- O(n)```\n``` Space complexity :- O(1)```\n```\\n int addRungs(vector<int>& a, int d) {\\n        int n=a.size();\\n        int c=0;\\n        if(a[0]>d)\\n            c+=(a[0]-1)/d;        // If the first element is greater than d(distance).\\n        for(int i=1;i<n;i++)\\n        {\\n            if((a[i]-a[i-1])>d)\\n            {\\n                c+=(a[i]-a[i-1]-1)/d;\\n            }\\n        }\\n        return c;          // Returned the count.\\n    }\\n```\n``` If you like my approach then hit the like button.```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365986,
                "title": "easy-cpp",
                "content": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count=0;\\n        for(int i=0; i<rungs.size(); i++){\\n            long long int temp;\\n            if(i==0)\\n                temp=rungs[i];\\n            else\\n                temp=rungs[i]-rungs[i-1];\\n            if(temp <= dist) continue;\\n            if(temp % dist==0) \\n            temp--;\\n            count+=(temp/dist);\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count=0;\\n        for(int i=0; i<rungs.size(); i++){\\n            long long int temp;\\n            if(i==0)\\n                temp=rungs[i];\\n            else\\n                temp=rungs[i]-rungs[i-1];\\n            if(temp <= dist) continue;\\n            if(temp % dist==0) \\n            temp--;\\n            count+=(temp/dist);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1345151,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cnt=0;\\n        int n=rungs.size();\\n        if(rungs[n-1]<dist)          \\n            return 0;\\n        if(rungs[0]>dist){            \\n            if(rungs[0]%dist==0)\\n             cnt+=(rungs[0]/dist)-1;\\n            else\\n             cnt+=rungs[0]/dist;\\n        }\\n        for(int i=0;i+1<n;i++){\\n            int x=rungs[i+1]-rungs[i];\\n            if(x >dist){\\n                if(x%dist==0)\\n                cnt+=(x/dist)-1;\\n                else\\n                    cnt+=x/dist;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nDo upvote, if u find it helpful !!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cnt=0;\\n        int n=rungs.size();\\n        if(rungs[n-1]<dist)          \\n            return 0;\\n        if(rungs[0]>dist){            \\n            if(rungs[0]%dist==0)\\n             cnt+=(rungs[0]/dist)-1;\\n            else\\n             cnt+=rungs[0]/dist;\\n        }\\n        for(int i=0;i+1<n;i++){\\n            int x=rungs[i+1]-rungs[i];\\n            if(x >dist){\\n                if(x%dist==0)\\n                cnt+=(x/dist)-1;\\n                else\\n                    cnt+=x/dist;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345016,
                "title": "o-n-python-solution-with-explanation-for-1",
                "content": "We simply iterate through rungs, keeping track of what the height of the previous rung was. If the difference in height between the current and previous rung is greater than the `dist` parameter, i.e. greater than the maximum distance we\\'re allowed to go up, we divide the height difference by `dist`. If `dist = 2` and height difference between the previous rung and current rung is `3`, we get `1.5` which we can simply truncate to `1`.\\n\\nThere are some cases this doesn\\'t cover, which comes up when the height difference is exactly divisible by `dist`, i.e. placing the minimum number of rungs puts us exactly *at* the next rung, from where we need to go a distance of `0` to get to the next rung. For example, when `dist = 2` and the difference between the previous and current rung is `4`, `4/2` would give us `2`, but we know that once we go up a distance of `2` from the previous rung, there already is a rung at a distance of `2` from there. For cases like this, we\\'d add one less rung than we usually do. \\n\\nIn the division `diff / dist`, this only happens when we get a whole number output (like `4/2 = 2` above); so we can simply check if the division result is a whole number or not, and take one out of the number of rungs to add if it is.\\n\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        newrungs = 0\\n        prev = 0\\n        \\n        for rung in rungs:\\n            diff = rung - prev\\n            \\n            if diff > dist:\\n                add = diff / dist # Number of rungs we need to add\\n                \\n                if add % 1 == 0:\\n                    add = int(add) - 1\\n                else:\\n                    add = int(add)\\n                newrungs += add\\n            prev = rung\\n        \\n\\t\\treturn newrungs\\n```\\n\\nAlternatively, if we subtract `1` from the difference between the previous and current rung, we do not need to check whether the division result is a whole number or not. For the first case above, `diff = 3` and `dist = 2`, we end up with `(3-1)/2 = 1` instead of `1.5`, removing the need to round down to get `1`. For the second case, `diff = 4` and `dist = 2`, we end up with `(4-1)/2 = 1.5`, which has to be truncated to `1`. Both cases require no additional checking, which helps simplify the code a fair bit.\\n\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        newrungs = 0\\n        prev = 0\\n        \\n        for rung in rungs:\\n            diff = rung - prev - 1\\n            newrungs += diff // dist\\n            prev = rung\\n        \\n        return newrungs\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        newrungs = 0\\n        prev = 0\\n        \\n        for rung in rungs:\\n            diff = rung - prev\\n            \\n            if diff > dist:\\n                add = diff / dist # Number of rungs we need to add\\n                \\n                if add % 1 == 0:\\n                    add = int(add) - 1\\n                else:\\n                    add = int(add)\\n                newrungs += add\\n            prev = rung\\n        \\n\\t\\treturn newrungs\\n```\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        newrungs = 0\\n        prev = 0\\n        \\n        for rung in rungs:\\n            diff = rung - prev - 1\\n            newrungs += diff // dist\\n            prev = rung\\n        \\n        return newrungs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344886,
                "title": "c-easy-to-understand-finding-gaps",
                "content": "The apporach is simple \\nhere we have to calculate the height difference between each rung.\\nthen we will check if that height difference is reachable or not.\\nif not reachable then, we will add (height diff - 1)/dist to find the no. of rungs needed to make it reachable.\\n\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n//         make a vector to store the differences\\n        vector<int> val(rungs.size());\\n        val[0]=rungs[0];\\n        for(int i=1;i<rungs.size();i++)\\n        {\\n            val[i]=rungs[i]-rungs[i-1];\\n        }\\n        int count=0;\\n//         iterate over the differences array\\n//         and count the numbers of rungs needed to make the climb possible\\n         for(int i=0;i<val.size();i++)\\n         {\\n             if(val[i]>dist)\\n             {\\n                 count+=((double)(val[i]-1)/dist);\\n             }\\n         }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n//         make a vector to store the differences\\n        vector<int> val(rungs.size());\\n        val[0]=rungs[0];\\n        for(int i=1;i<rungs.size();i++)\\n        {\\n            val[i]=rungs[i]-rungs[i-1];\\n        }\\n        int count=0;\\n//         iterate over the differences array\\n//         and count the numbers of rungs needed to make the climb possible\\n         for(int i=0;i<val.size();i++)\\n         {\\n             if(val[i]>dist)\\n             {\\n                 count+=((double)(val[i]-1)/dist);\\n             }\\n         }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633568,
                "title": "greedy-c-very-simple",
                "content": "# if it Helps You. Please Upvote Me..!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is Simple, just Calculate the difference between **current positions and Next Position**, if **Difference** is **Fully Divisible** by given **dist** then add **Difference/dist-1** to the **answer** otherwise add **difference/dist** to the **answer**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& arr, int d) {\\n        int count = 0,pos = 0,n = arr.size();\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n          int dif = arr[i]-pos;\\n\\n          if(dif>d)\\n          {\\n            if(dif%d==0)\\n            count+=(dif/d-1);\\n            else\\n            count+=(dif/d);\\n          }\\n          pos = arr[i];\\n          \\n        }\\n\\n        return count;\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/f519ef05-8d79-42ea-baba-68d9a4d61b43_1686664921.6870508.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& arr, int d) {\\n        int count = 0,pos = 0,n = arr.size();\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n          int dif = arr[i]-pos;\\n\\n          if(dif>d)\\n          {\\n            if(dif%d==0)\\n            count+=(dif/d-1);\\n            else\\n            count+=(dif/d);\\n          }\\n          pos = arr[i];\\n          \\n        }\\n\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553738,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Greedy***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& nums, int dist) {\\n        \\n        int n = nums.size();\\n        \\n        int count = 0;\\n        \\n        // prev will store the height at which i am standing\\n        \\n        int prev = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if we can reach the rung\\n            \\n            if(prev + dist >= nums[i])\\n            {\\n                prev = nums[i];\\n            }\\n            \\n            // if we can\\'t reach the rung\\n            \\n            // count the no. of rungs we have to add in the ladder to reach next rung\\n            \\n            else\\n            {\\n                int req_rung = (nums[i] - prev) / dist;\\n                \\n                if((nums[i] - prev) % dist == 0)\\n                {\\n                    req_rung--;\\n                }\\n                \\n                // update count\\n                \\n                count += req_rung;\\n                \\n                prev = nums[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& nums, int dist) {\\n        \\n        int n = nums.size();\\n        \\n        int count = 0;\\n        \\n        // prev will store the height at which i am standing\\n        \\n        int prev = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if we can reach the rung\\n            \\n            if(prev + dist >= nums[i])\\n            {\\n                prev = nums[i];\\n            }\\n            \\n            // if we can\\'t reach the rung\\n            \\n            // count the no. of rungs we have to add in the ladder to reach next rung\\n            \\n            else\\n            {\\n                int req_rung = (nums[i] - prev) / dist;\\n                \\n                if((nums[i] - prev) % dist == 0)\\n                {\\n                    req_rung--;\\n                }\\n                \\n                // update count\\n                \\n                count += req_rung;\\n                \\n                prev = nums[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680088,
                "title": "simple-straight-forward-javascript-solution",
                "content": "Solution based on [[Java/C++/Python] Straight Forward](https://leetcode.com/problems/add-minimum-number-of-rungs/discuss/1344941/JavaC%2B%2BPython-Straight-Forward) by [lee215](https://leetcode.com/lee215/)\\n\\n**Short Explanation**\\nCompare the previous height pre and the current height a,\\nwe need (a - pre - 1) / dist extra rungs.\\n\\n**Long Explanation** - by [kunqian](https://leetcode.com/kunqian/) \\nExplanation:\\nImagine we need at least k rungs between A[i - 1] ~ A[i], then we have the following relationships:\\n\\nA[i - 1] + (k + 1) * dist >= A[i]\\nA[i - 1] + k * dist < A[i] => [(A[i] - A[i - 1]) / dist] - 1 <= k < (A[i] - A[i - 1]) / dist\\nif D = (A[i] - A[i - 1]) / dist, D is a float and k is an integer\\nwe have D - 1 <= k < D, so k is biggest int that smaller than D, which is (A[i] - A[i - 1] - 1) // dist.\\n\\n**Complexity**\\n```\\nTime O(n)\\nSpace O(1)\\n```\\n\\n**JavaScript Code** \\n```\\nvar addRungs = function(rungs, dist) {\\n    let res = 0;\\n    let prev = 0;\\n    for ( let i = 0; i < rungs.length; i++ ){\\n        res += Math.floor(( rungs[i] - prev - 1 ) / dist ); \\n        prev = rungs[i];\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nTime O(n)\\nSpace O(1)\\n```\n```\\nvar addRungs = function(rungs, dist) {\\n    let res = 0;\\n    let prev = 0;\\n    for ( let i = 0; i < rungs.length; i++ ){\\n        res += Math.floor(( rungs[i] - prev - 1 ) / dist ); \\n        prev = rungs[i];\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1364199,
                "title": "python-easy-to-understand-faster-than-87-16",
                "content": "Runtime: 532 ms, faster than 87.16% of Python3 online submissions for Add Minimum Number of Rungs.\\nMemory Usage: 28.8 MB, less than 47.33% of Python3 online submissions for Add Minimum Number of Rungs.\\n\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        if rungs[0] > dist:\\n            m = rungs[0]\\n            m = (m - 1) // dist\\n            count += m\\n        for i in range (len(rungs) - 1):\\n            k = rungs[i+1] - rungs[i]\\n            if k > dist:\\n                \\n                n = (k-1) // dist\\n                count += n\\n        return count      \\n```\\n\\nFeel free to ask your doubts in comment section, Please do upvote.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        if rungs[0] > dist:\\n            m = rungs[0]\\n            m = (m - 1) // dist\\n            count += m\\n        for i in range (len(rungs) - 1):\\n            k = rungs[i+1] - rungs[i]\\n            if k > dist:\\n                \\n                n = (k-1) // dist\\n                count += n\\n        return count      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349799,
                "title": "c-just-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int spot = 0, count = 0;\\n        for (int i = 0; i < rungs.size(); i++) {\\n            if (spot + dist < rungs[i]) {\\n                count += (rungs[i] - 1 - spot) / dist;\\n            }\\n            spot = rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int spot = 0, count = 0;\\n        for (int i = 0; i < rungs.size(); i++) {\\n            if (spot + dist < rungs[i]) {\\n                count += (rungs[i] - 1 - spot) / dist;\\n            }\\n            spot = rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345278,
                "title": "c-explanation-efficient-solution-time-o-n-auxiliary-space-o-1",
                "content": "Explanation: \\n\\n**Input**\\n\\nrungs = [6,12,13,14,15], dist = 2\\n\\n**Output** = 4\\n\\n\\n**Ladder**\\n\\n**---15**\\n**---14**\\n**---13**\\n**---12**\\n---11\\n---10\\n---9\\n---8\\n---7\\n**---6**\\n---5\\n---4\\n---3\\n---2\\n---1\\n**---0**\\n\\n**Concept of count1=(rungs[i]-rungs[i-1]-1)/dist vs count2=(rungs[i]-rungs[i-1])/dist**\\n\\nFor example : If i=2, count1=(12-6)/2=3 & count2=(12-6-1)/2=2. From ladder diagram, if we add rungs at 8 & 10, it will enable us to climb from 6 to 12 in steps of 8-6=2=dist, 10-8=2=dist, 12-10=2=dist by adding minimum number of rungs. Hence, count2 is the correct equation.\\n\\n**Efficient Solution** \\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n\\t    // Efficient Solution Time O(N) & Auxiliary Space O(1)\\n        int len=rungs.size();\\n        int count=(rungs[0]-1)/dist; \\n        if(len==1)\\n            return count;\\n        for(int i=1;i<len;i++){\\n            count+=(rungs[i]-rungs[i-1]-1)/dist;\\n        }\\n      return count;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n\\t    // Efficient Solution Time O(N) & Auxiliary Space O(1)\\n        int len=rungs.size();\\n        int count=(rungs[0]-1)/dist; \\n        if(len==1)\\n            return count;\\n        for(int i=1;i<len;i++){\\n            count+=(rungs[i]-rungs[i-1]-1)/dist;\\n        }\\n      return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344992,
                "title": "java-simple-division-self-written-ceiling-function",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        //greedy\\n        int last=0;\\n        int res=0;\\n        for (int cur:rungs){\\n            if (cur-last>dist){\\n                //self written ceiling funtion\\n                int batch = (cur-last)/dist -1;\\n                if ((cur-last)%dist > 0){\\n                    batch+=1;\\n                }\\n                res+=batch;\\n            }\\n            last=cur;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        //greedy\\n        int last=0;\\n        int res=0;\\n        for (int cur:rungs){\\n            if (cur-last>dist){\\n                //self written ceiling funtion\\n                int batch = (cur-last)/dist -1;\\n                if ((cur-last)%dist > 0){\\n                    batch+=1;\\n                }\\n                res+=batch;\\n            }\\n            last=cur;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344963,
                "title": "java-straight-forward-5-lines",
                "content": "```java\\n public int addRungs(int[] rungs, int dist) {\\n        int s = 0, res = 0;\\n       for (int i = 0; i < rungs.length ; i++) {\\n           res += (rungs[i] - s - 1) / dist;\\n           s = rungs[i];\\n       }\\n       return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public int addRungs(int[] rungs, int dist) {\\n        int s = 0, res = 0;\\n       for (int i = 0; i < rungs.length ; i++) {\\n           res += (rungs[i] - s - 1) / dist;\\n           s = rungs[i];\\n       }\\n       return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344946,
                "title": "easy-java-o-n-solution",
                "content": "What we do here is that we traverse the array if our height is more that rungs[i], then we will keep it rungs[i].\\n\\nBut if not then we will get the difference between the rungs[i] and our height and add the ceil to the count and update the count this way.\\n\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        int curHeight = 0;\\n        \\n        for(int i = 0; i < rungs.length; i++){\\n            curHeight += dist;\\n            if(curHeight >= rungs[i]){\\n                curHeight = rungs[i];\\n            }else{\\n                int diff = (rungs[i] - curHeight);\\n                count += (int)(Math.ceil((double)diff/dist));\\n                curHeight = rungs[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        int curHeight = 0;\\n        \\n        for(int i = 0; i < rungs.length; i++){\\n            curHeight += dist;\\n            if(curHeight >= rungs[i]){\\n                curHeight = rungs[i];\\n            }else{\\n                int diff = (rungs[i] - curHeight);\\n                count += (int)(Math.ceil((double)diff/dist));\\n                curHeight = rungs[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839932,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int n=rungs.size();\\n        int count=0;\\n        int pre=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            count+=(rungs[i]-pre-1)/dist;\\n            pre=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int n=rungs.size();\\n        int count=0;\\n        int pre=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            count+=(rungs[i]-pre-1)/dist;\\n            pre=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565358,
                "title": "1-ms-just-move-rung-by-rung",
                "content": "## Java\\n```java\\npublic int addRungs(int[] rungs, int dist) {\\n    var answer = 0;\\n    for (int current = 0, i = 0; i < rungs.length; current = rungs[i++]) {\\n        int height;\\n        if ((height = rungs[i] - current) > dist) {\\n            answer += (height - 1) / dist;\\n        }\\n    }\\n    return answer;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int addRungs(int[] rungs, int dist) {\\n    var answer = 0;\\n    for (int current = 0, i = 0; i < rungs.length; current = rungs[i++]) {\\n        int height;\\n        if ((height = rungs[i] - current) > dist) {\\n            answer += (height - 1) / dist;\\n        }\\n    }\\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282999,
                "title": "greedy-easy-to-understand-eazy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n         //to keep the track of the number of extra rung to be added\\n         long long int count = 0;\\n       \\n         //our curr pos at the beggining\\n         long long int currpos = 0;\\n\\n         //to keep the track of the next pos to be climed\\n         long long int nextposidx = 0;\\n\\n         while(true)\\n         {\\n             if(currpos == rungs[rungs.size()-1])\\n             {\\n                 break;\\n             }\\n\\n             if((rungs[nextposidx] - currpos) <= dist)\\n             {\\n                 currpos = rungs[nextposidx];\\n                 nextposidx++;\\n             }\\n             else\\n             {\\n                 //cout<<\"hello\"<<endl;\\n                 long long int temp = (rungs[nextposidx] - currpos);\\n                 //cout<<\"temp = \"<<temp<<endl;\\n                 \\n                 if((temp%dist) == 0)\\n                 {\\n                     long long int val = temp/dist;\\n                     count = count + (val - 1);\\n                 }\\n                 else\\n                 {\\n                    long long int val = floor(((temp*1.00)/(dist*1.00)));\\n                    count = count + (val);\\n                 }\\n                 currpos = rungs[nextposidx];\\n             }\\n         }\\n         return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n         //to keep the track of the number of extra rung to be added\\n         long long int count = 0;\\n       \\n         //our curr pos at the beggining\\n         long long int currpos = 0;\\n\\n         //to keep the track of the next pos to be climed\\n         long long int nextposidx = 0;\\n\\n         while(true)\\n         {\\n             if(currpos == rungs[rungs.size()-1])\\n             {\\n                 break;\\n             }\\n\\n             if((rungs[nextposidx] - currpos) <= dist)\\n             {\\n                 currpos = rungs[nextposidx];\\n                 nextposidx++;\\n             }\\n             else\\n             {\\n                 //cout<<\"hello\"<<endl;\\n                 long long int temp = (rungs[nextposidx] - currpos);\\n                 //cout<<\"temp = \"<<temp<<endl;\\n                 \\n                 if((temp%dist) == 0)\\n                 {\\n                     long long int val = temp/dist;\\n                     count = count + (val - 1);\\n                 }\\n                 else\\n                 {\\n                    long long int val = floor(((temp*1.00)/(dist*1.00)));\\n                    count = count + (val);\\n                 }\\n                 currpos = rungs[nextposidx];\\n             }\\n         }\\n         return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2926135,
                "title": "100-0ms-easy-o-n-proof",
                "content": "# upvote pls\\n\\n# Complexity\\n- Time complexity: n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/09ef1aff-32f0-4e0c-bcdc-c0a3b2c2d773_1671384607.6674387.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] R, int D) {\\n        int st=0,c=0;\\n        for(int i:R){\\n            c+=(i-st-1)/D;\\n            st=i;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] R, int D) {\\n        int st=0,c=0;\\n        for(int i:R){\\n            c+=(i-st-1)/D;\\n            st=i;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496891,
                "title": "c-easiest-medium-i-ever-saw-on-leetcode",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        for(int i=0; i<rungs.size()-1; i++) ans+=(rungs[i+1]-rungs[i]-1)/dist;\\n        ans+=(rungs[0]-1)/dist;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        for(int i=0; i<rungs.size()-1; i++) ans+=(rungs[i+1]-rungs[i]-1)/dist;\\n        ans+=(rungs[0]-1)/dist;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447400,
                "title": "python-2-line-simple-solution",
                "content": "```\\ndef addRungs(self, nums: List[int], d: int) -> int:\\n\\tnums = [0]+nums\\n\\treturn sum(ceil((nums[i+1]-nums[i])/d)-1 for i in range(len(nums)-1))\\n```",
                "solutionTags": [],
                "code": "```\\ndef addRungs(self, nums: List[int], d: int) -> int:\\n\\tnums = [0]+nums\\n\\treturn sum(ceil((nums[i+1]-nums[i])/d)-1 for i in range(len(nums)-1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2281037,
                "title": "c-easy-solution",
                "content": "```\\n  int n=r.size();\\n       \\n       int cnt=0;\\n        if(r[0]>d){\\n            cnt+=(r[0]-1)/d;\\n        }\\n        for(int i=1;i<n;i++){\\n           int val=r[i]-r[i-1];\\n            if(val>d){\\n                cnt+=(val-1)/d;\\n            }\\n            \\n        }\\n        return cnt;",
                "solutionTags": [],
                "code": "```\\n  int n=r.size();\\n       \\n       int cnt=0;\\n        if(r[0]>d){\\n            cnt+=(r[0]-1)/d;\\n        }\\n        for(int i=1;i<n;i++){\\n           int val=r[i]-r[i-1];\\n            if(val>d){\\n                cnt+=(val-1)/d;\\n            }\\n            \\n        }\\n        return cnt;",
                "codeTag": "Unknown"
            },
            {
                "id": 2266506,
                "title": "java-solution-o-n-time-o-1-space",
                "content": "```java \\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int c=(rungs[0]-0)/dist;\\n        if((rungs[0]-0)%dist==0)\\n        c--;\\n        for(int i=1;i<rungs.length;i++)\\n        {\\n            c+=(rungs[i]-rungs[i-1])/dist;\\n            if((rungs[i]-rungs[i-1])%dist==0)\\n            c--;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int c=(rungs[0]-0)/dist;\\n        if((rungs[0]-0)%dist==0)\\n        c--;\\n        for(int i=1;i<rungs.length;i++)\\n        {\\n            c+=(rungs[i]-rungs[i-1])/dist;\\n            if((rungs[i]-rungs[i-1])%dist==0)\\n            c--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2243766,
                "title": "java-faster-than-100-o-n",
                "content": "```class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int rungsNeeded = 0;\\n        \\n        if(rungs[0] - 0 > dist)\\n            rungsNeeded += (rungs[0] - 1) / dist;\\n        \\n        for(int i = 1; i < rungs.length; i++) {\\n            \\n            if(rungs[i] - rungs[i-1] > dist) {\\n                rungsNeeded += (rungs[i] - rungs[i-1] - 1) / dist;\\n            }\\n        }\\n        \\n        return rungsNeeded;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int rungsNeeded = 0;\\n        \\n        if(rungs[0] - 0 > dist)\\n            rungsNeeded += (rungs[0] - 1) / dist;\\n        \\n        for(int i = 1; i < rungs.length; i++) {\\n            \\n            if(rungs[i] - rungs[i-1] > dist) {\\n                rungsNeeded += (rungs[i] - rungs[i-1] - 1) / dist;\\n            }\\n        }\\n        \\n        return rungsNeeded;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2152380,
                "title": "c-divide-gaps-by-dist-explanation",
                "content": "Sharing my solution here :\\n+ greedy approach\\n+ optimised linear traversal\\n\\n**We need to take care of following:**\\n1.  take difference between consecutive jumps, and use division of difference by the at most distance (\\'dist\\') allowed. This way we can do better than 0(n) traversal\\n2.   if difference is a multiple of \\'dist\\', then we require those many rungs (see #3) else there will be a remainder left (less than \\'dist\\') so we would require extra rung for that\\n3.    at every step we can do a jump of atmost \\'dist\\', if we want to go higher than this we need extra rug, so in division we ned to subtract this as this jump at each step is allowed / 0 cost.\\n\\n \\n     int solution(vector<int> &rungs, int dist) {\\n\\t\\tconst int len = rungs.size();\\n        int count = 0, prev_rung = 0;\\n        \\n        // traverse and add any additional rung required\\n        for (int curr_rung : rungs) {\\n            if (curr_rung - prev_rung > dist) {\\n                int diff = curr_rung - prev_rung;\\n                // if the \\'diff\\' is not a multiple, add 1\\n                // -1 as a jump of atmost \\'dist\\' is allowed (0 cost)\\n                count += (diff / dist) + (diff % dist > 0 ? 1 : 0) - 1;\\n            }\\n            \\n            prev_rung = curr_rung;\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "Sharing my solution here :\\n+ greedy approach\\n+ optimised linear traversal\\n\\n**We need to take care of following:**\\n1.  take difference between consecutive jumps, and use division of difference by the at most distance (\\'dist\\') allowed. This way we can do better than 0(n) traversal\\n2.   if difference is a multiple of \\'dist\\', then we require those many rungs (see #3) else there will be a remainder left (less than \\'dist\\') so we would require extra rung for that\\n3.    at every step we can do a jump of atmost \\'dist\\', if we want to go higher than this we need extra rug, so in division we ned to subtract this as this jump at each step is allowed / 0 cost.\\n\\n \\n     int solution(vector<int> &rungs, int dist) {\\n\\t\\tconst int len = rungs.size();\\n        int count = 0, prev_rung = 0;\\n        \\n        // traverse and add any additional rung required\\n        for (int curr_rung : rungs) {\\n            if (curr_rung - prev_rung > dist) {\\n                int diff = curr_rung - prev_rung;\\n                // if the \\'diff\\' is not a multiple, add 1\\n                // -1 as a jump of atmost \\'dist\\' is allowed (0 cost)\\n                count += (diff / dist) + (diff % dist > 0 ? 1 : 0) - 1;\\n            }\\n            \\n            prev_rung = curr_rung;\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1849480,
                "title": "only-3-lines-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int s=(rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.size();i++) s+=(rungs[i]-rungs[i-1]-1)/dist;\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int s=(rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.size();i++) s+=(rungs[i]-rungs[i-1]-1)/dist;\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846169,
                "title": "java-two-solutions",
                "content": "This is not a Binary-search problem but the first thing that came into my mind was binary search and not greedy :( ........\\ni think i have done enough binary search problems, also this was recommended after a binary search problem.\\n\\n**BinarySearch :**\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        //  if we are given the amount of rungs that can be inserted\\n        //  check if it is possible to go from ground to the last stair\\n        int n = rungs.length;\\n        int l = 0;\\n        int r = rungs[n - 1] / dist;\\n        int ans = 0;\\n        while (l <= r) {\\n            //  allowed steps rungs = mid\\n            int mid = (l + r) / 2;\\n            if (isPossible(rungs, mid, dist)) {\\n                ans = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[] a, int allowed, int step) {\\n        int curr_rungs = a[0] / step + (a[0] % step == 0 ? -1 : 0);\\n        if (curr_rungs > allowed) {\\n            return false;\\n        }\\n        for (int i = 1; i < a.length; i++) {\\n            int diff = a[i] - a[i - 1];\\n            if (diff > step) {\\n                curr_rungs += diff / step + (diff % step == 0 ? -1 : 0);\\n            }\\n            if (curr_rungs > allowed) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**Greedy :**\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int n = rungs.length;\\n        int ans = 0;\\n        ans = rungs[0] / dist + (rungs[0] % dist == 0 ? -1 : 0);\\n        for (int i = 1; i < n; i++) {\\n            int diff = rungs[i] - rungs[i - 1];\\n            ans += diff / dist + (diff % dist == 0 ? -1 : 0);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        //  if we are given the amount of rungs that can be inserted\\n        //  check if it is possible to go from ground to the last stair\\n        int n = rungs.length;\\n        int l = 0;\\n        int r = rungs[n - 1] / dist;\\n        int ans = 0;\\n        while (l <= r) {\\n            //  allowed steps rungs = mid\\n            int mid = (l + r) / 2;\\n            if (isPossible(rungs, mid, dist)) {\\n                ans = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[] a, int allowed, int step) {\\n        int curr_rungs = a[0] / step + (a[0] % step == 0 ? -1 : 0);\\n        if (curr_rungs > allowed) {\\n            return false;\\n        }\\n        for (int i = 1; i < a.length; i++) {\\n            int diff = a[i] - a[i - 1];\\n            if (diff > step) {\\n                curr_rungs += diff / step + (diff % step == 0 ? -1 : 0);\\n            }\\n            if (curr_rungs > allowed) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int n = rungs.length;\\n        int ans = 0;\\n        ans = rungs[0] / dist + (rungs[0] % dist == 0 ? -1 : 0);\\n        for (int i = 1; i < n; i++) {\\n            int diff = rungs[i] - rungs[i - 1];\\n            ans += diff / dist + (diff % dist == 0 ? -1 : 0);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577549,
                "title": "c-greedy-solution-easy-to-understand",
                "content": "## class Solution {\\n## public:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        if(rungs[0]-0>dist){\\n            if(rungs[0]%dist==0)\\n                ans+=rungs[0]/dist -1;\\n            else\\n                ans+=rungs[0]/dist;\\n        }\\n        for(int i=1; i<rungs.size(); i++){\\n            if(rungs[i]-rungs[i-1]>dist){\\n                if((rungs[i]-rungs[i-1])%dist==0)\\n                    ans+=(rungs[i]-rungs[i-1])/dist -1;\\n                else\\n                    ans+=(rungs[i]-rungs[i-1])/dist;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n## public:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        if(rungs[0]-0>dist){\\n            if(rungs[0]%dist==0)\\n                ans+=rungs[0]/dist -1;\\n            else\\n                ans+=rungs[0]/dist;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1512546,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n        \\n        int ans=0;\\n        ans=(rungs[0]-1)/dist;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            ans+=(rungs[i]-rungs[i-1]-1)/dist;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n        \\n        int ans=0;\\n        ans=(rungs[0]-1)/dist;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            ans+=(rungs[i]-rungs[i-1]-1)/dist;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1405676,
                "title": "7-lines-1ms-java-code-beats-99-97-codes",
                "content": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count=0;\\n        int min=0;\\n        for(int i=0;i<rungs.length;i++)\\n        {\\n            if((rungs[i]-min)>dist)\\n            {\\n                count=count+(rungs[i]-1-min)/dist;\\n            }\\n              min=rungs[i];\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count=0;\\n        int min=0;\\n        for(int i=0;i<rungs.length;i++)\\n        {\\n            if((rungs[i]-min)>dist)\\n            {\\n                count=count+(rungs[i]-1-min)/dist;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1398182,
                "title": "c-o-1-space-o-n-speed",
                "content": "```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        if (rungs == null) {\\n            return -1;\\n        }\\n        \\n        int rungsToAdd = 0;\\n        for (int i = rungs.Length - 1; i >= 0; i--) {\\n            int nextHeight = i == 0 ? 0 : rungs[i - 1];\\n            int distance = rungs[i] - nextHeight;\\n            rungsToAdd += (distance / dist);\\n            if (distance % dist == 0) {\\n                rungsToAdd--;\\n            }\\n        }\\n        \\n        return rungsToAdd;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        if (rungs == null) {\\n            return -1;\\n        }\\n        \\n        int rungsToAdd = 0;\\n        for (int i = rungs.Length - 1; i >= 0; i--) {\\n            int nextHeight = i == 0 ? 0 : rungs[i - 1];\\n            int distance = rungs[i] - nextHeight;\\n            rungsToAdd += (distance / dist);\\n            if (distance % dist == 0) {\\n                rungsToAdd--;\\n            }\\n        }\\n        \\n        return rungsToAdd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389428,
                "title": "greedy-c",
                "content": "\\n```\\nint addRungs(vector<int>& rungs, int dist) {\\n      int c=0;\\n     int p=0;\\n     for(int i=0;i<rungs.size();i++){\\n       c+=(rungs[i]-p-1)/dist;\\n       p=rungs[i];\\n         }\\n      return c;  \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint addRungs(vector<int>& rungs, int dist) {\\n      int c=0;\\n     int p=0;\\n     for(int i=0;i<rungs.size();i++){\\n       c+=(rungs[i]-p-1)/dist;\\n       p=rungs[i];\\n         }\\n      return c;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369896,
                "title": "c-and-python",
                "content": "The solution is easy but hard to implement if you ignore the fact that dividing two integers is integer and not float, so we need to typecast it into double/float to solve this question. \\n\\nPython doesn\\'t have this issue, so we don\\'t need to bother about float division here. \\n\\nhere is my both the solutions.\\nC++ \\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        rungs.insert(rungs.begin(), 0);\\n        int count = 0;\\n        int size = rungs.size();\\n        for(int i=1; i< size; i++){\\n            double gap = rungs[i]-rungs[i-1];\\n            if(gap>dist){\\n                count = count + ceil((double)gap/(double)dist)-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        rungs.insert(0,0)\\n        for i in range(len(rungs)-1):\\n            gap = rungs[i+1] - rungs[i]\\n            if gap > dist:\\n                count = count + math.ceil(gap/dist)-1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        rungs.insert(rungs.begin(), 0);\\n        int count = 0;\\n        int size = rungs.size();\\n        for(int i=1; i< size; i++){\\n            double gap = rungs[i]-rungs[i-1];\\n            if(gap>dist){\\n                count = count + ceil((double)gap/(double)dist)-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        rungs.insert(0,0)\\n        for i in range(len(rungs)-1):\\n            gap = rungs[i+1] - rungs[i]\\n            if gap > dist:\\n                count = count + math.ceil(gap/dist)-1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368201,
                "title": "python-easy-explained-with-common-mistakes",
                "content": "Reason why you should divide gap by distance is TLE.\\nI initially did a while loop to increase counter by 1 but it failed a later test case.\\nThen I divided gap//dist but this creates a problem when dist = 1\\nHence we divide and take the ceil value and subtract 1 from it\\n\\n```def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        rungs.insert(0,0)    # add 0 because you start from the ground not the first rung.\\n        for i in range(len(rungs)-1):\\n            gap = rungs[i+1] - rungs[i]\\n            if gap > dist:\\n                gap = math.ceil(gap/dist) - 1\\n                count += gap\\n        return count\\'\\'\\'",
                "solutionTags": [],
                "code": "Reason why you should divide gap by distance is TLE.\\nI initially did a while loop to increase counter by 1 but it failed a later test case.\\nThen I divided gap//dist but this creates a problem when dist = 1\\nHence we divide and take the ceil value and subtract 1 from it\\n\\n```def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        rungs.insert(0,0)    # add 0 because you start from the ground not the first rung.\\n        for i in range(len(rungs)-1):\\n            gap = rungs[i+1] - rungs[i]\\n            if gap > dist:\\n                gap = math.ceil(gap/dist) - 1\\n                count += gap\\n        return count\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1365762,
                "title": "easy-in-python",
                "content": "def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs.insert(0,0)\\n        count=0\\n        for i in range(1,len(rungs)):\\n            if((rungs[i]-rungs[i-1])>dist):\\n                a=rungs[i]-rungs[i-1]\\n                if(a%dist==0):\\n                    count+=(a//dist)-1\\n                else:\\n                    count+=a//dist\\n        return count",
                "solutionTags": [],
                "code": "def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs.insert(0,0)\\n        count=0\\n        for i in range(1,len(rungs)):\\n            if((rungs[i]-rungs[i-1])>dist):\\n                a=rungs[i]-rungs[i-1]\\n                if(a%dist==0):\\n                    count+=(a//dist)-1\\n                else:\\n                    count+=a//dist\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 1361849,
                "title": "easy-to-understand-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int prev = 0;\\n        int ans = 0;\\n        for(auto r: rungs){\\n            int gap = r-prev;\\n            ans += (gap-1)/dist;\\n            prev = r;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int prev = 0;\\n        int ans = 0;\\n        for(auto r: rungs){\\n            int gap = r-prev;\\n            ans += (gap-1)/dist;\\n            prev = r;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361667,
                "title": "99-faster-easy-to-understand-divide-approach",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n     \\n        int c = (rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.length;i++) {\\n            if(rungs[i]-rungs[i-1]>dist) {\\n                c += (rungs[i]-rungs[i-1]-1)/dist;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n//please upvote if this is helpful for you.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n     \\n        int c = (rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.length;i++) {\\n            if(rungs[i]-rungs[i-1]>dist) {\\n                c += (rungs[i]-rungs[i-1]-1)/dist;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361117,
                "title": "python3-easy-for-beginners",
                "content": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        h  = 0\\n        solution = 0\\n        for r in rungs:\\n            if (r-h)%dist==0:\\n                solution+=(r-h)//dist-1\\n            else:\\n                solution+=(r-h)//dist\\n            h=r\\n        return solution\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        h  = 0\\n        solution = 0\\n        for r in rungs:\\n            if (r-h)%dist==0:\\n                solution+=(r-h)//dist-1\\n            else:\\n                solution+=(r-h)//dist\\n            h=r\\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359318,
                "title": "java-easy-clean",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        /* Compare the previous height and the current height */\\n         int min = 0;\\n         for(int i = 0;i < rungs.length ;i++){\\n             //current distance\\n             int cd = (i == 0) ? rungs[i] - 1 : rungs[i] - rungs[i - 1] - 1;\\n             int div = (cd / dist);\\n             min = min + div ;\\n         }\\n      return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        /* Compare the previous height and the current height */\\n         int min = 0;\\n         for(int i = 0;i < rungs.length ;i++){\\n             //current distance\\n             int cd = (i == 0) ? rungs[i] - 1 : rungs[i] - rungs[i - 1] - 1;\\n             int div = (cd / dist);\\n             min = min + div ;\\n         }\\n      return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352209,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] arr, int d) {\\n       int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(i==0){\\n                if(arr[i]>d){\\n                    if(arr[i]%d==0){\\n                ans+=(arr[i]/d)-1;\\n                    }\\n                    else{\\n                        ans+=(arr[i]/d);\\n                    }\\n                }\\n            }\\n            else{\\n                if(arr[i]>arr[i-1]+d){\\n                if((arr[i]-arr[i-1])%d==0){\\n                    ans+=((arr[i]-arr[i-1])/d)-1;\\n                }\\n                    else{\\n                    ans+=(arr[i]-arr[i-1])/d;\\n                }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] arr, int d) {\\n       int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(i==0){\\n                if(arr[i]>d){\\n                    if(arr[i]%d==0){\\n                ans+=(arr[i]/d)-1;\\n                    }\\n                    else{\\n                        ans+=(arr[i]/d);\\n                    }\\n                }\\n            }\\n            else{\\n                if(arr[i]>arr[i-1]+d){\\n                if((arr[i]-arr[i-1])%d==0){\\n                    ans+=((arr[i]-arr[i-1])/d)-1;\\n                }\\n                    else{\\n                    ans+=(arr[i]-arr[i-1])/d;\\n                }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349746,
                "title": "python-3-o-n-simple-solution",
                "content": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        L , count = 0\\n        for i in rungs:\\n            if (i - L) > dist:\\n                count += (i-L-1)//dist\\n            L = i\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        L , count = 0\\n        for i in rungs:\\n            if (i - L) > dist:\\n                count += (i-L-1)//dist\\n            L = i\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345954,
                "title": "c",
                "content": "class Solution {\\npublic:\\n        \\n    int addRungs(vector<int>& v, int dist) {\\n        \\n         int prev=0;\\n         int ans=0;  \\n            \\n         for(int i=0;i<v.size();i++){\\n             int x=(v[i]-prev)/dist;    \\n             ans+=x;\\n             if((v[i]-prev)%dist==0)ans--;    \\n             prev=v[i];    \\n         }   \\n            \\nreturn ans;     \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n        \\n    int addRungs(vector<int>& v, int dist) {\\n        \\n         int prev=0;\\n         int ans=0;  \\n            \\n         for(int i=0;i<v.size();i++){\\n             int x=(v[i]-prev)/dist;    \\n             ans+=x;\\n             if((v[i]-prev)%dist==0)ans--;    \\n             prev=v[i];    \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1345821,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int result = rungs[0] - 0 <= dist ? 0 : (rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.length;i++)\\n            result += (rungs[i] - rungs[i-1] <= dist ? 0 : ((rungs[i] - rungs[i-1] - 1)/dist));\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int result = rungs[0] - 0 <= dist ? 0 : (rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.length;i++)\\n            result += (rungs[i] - rungs[i-1] <= dist ? 0 : ((rungs[i] - rungs[i-1] - 1)/dist));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345009,
                "title": "java-1ms-faster-than-100",
                "content": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int count=0;\\n        int hdiff=rungs[0]-0;\\n        count+=hdiff/dist;\\n        if(hdiff%dist==0){\\n            count--;\\n        }\\n        for(int i=0;i<rungs.length-1;i++){\\n            if(rungs[i]+dist>=rungs[i+1]){\\n                continue;\\n            }\\n            else{\\n                int diff=rungs[i+1]-rungs[i];\\n                count+=diff/dist;\\n                if(diff%dist==0){\\n                    count--;\\n                }                \\n            }\\n        }\\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int count=0;\\n        int hdiff=rungs[0]-0;\\n        count+=hdiff/dist;\\n        if(hdiff%dist==0){\\n            count--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1344976,
                "title": "java-solution-clean-code",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i=0 ; i<rungs.length ; i++) {\\n\\t\\t\\tint d = (i==0) ? rungs[i] : rungs[i] - rungs[i-1];\\n\\t\\t\\tif ( d > dist ) {\\n\\t\\t\\t\\tans += d/dist;\\n\\t\\t\\t\\tans += ( d%dist == 0 ) ? -1 : 0; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i=0 ; i<rungs.length ; i++) {\\n\\t\\t\\tint d = (i==0) ? rungs[i] : rungs[i] - rungs[i-1];\\n\\t\\t\\tif ( d > dist ) {\\n\\t\\t\\t\\tans += d/dist;\\n\\t\\t\\t\\tans += ( d%dist == 0 ) ? -1 : 0; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344953,
                "title": "java-100-1ms",
                "content": "``\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int i =0;\\n        int count = 0;\\n        \\n        if(rungs[0] > dist){\\n            \\n            count+= (int)((rungs[0])/dist);\\n            if((rungs[0])%dist == 0) count-=1;\\n        }\\n        for(i = 1; i< rungs.length;i++){\\n          \\n           if(rungs[i]-rungs[i-1] > dist){\\n                \\n                count+= (int) ((rungs[i]-rungs[i-1])/dist);\\n               if((rungs[i]-rungs[i-1])%dist == 0) count-=1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int i =0;\\n        int count = 0;\\n        \\n        if(rungs[0] > dist){\\n            \\n            count+= (int)((rungs[0])/dist);\\n            if((rungs[0])%dist == 0) count-=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1344949,
                "title": "easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        if(rungs[0]>dist)\\n        ans+=((rungs[0]-1)/dist);\\n        for(int i=1;i<rungs.size();i++)\\n        {\\n            if(rungs[i]-rungs[i-1]>dist)\\n            {\\n                ans+=(((rungs[i]-rungs[i-1])-1)/dist);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        if(rungs[0]>dist)\\n        ans+=((rungs[0]-1)/dist);\\n        for(int i=1;i<rungs.size();i++)\\n        {\\n            if(rungs[i]-rungs[i-1]>dist)\\n            {\\n                ans+=(((rungs[i]-rungs[i-1])-1)/dist);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344915,
                "title": "best-simple-one-pass-solution-in-python",
                "content": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        height=0\\n        sol=0\\n        for r in rungs:\\n            if (r-height)%dist==0:\\n                sol+=(r-height)//dist-1\\n            else:\\n                sol+=(r-height)//dist\\n            height=r\\n        return sol\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        height=0\\n        sol=0\\n        for r in rungs:\\n            if (r-height)%dist==0:\\n                sol+=(r-height)//dist-1\\n            else:\\n                sol+=(r-height)//dist\\n            height=r\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344912,
                "title": "c-very-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& r, int d) {\\n        int start = 0;\\n        int ans =0;\\n        for(int i=0;i<r.size();i++){\\n            int x = r[i];\\n            if(x-start>d){\\n                int p = (x-start)/d;\\n                if(start+(p*d)==x){\\n                    ans+=(p-1);\\n                }\\n                else{\\n                    ans+=p;\\n                }\\n            }\\n            start = x;\\n        }\\n        //cout<<ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& r, int d) {\\n        int start = 0;\\n        int ans =0;\\n        for(int i=0;i<r.size();i++){\\n            int x = r[i];\\n            if(x-start>d){\\n                int p = (x-start)/d;\\n                if(start+(p*d)==x){\\n                    ans+=(p-1);\\n                }\\n                else{\\n                    ans+=p;\\n                }\\n            }\\n            start = x;\\n        }\\n        //cout<<ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1344909,
                "title": "java-simple-sol",
                "content": "We have to handle edge cases explicitly here\\n```\\n public int addRungs(int[] arr, int dist) {\\n        int n=arr.length;\\n    \\n        int diff=0;\\n        int c=0;\\n        \\n        \\n        if(arr[0]>dist){   //if first element is itself greater than dist given\\n            \\n            if(arr[0]%dist==0) c+=arr[0]/dist-1;\\n            else c+=arr[0]/dist; \\n        }\\n        for(int i=1;i<n;i++){\\n            if(arr[i]-arr[i-1]>dist){\\n                diff=arr[i]-arr[i-1];\\n               if(diff%dist==0) \\n                  c+=diff/dist-1;\\n               else c+=diff/dist;\\n            }\\n            else continue;\\n            \\n        }\\n        return c;\\n       }",
                "solutionTags": [],
                "code": "We have to handle edge cases explicitly here\\n```\\n public int addRungs(int[] arr, int dist) {\\n        int n=arr.length;\\n    \\n        int diff=0;\\n        int c=0;\\n        \\n        \\n        if(arr[0]>dist){   //if first element is itself greater than dist given\\n            \\n            if(arr[0]%dist==0) c+=arr[0]/dist-1;\\n            else c+=arr[0]/dist; \\n        }\\n        for(int i=1;i<n;i++){\\n            if(arr[i]-arr[i-1]>dist){\\n                diff=arr[i]-arr[i-1];\\n               if(diff%dist==0) \\n                  c+=diff/dist-1;\\n               else c+=diff/dist;\\n            }\\n            else continue;\\n            \\n        }\\n        return c;\\n       }",
                "codeTag": "Unknown"
            },
            {
                "id": 1344882,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int previousNumber=0;\\n        int ans=0;\\n        for(auto n:rungs)\\n        {\\n            int gap=n-previousNumber;\\n            ans+=(gap-1)/dist;\\n            previousNumber=n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int previousNumber=0;\\n        int ans=0;\\n        for(auto n:rungs)\\n        {\\n            int gap=n-previousNumber;\\n            ans+=(gap-1)/dist;\\n            previousNumber=n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344876,
                "title": "a-few-solutions",
                "content": "Accumulate the count `cnt` of previous `pre` and current `cur` rung position differences `diff` divided by the distance threshold `T`, ie. this is the amount of rungs we need to add in between the previous and current rungs.\\n\\nNote: we subtract `1` from `diff`, since `cur` is non-inclusive for additional rungs (ie. there already exists a rung at `cur`, so we don\\'t need to add a rung at `cur` when `diff` exceeds the threshold `T`).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun addRungs(A: IntArray, T: Int): Int {\\n        var cnt = 0\\n        var pre = 0\\n        for (cur in A) {\\n            var diff = cur - pre\\n            if (T < diff)\\n                cnt += (diff - 1) / T  // -1 since cur is non-inclusive\\n            pre = cur\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet addRungs = (A, T, pre = 0, cnt = 0) => {\\n    for (let cur of A) {\\n        let diff = cur - pre;\\n        if (T < diff)\\n            cnt += Math.floor((diff - 1) / T);  // -1 since cur is non-inclusive\\n        pre = cur;\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def addRungs(self, A: List[int], T: int, pre = 0, cnt = 0) -> int:\\n        for cur in A:\\n            diff = cur - pre\\n            if T < diff:\\n                cnt += (diff - 1) // T  # -1 since cur is non-inclusive\\n            pre = cur\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int addRungs(VI& A, int T, int pre = 0, int cnt = 0) {\\n        for (auto cur: A) {\\n            auto diff = cur - pre;\\n            if (T < diff) {\\n                cnt += (diff - 1) / T;  // -1 since cur is non-inclusive\\n            pre = cur;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun addRungs(A: IntArray, T: Int): Int {\\n        var cnt = 0\\n        var pre = 0\\n        for (cur in A) {\\n            var diff = cur - pre\\n            if (T < diff)\\n                cnt += (diff - 1) / T  // -1 since cur is non-inclusive\\n            pre = cur\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet addRungs = (A, T, pre = 0, cnt = 0) => {\\n    for (let cur of A) {\\n        let diff = cur - pre;\\n        if (T < diff)\\n            cnt += Math.floor((diff - 1) / T);  // -1 since cur is non-inclusive\\n        pre = cur;\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def addRungs(self, A: List[int], T: int, pre = 0, cnt = 0) -> int:\\n        for cur in A:\\n            diff = cur - pre\\n            if T < diff:\\n                cnt += (diff - 1) // T  # -1 since cur is non-inclusive\\n            pre = cur\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int addRungs(VI& A, int T, int pre = 0, int cnt = 0) {\\n        for (auto cur: A) {\\n            auto diff = cur - pre;\\n            if (T < diff) {\\n                cnt += (diff - 1) / T;  // -1 since cur is non-inclusive\\n            pre = cur;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079318,
                "title": "simple-and-clear-python3-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        result = 0\\n        prev = 0\\n        for elem in rungs:\\n            delta = elem - prev\\n            current = (delta - 1) // dist\\n            result += current\\n            prev = elem\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "``` python3 []\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        result = 0\\n        prev = 0\\n        for elem in rungs:\\n            delta = elem - prev\\n            current = (delta - 1) // dist\\n            result += current\\n            prev = elem\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075576,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def addRungs(self, rungs, dist):\\n        \"\"\"\\n        :type rungs: List[int]\\n        :type dist: int\\n        :rtype: int\\n        \"\"\"\\n        current_height = 0  # Start at the ground\\n        rungs_to_add = 0\\n\\n        for rung in rungs:\\n            gap = rung - current_height\\n            if gap > dist:\\n                rungs_to_add += (gap - 1) // dist\\n            current_height = rung\\n\\n        return rungs_to_add\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def addRungs(self, rungs, dist):\\n        \"\"\"\\n        :type rungs: List[int]\\n        :type dist: int\\n        :rtype: int\\n        \"\"\"\\n        current_height = 0  # Start at the ground\\n        rungs_to_add = 0\\n\\n        for rung in rungs:\\n            gap = rung - current_height\\n            if gap > dist:\\n                rungs_to_add += (gap - 1) // dist\\n            current_height = rung\\n\\n        return rungs_to_add\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019664,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int sum=0;\\n        rungs.insert(rungs.begin(),0);\\n        for(int i=0;i<rungs.size()-1;i++){\\n            int gap=rungs[i+1]-rungs[i];\\n            if(gap>dist){\\n            sum+=gap/dist + (gap%dist?0:-1);\\n            rungs[i+1] = max(rungs[i+1],rungs[i]+ (gap/dist + (gap%dist?0:-1))*dist);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int sum=0;\\n        rungs.insert(rungs.begin(),0);\\n        for(int i=0;i<rungs.size()-1;i++){\\n            int gap=rungs[i+1]-rungs[i];\\n            if(gap>dist){\\n            sum+=gap/dist + (gap%dist?0:-1);\\n            rungs[i+1] = max(rungs[i+1],rungs[i]+ (gap/dist + (gap%dist?0:-1))*dist);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017086,
                "title": "easy-approach-100-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int curr = 0;\\n        int cnt = 0; \\n        int n = rungs.size();\\n\\n        if(n==1){\\n            return (dist>rungs[0]) ? 0:((rungs[0]-1)/dist);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int gap = rungs[i]-curr;\\n            if(gap>dist){\\n                cnt+= (gap-1)/dist;\\n            }\\n            curr = rungs[i];\\n        }\\n        return cnt;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int curr = 0;\\n        int cnt = 0; \\n        int n = rungs.size();\\n\\n        if(n==1){\\n            return (dist>rungs[0]) ? 0:((rungs[0]-1)/dist);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3999377,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int addRungs(vector<int>& rungs, int dist) {\\n    int ans = 0;\\n    int prev = 0;\\n\\n    for (const int rung : rungs) {\\n      ans += (rung - prev - 1) / dist;\\n      prev = rung;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int addRungs(vector<int>& rungs, int dist) {\\n    int ans = 0;\\n    int prev = 0;\\n\\n    for (const int rung : rungs) {\\n      ans += (rung - prev - 1) / dist;\\n      prev = rung;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947917,
                "title": "java-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0, prev = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            int diff = rungs[i] - prev;\\n            prev = rungs[i];\\n            if (diff > dist) count += diff % dist == 0 ? (diff / dist) - 1 : diff / dist;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0, prev = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            int diff = rungs[i] - prev;\\n            prev = rungs[i];\\n            if (diff > dist) count += diff % dist == 0 ? (diff / dist) - 1 : diff / dist;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898885,
                "title": "easy-to-understand-c-solution",
                "content": "# Approach\\nDifference = (rungs at each i - previous rung) if this is divisible by dist they we required one less rung, if not add the difference / dist and move to the next rung of the ladder.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cnt = 0;\\n        int intial = 0;\\n        int n = rungs.size();\\n        for(int i=0;i<n;i++){\\n            int diff = rungs[i] - intial;\\n            if(diff > dist){\\n                if(diff%dist == 0) cnt--;\\n                cnt += diff/ dist;\\n            }\\n            intial = rungs[i];\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n##### Kindly UpVote",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cnt = 0;\\n        int intial = 0;\\n        int n = rungs.size();\\n        for(int i=0;i<n;i++){\\n            int diff = rungs[i] - intial;\\n            if(diff > dist){\\n                if(diff%dist == 0) cnt--;\\n                cnt += diff/ dist;\\n            }\\n            intial = rungs[i];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896476,
                "title": "mathematical-java-solution-o-n-time-o-1-space-complexity",
                "content": "# Intuition\\nWhen solving this problem. It is paramount to understand that odd and even numbers behave differently. \\n\\n# Approach\\nWhat I did was I realized that, after putting together some data, that if the distance between two rungs that could not be reached, was even or odd. I realized that this mattered for odd and even distances because if the distance was even, then you needed to take into account if \\'dist\\' went into the rung evenly or not.\\n\\nIf it did, you needed to subtract one from the amount of rungs you needed to add, because the equation (rungs[i] - rung)/dist would account for how many steps it would take to get to your destination, including the step of your destination. \\n\\nIf (rungs[i] - rung) was odd, you didn\\'t need to take this into account, due to the nature that odd numbers behave in, you don\\'t need to take into account whether dist will go evenly into your destination rung.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int num = 0;\\n        int rung = 0;\\n\\n        for(int i=0; i<rungs.length; i++) {\\n            if(rungs[i] - rung > dist) {\\n                if(dist == 1) \\n                    num += ((rungs[i] - rung)/dist) - 1;\\n                else if((rungs[i]-rung)%2 == 1) \\n                    num += (rungs[i] - rung)/dist;\\n                else {\\n                    if((rungs[i]-rung) % dist != 0) \\n                        num += ((rungs[i] - rung)/dist);\\n                    else \\n                        num += (rungs[i] - rung)/dist-1;\\n                }\\n            } \\n            rung = rungs[i];\\n        }\\n\\n        return num;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int num = 0;\\n        int rung = 0;\\n\\n        for(int i=0; i<rungs.length; i++) {\\n            if(rungs[i] - rung > dist) {\\n                if(dist == 1) \\n                    num += ((rungs[i] - rung)/dist) - 1;\\n                else if((rungs[i]-rung)%2 == 1) \\n                    num += (rungs[i] - rung)/dist;\\n                else {\\n                    if((rungs[i]-rung) % dist != 0) \\n                        num += ((rungs[i] - rung)/dist);\\n                    else \\n                        num += (rungs[i] - rung)/dist-1;\\n                }\\n            } \\n            rung = rungs[i];\\n        }\\n\\n        return num;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874846,
                "title": "medium",
                "content": "# Intuition : \\nNothing checking we can jump to next positio or not \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans=0;\\n        int curr=0;\\n        for(int i=0;i<rungs.length;i++){\\n            int diff=rungs[i]-curr-1;\\n            if(diff>=dist)\\n            ans+=diff/dist;\\n            curr=rungs[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans=0;\\n        int curr=0;\\n        for(int i=0;i<rungs.length;i++){\\n            int diff=rungs[i]-curr-1;\\n            if(diff>=dist)\\n            ans+=diff/dist;\\n            curr=rungs[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854016,
                "title": "c-just-think",
                "content": "# Intuition\\nHow high from a particular index(i) can u go that is the question ? \\n\\n# Approach\\n\\nIf you\\'ll think carefully then you will see from arr[i] you can for to arr[i+1] always. SOOOO just count the steps require to move from i --> i + 1. which is ceil((arr[i] - arr[i - 1])/ k) steps (floot makes it complicated). \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& arr, int k) {\\n        int len = arr.size();\\n        int ans = 0;\\n\\n        ans = ans + ceil(arr[0] / (1.0* k)) - 1;\\n        for(int i = 1; i < len; i++){\\n            ans = ans + ceil((arr[i] - arr[i - 1])/ (1.0* k)) - 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& arr, int k) {\\n        int len = arr.size();\\n        int ans = 0;\\n\\n        ans = ans + ceil(arr[0] / (1.0* k)) - 1;\\n        for(int i = 1; i < len; i++){\\n            ans = ans + ceil((arr[i] - arr[i - 1])/ (1.0* k)) - 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842083,
                "title": "easy-c-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& v, int d) {\\n        int count=0;\\n        int n=v.size();\\n        for(int i=n-2;i>=0;i--){\\n            int k=(v[i+1]-v[i])/d;\\n            if((v[i+1]-v[i])%d>0) k++;\\n            if(k>0) count+=k-1;\\n        }\\n        int k=(v[0]-0)/d;\\n        if((v[0]-0)%d>0) k++;\\n        if(k>0) count+=k-1;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& v, int d) {\\n        int count=0;\\n        int n=v.size();\\n        for(int i=n-2;i>=0;i--){\\n            int k=(v[i+1]-v[i])/d;\\n            if((v[i+1]-v[i])%d>0) k++;\\n            if(k>0) count+=k-1;\\n        }\\n        int k=(v[0]-0)/d;\\n        if((v[0]-0)%d>0) k++;\\n        if(k>0) count+=k-1;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793003,
                "title": "java-100-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int result = 0;\\n\\n        int currentHeight = 0;\\n\\n        for (int i = 0; i < rungs.length; i++) {\\n            int dif = rungs[i] - currentHeight;\\n            if (dif > dist) {\\n                result += (dif - 1) / dist;\\n            }\\n            currentHeight = rungs[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int result = 0;\\n\\n        int currentHeight = 0;\\n\\n        for (int i = 0; i < rungs.length; i++) {\\n            int dif = rungs[i] - currentHeight;\\n            if (dif > dist) {\\n                result += (dif - 1) / dist;\\n            }\\n            currentHeight = rungs[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787361,
                "title": "83-faster-easy-c-solution-with-explanation-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int addRungs(vector<int> &rungs, int dist)\\n    {\\n        int n = rungs.size();\\n        int height = 0; // Initially on the floor\\n        int ans = 0;    // Total no. of rungs to be added\\n\\n        int i = 0; // tracks the rungs already present\\n\\n        if (dist < rungs[i])\\n            ans += ceil(double(rungs[i] - 0) / double(dist)) - 1; // No. of rungs required to climb the first rung\\n\\n        height = rungs[i]; // reached the first rung\\n\\n        i++;\\n        while (i < n)\\n        {\\n            if (height + dist < rungs[i])\\n            {\\n                int temp = ceil(double(rungs[i] - rungs[i - 1]) / double(dist)) - 1; // No. of rungs required to move from (i-1)th to ith\\n                ans += temp;\\n                height = rungs[i]; // reached the ith rung\\n            }\\n\\n            else\\n            {\\n                height = rungs[i];\\n                i++; // reached the ith rung\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int addRungs(vector<int> &rungs, int dist)\\n    {\\n        int n = rungs.size();\\n        int height = 0; // Initially on the floor\\n        int ans = 0;    // Total no. of rungs to be added\\n\\n        int i = 0; // tracks the rungs already present\\n\\n        if (dist < rungs[i])\\n            ans += ceil(double(rungs[i] - 0) / double(dist)) - 1; // No. of rungs required to climb the first rung\\n\\n        height = rungs[i]; // reached the first rung\\n\\n        i++;\\n        while (i < n)\\n        {\\n            if (height + dist < rungs[i])\\n            {\\n                int temp = ceil(double(rungs[i] - rungs[i - 1]) / double(dist)) - 1; // No. of rungs required to move from (i-1)th to ith\\n                ans += temp;\\n                height = rungs[i]; // reached the ith rung\\n            }\\n\\n            else\\n            {\\n                height = rungs[i];\\n                i++; // reached the ith rung\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778731,
                "title": "simple-solution-o-n",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} rungs\\n * @param {number} dist\\n * @return {number}\\n */\\nvar addRungs = function(rungs, dist) {\\n    let curr = 0\\n    let addition = 0\\n    for (const r of rungs){\\n        addition += Math.ceil((r - curr) / dist) - 1\\n        curr = r\\n    }\\n    return addition\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} rungs\\n * @param {number} dist\\n * @return {number}\\n */\\nvar addRungs = function(rungs, dist) {\\n    let curr = 0\\n    let addition = 0\\n    for (const r of rungs){\\n        addition += Math.ceil((r - curr) / dist) - 1\\n        curr = r\\n    }\\n    return addition\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3718862,
                "title": "python3-4-lines-only-yep-a-bit-tricky-ones",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rung, result = 0, 0\\n        for r in rungs:\\n            rung, result = r, result if r - rung <= dist else result + ((r - rung) // dist + (-1 if (r - rung) % dist == 0 else 0))\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rung, result = 0, 0\\n        for r in rungs:\\n            rung, result = r, result if r - rung <= dist else result + ((r - rung) // dist + (-1 if (r - rung) % dist == 0 else 0))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714719,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $rungs\\n     * @param Integer $dist\\n     * @return Integer\\n     */\\n    function addRungs($rungs, $dist) {\\n        ## returned value\\n        $count = 0;\\n\\n        #including 0 ( the floor ) in all cases. We start at 0 everytime.\\n        $rungs = [0, ...$rungs];\\n\\n        # iterate in array using two variables for N and N+1.\\n        for($i = 0, $j = 1; $j < count($rungs) ; $i++, $j++){\\n\\n            #get the diff of the values. ( N+1 - N)\\n            $diff = $rungs[$j] - $rungs[$i];\\n\\n            #if the diff > dist we need add a new rung\\n            if($diff > $dist){\\n\\n              #The amount of rungs is: the difference / dist - 1;\\n              # Example: N = 0\\n              # N + 1 = 9\\n              # Dist= 4\\n              # We cant reach 9. So, we add a rung in max height possible: N + 4;\\n              # Now we have [0, 4, 9]\\n              # We cant reach 9. So we add one more in max height: 4 + 4 = 8;\\n              # What we are doing is the same of divide the diff for the dist. In some cases, the number isn\\'t integer ( 9 / 2 ). So, we ceil.\\n              # We cant include the inital value, so we subtract 1.\\n              $count += ceil($diff/$dist) - 1;\\n            }\\n        }\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $rungs\\n     * @param Integer $dist\\n     * @return Integer\\n     */\\n    function addRungs($rungs, $dist) {\\n        ## returned value\\n        $count = 0;\\n\\n        #including 0 ( the floor ) in all cases. We start at 0 everytime.\\n        $rungs = [0, ...$rungs];\\n\\n        # iterate in array using two variables for N and N+1.\\n        for($i = 0, $j = 1; $j < count($rungs) ; $i++, $j++){\\n\\n            #get the diff of the values. ( N+1 - N)\\n            $diff = $rungs[$j] - $rungs[$i];\\n\\n            #if the diff > dist we need add a new rung\\n            if($diff > $dist){\\n\\n              #The amount of rungs is: the difference / dist - 1;\\n              # Example: N = 0\\n              # N + 1 = 9\\n              # Dist= 4\\n              # We cant reach 9. So, we add a rung in max height possible: N + 4;\\n              # Now we have [0, 4, 9]\\n              # We cant reach 9. So we add one more in max height: 4 + 4 = 8;\\n              # What we are doing is the same of divide the diff for the dist. In some cases, the number isn\\'t integer ( 9 / 2 ). So, we ceil.\\n              # We cant include the inital value, so we subtract 1.\\n              $count += ceil($diff/$dist) - 1;\\n            }\\n        }\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669335,
                "title": "simple-java-solution-1-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int extraRungs = 0;\\n        int currentRung = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            if (currentRung + dist < rungs[i]) {\\n                extraRungs += ((rungs[i] - currentRung - 1) / dist);\\n            }\\n            currentRung = rungs[i];\\n        }\\n        return extraRungs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int extraRungs = 0;\\n        int currentRung = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            if (currentRung + dist < rungs[i]) {\\n                extraRungs += ((rungs[i] - currentRung - 1) / dist);\\n            }\\n            currentRung = rungs[i];\\n        }\\n        return extraRungs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638217,
                "title": "c-i-bet-you-will-understand-easy-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterating over the array first finding the required number of rings.\\nAfter that from height 0 to the height of first ring we find the required number of rings.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ct=0;\\n        for(int i=0;i<rungs.size()-1;i++){\\n            int ans1=rungs[i+1]-rungs[i];\\n            int temp=ans1/dist;\\n            if(ans1%dist!=0){\\n                temp++;\\n            }\\n            ct+=(temp-1);\\n        }\\n        int rest_sum=rungs[0];\\n        int rest_temp=rest_sum/dist;\\n        if(rest_sum%dist!=0){\\n                rest_temp++;\\n        }\\n        ct+=(rest_temp-1);\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ct=0;\\n        for(int i=0;i<rungs.size()-1;i++){\\n            int ans1=rungs[i+1]-rungs[i];\\n            int temp=ans1/dist;\\n            if(ans1%dist!=0){\\n                temp++;\\n            }\\n            ct+=(temp-1);\\n        }\\n        int rest_sum=rungs[0];\\n        int rest_temp=rest_sum/dist;\\n        if(rest_sum%dist!=0){\\n                rest_temp++;\\n        }\\n        ct+=(rest_temp-1);\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580735,
                "title": "stack-solution-gave-tle-so-tried-one-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int k) {\\n        vector<int> lad;\\n        stack<int> st;\\n            st.push(0);        \\n        int i=0;\\n        int c = 0;\\n        // while(i<rungs.size()){\\n\\n        //     if(k+st.top()>=rungs[i]){\\n        //         st.push(rungs[i]);\\n        //         i++;\\n        //     }else{\\n        //         st.push(st.top()+k);\\n        //     }\\n\\n        // }\\n        if(0+k<rungs[0]){\\n              c+=(ceil)((rungs[0]-1)/k);\\n        }\\n        for(int i=0;i<rungs.size()-1;i++){\\n            if(rungs[i]+k>=rungs[i+1]){\\n\\n            }else{\\n                c+=(ceil)((rungs[i+1] - rungs[i]-1)/k);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int k) {\\n        vector<int> lad;\\n        stack<int> st;\\n            st.push(0);        \\n        int i=0;\\n        int c = 0;\\n        // while(i<rungs.size()){\\n\\n        //     if(k+st.top()>=rungs[i]){\\n        //         st.push(rungs[i]);\\n        //         i++;\\n        //     }else{\\n        //         st.push(st.top()+k);\\n        //     }\\n\\n        // }\\n        if(0+k<rungs[0]){\\n              c+=(ceil)((rungs[0]-1)/k);\\n        }\\n        for(int i=0;i<rungs.size()-1;i++){\\n            if(rungs[i]+k>=rungs[i+1]){\\n\\n            }else{\\n                c+=(ceil)((rungs[i+1] - rungs[i]-1)/k);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571208,
                "title": "python3-very-easy-7-lines-code-o-n-beginner-friendly-sece-cbe",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        c=0\\n        if(rungs[0]>dist):\\n            c+=((rungs[0]-1)//dist)\\n        for i in range(len(rungs)-1):\\n            if((rungs[i+1]-rungs[i]) > dist):\\n                if((rungs[i+1]-rungs[i])>dist):\\n                    c+= (rungs[i+1]-rungs[i])//dist if ((rungs[i+1]-rungs[i])%dist >= 1) else ((rungs[i+1]-rungs[i])//dist)-1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        c=0\\n        if(rungs[0]>dist):\\n            c+=((rungs[0]-1)//dist)\\n        for i in range(len(rungs)-1):\\n            if((rungs[i+1]-rungs[i]) > dist):\\n                if((rungs[i+1]-rungs[i])>dist):\\n                    c+= (rungs[i+1]-rungs[i])//dist if ((rungs[i+1]-rungs[i])%dist >= 1) else ((rungs[i+1]-rungs[i])//dist)-1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569426,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    iterarte through each step and find diff\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int n=rungs.size();\\n        int count=0;\\n        \\n            if(rungs[0]>dist)\\n                count+=(rungs[0]-1)/dist;\\n            \\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int diff=rungs[i+1]-rungs[i];\\n\\n            if(diff>dist)\\n            {\\n                count+=(diff-1)/dist;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int n=rungs.size();\\n        int count=0;\\n        \\n            if(rungs[0]>dist)\\n                count+=(rungs[0]-1)/dist;\\n            \\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int diff=rungs[i+1]-rungs[i];\\n\\n            if(diff>dist)\\n            {\\n                count+=(diff-1)/dist;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530053,
                "title": "java-greedy-100-faster-intuition-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```\\nintuition here is,\\n        initially we are standing at height = 0 ==> prevHeight = 0\\n        and from some prevHeight we need to cover a \\'dist\\' to reach the rungs[i],\\n        if there is prevHeight + dist >= rungs[i] then it is good we can reach our\\n        rungs[i] as we have covered plenty of range from [prevHeight, prevHeight + dist] \\n        as prevHeight < rungs[i] <= (prevHeight + dist)\\n        \\n        BUT \\n        \\n        if our prevHeight + dist < rungs[i] we don\\'t have much range to reach our\\n        rungs[i] so what we have to do is to add new rungs in between prevHeight\\n        and rungs[i] so to calculate that \\n        dest = rungs[i]\\n        src = prevHeight\\n        adjust = -1 \"adjust\", why? \\n        because, as we need to reach to dest from our src and we also know that\\n        we definitely have dest == rungs[i] available so we don\\'t need to count\\n        the dest rungs but those required in between thats why!!!\\n        \\n        so with this we need to cover a \\'total-length\\' of (dest - src - 1) between src & dest\\n        so how many rungs would be reuired to cover this \\'total-length\\' provided that we can\\n        move by dist \\'dist\\', then rungs required would be (\\'total-length\\' / \\'dist\\')\\n        \\n        hence, number of rungs required to add\\n        ==> addedRungs = ((dest - src - 1) / dist);\\n        ==> ((rungs[i] - prevHeight - 1) / dist)\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N), N is length of rungs[] arrays\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), only few varibles are used\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int n = rungs.length;\\n        int prevHeight = 0;\\n        int added = 0;\\n        for(int i = 0; i < n; i++){\\n            if(prevHeight + dist < rungs[i]) {\\n                added += ((rungs[i] - prevHeight - 1) / dist);\\n            }\\n            prevHeight = rungs[i];\\n        }\\n        return added;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nintuition here is,\\n        initially we are standing at height = 0 ==> prevHeight = 0\\n        and from some prevHeight we need to cover a \\'dist\\' to reach the rungs[i],\\n        if there is prevHeight + dist >= rungs[i] then it is good we can reach our\\n        rungs[i] as we have covered plenty of range from [prevHeight, prevHeight + dist] \\n        as prevHeight < rungs[i] <= (prevHeight + dist)\\n        \\n        BUT \\n        \\n        if our prevHeight + dist < rungs[i] we don\\'t have much range to reach our\\n        rungs[i] so what we have to do is to add new rungs in between prevHeight\\n        and rungs[i] so to calculate that \\n        dest = rungs[i]\\n        src = prevHeight\\n        adjust = -1 \"adjust\", why? \\n        because, as we need to reach to dest from our src and we also know that\\n        we definitely have dest == rungs[i] available so we don\\'t need to count\\n        the dest rungs but those required in between thats why!!!\\n        \\n        so with this we need to cover a \\'total-length\\' of (dest - src - 1) between src & dest\\n        so how many rungs would be reuired to cover this \\'total-length\\' provided that we can\\n        move by dist \\'dist\\', then rungs required would be (\\'total-length\\' / \\'dist\\')\\n        \\n        hence, number of rungs required to add\\n        ==> addedRungs = ((dest - src - 1) / dist);\\n        ==> ((rungs[i] - prevHeight - 1) / dist)\\n```\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int n = rungs.length;\\n        int prevHeight = 0;\\n        int added = 0;\\n        for(int i = 0; i < n; i++){\\n            if(prevHeight + dist < rungs[i]) {\\n                added += ((rungs[i] - prevHeight - 1) / dist);\\n            }\\n            prevHeight = rungs[i];\\n        }\\n        return added;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478681,
                "title": "c-solution-in-linear-time-without-extra-storage",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        int cur = 0, res = 0;\\n        for(int i = 0; i < rungs.Length;i++){\\n            res+= (rungs[i] - cur - 1) / dist;\\n            cur = rungs[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        int cur = 0, res = 0;\\n        for(int i = 0; i < rungs.Length;i++){\\n            res+= (rungs[i] - cur - 1) / dist;\\n            cur = rungs[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477591,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int prev=0, cnt=0;\\n        for(auto r: rungs)\\n        {\\n            int diff=r-prev;\\n            if(diff%dist==0) cnt+=diff/dist-1;\\n            else cnt+=diff/dist;\\n            prev=r;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int prev=0, cnt=0;\\n        for(auto r: rungs)\\n        {\\n            int diff=r-prev;\\n            if(diff%dist==0) cnt+=diff/dist-1;\\n            else cnt+=diff/dist;\\n            prev=r;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473601,
                "title": "java-simple-code-beats-100-92",
                "content": "```\\n    public int addRungs(int[] rungs, int dist) {\\n        int res=0, pos=0;\\n        for (int i=0;i<rungs.length;i++){\\n            var val = rungs[i];\\n            if (val-pos>dist){\\n                var diff = val-pos;\\n                res+= diff%dist==0?diff/dist-1:diff/dist;\\n            }\\n            pos=val;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int addRungs(int[] rungs, int dist) {\\n        int res=0, pos=0;\\n        for (int i=0;i<rungs.length;i++){\\n            var val = rungs[i];\\n            if (val-pos>dist){\\n                var diff = val-pos;\\n                res+= diff%dist==0?diff/dist-1:diff/dist;\\n            }\\n            pos=val;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3458818,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans = (rungs[0] - 1) / dist;\\n        for(int i = 1; i < rungs.size(); i++) {\\n            ans += (rungs[i] - rungs[i - 1] - 1) / dist;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc addRungs(rungs []int, dist int) int {\\n    var ans int = (rungs[0] - 1) / dist\\n    for i := 1; i < len(rungs); i++ {\\n        ans += (rungs[i] - rungs[i - 1] - 1) / dist\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans = (rungs[0] - 1) / dist;\\n        for(int i = 1; i < rungs.size(); i++) {\\n            ans += (rungs[i] - rungs[i - 1] - 1) / dist;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc addRungs(rungs []int, dist int) int {\\n    var ans int = (rungs[0] - 1) / dist\\n    for i := 1; i < len(rungs); i++ {\\n        ans += (rungs[i] - rungs[i - 1] - 1) / dist\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446440,
                "title": "python3-clean-and-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        \\n        rungs=[0]+rungs\\n        ans=0\\n        \\n        for i in range(len(rungs)-1):\\n            diff=rungs[i+1]-rungs[i]\\n            if diff<=dist:\\n                continue\\n            \\n            ans+=(diff-1)//dist\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        \\n        rungs=[0]+rungs\\n        ans=0\\n        \\n        for i in range(len(rungs)-1):\\n            diff=rungs[i+1]-rungs[i]\\n            if diff<=dist:\\n                continue\\n            \\n            ans+=(diff-1)//dist\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430578,
                "title": "c-best-solution-explained-in-easy-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs given array is increasing in nature, So we just need to see the difference between then and number count minumum number of rungs we can keep in between them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor example : If we have to go from 3 to 6 and distance given is 1\\nWe just need 2 rungs no need to keep 3 rungs in between them\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int ans=0,val=0,n=rungs.size();\\n        for(int i=0;i<n;i++){\\n            //This is difference between two rungs\\n            int diff=rungs[i]-val;\\n            if(diff > dist){\\n                int toBeAdded=diff/dist;\\n\\n                //if difference is exactly divisible by distance then you can remove one rungs in between them to minimix your answer\\n                /*\\n                    For example : If we have to go from 3 to 6 and distance given is 1\\n                    We just need 2 rungs no need to keep 3 rungs in between them\\n                */\\n                if(diff % dist==0) toBeAdded--;\\n                ans+=toBeAdded;\\n            }\\n            //val is temporary variable taking previous rungs value\\n            val=rungs[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int ans=0,val=0,n=rungs.size();\\n        for(int i=0;i<n;i++){\\n            //This is difference between two rungs\\n            int diff=rungs[i]-val;\\n            if(diff > dist){\\n                int toBeAdded=diff/dist;\\n\\n                //if difference is exactly divisible by distance then you can remove one rungs in between them to minimix your answer\\n                /*\\n                    For example : If we have to go from 3 to 6 and distance given is 1\\n                    We just need 2 rungs no need to keep 3 rungs in between them\\n                */\\n                if(diff % dist==0) toBeAdded--;\\n                ans+=toBeAdded;\\n            }\\n            //val is temporary variable taking previous rungs value\\n            val=rungs[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396637,
                "title": "100-fast-easy-java-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n         \\n        int curr=0;       //created a pointer for the element at ground\\n        int i=0;\\n        int count=0;      //variable for taking count of rungs required\\n        while(i<rungs.length) //made a loop which will run to iterate the values\\n        {\\n            if(rungs[i]-curr<=dist) //if the value is satisfied then do nothing\\n            {\\n                curr=rungs[i];\\n                \\n                \\n            }\\n            else. //else we will see the difference between those two rungs where value is not satisified and if the difference is divisible by the dist then we will do -1 bcuz since it is a distance bwteen two numbers else we will take floor value.\\n            {\\n                int val=0;\\n                if((rungs[i]-curr)%dist==0)\\n                {\\n                        val=(rungs[i]-curr)/dist-1;\\n                }\\n                else\\n                {\\n                    val=(int)Math.floor((rungs[i]-curr)/dist);\\n                }\\n                 count=count+val;\\n                \\n                  curr=rungs[i];\\n               \\n\\n            }\\n          \\n            i++; //increment to proceed further\\n        }\\n        return count; //count of rungs required\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n         \\n        int curr=0;       //created a pointer for the element at ground\\n        int i=0;\\n        int count=0;      //variable for taking count of rungs required\\n        while(i<rungs.length) //made a loop which will run to iterate the values\\n        {\\n            if(rungs[i]-curr<=dist) //if the value is satisfied then do nothing\\n            {\\n                curr=rungs[i];\\n                \\n                \\n            }\\n            else. //else we will see the difference between those two rungs where value is not satisified and if the difference is divisible by the dist then we will do -1 bcuz since it is a distance bwteen two numbers else we will take floor value.\\n            {\\n                int val=0;\\n                if((rungs[i]-curr)%dist==0)\\n                {\\n                        val=(rungs[i]-curr)/dist-1;\\n                }\\n                else\\n                {\\n                    val=(int)Math.floor((rungs[i]-curr)/dist);\\n                }\\n                 count=count+val;\\n                \\n                  curr=rungs[i];\\n               \\n\\n            }\\n          \\n            i++; //increment to proceed further\\n        }\\n        return count; //count of rungs required\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359003,
                "title": "c",
                "content": "```\\nint addRungs(int* rungs, int rungsSize, int dist){\\n    int ret = 0 ;\\n    ret += (rungs[0]-1) / dist ;\\n    for(int i = 1; i < rungsSize; i++){\\n        int gap = rungs[i] - rungs[i-1] ;\\n        ret += (gap-1)/dist ;\\n    }\\n    return ret ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint addRungs(int* rungs, int rungsSize, int dist){\\n    int ret = 0 ;\\n    ret += (rungs[0]-1) / dist ;\\n    for(int i = 1; i < rungsSize; i++){\\n        int gap = rungs[i] - rungs[i-1] ;\\n        ret += (gap-1)/dist ;\\n    }\\n    return ret ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337773,
                "title": "python-3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        last = 0\\n        res = 0\\n        for x in rungs:\\n            res += (x - last-1)//dist\\n            last = x\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        last = 0\\n        res = 0\\n        for x in rungs:\\n            res += (x - last-1)//dist\\n            last = x\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320637,
                "title": "easy-to-understand-java-solution",
                "content": "![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/929d63af-ad34-4c9f-9657-b23a867a3f5b_1679327963.848759.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int a=0;\\n        int c = 0;\\n        for(int i:rungs){\\n            a += ((i-c-1)/dist); \\n            c = i;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int a=0;\\n        int c = 0;\\n        for(int i:rungs){\\n            a += ((i-c-1)/dist); \\n            c = i;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248769,
                "title": "python3-easy-o-n",
                "content": "\\n# Explanation:\\nWe iterate through the rungs one by one and check if the distance between the current rung and the previous rung is greater than the given distance. If it is, we calculate the number of rungs that need to be added in between the two rungs to maintain the given distance. We add this count to our total count of rungs to be added. Finally, we update the start position to be the current rung and move on to the next rung. At the end, we return the total count of rungs to be added.\\n\\n# Time Complexity:\\nThe time complexity of this approach is O(n) as we iterate through the entire array once.\\n\\n# Space Complexity:\\nThe space complexity of this approach is O(1) as we only use a constant amount of extra space to keep track of the current position and the total count of rungs to be added.\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        start = 0\\n        i = 0\\n        while i < len(rungs):\\n            cur_rung = rungs[i]\\n            if cur_rung - start > dist:\\n                count += (cur_rung - start - 1) // dist\\n            start = cur_rung\\n            i += 1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        start = 0\\n        i = 0\\n        while i < len(rungs):\\n            cur_rung = rungs[i]\\n            if cur_rung - start > dist:\\n                count += (cur_rung - start - 1) // dist\\n            start = cur_rung\\n            i += 1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245711,
                "title": "beginner-friendly-solution-c-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nH:(-1 for one less step or plank.)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n     int cnt=0;\\n      cnt+=(rungs[0]-1)/dist;\\n     for(int i=0;i<n-1;i++)\\n     {\\n        \\n            cnt+=(rungs[i+1]-rungs[i]-1)/dist;\\n        \\n     }\\n\\n     \\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n     int cnt=0;\\n      cnt+=(rungs[0]-1)/dist;\\n     for(int i=0;i<n-1;i++)\\n     {\\n        \\n            cnt+=(rungs[i+1]-rungs[i]-1)/dist;\\n        \\n     }\\n\\n     \\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223152,
                "title": "python-ceil-distance-gaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs=[0]+rungs\\n        i,ans=1,0\\n        while i<len(rungs): \\n            if rungs[i]-rungs[i-1] > dist:\\n                ans+=ceil((rungs[i]-rungs[i-1])/dist)-1\\n            i+=1\\n        return ans\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs=[0]+rungs\\n        i,ans=1,0\\n        while i<len(rungs): \\n            if rungs[i]-rungs[i-1] > dist:\\n                ans+=ceil((rungs[i]-rungs[i-1])/dist)-1\\n            i+=1\\n        return ans\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191131,
                "title": "100-1ms-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int cur =0;\\n        int res =0;\\n        for(int n:rungs){\\n            if(n-cur>dist){\\n                int q = (n-cur-1)/dist;\\n            \\n                res += q;\\n            \\n            }\\n            cur = n;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int cur =0;\\n        int res =0;\\n        for(int n:rungs){\\n            if(n-cur>dist){\\n                int q = (n-cur-1)/dist;\\n            \\n                res += q;\\n            \\n            }\\n            cur = n;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188468,
                "title": "c-clean-short-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;\\n        if(rungs[0]>dist)\\n        {c+=rungs[0]/dist;\\n        if(rungs[0]%dist==0)\\n        c--;\\n        }\\n        for(int i=1;i<rungs.size();i++)\\n        {    int d=rungs[i]-rungs[i-1];\\n            if(d>dist)\\n            {\\n             c+=d/dist;\\n             if(d%dist==0)\\n             c--;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;\\n        if(rungs[0]>dist)\\n        {c+=rungs[0]/dist;\\n        if(rungs[0]%dist==0)\\n        c--;\\n        }\\n        for(int i=1;i<rungs.size();i++)\\n        {    int d=rungs[i]-rungs[i-1];\\n            if(d>dist)\\n            {\\n             c+=d/dist;\\n             if(d%dist==0)\\n             c--;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186165,
                "title": "java-simple-solution-greedy-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans = 0;\\n        int curr=0;\\n        int n = rungs.length;\\n        for(int i=0;i<n;i++){\\n            if((rungs[i]-curr-1)/dist>0) \\n                ans += (rungs[i]-curr-1)/dist;\\n            curr = rungs[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans = 0;\\n        int curr=0;\\n        int n = rungs.length;\\n        for(int i=0;i<n;i++){\\n            if((rungs[i]-curr-1)/dist>0) \\n                ans += (rungs[i]-curr-1)/dist;\\n            curr = rungs[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182461,
                "title": "i-feel-it-s-easy-level",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, pos = 0;\\n        for(auto x: rungs){\\n            res += (x-pos-1) / dist;\\n            pos = x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, pos = 0;\\n        for(auto x: rungs){\\n            res += (x-pos-1) / dist;\\n            pos = x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176621,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int cnt=0;int k=0;\\n        if(rungs[0]-0>dist){\\n            if(dist>1&&((rungs[0]-0)%dist!=0))\\n            cnt=((rungs[0]-0)/dist);\\n            else\\n             cnt=((rungs[0]-0)/dist)-1;\\n        }\\n        for(int i=0;i<rungs.length-1;i++){\\n            if(rungs[i+1]-rungs[i]>dist){\\n                k=rungs[i+1]-rungs[i];\\n                if(k%dist!=0){\\n                cnt+=k/dist;\\n                }\\n                else{\\n                cnt+=k/dist-1;}\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int cnt=0;int k=0;\\n        if(rungs[0]-0>dist){\\n            if(dist>1&&((rungs[0]-0)%dist!=0))\\n            cnt=((rungs[0]-0)/dist);\\n            else\\n             cnt=((rungs[0]-0)/dist)-1;\\n        }\\n        for(int i=0;i<rungs.length-1;i++){\\n            if(rungs[i+1]-rungs[i]>dist){\\n                k=rungs[i+1]-rungs[i];\\n                if(k%dist!=0){\\n                cnt+=k/dist;\\n                }\\n                else{\\n                cnt+=k/dist-1;}\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158297,
                "title": "simple-o-n-solution-rust-beats-100",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nuse std::cmp::max;\\n\\nimpl Solution {\\n    pub fn add_rungs(rungs: Vec<i32>, dist: i32) -> i32 {\\n        let (mut far, mut ans, n) = (0, 0, rungs.len());\\n\\n        for i in 0..n {\\n            if rungs[i] - far > dist {\\n                ans += (rungs[i] - far - 1) / dist;\\n                far += rungs[i] - far - 1;\\n            }\\n \\n            far = max(far, rungs[i]);\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::max;\\n\\nimpl Solution {\\n    pub fn add_rungs(rungs: Vec<i32>, dist: i32) -> i32 {\\n        let (mut far, mut ans, n) = (0, 0, rungs.len());\\n\\n        for i in 0..n {\\n            if rungs[i] - far > dist {\\n                ans += (rungs[i] - far - 1) / dist;\\n                far += rungs[i] - far - 1;\\n            }\\n \\n            far = max(far, rungs[i]);\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3156899,
                "title": "simple-java-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int res = 0, pre = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            int d = rungs[i] - pre;\\n            if (d > dist) {\\n                res += d % dist == 0 ? d / dist - 1: d / dist;\\n            }\\n            pre = rungs[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int res = 0, pre = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            int d = rungs[i] - pre;\\n            if (d > dist) {\\n                res += d % dist == 0 ? d / dist - 1: d / dist;\\n            }\\n            pre = rungs[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087031,
                "title": "python-clean-and-simple",
                "content": "```\\nfrom itertools import chain, pairwise\\nfrom math import ceil\\n\\n\\nclass Solution:\\n    def addRungs(self, rungs: list[int], dist: int) -> int:\\n        return sum(\\n            ceil((cur - prev) / dist) - 1\\n            for prev, cur in pairwise(chain([0], rungs))\\n        )\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import chain, pairwise\\nfrom math import ceil\\n\\n\\nclass Solution:\\n    def addRungs(self, rungs: list[int], dist: int) -> int:\\n        return sum(\\n            ceil((cur - prev) / dist) - 1\\n            for prev, cur in pairwise(chain([0], rungs))\\n        )\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045183,
                "title": "my-solution-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first I thought that if difference between two elements is greater than the allowed distance than i should subtract the distance from difference and increment the counter(no Of Rungs).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince my first approach takes alot time when input is large, therefore the approach used to solve the problem is that difference between two elemnts of array is divided by allowed/given distance. Then the answers is added to noOfRungs(an int variable).\\nThe process is done in loop by comparing two elements in sequence.\\n\\nFor example if array is [4,9,15] and allowed distance is 4. Then\\n\\nFirst iteration : diff = 9-4 = 5, dist = 4\\ndiff/dist = 5/4 = 1\\n\\nSecond iteration:diff = 15-9 = 6, dist = 4\\ndiff/dist = 6/4 = 1\\n\\nhence total rungs that should be added are 1+1 = 2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n.\\n\\n# Code\\n```\\n#include<string.h>\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int length = rungs.size();\\n        int noOfRungs = 0;\\n\\n        //check if number of elements within the allowed limits\\n        if(length < 1 || length > 100000 )\\n            return -1;\\n\\n        //check if distance is within the allowed limits\\n        if(dist < 1 || dist > 1000000000)\\n            return -2;\\n  \\n        int firstHeightCheck = 0 + rungs[0] - 1;\\n        if(firstHeightCheck >= dist)\\n            noOfRungs += firstHeightCheck/dist;\\n        \\n        //first approach, correct but takes a lot of time\\n        /*while(firstHeightCheck > dist)\\n        {\\n            noOfRungs++;\\n            firstHeightCheck -=dist;\\n        }\\n        */\\n            \\n        for(int i = 1; i < length ; i++)\\n        {\\n            int diff = rungs[i] - rungs[i-1] - 1;\\n            \\n            //check if array is strictly increasing\\n            if(diff < 0)\\n                return -3;\\n\\n            if(diff >= dist)\\n            {\\n                //cout<<rungs[i] << \"-\" << rungs[i-1] << \"=\"<< diff <<\"\\\\n\";\\n                /*\\n                while(diff > dist)\\n                {\\n                    noOfRungs++;\\n                    diff -= dist;\\n                }\\n                */\\n\\n                noOfRungs += diff/dist;\\n            }\\n        }\\n        return noOfRungs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<string.h>\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int length = rungs.size();\\n        int noOfRungs = 0;\\n\\n        //check if number of elements within the allowed limits\\n        if(length < 1 || length > 100000 )\\n            return -1;\\n\\n        //check if distance is within the allowed limits\\n        if(dist < 1 || dist > 1000000000)\\n            return -2;\\n  \\n        int firstHeightCheck = 0 + rungs[0] - 1;\\n        if(firstHeightCheck >= dist)\\n            noOfRungs += firstHeightCheck/dist;\\n        \\n        //first approach, correct but takes a lot of time\\n        /*while(firstHeightCheck > dist)\\n        {\\n            noOfRungs++;\\n            firstHeightCheck -=dist;\\n        }\\n        */\\n            \\n        for(int i = 1; i < length ; i++)\\n        {\\n            int diff = rungs[i] - rungs[i-1] - 1;\\n            \\n            //check if array is strictly increasing\\n            if(diff < 0)\\n                return -3;\\n\\n            if(diff >= dist)\\n            {\\n                //cout<<rungs[i] << \"-\" << rungs[i-1] << \"=\"<< diff <<\"\\\\n\";\\n                /*\\n                while(diff > dist)\\n                {\\n                    noOfRungs++;\\n                    diff -= dist;\\n                }\\n                */\\n\\n                noOfRungs += diff/dist;\\n            }\\n        }\\n        return noOfRungs;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3013521,
                "title": "python-one-pass",
                "content": "# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        cur = 0\\n        res = 0\\n        for r in rungs:\\n            res += (r - cur - 1)//dist\\n            cur = r\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        cur = 0\\n        res = 0\\n        for r in rungs:\\n            res += (r - cur - 1)//dist\\n            cur = r\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005467,
                "title": "java-beats-82",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        if (rungs[0] > dist) {\\n            count += rungs[0]/dist;\\n            if (rungs[0] % dist == 0) count--;\\n        }\\n        for (int i = 0; i < rungs.length - 1; i++) {\\n            int distance = rungs[i+1] - rungs[i];\\n            if (distance > dist) {\\n                count += distance / dist;\\n                if (distance % dist == 0) count--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        if (rungs[0] > dist) {\\n            count += rungs[0]/dist;\\n            if (rungs[0] % dist == 0) count--;\\n        }\\n        for (int i = 0; i < rungs.length - 1; i++) {\\n            int distance = rungs[i+1] - rungs[i];\\n            if (distance > dist) {\\n                count += distance / dist;\\n                if (distance % dist == 0) count--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963671,
                "title": "java-easy-solution-in-constant-space",
                "content": "**If you like my solution, Please Upvote!!**\\n\\n# Approach\\n1. If you have to add a new rung, add it as high up as possible.\\n2. Try using division to decrease the number of computations.\\n\\n# Complexity\\n- Time complexity:  O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        int currRung = 0;\\n        \\n        for(int i=0;i<rungs.length;i++){\\n            if(rungs[i]-currRung<=dist){\\n                currRung = rungs[i];\\n            }else{\\n                count += (rungs[i]-currRung-1)/dist;\\n                currRung = rungs[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        int currRung = 0;\\n        \\n        for(int i=0;i<rungs.length;i++){\\n            if(rungs[i]-currRung<=dist){\\n                currRung = rungs[i];\\n            }else{\\n                count += (rungs[i]-currRung-1)/dist;\\n                currRung = rungs[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954053,
                "title": "o-n-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans[]=new int[rungs.length];\\n        int c=0;\\n        for(int i=rungs.length-1;i>=1;i--){\\n            ans[i]=rungs[i]-rungs[i-1];\\n        }\\n        ans[0]=rungs[0]-0;\\n        for(int i=0;i<ans.length;i++){\\n            if(ans[i]>dist)\\n            {\\n                \\n            \\n                if(ans[i]%dist==0)\\n                c+=ans[i]/dist-1;\\n                else\\n                c+=ans[i]/dist;\\n            \\n               // c+=ans[i]/dist;\\n            }\\n        }\\n            \\n        return c;\\n            \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans[]=new int[rungs.length];\\n        int c=0;\\n        for(int i=rungs.length-1;i>=1;i--){\\n            ans[i]=rungs[i]-rungs[i-1];\\n        }\\n        ans[0]=rungs[0]-0;\\n        for(int i=0;i<ans.length;i++){\\n            if(ans[i]>dist)\\n            {\\n                \\n            \\n                if(ans[i]%dist==0)\\n                c+=ans[i]/dist-1;\\n                else\\n                c+=ans[i]/dist;\\n            \\n               // c+=ans[i]/dist;\\n            }\\n        }\\n            \\n        return c;\\n            \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952710,
                "title": "easy-solution-with-90-faster-c-beginner-friendly",
                "content": "# Intuition\\nWe just have to find number of times we need to insert rungs in between two adjacent element .\\n\\n# Approach\\nCreate two variable\\n answer: to store inerstion count;\\n floor: to store the floor till which we reached;\\n\\n\\nFor each element check if floor + dist>= element ,then we dont need to insert any rungs, so we move forward.\\nelse if floor+ dist < element, then we need to insert rungs.\\nIn inserting there are two cases:\\nFirst case if Element - floor is divisible by dist then we add required rungs-1.\\nelse we insert (element -floor)/dist rungs.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n        int floor=0,ans=0,i=0;\\n        while(i<n)\\n        {\\n            if(floor+dist>=rungs[i])\\n            {  floor=rungs[i];\\n                i++;\\n            }\\n            else\\n            {     int count=rungs[i]-floor;\\n               \\n                  if(count%dist==0)\\n                  {  int val=count/dist-1;\\n                     ans+=val;\\n                     floor+=(dist*val);\\n                  }\\n                  else\\n                  {  int val=count/dist;\\n                     ans+=val;\\n                     floor+=dist*val;\\n                  }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n        int floor=0,ans=0,i=0;\\n        while(i<n)\\n        {\\n            if(floor+dist>=rungs[i])\\n            {  floor=rungs[i];\\n                i++;\\n            }\\n            else\\n            {     int count=rungs[i]-floor;\\n               \\n                  if(count%dist==0)\\n                  {  int val=count/dist-1;\\n                     ans+=val;\\n                     floor+=(dist*val);\\n                  }\\n                  else\\n                  {  int val=count/dist;\\n                     ans+=val;\\n                     floor+=dist*val;\\n                  }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933481,
                "title": "c-simple-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans{0}, prev{0};\\n\\n        for(int i{0}; i < rungs.size(); i++){\\n            int diff = (rungs[i] - prev);\\n\\n            if(diff > dist)\\n                ans += (diff - 1) / dist;\\n\\n            prev = rungs[i];\\n        }\\n\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans{0}, prev{0};\\n\\n        for(int i{0}; i < rungs.size(); i++){\\n            int diff = (rungs[i] - prev);\\n\\n            if(diff > dist)\\n                ans += (diff - 1) / dist;\\n\\n            prev = rungs[i];\\n        }\\n\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841684,
                "title": "c-simple-o-n-solution-using-for-loop",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n\\nint addRungs(int* rungs, int rungsSize, int dist){\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < rungsSize; i++) {\\n\\n        count += (rungs[i] - (i > 0 ? rungs[i - 1] : 0) - 1) / dist; \\n\\n    }\\n\\n    return count;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint addRungs(int* rungs, int rungsSize, int dist){\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < rungsSize; i++) {\\n\\n        count += (rungs[i] - (i > 0 ? rungs[i - 1] : 0) - 1) / dist; \\n\\n    }\\n\\n    return count;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2824290,
                "title": "c-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, pos = 0;\\n        for (int i = 0; i < rungs.size(); ++i) {\\n            if (pos + dist < rungs[i]) {\\n                res += ceil((rungs[i]-pos) / double(dist)) - 1;\\n            }\\n            pos = rungs[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, pos = 0;\\n        for (int i = 0; i < rungs.size(); ++i) {\\n            if (pos + dist < rungs[i]) {\\n                res += ceil((rungs[i]-pos) / double(dist)) - 1;\\n            }\\n            pos = rungs[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783038,
                "title": "greedy",
                "content": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs = [0] + rungs\\n        return sum(  (rungs[i]-rungs[i-1] - 1)//dist        for i in range(1,len(rungs)) )\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs = [0] + rungs\\n        return sum(  (rungs[i]-rungs[i-1] - 1)//dist        for i in range(1,len(rungs)) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782614,
                "title": "simply-syntax-on-python-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        curr, preSum = 0, []\\n        for run in rungs:\\n            preSum.append(run - curr)\\n            curr = run\\n        \\n        result = sum([ (k-1 if dist == 1 else (k//dist if k%dist > 0 else (k//dist) - 1) )   for k in preSum if k > dist])    \\n        return result\\n    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        curr, preSum = 0, []\\n        for run in rungs:\\n            preSum.append(run - curr)\\n            curr = run\\n        \\n        result = sum([ (k-1 if dist == 1 else (k//dist if k%dist > 0 else (k//dist) - 1) )   for k in preSum if k > dist])    \\n        return result\\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767867,
                "title": "divide-gaps-by-dist-details-explanation",
                "content": "**Why (gaps-1)/dist ?**\\nIf we only have two point (0 and 5 lets say) then how can we reach to 5 from 0. We need a intermediate step which is in distance D from 0. It may be tempting to find out by dividing the gap by distance D.\\nSo, (5-0)/2=2 which is correct.\\n```\\n0 1 2 3 4 5\\n    -   -\\n```\\nAs we can see, to react the desired point 5 we require two intermediate step (2 and 4).\\n\\nNow lets say, we have to reach from 0 to 6 this time. If we apply the same logic as we did earlier i.e. gap/dist = (6-0)/2 = 3. Lets see them in following figure:\\n```\\n0 1 2 3 4 5 6\\n    -   -\\n```\\nAs we can see , we still only require step 2 and step 4 to reach our goal.\\nThis is why we did -1 in the beginning. \\n\\nIf you understand this far, the rest of logic is straight forward. Here is the C++ code: \\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count  = 0;\\n        int prev = 0;\\n        int sz = rungs.size();\\n        for(int i = 0; i<sz; i++){\\n            if(rungs[i]-prev>dist){\\n                count += (rungs[i]-prev-1)/dist;\\n            }\\n            prev = rungs[i];\\n        }      \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n0 1 2 3 4 5\\n    -   -\\n```\n```\\n0 1 2 3 4 5 6\\n    -   -\\n```\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count  = 0;\\n        int prev = 0;\\n        int sz = rungs.size();\\n        for(int i = 0; i<sz; i++){\\n            if(rungs[i]-prev>dist){\\n                count += (rungs[i]-prev-1)/dist;\\n            }\\n            prev = rungs[i];\\n        }      \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754908,
                "title": "easiest-sol-maybe-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& a, int k) \\n    {\\n        int res=0;\\n        if(a.size()==1)return (a[0]-1)/k;\\n        for(int i=0;i<a.size()-1;i++)\\n        {\\n            res+=(a[i+1]-a[i]-1)/k;\\n            if(i==0)res+=(a[0]-1)/k;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& a, int k) \\n    {\\n        int res=0;\\n        if(a.size()==1)return (a[0]-1)/k;\\n        for(int i=0;i<a.size()-1;i++)\\n        {\\n            res+=(a[i+1]-a[i]-1)/k;\\n            if(i==0)res+=(a[0]-1)/k;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742659,
                "title": "easy-solution-in-java-10-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple maths\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaths\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n          int count=dist;\\n          int sum=0; \\n          int arr[]=new int[rungs.length+1];\\n          arr[0]=0;\\n          int p=0;\\n          for(int i=1;i<rungs.length+1;i++)\\n          {\\n              arr[i]=rungs[p++];\\n          }\\n          for(int i=0;i<rungs.length;i++)\\n          {\\n              if((arr[i+1]-arr[i])>dist)\\n              {\\n                  int pp=(arr[i+1]-arr[i]);\\n                  int value=(arr[i+1]-arr[i])/dist;\\n                  if((pp%dist)==0)\\n                  {\\n                      value=value-1;\\n                  }\\n                  sum=sum+value;    \\n              }\\n              else\\n              {\\n                  \\n              }\\n          } \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n          int count=dist;\\n          int sum=0; \\n          int arr[]=new int[rungs.length+1];\\n          arr[0]=0;\\n          int p=0;\\n          for(int i=1;i<rungs.length+1;i++)\\n          {\\n              arr[i]=rungs[p++];\\n          }\\n          for(int i=0;i<rungs.length;i++)\\n          {\\n              if((arr[i+1]-arr[i])>dist)\\n              {\\n                  int pp=(arr[i+1]-arr[i]);\\n                  int value=(arr[i+1]-arr[i])/dist;\\n                  if((pp%dist)==0)\\n                  {\\n                      value=value-1;\\n                  }\\n                  sum=sum+value;    \\n              }\\n              else\\n              {\\n                  \\n              }\\n          } \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742658,
                "title": "easy-solution-in-java-10-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple maths\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaths\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n          int count=dist;\\n          int sum=0; \\n          int arr[]=new int[rungs.length+1];\\n          arr[0]=0;\\n          int p=0;\\n          for(int i=1;i<rungs.length+1;i++)\\n          {\\n              arr[i]=rungs[p++];\\n          }\\n          for(int i=0;i<rungs.length;i++)\\n          {\\n              if((arr[i+1]-arr[i])>dist)\\n              {\\n                  int pp=(arr[i+1]-arr[i]);\\n                  int value=(arr[i+1]-arr[i])/dist;\\n                  if((pp%dist)==0)\\n                  {\\n                      value=value-1;\\n                  }\\n                  sum=sum+value;    \\n              }\\n              else\\n              {\\n                  \\n              }\\n          } \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n          int count=dist;\\n          int sum=0; \\n          int arr[]=new int[rungs.length+1];\\n          arr[0]=0;\\n          int p=0;\\n          for(int i=1;i<rungs.length+1;i++)\\n          {\\n              arr[i]=rungs[p++];\\n          }\\n          for(int i=0;i<rungs.length;i++)\\n          {\\n              if((arr[i+1]-arr[i])>dist)\\n              {\\n                  int pp=(arr[i+1]-arr[i]);\\n                  int value=(arr[i+1]-arr[i])/dist;\\n                  if((pp%dist)==0)\\n                  {\\n                      value=value-1;\\n                  }\\n                  sum=sum+value;    \\n              }\\n              else\\n              {\\n                  \\n              }\\n          } \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702256,
                "title": "c-o-n-easy-understanding",
                "content": "```\\nint addRungs(vector<int>& r, int d) {\\n        int n=r.size();\\n        int c=0;\\n        if(r[0]>d){\\n            c+=(r[0]-1)/d;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(r[i+1]-r[i]>d){\\n                int p=r[i+1]-r[i]-1;\\n                c+=(p/d);\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint addRungs(vector<int>& r, int d) {\\n        int n=r.size();\\n        int c=0;\\n        if(r[0]>d){\\n            c+=(r[0]-1)/d;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(r[i+1]-r[i]>d){\\n                int p=r[i+1]-r[i]-1;\\n                c+=(p/d);\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690098,
                "title": "easy-python-greedy-solution-94-faster",
                "content": "![image](https://assets.leetcode.com/users/images/0055bb0f-ca93-4fff-95eb-d00243b239ad_1665487325.3612945.png)\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs = [0] + rungs\\n        n = len(rungs)\\n        res = 0\\n        for i in range(1,n):\\n            if rungs[i] - rungs[i-1] <= dist: continue\\n\\n            res += math.ceil((rungs[i] - rungs[i-1])/dist) - 1\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs = [0] + rungs\\n        n = len(rungs)\\n        res = 0\\n        for i in range(1,n):\\n            if rungs[i] - rungs[i-1] <= dist: continue\\n\\n            res += math.ceil((rungs[i] - rungs[i-1])/dist) - 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670251,
                "title": "greedy-distance-python-tc-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. --> Greedy methodology\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        ans = 0\\n        if rungs[0] - 0 > dist:\\n            ans += (rungs[0]-1)//dist\\n        for i in range(len(rungs)):\\n            diff = rungs[i] - rungs[i-1]\\n            if diff > dist: \\n                ans += (diff-1)//dist\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        ans = 0\\n        if rungs[0] - 0 > dist:\\n            ans += (rungs[0]-1)//dist\\n        for i in range(len(rungs)):\\n            diff = rungs[i] - rungs[i-1]\\n            if diff > dist: \\n                ans += (diff-1)//dist\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657033,
                "title": "c-simple-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int pos=0,count=0;\\n        for(int i=0;i<rungs.size();i++){\\n            if((rungs[i]-pos)>dist){\\n                if((rungs[i]-pos)%dist){\\n                   count+=(rungs[i]-pos)/dist; \\n                }\\n                else{\\n                    count+=(rungs[i]-pos)/dist-1;\\n                }   \\n            }\\n            pos=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int pos=0,count=0;\\n        for(int i=0;i<rungs.size();i++){\\n            if((rungs[i]-pos)>dist){\\n                if((rungs[i]-pos)%dist){\\n                   count+=(rungs[i]-pos)/dist; \\n                }\\n                else{\\n                    count+=(rungs[i]-pos)/dist-1;\\n                }   \\n            }\\n            pos=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641513,
                "title": "maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0; \\n        if(rungs[0] > dist)  ans+=(rungs[0]-1)/dist;\\n        \\n        for(int i=0;i<rungs.size()-1;i++){\\n            int val = rungs[i+1]-rungs[i] ; \\n            if(val>dist) ans+=(val-1)/dist ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0; \\n        if(rungs[0] > dist)  ans+=(rungs[0]-1)/dist;\\n        \\n        for(int i=0;i<rungs.size()-1;i++){\\n            int val = rungs[i+1]-rungs[i] ; \\n            if(val>dist) ans+=(val-1)/dist ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639785,
                "title": "javascript-o-n-w-reduce",
                "content": "```javascript\\n/**\\n * @param {number[]} rungs\\n * @param {number} dist\\n * @return {number}\\n */\\nvar addRungs = function (rungs, dist) {\\n  return rungs.reduce(\\n    (acc, cur) => {\\n      let [prev, res] = acc;\\n      return [cur, res + Math.floor((cur - prev - 1) / dist)];\\n    },\\n    [0, 0]\\n  )[1];\\n};\\n```\\n\\nTESTED\\n\\n```txt\\nAccepted\\n117/117 cases passed (158 ms)\\nYour runtime beats 11.11 % of javascript submissions\\nYour memory usage beats 5.56 % of javascript submissions (55.6 MB)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} rungs\\n * @param {number} dist\\n * @return {number}\\n */\\nvar addRungs = function (rungs, dist) {\\n  return rungs.reduce(\\n    (acc, cur) => {\\n      let [prev, res] = acc;\\n      return [cur, res + Math.floor((cur - prev - 1) / dist)];\\n    },\\n    [0, 0]\\n  )[1];\\n};\\n```\n```txt\\nAccepted\\n117/117 cases passed (158 ms)\\nYour runtime beats 11.11 % of javascript submissions\\nYour memory usage beats 5.56 % of javascript submissions (55.6 MB)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2638559,
                "title": "c-easy-solution-95-faster",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;\\n        int ans=0;\\n        for(int i=0;i<rungs.size();i++){\\n\\t\\t\\n            if(rungs[i]-c>dist ){\\n                if((rungs[i]-c)%dist==0){\\n                    ans = ans + (rungs[i]-c)/dist -1;\\n                    c = rungs[i];\\n                }\\n                else if((rungs[i]-c)%dist!=0) {\\n                ans = ans + (rungs[i]-c)/dist;\\n                c = rungs[i];\\n                }\\n            }\\n            c =rungs[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;\\n        int ans=0;\\n        for(int i=0;i<rungs.size();i++){\\n\\t\\t\\n            if(rungs[i]-c>dist ){\\n                if((rungs[i]-c)%dist==0){\\n                    ans = ans + (rungs[i]-c)/dist -1;\\n                    c = rungs[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2627308,
                "title": "simple-c-solutioon",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int i, ans = 0, last, diff, k;\\n        \\n        last = 0;\\n        \\n        for(i=0; i < rungs.size(); i++){\\n            \\n            diff = rungs[i] - last;\\n            \\n            if(diff > dist){\\n                \\n                if(diff%dist==0){\\n                    \\n                    k = diff/dist-1;\\n                    \\n                }else\\n                    k = diff/dist;\\n                \\n                ans += k;\\n                \\n                last = max(k*dist, rungs[i]);\\n                \\n            }else{\\n                \\n                last = rungs[i];\\n                \\n            }\\n            \\n        }\\n         \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int i, ans = 0, last, diff, k;\\n        \\n        last = 0;\\n        \\n        for(i=0; i < rungs.size(); i++){\\n            \\n            diff = rungs[i] - last;\\n            \\n            if(diff > dist){\\n                \\n                if(diff%dist==0){\\n                    \\n                    k = diff/dist-1;\\n                    \\n                }else\\n                    k = diff/dist;\\n                \\n                ans += k;\\n                \\n                last = max(k*dist, rungs[i]);\\n                \\n            }else{\\n                \\n                last = rungs[i];\\n                \\n            }\\n            \\n        }\\n         \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617822,
                "title": "unique-solution-and-clean-code-cpp",
                "content": "```\\nint addRungs(vector<int>& a, int dist) {\\n\\tint curDis = a[0], ans = 0, n = a.size();\\n\\n\\tif(curDis > dist) {\\n\\t\\tans += (curDis/dist) + ((curDis%dist) > 0);\\n\\t\\tans--;\\n\\t}\\n\\n\\tfor(int i = 0; i + 1 < n; i++) {\\n\\t\\tcurDis = (a[i+1] - a[i]);\\n\\t\\tif(curDis > dist) {\\n\\t\\t\\tans += (curDis/dist) + ((curDis%dist) > 0);\\n\\t\\t\\tans--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nint addRungs(vector<int>& a, int dist) {\\n\\tint curDis = a[0], ans = 0, n = a.size();\\n\\n\\tif(curDis > dist) {\\n\\t\\tans += (curDis/dist) + ((curDis%dist) > 0);\\n\\t\\tans--;\\n\\t}\\n\\n\\tfor(int i = 0; i + 1 < n; i++) {\\n\\t\\tcurDis = (a[i+1] - a[i]);\\n\\t\\tif(curDis > dist) {\\n\\t\\t\\tans += (curDis/dist) + ((curDis%dist) > 0);\\n\\t\\t\\tans--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2617640,
                "title": "simple-solution",
                "content": "class Solution {\\n    public int addRungs(int[] Rungs, int dist) {\\n        \\n        int ptr = 0;\\n        int res = 0;\\n        \\n        for (int i = 0; i < Rungs.length; i++) {\\n            \\n            res += (Rungs[i] - ptr - 1) / dist;\\n            ptr = Rungs[i];\\n            \\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int addRungs(int[] Rungs, int dist) {\\n        \\n        int ptr = 0;\\n        int res = 0;\\n        \\n        for (int i = 0; i < Rungs.length; i++) {\\n            \\n            res += (Rungs[i] - ptr - 1) / dist;\\n            ptr = Rungs[i];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2560016,
                "title": "c-intuition-explained-greedy-o-n",
                "content": "```\\n  int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int prev=0,count=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            int diff=rungs[i]-prev;\\n            \\n//IMPORTANT ---> if diff/dist is totally divisible then in bw diff/dist -1 rings inserted if diff =13 and dist=3 4 rings inserted at 3,6,9,12, but if diff=9 and dist=k 2 rings inserted 3,6 .. (9 me to ring hai hi)\\n            count+=(diff%dist)?diff/dist:diff/dist-1;\\n            prev=rungs[i];\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\n  int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int prev=0,count=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            int diff=rungs[i]-prev;\\n            \\n//IMPORTANT ---> if diff/dist is totally divisible then in bw diff/dist -1 rings inserted if diff =13 and dist=3 4 rings inserted at 3,6,9,12, but if diff=9 and dist=k 2 rings inserted 3,6 .. (9 me to ring hai hi)\\n            count+=(diff%dist)?diff/dist:diff/dist-1;\\n            prev=rungs[i];\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2555940,
                "title": "java-c-python-straight-forward-greedy-sorting-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = (rungs[0] - 1-0) / dist;\\n    for (int i = 1; i < rungs.size(); ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2553182,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn add_rungs(rungs: Vec<i32>, dist: i32) -> i32 {\\n        let mut now = 0;\\n        let mut result = 0;\\n        for v in rungs {\\n            let diff = v - now;\\n            if diff > dist {\\n                let diff = diff - dist;\\n                let mut add = diff / dist;\\n                if diff % dist != 0 {\\n                    add += 1;\\n                }\\n                result += add;\\n            }\\n            \\n            now = v;\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn add_rungs(rungs: Vec<i32>, dist: i32) -> i32 {\\n        let mut now = 0;\\n        let mut result = 0;\\n        for v in rungs {\\n            let diff = v - now;\\n            if diff > dist {\\n                let diff = diff - dist;\\n                let mut add = diff / dist;\\n                if diff % dist != 0 {\\n                    add += 1;\\n                }\\n                result += add;\\n            }\\n            \\n            now = v;\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549218,
                "title": "typescript-minimum-rungs-clean-solution-139-ms-faster-than-100-00-54-3-mb-less-than-100-00",
                "content": "Explanation:\\n1. Currently on floor 0, so create a storage for the minimum number of floors.\\n2. Check if first item is greater than `dist`, then add dist to the rungs.\\n3. Loop through the rungs starting from the second item.\\n4. Split Check if the difference between current item and the previous item is greater than `dist`.\\n5. Divide `diff` by `dist` and substract the result of the upper bound by 1.\\n```\\nfunction addRungs(rungs: number[], dist: number): number {\\n    let minimum = 0;\\n    \\n    const temp = rungs;\\n    if (temp[0] > dist) {\\n        minimum += 1;\\n        temp.unshift(dist);\\n    }\\n    \\n    for (let i = 1; i < temp.length; i++) {\\n        const diff = temp[i] - temp[i - 1];\\n        if (diff > dist) {\\n            minimum += Math.ceil(diff / dist) - 1;\\n        }\\n    }\\n    return minimum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction addRungs(rungs: number[], dist: number): number {\\n    let minimum = 0;\\n    \\n    const temp = rungs;\\n    if (temp[0] > dist) {\\n        minimum += 1;\\n        temp.unshift(dist);\\n    }\\n    \\n    for (let i = 1; i < temp.length; i++) {\\n        const diff = temp[i] - temp[i - 1];\\n        if (diff > dist) {\\n            minimum += Math.ceil(diff / dist) - 1;\\n        }\\n    }\\n    return minimum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458114,
                "title": "add-minimum-rungs-c-explained-solution-100-faster-and-100-space-optimised",
                "content": "The question here is quite simple based on basic observations. Lets say we are currently at some **rungs[i]**. If I can jump to next rung without using any extra rung, then just move to the next rung. If not then we would have to add some rungs in between. This could be easily calculated by taking **difference of next rung and current rung and divide it by dist**. Now we would move to **current rung + (number of rungs needed) x dist**. We would apply the same process for all.\\nImplementation goes below :\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(1)\\n\\nCode :\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        ios_base::sync_with_stdio(0);\\n        long long ans = 0,cur_rung = 0,i = 0;\\n        while(i<rungs.size()){\\n            if(cur_rung+dist>=rungs[i]){\\n                cur_rung = rungs[i];\\n                i++;\\n            }\\n            else{\\n                long long diff = ceil((double)(rungs[i]-cur_rung)/dist);\\n                ans+=diff-1;\\n                cur_rung = cur_rung+diff*dist;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/14079515-c2d3-4795-ae46-45162b536314_1661071475.8651202.png)\\n\\n**Do Upvote If Found Helpful !**\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        ios_base::sync_with_stdio(0);\\n        long long ans = 0,cur_rung = 0,i = 0;\\n        while(i<rungs.size()){\\n            if(cur_rung+dist>=rungs[i]){\\n                cur_rung = rungs[i];\\n                i++;\\n            }\\n            else{\\n                long long diff = ceil((double)(rungs[i]-cur_rung)/dist);\\n                ans+=diff-1;\\n                cur_rung = cur_rung+diff*dist;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432237,
                "title": "c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int required=0;\\n        int n=rungs.size();\\n        for(int i=1;i<n;i++){\\n            int diff=rungs[i]-rungs[i-1];\\n            required+=(diff-1)/dist;\\n            \\n        }\\n      \\n        required+=(rungs[0]-1)/dist;\\n        return required;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int required=0;\\n        int n=rungs.size();\\n        for(int i=1;i<n;i++){\\n            int diff=rungs[i]-rungs[i-1];\\n            required+=(diff-1)/dist;\\n            \\n        }\\n      \\n        required+=(rungs[0]-1)/dist;\\n        return required;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400325,
                "title": "divide-gaps-by-dist-and-then-add-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n          int res = (rungs[0] - 1-0) / dist;\\n    for (int i = 1; i < rungs.size(); ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390413,
                "title": "loop-and-count-numbers-needed",
                "content": "```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        int pre=0,count=0;\\n        foreach(var rung in rungs){\\n            count+=(rung-pre-1)/dist;\\n            pre=rung;\\n        }\\n        return count;\\n    }\\n}\\n```\\nO(N)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        int pre=0,count=0;\\n        foreach(var rung in rungs){\\n            count+=(rung-pre-1)/dist;\\n            pre=rung;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304439,
                "title": "intuitive",
                "content": "```\\nclass Solution {\\n    \\n    bool climb(int cur, int next, int dist) {\\n        return next - cur <= dist;\\n    }\\n    \\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cur = 0;\\n        int res = 0;\\n        for (int i = 0, len = rungs.size(); i < len;) {\\n            auto r = rungs[i];\\n            if (climb(cur, r, dist)) {\\n                cur = r;\\n                ++i;\\n            } else {\\n                int diff = (r - cur - 1) / dist;\\n                cur += diff * dist;\\n                res += diff;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool climb(int cur, int next, int dist) {\\n        return next - cur <= dist;\\n    }\\n    \\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cur = 0;\\n        int res = 0;\\n        for (int i = 0, len = rungs.size(); i < len;) {\\n            auto r = rungs[i];\\n            if (climb(cur, r, dist)) {\\n                cur = r;\\n                ++i;\\n            } else {\\n                int diff = (r - cur - 1) / dist;\\n                cur += diff * dist;\\n                res += diff;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294645,
                "title": "python-one-liner-ugly",
                "content": "```\\nclass Solution:\\n    def addRungs(self, arr: List[int], dist: int) -> int:\\n        return sum([ceil((arr[i]-arr[i-1])/dist)-1 if i != 0 else ceil(arr[i]/dist)-1 for i in range(len(arr))])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addRungs(self, arr: List[int], dist: int) -> int:\\n        return sum([ceil((arr[i]-arr[i-1])/dist)-1 if i != 0 else ceil(arr[i]/dist)-1 for i in range(len(arr))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282467,
                "title": "c-solution-greedy",
                "content": "```\\n    int addRungs(vector<int>& nums, int dist) {\\n        int n=nums.size();\\n        int count=0;\\n        if(nums[0]>dist)\\n            count+=(nums[0]/dist)-1+((nums[0]%dist)!=0);\\n        for(int i=0; i<n-1; i++)\\n            if(nums[i+1]-nums[i]>dist)\\n                count+=((nums[i+1]-nums[i])/dist)-1+((nums[i+1]-nums[i])%dist!=0);\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int addRungs(vector<int>& nums, int dist) {\\n        int n=nums.size();\\n        int count=0;\\n        if(nums[0]>dist)\\n            count+=(nums[0]/dist)-1+((nums[0]%dist)!=0);\\n        for(int i=0; i<n-1; i++)\\n            if(nums[i+1]-nums[i]>dist)\\n                count+=((nums[i+1]-nums[i])/dist)-1+((nums[i+1]-nums[i])%dist!=0);\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2275602,
                "title": "swift-solution-100-efficient",
                "content": "```\\nclass Solution {\\n    func addRungs(_ A: [Int], _ dist: Int) -> Int {\\n        var pre = 0, res = 0\\n        for a in A {\\n            res += (a - pre - 1) / dist\\n            pre = a\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func addRungs(_ A: [Int], _ dist: Int) -> Int {\\n        var pre = 0, res = 0\\n        for a in A {\\n            res += (a - pre - 1) / dist\\n            pre = a\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241826,
                "title": "c-faster-than-97",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans = 0;\\n        rungs.insert(rungs.begin(), 0);\\n        for(int i=0; i<rungs.size()-1; ++i) {\\n            if(rungs[i+1] - rungs[i] > dist) {\\n                ans += (rungs[i+1] - rungs[i] - 1) / dist;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans = 0;\\n        rungs.insert(rungs.begin(), 0);\\n        for(int i=0; i<rungs.size()-1; ++i) {\\n            if(rungs[i+1] - rungs[i] > dist) {\\n                ans += (rungs[i+1] - rungs[i] - 1) / dist;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211831,
                "title": "c-solution-only-integer-math",
                "content": "This doesn\\'t seem to be a medium problem.  I\\'d rate it lower.\\n\\n```\\n    public int AddRungs(int[] rungs, int dist) \\n    {\\n        int result = 0;\\n        int previous = 0;\\n        for(int i=0;i<rungs.Length;i++)\\n        {\\n            int delta = rungs[i]-previous;\\n            int x = delta / dist;\\n            if (x*dist!=delta) x++;\\n            //So if this is greater that 1 we need the extra rungs.\\n            result+=x-1;\\n            previous=rungs[i];\\n        }\\n        return result;\\n    }   \\n```",
                "solutionTags": [],
                "code": "```\\n    public int AddRungs(int[] rungs, int dist) \\n    {\\n        int result = 0;\\n        int previous = 0;\\n        for(int i=0;i<rungs.Length;i++)\\n        {\\n            int delta = rungs[i]-previous;\\n            int x = delta / dist;\\n            if (x*dist!=delta) x++;\\n            //So if this is greater that 1 we need the extra rungs.\\n            result+=x-1;\\n            previous=rungs[i];\\n        }\\n        return result;\\n    }   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192323,
                "title": "python-greedy-5-liner",
                "content": "```\\nclass Solution:\\n    def addRungs(self, x: List[int], dist: int) -> int:\\n        q=ans=0\\n        for i in x:\\n            ans+=(i-q-1)//dist\\n            q=i\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addRungs(self, x: List[int], dist: int) -> int:\\n        q=ans=0\\n        for i in x:\\n            ans+=(i-q-1)//dist\\n            q=i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182195,
                "title": "c-5-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int answer = 0, prev = 0;\\n        \\n        for(int i=0;i<rungs.size();i++){\\n            answer += ceil((rungs[i]-prev) / (double)dist) - 1;\\n            prev = rungs[i];\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int answer = 0, prev = 0;\\n        \\n        for(int i=0;i<rungs.size();i++){\\n            answer += ceil((rungs[i]-prev) / (double)dist) - 1;\\n            prev = rungs[i];\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158457,
                "title": "o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int s=0,ans=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            if(s+dist<rungs[i])\\n            {\\n                ans+=ceil((double)(rungs[i]-s)/dist)-1;\\n            }\\n            s=rungs[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int s=0,ans=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            if(s+dist<rungs[i])\\n            {\\n                ans+=ceil((double)(rungs[i]-s)/dist)-1;\\n            }\\n            s=rungs[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156701,
                "title": "c-short-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, i=0, curr=0;\\n        while(i<rungs.size()){\\n            res += (rungs[i] - curr-1)/dist;\\n            curr = rungs[i];\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, i=0, curr=0;\\n        while(i<rungs.size()){\\n            res += (rungs[i] - curr-1)/dist;\\n            curr = rungs[i];\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139545,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int extras=0;\\n        int curr=0;\\n        int i=0;\\n        while(i<rungs.size())\\n        {\\n            if(curr + dist>= rungs[i])\\n            {\\n                curr=rungs[i];\\n                i++;\\n            }\\n            else\\n            {\\n                int multi=(rungs[i]-curr)/dist;\\n                if((rungs[i]-curr)%dist==0)\\n                {\\n                    curr=rungs[i];\\n                    i++;\\n                    extras+= multi-1;\\n                }\\n                else\\n                {\\n                    extras+= multi;\\n                    curr +=multi*dist;\\n                }\\n                \\n            }\\n        }\\n        return extras;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int extras=0;\\n        int curr=0;\\n        int i=0;\\n        while(i<rungs.size())\\n        {\\n            if(curr + dist>= rungs[i])\\n            {\\n                curr=rungs[i];\\n                i++;\\n            }\\n            else\\n            {\\n                int multi=(rungs[i]-curr)/dist;\\n                if((rungs[i]-curr)%dist==0)\\n                {\\n                    curr=rungs[i];\\n                    i++;\\n                    extras+= multi-1;\\n                }\\n                else\\n                {\\n                    extras+= multi;\\n                    curr +=multi*dist;\\n                }\\n                \\n            }\\n        }\\n        return extras;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120961,
                "title": "c-solution-linear-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count = 0;\\n        for(int i = 1; i < rungs.size(); ++i){\\n            if(rungs[i] - rungs[i - 1] > dist)\\n                count += (rungs[i] - 1 - rungs[i - 1]) / dist;\\n        }\\n        if(rungs[0] > dist)\\n            count += (rungs[0] - 1) / dist;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count = 0;\\n        for(int i = 1; i < rungs.size(); ++i){\\n            if(rungs[i] - rungs[i - 1] > dist)\\n                count += (rungs[i] - 1 - rungs[i - 1]) / dist;\\n        }\\n        if(rungs[0] > dist)\\n            count += (rungs[0] - 1) / dist;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079747,
                "title": "greedy",
                "content": "```\\nint addRungs(vector<int> & r, int d)\\n{\\n\\tint out{(r[0]-1)/d};\\n\\tfor(int i{1}; i<size(r); out += (r[i]-r[i-1]-1)/d, ++i);\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint addRungs(vector<int> & r, int d)\\n{\\n\\tint out{(r[0]-1)/d};\\n\\tfor(int i{1}; i<size(r); out += (r[i]-r[i-1]-1)/d, ++i);\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2079134,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;int s=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n          if(rungs[i]-c>dist)\\n          {\\n              int d=rungs[i]-c-1;\\n              s+=d/dist;\\n              \\n          }\\n            c=rungs[i];\\n        }\\n        return s;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;int s=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n          if(rungs[i]-c>dist)\\n          {\\n              int d=rungs[i]-c-1;\\n              s+=d/dist;\\n              \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2016970,
                "title": "easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count =0;\\n        int m =0;\\n        for(int i =0;i<rungs.size();i++){\\n            if(rungs[i]-m> dist){\\n                \\n                count += ((rungs[i]-m)/dist);\\n                if((rungs[i]-m)%dist==0){\\n                    count--;\\n                }\\n            }\\n                         m = rungs[i];\\n\\n        }\\n        return count ;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count =0;\\n        int m =0;\\n        for(int i =0;i<rungs.size();i++){\\n            if(rungs[i]-m> dist){\\n                \\n                count += ((rungs[i]-m)/dist);\\n                if((rungs[i]-m)%dist==0){\\n                    count--;\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1906337,
                "content": [
                    {
                        "username": "zalars",
                        "content": "This task is very easy even for me (I\\'m a beginner in algorithms) - why medium?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Points with Cost",
        "question_content": "<p>You are given an <code>m x n</code> integer matrix <code>points</code> (<strong>0-indexed</strong>). Starting with <code>0</code> points, you want to <strong>maximize</strong> the number of points you can get from the matrix.</p>\n\n<p>To gain points, you must pick one cell in <strong>each row</strong>. Picking the cell at coordinates <code>(r, c)</code> will <strong>add</strong> <code>points[r][c]</code> to your score.</p>\n\n<p>However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows <code>r</code> and <code>r + 1</code> (where <code>0 &lt;= r &lt; m - 1</code>), picking cells at coordinates <code>(r, c<sub>1</sub>)</code> and <code>(r + 1, c<sub>2</sub>)</code> will <strong>subtract</strong> <code>abs(c<sub>1</sub> - c<sub>2</sub>)</code> from your score.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of points you can achieve</em>.</p>\n\n<p><code>abs(x)</code> is defined as:</p>\n\n<ul>\n\t<li><code>x</code> for <code>x &gt;= 0</code>.</li>\n\t<li><code>-x</code> for <code>x &lt; 0</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong><strong> </strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,2,3],[1,5,1],[3,1,1]]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong>\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).\nYou add 3 + 5 + 3 = 11 to your score.\nHowever, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.\nYour final score is 11 - 2 = 9.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png\" style=\"width: 200px; height: 299px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,5],[2,3],[4,2]]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong>\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).\nYou add 5 + 3 + 4 = 12 to your score.\nHowever, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.\nYour final score is 12 - 1 = 11.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == points.length</code></li>\n\t<li><code>n == points[r].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= points[r][c] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1344908,
                "title": "c-java-python-3-dp-explanation-with-pictures-o-mn-time-o-n-space",
                "content": "Let\\'s say that we start from the top row to the bottom row and pick one number in each row, as requested.\\nSuppose we have result array from some previous rows (For example, first **X** rows) as **prev**. Here, **prev[i]** is the total points we have if we pick the **i-th** number in the **X**-th row. \\n\\n![image](https://assets.leetcode.com/users/images/8cbe8fdc-55c6-4629-9d76-acb88de4aac5_1651327285.2736592.png)\\n\\n\\n\\n\\nNow we have the **X+1**-th row (points[X + 1]) to pick, what is the result array **curr** for this row according to the previous result array **prev**?\\nAt a first glance, for the index **i** in **curr**, we have:\\n**curr[i] = max(prev[j] - abs(j - i) for j in range(n)) + points[X+1][i]**, but we don\\'t want to literally compare every index in **prev** with every index **i** in **points[X+1]**, which brings O(N ^ 2) time for a single row and O(N ^ 3) for the whole grids.\\n\\n![image](https://assets.leetcode.com/users/images/1f076567-5fbc-4203-af98-1d463e4722ee_1651327294.0604868.png)\\n\\n\\n\\nNotice that, for a certain index **i**, the maximum value for **i** is a index that could either come from its left, or its right(inclusive). Thus we can build two arrays, **lft** and **rgt**, and focus on the maximum value only coming from its left or right. Finding the best fit for a single index **i** could just cost O(1) time from then on.\\n\\n![image](https://assets.leetcode.com/users/images/19088d33-9447-4727-8728-514f0c7f041f_1651327304.4782481.png)\\n\\n\\n\\n\\nTake a look at how we build **lft**.\\nApparently, **lft[0]** is just **prev[0]**, since there is no other values coming from its left.\\n\\n![image](https://assets.leetcode.com/users/images/a86e7828-0495-4ab7-a753-f3a0819fe642_1651327321.5416875.png)\\n\\n\\n\\nFor **lft[1]**, we need to make a choice, the value is the larger one between **prev[1]** or **lft[0] - 1**, (considering the index shift so we need to substract **1** from **lft[0]**).\\n\\n![image](https://assets.leetcode.com/users/images/dee3e134-d5fc-4140-a4d4-43dfd0d0785a_1651327334.5943615.png)\\n\\n\\n\\nFor **lft[2]**, the value is the larger one between **prev[2]** or **lft[1] - 1**, so on so forth.\\n\\n![image](https://assets.leetcode.com/users/images/2922aa49-05e2-4618-817d-34617be30389_1651327340.3885162.png)\\n\\n\\n\\n\\n\\n\\n> **Wait a second...**\\n> **Why we just compare prev[2] and lft[1] - 1, why its not necessary to compare lft[0] - 2 as well?**\\n\\nAssume we do compare: **lft[1] - 1** and **lft[0] - 2**, that is, to get `max(lft[2], lft[1] - 1, lft[0] - 2)`\\nAdd **1** to last two terms and we have: **lft[1]**, **lft[0] - 1**.\\nLooks familiar? That is exactly the previous comparison we made for ```index=1```, we have already selected the maximum value in the selection on the previous index and saved it in **curr[1]**, shifting all previous candidates by 1 doesn\\'t change the result. We can just safetly use the larger result from the previous index.\\n\\n\\nBuild **rgt** using the same method.\\n\\n![image](https://assets.leetcode.com/users/images/217aa899-811d-44be-8d85-316e84d23be3_1651327348.3117893.png)\\n\\n\\n\\nNow for each index **i** in **points[X+1]**, all we need to do is get the larger value from **lft[i], rgt[i]**, plus **points[X+1][i]**, and that is the maximum value **curr[i]** for this current row. Aftering filling **curr**, we could move on to the next row by taking **curr** as **prev**. Therefore, for each new row, we repeatedly get **lft, rgt** from **prev**, get **curr** from **points[X], lft, rgt**, until we reach the last row.\\n\\n![image](https://assets.leetcode.com/users/images/cbac3d46-47f2-4541-a595-e27b3bf6bf8f_1651327356.6044252.png)\\n\\n\\n\\n\\n```\\ndef maxPoints(self, P: List[List[int]]) -> int:\\n        m, n = len(P), len(P[0])\\n        if m == 1: return max(P[0])\\n        if n == 1: return sum(sum(x) for x in P)\\n        \\n        def left(arr):\\n            lft = [arr[0]] + [0] * (n - 1)\\n            for i in range(1, n): lft[i] = max(lft[i - 1] - 1, arr[i])\\n            return lft\\n        \\n        def right(arr):\\n            rgt = [0] * (n - 1) + [arr[-1]]\\n            for i in range(n - 2, -1, -1): rgt[i] = max(rgt[i + 1] - 1, arr[i])\\n            return rgt\\n        \\n        pre = P[0]\\n        for i in range(m - 1):\\n            lft, rgt, cur = left(pre), right(pre), [0] * n\\n            for j in range(n):\\n                cur[j] = P[i + 1][j] + max(lft[j], rgt[j])\\n            pre = cur[:]\\n\\n        return max(pre)\\n```\\n\\nC++\\n```\\nlong long maxPoints(vector<vector<int>>& P) {\\n        long long m = P.size(), n = P[0].size();\\n        vector<long long> pre(n);\\n        for (int i = 0; i < n; ++i) pre[i] = P[0][i];\\n        for (int i = 0; i < m - 1; ++i){\\n            vector<long long> lft(n, 0), rgt(n, 0), cur(n, 0);\\n            lft[0] = pre[0];\\n            rgt[n - 1] = pre[n - 1];\\n            for (int j = 1; j < n; ++j){\\n                lft[j] = max(lft[j - 1] - 1, pre[j]);\\n            }\\n            for (int j = n - 2; j >= 0; --j){\\n                rgt[j] = max(rgt[j + 1] - 1, pre[j]);\\n            }\\n            for (int j = 0; j < n; ++j){\\n                cur[j] = P[i + 1][j] + max(lft[j], rgt[j]);\\n            }\\n            pre = cur;\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < n; ++i)\\n            ans = max(ans, pre[i]);\\n        return ans;\\n    }\\n```\\nJava\\n```\\npublic long maxPoints(int[][] P) {\\n        int m = P.length, n = P[0].length;\\n        long[] pre = new long[n];\\n        for (int i = 0; i < n; ++i) pre[i] = P[0][i];\\n        for (int i = 0; i < m - 1; ++i){\\n            long[] lft = new long[n], rgt = new long[n], cur = new long[n];\\n            lft[0] = pre[0];\\n            rgt[n - 1] = pre[n - 1];\\n            for (int j = 1; j < n; ++j)\\n                lft[j] = Math.max(lft[j - 1] - 1, pre[j]);\\n            for (int j = n - 2; j >= 0; --j)\\n                rgt[j] = Math.max(rgt[j + 1] - 1, pre[j]);\\n            for (int j = 0; j < n; ++j)\\n                cur[j] = P[i + 1][j] + Math.max(lft[j], rgt[j]);\\n            pre = cur;\\n        }\\n        long ans = 0;\\n        for (int i = 0; i < n; ++i)\\n            ans = Math.max(ans, pre[i]);\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```index=1```\n```\\ndef maxPoints(self, P: List[List[int]]) -> int:\\n        m, n = len(P), len(P[0])\\n        if m == 1: return max(P[0])\\n        if n == 1: return sum(sum(x) for x in P)\\n        \\n        def left(arr):\\n            lft = [arr[0]] + [0] * (n - 1)\\n            for i in range(1, n): lft[i] = max(lft[i - 1] - 1, arr[i])\\n            return lft\\n        \\n        def right(arr):\\n            rgt = [0] * (n - 1) + [arr[-1]]\\n            for i in range(n - 2, -1, -1): rgt[i] = max(rgt[i + 1] - 1, arr[i])\\n            return rgt\\n        \\n        pre = P[0]\\n        for i in range(m - 1):\\n            lft, rgt, cur = left(pre), right(pre), [0] * n\\n            for j in range(n):\\n                cur[j] = P[i + 1][j] + max(lft[j], rgt[j])\\n            pre = cur[:]\\n\\n        return max(pre)\\n```\n```\\nlong long maxPoints(vector<vector<int>>& P) {\\n        long long m = P.size(), n = P[0].size();\\n        vector<long long> pre(n);\\n        for (int i = 0; i < n; ++i) pre[i] = P[0][i];\\n        for (int i = 0; i < m - 1; ++i){\\n            vector<long long> lft(n, 0), rgt(n, 0), cur(n, 0);\\n            lft[0] = pre[0];\\n            rgt[n - 1] = pre[n - 1];\\n            for (int j = 1; j < n; ++j){\\n                lft[j] = max(lft[j - 1] - 1, pre[j]);\\n            }\\n            for (int j = n - 2; j >= 0; --j){\\n                rgt[j] = max(rgt[j + 1] - 1, pre[j]);\\n            }\\n            for (int j = 0; j < n; ++j){\\n                cur[j] = P[i + 1][j] + max(lft[j], rgt[j]);\\n            }\\n            pre = cur;\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < n; ++i)\\n            ans = max(ans, pre[i]);\\n        return ans;\\n    }\\n```\n```\\npublic long maxPoints(int[][] P) {\\n        int m = P.length, n = P[0].length;\\n        long[] pre = new long[n];\\n        for (int i = 0; i < n; ++i) pre[i] = P[0][i];\\n        for (int i = 0; i < m - 1; ++i){\\n            long[] lft = new long[n], rgt = new long[n], cur = new long[n];\\n            lft[0] = pre[0];\\n            rgt[n - 1] = pre[n - 1];\\n            for (int j = 1; j < n; ++j)\\n                lft[j] = Math.max(lft[j - 1] - 1, pre[j]);\\n            for (int j = n - 2; j >= 0; --j)\\n                rgt[j] = Math.max(rgt[j + 1] - 1, pre[j]);\\n            for (int j = 0; j < n; ++j)\\n                cur[j] = P[i + 1][j] + Math.max(lft[j], rgt[j]);\\n            pre = cur;\\n        }\\n        long ans = 0;\\n        for (int i = 0; i < n; ++i)\\n            ans = Math.max(ans, pre[i]);\\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344888,
                "title": "c-dp-from-o-m-n-n-to-o-m-n",
                "content": "The initial thought of this problem is dynamic programing. It can be defined simply in the following method.\\n\\n```cpp\\ndp[i][j] = max(dp[i - 1][k] + point[i][j] - abs(j - k)) for each 0 <= k < points[i - 1].szie()\\n```\\n\\ndp[i][j] means the maximum points in row i and col j. The value is from previous row with costs abs(j - k).\\n\\n This recurrence relation is from the definition of problem. Using this recurrence relation we can write code like this.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        vector<vector<long long>> dp(points.size(), vector<long long>(points[0].size(), -1));\\n        \\n        for (int i = 0; i < points[0].size(); ++i) {\\n            dp[0][i] = points[0][i];\\n        }\\n        \\n        for (int i = 1; i < points.size(); ++i) {\\n            for (int j = 0; j < points[i].size(); ++j) {\\n                for (int k = 0; k < points[i].size(); ++k) {\\n                    dp[i][j] = max(dp[i][j], dp[i - 1][k] - abs(k - j) + points[i][j]);\\n                }\\n            }\\n        }\\n        \\n        long long max_ans = -1;\\n        for (const auto v : dp.back()) {\\n            max_ans = max(max_ans, v);\\n        }\\n        \\n        return max_ans;\\n    }\\n};\\n```\\n\\nIt produces the time complexity O(m * n * n) also it will gain TLE in the end.\\n\\nTo further reduce the time complexity, I found that there is some similar calculation when we are trying to find the max. That is dp[i - 1][k] - k (or + k depends on the position). To reduce to the smaller problem, we assume that all the max value is from the left side of the current position. With this assumption, the abs(k - j) can be changed to j - k. Due to other values (e.g. points[i][j]) are fixed. The problem becomes to find the max dp[i - 1][k] + k in the left. That is\\n\\n```cpp\\ndp[i][j] = max(dp[i - 1][k] + k) + points[i][j] - j for all 0 <= k <= j\\n```\\n\\nYou may notice that some of the sign is reversed, that is because of we need to subtract the cost.\\n\\nNow, the right side is similar. If we assume max value is from the right side. The relation will be:\\n\\n```cpp\\ndp[i][j] = max(dp[i - 1][k] - k) + points[i][j] + j for all j <= k <= points[i].size() - 1\\n```\\n\\nThe actual answer will be either from the left side or right side.\\n\\nFrom the observation, the code can be modified to\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        vector<vector<long long>> dp(points.size(), vector<long long>(points[0].size(), -1));\\n        \\n        for (int i = 0; i < points[0].size(); ++i) {\\n            dp[0][i] = points[0][i];\\n        }\\n        \\n        for (int i = 1; i < points.size(); ++i) {\\n            vector<long long> left_dp(points[i].size(), -1);\\n            vector<long long> right_dp(points[i].size(), -1);\\n            \\n            left_dp[0] = dp[i - 1][0];\\n            for (int k = 1; k < points[i].size(); ++k) {\\n                left_dp[k] = max(left_dp[k - 1], dp[i - 1][k] + k);\\n            }\\n            \\n            right_dp.back() = dp[i - 1].back() - points[i].size() + 1;\\n            for (int k = points[i].size() - 2; k >= 0; --k) {\\n                right_dp[k] = max(right_dp[k + 1], dp[i - 1][k] - k);\\n            }\\n            \\n            for (int j = 0; j < points[i].size(); ++j) {\\n                dp[i][j] = max(left_dp[j] - j, right_dp[j] + j) + points[i][j];\\n            }\\n        }\\n        \\n        long long max_ans = -1;\\n        for (const auto v : dp.back()) {\\n            max_ans = max(max_ans, v);\\n        }\\n        \\n        return max_ans;\\n    }\\n};\\n```\\n\\nWhich then produces the time complexity O(m * n)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\ndp[i][j] = max(dp[i - 1][k] + point[i][j] - abs(j - k)) for each 0 <= k < points[i - 1].szie()\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        vector<vector<long long>> dp(points.size(), vector<long long>(points[0].size(), -1));\\n        \\n        for (int i = 0; i < points[0].size(); ++i) {\\n            dp[0][i] = points[0][i];\\n        }\\n        \\n        for (int i = 1; i < points.size(); ++i) {\\n            for (int j = 0; j < points[i].size(); ++j) {\\n                for (int k = 0; k < points[i].size(); ++k) {\\n                    dp[i][j] = max(dp[i][j], dp[i - 1][k] - abs(k - j) + points[i][j]);\\n                }\\n            }\\n        }\\n        \\n        long long max_ans = -1;\\n        for (const auto v : dp.back()) {\\n            max_ans = max(max_ans, v);\\n        }\\n        \\n        return max_ans;\\n    }\\n};\\n```\n```cpp\\ndp[i][j] = max(dp[i - 1][k] + k) + points[i][j] - j for all 0 <= k <= j\\n```\n```cpp\\ndp[i][j] = max(dp[i - 1][k] - k) + points[i][j] + j for all j <= k <= points[i].size() - 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        vector<vector<long long>> dp(points.size(), vector<long long>(points[0].size(), -1));\\n        \\n        for (int i = 0; i < points[0].size(); ++i) {\\n            dp[0][i] = points[0][i];\\n        }\\n        \\n        for (int i = 1; i < points.size(); ++i) {\\n            vector<long long> left_dp(points[i].size(), -1);\\n            vector<long long> right_dp(points[i].size(), -1);\\n            \\n            left_dp[0] = dp[i - 1][0];\\n            for (int k = 1; k < points[i].size(); ++k) {\\n                left_dp[k] = max(left_dp[k - 1], dp[i - 1][k] + k);\\n            }\\n            \\n            right_dp.back() = dp[i - 1].back() - points[i].size() + 1;\\n            for (int k = points[i].size() - 2; k >= 0; --k) {\\n                right_dp[k] = max(right_dp[k + 1], dp[i - 1][k] - k);\\n            }\\n            \\n            for (int j = 0; j < points[i].size(); ++j) {\\n                dp[i][j] = max(left_dp[j] - j, right_dp[j] + j) + points[i][j];\\n            }\\n        }\\n        \\n        long long max_ans = -1;\\n        for (const auto v : dp.back()) {\\n            max_ans = max(max_ans, v);\\n        }\\n        \\n        return max_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344893,
                "title": "similar-to-931-minimum-falling-path-sum",
                "content": "This is similar to [931. Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum/).\\n\\nThe difference is that, instead of checking 3 items above (\\u2B06, \\u2196 and \\u2197), we need to check the entire row. If we do just that, the complexity will be O(m * n * n) and we will get TLE.\\n\\n> Also note that the path sum can overflow, so we cannot use the input grid directly.\\n\\nTo make it efficient, we first go left-to-right, and track the running maximum value (`run_max`). For each step, we decrement it to account for the distance, and compare with the value right above. Then, we do the same right-to-left, and add the maximum of two running values to each cell.\\n\\n**C++**\\n```cpp\\nlong long maxPoints(vector<vector<int>>& p) {\\n    vector<long long> cur_row(p[0].size()), prev_row(p[0].size());\\n    for (auto &row : p) {\\n        for (long long j = 0, run_max = 0; j < row.size(); ++j) {\\n            run_max = max(run_max - 1, prev_row[j]);\\n            cur_row[j] = run_max;\\n        }\\n        for (long long j = row.size() - 1, run_max = 0; j >= 0; --j) {\\n            run_max = max(run_max - 1, prev_row[j]);\\n            cur_row[j] = max(cur_row[j], run_max) + row[j];\\n        }\\n        swap(cur_row, prev_row);\\n    }\\n    return *max_element(begin(prev_row), end(prev_row));\\n}\\n```\\n**Java**\\n```java\\npublic long maxPoints(int[][] p) {\\n    long[] cur_row = new long[p[0].length], prev_row = new long[p[0].length];\\n    for (var row : p) {\\n        long run_max = 0;\\n        for (int j = 0; j < row.length; ++j) {\\n            run_max = Math.max(run_max - 1, prev_row[j]);\\n            cur_row[j] = run_max;\\n        }\\n        for (int j = row.length - 1; j >= 0; --j) {\\n            run_max = Math.max(run_max - 1, prev_row[j]);\\n            cur_row[j] = Math.max(cur_row[j], run_max) + row[j];\\n        }\\n        prev_row = cur_row;\\n    }\\n    return Arrays.stream(prev_row).max().getAsLong();\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(m * n)\\n- Memory: O(n)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nlong long maxPoints(vector<vector<int>>& p) {\\n    vector<long long> cur_row(p[0].size()), prev_row(p[0].size());\\n    for (auto &row : p) {\\n        for (long long j = 0, run_max = 0; j < row.size(); ++j) {\\n            run_max = max(run_max - 1, prev_row[j]);\\n            cur_row[j] = run_max;\\n        }\\n        for (long long j = row.size() - 1, run_max = 0; j >= 0; --j) {\\n            run_max = max(run_max - 1, prev_row[j]);\\n            cur_row[j] = max(cur_row[j], run_max) + row[j];\\n        }\\n        swap(cur_row, prev_row);\\n    }\\n    return *max_element(begin(prev_row), end(prev_row));\\n}\\n```\n```java\\npublic long maxPoints(int[][] p) {\\n    long[] cur_row = new long[p[0].length], prev_row = new long[p[0].length];\\n    for (var row : p) {\\n        long run_max = 0;\\n        for (int j = 0; j < row.length; ++j) {\\n            run_max = Math.max(run_max - 1, prev_row[j]);\\n            cur_row[j] = run_max;\\n        }\\n        for (int j = row.length - 1; j >= 0; --j) {\\n            run_max = Math.max(run_max - 1, prev_row[j]);\\n            cur_row[j] = Math.max(cur_row[j], run_max) + row[j];\\n        }\\n        prev_row = cur_row;\\n    }\\n    return Arrays.stream(prev_row).max().getAsLong();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344870,
                "title": "java-dp",
                "content": "```\\npublic long maxPoints(int[][] points) {\\n        long ans = 0;\\n        int m = points.length, n = points[0].length;\\n        long []dp = new long[n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[j] += points[i][j];\\n            }\\n            for(int j=1;j<n;j++){\\n                dp[j] = Math.max(dp[j], dp[j-1] - 1);\\n            }\\n            for(int j=n-2;j>=0;j--){\\n                dp[j] = Math.max(dp[j], dp[j+1] - 1);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            ans = Math.max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic long maxPoints(int[][] points) {\\n        long ans = 0;\\n        int m = points.length, n = points[0].length;\\n        long []dp = new long[n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[j] += points[i][j];\\n            }\\n            for(int j=1;j<n;j++){\\n                dp[j] = Math.max(dp[j], dp[j-1] - 1);\\n            }\\n            for(int j=n-2;j>=0;j--){\\n                dp[j] = Math.max(dp[j], dp[j+1] - 1);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            ans = Math.max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345059,
                "title": "python-dp-like-solution",
                "content": "# **Explanation**\\nSimilar to [1014. Best Sightseeing Pair](https://leetcode.com/problems/best-sightseeing-pair/discuss/260850/JavaC%2B%2BPython-One-Pass-O(1)-space)\\n<br>\\n\\n# **Complexity**\\nTime `O(mn)`\\nSpace `O(n)` for dp each row\\nSpace `O(1)` if use input\\n<br>\\n\\n**Python**\\n```py\\n    def maxPoints(self, A):\\n        m, n = len(A), len(A[0])\\n        for i in xrange(m - 1):\\n            for j in xrange(n - 2, -1, -1):\\n                A[i][j] = max(A[i][j], A[i][j + 1] - 1)\\n            for j in xrange(n):\\n                A[i][j] = max(A[i][j], A[i][j - 1] - 1 if j else 0)\\n                A[i + 1][j] += A[i][j]\\n        return max(A[-1])\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def maxPoints(self, A):\\n        m, n = len(A), len(A[0])\\n        for i in xrange(m - 1):\\n            for j in xrange(n - 2, -1, -1):\\n                A[i][j] = max(A[i][j], A[i][j + 1] - 1)\\n            for j in xrange(n):\\n                A[i][j] = max(A[i][j], A[i][j - 1] - 1 if j else 0)\\n                A[i + 1][j] += A[i][j]\\n        return max(A[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344898,
                "title": "python-very-short-dp-solution-explained",
                "content": "The idea is to us dynamic programming, but we need to update each next row, using previous in linear time, we can not allow slower given problem constraints. Imagine, that we have row\\n\\n`A0, A1, A2, A3, A4, A5`.\\n\\nAnd we want to calcualte answers for the new row. For the first element we need to calculate:\\n`max(A0, A1-1, A2-2, A3-3, A4-4, A5-5)`, for the second element\\n`max(A0-1, A1, A2-1, A3-2, A4-3, A5-4)`,\\n`max(A0-2, A1-1, A2, A3-1, A4-2, A5-3)` and so on.\\n\\nThe trick is to find all this values using some preprocessing. Look at the value  `max(A0-2, A1-1, A2, A3-1, A4-2, A5-3)`, it can be written as `max(max([A0+0, A1+1, A2+2] - 2), max([A2-2, A3-3, A4-4, A5-5]) + 2)`. And in fact all values can be written in similar way. What we need to do now is to calculate cumulative maximums ans we are done!\\n\\n#### Complexity\\nTime complexity is `O(mn)`, space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxPoints(self, P):\\n        m, n = len(P), len(P[0])\\n        dp = P[0]\\n        for i in range(1, m):\\n            c1 = list(accumulate([a+b for a,b in zip(dp, range(n))], max))\\n            c2 = list(accumulate([a-b for a,b in zip(dp[::-1], range(n-1,-1,-1))], max))\\n            dp2 = [max(c1[i] - i, c2[n-1-i] + i) for i in range(n)]\\n            dp = [x+y for x,y in zip(dp2, P[i])]\\n        return max(dp)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxPoints(self, P):\\n        m, n = len(P), len(P[0])\\n        dp = P[0]\\n        for i in range(1, m):\\n            c1 = list(accumulate([a+b for a,b in zip(dp, range(n))], max))\\n            c2 = list(accumulate([a-b for a,b in zip(dp[::-1], range(n-1,-1,-1))], max))\\n            dp2 = [max(c1[i] - i, c2[n-1-i] + i) for i in range(n)]\\n            dp = [x+y for x,y in zip(dp2, P[i])]\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345593,
                "title": "c-o-n-m-m-and-o-n-m-dp-with-explanation",
                "content": "## **O(n\\\\*m\\\\*m) DP**\\n\\nThis approach is pretty straightforward. It follows a max path sum sort of approach. \\n\\n`dp[r][c] represents the max path to reach at (r,c)`\\n\\ndp[0] is initialised with values from points[0].\\nFor every other row, for each column we find which is the most optimal element in the previous row, from where we should arrive at the current element.\\n\\n**Psuedo code:**\\n\\n\\n```\\ndp[0] = points[0]\\nfor r in range(1,n):\\n\\tfor c in range(m):\\n\\t\\tbest = 0\\n\\t\\tfor j in range(m):\\n\\t\\t\\tbest = max(best, dp[r-1][j] + abs(c-j))\\n\\t\\tdp[r][c] = points[r][c] + best\\t\\n```\\n\\nThe answer would be the max element in the last row \\n<br />\\n\\n## **O(n\\\\*m) dp**\\n\\nFor a given (r,c), it\\'s partner in the previous row would be (r-1,j) where `dp[r-1][j] + abs(c-j)` is maximum.\\n\\nif c >= j:\\n\\n```\\ndp[r][c] = points[r][c] + dp[r-1][j] + abs(c-j)\\n\\t\\t = points[r][c] + dp[r-1][j] + c-j\\n\\t\\t = (points[r][c] + c) + (dp[r-1][j] - j)\\n```\\n\\nFor a given (r,c), points\\\\[r][c] + c is fixed, ie we have to `maximise dp[r-1][j] - j on the when c >= j` \\n\\nif c <= j:\\n\\n```\\ndp[r][c] = points[r][c] + dp[r-1][j] + abs(c-j)\\n\\t\\t = points[r][c] + dp[r-1][j] + j - c\\n\\t\\t = (points[r][c] - c) + (dp[r-1][j] + j)\\n```\\n\\nFor a given (r,c), points\\\\[r][c] - c is fixed, ie we have to `maximise dp[r-1][j] + j on the when c <= j`\\n\\nlet left[c] denote maximum dp\\\\[r-1][j] + j for j <= c\\nand right[c] denote maximum dp\\\\[r-1][j] - j for j >= c\\n\\nUsing these two we can get `dp[r][c] = points[r][c] + max(left[c] - c, right[c] + c)`\\n\\n```\\n#define ll long long\\n#define vi vector<ll>\\n\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<vector<ll>> dp(n, vector<ll>(m));\\n        \\n        for(int c = 0 ; c < m ; c++) {\\n            dp[0][c] = points[0][c];\\n        }\\n        \\n        for(int r = 1 ; r < n ; r++) {\\n            vector<ll> left(m), right(m);\\n            \\n            left[0] = dp[r-1][0];\\n            for(int c = 1 ; c < m ; c++) {\\n                left[c] = max(left[c-1], dp[r-1][c] + c);\\n            }\\n            \\n            right[m-1] = dp[r-1][m-1] - (m-1);\\n            for(int c = m-2 ; c >= 0 ; c--) {\\n                right[c] = max(right[c+1], dp[r-1][c] - c);\\n            }\\n            \\n            for(int c = 0 ; c < m ; c++) {\\n                dp[r][c] = points[r][c] + max(left[c] - c, right[c] + c);\\n            }\\n        }\\n                \\n        return *max_element(dp[n-1].begin(), dp[n-1].end());\\n    }\\n};\\n```\\n\\n**Note:** The second approach can be easily converted to O(m) space but i let it be O(n\\\\*m) space for readability sake",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[0] = points[0]\\nfor r in range(1,n):\\n\\tfor c in range(m):\\n\\t\\tbest = 0\\n\\t\\tfor j in range(m):\\n\\t\\t\\tbest = max(best, dp[r-1][j] + abs(c-j))\\n\\t\\tdp[r][c] = points[r][c] + best\\t\\n```\n```\\ndp[r][c] = points[r][c] + dp[r-1][j] + abs(c-j)\\n\\t\\t = points[r][c] + dp[r-1][j] + c-j\\n\\t\\t = (points[r][c] + c) + (dp[r-1][j] - j)\\n```\n```\\ndp[r][c] = points[r][c] + dp[r-1][j] + abs(c-j)\\n\\t\\t = points[r][c] + dp[r-1][j] + j - c\\n\\t\\t = (points[r][c] - c) + (dp[r-1][j] + j)\\n```\n```\\n#define ll long long\\n#define vi vector<ll>\\n\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<vector<ll>> dp(n, vector<ll>(m));\\n        \\n        for(int c = 0 ; c < m ; c++) {\\n            dp[0][c] = points[0][c];\\n        }\\n        \\n        for(int r = 1 ; r < n ; r++) {\\n            vector<ll> left(m), right(m);\\n            \\n            left[0] = dp[r-1][0];\\n            for(int c = 1 ; c < m ; c++) {\\n                left[c] = max(left[c-1], dp[r-1][c] + c);\\n            }\\n            \\n            right[m-1] = dp[r-1][m-1] - (m-1);\\n            for(int c = m-2 ; c >= 0 ; c--) {\\n                right[c] = max(right[c+1], dp[r-1][c] - c);\\n            }\\n            \\n            for(int c = 0 ; c < m ; c++) {\\n                dp[r][c] = points[r][c] + max(left[c] - c, right[c] + c);\\n            }\\n        }\\n                \\n        return *max_element(dp[n-1].begin(), dp[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680374,
                "title": "clean-python-solution-explained-dp-thinking-process",
                "content": "```python\\n\"\"\"\\ndp[i][j] := considering from points[0]~points[i], the max points if choosing points[i][j]\\n\"\"\"\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        N = len(points)\\n        M = len(points[0])\\n        dp = [[0]*M for _ in xrange(N)]\\n        \\n        for i in xrange(N):\\n            for j in xrange(M):\\n                if i==0:\\n                    dp[i][j] = points[i][j]\\n                else:\\n                    dp[i][j] = points[i][j]+max([dp[i-1][k] - abs(k-j) for k in xrange(M)])\\n        return max(dp[N-1])\\n\\n    \\n\"\"\"\\nThe above solution will take O(NM^2) in time.\\nThe bottle neck is for each j we need to traverse the whole last row.\\nLet us see a little bit closer on `dp[i][j]`\\n\\ndp[i][j] = points[i][j]+max([dp[i-1][k] - abs(k-j) for k in xrange(M)])\\n\\nSo, if j>=k (Part 1)\\npoints[i][j]+max([dp[i-1][k] - (j-k) for k in xrange(M)])\\npoints[i][j] - j + max([dp[i-1][k] + k) for k in xrange(M)])\\n\\nif k>=j (Part 2)\\npoints[i][j] + max([dp[i-1][k] - (k-j) for k in xrange(M)])\\npoints[i][j] + j + max([dp[i-1][k] - k) for k in xrange(M)])\\n\\nSince we cannot do a full scan\\nwhy not we update the value from left to right for Part 1 and\\nright to left for part 2\\nWith a variable call rollingMax to store the max.\\n\\nThat way dp[i][j] will be updated as if we do a full scan.\\n\\nThe time complexity will become O(NM)\\n\"\"\"\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        N = len(points)\\n        M = len(points[0])\\n        dp = [[0]*M for _ in xrange(N)]\\n\\n        for j in xrange(M):\\n            dp[0][j] = points[0][j]\\n        \\n        for i in xrange(1, N):\\n            rollingMax = float(\\'-inf\\')\\n            for j in xrange(M):\\n                rollingMax = max(rollingMax, dp[i-1][j] - j)\\n                dp[i][j] = max(dp[i][j], points[i][j] + j + rollingMax))\\n            \\n            rollingMax = float(\\'-inf\\')\\n            for j in xrange(M, -1, -1):\\n                rollingMax = max(rollingMax, dp[i-1][j] + j)\\n                dp[i][j] = max(dp[i][j], points[i][j] - j + rollingMax))\\n\\n        return max(dp[N-1])\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\ndp[i][j] := considering from points[0]~points[i], the max points if choosing points[i][j]\\n\"\"\"\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        N = len(points)\\n        M = len(points[0])\\n        dp = [[0]*M for _ in xrange(N)]\\n        \\n        for i in xrange(N):\\n            for j in xrange(M):\\n                if i==0:\\n                    dp[i][j] = points[i][j]\\n                else:\\n                    dp[i][j] = points[i][j]+max([dp[i-1][k] - abs(k-j) for k in xrange(M)])\\n        return max(dp[N-1])\\n\\n    \\n\"\"\"\\nThe above solution will take O(NM^2) in time.\\nThe bottle neck is for each j we need to traverse the whole last row.\\nLet us see a little bit closer on `dp[i][j]`\\n\\ndp[i][j] = points[i][j]+max([dp[i-1][k] - abs(k-j) for k in xrange(M)])\\n\\nSo, if j>=k (Part 1)\\npoints[i][j]+max([dp[i-1][k] - (j-k) for k in xrange(M)])\\npoints[i][j] - j + max([dp[i-1][k] + k) for k in xrange(M)])\\n\\nif k>=j (Part 2)\\npoints[i][j] + max([dp[i-1][k] - (k-j) for k in xrange(M)])\\npoints[i][j] + j + max([dp[i-1][k] - k) for k in xrange(M)])\\n\\nSince we cannot do a full scan\\nwhy not we update the value from left to right for Part 1 and\\nright to left for part 2\\nWith a variable call rollingMax to store the max.\\n\\nThat way dp[i][j] will be updated as if we do a full scan.\\n\\nThe time complexity will become O(NM)\\n\"\"\"\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        N = len(points)\\n        M = len(points[0])\\n        dp = [[0]*M for _ in xrange(N)]\\n\\n        for j in xrange(M):\\n            dp[0][j] = points[0][j]\\n        \\n        for i in xrange(1, N):\\n            rollingMax = float(\\'-inf\\')\\n            for j in xrange(M):\\n                rollingMax = max(rollingMax, dp[i-1][j] - j)\\n                dp[i][j] = max(dp[i][j], points[i][j] + j + rollingMax))\\n            \\n            rollingMax = float(\\'-inf\\')\\n            for j in xrange(M, -1, -1):\\n                rollingMax = max(rollingMax, dp[i-1][j] + j)\\n                dp[i][j] = max(dp[i][j], points[i][j] - j + rollingMax))\\n\\n        return max(dp[N-1])\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321936,
                "title": "journey-of-solving-this-problem-c",
                "content": "If you expect a correct solution you wont find it in this post. For better solutions you can refer other posts :)\\n\\nThis post is all about how i tried approaching the given problem :)\\n\\n![image](https://assets.leetcode.com/users/images/cc2003e5-e2a0-4f97-94f3-f49a41d28821_1658582981.978771.png)\\n\\nSo if you have watched this video [DP 7. Ninja\\'s Training (takeuforward](https://www.youtube.com/watch?v=AE39gJYuRog) you will be able to code the solution. (or atleast you can attempt)\\n\\n## So the first code which i submitted was:\\n### Recursion\\n```\\nclass Solution {\\nprivate:\\n    int m;\\n    int n;\\n    int solve(int index,int last,vector<vector<int>>& points)\\n    { \\n        if(index == 0)\\n        {\\n            int ans = 0;\\n            \\n            for(int i = 0;i<m;i++)\\n                ans = max(ans,(points[0][i] - abs(i-last)));\\n            \\n            return ans;\\n        }\\n        \\n        int maxi = 0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            maxi = max(maxi, (solve(index-1,i,points) + points[index][i] - abs(last-i)));\\n        }\\n        return maxi;\\n    }\\n    \\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        n = points.size();\\n        m = points[0].size();\\n        \\n        int maxi = 0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            maxi = max(maxi, solve(n-1,i,points));\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\\n\\n**verdict: TLE** \\u274C\\uD83D\\uDEA9 54 / 157 test cases passed.\\n**TC:** *[[0,9,6,7,0,5,4,6,6],[8,8,9,3,7,3,4,6,7],[0,6,5,10,10,6,2,7,2],[9,8,0,6,9,9,10,0,1],[10,6,2,7,2,0,4,6,5],[3,7,5,5,6,4,6,4,1],[7,0,8,0,5,3,10,1,10],[0,0,3,3,0,9,2,3,2]]*\\n\\ni was like okayy as expected \\uD83D\\uDE44\\uD83E\\uDD71\\n\\n## Second code:\\n### TOP DOWN DP \\n```\\nclass Solution {\\nprivate:\\n    int m;\\n    int n;\\n    int solve(int index,int last,vector<vector<int>>& points,vector<vector<int>>& dp)\\n    { \\n        if(index == 0)\\n        {\\n            int ans = 0;\\n            \\n            for(int i = 0;i<m;i++)\\n                ans = max(ans,(points[0][i] - abs(i-last)));\\n            \\n            return dp[index][last] = ans;\\n        }\\n        \\n        if(dp[index][last]!=-1)\\n            return dp[index][last];\\n        \\n        int maxi = 0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            maxi = max(maxi, (solve(index-1,i,points,dp) + points[index][i] - abs(last-i)));\\n        }\\n        return dp[index][last] = maxi;\\n    }\\n    \\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        n = points.size();\\n        m = points[0].size();\\n        vector<vector<int>>dp(n,vector<int> (m,-1));\\n        \\n        int maxi = 0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            maxi = max(maxi, solve(n-1,i,points,dp));\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\\n**verdict: TLE** \\u274C\\uD83D\\uDEA9 140 / 157 test cases passed\\n**TC:** [Test case:140](https://pastebin.com/4B2kfBcy)\\n\\nAt this moment i thought okayy the constraints are strict \\uD83D\\uDE28\\uD83D\\uDE25\\uD83D\\uDE23\\nSo i tried Tabulation (bottom up) to optimize my code\\n\\n## Third Solution\\n### BOTTOM UP (TABULATION)\\n```\\nclass Solution {\\n    \\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        const int n = points.size();\\n        const int m = points[0].size();\\n        vector<vector<int>>dp(n,vector<int> (m,-1));\\n\\n        long long ans = 0;\\n        for(int i =0;i<m;i++)\\n        {\\n            dp[0][i] = points[0][i];\\n            ans = max<long long int>(ans,dp[0][i]);\\n        }\\n        \\n        for(int i = 1;i<n;i++)\\n        {\\n            for(int j= 0;j<m;j++)\\n            {\\n                ans = 0;\\n                for(int k = 0;k<m;k++)\\n                {\\n                    ans = max<long long int>(ans,dp[i-1][k] + points[i][j] - abs(k-j));\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n \\n        ans = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n             ans = max<long long int>(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**verdict: TLE** \\u274C\\uD83D\\uDEA9 143 / 157 test cases passed.\\n**TC:** [Test case 143](https://pastebin.com/7ADLCDuJ)\\n\\ntried few optimization and submitted the code again and again just to get TLE \\uD83D\\uDE35\\uD83D\\uDE2D\\u274C\\uD83D\\uDEA9\\uD83D\\uDEA9\\nLater, i thought about space optimized solution\\n\\n## fourth solution\\n### space optimized\\n```\\nclass Solution {\\n    \\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        const int n = points.size();\\n        const int m = points[0].size();\\n        vector<long long int>curr(m,-1);\\n\\n        long long ans = 0;\\n        for(int i =0;i<m;i++)\\n        {\\n            curr[i] = points[0][i];\\n            ans = max(ans,curr[i]);\\n        }\\n        \\n        vector<long long int>prev(curr);\\n\\n        for(int i = 1;i<n;i++)\\n        {\\n            for(int j= 0;j<m;j++)\\n            {\\n                long long temp = 0;\\n                for(int k = 0;k<m;k++)\\n                {\\n                    temp = max(temp,prev[k] + points[i][j] - abs(k-j));\\n                }\\n                curr[j] = temp;\\n                ans = max(ans,curr[j]);\\n            }\\n            prev = curr;\\n        }\\n \\n        return ans;\\n    }\\n};\\n```\\n**verdict: TLE** \\u274C\\uD83D\\uDEA9 143 / 157 test cases passed.\\n**TC:** [Test case 143](https://pastebin.com/7ADLCDuJ)\\n\\nWhen i saw my submissions,\\nthis meme struck my mind\\uD83D\\uDE02\\n![image](https://assets.leetcode.com/users/images/f194de48-293e-4826-90c1-0e4c945e9b3f_1658584434.777416.png)\\n\\nLater i viewed other solutions and submitted the AC solution\\uD83E\\uDD71\\uD83D\\uDE2A\\n\\n**Consistency is important!**\\nTry to approach the question without looking at the solution\\nSometimes you might discover a new way to solve it and sometimes you will learn a new way to solve it!\\n\\n**Happy Coding!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int m;\\n    int n;\\n    int solve(int index,int last,vector<vector<int>>& points)\\n    { \\n        if(index == 0)\\n        {\\n            int ans = 0;\\n            \\n            for(int i = 0;i<m;i++)\\n                ans = max(ans,(points[0][i] - abs(i-last)));\\n            \\n            return ans;\\n        }\\n        \\n        int maxi = 0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            maxi = max(maxi, (solve(index-1,i,points) + points[index][i] - abs(last-i)));\\n        }\\n        return maxi;\\n    }\\n    \\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        n = points.size();\\n        m = points[0].size();\\n        \\n        int maxi = 0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            maxi = max(maxi, solve(n-1,i,points));\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int m;\\n    int n;\\n    int solve(int index,int last,vector<vector<int>>& points,vector<vector<int>>& dp)\\n    { \\n        if(index == 0)\\n        {\\n            int ans = 0;\\n            \\n            for(int i = 0;i<m;i++)\\n                ans = max(ans,(points[0][i] - abs(i-last)));\\n            \\n            return dp[index][last] = ans;\\n        }\\n        \\n        if(dp[index][last]!=-1)\\n            return dp[index][last];\\n        \\n        int maxi = 0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            maxi = max(maxi, (solve(index-1,i,points,dp) + points[index][i] - abs(last-i)));\\n        }\\n        return dp[index][last] = maxi;\\n    }\\n    \\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        n = points.size();\\n        m = points[0].size();\\n        vector<vector<int>>dp(n,vector<int> (m,-1));\\n        \\n        int maxi = 0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            maxi = max(maxi, solve(n-1,i,points,dp));\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        const int n = points.size();\\n        const int m = points[0].size();\\n        vector<vector<int>>dp(n,vector<int> (m,-1));\\n\\n        long long ans = 0;\\n        for(int i =0;i<m;i++)\\n        {\\n            dp[0][i] = points[0][i];\\n            ans = max<long long int>(ans,dp[0][i]);\\n        }\\n        \\n        for(int i = 1;i<n;i++)\\n        {\\n            for(int j= 0;j<m;j++)\\n            {\\n                ans = 0;\\n                for(int k = 0;k<m;k++)\\n                {\\n                    ans = max<long long int>(ans,dp[i-1][k] + points[i][j] - abs(k-j));\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n \\n        ans = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n             ans = max<long long int>(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        const int n = points.size();\\n        const int m = points[0].size();\\n        vector<long long int>curr(m,-1);\\n\\n        long long ans = 0;\\n        for(int i =0;i<m;i++)\\n        {\\n            curr[i] = points[0][i];\\n            ans = max(ans,curr[i]);\\n        }\\n        \\n        vector<long long int>prev(curr);\\n\\n        for(int i = 1;i<n;i++)\\n        {\\n            for(int j= 0;j<m;j++)\\n            {\\n                long long temp = 0;\\n                for(int k = 0;k<m;k++)\\n                {\\n                    temp = max(temp,prev[k] + points[i][j] - abs(k-j));\\n                }\\n                curr[j] = temp;\\n                ans = max(ans,curr[j]);\\n            }\\n            prev = curr;\\n        }\\n \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526958,
                "title": "python-o-mn-in-time-o-n-in-space-faster-that-98",
                "content": "It\\'s a pretty standard dynamic programming problem. It is easy to find the O(M * N^2) solution but it is possible to go lower with some post-processing of the memory array.\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        current_points = [point for point in points[0]]\\n        \\n        for row in range(1, len(points)):\\n            # We traverse current_points left to right and store the maximum possible score that the next row can get,\\n            # taking into account only the elements with indexes [0, col]\\n            max_col_points = -float(\"inf\")\\n            for col in range(0, len(current_points)):\\n                max_col_points = max(max_col_points - 1, current_points[col])\\n                current_points[col] = max_col_points\\n                \\n            # We traverse current_points right to left and store the maximum possible score that the next row can get,\\n            # taking into account only the elements with indexes [col, end]\\n            max_col_points = -float(\"inf\")\\n            for col in range(len(current_points) - 1, -1, -1):\\n                max_col_points = max(max_col_points - 1, current_points[col])\\n                current_points[col] = max_col_points\\n                \\n            # We update current_points, adding the maximum value we can carry over from the previous row to the value\\n            # contained in the current column of the current row\\n            for col in range(len(current_points)):\\n                current_points[col] = points[row][col] + current_points[col]\\n                \\n        return max(current_points)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        current_points = [point for point in points[0]]\\n        \\n        for row in range(1, len(points)):\\n            # We traverse current_points left to right and store the maximum possible score that the next row can get,\\n            # taking into account only the elements with indexes [0, col]\\n            max_col_points = -float(\"inf\")\\n            for col in range(0, len(current_points)):\\n                max_col_points = max(max_col_points - 1, current_points[col])\\n                current_points[col] = max_col_points\\n                \\n            # We traverse current_points right to left and store the maximum possible score that the next row can get,\\n            # taking into account only the elements with indexes [col, end]\\n            max_col_points = -float(\"inf\")\\n            for col in range(len(current_points) - 1, -1, -1):\\n                max_col_points = max(max_col_points - 1, current_points[col])\\n                current_points[col] = max_col_points\\n                \\n            # We update current_points, adding the maximum value we can carry over from the previous row to the value\\n            # contained in the current column of the current row\\n            for col in range(len(current_points)):\\n                current_points[col] = points[row][col] + current_points[col]\\n                \\n        return max(current_points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983452,
                "title": "cool-animations-described-all-approaches",
                "content": "Hi everyone! \\n\\nThis is my favourite question on leetcode, therefore I\\'ve prepared cool animations by using Manim lib from 3blue1brown.\\nCheck it out here: https://www.youtube.com/watch?v=P4Z9XdHAE4o\\n\\nPlease, upvote, if you think, I deserve, and have a nice day!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Hi everyone! \\n\\nThis is my favourite question on leetcode, therefore I\\'ve prepared cool animations by using Manim lib from 3blue1brown.\\nCheck it out here: https://www.youtube.com/watch?v=P4Z9XdHAE4o\\n\\nPlease, upvote, if you think, I deserve, and have a nice day!",
                "codeTag": "Unknown"
            },
            {
                "id": 1734788,
                "title": "java-explained-with-example",
                "content": "\\t/* \\n\\t   -> take a frame same width as points,this frame will contains most effective(which provide maximum sum)values which will later get \\n\\t\\tadded to next values from next row.\\n\\n\\t   -> conditions to update values in frame \\n\\t\\t\\t* we will keep only those values which will contribute maximum in next row addition\\n\\n\\t\\te.g-->\\n\\t\\t\\tpoints --->[[1,2,3]\\n\\t\\t\\t\\t\\t\\t[1,5,1]\\n\\t\\t\\t\\t\\t\\t[3,1,1]]\\n\\n\\t\\t\\tfor 1st iteration frame <--- [1,2,3] rest of two loops will not affect frame so in \\n\\t\\t\\t2nd itreration frame <--------[2,7,4] <-------- [1,2,3] + [1,5,1]\\n\\t\\t\\tnow we have to update frame so it can give max values for next row addition\\n\\t\\t\\t 0 1 2   \\n\\t\\t\\t[2,7,4] \\n\\t\\t\\t  \\\\ \\n\\t\\t\\t[2,7,4]  check left to right--> just check value at index 0 can contribute more than curr_sum at index 1 but to do so it has to give up (1-0) a penalty,here 7 can contribute more than 2-1=1 in next sum.\\n\\t\\t\\t2 7 4        now check for index 2,where (7-1)>4\\n\\t\\t\\t   \\\\\\n\\t\\t\\t2 7 6\\n\\t\\t\\t\\t\\t\\tnow do in reverse,can 6 contribute more than 7 no ( 7 >(6-1) )  \\n\\t\\t\\t\\t\\t\\tcan 7 contibute more than 2 yes (2<(7-1)),so now  frame will be\\n\\t\\t\\t6 7 6       now we can cal optimal-frame for rest of the matrix.\\n\\t\\t+   3 1 1\\n\\t ------------------- \\n\\t\\t\\t9 8 7  check left to right--> can 9 can contibute 8>(9-1) no; can 8 can contibute for index 2 no simlier for right to left\\n\\t*/\\n\\n\\tclass Solution {\\n\\t\\tpublic long maxPoints(int[][] points) {\\n\\t\\t\\tlong[] frame = new long[points[0].length];\\n\\n\\t\\t\\tfor (int i = 0; i < points.length; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j <frame.length; j ++) frame[j] += points[i][j];\\n\\n\\t\\t\\t\\tfor (int j = 1; j < frame.length; j ++) frame[j] = Math.max(frame[j], frame[j - 1] - 1);\\n\\n\\t\\t\\t\\tfor (int j=frame.length-2;j>=0;j--) frame[j] = Math.max(frame[j], frame[j + 1] - 1);\\n\\n\\t\\t\\t\\tfor(long k:frame) System.out.println(k);\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tlong ans = 0;\\n\\t\\t\\tfor (int i = 0; i < frame.length; i ++) {\\n\\t\\t\\t\\tans = Math.max(ans, frame[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic long maxPoints(int[][] points) {\\n\\t\\t\\tlong[] frame = new long[points[0].length];\\n\\n\\t\\t\\tfor (int i = 0; i < points.length; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j <frame.length; j ++) frame[j] += points[i][j];\\n\\n\\t\\t\\t\\tfor (int j = 1; j < frame.length; j ++) frame[j] = Math.max(frame[j], frame[j - 1] - 1);\\n\\n\\t\\t\\t\\tfor (int j=frame.length-2;j>=0;j--) frame[j] = Math.max(frame[j], frame[j + 1] - 1);\\n\\n\\t\\t\\t\\tfor(long k:frame) System.out.println(k);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1549672,
                "title": "java-brute-force-to-optimized-dp-with-o-mn-time-complexity-and-o-n-space-complexity",
                "content": "m is the number of rows and n is the number of columns.\\n**Brute Force Approach (TLE)**: O(m n^2) Time Complexity\\nUsing Previous(prev) and Current(curr) Arrays because we are assessing 2 rows at a time.\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        \\n        int rows = points.length;\\n        int cols = points[0].length;\\n        \\n        long[] prev = new long[cols];\\n        \\n        for (int i = 0; i < cols; i++) {\\n            prev[i] = points[0][i];\\n        }\\n        \\n        for (int i = 1; i < rows; i++) {\\n            long[] curr = new long[cols];\\n            for (int j = 0; j < cols; j++) {                \\n                \\n                int num = points[i][j];\\n                long ans = 0;\\n                for (int k = 0; k < cols; k++) {\\n                    ans = Math.max(ans, num + prev[k] - Math.abs(k - j));\\n                }\\n                curr[j] = ans;\\n            }\\n            prev = curr;\\n        }\\n        \\n        long maxPoints = 0;\\n        for (int j = 0; j < cols; j++) {\\n            maxPoints = Math.max(maxPoints, prev[j]);\\n        }\\n        return maxPoints;\\n    }\\n}\\n\\n\\n```\\n\\n**Approach 2 : Improved DP using additional space for left and right passes (Accepted)**\\nLeft Array of size O(n), Right Array of size O(n), Prev and Curr arrays are the same as before.\\nTime Complexity : O(mn)\\nSpace Complexity: O(4n) which is O(n)\\n\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        \\n        int rows = points.length;\\n        int cols = points[0].length;\\n        \\n        long[] prev = new long[cols];\\n        \\n        for (int i = 0; i < cols; i++) {\\n            prev[i] = points[0][i];\\n        }\\n        \\n        for (int i = 0; i < rows - 1; i++) {\\n            long[] left = new long[cols];\\n            long[] right = new long[cols];\\n            long curr[] = new long[cols];\\n            \\n            left[0] = prev[0];\\n            right[cols - 1] = prev[cols - 1];\\n            \\n            for (int j = 1; j < cols; j++) {\\n                left[j] = Math.max(left[j-1] - 1, prev[j]);\\n            }\\n            \\n            for (int j = cols - 2; j >= 0; j--) {\\n                right[j] = Math.max(right[j+1] - 1, prev[j]);\\n            }\\n            \\n            for (int j = 0; j < cols; j++) {\\n                curr[j] = points[i + 1][j] + Math.max(left[j], right[j]);\\n            }\\n            \\n            prev = curr;\\n        }\\n        \\n        long maxPoints = 0;\\n        for (int j = 0; j < cols; j++) {\\n            maxPoints = Math.max(maxPoints, prev[j]);\\n        }\\n        return maxPoints;\\n    }\\n}\\n```\\n\\n**Approach 3 : Improving the Space Complexity of Approach 2 (Accepted)**\\n\\nWe will use just 1 extra array (dp) of size n. \\nTime Complexity: O(mn)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        \\n        int rows = points.length;\\n        int cols = points[0].length;\\n        \\n        long[] dp = new long[cols];\\n        \\n        for (int i = 0; i < rows; i++) {\\n            \\n            for (int j = 0; j < cols; j++) {\\n                dp[j] += points[i][j];\\n            }\\n            \\n\\t\\t\\t//left to right pass\\n            for (int j = 1; j < cols; j++) {\\n                dp[j] = Math.max(dp[j], dp[j - 1] - 1);\\n            }\\n            \\n\\t\\t\\t//right to left pass\\n            for (int j = cols - 2; j >= 0; j--) {\\n                dp[j] = Math.max(dp[j], dp[j + 1] - 1);\\n            }\\n        }\\n        \\n        long maxPoints = 0;\\n        for (int j = 0; j < cols; j++) {\\n            maxPoints = Math.max(maxPoints, dp[j]);\\n        }\\n        return maxPoints;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        \\n        int rows = points.length;\\n        int cols = points[0].length;\\n        \\n        long[] prev = new long[cols];\\n        \\n        for (int i = 0; i < cols; i++) {\\n            prev[i] = points[0][i];\\n        }\\n        \\n        for (int i = 1; i < rows; i++) {\\n            long[] curr = new long[cols];\\n            for (int j = 0; j < cols; j++) {                \\n                \\n                int num = points[i][j];\\n                long ans = 0;\\n                for (int k = 0; k < cols; k++) {\\n                    ans = Math.max(ans, num + prev[k] - Math.abs(k - j));\\n                }\\n                curr[j] = ans;\\n            }\\n            prev = curr;\\n        }\\n        \\n        long maxPoints = 0;\\n        for (int j = 0; j < cols; j++) {\\n            maxPoints = Math.max(maxPoints, prev[j]);\\n        }\\n        return maxPoints;\\n    }\\n}\\n\\n\\n```\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        \\n        int rows = points.length;\\n        int cols = points[0].length;\\n        \\n        long[] prev = new long[cols];\\n        \\n        for (int i = 0; i < cols; i++) {\\n            prev[i] = points[0][i];\\n        }\\n        \\n        for (int i = 0; i < rows - 1; i++) {\\n            long[] left = new long[cols];\\n            long[] right = new long[cols];\\n            long curr[] = new long[cols];\\n            \\n            left[0] = prev[0];\\n            right[cols - 1] = prev[cols - 1];\\n            \\n            for (int j = 1; j < cols; j++) {\\n                left[j] = Math.max(left[j-1] - 1, prev[j]);\\n            }\\n            \\n            for (int j = cols - 2; j >= 0; j--) {\\n                right[j] = Math.max(right[j+1] - 1, prev[j]);\\n            }\\n            \\n            for (int j = 0; j < cols; j++) {\\n                curr[j] = points[i + 1][j] + Math.max(left[j], right[j]);\\n            }\\n            \\n            prev = curr;\\n        }\\n        \\n        long maxPoints = 0;\\n        for (int j = 0; j < cols; j++) {\\n            maxPoints = Math.max(maxPoints, prev[j]);\\n        }\\n        return maxPoints;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        \\n        int rows = points.length;\\n        int cols = points[0].length;\\n        \\n        long[] dp = new long[cols];\\n        \\n        for (int i = 0; i < rows; i++) {\\n            \\n            for (int j = 0; j < cols; j++) {\\n                dp[j] += points[i][j];\\n            }\\n            \\n\\t\\t\\t//left to right pass\\n            for (int j = 1; j < cols; j++) {\\n                dp[j] = Math.max(dp[j], dp[j - 1] - 1);\\n            }\\n            \\n\\t\\t\\t//right to left pass\\n            for (int j = cols - 2; j >= 0; j--) {\\n                dp[j] = Math.max(dp[j], dp[j + 1] - 1);\\n            }\\n        }\\n        \\n        long maxPoints = 0;\\n        for (int j = 0; j < cols; j++) {\\n            maxPoints = Math.max(maxPoints, dp[j]);\\n        }\\n        return maxPoints;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626313,
                "title": "python-dp-in-o-m-n-time-and-o-n-space-with-clear-proof",
                "content": "```python\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \"\"\" DP in Time: O(M*N) Space: O(N)\\n        \\n        Define dp[i][j] (i = 0, ..., m - 1; j = 0, ..., n - 1) as max points that one can get from \\n        the first i rows (up to the i-th row), and for the i-th row, picking exactly the j-th point\\n        \\n        fill dp row by row until the (m - 1)-th row, then return max(dp[-1]) as max points \\n        we have initial case: first row dp[0][j] = points[0][j] for j in range(n)\\n        and for i >= 1: dp[i][j] = points[i][j] + max(dp[i-1][k] - abs(k-j) for k in range(n))\\n               \\n        focus on the max term: max(dp[i-1][k] - abs(k-j) for k in range(n)) = max(A[k] + B[k] for k in range(n))\\n        where A = dp[i-1] remains unchanged over different j, only B shifts right with j\\n        For example: \\n        for each j=0,...,n-1, we need to find the max over A[k] + B[k] to fill dp[i][j]\\n        A: ..., dp[i-1][j-2], dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1], dp[i-1][j+2], ...\\n        B: ...,           -2,           -1,          0,           -1,           -2, ...\\n        \\n        for j = 0, ..., n-1, \\n        there are repetative patterns in this max(A+B) calculation that can be speed up using another DP\\n        \\n        for each j\\n        define left[j] (j=0, ..., n-1) as left[j] = max(A[:j+1] + B[:j+1]) \\n        left[0] = max(dp[i-1][0])\\n        left[1] = max(dp[i-1][0] - 1, dp[i-1][1]) = max(left[0] - 1, dp[i-1][1])\\n        left[2] = max(dp[i-1][0] - 2, dp[i-1][1] - 1, dp[i-1][2]) = max(left[1] - 1, dp[i-1][2])\\n        left[3] = max(dp[i-1][0] - 3, dp[i-1][1] - 2, dp[i-1][2] - 1, dp[i-1][3]) = max(left[2] - 1, dp[i-1][3])\\n        ...\\n        left can be filled in linear time \\n        \\n        for each j define right[j] (j=0, ..., n-1) as right[j] = max(A[j:] + B[j:])\\n        right[n-1] = max(dp[i-1][n-1])\\n        right[n-2] = max(dp[i-1][n-2], dp[i-1][n-1] - 1) = max(dp[i-1][n-2], right[n-1]-1)\\n        right[n-3] = max(dp[i-1][n-3], dp[i-1][n-2] - 1 , dp[i-1][n-1] - 2) = max(dp[i-1][n-3], right[n-2] - 1)\\n        ...\\n        right[0] = max(dp[i-1][0], right[1] - 1)\\n        right can be filled in linear time\\n        \\n        max(left[j], right[j]) \\n        = max( \\n                max(A[:j+1] + B[:j+1]), \\n                max(A[j:]   + B[j:])        \\n            ) = max(A + B) = max(dp[i-1][k] - abs(k-j) for k in range(n))\\n            \\n        thus dp[i][j] = points[i][j] + max(dp[i-1][k] - abs(k-j) for k in range(n)) \\n         = points[i][j] + max(left[j], right[j]) \\n         can be computed in O(1) time\\n        \"\"\"\\n        num_rows, num_cols = len(points), len(points[0])\\n        dp_cur, dp_prev = points[0], points[0]\\n        for i in range(1, num_rows):\\n            # construct left\\n            for j in range(num_cols):\\n                if j == 0:\\n                    left = [dp_prev[0]]\\n                else:\\n                    left.append(max(left[-1] - 1, dp_prev[j]))\\n            # construct right\\n            for j in reversed(range(num_cols)):\\n                if j == num_cols - 1:\\n                    right = deque([dp_prev[j]])\\n                else:\\n                    right.appendleft(max(dp_prev[j], right[0] - 1))\\n            # fill dp[i][j]\\n            for j in range(num_cols):\\n                dp_cur[j] = points[i][j] + max(left[j], right[j])\\n            dp_prev = dp_cur.copy()\\n        return max(dp_cur)\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \"\"\" DP in Time: O(M*N) Space: O(N)\\n        \\n        Define dp[i][j] (i = 0, ..., m - 1; j = 0, ..., n - 1) as max points that one can get from \\n        the first i rows (up to the i-th row), and for the i-th row, picking exactly the j-th point\\n        \\n        fill dp row by row until the (m - 1)-th row, then return max(dp[-1]) as max points \\n        we have initial case: first row dp[0][j] = points[0][j] for j in range(n)\\n        and for i >= 1: dp[i][j] = points[i][j] + max(dp[i-1][k] - abs(k-j) for k in range(n))\\n               \\n        focus on the max term: max(dp[i-1][k] - abs(k-j) for k in range(n)) = max(A[k] + B[k] for k in range(n))\\n        where A = dp[i-1] remains unchanged over different j, only B shifts right with j\\n        For example: \\n        for each j=0,...,n-1, we need to find the max over A[k] + B[k] to fill dp[i][j]\\n        A: ..., dp[i-1][j-2], dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1], dp[i-1][j+2], ...\\n        B: ...,           -2,           -1,          0,           -1,           -2, ...\\n        \\n        for j = 0, ..., n-1, \\n        there are repetative patterns in this max(A+B) calculation that can be speed up using another DP\\n        \\n        for each j\\n        define left[j] (j=0, ..., n-1) as left[j] = max(A[:j+1] + B[:j+1]) \\n        left[0] = max(dp[i-1][0])\\n        left[1] = max(dp[i-1][0] - 1, dp[i-1][1]) = max(left[0] - 1, dp[i-1][1])\\n        left[2] = max(dp[i-1][0] - 2, dp[i-1][1] - 1, dp[i-1][2]) = max(left[1] - 1, dp[i-1][2])\\n        left[3] = max(dp[i-1][0] - 3, dp[i-1][1] - 2, dp[i-1][2] - 1, dp[i-1][3]) = max(left[2] - 1, dp[i-1][3])\\n        ...\\n        left can be filled in linear time \\n        \\n        for each j define right[j] (j=0, ..., n-1) as right[j] = max(A[j:] + B[j:])\\n        right[n-1] = max(dp[i-1][n-1])\\n        right[n-2] = max(dp[i-1][n-2], dp[i-1][n-1] - 1) = max(dp[i-1][n-2], right[n-1]-1)\\n        right[n-3] = max(dp[i-1][n-3], dp[i-1][n-2] - 1 , dp[i-1][n-1] - 2) = max(dp[i-1][n-3], right[n-2] - 1)\\n        ...\\n        right[0] = max(dp[i-1][0], right[1] - 1)\\n        right can be filled in linear time\\n        \\n        max(left[j], right[j]) \\n        = max( \\n                max(A[:j+1] + B[:j+1]), \\n                max(A[j:]   + B[j:])        \\n            ) = max(A + B) = max(dp[i-1][k] - abs(k-j) for k in range(n))\\n            \\n        thus dp[i][j] = points[i][j] + max(dp[i-1][k] - abs(k-j) for k in range(n)) \\n         = points[i][j] + max(left[j], right[j]) \\n         can be computed in O(1) time\\n        \"\"\"\\n        num_rows, num_cols = len(points), len(points[0])\\n        dp_cur, dp_prev = points[0], points[0]\\n        for i in range(1, num_rows):\\n            # construct left\\n            for j in range(num_cols):\\n                if j == 0:\\n                    left = [dp_prev[0]]\\n                else:\\n                    left.append(max(left[-1] - 1, dp_prev[j]))\\n            # construct right\\n            for j in reversed(range(num_cols)):\\n                if j == num_cols - 1:\\n                    right = deque([dp_prev[j]])\\n                else:\\n                    right.appendleft(max(dp_prev[j], right[0] - 1))\\n            # fill dp[i][j]\\n            for j in range(num_cols):\\n                dp_cur[j] = points[i][j] + max(left[j], right[j])\\n            dp_prev = dp_cur.copy()\\n        return max(dp_cur)\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119013,
                "title": "python-dynamic-programming-o-mn-solution",
                "content": "![image](https://assets.leetcode.com/users/images/1aec9f3b-ab55-4997-b3e0-c41b0e7dcbe2_1654531688.4755151.jpeg)\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        \\n        dp = points[0]\\n        \\n        left = [0] * n ## left side contribution\\n        right = [0] * n ## right side contribution\\n        \\n        for r in range(1, m):\\n            for c in range(n):\\n                if c == 0:\\n                    left[c] = dp[c]\\n                else:\\n                    left[c] = max(left[c - 1] - 1, dp[c])\\n            \\n            for c in range(n - 1, -1, -1):\\n                if c == n-1:\\n                    right[c] = dp[c]\\n                else:\\n                    right[c] = max(right[c + 1] - 1, dp[c])\\n                    \\n            for c in range(n):\\n                dp[c] = points[r][c] + max(left[c], right[c])\\n                \\n        return max(dp)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        \\n        dp = points[0]\\n        \\n        left = [0] * n ## left side contribution\\n        right = [0] * n ## right side contribution\\n        \\n        for r in range(1, m):\\n            for c in range(n):\\n                if c == 0:\\n                    left[c] = dp[c]\\n                else:\\n                    left[c] = max(left[c - 1] - 1, dp[c])\\n            \\n            for c in range(n - 1, -1, -1):\\n                if c == n-1:\\n                    right[c] = dp[c]\\n                else:\\n                    right[c] = max(right[c + 1] - 1, dp[c])\\n                    \\n            for c in range(n):\\n                dp[c] = points[r][c] + max(left[c], right[c])\\n                \\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344932,
                "title": "why-top-down-giving-tle-along-with-testcase",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long solve(vector<vector<int>>& points,int x,int y,int n,int m,vector<vector<long long>>&dp){\\n        \\n        if(x==n){\\n            return 0;\\n        }\\n        \\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        long long ans=INT_MIN;\\n        for(int j=0;j<m;j++){\\n            if(dp[x][j]!=-1){\\n                ans=max(dp[x][j]-abs(j-y),ans);\\n            }\\n            else{\\n                ans=max(ans,points[x][j]+solve(points,x+1,j,n,m,dp)-abs(y-j));\\n            }\\n            \\n        }\\n        \\n        return dp[x][y]=ans;\\n        \\n    }  \\n    \\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        int n=points.size();\\n        int m=points[0].size();\\n        \\n        long long ans=INT_MIN;\\n        \\n        vector<vector<long long>>dp(n , vector<long long> (m, -1));\\n        \\n        for(int j=0;j<m;j++){\\n            dp[0][j]=points[0][j]+solve(points,1,j,n,m,dp);\\n            ans=max(dp[0][j],ans);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n**TESTCASE**\\n[[740,519,678,823,57,528,879,938,894,973,811,887,601,981,851,3,6,478,277,1013,426,115,437,295,292,275,1034,283,314,903,218,1,357,896,231,49,874,1073,911,99,697,446,935,535,347,656,634,125,780,403,754,1009,255,710,172,466,220,294,541,700,148,517,825,892,525,73,841,961,1031,1011,461,491,177,930,972,557,480,867,755,1018,228,769,459,365,364,235,768,2,254,812,318,556,822,415,819,842,86,1024,460,385,468,360,707,758,919,546,771,242,1063,917,213,492,332,206,603,617,435,223,230,653,676,788,27,143,50,509,646,849,1040,577,398,897,712,38,163,473,77,1030,326,329,826,731,589,1019,831,766,205,344,302,604,563,690,677,734,950,31,451,195,733,1023,105,313,565,311,303,243,566,993,764,720,378,655,386,402,905,87,471,640,363,521,760,1044,1007,481,576,71,821,276,184,944,186,306,861,802,573,762,615,784,967,40,889,969,991,543,923,926,1016,1022,103,549,474,354,693,907,107,193,54,588,41,708,508,162,659,238,373,866,776,574,421,79,568,986,320,878,881,417,552,915,728,672,23,391,609,271,83,30,1062,5,1065,645,987,783,673,793,52,789,485,596,470,339,362,116,297,828,704,144,667,91,1015,971,920,20,936,247,1071,15,312,327,797,835,983,1006,569,477,1003,447,955,476,796,137,947,514,713,286,781,1067,100,420,1025,244,53,711,431,630,592,274,289,927,395,412,495,976,319,439,709,497,11,352,488,621,224,225,567,816,1021,108,948,542,1002,536,299,7,963,1080,411,532,256,600,902,912,152,258,192,335,121,97,616,1010,611,773,265,1020,975,850,74,80,124,248,629,893,376,383,661,430,1033,545,1056,1046,418,291,406,1069,500,161,591,422,59,207,424,962,687,46,369,396,245,806,1037,547,747,748,594,524,106,900,749,800,1077,862,448,527,337,374,752,876,307,648,998,877,432,1068,992,84,179,925,136,24,995,801,284,685,456,234,553,428,1004,413,98,368,1032,490,827,537,13,778,854,513,952,715,279,910,654,387,597,8,718,721,126,898,847,64,191,1072,18,958,977,599,590,618,719,587,455,622,95,237,380,804,716,953,449,770,101,60,838,550,222,336,401,501,441,133,652,941,872,410,316,714,503,817,730,62,301,296,370,359,351,9,229,308,506,429,81,1066,627,679,66,201,916,458,1054,724,1027,785,58,1061,330,440,288,199,745,698,372,738,664,381,164,890,379,997,585,767,467,772,200,67,263,118,427,564,837,29,282,109,988,36,409,666,463,856,526,853,438,367,141,875,142,117,570,999,979,178,504,584,943,959,1029,858,815,173,375,390,272,394,641,340,355,516,561,1052,882,331,85,921,533,454,1055,499,88,4,227,869,650,1053,671,808,520,775,744,761,990,215,43,722,824,214,154,111,1000,957,188,954,123,189,371,994,203,434,668,281,1076,309,739,498,278,75,572,614,663,554,346,1049,324,1026,158,196,392,840,452,625,266,33,540,612,1041,807,530,1038,579,928,868,968,1012,1060,90,765,397,638,852,717,236,555,888,649,1050,120,706,696,966,1014,829,939,174,322,253,102,47,870,924,343,119,809,523,510,901,922,688,68,951,539,180,487,202,436,777,159,197,702,814,450,880,1008,606,1059,607,683,16,845,865,261,647,190,613,857,531,393,636,913,794,694,507,55,544,736,984,502,285,317,1075,389,660,742,273,934,135,51,210,512,28,1035,605,701,63,464,65,737,970,1064,974,657,187,844,405,240,484,257,19,1070,1074,348,194,334,156,321,39,705,1048,69,792,725,929,832,114,472,494,153,602,48,949,408,358,112,241,10,304,795,366,469,21,873,833,803,918,763,217,741,626,155,1017,608,906,632,232,684,300,942,548,562,17,871,342,644,658,384,270,165,691,931,1039,145,637,226,262,147,482,798,909,493,489,843,732,325,465,377,743,219,985,34,425,483,779,964,791,35,315,787,1028,419,820,182,937,160,665,233,610,251,1047,113,1042,185,960,70,149,25,122,836,399,681,260,522,746,127,699,886,486,12,298,756,619,578,433,443,505,280,830,583,581,407,22,78,268,61,1057,735,323,575,175,1079,982,593,675,76,651,635,726,662,104,208,204,529,518,350,328,1043,670,414,586,945,166,598,37,885,453,1001,628,310,269,496,933,692,790,580,361,1036,723,515,400,956,989,345,250,356,353,839,805,131,703,169,1045,978,899,863,643,42,818,1078,751,624,168,551,209,759,293,686,682,631,264,940,834,198,595,132,891,249,150,140,246,571,221,462,810,212],[333,376,614,527,66,951,598,609,784,778,989,125,692,550,867,89,602,74,427,368,129,300,492,195,846,471,419,271,244,102,698,577,962,236,380,122,828,912,268,336,847,562,235,68,1021,363,267,178,522,1054,536,421,441,771,84,909,307,844,450,705,817,232,508,337,265,134,383,411,474,807,103,863,113,204,905,813,1045,785,343,765,927,760,144,167,443,354,279,261,238,566,38,704,923,519,551,18,311,212,736,366,638,1069,811,593,815,180,472,389,344,420,691,537,672,25,139,372,762,570,1016,391,639,836,54,816,39,266,880,851,462,43,120,996,32,44,966,842,968,1033,86,323,722,1052,656,646,404,781,597,324,806,385,937,928,407,170,142,934,132,772,225,104,96,875,319,396,1048,983,528,453,51,843,687,35,275,613,506,902,145,76,985,685,864,251,151,192,205,497,797,997,1068,384,357,891,80,1002,14,708,809,543,868,1049,405,895,154,1060,636,223,790,118,920,469,831,517,918,730,756,58,686,1018,361,23,936,556,945,233,884,825,1029,637,885,350,248,105,1047,36,906,410,491,890,953,250,848,71,944,182,675,256,729,879,45,1013,743,827,9,435,291,1076,280,82,641,572,588,314,750,1007,444,394,16,571,823,755,451,197,22,654,434,712,888,79,501,131,490,488,829,611,1028,359,510,869,926,1067,48,190,949,865,1017,788,616,298,97,1062,540,228,187,274,542,397,599,821,605,487,165,942,695,95,26,1079,198,28,741,478,530,1012,20,237,553,701,673,898,322,330,640,526,482,776,140,289,735,946,559,916,5,889,254,127,1075,679,50,606,1057,484,915,230,703,239,463,148,318,524,1031,503,449,374,892,779,954,802,1080,480,264,34,1055,514,964,874,579,564,961,220,160,468,153,529,824,452,531,1008,297,775,387,592,191,668,375,11,270,583,1041,210,1015,998,4,745,594,202,219,149,555,229,98,392,423,341,979,1073,911,618,114,841,626,516,135,133,849,534,378,91,931,545,6,90,586,281,296,803,312,717,243,55,17,622,87,382,1006,539,12,709,455,935,304,661,365,725,224,292,601,493,660,840,426,460,663,398,665,633,495,373,116,448,262,677,604,992,81,702,560,163,316,30,47,933,795,408,1036,929,141,164,1020,674,511,309,737,401,53,922,608,732,364,648,749,769,789,963,351,393,952,152,440,805,147,620,882,509,379,584,870,910,739,861,688,199,632,334,518,681,61,65,904,658,950,346,872,52,7,653,467,175,282,643,138,682,852,761,278,941,982,507,327,768,976,500,196,667,576,958,967,711,596,390,227,850,263,645,544,340,627,793,647,561,839,801,207,88,715,465,128,72,1077,13,969,693,301,483,412,914,29,657,3,845,995,723,684,568,352,360,533,200,855,1032,649,454,655,186,903,1039,494,406,489,591,664,1071,73,513,535,193,498,1004,666,759,62,1038,137,988,464,174,211,830,694,876,955,21,231,347,900,549,161,714,866,425,362,751,972,740,631,718,295,1063,302,320,159,804,819,1070,242,130,273,734,623,763,590,812,994,1023,525,683,326,943,799,438,947,777,10,155,818,1034,971,446,458,1064,77,956,168,158,720,258,558,800,786,581,99,218,269,1027,744,284,975,569,521,726,986,858,345,970,185,780,1,546,111,353,60,1042,835,834,563,112,246,475,981,610,502,707,415,249,203,277,557,1050,977,589,748,221,234,176,241,172,607,515,624,240,1009,747,987,642,418,1053,247,893,854,315,461,621,306,925,728,794,109,580,690,1014,69,899,369,680,399,662,578,332,1035,457,938,932,417,403,381,706,965,1019,878,288,433,1040,669,612,948,630,1074,810,57,670,629,194,980,585,293,1003,659,856,826,924,162,587,156,873,752,957,837,367,181,395,214,1072,742,678,791,356,253,552,512,504,767,993,19,294,973,652,409,917,877,101,59,146,774,46,78,115,422,699,377,603,24,255,283,459,505,960,477,150,883,339,520,860,177,413,348,984,625,201,644,429,184,764,436,171,1000,431,2,40,33,56,285,496,974,770,921,798,226,738,753,317,940,538,335,820,310,796,930,894,124,871,290,456,179,710,1022,990,217,634,439,355,215,887,286,548,213,63,615,136,1059,1043,42,252,857,886,107,402,479,85,416,106,1056,466,64,41,908,303,119,724,209,896,939,173,486,188,787,697,276,1051,907,49,582,628,1065,853,1010,370,719,329,733,257,169,1024,371,1025,430,696,37,1011,499,833,166,445,783,27,216,1005,1061,321,143,92,93,713,676,272,757,1078,978,400,814,650,123,897],[947,537,314,141,280,551,202,922,59,773,367,339,797,234,926,826,17,749,836,114,267,901,337,387,523,217,58,649,834,67,301,1055,833,31,193,738,686,903,37,460,54,503,795,758,353,192,145,388,399,246,735,701,255,990,448,162,995,215,781,1009,762,402,334,579,786,331,876,1030,666,760,935,634,1057,842,958,611,1017,81,205,571,55,104,528,684,383,825,896,359,547,170,1027,700,514,905,852,90,111,960,129,963,511,1054,329,785,128,661,685,468,712,1011,115,210,1041,112,1065,927,609,412,27,455,918,456,429,681,75,522,915,168,1006,360,724,361,147,959,43,737,1021,912,985,299,222,677,565,172,521,610,792,853,437,226,971,484,730,419,158,691,602,398,11,692,741,899,1003,501,313,854,308,51,85,605,259,258,194,780,48,805,739,1023,66,752,3,669,1013,986,166,950,606,550,95,389,1059,968,281,365,221,227,100,708,558,676,499,557,392,878,564,767,110,385,127,931,563,441,816,502,975,597,721,7,806,142,230,485,247,296,1062,472,352,369,216,981,720,467,671,489,695,632,9,849,435,324,414,845,333,1069,94,242,614,321,208,787,452,920,298,97,41,659,118,989,1061,885,944,393,764,179,185,987,567,174,589,815,627,28,271,976,86,214,766,970,263,651,431,357,425,1000,880,543,949,257,376,434,1036,463,925,310,883,667,777,380,82,980,653,471,430,532,967,731,1015,136,438,838,846,233,745,124,525,207,804,1035,1025,658,182,714,593,330,961,137,1080,539,1077,955,62,790,869,929,454,206,675,198,497,747,811,774,1007,480,704,391,996,568,646,744,140,814,239,61,892,494,496,608,52,132,934,297,943,566,994,105,837,309,56,796,965,733,1020,89,293,626,791,688,290,8,465,44,932,163,349,895,328,828,490,1042,1031,440,753,624,57,993,803,103,381,275,1018,108,122,618,638,96,864,212,171,613,512,404,868,941,584,190,631,509,79,461,24,592,540,106,1076,954,218,729,924,394,902,459,917,783,491,154,1038,562,888,983,320,673,231,498,689,175,625,400,88,582,678,101,92,424,21,654,670,820,161,506,697,808,696,761,364,870,515,771,702,569,33,555,1044,526,956,693,26,793,487,236,1050,900,992,238,644,650,715,1066,350,113,1012,268,750,662,181,488,199,1022,78,813,18,444,269,535,178,229,946,680,829,346,843,746,601,38,285,856,674,279,703,186,433,835,408,534,204,228,355,973,420,570,150,421,940,713,682,245,476,413,544,436,580,921,46,951,466,248,315,358,1024,998,12,728,690,307,999,1064,1063,1071,327,254,35,10,250,945,159,153,177,588,344,64,598,861,628,332,710,726,894,220,620,898,784,1060,382,1074,776,779,191,49,107,265,2,936,622,772,30,225,559,719,439,748,189,274,633,1028,911,599,362,906,213,397,1016,409,1033,841,913,151,516,83,799,165,1014,556,417,839,130,617,879,25,782,507,470,123,1037,68,939,860,520,294,581,116,93,342,636,858,908,232,865,4,1049,74,458,635,1051,451,812,495,717,727,157,282,453,264,69,560,910,292,22,648,403,418,942,561,1039,201,997,641,549,243,164,135,445,647,679,493,948,982,384,19,32,390,374,756,156,668,889,572,778,486,372,705,595,306,513,891,952,930,893,1029,831,102,34,707,405,823,366,851,769,39,969,709,594,510,639,824,977,672,736,36,197,432,224,988,492,63,91,742,542,630,42,47,469,872,1068,505,536,378,347,335,1002,266,289,518,699,422,302,109,363,253,548,619,607,343,295,473,160,316,553,73,300,180,449,284,457,260,1070,6,450,45,775,203,188,256,319,121,1072,862,877,16,857,305,477,379,169,652,291,866,173,819,395,923,1045,740,587,1067,447,928,583,629,755,907,249,665,40,341,139,196,863,283,882,859,98,272,1047,474,77,810,200,348,751,984,322,578,759,1008,411,446,817,311,1,585,15,427,531,99,323,554,694,407,886,909,155,711,270,621,504,148,146,345,237,706,575,991,401,802,827,637,916,591,855,807,87,765,867,464,743,1005,209,117,261,187,541,663,244,251,303,723,278,410,195,176,545,890,657,1079,524,871,966,277,475,53,144,149,370,396,800,1052,423,241,573,276,219,240,789,80,120,768,416,134,340,235,574,29,1010,732,933,72,133,612,734,415,1019,252,873,131,1073,223,718,698,546,462,71,351,725,801,167,184,76,262,847,757,914,65,884,84,1026,530,152,1034,953,722,957,937,962,683,508,125,183,23,312,1058,529,428,604,615,887,119,138,1040,798,716],[706,787,839,498,744,789,301,1039,239,440,961,692,420,556,136,608,855,179,330,244,1079,64,249,1052,621,340,716,302,319,984,762,834,568,884,520,432,28,792,1004,1061,166,311,583,21,1043,691,770,102,181,428,19,910,458,560,711,1042,292,528,1018,878,491,538,575,1022,381,324,486,373,646,251,99,1015,445,475,903,531,584,60,836,221,140,1078,864,790,765,631,488,504,198,414,449,132,1044,453,459,840,684,68,34,401,298,974,594,371,50,738,1014,131,870,707,655,89,571,163,87,1035,651,24,586,210,1074,752,204,465,718,932,355,187,79,97,901,80,220,395,438,977,580,405,336,672,297,1013,605,408,189,682,460,1001,939,378,169,822,775,211,115,869,980,227,818,966,410,316,547,722,145,1032,713,524,48,263,383,710,429,947,500,619,483,786,439,668,44,1010,31,526,515,82,618,745,970,354,587,719,610,771,928,810,358,847,404,207,930,170,335,168,527,107,669,788,313,800,915,835,485,241,294,1057,1064,390,746,1053,229,674,144,1065,1069,322,613,761,949,656,774,1,267,282,551,603,897,195,936,846,285,276,523,499,377,497,607,281,1037,784,484,1034,435,295,702,478,16,1009,589,522,956,323,213,971,365,760,14,41,764,172,985,8,84,1020,257,203,1066,321,579,570,1011,592,597,863,615,778,250,887,105,127,574,647,1027,300,828,690,134,242,652,1063,591,1054,906,714,665,135,78,842,326,372,1055,411,266,553,759,952,801,986,446,208,200,865,734,982,350,487,363,582,992,197,464,1007,811,352,937,600,325,507,389,288,879,218,433,905,289,11,108,677,367,767,533,962,331,559,749,518,74,1038,157,612,37,304,274,838,858,81,791,226,649,100,196,480,624,293,407,637,332,341,56,989,167,1016,667,633,1071,920,46,871,688,143,898,678,147,119,431,626,1041,158,409,62,437,7,854,676,780,1046,632,493,640,1012,755,151,317,474,833,807,70,51,101,52,967,889,627,201,581,334,545,881,725,434,114,342,625,1023,230,110,185,927,18,973,29,795,264,620,696,512,812,543,1026,180,148,886,748,942,875,940,279,462,929,345,680,154,816,519,1059,161,260,223,308,1080,129,479,36,423,925,139,904,797,232,963,47,277,981,111,33,751,61,259,65,933,269,542,1062,39,868,216,687,724,683,54,152,403,628,32,338,387,305,549,112,785,235,729,186,517,673,137,1049,193,72,1024,563,695,723,781,240,492,138,422,916,219,739,913,917,206,71,599,572,508,328,813,1019,803,2,837,466,953,436,290,666,273,184,380,190,470,979,1005,128,192,814,149,369,634,443,893,356,49,374,231,510,188,59,894,598,890,968,450,5,347,1050,740,191,685,697,699,1070,874,92,645,104,1040,995,481,376,769,892,883,261,694,918,850,934,314,23,13,296,772,653,912,616,254,398,768,177,622,636,337,173,557,209,689,660,69,270,85,419,425,1031,35,91,943,891,862,406,670,75,853,565,857,225,536,849,476,382,156,931,741,1008,859,975,22,159,495,142,349,1000,146,183,794,657,45,525,26,798,1029,779,73,174,671,709,704,663,805,611,848,224,238,299,860,529,368,648,708,344,83,202,629,122,397,150,117,399,766,106,178,954,630,375,473,95,827,820,402,477,844,502,806,199,541,705,418,456,329,880,782,1058,941,997,1003,546,642,141,1075,693,309,66,1006,505,394,1067,258,228,856,558,721,94,1030,809,280,248,463,830,1048,457,650,120,1051,126,960,393,888,3,388,236,872,339,773,77,946,357,654,53,998,899,737,359,113,990,160,726,361,802,540,561,391,175,346,256,552,754,320,272,468,417,736,253,370,753,867,15,727,539,9,1045,121,1077,882,825,265,923,550,194,222,20,757,38,103,310,601,576,957,720,1072,866,819,444,909,964,25,17,664,826,851,569,614,171,703,268,275,494,717,469,416,27,513,284,471,165,412,116,959,824,733,1036,58,130,644,40,315,1073,996,93,472,885,6,384,125,938,243,217,609,965,815,681,728,715,596,735,935,1047,489,566,534,994,701,327,364,442,176,451,983,448,1076,908,564,623,907,712,978,452,396,945,1021,1017,252,67,590,96,951,348,215,379,698,386,1002,496,461,306,641,4,758,155,808,12,944,783,573,658,501,578,482,76,843,976,554,353,924,385,283,307,516,42,455,914,286,955,638,588,841,424,1028,804,606,430,214,861,182,895,548,1025,333,90,233,351,291,643,922,602,506,577,212,467,902,987,427,911,919,303,509,993,593,530,763,262,415,756,661,237,742,164,896],[351,547,170,421,548,693,423,457,221,519,12,634,589,270,836,302,314,614,1060,523,1023,1058,494,818,846,984,208,178,748,914,429,478,967,291,394,48,715,77,725,75,206,268,250,73,225,399,606,372,517,903,605,890,1033,538,803,333,226,395,698,884,680,937,402,49,201,650,442,462,234,565,120,946,778,326,46,549,923,651,64,292,34,1072,322,542,826,347,256,246,858,689,909,687,410,752,475,664,612,654,839,94,809,918,439,123,785,272,880,814,1021,864,740,112,424,905,446,278,236,392,216,438,958,876,175,928,933,883,82,935,686,822,938,260,945,1009,510,17,371,223,751,1079,789,126,871,168,452,703,489,247,667,35,85,848,920,229,74,917,940,970,101,960,872,143,210,105,176,320,51,844,684,266,41,969,503,962,529,716,1067,954,288,507,342,766,952,43,509,607,76,829,712,98,961,943,596,167,83,578,146,786,528,337,18,380,87,273,655,994,910,603,856,197,592,964,391,911,757,42,341,521,681,904,594,470,84,305,373,971,527,1027,714,78,1039,782,211,869,501,228,113,772,998,579,1076,569,731,632,453,145,1029,148,38,235,1063,750,461,186,566,364,93,279,1020,344,28,863,673,563,708,635,942,859,390,1032,252,995,544,386,907,653,617,479,263,271,870,408,661,956,543,690,567,436,460,604,261,330,1040,820,709,899,1075,758,132,405,60,301,484,142,645,481,824,976,825,665,704,502,1007,498,615,817,1046,325,879,1037,374,993,706,746,1012,289,983,627,679,732,949,50,798,22,808,259,138,727,769,591,799,454,155,265,80,334,979,564,505,643,100,220,593,435,1073,773,25,70,90,582,685,466,150,171,807,188,924,1043,88,11,532,359,459,536,403,469,788,139,55,619,558,741,59,1006,426,842,6,56,187,953,957,193,932,485,965,620,393,671,196,1004,293,258,683,383,623,471,977,901,286,440,433,222,1070,739,240,1024,941,554,160,124,128,473,624,144,369,31,152,628,318,697,61,451,19,119,912,934,656,68,203,79,456,353,352,1048,526,184,420,39,232,141,297,926,304,121,328,887,147,1025,67,356,610,853,531,576,275,218,1050,493,657,626,387,1028,255,718,249,968,102,514,891,774,793,1051,873,313,925,14,639,199,804,190,702,496,816,65,939,670,30,282,29,465,621,269,616,908,251,828,294,886,783,117,728,539,835,546,821,812,691,4,756,58,295,366,1069,1041,641,1002,448,675,948,450,552,312,813,771,504,662,738,710,636,96,346,350,181,135,590,336,647,682,922,990,151,1049,644,40,831,765,787,919,944,116,1026,316,360,811,107,156,455,561,768,973,463,1055,109,1008,975,354,280,518,495,801,1035,577,1047,5,660,45,692,1036,761,389,637,707,1001,878,1042,701,281,164,672,425,15,557,215,806,916,915,719,1018,972,298,790,276,66,396,659,866,800,781,570,560,512,205,638,580,625,500,245,127,574,524,1022,744,97,174,357,338,412,1052,897,745,613,136,233,535,348,345,893,497,340,37,981,837,7,99,416,468,630,759,307,230,231,553,3,860,852,331,797,588,520,1015,1038,303,688,830,349,1054,129,89,472,1034,499,874,368,819,640,200,71,815,763,721,622,980,162,796,658,401,895,192,153,1044,784,571,397,422,700,486,530,370,843,506,477,841,244,237,633,1062,134,648,537,668,581,241,992,445,315,474,343,157,32,729,413,534,95,513,545,219,267,631,110,711,906,379,720,767,212,734,10,306,629,417,414,140,131,986,753,36,987,409,608,666,646,428,2,130,780,840,726,217,1053,169,770,791,1019,827,776,652,1005,277,53,177,559,736,618,556,1056,1,861,743,978,832,587,1030,449,16,296,723,997,699,54,103,849,889,198,541,339,335,696,1064,555,319,611,913,754,974,158,760,927,214,299,1080,20,525,398,802,875,881,480,195,407,792,411,24,309,533,378,443,183,63,81,44,988,482,950,23,575,355,108,850,47,963,742,327,810,755,122,597,166,550,834,845,609,323,1061,775,447,431,1057,287,358,182,432,490,62,598,1066,382,930,551,283,892,1000,69,213,149,865,779,823,376,777,191,867,854,33,877,253,332,194,1071,434,955,888,1013,106,898,26,444,427,361,540,159,868,855,114,86,1017,959,262,476,991,285,838,695,488,404,663,137,111,329,1010,1074,882,418,562,362,894,13,595,1003,172,857,290,966,900,602,243,851,207,406,585,1059,209,72,388,492,508,133,9,921,1014,762,1011,458,365,805,375,951,311,308,1078,1031,642,367,467,896,982,264,254,747,862,104],[419,458,408,316,213,968,96,950,755,35,990,778,743,634,718,150,807,970,304,475,268,693,874,265,125,394,281,1055,414,783,933,24,1044,897,651,658,889,423,82,535,994,135,908,919,38,527,171,285,701,621,1052,787,1051,885,257,84,260,500,729,821,69,409,534,155,864,590,570,234,927,644,320,229,64,993,127,989,643,71,565,789,557,978,157,626,581,321,461,828,184,768,977,1056,377,647,522,940,1022,751,769,106,358,700,172,66,541,760,158,736,986,270,898,3,439,1064,367,140,363,1026,659,704,252,931,913,197,809,177,610,453,698,767,200,420,619,2,411,1000,182,727,1021,427,591,311,287,310,687,53,288,1049,1024,405,1007,1075,118,379,431,753,141,34,446,258,771,692,671,758,991,691,1013,613,795,748,694,784,706,571,376,639,796,480,312,785,21,703,886,132,259,942,853,149,585,61,1061,413,117,971,442,68,963,633,162,776,269,1050,437,153,401,747,390,843,79,537,114,163,283,397,143,385,772,593,203,479,548,426,823,754,558,224,733,550,181,624,349,685,333,739,152,899,373,559,329,584,530,486,105,605,325,404,18,872,443,793,36,672,756,794,51,858,909,520,792,245,937,608,23,173,816,763,142,73,483,360,834,382,97,126,827,510,1067,631,1039,538,384,953,922,468,1001,719,216,1012,119,676,104,1023,818,815,637,131,488,589,1073,463,511,766,1003,930,662,289,429,770,516,359,888,417,583,730,925,386,410,217,235,625,323,780,554,551,985,80,737,421,254,524,144,936,609,797,673,840,749,533,93,306,1016,313,837,46,984,721,391,866,315,70,251,378,601,284,588,845,326,276,677,91,491,594,460,503,880,448,1048,646,808,103,199,975,865,72,374,542,212,338,660,327,1009,611,686,100,777,596,176,735,244,526,876,261,498,55,906,655,418,37,905,193,240,81,661,921,762,863,738,574,723,641,303,451,742,271,58,456,952,764,368,122,1015,667,740,255,566,348,528,1042,98,539,495,804,375,487,5,939,1025,824,39,509,884,324,445,102,482,219,618,111,90,861,191,599,918,485,817,825,204,682,765,1063,800,926,833,914,519,1028,728,50,636,949,848,428,247,710,683,129,1032,1066,855,656,657,839,241,568,14,910,988,564,502,663,781,398,969,791,775,1036,232,521,357,29,664,580,757,222,242,94,869,489,707,250,892,393,582,112,948,297,851,912,402,57,400,190,712,759,433,1065,929,469,904,202,983,262,725,844,877,415,89,1019,115,1005,330,291,493,318,966,665,174,517,1074,109,945,165,17,388,616,231,956,205,576,629,78,1,335,1043,1029,1011,478,734,435,715,248,33,280,220,266,1057,943,761,507,561,425,52,506,1006,25,1070,544,669,476,732,895,577,336,145,296,805,432,689,1047,543,301,532,946,279,1046,361,746,798,955,136,189,277,221,504,1008,32,870,403,121,1020,812,381,175,642,484,366,139,179,678,902,607,773,430,552,998,466,65,345,714,473,492,960,95,1062,688,31,501,849,518,648,923,932,196,862,684,210,623,774,724,380,592,540,650,43,128,980,668,868,192,553,267,151,110,560,911,314,273,782,1058,227,1069,961,595,137,597,997,1018,183,675,194,750,67,578,1072,645,1038,347,788,832,138,702,290,449,465,696,383,959,887,444,873,278,459,709,979,353,494,462,286,1059,396,471,133,239,364,802,9,882,253,549,569,406,900,16,27,1068,441,801,12,481,838,62,308,424,452,941,499,201,215,803,300,1035,563,13,836,370,101,354,146,198,514,74,147,512,334,42,586,875,497,670,15,455,779,603,612,924,883,166,741,178,233,547,161,341,1054,1017,40,116,1041,573,879,928,745,604,76,48,720,920,120,211,86,614,392,467,1045,186,713,531,187,352,263,810,464,752,457,302,907,226,1079,996,628,195,620,635,412,830,916,342,1077,813,627,947,846,395,1030,474,602,344,45,230,275,567,185,130,954,20,22,881,515,680,814,331,847,209,305,350,387,555,156,60,54,513,822,967,598,236,389,164,622,264,1076,218,272,188,298,399,934,339,711,206,328,786,56,332,690,83,362,871,860,819,974,49,317,579,976,4,41,454,1034,371,878,85,726,681,799,1014,640,168,850,159,962,652,896,470,436,992,695,826,615,148,11,225,699,995,99,806,180,1027,938,1071,546,44,523,346,829,496,447,944,309,416,556,716,238,854,717,356,697,10,964,903,228,214,274,47,223,972,134,1031,256,835,856,19,170,1037,63,572,243,123,169,337,107,322,617,1004,852,638,1078,1033,958,575,369],[341,855,6,292,128,138,266,885,786,581,679,758,72,669,864,950,804,708,973,442,696,110,872,383,114,1006,854,761,2,947,252,483,249,818,863,401,95,222,625,224,368,386,82,905,948,764,999,419,381,188,242,371,393,556,658,464,372,271,580,239,88,569,18,294,869,176,674,20,803,296,531,939,91,351,229,31,1041,513,171,8,7,1019,741,108,755,147,530,330,11,206,714,578,747,675,145,1063,815,1068,688,432,70,382,507,452,190,703,323,1057,79,978,743,1070,956,468,837,25,132,921,565,783,667,672,604,865,789,219,847,887,470,21,554,498,734,582,637,390,895,66,920,496,1038,497,800,19,509,900,630,851,964,739,749,466,205,955,616,340,931,773,53,726,722,681,30,60,631,731,141,1,1054,1015,475,1002,22,54,535,785,491,732,600,228,906,314,356,904,326,870,144,896,629,90,610,279,503,878,597,890,265,796,608,482,923,394,407,1018,1010,1024,915,979,380,312,106,255,1009,514,526,568,1030,120,671,611,547,910,842,149,152,299,769,214,220,746,282,80,208,23,820,346,83,59,1075,944,447,413,406,997,1067,29,28,1022,558,977,322,161,974,336,666,840,115,107,233,358,908,216,437,716,583,971,771,822,1031,663,936,154,375,861,263,805,230,399,112,207,329,360,160,646,96,493,605,733,1047,767,634,295,288,337,938,37,1004,693,97,440,344,213,1025,501,812,792,362,533,807,283,325,178,453,961,1007,686,61,695,806,262,553,676,588,776,779,957,370,986,172,1011,791,492,1003,454,472,3,687,774,613,564,729,665,260,826,319,641,846,572,418,691,528,532,996,69,951,335,182,197,307,640,289,1049,990,833,965,89,832,891,877,925,609,55,416,490,860,129,1060,699,354,278,166,587,350,874,827,644,17,168,422,320,443,981,1066,467,712,520,148,240,557,784,67,980,505,459,92,10... 372517 more chars",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long solve(vector<vector<int>>& points,int x,int y,int n,int m,vector<vector<long long>>&dp){\\n        \\n        if(x==n){\\n            return 0;\\n        }\\n        \\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        long long ans=INT_MIN;\\n        for(int j=0;j<m;j++){\\n            if(dp[x][j]!=-1){\\n                ans=max(dp[x][j]-abs(j-y),ans);\\n            }\\n            else{\\n                ans=max(ans,points[x][j]+solve(points,x+1,j,n,m,dp)-abs(y-j));\\n            }\\n            \\n        }\\n        \\n        return dp[x][y]=ans;\\n        \\n    }  \\n    \\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        int n=points.size();\\n        int m=points[0].size();\\n        \\n        long long ans=INT_MIN;\\n        \\n        vector<vector<long long>>dp(n , vector<long long> (m, -1));\\n        \\n        for(int j=0;j<m;j++){\\n            dp[0][j]=points[0][j]+solve(points,1,j,n,m,dp);\\n            ans=max(dp[0][j],ans);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344902,
                "title": "python-two-way-with-example",
                "content": "### Largest Sum without In-row Movement\\nFor example, we have a (i + 1) by 3 matrix with two consecutive rows i and i+1 as follow:\\n```\\n...\\n1   3   9\\n4   2   9\\n...\\n```\\n\\nWe can understand the last row [4, 2, 9] as **the largest sums starting from each unit and moving downards(with no in-row movement)**. This largest sums with no in-row movement only equals to the unit points at the last row as there is no more rows downards.\\n\\n### Largest Sum with In-row Movement\\n\\nNow we take the in-row movement into consideration. We observe that reaching the unit `(i + 1, 1)` with `2` points is equivalent to reaching a unit with `8` points, as we can move to `(i + 1, 2)` using one step and get `9 - 1 = 8` points. \\n```\\n1   3   9\\n4   2-> 9\\n```\\n```\\n1   3   9\\n4   8   9\\n```\\nSimilarly, `(i+1, 0)` is equivalent to a unit with point 7:\\n```\\n1   3   9\\n4-> 8   9\\n```\\n```\\n1   3   9\\n7   8   9\\n```\\nEventually we get an array `[7, 8, 9]` where `7` means that the largest sum we can get starting from `(i+1, 0)` is `7` considering in-row movement.\\n\\nA general way to compute this largest sum is to scan from left to right and then from right to left with a size-2 window:\\n\\n1) We first consider 4 and 2 on the last row. We found that 2 is equivalent to 3 as `4 - 1 == 3 > 2`. We update the local optimial points as:\\n`(4 -> 2) 9 => 4, 3, 9`\\n\\n2) We then consider if 9 can be replaced with 3 - 1, as `3 - 1 < 9`, so we keep the points:\\n`4 (3 -> 9) => 4, 3, 9`\\n\\n3) We do the same thing from right to left, and we get:\\n`4 (3 <- 9) => 4, 8, 9`\\n\\n4) and\\n`(4 <- 8) 9 => 7, 8, 9`\\n\\n3. If we are at the `i`th row, we can first compute **Largest Sum without In-row Movement**, which is simply adding the points of the current unit and the **Largest Sum with In-row Movement** we got for the `i+1`th row:\\n```\\n1  3  9   ==>  8  11  18\\n^  ^  ^   \\n7  8  9\\n```\\n\\nRepeating above steps until the top row, and select the unit with the largest value.\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m = len(points)\\n        n = len(points[0])\\n        v_max = [0] * n\\n        \\n        for r in range(m):\\n            p = points[r]\\n            for c in range(n):\\n                v_max[c] += p[c]\\n            \\n            # left to right\\n            for cl in range(n - 1):\\n                cr = cl + 1\\n                v_max[cr] = max(v_max[cl] - 1, v_max[cr])\\n\\n            # right to left\\n            for cr in range(n - 1):\\n                cr = n - 1 - cr\\n                cl = cr - 1\\n                v_max[cl] = max(v_max[cr] - 1, v_max[cl])\\n        \\n        return max(v_max)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n...\\n1   3   9\\n4   2   9\\n...\\n```\n```\\n1   3   9\\n4   2-> 9\\n```\n```\\n1   3   9\\n4   8   9\\n```\n```\\n1   3   9\\n4-> 8   9\\n```\n```\\n1   3   9\\n7   8   9\\n```\n```\\n1  3  9   ==>  8  11  18\\n^  ^  ^   \\n7  8  9\\n```\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m = len(points)\\n        n = len(points[0])\\n        v_max = [0] * n\\n        \\n        for r in range(m):\\n            p = points[r]\\n            for c in range(n):\\n                v_max[c] += p[c]\\n            \\n            # left to right\\n            for cl in range(n - 1):\\n                cr = cl + 1\\n                v_max[cr] = max(v_max[cl] - 1, v_max[cr])\\n\\n            # right to left\\n            for cr in range(n - 1):\\n                cr = n - 1 - cr\\n                cl = cr - 1\\n                v_max[cl] = max(v_max[cr] - 1, v_max[cl])\\n        \\n        return max(v_max)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372089,
                "title": "javascript-clear-explanation",
                "content": "This solution uses the left and right arrays that you might have read elsewhere. \\nI will try my best to help you understand the mental model. \\n\\nUsing the case `points = [[1,2,3],[1,5,1],[3,1,1]]`, and `output = 9`\\n\\n\\nWe start from index 1 (second row) , and we\\'re always looking up\\nSo starting at index `[1,0]`, we ask ourself, what is the max value from the previous row? \\n\\nWe\\'ll initialize, `let prev = points[0]`, which gives us `[1,2,3]`, \\nwhen I am at `[1,0]`, the max value from prev (but only looking left, is 1) \\nWhen I am at `[1,1]`, the values that I can look towards are `1,2`\\nWhen I\\'m at `[1,2]`, the values I can look left towards are now 1,2,3\\n![image](https://assets.leetcode.com/users/images/a6f86516-183c-4765-8711-83530b1e707b_1627640557.1900415.png)\\n\\n![image](https://assets.leetcode.com/users/images/c5c583fe-8f97-4899-8178-5909167c0ae3_1627640557.2031465.png)\\n![image](https://assets.leetcode.com/users/images/56bb71fd-cc25-4b96-ad5d-63e802b79b71_1627640557.1651108.png)\\n\\nSolution\\n```\\nvar maxPoints = function(points) {\\n    let prev = points[0]; \\n    let curr = Array(points[0].length); \\n    \\n    for(let i = 1; i<points.length; i++){\\n        \\n        // from left to right; \\n        for(let j = 0, maxAdd=0; j<points[0].length;j++){\\n            maxAdd = Math.max(maxAdd-1, prev[j]);\\n            curr[j] = points[i][j] + maxAdd;\\n        }\\n        \\n        for(let j = points[0].length-1, maxAdd = 0; j>=0; j--){\\n            maxAdd = Math.max(maxAdd-1, prev[j]);\\n            curr[j] = Math.max(curr[j], points[i][j] + maxAdd)\\n        }\\n        \\n        \\n        prev = curr; \\n        curr = Array(points[0].length)\\n        \\n    }\\n    return Math.max(...prev)\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxPoints = function(points) {\\n    let prev = points[0]; \\n    let curr = Array(points[0].length); \\n    \\n    for(let i = 1; i<points.length; i++){\\n        \\n        // from left to right; \\n        for(let j = 0, maxAdd=0; j<points[0].length;j++){\\n            maxAdd = Math.max(maxAdd-1, prev[j]);\\n            curr[j] = points[i][j] + maxAdd;\\n        }\\n        \\n        for(let j = points[0].length-1, maxAdd = 0; j>=0; j--){\\n            maxAdd = Math.max(maxAdd-1, prev[j]);\\n            curr[j] = Math.max(curr[j], points[i][j] + maxAdd)\\n        }\\n        \\n        \\n        prev = curr; \\n        curr = Array(points[0].length)\\n        \\n    }\\n    return Math.max(...prev)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2078142,
                "title": "c-dp-concept-explainations-by-comments",
                "content": "```\\n/**\\n * @brief \\n * Select a value in each row that will maximize the total value.\\n * However, we will lose points, for every two adjacent rows r and r + 1 (where 0 <= r < m - 1), \\n * picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score.\\n * \\n * @algo1 bruce force \\n *  Using recursion backtrack, bruce force for every possible answer combination\\n *  Time O(m^n)\\n *  Space O(max(m, n))\\n * \\n * @algo2 DP\\n *  We can set the matrix into multiple sub-matrixs. \\n *  For example, let\\'s see the first 2 row, the answer will not be affected below, we can find the best value for row 2.\\n *  Then we pass it as a dp record for row 3 to decide the best answer in row 3.\\n * \\n *  The new row will have to loop through the prev row to get the value\\n *  Time O(m*n*n)\\n *  Space O(m*n)\\n * \\n *  [Improve the space] using 1D container to finish the executions.\\n *  Space O(n)\\n *\\n * @algo3 DP time improvement\\n *  Can we improve it to Time O(m*n)? Try to get the previous row max in O(1).\\n * \\n *  As a dp concept, consider (i,j), we can record the max from j to left, and j to right with two containers.\\n *  Then do not forget to calculate the shift.\\n * \\n *  After counting the left, right container.\\n *  We can easily to count the sum(i+1,j) as the points(i+1,j) + max(left, right);\\n * \\n *  Time O(m*n)\\n *  Space O(n)\\n */\\n\\n// algo 3\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int row = points.size();\\n        if(row == 0) {\\n            // emtpy array\\n            return 0;\\n        }\\n\\n        int col = points[0].size();\\n\\n        vector<long long> dp(points[0].begin(), points[0].end());\\n        vector<long long> left(col);\\n        vector<long long> right(col);\\n\\n        for(int i=1; i<row; i++) {\\n            left.front() = dp.front();\\n            for(int j=1; j<col; j++) {\\n                // left[j-1]-1, the minus 1 counts the shift\\n                left[j] = max(dp[j], left[j-1]-1); \\n            }\\n\\n            right.back() = dp.back();\\n            for(int j=col-2; j>=0; j--) {\\n                right[j] =  max(dp[j], right[j+1]-1);\\n            }\\n\\n            for (int j=0; j<col; j++) {\\n                dp[j] = points[i][j] + max(left[j], right[j]);\\n            }\\n        }\\n\\n        return max_element(dp.begin(), dp.end());\\n    }\\n};\\n\\n// algo 2\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        long long ans = 0;\\n        int row = points.size();\\n        if(row == 0) {\\n            // emtpy array\\n            return ans;\\n        }\\n\\n        int col = points[0].size();\\n        vector<long long> dp(col);\\n\\n        for(int j=0; j<col; j++) {\\n            // copy first row\\n            dp[j] = points[0][j];\\n            ans = max(ans, dp[j]);\\n        }\\n\\n        for(int i=1; i<row; i++) {\\n            vector<long long> prev(dp);\\n            for(int j=0; j<col; j++) {\\n                long long temp = 0;\\n                for(int k=0; k<col; k++) {\\n                    temp = max(temp, points[i][j] + prev[k] - abs(k-j));\\n                }\\n                dp[j] = temp;\\n                ans = max(ans,dp[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @brief \\n * Select a value in each row that will maximize the total value.\\n * However, we will lose points, for every two adjacent rows r and r + 1 (where 0 <= r < m - 1), \\n * picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score.\\n * \\n * @algo1 bruce force \\n *  Using recursion backtrack, bruce force for every possible answer combination\\n *  Time O(m^n)\\n *  Space O(max(m, n))\\n * \\n * @algo2 DP\\n *  We can set the matrix into multiple sub-matrixs. \\n *  For example, let\\'s see the first 2 row, the answer will not be affected below, we can find the best value for row 2.\\n *  Then we pass it as a dp record for row 3 to decide the best answer in row 3.\\n * \\n *  The new row will have to loop through the prev row to get the value\\n *  Time O(m*n*n)\\n *  Space O(m*n)\\n * \\n *  [Improve the space] using 1D container to finish the executions.\\n *  Space O(n)\\n *\\n * @algo3 DP time improvement\\n *  Can we improve it to Time O(m*n)? Try to get the previous row max in O(1).\\n * \\n *  As a dp concept, consider (i,j), we can record the max from j to left, and j to right with two containers.\\n *  Then do not forget to calculate the shift.\\n * \\n *  After counting the left, right container.\\n *  We can easily to count the sum(i+1,j) as the points(i+1,j) + max(left, right);\\n * \\n *  Time O(m*n)\\n *  Space O(n)\\n */\\n\\n// algo 3\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int row = points.size();\\n        if(row == 0) {\\n            // emtpy array\\n            return 0;\\n        }\\n\\n        int col = points[0].size();\\n\\n        vector<long long> dp(points[0].begin(), points[0].end());\\n        vector<long long> left(col);\\n        vector<long long> right(col);\\n\\n        for(int i=1; i<row; i++) {\\n            left.front() = dp.front();\\n            for(int j=1; j<col; j++) {\\n                // left[j-1]-1, the minus 1 counts the shift\\n                left[j] = max(dp[j], left[j-1]-1); \\n            }\\n\\n            right.back() = dp.back();\\n            for(int j=col-2; j>=0; j--) {\\n                right[j] =  max(dp[j], right[j+1]-1);\\n            }\\n\\n            for (int j=0; j<col; j++) {\\n                dp[j] = points[i][j] + max(left[j], right[j]);\\n            }\\n        }\\n\\n        return max_element(dp.begin(), dp.end());\\n    }\\n};\\n\\n// algo 2\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        long long ans = 0;\\n        int row = points.size();\\n        if(row == 0) {\\n            // emtpy array\\n            return ans;\\n        }\\n\\n        int col = points[0].size();\\n        vector<long long> dp(col);\\n\\n        for(int j=0; j<col; j++) {\\n            // copy first row\\n            dp[j] = points[0][j];\\n            ans = max(ans, dp[j]);\\n        }\\n\\n        for(int i=1; i<row; i++) {\\n            vector<long long> prev(dp);\\n            for(int j=0; j<col; j++) {\\n                long long temp = 0;\\n                for(int k=0; k<col; k++) {\\n                    temp = max(temp, points[i][j] + prev[k] - abs(k-j));\\n                }\\n                dp[j] = temp;\\n                ans = max(ans,dp[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971052,
                "title": "dp-python-with-explanation",
                "content": "To brute force this problem we find the max value at each row, column by comparing it to the previous row, column and factoring in the subtraction based on distance. One for each index.\\n\\nThis leads to an `O(M*N**2)` time complexity. \\n\\nExperience with this sort of problem tells us that there\\'s a dynamic programming solution that reduces the inner processing step to linear time.\\n\\nAssuming that we have a single row of size N to cache our results, we just have to come up with a memoization criteria. That criteria is as follows:\\n\\nEach dp[j] can be one of three values:\\n1) dp[j]\\n2) dp[j-1]-1\\n3) dp[j+1]+1\\n\\nMoreover, dp[j+1] can be:\\n1) dp[j+1]\\n2) dp[j]-1\\n3) dp[j+2]-1\\n\\nThis is because we know there\\'s a cost of 1 for every value we selected previously. And `max(dp[0]-j, dp[1]-(j-1),..,dp[j]..)` is the same as `max(max(dp[0]-j, dp[1]-(j-1),..,dp[j-1]-1), dp[j])`. So we only need to compare the current dp value to its neighbor as we\\'re iterating over the dp array.\\n\\nSo we just have to create a left to right dp array and a right to left dp array for every row and then take the max at each postion j and add it to the current point at points[i][j] to get the subsequent dp[j].\\n\\nThis leads to a time complexity of `O(M*N)` and a space complexity of `O(N)`.\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        M, N = len(points), len(points[0])\\n        left = [0] * N\\n        right = [0] * N\\n        dp = points[0]\\n        for i in range(1, M):\\n            # process from left to right\\n            for j in range(N):\\n                if j == 0:\\n                    left[0] = dp[0]\\n                else:\\n                    left[j] = max(dp[j], left[j-1]-1)\\n            # process from right to left\\n            for j in range(N-1,-1,-1):\\n                if j == N-1:\\n                    right[N-1] = dp[N-1]\\n                else:\\n                    right[j] = max(dp[j], right[j+1]-1)\\n            # set the new max points at each column based on the max of going\\n            # left to right vs right to left\\n            for j in range(N):\\n                dp[j] = points[i][j] + max(left[j], right[j])\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        M, N = len(points), len(points[0])\\n        left = [0] * N\\n        right = [0] * N\\n        dp = points[0]\\n        for i in range(1, M):\\n            # process from left to right\\n            for j in range(N):\\n                if j == 0:\\n                    left[0] = dp[0]\\n                else:\\n                    left[j] = max(dp[j], left[j-1]-1)\\n            # process from right to left\\n            for j in range(N-1,-1,-1):\\n                if j == N-1:\\n                    right[N-1] = dp[N-1]\\n                else:\\n                    right[j] = max(dp[j], right[j+1]-1)\\n            # set the new max points at each column based on the max of going\\n            # left to right vs right to left\\n            for j in range(N):\\n                dp[j] = points[i][j] + max(left[j], right[j])\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346573,
                "title": "javascript-easy-to-understand-o-m-n",
                "content": "```js\\nconst maxPoints = function(points) {\\n  const height = points.length;\\n  const width = points[0].length;\\n  \\n  // We only need to keep track of the current and previous rows\\n  let prev = points[0];\\n  let cur = Array(width);\\n  \\n  // Note that we start at the second row\\n  // We\\'re always looking one row up to find the max value we can add to any cell in the current row\\n  for (let i = 1; i < height; ++i) {\\n    \\n    // Make a pass from left to right\\n    // Keep track of a running max that you can add to the current cell\\n    // The running max has to decrement each iteration since it costs for each column of distance\\n    for (let j = 0, maxAdd = 0; j < width; ++j) {\\n      maxAdd = Math.max(maxAdd - 1, prev[j]);\\n      cur[j] = points[i][j] + maxAdd;\\n    }\\n    \\n    // Make a right to left pass, same idea as the first loop\\n    // For each cell, take the max(best sum from previous loop, best sum from current loop)\\n    for (let j = width - 1, maxAdd = 0; j >= 0; --j) {\\n      maxAdd = Math.max(maxAdd - 1, prev[j]);\\n      cur[j] = Math.max(cur[j], points[i][j] + maxAdd);\\n    }\\n    \\n    prev = cur;\\n    cur = Array(width);\\n  }\\n  \\n  // The last row we calculated will have all of our possible max sums\\n  return Math.max(...prev);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst maxPoints = function(points) {\\n  const height = points.length;\\n  const width = points[0].length;\\n  \\n  // We only need to keep track of the current and previous rows\\n  let prev = points[0];\\n  let cur = Array(width);\\n  \\n  // Note that we start at the second row\\n  // We\\'re always looking one row up to find the max value we can add to any cell in the current row\\n  for (let i = 1; i < height; ++i) {\\n    \\n    // Make a pass from left to right\\n    // Keep track of a running max that you can add to the current cell\\n    // The running max has to decrement each iteration since it costs for each column of distance\\n    for (let j = 0, maxAdd = 0; j < width; ++j) {\\n      maxAdd = Math.max(maxAdd - 1, prev[j]);\\n      cur[j] = points[i][j] + maxAdd;\\n    }\\n    \\n    // Make a right to left pass, same idea as the first loop\\n    // For each cell, take the max(best sum from previous loop, best sum from current loop)\\n    for (let j = width - 1, maxAdd = 0; j >= 0; --j) {\\n      maxAdd = Math.max(maxAdd - 1, prev[j]);\\n      cur[j] = Math.max(cur[j], points[i][j] + maxAdd);\\n    }\\n    \\n    prev = cur;\\n    cur = Array(width);\\n  }\\n  \\n  // The last row we calculated will have all of our possible max sums\\n  return Math.max(...prev);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344959,
                "title": "why-memoization-is-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long max(long long a,long long b){\\n        \\n        return a>b?a:b;\\n    }\\nvector<vector<long long>>dp;\\n    long long ret(vector<vector<int>>& points,int i,int pj){\\n        int m=points.size(),n=points[0].size();\\n        if(i>=m){\\n            return 0;\\n        }\\n        if(dp[i][pj]){\\n            return dp[i][pj];\\n        }\\n        long long tot=0;\\n            for(int j=0;j<n;j++){\\n              int temp=max(tot,points[i][j]-abs(j-pj)+ret(points,i+1,j));\\n                tot=max(tot,temp);\\n            }\\n        return dp[i][pj]=tot;\\n        }\\n        \\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        int m=points.size(),n=points[0].size();\\n        \\n         long long tot=0;\\n        dp.resize(m,vector<long long>(n));\\n\\n        \\n        for(int j=0;j<n;j++){\\n            tot=max(tot,points[0][j]+ret(points,1,j));\\n            \\n        }\\n      \\n        \\n        \\n        return tot;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long max(long long a,long long b){\\n        \\n        return a>b?a:b;\\n    }\\nvector<vector<long long>>dp;\\n    long long ret(vector<vector<int>>& points,int i,int pj){\\n        int m=points.size(),n=points[0].size();\\n        if(i>=m){\\n            return 0;\\n        }\\n        if(dp[i][pj]){\\n            return dp[i][pj];\\n        }\\n        long long tot=0;\\n            for(int j=0;j<n;j++){\\n              int temp=max(tot,points[i][j]-abs(j-pj)+ret(points,i+1,j));\\n                tot=max(tot,temp);\\n            }\\n        return dp[i][pj]=tot;\\n        }\\n        \\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        int m=points.size(),n=points[0].size();\\n        \\n         long long tot=0;\\n        dp.resize(m,vector<long long>(n));\\n\\n        \\n        for(int j=0;j<n;j++){\\n            tot=max(tot,points[0][j]+ret(points,1,j));\\n            \\n        }\\n      \\n        \\n        \\n        return tot;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344879,
                "title": "c-math-tc-o-m-n-sc-o-n-very-easily-readable",
                "content": "We have 45 degree mountains and we want to find the highest value among mountains for the current index j\\n\\ntmp is the current mountain we have. \\n\\n**Note: 45 degree would minus 1 height per j beyond current index**\\n\\n![image](https://assets.leetcode.com/users/images/83c3fa4d-763a-4fed-934a-2c4737afc4c6_1626581840.6866734.png)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int m = points.size(), n = points[0].size();\\n        vector<long long> tmp(n);\\n        for(int i = 0 ; i < m ; ++i){\\n            for(int j = 0 ; j < n; ++j) tmp[j] += points[i][j];\\n\\t\\t\\t//  45 degree would minus 1 height per j beyond current index\\n            for(int j = 1 ; j < n ; ++j)tmp[j] = max(tmp[j-1]-1, tmp[j]);\\n\\t\\t\\t//  45 degree would minus 1 height per j beyond current index\\n            for(int j = n-2 ; j >= 0; --j) tmp[j] = max(tmp[j+1]-1, tmp[j]);\\n        }\\n        return *max_element(begin(tmp),end(tmp));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int m = points.size(), n = points[0].size();\\n        vector<long long> tmp(n);\\n        for(int i = 0 ; i < m ; ++i){\\n            for(int j = 0 ; j < n; ++j) tmp[j] += points[i][j];\\n\\t\\t\\t//  45 degree would minus 1 height per j beyond current index\\n            for(int j = 1 ; j < n ; ++j)tmp[j] = max(tmp[j-1]-1, tmp[j]);\\n\\t\\t\\t//  45 degree would minus 1 height per j beyond current index\\n            for(int j = n-2 ; j >= 0; --j) tmp[j] = max(tmp[j+1]-1, tmp[j]);\\n        }\\n        return *max_element(begin(tmp),end(tmp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947800,
                "title": "python-top-down-memorization-o-mn-passes",
                "content": "Inspired by dp solutions I wanted to understand the recursive opproach as it\\'s sometimes more intuitive and helpful to get to the final dp solution. Note that even though the runtime complexity is O(mn) the space complexity is higher. non-recursive dp solutions usually allows better space optimization too.\\n\\n```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        M = len(points)\\n        N = len(points[0])\\n\\n        @cache\\n        def dp(r, c):\\n            if r == M - 1:\\n                return points[r][c]\\n            \\n            return points[r][c] + max(best_relative_right(r+1, c), best_relative_left(r+1, c))\\n        \\n        @cache\\n        def best_relative_left(r, c):\\n            \"\"\"Returns the best value to the left side seen so far\"\"\"\\n            \\n            if c == 0:\\n                return dp(r, c)\\n            return max(dp(r, c), best_relative_left(r, c-1) - 1)\\n        \\n        @cache\\n        def best_relative_right(r, c):\\n            \"\"\"Returns the best value to the right side seen so far\"\"\"\\n\\n            if c == N-1:\\n                return dp(r, c)\\n            return max(dp(r, c), best_relative_right(r, c+1) - 1)\\n        \\n        return max(dp(0, c) for c in range(N))\\n```\\n\\nTime complexity: O(mn)\\nSpace complexity: O(mn*3)",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        M = len(points)\\n        N = len(points[0])\\n\\n        @cache\\n        def dp(r, c):\\n            if r == M - 1:\\n                return points[r][c]\\n            \\n            return points[r][c] + max(best_relative_right(r+1, c), best_relative_left(r+1, c))\\n        \\n        @cache\\n        def best_relative_left(r, c):\\n            \"\"\"Returns the best value to the left side seen so far\"\"\"\\n            \\n            if c == 0:\\n                return dp(r, c)\\n            return max(dp(r, c), best_relative_left(r, c-1) - 1)\\n        \\n        @cache\\n        def best_relative_right(r, c):\\n            \"\"\"Returns the best value to the right side seen so far\"\"\"\\n\\n            if c == N-1:\\n                return dp(r, c)\\n            return max(dp(r, c), best_relative_right(r, c+1) - 1)\\n        \\n        return max(dp(0, c) for c in range(N))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669305,
                "title": "java-dp-brute-force-dp-solution",
                "content": "Brute force solution, and I got TLE:\\n\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long[][] dp = new long[points.length][points[0].length];\\n        for (int i = 0; i < points[0].length; i ++) {\\n            dp[0][i] = points[0][i];\\n        }\\n        \\n        for (int i = 1; i < points.length; i ++) {\\n            for (int j = 0; j < points[0].length; j ++) {\\n                long max = 0;\\n                for (int k = 0; k < points[0].length; k ++) {\\n                    max = Math.max(max, dp[i - 1][k] - Math.abs(j - k));\\n                }\\n                dp[i][j] = max + points[i][j];\\n            }\\n        }\\n        \\n        long result = 0;\\n        for (int i = 0; i < dp[dp.length - 1].length; i ++) {\\n            result = Math.max(result, dp[dp.length - 1][i]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n\\nDP solution w O(mn) time complexity and 0(n) space complexity\\n\\n```\\n\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long[] dp = new long[points[0].length];\\n        \\n        for (int i = 0; i < points.length; i ++) {\\n            for (int j = 0; j < points[0].length; j ++) {\\n                dp[j] += points[i][j];\\n            }\\n            \\n            for (int j = 1; j < dp.length; j ++) { \\n                dp[j] = Math.max(dp[j], dp[j - 1] - 1);\\n            }\\n            \\n            for (int j = dp.length - 2; j >= 0; j --) {\\n                dp[j] = Math.max(dp[j], dp[j + 1] - 1);\\n            }\\n        }\\n        \\n        long result = 0;\\n        for (int i = 0; i < dp.length; i ++) {\\n            result = Math.max(result, dp[i]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```\\n\\nI would suggest to write down dp[i] output with the given example line by line and you will get its spirit :))\\n\\nGood luck and have fun",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long[][] dp = new long[points.length][points[0].length];\\n        for (int i = 0; i < points[0].length; i ++) {\\n            dp[0][i] = points[0][i];\\n        }\\n        \\n        for (int i = 1; i < points.length; i ++) {\\n            for (int j = 0; j < points[0].length; j ++) {\\n                long max = 0;\\n                for (int k = 0; k < points[0].length; k ++) {\\n                    max = Math.max(max, dp[i - 1][k] - Math.abs(j - k));\\n                }\\n                dp[i][j] = max + points[i][j];\\n            }\\n        }\\n        \\n        long result = 0;\\n        for (int i = 0; i < dp[dp.length - 1].length; i ++) {\\n            result = Math.max(result, dp[dp.length - 1][i]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long[] dp = new long[points[0].length];\\n        \\n        for (int i = 0; i < points.length; i ++) {\\n            for (int j = 0; j < points[0].length; j ++) {\\n                dp[j] += points[i][j];\\n            }\\n            \\n            for (int j = 1; j < dp.length; j ++) { \\n                dp[j] = Math.max(dp[j], dp[j - 1] - 1);\\n            }\\n            \\n            for (int j = dp.length - 2; j >= 0; j --) {\\n                dp[j] = Math.max(dp[j], dp[j + 1] - 1);\\n            }\\n        }\\n        \\n        long result = 0;\\n        for (int i = 0; i < dp.length; i ++) {\\n            result = Math.max(result, dp[i]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355383,
                "title": "c-dp-top-down-with-memoization-o-n-m",
                "content": "My first solution was a bottom up version using multisets to track previous row DP values in left and right sides of the current column. that was messy AF tbh, so i tried to do a more elegant solution, through Memoization, since i thought it was impossible to memoize the answer here and get n^2 complexity. \\nThe concept is simple, either i can go down from i,j to i+1, j, or go left, or go right.\\n\\nbasically, the recurrence relation formed is:\\n\\n```\\nDP[i][j] = maximum of :\\na[i][j] + DP[i+1][j] //moving to the next row, while finalizing the element choice for this row as i,j\\n   -1   + DP[i][j-1] //moving in the same row, to the left, hence cost is -1\\n   -1   + DP[i][j+1] //moving in the same row, to the right, hence cost is -1\\n```\\n\\nnow, if you noticed here, we are basically getting a cycle, which is a no go. to rectify that, i just used directional variable which has values : \\n```\\n0 if i came at i,j from top row,\\n1 if i came at i,j from same row, left column and\\n2 if i came at i,j from same row, right column.\\n```\\nthis worked flawlessly!\\nat first, i tried to solve the cycle problem by temporarily setting the value of DP to -2, before recurring and checking at the start of the function, if the value was -2, then return INF to avoid looping, but that gives a wrong answer since the answer to a subproblem is not unique in this case.\\n\\nAnyways, Here\\'s the code:\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll n, m;\\n    ll INF = 1000000000000ll;\\n    vector<vector<vector<ll>>> DP;\\n    long long dp(ll i, ll j, int dir, vector<vector<int>>& a) {\\n        if (j < 0 || j >= m)\\n            return -INF;\\n        if (i == n)\\n            return 0;\\n        if (DP[i][j][dir] != -1)\\n            return DP[i][j][dir];\\n        ll x = a[i][j];\\n        ll ans = x + dp(i + 1, j, 0, a);\\n        if (dir != 1)\\n            ans = max(ans, -1 + dp(i, j - 1, 2, a));\\n        if (dir != 2)\\n            ans = max(ans, -1 + dp(i, j + 1, 1, a));\\n        return DP[i][j][dir] = ans;\\n    }\\n    long long maxPoints(vector<vector<int>> &a) {\\n        n = a.size(), m = a[0].size();\\n        DP.resize(n, vector<vector<ll>>(m, vector<ll>(3, -1)));\\n        ll ans = INT_MIN;\\n        for (int i = 0; i < m; i++) {\\n            ans = max(ans, dp(0, i, 0, a));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nDP[i][j] = maximum of :\\na[i][j] + DP[i+1][j] //moving to the next row, while finalizing the element choice for this row as i,j\\n   -1   + DP[i][j-1] //moving in the same row, to the left, hence cost is -1\\n   -1   + DP[i][j+1] //moving in the same row, to the right, hence cost is -1\\n```\n```\\n0 if i came at i,j from top row,\\n1 if i came at i,j from same row, left column and\\n2 if i came at i,j from same row, right column.\\n```\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll n, m;\\n    ll INF = 1000000000000ll;\\n    vector<vector<vector<ll>>> DP;\\n    long long dp(ll i, ll j, int dir, vector<vector<int>>& a) {\\n        if (j < 0 || j >= m)\\n            return -INF;\\n        if (i == n)\\n            return 0;\\n        if (DP[i][j][dir] != -1)\\n            return DP[i][j][dir];\\n        ll x = a[i][j];\\n        ll ans = x + dp(i + 1, j, 0, a);\\n        if (dir != 1)\\n            ans = max(ans, -1 + dp(i, j - 1, 2, a));\\n        if (dir != 2)\\n            ans = max(ans, -1 + dp(i, j + 1, 1, a));\\n        return DP[i][j][dir] = ans;\\n    }\\n    long long maxPoints(vector<vector<int>> &a) {\\n        n = a.size(), m = a[0].size();\\n        DP.resize(n, vector<vector<ll>>(m, vector<ll>(3, -1)));\\n        ll ans = INT_MIN;\\n        for (int i = 0; i < m; i++) {\\n            ans = max(ans, dp(0, i, 0, a));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349420,
                "title": "c-left-right-dynamic-programming",
                "content": "n = #rows, m = #columns\\nThe standard DP method would take O(n * m * m)\\nFor each row, for each cell, we would look at every cell in the previous row and calculate ```dp[i][j]```\\n``` \\n// dp[i][j] = maximum sum to cell (i, j)\\ndp[i][j] = max(dp[i - 1][k] + points[i][j]) for 0 <= k < m\\n```\\nTo optimize this, we can use additional space.\\nFor each row, for each cell, we take max from either exactly above, or left above, or right above\\n```\\ndp[i][j] = max(left[j], right[j]) + points[i][j]\\n// left[j] represents the maximum sum if it came from the left of (or directly above) j\\n// right[j] represents the maximum sum if it came from the right of (or directly above) j\\n// once we calculate dp[i][j] for the entire row i, we can update left and right vectors\\nleft[j] = max(left[j - 1] - 1, dp[i][j]) \\nright[j] = max(right[j + 1] - 1, dp[i][j])\\n```\\n\\nC++ [O(n * m) Time | O(n * m) Space]:\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<long long> left(m), right(m);\\n        vector<vector<long long>> dp(n, vector<long long> (m));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (i == 0)\\n                    dp[i][j] = points[i][j];\\n                else\\n                    dp[i][j] = max(left[j], right[j]) + points[i][j];\\n            }\\n            // update left\\n            for (int j = 0; j < m; ++j) {\\n                if (j == 0)\\n                    left[j] = dp[i][j];\\n                else\\n                    left[j] = max(dp[i][j], left[j - 1] - 1);\\n            }\\n            // updating right\\n            for (int j = m - 1; j >= 0; --j) {\\n                if (j == m - 1)\\n                    right[j] = dp[i][j];\\n                else\\n                    right[j] = max(dp[i][j], right[j + 1] - 1);\\n            }\\n        }\\n        long long res = 0;\\n        for (int i = 0; i < m; ++i)\\n            res = max(res, dp[n - 1][i]);\\n        return res;\\n    }\\n};\\n```\\n**Kindly upvote if this was helpful**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j]```\n``` \\n// dp[i][j] = maximum sum to cell (i, j)\\ndp[i][j] = max(dp[i - 1][k] + points[i][j]) for 0 <= k < m\\n```\n```\\ndp[i][j] = max(left[j], right[j]) + points[i][j]\\n// left[j] represents the maximum sum if it came from the left of (or directly above) j\\n// right[j] represents the maximum sum if it came from the right of (or directly above) j\\n// once we calculate dp[i][j] for the entire row i, we can update left and right vectors\\nleft[j] = max(left[j - 1] - 1, dp[i][j]) \\nright[j] = max(right[j + 1] - 1, dp[i][j])\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<long long> left(m), right(m);\\n        vector<vector<long long>> dp(n, vector<long long> (m));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (i == 0)\\n                    dp[i][j] = points[i][j];\\n                else\\n                    dp[i][j] = max(left[j], right[j]) + points[i][j];\\n            }\\n            // update left\\n            for (int j = 0; j < m; ++j) {\\n                if (j == 0)\\n                    left[j] = dp[i][j];\\n                else\\n                    left[j] = max(dp[i][j], left[j - 1] - 1);\\n            }\\n            // updating right\\n            for (int j = m - 1; j >= 0; --j) {\\n                if (j == m - 1)\\n                    right[j] = dp[i][j];\\n                else\\n                    right[j] = max(dp[i][j], right[j + 1] - 1);\\n            }\\n        }\\n        long long res = 0;\\n        for (int i = 0; i < m; ++i)\\n            res = max(res, dp[n - 1][i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1820366,
                "title": "python-dp-o-mn",
                "content": "Initially, I used a simple dp of O(MN^2), which caused TLE. \\n\\nIn fact, for each row, we don\\'t have to use O(N^2) to update the dp array. Instead, **2N is enough.**\\n\\n1. Initial **new_dp[j] = dp[j]**\\n2. First, we scan the dp array from left to right, and update **new_dp[j] = max(new_dp[j-1] - 1, new_dp[j])**\\nAfter this step, new_dp[j] is the max points considering movements from dp[0] ~ dp[j].\\n3. Then, we scan the dp array from right to left, and update **new_dp[j] = max(new_dp[j+1] - 1, new_dp[j])**\\nAfter this step, new_dp[j] is the max points also considering movements from dp[j+1]~dp[-1]\\n\\nCheck the code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        dp = [0] * n\\n        for i in range(m):\\n            new_dp = dp[:]\\n            for j in range(1, n):\\n                new_dp[j] = max(new_dp[j-1] - 1, new_dp[j])\\n            for j in range(n-2, -1, -1):\\n                new_dp[j] = max(new_dp[j+1] - 1, new_dp[j])\\n            dp = [points[i][j] + new_dp[j] for j in range(n)]\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        dp = [0] * n\\n        for i in range(m):\\n            new_dp = dp[:]\\n            for j in range(1, n):\\n                new_dp[j] = max(new_dp[j-1] - 1, new_dp[j])\\n            for j in range(n-2, -1, -1):\\n                new_dp[j] = max(new_dp[j+1] - 1, new_dp[j])\\n            dp = [points[i][j] + new_dp[j] for j in range(n)]\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417056,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long maxPoints(vector<vector<int>>& mat) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<long long>>dp(n,vector<long long>(m,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            dp[0][i]=mat[0][i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<long long>left(m,0),right(m,0);\\n            vector<long long>val=dp[i-1];\\n            left[0]=val[0];\\n            right[m-1]=val[m-1];\\n            for(int j=1;j<m;j++)\\n            {\\n                left[j]=max(left[j-1]-1,val[j]);\\n            }\\n            for(int j=m-2;j>=0;j--)\\n            {\\n                right[j]=max(right[j+1]-1,val[j]);\\n            }\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=mat[i][j]+max(left[j],right[j]);\\n            }\\n        }\\n        return *max_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long maxPoints(vector<vector<int>>& mat) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<long long>>dp(n,vector<long long>(m,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            dp[0][i]=mat[0][i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<long long>left(m,0),right(m,0);\\n            vector<long long>val=dp[i-1];\\n            left[0]=val[0];\\n            right[m-1]=val[m-1];\\n            for(int j=1;j<m;j++)\\n            {\\n                left[j]=max(left[j-1]-1,val[j]);\\n            }\\n            for(int j=m-2;j>=0;j--)\\n            {\\n                right[j]=max(right[j+1]-1,val[j]);\\n            }\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=mat[i][j]+max(left[j],right[j]);\\n            }\\n        }\\n        return *max_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345013,
                "title": "c-bottom-up-dp-o-n-2-optimized-from-o-n-3",
                "content": "The idea is to calculate score considering picking up each cell in next row for each cell in current row. But this idea implementation using Simple Bottom UP DP will take O(n^3).\\nSo to optimise, we store (for each cell in a row)  max-value when **we assume we jump towards left from current cell** and **when we jump right from current cell**  seperately.\\n\\nFor filling of ```left``` values :\\n```left``` can be calculated in O(n) by filling from left to right,  as for each subsequent value  ```left[i+1]=left[i] -1``` as for each subsequent value **i+1, abs(i-j) increases by 1** .\\nSimilarly we fill ```right``` , by storing values assuming we jump towards right from current cell.This can be done by filling array from **right to left** ie. ```right[i]=right[i+1]-1```.\\nAnswer for any cell would be ```max(left[i],right[i]) +points[j][k]``` ;\\n**Similar idea can be implemented through Memoization too. We can fill left[n][m] and right[n][m] arrays using memoization.**\\n**Comment IF Any Doubt**\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),m=points[0].size();\\n        long long int dp[n][m];\\n        \\n        for(int i=0;i<m;i++){\\n            dp[n-1][i]=points[n-1][i];\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n           \\n               long long int left[m],right[m];\\n            long long int lm=dp[i+1][0];\\n                for(int j=0;j<m;j++){\\n                    left[j]=lm-1>dp[i+1][j]?lm-1:dp[i+1][j];\\n                    lm=left[j];\\n                }\\n              long long int rm=dp[i+1][m-1];\\n                for(int j=m-1;j>=0;j--){\\n                    right[j]=rm-1>dp[i+1][j]?rm-1:dp[i+1][j];\\n                    rm=right[j];\\n                }\\n            \\n             for(int j=0;j<m;j++){\\n                    dp[i][j]=max(left[j],right[j])+points[i][j];\\n                }\\n            \\n            }\\n        \\n        \\n        long long int ans=LLONG_MIN;\\n        for(int i=0;i<m;i++){\\n            if(dp[0][i]>ans){ans=dp[0][i];}\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```left```\n```left```\n```left[i+1]=left[i] -1```\n```right```\n```right[i]=right[i+1]-1```\n```max(left[i],right[i]) +points[j][k]```\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),m=points[0].size();\\n        long long int dp[n][m];\\n        \\n        for(int i=0;i<m;i++){\\n            dp[n-1][i]=points[n-1][i];\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n           \\n               long long int left[m],right[m];\\n            long long int lm=dp[i+1][0];\\n                for(int j=0;j<m;j++){\\n                    left[j]=lm-1>dp[i+1][j]?lm-1:dp[i+1][j];\\n                    lm=left[j];\\n                }\\n              long long int rm=dp[i+1][m-1];\\n                for(int j=m-1;j>=0;j--){\\n                    right[j]=rm-1>dp[i+1][j]?rm-1:dp[i+1][j];\\n                    rm=right[j];\\n                }\\n            \\n             for(int j=0;j<m;j++){\\n                    dp[i][j]=max(left[j],right[j])+points[i][j];\\n                }\\n            \\n            }\\n        \\n        \\n        long long int ans=LLONG_MIN;\\n        for(int i=0;i<m;i++){\\n            if(dp[0][i]>ans){ans=dp[0][i];}\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758037,
                "title": "c-99-o-mn-time-o-n-space",
                "content": "```C++\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        const int n = points.size(), m = points[0].size();\\n        long long dp[m], lmax[m], rmax[m];\\n        for (int i = 0; i < m; i++) dp[i] = points[0][i];\\n        for (int i = 1; i < n; i++) {\\n            lmax[0] = dp[0];\\n            for (int i = 1; i < m; i++)\\n                lmax[i] = max(lmax[i-1], dp[i] + i);\\n            rmax[m-1] = dp[m-1] - m + 1;\\n            for (int i = m-2; i > -1; i--)\\n                rmax[i] = max(rmax[i+1], dp[i] - i);\\n            for (int j = 0; j < m; j++)\\n                dp[j] = points[i][j] + max(lmax[j] - j, rmax[j] + j);\\n        }\\n        return *max_element(dp, dp + m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        const int n = points.size(), m = points[0].size();\\n        long long dp[m], lmax[m], rmax[m];\\n        for (int i = 0; i < m; i++) dp[i] = points[0][i];\\n        for (int i = 1; i < n; i++) {\\n            lmax[0] = dp[0];\\n            for (int i = 1; i < m; i++)\\n                lmax[i] = max(lmax[i-1], dp[i] + i);\\n            rmax[m-1] = dp[m-1] - m + 1;\\n            for (int i = m-2; i > -1; i--)\\n                rmax[i] = max(rmax[i+1], dp[i] - i);\\n            for (int j = 0; j < m; j++)\\n                dp[j] = points[i][j] + max(lmax[j] - j, rmax[j] + j);\\n        }\\n        return *max_element(dp, dp + m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344995,
                "title": "c-dp-explained-with-intuition-o-m-n-solution",
                "content": "### **Intuition :**\\nFor any row i, we need to store results of previous row(i-1) in such a manner that we won\\'t waste O(n) time to traverse over previous row(i-1), we can fetch the best possible candidate from the prev row(i-1) in just O(1) time. \\n\\n*That\\'s why we will store the best candidate for (i,j) in the previous row same column. (i-1,j) => hence can be lookup in O(1) time\\n=> That will reduce our total time from O(m  n  n) to O(m  n)*\\n\\n```\\nFor any element (i,j) we do have three choices , we will pick max of these :\\n\\n1. Curr_element stored at (i,j) + best candidate from prev row => mat[i][j] + dp[i-1][j]\\n2. For all k = (0..j) => dp[i][j] = max(mat[i,k] - (i-k) ) \\n3. For all k = (j+1..n) => dp[i][j] = max(mat[i,k] - (k-i) ) \\n```\\n\\n\\nStore results for every row in following manner :\\n* While traversing from left to right :    max(choice #1, choice #2)\\n\\t* dp[i][j] = max ( dp[i][j-1] -1, dp[i-1][j] + element at pos(i,j) );  \\n* While traversing from left to right :     max with choice #3\\n\\t* dp[i][j] = max ( dp[i][j+1]-1, dp[i][j] );\\n* Return max value from last row.\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\t\\t//dp[m+1][n] -> extra row to have zero padding in first row.\\n        vector<vector<ll> > dp(m+1,vector<ll>(n,0));\\n        int curr_max = 0;\\n        \\n        for(int i = 1; i <=m; i++){\\n            //Explicitly handling for first column\\n            dp[i][0] = mat[i-1][0] + dp[i-1][0];\\n            \\n\\t\\t\\t//Taking max(choice #1, choice #2)\\n            for(int j = 1; j < n; j++)\\n                dp[i][j] = max(mat[i-1][j] + dp[i-1][j], dp[i][j-1]-1);\\n            \\n            //Explicitly handling for last column\\n            dp[i][n-1] = max(dp[i][n-1],mat[i-1][n-1] + dp[i-1][n-1]);\\n            \\n\\t\\t\\t//Taking max with choice #3\\n            for(int j = n-2; j >=0; j--)\\n                dp[i][j] = max(dp[i][j], dp[i][j+1]-1);\\n        }\\n        \\n        return *max_element(dp[m].begin(),dp[m].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nFor any element (i,j) we do have three choices , we will pick max of these :\\n\\n1. Curr_element stored at (i,j) + best candidate from prev row => mat[i][j] + dp[i-1][j]\\n2. For all k = (0..j) => dp[i][j] = max(mat[i,k] - (i-k) ) \\n3. For all k = (j+1..n) => dp[i][j] = max(mat[i,k] - (k-i) ) \\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\t\\t//dp[m+1][n] -> extra row to have zero padding in first row.\\n        vector<vector<ll> > dp(m+1,vector<ll>(n,0));\\n        int curr_max = 0;\\n        \\n        for(int i = 1; i <=m; i++){\\n            //Explicitly handling for first column\\n            dp[i][0] = mat[i-1][0] + dp[i-1][0];\\n            \\n\\t\\t\\t//Taking max(choice #1, choice #2)\\n            for(int j = 1; j < n; j++)\\n                dp[i][j] = max(mat[i-1][j] + dp[i-1][j], dp[i][j-1]-1);\\n            \\n            //Explicitly handling for last column\\n            dp[i][n-1] = max(dp[i][n-1],mat[i-1][n-1] + dp[i-1][n-1]);\\n            \\n\\t\\t\\t//Taking max with choice #3\\n            for(int j = n-2; j >=0; j--)\\n                dp[i][j] = max(dp[i][j], dp[i][j+1]-1);\\n        }\\n        \\n        return *max_element(dp[m].begin(),dp[m].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058133,
                "title": "python-3-o-mn-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        for i in range(m - 1):\\n            for j in range(1, n):\\n                points[i][j] = max(points[i][j], points[i][j - 1] - 1)\\n            for j in range(n - 2, -1, -1):\\n                points[i][j] = max(points[i][j], points[i][j + 1] - 1)\\n            for j in range(n):\\n                points[i + 1][j] += points[i][j]   \\n        return max(points[m - 1])",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        for i in range(m - 1):\\n            for j in range(1, n):\\n                points[i][j] = max(points[i][j], points[i][j - 1] - 1)\\n            for j in range(n - 2, -1, -1):\\n                points[i][j] = max(points[i][j], points[i][j + 1] - 1)\\n            for j in range(n):\\n                points[i + 1][j] += points[i][j]   \\n        return max(points[m - 1])",
                "codeTag": "Java"
            },
            {
                "id": 1841903,
                "title": "java-top-down-and-bottom-up-approaches",
                "content": "**1. Brute Force Solution**\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        return getMaxPoints(points, 0, -1);\\n    }\\n    \\n    // Space complexity: O(m) where m is number of rows (stack space due to recursion), \\n    // Time complexity: O(n ^ m) (exponential)\\n    public long getMaxPoints(int[][] points, int currRow, int prevCol){\\n        //base case\\n        if(currRow == points.length)return 0;\\n        \\n        long maxPoints = 0;\\n        for(int i = 0; i < points[currRow].length; i++){\\n            \\n            if(prevCol != -1)\\n                maxPoints = Math.max(maxPoints, \\n                                     points[currRow][i] - Math.abs(i - prevCol) +  \\n                                     getMaxPoints(points, currRow + 1, i));\\n            else maxPoints = Math.max(maxPoints, points[currRow][i] + getMaxPoints(points, currRow + 1, i));\\n        }\\n        \\n        return maxPoints;\\n    }\\n}\\n```\\n**2. Top Down Memoization Solution**\\n```\\nclass Solution {\\n    \\n    long[][] dp;\\n    public long maxPoints(int[][] points) {\\n        dp = new long[points.length][points[0].length];\\n        \\n        for(int i = 0; i < points.length; i++)\\n            Arrays.fill(dp[i], -1);\\n        \\n        return getMaxPoints(points, 0, -1);\\n    }\\n    \\n    // Space complexity: O(m * n) where m is number of rows and n is number of columns\\n    // Time complexity: O(m * n * n)\\n    public long getMaxPoints(int[][] points, int currRow, int prevCol){\\n        //base case\\n        if(currRow == points.length)return 0;\\n        \\n        if(prevCol != -1 && dp[currRow][prevCol] != -1)return dp[currRow][prevCol];\\n        \\n        long maxPoints = 0;\\n        for(int i = 0; i < points[currRow].length; i++){\\n            \\n            if(prevCol != -1)\\n                maxPoints = Math.max(maxPoints, \\n                                     points[currRow][i] - Math.abs(i - prevCol) +  \\n                                     getMaxPoints(points, currRow + 1, i));\\n            else maxPoints = Math.max(maxPoints, points[currRow][i] + getMaxPoints(points, currRow + 1, i));\\n        }\\n        \\n        if(prevCol != -1)dp[currRow][prevCol] = maxPoints;\\n        return maxPoints;\\n    }\\n}\\n```\\n**3. Bottom Up DP Solution**\\n```\\nclass Solution {\\n\\n    //Space Complexity: O(m * n)\\n    //Time complexity: O(m * n * n)\\n    public long maxPoints(int[][] points) {\\n        long maxPoints = 0;\\n        long[][] dp = new long[points.length][points[0].length];\\n\\n        for(int c = 0; c < points[0].length; c++)dp[0][c] = points[0][c];\\n        \\n        for(int i = 1; i < points.length; i++){\\n            \\n            for(int j = 0; j < points[0].length; j++){\\n                \\n                for(int k = 0; k < points[0].length; k++){\\n                    \\n                    dp[i][j] = Math.max(dp[i][j], points[i][j] + dp[i - 1][k] - Math.abs(j - k));\\n                    maxPoints = Math.max(maxPoints, dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return maxPoints;\\n    }\\n}\\n```\\n**4. Optimized Bottom Up DP Solution**\\n```\\nclass Solution {\\n\\n    //Space Complexity: O(m * n)\\n    //Time complexity: O(m * n)\\n    public long maxPoints(int[][] points) {\\n        long maxPoints = 0;\\n        long[][] dp = new long[points.length][points[0].length];\\n\\n        for(int c = 0; c < points[0].length; c++){\\n            dp[0][c] = points[0][c];\\n            maxPoints = Math.max(maxPoints, dp[0][c]);\\n        }\\n        \\n        for(int i = 1; i < points.length; i++){\\n            \\n            long[] prefix = new long[points[0].length];\\n            long[] suffix = new long[points[0].length];\\n            \\n            prefix[0] = dp[i - 1][0] + 0;\\n            for(int j = 1; j < points[0].length; j++)\\n                prefix[j] = Math.max(prefix[j - 1], dp[i - 1][j] + j);\\n            \\n            suffix[points[0].length - 1] = dp[i - 1][points[0].length - 1] - (points[0].length - 1);\\n            for(int j = points[0].length - 2; j >= 0; j--)\\n                suffix[j] = Math.max(suffix[j + 1], dp[i - 1][j] - j);\\n                \\n            for(int j = 0; j < points[0].length; j++){\\n                dp[i][j] = Math.max(dp[i][j], points[i][j] + Math.max(prefix[j] - j, suffix[j] + j));\\n                maxPoints = Math.max(maxPoints, dp[i][j]);\\n            }\\n        }\\n        \\n        return maxPoints;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        return getMaxPoints(points, 0, -1);\\n    }\\n    \\n    // Space complexity: O(m) where m is number of rows (stack space due to recursion), \\n    // Time complexity: O(n ^ m) (exponential)\\n    public long getMaxPoints(int[][] points, int currRow, int prevCol){\\n        //base case\\n        if(currRow == points.length)return 0;\\n        \\n        long maxPoints = 0;\\n        for(int i = 0; i < points[currRow].length; i++){\\n            \\n            if(prevCol != -1)\\n                maxPoints = Math.max(maxPoints, \\n                                     points[currRow][i] - Math.abs(i - prevCol) +  \\n                                     getMaxPoints(points, currRow + 1, i));\\n            else maxPoints = Math.max(maxPoints, points[currRow][i] + getMaxPoints(points, currRow + 1, i));\\n        }\\n        \\n        return maxPoints;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    long[][] dp;\\n    public long maxPoints(int[][] points) {\\n        dp = new long[points.length][points[0].length];\\n        \\n        for(int i = 0; i < points.length; i++)\\n            Arrays.fill(dp[i], -1);\\n        \\n        return getMaxPoints(points, 0, -1);\\n    }\\n    \\n    // Space complexity: O(m * n) where m is number of rows and n is number of columns\\n    // Time complexity: O(m * n * n)\\n    public long getMaxPoints(int[][] points, int currRow, int prevCol){\\n        //base case\\n        if(currRow == points.length)return 0;\\n        \\n        if(prevCol != -1 && dp[currRow][prevCol] != -1)return dp[currRow][prevCol];\\n        \\n        long maxPoints = 0;\\n        for(int i = 0; i < points[currRow].length; i++){\\n            \\n            if(prevCol != -1)\\n                maxPoints = Math.max(maxPoints, \\n                                     points[currRow][i] - Math.abs(i - prevCol) +  \\n                                     getMaxPoints(points, currRow + 1, i));\\n            else maxPoints = Math.max(maxPoints, points[currRow][i] + getMaxPoints(points, currRow + 1, i));\\n        }\\n        \\n        if(prevCol != -1)dp[currRow][prevCol] = maxPoints;\\n        return maxPoints;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    //Space Complexity: O(m * n)\\n    //Time complexity: O(m * n * n)\\n    public long maxPoints(int[][] points) {\\n        long maxPoints = 0;\\n        long[][] dp = new long[points.length][points[0].length];\\n\\n        for(int c = 0; c < points[0].length; c++)dp[0][c] = points[0][c];\\n        \\n        for(int i = 1; i < points.length; i++){\\n            \\n            for(int j = 0; j < points[0].length; j++){\\n                \\n                for(int k = 0; k < points[0].length; k++){\\n                    \\n                    dp[i][j] = Math.max(dp[i][j], points[i][j] + dp[i - 1][k] - Math.abs(j - k));\\n                    maxPoints = Math.max(maxPoints, dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return maxPoints;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    //Space Complexity: O(m * n)\\n    //Time complexity: O(m * n)\\n    public long maxPoints(int[][] points) {\\n        long maxPoints = 0;\\n        long[][] dp = new long[points.length][points[0].length];\\n\\n        for(int c = 0; c < points[0].length; c++){\\n            dp[0][c] = points[0][c];\\n            maxPoints = Math.max(maxPoints, dp[0][c]);\\n        }\\n        \\n        for(int i = 1; i < points.length; i++){\\n            \\n            long[] prefix = new long[points[0].length];\\n            long[] suffix = new long[points[0].length];\\n            \\n            prefix[0] = dp[i - 1][0] + 0;\\n            for(int j = 1; j < points[0].length; j++)\\n                prefix[j] = Math.max(prefix[j - 1], dp[i - 1][j] + j);\\n            \\n            suffix[points[0].length - 1] = dp[i - 1][points[0].length - 1] - (points[0].length - 1);\\n            for(int j = points[0].length - 2; j >= 0; j--)\\n                suffix[j] = Math.max(suffix[j + 1], dp[i - 1][j] - j);\\n                \\n            for(int j = 0; j < points[0].length; j++){\\n                dp[i][j] = Math.max(dp[i][j], points[i][j] + Math.max(prefix[j] - j, suffix[j] + j));\\n                maxPoints = Math.max(maxPoints, dp[i][j]);\\n            }\\n        }\\n        \\n        return maxPoints;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720078,
                "title": "python-98-dp-with-explanation-of-state-transfer",
                "content": "DP idea:\\n***base line, r=0***: at each (r, c) the largets score at (0, c) = max(points[r][c],  \"largest score passed from the left\", \"largest score passed from the right\")\\n***first iteration, r=1***: ***largets score at (1, c)*** = max( ***largets score at (0, c)*** , \"largest score passed from the left\", \"largest score passed from the right\")\\nHere we found the state transfer already: ***state(r,c)*** = max(***state(r-1,c)*** , extra cases for this state).\\n\\nTime: O(mn)\\nSpace: O(n) (O(1) if using points in space)\\n```\\n    def maxPoints(self, points):\\n        dp = [0 for i in range(len(points[0]))] # each dp[c] means the max val points[r][c] can get from previous row\\n        for r in range(len(points)):\\n            dp[0] += points[r][0] \\n            for c in range(1, len(points[0])): # forward pass\\n                dp[c] = max(dp[c]+points[r][c], dp[c-1]-1)\\n            \\n            for c in range(len(points[0])-2, -1, -1): # backward pass\\n                dp[c] = max(dp[c], dp[c+1]-1)\\n        \\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def maxPoints(self, points):\\n        dp = [0 for i in range(len(points[0]))] # each dp[c] means the max val points[r][c] can get from previous row\\n        for r in range(len(points)):\\n            dp[0] += points[r][0] \\n            for c in range(1, len(points[0])): # forward pass\\n                dp[c] = max(dp[c]+points[r][c], dp[c-1]-1)\\n            \\n            for c in range(len(points[0])-2, -1, -1): # backward pass\\n                dp[c] = max(dp[c], dp[c+1]-1)\\n        \\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1689755,
                "title": "java-solution-time-o-n-m-and-space-o-m",
                "content": "Below is solution,\\nLogic --  We need to know maximum values with minus if select different column then previous selected column. So , we go through with each row , select column points. minus -1 from total 0 to M. Also we also need to see if we select different column from other end . so -1 from M to 0. Keep doing for all rows. At the end you have M different values . Select MAX. ( trying to pick maximum from all options ) \\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        \\n        long[] tempRowPoints = new long [points[0].length];\\n        long result = 0;\\n        \\n        for(int i=0; i< points.length; i++) {\\n            for(int j=0; j<points[0].length; j++) {\\n                tempRowPoints[j] += points[i][j];\\n            }\\n            for(int j = 1; j < points[0].length; j++) {\\n                tempRowPoints[j] = Math.max(tempRowPoints[j], tempRowPoints[j-1] - 1);\\n            }\\n            \\n            for(int j = points[0].length-2; j >= 0; j--) {\\n               tempRowPoints[j] = Math.max(tempRowPoints[j], tempRowPoints[j+1] - 1); \\n            }\\n        }\\n        for(int k = 0; k<tempRowPoints.length; k++) {\\n            result = Math.max(tempRowPoints[k], result);\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long maxPoints(int[][] points) {\\n        \\n        long[] tempRowPoints = new long [points[0].length];\\n        long result = 0;\\n        \\n        for(int i=0; i< points.length; i++) {\\n            for(int j=0; j<points[0].length; j++) {\\n                tempRowPoints[j] += points[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1593795,
                "title": "explanation-with-mathematical-reasoning",
                "content": "I browsed some other posts even the ones with the most upvotes but I didn\\'t find a great explanation. So I made this post to help people who are struggling to find an `O(m*n)` approach after figuring out an `O(m*n^2)` approach\\n\\nConsidering you know how to solve this problem with `O(m*n^2)` approach, you must be familiar with this equation\\n\\n![image](https://assets.leetcode.com/users/images/85cf1576-d597-4af9-8eb4-1f5905802a4a_1637728393.988411.png)\\n\\nwhere `ri[j]` is the best point accumulated in cell[i][j], `j_{i-1}` is the variable of another j loop (or considering it as an index of elements in last row)\\n\\nThen we expand the `abs()` function. After expansion, we have the following 3 equations\\n\\n![image](https://assets.leetcode.com/users/images/f5eaf7de-5157-46b6-86cd-94073bd96180_1637728911.757653.png)\\n\\nThe `left_i[j]` means the best result that cell[i][j] can get when `j_{i-1}` is less or equal to `j` while `right_i[j]` means the best result that cell[i][j] can get when `j_{i-1}` is greater or equal to `j`\\n\\nThen we move the terms without `j_{i-1}` out of max function for the first 2 equations.\\n\\n![image](https://assets.leetcode.com/users/images/e9b04786-79c0-43de-9b9d-532f6212ab12_1637729410.5076957.png)\\n\\nSee, we have separated the 2 kinds of `j` variables, which means we can calculate 2 parts separately (`max()` part and `+/-j+points[j]` part). For max() part there is still a `j` under the `max` function, but we can use the previously calculated values to get the new value(where DP comes into the picture), and we can simply use a single for loop like below\\n\\n```python\\nm = -math.inf\\nfor j in range(width):\\n    m = max(last_r[j] + j, m)\\n    left_i_maxpart[j] = m\\n```\\n\\nOnce you get the `max()` part, combine the second parts and get the maximum of each element in `left` and `right` array\\n\\n```python\\nfor j in range(width):\\n    m1 = left_i_maxpart[j]\\n    m2 = right_i_maxpart[j]\\n    r[i][j] = max(m1 - j + points[i][j], m2 + j + points[i][j])\\n```\\n\\nThe final result is the r[height-1]\\n",
                "solutionTags": [],
                "code": "```python\\nm = -math.inf\\nfor j in range(width):\\n    m = max(last_r[j] + j, m)\\n    left_i_maxpart[j] = m\\n```\n```python\\nfor j in range(width):\\n    m1 = left_i_maxpart[j]\\n    m2 = right_i_maxpart[j]\\n    r[i][j] = max(m1 - j + points[i][j], m2 + j + points[i][j])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359060,
                "title": "java-simple-o-m-n-time-o-n-space-solution",
                "content": "So for each row i calculated the maximum value for each column, and then directly added to that column of next row, and repeated the process\\n\\n\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m = points.length;\\n        int n = points[0].length;\\n        \\n        long[] pre = new long[n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            pre[i] = points[0][i];\\n        }\\n        function(pre);\\n        for(int i = 1; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                pre[j] += points[i][j];\\n            }\\n            function(pre);\\n        }\\n        \\n        long max = 0;\\n        for(long i : pre) {\\n            max = Math.max(i, max);\\n        }\\n        return max;\\n    }\\n    \\n    public void function(long[] pre) {\\n        int n = pre.length;\\n        for(int i = 1; i < n; i++) {\\n            pre[i] = Math.max(pre[i], pre[i - 1] - 1);\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            pre[i] = Math.max(pre[i], pre[i + 1] - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m = points.length;\\n        int n = points[0].length;\\n        \\n        long[] pre = new long[n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            pre[i] = points[0][i];\\n        }\\n        function(pre);\\n        for(int i = 1; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                pre[j] += points[i][j];\\n            }\\n            function(pre);\\n        }\\n        \\n        long max = 0;\\n        for(long i : pre) {\\n            max = Math.max(i, max);\\n        }\\n        return max;\\n    }\\n    \\n    public void function(long[] pre) {\\n        int n = pre.length;\\n        for(int i = 1; i < n; i++) {\\n            pre[i] = Math.max(pre[i], pre[i - 1] - 1);\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            pre[i] = Math.max(pre[i], pre[i + 1] - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345409,
                "title": "c-tle-accepted-tried-my-best-to-explain-with-comments",
                "content": "```\\n//Approach-1 (TLE) (O(m*n*n) Just applying concept of\\n//Leetcode-931 (Minimum Falling Path Sum)\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll maxPoints(vector<vector<int>>& points) {\\n        int m = points.size(), n = points[0].size();\\n        vector<ll> prev(n);\\n        int score = 0;\\n        \\n        for(int col = 0; col < n; col++) {\\n            prev[col] = points[0][col];\\n        }\\n        \\n        for(int i = 1; i<m; i++) {\\n            vector<ll> curr(n);\\n            for(int j = 0; j<n; j++) {\\n                for(int k = 0; k < n; k++) {\\n                    curr[j] = max(curr[j], prev[k] + points[i][j] - abs(k-j));\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return *max_element(prev.begin(), prev.end());\\n    }\\n};\\n```\\n\\n\\n```\\n//Approach-2 (Accepted : O(m*n))\\n/*\\n\\tThis is similar to Approach-1 but we are finding the best prev column smartly.\\n\\tRead comments below to understand.\\n*/\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll maxPoints(vector<vector<int>>& points) {\\n        int m = points.size(), n = points[0].size();\\n        vector<ll> prev(n);\\n        int score = 0;\\n        \\n        for(int col = 0; col < n; col++) {\\n            prev[col] = points[0][col];\\n        }\\n        \\n        for(int i = 1; i<m; i++) {\\n            vector<ll> curr(n);\\n            auto left = curr, right = curr;\\n            \\n            /*\\n                While calculating left and right, we will find what will be added to\\n                points[i][j] (either left[j] or right[j]) which yields maximum value.\\n                Is it the prev row top value = prev[j];\\n                or is it prev row left value(but then subtract -1 due to one gap) = prev[j-1]-1\\n                or is it prev row left left value = prev[j-2]-2\\n                ans so on.\\n                Instead of comparing with all previous left (prev[j], prev[j-1]-1, prev[j-2]-2 etc)\\n                We know that left stores the bext left values.\\n                So we just subtract -1 from left[j-1] to get the result.\\n                \\n                i.e. (In short)\\n                essentially left[2] = max(pre[2], lft[1]-1) is the max for index 2 \\n                (instead of calculating from iterating from index 0) is because that\\n                lft[1]-1 already calculated for index 1 which includes the comparison\\n                between left[0]-1 and prev[1], so left[1] -1 includes left[0] -2, and prev[1] - 1 already\\n                \\n\\t\\t\\t\\tsimilar story goes for right.\\n            */\\n            \\n            //Fill left\\n            left[0] = prev[0];\\n            for(int j = 1; j<n; j++) {\\n                left[j] = max(prev[j], left[j-1]-1); // points[i][j] will be added later            \\n            }\\n            \\n            //Fill right\\n            right[n-1] = prev[n-1];\\n            for(int j = n-2; j >= 0; j--) {\\n                right[j] = max(prev[j], right[j+1]-1); // points[i][j] will be added later\\n            }\\n            \\n            for(int j = 0; j<n; j++)\\n                curr[j] = points[i][j] + max(left[j], right[j]); // points[i][j] added here\\n            \\n            prev = curr;\\n        }\\n        return *max_element(prev.begin(), prev.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (TLE) (O(m*n*n) Just applying concept of\\n//Leetcode-931 (Minimum Falling Path Sum)\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll maxPoints(vector<vector<int>>& points) {\\n        int m = points.size(), n = points[0].size();\\n        vector<ll> prev(n);\\n        int score = 0;\\n        \\n        for(int col = 0; col < n; col++) {\\n            prev[col] = points[0][col];\\n        }\\n        \\n        for(int i = 1; i<m; i++) {\\n            vector<ll> curr(n);\\n            for(int j = 0; j<n; j++) {\\n                for(int k = 0; k < n; k++) {\\n                    curr[j] = max(curr[j], prev[k] + points[i][j] - abs(k-j));\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return *max_element(prev.begin(), prev.end());\\n    }\\n};\\n```\n```\\n//Approach-2 (Accepted : O(m*n))\\n/*\\n\\tThis is similar to Approach-1 but we are finding the best prev column smartly.\\n\\tRead comments below to understand.\\n*/\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll maxPoints(vector<vector<int>>& points) {\\n        int m = points.size(), n = points[0].size();\\n        vector<ll> prev(n);\\n        int score = 0;\\n        \\n        for(int col = 0; col < n; col++) {\\n            prev[col] = points[0][col];\\n        }\\n        \\n        for(int i = 1; i<m; i++) {\\n            vector<ll> curr(n);\\n            auto left = curr, right = curr;\\n            \\n            /*\\n                While calculating left and right, we will find what will be added to\\n                points[i][j] (either left[j] or right[j]) which yields maximum value.\\n                Is it the prev row top value = prev[j];\\n                or is it prev row left value(but then subtract -1 due to one gap) = prev[j-1]-1\\n                or is it prev row left left value = prev[j-2]-2\\n                ans so on.\\n                Instead of comparing with all previous left (prev[j], prev[j-1]-1, prev[j-2]-2 etc)\\n                We know that left stores the bext left values.\\n                So we just subtract -1 from left[j-1] to get the result.\\n                \\n                i.e. (In short)\\n                essentially left[2] = max(pre[2], lft[1]-1) is the max for index 2 \\n                (instead of calculating from iterating from index 0) is because that\\n                lft[1]-1 already calculated for index 1 which includes the comparison\\n                between left[0]-1 and prev[1], so left[1] -1 includes left[0] -2, and prev[1] - 1 already\\n                \\n\\t\\t\\t\\tsimilar story goes for right.\\n            */\\n            \\n            //Fill left\\n            left[0] = prev[0];\\n            for(int j = 1; j<n; j++) {\\n                left[j] = max(prev[j], left[j-1]-1); // points[i][j] will be added later            \\n            }\\n            \\n            //Fill right\\n            right[n-1] = prev[n-1];\\n            for(int j = n-2; j >= 0; j--) {\\n                right[j] = max(prev[j], right[j+1]-1); // points[i][j] will be added later\\n            }\\n            \\n            for(int j = 0; j<n; j++)\\n                curr[j] = points[i][j] + max(left[j], right[j]); // points[i][j] added here\\n            \\n            prev = curr;\\n        }\\n        return *max_element(prev.begin(), prev.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344948,
                "title": "clean-java",
                "content": "It is similar to trapping rain water, we left sweep and right sweep to get the max value for each index.\\n\\ntrapping raing water\\nhttps://leetcode.com/problems/trapping-rain-water/\\n\\n\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long res = 0L;\\n        int M = points.length, N = points[0].length;\\n        long[][] dp = new long[M][N];\\n        if (M == 1) {\\n            for (int j = 0; j < N; j++)\\n                res = Math.max(res, points[0][j]);\\n            return res;\\n        }\\n        for (int i = 0; i < M; i++)\\n            for (int j = 0; j < N; j++)\\n                dp[i][j] = points[i][j];\\n        for (int i = 1; i < M; i++) {\\n            long[] tmp = new long[N];\\n            long pre = dp[i - 1][0];\\n            tmp[0] = pre;\\n            for (int j = 1; j < N; j++) {\\n                long cur = dp[i - 1][j];\\n                pre--;\\n                pre = Math.max(cur, pre);\\n                tmp[j] = Math.max(tmp[j], pre);\\n            }\\n            pre = dp[i - 1][N - 1];\\n            tmp[N - 1] = Math.max(pre, tmp[N - 1]);\\n            for (int j = N - 2; j >= 0; j--) {\\n                long cur = dp[i - 1][j];\\n                pre--;\\n                pre = Math.max(cur, pre);\\n                tmp[j] = Math.max(tmp[j], pre);\\n            }\\n            long max = 0L;\\n            for (int j = 0; j < N; j++) {\\n                dp[i][j] += tmp[j];\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\nfrom trapping rain water we had below simialr logic from left and right\\n```\\n    public int trap(int[] height) {\\n        if (height.length == 0) return 0;\\n        int N = height.length, res = 0;\\n        int[] left = new int[N], right = new int[N];\\n        left[0] = height[0];\\n        right[N - 1] = height[N - 1]; \\n        for (int i = 1; i < N; i++) left[i] = Math.max(left[i - 1], height[i]);\\n        for (int i = N - 2; i >= 0; i--) right[i] = Math.max(right[i + 1], height[i]);\\n        for (int i = 0; i < N; i++) res += Math.min(left[i], right[i]) - height[i];\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long res = 0L;\\n        int M = points.length, N = points[0].length;\\n        long[][] dp = new long[M][N];\\n        if (M == 1) {\\n            for (int j = 0; j < N; j++)\\n                res = Math.max(res, points[0][j]);\\n            return res;\\n        }\\n        for (int i = 0; i < M; i++)\\n            for (int j = 0; j < N; j++)\\n                dp[i][j] = points[i][j];\\n        for (int i = 1; i < M; i++) {\\n            long[] tmp = new long[N];\\n            long pre = dp[i - 1][0];\\n            tmp[0] = pre;\\n            for (int j = 1; j < N; j++) {\\n                long cur = dp[i - 1][j];\\n                pre--;\\n                pre = Math.max(cur, pre);\\n                tmp[j] = Math.max(tmp[j], pre);\\n            }\\n            pre = dp[i - 1][N - 1];\\n            tmp[N - 1] = Math.max(pre, tmp[N - 1]);\\n            for (int j = N - 2; j >= 0; j--) {\\n                long cur = dp[i - 1][j];\\n                pre--;\\n                pre = Math.max(cur, pre);\\n                tmp[j] = Math.max(tmp[j], pre);\\n            }\\n            long max = 0L;\\n            for (int j = 0; j < N; j++) {\\n                dp[i][j] += tmp[j];\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n    public int trap(int[] height) {\\n        if (height.length == 0) return 0;\\n        int N = height.length, res = 0;\\n        int[] left = new int[N], right = new int[N];\\n        left[0] = height[0];\\n        right[N - 1] = height[N - 1]; \\n        for (int i = 1; i < N; i++) left[i] = Math.max(left[i - 1], height[i]);\\n        for (int i = N - 2; i >= 0; i--) right[i] = Math.max(right[i + 1], height[i]);\\n        for (int i = 0; i < N; i++) res += Math.min(left[i], right[i]) - height[i];\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479135,
                "title": "this-problem-should-be-hard-difficulty",
                "content": "I spent so much time figuring out how to solve this problem... Not only it is a dynamic programming problem, but it is even in 2 dimensions! That is insane for a Medium difficulty problem...",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1959299,
                "title": "8-lines-of-python-code-faster-than-99-73-explained",
                "content": "Please just read the darn comments\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        for i, row in enumerate(points[:-1]):\\n            # the trick is not to compute what the accumulated best val can be achieved at each cell, like A*\\n            # rather, compute the best val each cell can send down, like doing a DP per row\\n\\n            # in the begining, each cell in row contains the original val, which it can send down directly\\n\\n            for j in range(1, len(row)):\\n                row[j] = max(row[j], row[j-1]-1)\\n            # each cell in row now contains the best val, if it could get val from the left, recursively\\n\\n            for j in range(len(row)-2, -1, -1):\\n                row[j] = max(row[j], row[j+1]-1)\\n            # each cell in row now contains the best val, if it could get val from both sides, recursively\\n\\n            # send down the value\\n            for j in range(len(row)):\\n                points[i+1][j] += points[i][j]\\n        return max(points[-1])\\n\\n```\\n\\nBTW it\\'s ridiculous coding cites used to have hundreds of problems, now it\\'s thousands, while hard questions are now diluted as medium. With  big companies exhaustively uses a fixed&standardized questions set, and more people exhaustively practice those high frequency questions.\\n\\nInterviews are less of a measure of how logical and clean your coding skill is, rather it finds out if you have been practicing LC a lot, lately. It\\'s the definition of \\u201Cneijuan\\u201D...\\n\\nApologize for my old man ranting.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        for i, row in enumerate(points[:-1]):\\n            # the trick is not to compute what the accumulated best val can be achieved at each cell, like A*\\n            # rather, compute the best val each cell can send down, like doing a DP per row\\n\\n            # in the begining, each cell in row contains the original val, which it can send down directly\\n\\n            for j in range(1, len(row)):\\n                row[j] = max(row[j], row[j-1]-1)\\n            # each cell in row now contains the best val, if it could get val from the left, recursively\\n\\n            for j in range(len(row)-2, -1, -1):\\n                row[j] = max(row[j], row[j+1]-1)\\n            # each cell in row now contains the best val, if it could get val from both sides, recursively\\n\\n            # send down the value\\n            for j in range(len(row)):\\n                points[i+1][j] += points[i][j]\\n        return max(points[-1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655461,
                "title": "c-dp-solution-o-m-n-with-3-rows-of-storage",
                "content": "**Key points:**\\n* It is obviously a DP problem. The key here is we want to scan one row at a time from top to bottom and in some dp storage we save off what is the max point to reach current cell.\\n* The max points to reach current cell is decided by finding the max value from the row above substract the offset to current column. Understand this point is the key!\\n* If we do the above comparison for each cell, we shall end up with O(N\\\\*N) to finish one row and O(M\\\\*N\\\\*N) for the matrix. I got a time-limit-exceeded because of it. No good!\\n* Here we can use two extra rows of storage to save off max value from left (and current) and max value from right (and current). The final winner is going to be the max of those two. This is another mini dp problem within a dp problem. I kind of remember there was a separate problem like this on LC. By using the extra two rows, we can reduce the N\\\\*N run to 2N run per each row.\\n* I could just create a M\\\\*N size dp storage but since we only care about previous row and current row, so one row is good enough.\\n* Need another 2N size dp buffer for per row calculation hence totoal storage is 3N in size. Run time is O(M\\\\*N).\\n```\\n  long long maxPoints(vector<vector<int>>& points) {\\n    int m = points.size();\\n    int n = points[0].size();\\n    vector<long long> pts(n, 0);\\n    vector<long long> left(n);\\n    vector<long long> right(n);\\n\\n    for (int i=0; i<m; ++i) {\\n      left[0] = pts[0];\\n      right[n-1] = pts[n-1];\\n      for (int j=1; j<n; ++j) {\\n        left[j] = std::max(pts[j], left[j-1] - 1);\\n        right[n-1-j] = std::max(pts[n-1-j], right[n-j] - 1);\\n      }\\n      for (int j=0; j<n; ++j)\\n        pts[j] = std::max(left[j], right[j]) + points[i][j];\\n    }\\n    return *std::max_element(pts.begin(), pts.end());\\n  }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n  long long maxPoints(vector<vector<int>>& points) {\\n    int m = points.size();\\n    int n = points[0].size();\\n    vector<long long> pts(n, 0);\\n    vector<long long> left(n);\\n    vector<long long> right(n);\\n\\n    for (int i=0; i<m; ++i) {\\n      left[0] = pts[0];\\n      right[n-1] = pts[n-1];\\n      for (int j=1; j<n; ++j) {\\n        left[j] = std::max(pts[j], left[j-1] - 1);\\n        right[n-1-j] = std::max(pts[n-1-j], right[n-j] - 1);\\n      }\\n      for (int j=0; j<n; ++j)\\n        pts[j] = std::max(left[j], right[j]) + points[i][j];\\n    }\\n    return *std::max_element(pts.begin(), pts.end());\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596492,
                "title": "o-nm-time-o-m-java-solution",
                "content": "The key to reduce from O(n * m ^2) to O(n * m) time complexity is carefully design the DP state transfer equation.\\n\\n```java\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long res = 0;\\n        int n = points.length;\\n        if (n == 0) { return res; }\\n        int m = points[0].length;\\n        if (m == 0) { return res; }\\n        long[] dp = new long[m];\\n        for (int i = 0; i < n; i++) {\\n            int[] curr = points[i];\\n            if (i == 0) {\\n                for (int j = 0; j < m; j++) {\\n                    dp[j] = curr[j];\\n                }\\n                continue;\\n            }\\n            long[] l = new long[m], r = new long[m];\\n            for (int j = 0; j < m; j++) {\\n                l[j] = j == 0 ? dp[j] : Math.max(dp[j], l[j - 1] - 1);\\n                r[m - 1 - j] = j == 0 ? dp[m - 1 - j] : Math.max(dp[m - 1 - j], r[m - j] - 1);\\n            }\\n            for (int j = 0; j < m; j++) {\\n                dp[j] = curr[j] + Math.max(l[j], r[j]);\\n            }\\n        }\\n        for (long val: dp) {\\n            res = Math.max(res, val);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long res = 0;\\n        int n = points.length;\\n        if (n == 0) { return res; }\\n        int m = points[0].length;\\n        if (m == 0) { return res; }\\n        long[] dp = new long[m];\\n        for (int i = 0; i < n; i++) {\\n            int[] curr = points[i];\\n            if (i == 0) {\\n                for (int j = 0; j < m; j++) {\\n                    dp[j] = curr[j];\\n                }\\n                continue;\\n            }\\n            long[] l = new long[m], r = new long[m];\\n            for (int j = 0; j < m; j++) {\\n                l[j] = j == 0 ? dp[j] : Math.max(dp[j], l[j - 1] - 1);\\n                r[m - 1 - j] = j == 0 ? dp[m - 1 - j] : Math.max(dp[m - 1 - j], r[m - j] - 1);\\n            }\\n            for (int j = 0; j < m; j++) {\\n                dp[j] = curr[j] + Math.max(l[j], r[j]);\\n            }\\n        }\\n        for (long val: dp) {\\n            res = Math.max(res, val);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547525,
                "title": "python-dp-prefixmax-postfixmax",
                "content": "```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        # handle edge case\\n        if len(points) == 0 or len(points[0]) == 0: return 0\\n        \\n        m, n = len(points), len(points[0])\\n            \\n        # fill in the table\\n        for i in range(1,m):\\n            \\n            # compute prefixMax from left\\n            left = [points[i-1][0]] * n\\n            for j in range(1,n):\\n                left[j] = max(left[j-1] - 1, points[i-1][j])\\n                \\n            # compute postfixMax from right\\n            right = [points[i-1][n-1]] * n\\n            for j in range(n-2, -1, -1):\\n                right[j] = max(right[j+1] - 1, points[i-1][j])\\n            \\n            # dp[i][j] = max(max_from_left, max_from_right) + points[i][j]\\n            for j in range(n):\\n                points[i][j] += max(left[j], right[j])\\n                \\n        return max(points[m-1])\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        # handle edge case\\n        if len(points) == 0 or len(points[0]) == 0: return 0\\n        \\n        m, n = len(points), len(points[0])\\n            \\n        # fill in the table\\n        for i in range(1,m):\\n            \\n            # compute prefixMax from left\\n            left = [points[i-1][0]] * n\\n            for j in range(1,n):\\n                left[j] = max(left[j-1] - 1, points[i-1][j])\\n                \\n            # compute postfixMax from right\\n            right = [points[i-1][n-1]] * n\\n            for j in range(n-2, -1, -1):\\n                right[j] = max(right[j+1] - 1, points[i-1][j])\\n            \\n            # dp[i][j] = max(max_from_left, max_from_right) + points[i][j]\\n            for j in range(n):\\n                points[i][j] += max(left[j], right[j])\\n                \\n        return max(points[m-1])\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348222,
                "title": "c-runtime-beats-100-o-n-m",
                "content": "\\n\\n    \\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        int m = points[0].size();\\n        if(n==1)\\n        {\\n            return *max_element(points[0].begin(),points[0].end());\\n        }\\n        long long arr[n][m];\\n        long long ans = -1;\\n        for(int i=0;i<m;i++)\\n        {\\n            arr[0][i] = points[0][i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            long long left[m];\\n            long long right[m];\\n            left[0] = arr[i-1][0];\\n            for(int k=1;k<m;k++)\\n            {\\n                left[k] = max(left[k-1]-1,arr[i-1][k]);\\n            }\\n            right[m-1] = arr[i-1][m-1];\\n            for(int k=m-2;k>=0;k--)\\n            {\\n                right[k] = max(right[k+1]-1,arr[i-1][k]);\\n            }\\n            \\n            for(int j=0;j<m;j++)\\n            {\\n                arr[i][j] = max(left[j],right[j])+points[i][j];\\n                \\n                ans = max(ans,arr[i][j]);\\n    \\n            }\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\n    \\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        int m = points[0].size();\\n        if(n==1)\\n        {\\n            return *max_element(points[0].begin(),points[0].end());\\n        }\\n        long long arr[n][m];\\n        long long ans = -1;\\n        for(int i=0;i<m;i++)\\n        {\\n            arr[0][i] = points[0][i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            long long left[m];\\n            long long right[m];\\n            left[0] = arr[i-1][0];\\n            for(int k=1;k<m;k++)\\n            {\\n                left[k] = max(left[k-1]-1,arr[i-1][k]);\\n            }\\n            right[m-1] = arr[i-1][m-1];\\n            for(int k=m-2;k>=0;k--)\\n            {\\n                right[k] = max(right[k+1]-1,arr[i-1][k]);\\n            }\\n            \\n            for(int j=0;j<m;j++)\\n            {\\n                arr[i][j] = max(left[j],right[j])+points[i][j];\\n                \\n                ans = max(ans,arr[i][j]);\\n    \\n            }\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1345530,
                "title": "4-different-solution-based-on-observation-c",
                "content": "I was not able to solve this problem during the contest and was getting TLE. Was thinking hard to come up with optimize solution unfortunately when did contest was . Sharing my thought process for same \\nThis my contest code for TLE\\n`\\nComplexity,\\nTime :O(n*m^2)  \\nSpace: O(n*m)`\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>>M;\\n    vector<vector<int>>DP;\\n    int solve(int r, int c) {\\n        if (r  >= n) return 0;\\n        int &ret = DP[r][c];\\n        if (ret != -1) return ret;\\n        ret = 0;\\n        for (int i= 0; i < m; i++)  {\\n            ret = max(ret, solve(r + 1, i)  + M[r][i] - abs(c - i));\\n        }\\n        return ret;\\n    }\\n    long long maxPoints(vector<vector<int>>& points) {\\n        M = points, n = points.size(), m = points[0].size();\\n        int ans =0 ;\\n        DP = vector<vector<int>>(n, vector<int>(m, -1));\\n        for (int i =0 ; i < m; i++) ans = max(ans, solve(1 , i) + M[0][i]);\\n        return ans;\\n    }\\n};\\n```\\nFew observation i had while doing it with pen and paper\\n*  Need only previous row for calcuating the current row values\\n*  For any `cell (i, j)`  its maximum value will either be from left, right or same j from previous row\\n\\t*  `cell (i,j) = max(prev[k] + points[i][j] + j - k, cell(i, j))  i.e cell (i,j) = max(prev[k] -k  + points[i][j] + j, cell(i, j)) for k = 0 to j`  or \\n\\t*  ` cell (i,j) = max(prev[k] + points[i][j] + k - j , cell(i, j)) i.e   cell (i,j) = max(prev[k]  + k points[i][j] - j , cell(i, j)) for k = j to m`  where m is size of columns\\n\\nAbove both can be acheive using heap data strucuture below the code. We need to keep left and right max using heap\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<long long> prev(m);\\n        for (int i =0 ; i < m; i++) prev[i] = points[0][i];\\n        for (int i = 1 ; i < n; i++) {\\n            multiset<long long>left, right;\\n            vector<long long> curr(m);\\n            for (int j = 0; j < m; j++) right.insert(prev[j] - j); // For condition 2\\n            for (int j = 0;j < m; j++) {\\n                left.insert(prev[j] + j); // For condition 1\\n                long long L = *left.rbegin(), R = *right.rbegin();\\n                curr[j] = max(L - j, R + j) + points[i][j];\\n                right.erase(right.find(prev[j] - j));\\n            }\\n            prev = curr;\\n        }\\n        long long ans = 0;\\n        for (int i =0 ; i < m; i++) ans = max(ans, prev[i]);\\n       return ans;\\n    }\\n};\\n```\\nComplexity\\n```\\nTime : O(n*mlogm) \\nSpace: O(m)\\n```\\nIf we notice we only need Maximum from Left and right which can be tracked using deque data structure \\nBelow is code for same\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<long long>prev(m);\\n        for (int j =0 ; j < m ; j++) prev[j] = points[0][j];\\n        for (int i = 1 ; i < n; i ++) {\\n            deque<long long> left, right;\\n            vector<long long>next(m);\\n            for (int j = 0 ; j < m; j++) {\\n                while (!left.empty() && left.back() <= prev[j] + j) left.pop_back();\\n                left.push_back(prev[j] + j);\\n                next[j] = left[0] + points[i][j] - j;\\n            }\\n            for (int j = m - 1; j >= 0; j--) {\\n                while (!right.empty() && right.back() <= prev[j] - j) right.pop_back();\\n                right.push_back(prev[j] - j);\\n                next[j] = max(next[j], right[0] + points[i][j] + j);\\n            } \\n            prev = next;\\n        }\\n        long long ans =0;\\n        for (int j =0 ; j < m; j++) ans = max(ans, prev[j]);\\n        return ans;\\n    }\\n};\\n```\\nComplexity\\n```\\nTime : O(n*m) \\nSpace: O(m)\\n```\\nIf we observed carefully we can track max using a single variable for both left and right below is the code\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<long long>prev(m);\\n        for (int j =0 ; j < m ; j++) prev[j] = points[0][j];\\n        for (int i = 1 ; i < n; i ++) {\\n            vector<long long>curr(m);\\n            long long runMax = LONG_MIN;\\n            for (int j = 0 ; j < m; j++) {\\n                runMax = max(runMax, prev[j] + j); // Max Till j from left\\n                curr[j] = runMax + points[i][j] - j;\\n            }\\n            runMax = LONG_MIN;\\n            for (int j = m - 1; j >= 0; j--) {\\n                runMax = max(runMax, prev[j] - j);  // Max till j from right\\n                curr[j] = max(curr[j], runMax + points[i][j] + j);\\n            } \\n            for (int j = 0; j < m; j++) prev[j] = curr[j];\\n        }\\n        long long ans =0;\\n        for (int j =0 ; j < m; j++) ans = max(ans, prev[j]);\\n        return ans;\\n    }\\n};\\n```\\nPlease comment if you are not able to understand anything \\n\\n\\t",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>>M;\\n    vector<vector<int>>DP;\\n    int solve(int r, int c) {\\n        if (r  >= n) return 0;\\n        int &ret = DP[r][c];\\n        if (ret != -1) return ret;\\n        ret = 0;\\n        for (int i= 0; i < m; i++)  {\\n            ret = max(ret, solve(r + 1, i)  + M[r][i] - abs(c - i));\\n        }\\n        return ret;\\n    }\\n    long long maxPoints(vector<vector<int>>& points) {\\n        M = points, n = points.size(), m = points[0].size();\\n        int ans =0 ;\\n        DP = vector<vector<int>>(n, vector<int>(m, -1));\\n        for (int i =0 ; i < m; i++) ans = max(ans, solve(1 , i) + M[0][i]);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<long long> prev(m);\\n        for (int i =0 ; i < m; i++) prev[i] = points[0][i];\\n        for (int i = 1 ; i < n; i++) {\\n            multiset<long long>left, right;\\n            vector<long long> curr(m);\\n            for (int j = 0; j < m; j++) right.insert(prev[j] - j); // For condition 2\\n            for (int j = 0;j < m; j++) {\\n                left.insert(prev[j] + j); // For condition 1\\n                long long L = *left.rbegin(), R = *right.rbegin();\\n                curr[j] = max(L - j, R + j) + points[i][j];\\n                right.erase(right.find(prev[j] - j));\\n            }\\n            prev = curr;\\n        }\\n        long long ans = 0;\\n        for (int i =0 ; i < m; i++) ans = max(ans, prev[i]);\\n       return ans;\\n    }\\n};\\n```\n```\\nTime : O(n*mlogm) \\nSpace: O(m)\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<long long>prev(m);\\n        for (int j =0 ; j < m ; j++) prev[j] = points[0][j];\\n        for (int i = 1 ; i < n; i ++) {\\n            deque<long long> left, right;\\n            vector<long long>next(m);\\n            for (int j = 0 ; j < m; j++) {\\n                while (!left.empty() && left.back() <= prev[j] + j) left.pop_back();\\n                left.push_back(prev[j] + j);\\n                next[j] = left[0] + points[i][j] - j;\\n            }\\n            for (int j = m - 1; j >= 0; j--) {\\n                while (!right.empty() && right.back() <= prev[j] - j) right.pop_back();\\n                right.push_back(prev[j] - j);\\n                next[j] = max(next[j], right[0] + points[i][j] + j);\\n            } \\n            prev = next;\\n        }\\n        long long ans =0;\\n        for (int j =0 ; j < m; j++) ans = max(ans, prev[j]);\\n        return ans;\\n    }\\n};\\n```\n```\\nTime : O(n*m) \\nSpace: O(m)\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<long long>prev(m);\\n        for (int j =0 ; j < m ; j++) prev[j] = points[0][j];\\n        for (int i = 1 ; i < n; i ++) {\\n            vector<long long>curr(m);\\n            long long runMax = LONG_MIN;\\n            for (int j = 0 ; j < m; j++) {\\n                runMax = max(runMax, prev[j] + j); // Max Till j from left\\n                curr[j] = runMax + points[i][j] - j;\\n            }\\n            runMax = LONG_MIN;\\n            for (int j = m - 1; j >= 0; j--) {\\n                runMax = max(runMax, prev[j] - j);  // Max till j from right\\n                curr[j] = max(curr[j], runMax + points[i][j] + j);\\n            } \\n            for (int j = 0; j < m; j++) prev[j] = curr[j];\\n        }\\n        long long ans =0;\\n        for (int j =0 ; j < m; j++) ans = max(ans, prev[j]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344967,
                "title": "dp-naive-solution-o-m-n-2-tle-optimised-solution-o-m-n-ac-python3",
                "content": "Naive Approach. For each column in each row, consider all the columns in the next row.\\nTime Complexity O(m*n^2)\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m = len(points)\\n        n = len(points[0])\\n        prevdp = points[-1]\\n        dp = [-float(\"inf\") for i in range(n)]\\n        \\n        \\n        for row in range(m-2, -1, -1):\\n            for col in range(n):\\n                for prevcol in range(n):\\n                    dp[col] = max(dp[col], points[row][col] + prevdp[prevcol] - abs(col-prevcol))\\n            prevdp = dp.copy()\\n            \\n        return max(prevdp)\\n```\\nOptimised Solution.\\nKeep track of leftMax and rightMax after subtracting the cost for each element in a row.\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m = len(points)\\n        n = len(points[0])\\n        \\n        \\n        prevdp = points[0]\\n        for row in range(1, len(points)):\\n            dp = [float(-inf)] * n\\n            \\n            leftMax = float(-inf)\\n            \\n            for col in range(n):\\n                leftMax = max(leftMax, prevdp[col])\\n                \\n                dp[col] = max(dp[col], leftMax + points[row][col])\\n                \\n                #decrement leftMax for next column\\n                leftMax -= 1\\n                \\n            rightMax = float(-inf)\\n            \\n            for col in range(n - 1, -1, -1):\\n                rightMax = max(rightMax, prevdp[col])\\n                \\n                dp[col] = max(dp[col], rightMax + points[row][col])\\n                \\n                #decrement rightMax for next column\\n                rightMax-= 1\\n                \\n            prevdp = dp\\n        return max(prevdp)\\n\\n            \\n        \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m = len(points)\\n        n = len(points[0])\\n        prevdp = points[-1]\\n        dp = [-float(\"inf\") for i in range(n)]\\n        \\n        \\n        for row in range(m-2, -1, -1):\\n            for col in range(n):\\n                for prevcol in range(n):\\n                    dp[col] = max(dp[col], points[row][col] + prevdp[prevcol] - abs(col-prevcol))\\n            prevdp = dp.copy()\\n            \\n        return max(prevdp)\\n```\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m = len(points)\\n        n = len(points[0])\\n        \\n        \\n        prevdp = points[0]\\n        for row in range(1, len(points)):\\n            dp = [float(-inf)] * n\\n            \\n            leftMax = float(-inf)\\n            \\n            for col in range(n):\\n                leftMax = max(leftMax, prevdp[col])\\n                \\n                dp[col] = max(dp[col], leftMax + points[row][col])\\n                \\n                #decrement leftMax for next column\\n                leftMax -= 1\\n                \\n            rightMax = float(-inf)\\n            \\n            for col in range(n - 1, -1, -1):\\n                rightMax = max(rightMax, prevdp[col])\\n                \\n                dp[col] = max(dp[col], rightMax + points[row][col])\\n                \\n                #decrement rightMax for next column\\n                rightMax-= 1\\n                \\n            prevdp = dp\\n        return max(prevdp)\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408129,
                "title": "python-dp-with-detailed-explaination",
                "content": "Thought process below: \\n- This is a graph problem and weighted path problem. Immediately there are several things that can come to mind\\n\\t- If there is a clear topological order of some sort, you can DP solve this (ended up taking this approach)\\n\\t- If there is no negative cycle, it could be Dijkstra (not as efficient as topo + DP) \\n\\t- if there is negative cycle, bellmen ford is pretty much the only choice \\n- Here we are looking at a however **Longest** path from **Multiple** sources so it\\'s hard to adopt Dijkstra or Bellmen-Ford. That means DP is our only choice\\n- DP focuses on avoiding duplicate calculations. There are two major duplications here, one **horizontally**, one **vertically** \\n\\t- **Horizontally**: In this example here `arr = [[1, 2, 3], [4, 5, 6]]`, if I know what works best for `arr[1][1]` from its left side in terms of total points (gain from cell value - cost from cell traversal) , I can easily know what works best for `arr[1][2]` from its left side. Effectively \\n\\t\\t```Python \\n\\t\\tleftmax(row, col) = max(leftmax(row, col-1) - 1), arr[row][col-1] - 1) \\n\\t\\trightmax(row, col) = max(rightmax(row, col+1) - 1), arr[row][col+1] - 1) \\n\\t\\t```\\n\\t\\t\\n\\t- **Vertically**: If I know what works best for my upper cell, I know what works best for me, because my uppercell and I cost the same to other columns. Effectively \\n\\t  ```Python \\n\\t  curLeft(row, col),  = leftmax(row-1, col) + arr[row][col]\\n\\t  curRight(row, col) = rightmax(row-1, col) + arr[row][col]\\n\\t  curMax(row, col) = (curLeft, curMax(row-1, col)+arr[row][col], curRight)\\n      ```\\n- Now I can write out the code and I would set c to be current max points of a row, cLSR to be a 2D array of `[[curLeft, self, curRight]..]`. Honestly feel like this could be better written \\n\\n```Python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        rows, cols = len(points), len(points[0])\\n\\n        if rows == 1: \\n            return max(points[0])\\n        c = points[0]\\n        cLSR = [[0, pts, 0] for pts in c]\\n        \\n        lmax, rmax = 0, 0\\n        # left scan and right scan to apply horizontal dp \\n        for i in range(1, cols): \\n            lmax = max(lmax-1, c[i-1]-1)\\n            cLSR[i][0] = lmax \\n        for i in reversed(range(cols-1)): \\n            rmax = max(rmax-1, c[i+1]-1)\\n            cLSR[i][2] = rmax\\n        \\n        for row in range(1, rows): \\n\\t\\t\\t# vertical\\n            for col in range(cols): \\n                cLSR[col] = [pts + points[row][col] for pts in cLSR[col]]\\n            c = [max(cLSR[i]) for i in range(cols)]\\n            cLSR, lmax, rmax = [[0, pts, 0] for pts in c], 0, 0\\n\\t\\t\\t# horizontal \\n            for i in range(1, cols): \\n                lmax = max(lmax-1, c[i-1]-1)\\n                cLSR[i][0] = lmax\\n            for i in reversed(range(cols-1)): \\n                rmax = max(rmax-1, c[i+1]-1)\\n                cLSR[i][2] = rmax\\n        \\n        return max(c)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```Python \\n\\t\\tleftmax(row, col) = max(leftmax(row, col-1) - 1), arr[row][col-1] - 1) \\n\\t\\trightmax(row, col) = max(rightmax(row, col+1) - 1), arr[row][col+1] - 1) \\n\\t\\t```\n```Python \\n\\t  curLeft(row, col),  = leftmax(row-1, col) + arr[row][col]\\n\\t  curRight(row, col) = rightmax(row-1, col) + arr[row][col]\\n\\t  curMax(row, col) = (curLeft, curMax(row-1, col)+arr[row][col], curRight)\\n      ```\n```Python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        rows, cols = len(points), len(points[0])\\n\\n        if rows == 1: \\n            return max(points[0])\\n        c = points[0]\\n        cLSR = [[0, pts, 0] for pts in c]\\n        \\n        lmax, rmax = 0, 0\\n        # left scan and right scan to apply horizontal dp \\n        for i in range(1, cols): \\n            lmax = max(lmax-1, c[i-1]-1)\\n            cLSR[i][0] = lmax \\n        for i in reversed(range(cols-1)): \\n            rmax = max(rmax-1, c[i+1]-1)\\n            cLSR[i][2] = rmax\\n        \\n        for row in range(1, rows): \\n\\t\\t\\t# vertical\\n            for col in range(cols): \\n                cLSR[col] = [pts + points[row][col] for pts in cLSR[col]]\\n            c = [max(cLSR[i]) for i in range(cols)]\\n            cLSR, lmax, rmax = [[0, pts, 0] for pts in c], 0, 0\\n\\t\\t\\t# horizontal \\n            for i in range(1, cols): \\n                lmax = max(lmax-1, c[i-1]-1)\\n                cLSR[i][0] = lmax\\n            for i in reversed(range(cols-1)): \\n                rmax = max(rmax-1, c[i+1]-1)\\n                cLSR[i][2] = rmax\\n        \\n        return max(c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371026,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n\\n        long maxPoints = 0;\\n\\n        long[][] dp = new long[points.length][points[0].length];\\n\\n        // Copy first row\\n        for (int i = 0; i < points[0].length; i++)\\n            dp[0][i] = points[0][i];\\n\\n        for (int i = 1; i < dp.length; i++) {\\n\\n            long[] prevDPRow = dp[i - 1];\\n\\n            // Calculate prefix max for prev DP row\\n            long[] prevDPRowPrefixMax = new long[dp[i - 1].length];\\n            prevDPRowPrefixMax[0] = prevDPRow[0];\\n            for (int j = 1; j < prevDPRow.length; j++)\\n                prevDPRowPrefixMax[j] = Math.max(prevDPRowPrefixMax[j - 1] - 1, prevDPRow[j]);\\n\\n            // Calculate suffix max for prev DP row\\n            long[] prevDPRowSuffixMax = new long[prevDPRow.length];\\n            prevDPRowSuffixMax[prevDPRowSuffixMax.length - 1] = prevDPRow[prevDPRow.length - 1];\\n            for (int j = prevDPRow.length - 2; j >= 0; j--)\\n                prevDPRowSuffixMax[j] = Math.max(prevDPRowSuffixMax[j + 1] - 1, prevDPRow[j]);\\n\\n            // Use prefix max and suffix max to get the max points for current cell\\n            for (int j = 0; j < dp[i].length; j++)\\n                dp[i][j] = points[i][j] + Math.max(prevDPRowPrefixMax[j], prevDPRowSuffixMax[j]);\\n        }\\n\\n        // Max value in the last row of DP is the answer\\n        long[] lastRow = dp[dp.length - 1];\\n        for (long totalPoints : lastRow)\\n            maxPoints = Math.max(totalPoints, maxPoints);\\n\\n        return maxPoints;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n\\n        long maxPoints = 0;\\n\\n        long[][] dp = new long[points.length][points[0].length];\\n\\n        // Copy first row\\n        for (int i = 0; i < points[0].length; i++)\\n            dp[0][i] = points[0][i];\\n\\n        for (int i = 1; i < dp.length; i++) {\\n\\n            long[] prevDPRow = dp[i - 1];\\n\\n            // Calculate prefix max for prev DP row\\n            long[] prevDPRowPrefixMax = new long[dp[i - 1].length];\\n            prevDPRowPrefixMax[0] = prevDPRow[0];\\n            for (int j = 1; j < prevDPRow.length; j++)\\n                prevDPRowPrefixMax[j] = Math.max(prevDPRowPrefixMax[j - 1] - 1, prevDPRow[j]);\\n\\n            // Calculate suffix max for prev DP row\\n            long[] prevDPRowSuffixMax = new long[prevDPRow.length];\\n            prevDPRowSuffixMax[prevDPRowSuffixMax.length - 1] = prevDPRow[prevDPRow.length - 1];\\n            for (int j = prevDPRow.length - 2; j >= 0; j--)\\n                prevDPRowSuffixMax[j] = Math.max(prevDPRowSuffixMax[j + 1] - 1, prevDPRow[j]);\\n\\n            // Use prefix max and suffix max to get the max points for current cell\\n            for (int j = 0; j < dp[i].length; j++)\\n                dp[i][j] = points[i][j] + Math.max(prevDPRowPrefixMax[j], prevDPRowSuffixMax[j]);\\n        }\\n\\n        // Max value in the last row of DP is the answer\\n        long[] lastRow = dp[dp.length - 1];\\n        for (long totalPoints : lastRow)\\n            maxPoints = Math.max(totalPoints, maxPoints);\\n\\n        return maxPoints;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339551,
                "title": "java-easy-to-understand-self-explanatory-dp",
                "content": "class Solution {\\n    public long maxPoints(int[][] points) {\\n        int n=points.length;\\n        int m=points[0].length;\\n        \\n        long dp[][]=new long[n][m];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[0][i]=points[0][i];\\n        \\n        long left[]=new long[m];\\n        long right[]=new long[m];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            left[0]=dp[i-1][0];\\n            right[m-1]=dp[i-1][m-1];\\n            \\n            for(int j=1;j<m;j++)\\n                left[j]=Math.max(dp[i-1][j],left[j-1]-1);\\n            \\n            for(int j=m-2;j>=0;j--)\\n                right[j]=Math.max(dp[i-1][j],right[j+1]-1);\\n            \\n            for(int j=0;j<m;j++)\\n                dp[i][j]=Math.max(left[j],right[j])+points[i][j];\\n        }\\n        \\n        long ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n            ans=Math.max(ans,dp[n-1][i]);\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public long maxPoints(int[][] points) {\\n        int n=points.length;\\n        int m=points[0].length;\\n        \\n        long dp[][]=new long[n][m];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[0][i]=points[0][i];\\n        \\n        long left[]=new long[m];\\n        long right[]=new long[m];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            left[0]=dp[i-1][0];\\n            right[m-1]=dp[i-1][m-1];\\n            \\n            for(int j=1;j<m;j++)\\n                left[j]=Math.max(dp[i-1][j],left[j-1]-1);\\n            \\n            for(int j=m-2;j>=0;j--)\\n                right[j]=Math.max(dp[i-1][j],right[j+1]-1);\\n            \\n            for(int j=0;j<m;j++)\\n                dp[i][j]=Math.max(left[j],right[j])+points[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2240549,
                "title": "python-dynamic-programming-similar-to-sight-seeing-pair-problem",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    we can try to solve this problem using approach similar to sight seeing pair problem\\n    \"\"\"\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m = len(points)\\n        n = len(points[0])\\n        dp = [[-1 for _ in range(n)] for _ in range(m)]\\n        # set the first row to the first row of points\\n        for i in range(n):\\n            dp[0][i] = points[0][i]\\n        \\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0]\\n            dp[i][-1] = dp[i-1][-1]\\n            \\n            for j in range(1, n):\\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]-1)\\n                \\n            for j in range(n-2, -1, -1):\\n                dp[i][j] = max(dp[i-1][j], dp[i][j+1]-1, dp[i][j])\\n            \\n            for j in range(0, n):\\n                dp[i][j] += points[i][j]\\n        return max(dp[-1])\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    we can try to solve this problem using approach similar to sight seeing pair problem\\n    \"\"\"\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m = len(points)\\n        n = len(points[0])\\n        dp = [[-1 for _ in range(n)] for _ in range(m)]\\n        # set the first row to the first row of points\\n        for i in range(n):\\n            dp[0][i] = points[0][i]\\n        \\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0]\\n            dp[i][-1] = dp[i-1][-1]\\n            \\n            for j in range(1, n):\\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]-1)\\n                \\n            for j in range(n-2, -1, -1):\\n                dp[i][j] = max(dp[i-1][j], dp[i][j+1]-1, dp[i][j])\\n            \\n            for j in range(0, n):\\n                dp[i][j] += points[i][j]\\n        return max(dp[-1])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908073,
                "title": "o-mn-time-and-o-n-space",
                "content": "The jist is go \"left to right\" and \"right to left\" on each row and find out what is the maximum value that can be carried over at each column.\\nFor example a row like [ 2, 2, 2, 5] the Maximums at each column are [2, 3, 4, 5].\\n\\nWhen you traverse to the next column use the calcualted DP[i][j] and add to current row and check repeat what is the maximum that can be carried over again.\\nFor example if the second row is [5,2,2 ,2] add the DP values from before so new is = [7,5,6,7] and then travel left to right and right to left to check what is the maximum that can be carried over to next row. Result = [7,6,6,7]\\n\\nReturn the Max of DP at the end.\\n\\n```\\npublic class Solution {\\n    public long MaxPoints(int[][] points) {               \\n        int MaxL = points.Length;\\n        int MaxH = points[0].Length;\\n        long[] tempDP = new long[MaxH];\\n        \\n        for(int i = 0; i < MaxL; i++)\\n        {\\n            tempDP[0] = tempDP[0] + points[i][0];\\n            \\n            for(int j = 1; j < MaxH; j++)\\n            {\\n                tempDP[j] = Math.Max(tempDP[j] + points[i][j], tempDP[j-1]-1);\\n            }\\n            \\n            for(int j = MaxH-2; j >= 0; j--)\\n            {\\n                tempDP[j] = Math.Max(tempDP[j], tempDP[j+1]-1);\\n            }\\n        }    \\n        \\n        return tempDP.Max();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxPoints(int[][] points) {               \\n        int MaxL = points.Length;\\n        int MaxH = points[0].Length;\\n        long[] tempDP = new long[MaxH];\\n        \\n        for(int i = 0; i < MaxL; i++)\\n        {\\n            tempDP[0] = tempDP[0] + points[i][0];\\n            \\n            for(int j = 1; j < MaxH; j++)\\n            {\\n                tempDP[j] = Math.Max(tempDP[j] + points[i][j], tempDP[j-1]-1);\\n            }\\n            \\n            for(int j = MaxH-2; j >= 0; j--)\\n            {\\n                tempDP[j] = Math.Max(tempDP[j], tempDP[j+1]-1);\\n            }\\n        }    \\n        \\n        return tempDP.Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784447,
                "title": "c-o-n-m-m-and-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        vector<vector<long long>>DP(points.size(),vector<long long>(points[0].size(),(long long)0));\\n        \\n        for(int col = 0; col < points[0].size(); col++){\\n            DP[0][col] = points[0][col];\\n        }\\n        \\n        for(int row = 1; row < points.size(); row++){\\n            vector<long long> fromLeft(points[row].size(),0);\\n            vector<long long> fromRight(points[row].size(),0);\\n            \\n            fromLeft[0] = DP[row-1][0];\\n            fromRight.back() = DP[row-1].back();\\n            \\n            for(int col = 1; col < points[row].size(); col++){\\n                fromLeft[col] = max(DP[row-1][col] , fromLeft[col-1] - 1);\\n            }\\n            for(int col = points[row].size()-2; col >= 0; col--){\\n                fromRight[col] = max(DP[row-1][col], fromRight[col+1] - 1);\\n            }\\n            \\n            for(int col = 0; col < points[row].size(); col++){\\n                DP[row][col] = max(fromLeft[col],fromRight[col]) + points[row][col];\\n            }\\n            /*\\n            for(int col = 0; col < points[0].size(); col++){\\n                DP[row][col] = maxValFromPrevRow(DP,row-1,col) + points[row][col];\\n            }\\n            */\\n        }\\n        \\n        return *max_element(DP.back().begin(), DP.back().end());\\n\\n    }                                                     \\n  \\nprivate:\\n    /*\\n    long long maxValFromPrevRow(const vector<vector<long long>>& DP, int row, int col){\\n        long long ans{};\\n        for(int i = 0; i < DP[0].size(); i++){\\n            ans = max(ans, DP[row][i] - abs(i-col));\\n        }\\n        return ans;\\n    }\\n    */\\n                             \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        vector<vector<long long>>DP(points.size(),vector<long long>(points[0].size(),(long long)0));\\n        \\n        for(int col = 0; col < points[0].size(); col++){\\n            DP[0][col] = points[0][col];\\n        }\\n        \\n        for(int row = 1; row < points.size(); row++){\\n            vector<long long> fromLeft(points[row].size(),0);\\n            vector<long long> fromRight(points[row].size(),0);\\n            \\n            fromLeft[0] = DP[row-1][0];\\n            fromRight.back() = DP[row-1].back();\\n            \\n            for(int col = 1; col < points[row].size(); col++){\\n                fromLeft[col] = max(DP[row-1][col] , fromLeft[col-1] - 1);\\n            }\\n            for(int col = points[row].size()-2; col >= 0; col--){\\n                fromRight[col] = max(DP[row-1][col], fromRight[col+1] - 1);\\n            }\\n            \\n            for(int col = 0; col < points[row].size(); col++){\\n                DP[row][col] = max(fromLeft[col],fromRight[col]) + points[row][col];\\n            }\\n            /*\\n            for(int col = 0; col < points[0].size(); col++){\\n                DP[row][col] = maxValFromPrevRow(DP,row-1,col) + points[row][col];\\n            }\\n            */\\n        }\\n        \\n        return *max_element(DP.back().begin(), DP.back().end());\\n\\n    }                                                     \\n  \\nprivate:\\n    /*\\n    long long maxValFromPrevRow(const vector<vector<long long>>& DP, int row, int col){\\n        long long ans{};\\n        for(int i = 0; i < DP[0].size(); i++){\\n            ans = max(ans, DP[row][i] - abs(i-col));\\n        }\\n        return ans;\\n    }\\n    */\\n                             \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781446,
                "title": "i-really-can-t-understand-why-recursion-memorization-got-tle",
                "content": "I found a very similar question in another discussion, but the only 1 answer does not make sense to me...\\nhttps://leetcode.com/problems/maximum-number-of-points-with-cost/discuss/1355299/Why-java-top-down-with-memory-cache-TLE\\n\\nMy Code:\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        if (points.length == 0) return 0;\\n        \\n        long[][] visited = new long[points.length][points[0].length];\\n        long result = Long.MIN_VALUE;\\n        for (int i = 0; i < points[0].length; i++) {\\n            long cur = helper(points, 0, visited, i);\\n            if (result < cur) {\\n                result = cur;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private long helper(int[][] points, int row, long[][] visited, int col) {\\n        if (row == points.length) return 0;\\n        if (visited[row][col] != 0) return visited[row][col];\\n        \\n        long max = Long.MIN_VALUE;\\n        for (int i = 0; i < points[0].length; i++) {\\n            long cur = helper(points, row + 1, visited, i);\\n            long sum = points[row][col] - Math.abs(col - i);\\n            cur += sum;\\n            if (max < cur) {\\n                max = cur;\\n            }\\n        }\\n        \\n        visited[row][col] = max;\\n        return max;\\n    }\\n}\\n```\\n\\nThe code also filling up a 2D array (m*n), each node in the array will be only calculated once, so the time complexity there I think is O(n^2), which is same with the dp solution. Can anybody explain to me why this get TLE??\\n\\nPlease correct me if I am wrong with the time complexity analysis. I also setup the debugger and make sure all nodes are only calculated once.",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        if (points.length == 0) return 0;\\n        \\n        long[][] visited = new long[points.length][points[0].length];\\n        long result = Long.MIN_VALUE;\\n        for (int i = 0; i < points[0].length; i++) {\\n            long cur = helper(points, 0, visited, i);\\n            if (result < cur) {\\n                result = cur;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private long helper(int[][] points, int row, long[][] visited, int col) {\\n        if (row == points.length) return 0;\\n        if (visited[row][col] != 0) return visited[row][col];\\n        \\n        long max = Long.MIN_VALUE;\\n        for (int i = 0; i < points[0].length; i++) {\\n            long cur = helper(points, row + 1, visited, i);\\n            long sum = points[row][col] - Math.abs(col - i);\\n            cur += sum;\\n            if (max < cur) {\\n                max = cur;\\n            }\\n        }\\n        \\n        visited[row][col] = max;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752910,
                "title": "simple-java-solution-using-array-faster-than-100",
                "content": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int row = points.length;\\n        int col = points[0].length;\\n        long[] cur = new long[col];\\n        for(int i=0; i<row; i++){\\n            cur[0] += points[i][0];\\n            for(int j=1; j<col; j++)\\n                cur[j] = Math.max(cur[j-1]-1, cur[j]+points[i][j]);\\n            for(int j=col-2; j>=0; j--)\\n                cur[j] = Math.max(cur[j+1]-1, cur[j]);\\n        }\\n        \\n        long max = 0;\\n        for(long val: cur) max = Math.max(max, val);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int row = points.length;\\n        int col = points[0].length;\\n        long[] cur = new long[col];\\n        for(int i=0; i<row; i++){\\n            cur[0] += points[i][0];\\n            for(int j=1; j<col; j++)\\n                cur[j] = Math.max(cur[j-1]-1, cur[j]+points[i][j]);\\n            for(int j=col-2; j>=0; j--)\\n                cur[j] = Math.max(cur[j+1]-1, cur[j]);\\n        }\\n        \\n        long max = 0;\\n        for(long val: cur) max = Math.max(max, val);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704260,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        M = len(points)\\n        N = len(points[0])\\n        dp = [[0]*N for _ in range(M)]\\n        \\n        for i in range(N):\\n            dp[0][i] = points[0][i]\\n            \\n        for i in range(1, M):\\n            rollingMax = float(\\'-inf\\')\\n            for j in range(N):\\n                rollingMax = max(rollingMax, dp[i-1][j] + j)\\n                dp[i][j] = points[i][j] + rollingMax - j\\n                \\n            rollingMax = float(\\'-inf\\')\\n            for j in range(N-1, -1, -1):\\n                rollingMax = max(rollingMax, dp[i-1][j] - j)\\n                dp[i][j] = max(dp[i][j], points[i][j] + rollingMax + j)\\n            \\n        \\n        return max(dp[M-1])\\n                \\n                \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        M = len(points)\\n        N = len(points[0])\\n        dp = [[0]*N for _ in range(M)]\\n        \\n        for i in range(N):\\n            dp[0][i] = points[0][i]\\n            \\n        for i in range(1, M):\\n            rollingMax = float(\\'-inf\\')\\n            for j in range(N):\\n                rollingMax = max(rollingMax, dp[i-1][j] + j)\\n                dp[i][j] = points[i][j] + rollingMax - j\\n                \\n            rollingMax = float(\\'-inf\\')\\n            for j in range(N-1, -1, -1):\\n                rollingMax = max(rollingMax, dp[i-1][j] - j)\\n                dp[i][j] = max(dp[i][j], points[i][j] + rollingMax + j)\\n            \\n        \\n        return max(dp[M-1])\\n                \\n                \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355299,
                "title": "why-java-top-down-with-memory-cache-tle",
                "content": "Passed 150 cases and initial idea comes from [#931](https://leetcode.com/problems/minimum-falling-path-sum/) \\n\\n```\\nclass Solution {\\n    long[][] memo;\\n    public long maxPoints(int[][] points) {\\n        memo = new long[points.length][points[0].length];\\n        for (long[] row : memo) Arrays.fill(row, -1);\\n        long res = 0;\\n        for (int j = 0; j < points[0].length; j++) res = Math.max(res, dp(points, 0, j));\\n        return res;\\n    }\\n    public long dp(int[][] points, int i, int j) {\\n        if (i == points.length-1) return points[i][j];\\n        if (memo[i][j] != -1) return memo[i][j];\\n        for (int col = 0; col < points[0].length; col++) {\\n            memo[i][j] = Math.max(memo[i][j], points[i][j]-Math.abs(col-j)+dp(points, i+1, col));\\n        }\\n        return memo[i][j];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long[][] memo;\\n    public long maxPoints(int[][] points) {\\n        memo = new long[points.length][points[0].length];\\n        for (long[] row : memo) Arrays.fill(row, -1);\\n        long res = 0;\\n        for (int j = 0; j < points[0].length; j++) res = Math.max(res, dp(points, 0, j));\\n        return res;\\n    }\\n    public long dp(int[][] points, int i, int j) {\\n        if (i == points.length-1) return points[i][j];\\n        if (memo[i][j] != -1) return memo[i][j];\\n        for (int col = 0; col < points[0].length; col++) {\\n            memo[i][j] = Math.max(memo[i][j], points[i][j]-Math.abs(col-j)+dp(points, i+1, col));\\n        }\\n        return memo[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353489,
                "title": "c-o-m-n-using-prefix-suffix-fully-explained",
                "content": "```\\n// O(N*M*M) solution: dp[i][j]=for all k 0 to m-> {  max(dp[i-1][k]+ points[i][j] + abs(j-k) )  }\\n// This abs factor is costing us O(m) operations so we break it into two half\\n\\n//  LEFT HALF  ->\\n\\n//   (for all values k of such that j>=k)\\n//  dp[i][j]= dp[i-1][k] + points[i][j] - (j-k);\\n// ->   dp[i][j]=(dp[i-1][k] + k) + (points[i][j] - j)\\n// ->   (points[i][j] - j) is constant so we need to maximize (dp[i-1][k]+k)\\n// -> so we keep track of the max value as prefix from 0 to the jth point in left vector\\n\\n// RIGHT HALF ->\\n//   (for all values k of such that j<=k)\\n//  dp[i][j]= dp[i-1][k] + points[i][j] - (k-j);\\n// ->   dp[i][j]=(dp[i-1][k] - k) + (points[i][j] + j)\\n// ->   (points[i][j]+j) is constant so we need to maximize (dp[i-1][k]-k)\\n// -> so we keep track of the max value as suffix from m-1 to the jth point in right vector\\n\\n// Below is the c++ implentation of this approach\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& pts) {\\n        int n=pts.size();\\n        int m=pts[0].size();\\n        vector<vector<long long>>dp(n,vector<long long>(m));\\n        for(int i=0;i<m;i++)\\n           dp[0][i]=pts[0][i];\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<long long>left(m),right(m);\\n            left[0]=dp[i-1][0];\\n            for(int k=1;k<m;k++)\\n                left[k]=max(left[k-1],dp[i-1][k]+k);\\n            right[m-1]=dp[i-1][m-1]-(m-1);\\n            for(int k=m-2;k>=0;k--)\\n                right[k]=max(right[k+1],dp[i-1][k]-k);\\n            \\n            for(int j=0;j<m;j++)\\n                dp[i][j]=max(left[j]-j,right[j]+j)+pts[i][j];\\n        }\\n        long long ans=INT_MIN;\\n        for(int i=0;i<m;i++)\\n            ans=max(ans,dp[n-1][i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// O(N*M*M) solution: dp[i][j]=for all k 0 to m-> {  max(dp[i-1][k]+ points[i][j] + abs(j-k) )  }\\n// This abs factor is costing us O(m) operations so we break it into two half\\n\\n//  LEFT HALF  ->\\n\\n//   (for all values k of such that j>=k)\\n//  dp[i][j]= dp[i-1][k] + points[i][j] - (j-k);\\n// ->   dp[i][j]=(dp[i-1][k] + k) + (points[i][j] - j)\\n// ->   (points[i][j] - j) is constant so we need to maximize (dp[i-1][k]+k)\\n// -> so we keep track of the max value as prefix from 0 to the jth point in left vector\\n\\n// RIGHT HALF ->\\n//   (for all values k of such that j<=k)\\n//  dp[i][j]= dp[i-1][k] + points[i][j] - (k-j);\\n// ->   dp[i][j]=(dp[i-1][k] - k) + (points[i][j] + j)\\n// ->   (points[i][j]+j) is constant so we need to maximize (dp[i-1][k]-k)\\n// -> so we keep track of the max value as suffix from m-1 to the jth point in right vector\\n\\n// Below is the c++ implentation of this approach\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& pts) {\\n        int n=pts.size();\\n        int m=pts[0].size();\\n        vector<vector<long long>>dp(n,vector<long long>(m));\\n        for(int i=0;i<m;i++)\\n           dp[0][i]=pts[0][i];\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<long long>left(m),right(m);\\n            left[0]=dp[i-1][0];\\n            for(int k=1;k<m;k++)\\n                left[k]=max(left[k-1],dp[i-1][k]+k);\\n            right[m-1]=dp[i-1][m-1]-(m-1);\\n            for(int k=m-2;k>=0;k--)\\n                right[k]=max(right[k+1],dp[i-1][k]-k);\\n            \\n            for(int j=0;j<m;j++)\\n                dp[i][j]=max(left[j]-j,right[j]+j)+pts[i][j];\\n        }\\n        long long ans=INT_MIN;\\n        for(int i=0;i<m;i++)\\n            ans=max(ans,dp[n-1][i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350048,
                "title": "east-to-understand-java-n-m",
                "content": "```\\npublic long maxPoints(int[][] points) {\\n\\t\\tint n = points.length;\\n\\t\\tint m = points[0].length;\\n\\t\\tlong[] ans = new long[m];\\n\\t\\tlong[] left = new long[m];\\n\\t\\tlong[] right = new long[m];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\n\\t\\t\\t//making answer\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tans[j] = points[i][j] + Math.max(left[j], right[j]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// making left for next row answer\\n\\t\\t\\tleft[0] = ans[0];\\n\\t\\t\\tfor (int j = 1; j < m; j++) {\\n\\t\\t\\t\\tleft[j] = Math.max(left[j - 1] - 1, ans[j]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t//making right for next row answer\\n\\t\\t\\tright[m - 1] = ans[m - 1];\\n\\t\\t\\tfor (int j = m - 2; j >= 0; j--) {\\n\\t\\t\\t\\tright[j] = Math.max(right[j + 1] - 1, ans[j]);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tlong max = 0;\\n\\t\\tfor (long num : ans) {\\n\\t\\t\\tmax = Math.max(max, num);\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\n\\t}",
                "solutionTags": [],
                "code": "```\\npublic long maxPoints(int[][] points) {\\n\\t\\tint n = points.length;\\n\\t\\tint m = points[0].length;\\n\\t\\tlong[] ans = new long[m];\\n\\t\\tlong[] left = new long[m];\\n\\t\\tlong[] right = new long[m];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\n\\t\\t\\t//making answer\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tans[j] = points[i][j] + Math.max(left[j], right[j]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// making left for next row answer\\n\\t\\t\\tleft[0] = ans[0];\\n\\t\\t\\tfor (int j = 1; j < m; j++) {\\n\\t\\t\\t\\tleft[j] = Math.max(left[j - 1] - 1, ans[j]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t//making right for next row answer\\n\\t\\t\\tright[m - 1] = ans[m - 1];\\n\\t\\t\\tfor (int j = m - 2; j >= 0; j--) {\\n\\t\\t\\t\\tright[j] = Math.max(right[j + 1] - 1, ans[j]);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tlong max = 0;\\n\\t\\tfor (long num : ans) {\\n\\t\\t\\tmax = Math.max(max, num);\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1348770,
                "title": "python-3-dynamic-programming",
                "content": "States: Let `dp[i][j]` be the max points with cost for `rows[0,...,i]` if pick number `j` on `row[i]`. \\n\\nBase case: `dp[0][j] = p[0][j]`.\\n\\nInduction rule: `dp[i][j] = max(dp[i - 1][k] + p[i][j] - abs(k - j)) for k = 0,...,n - 1`.\\n\\nTime Complexity: $O(n^2 m)$. This will cause TLE.\\n\\nOptimize: rewrite the induction rule. Note that the absolute value is annoying. We split into cases and take the absolute value away.\\n\\n1. for `k = 0,...,j`: `-abs(k - j) = -(j - k) = + k - j`. `dp[i][j] = max_k(dp[i - 1][k] + k) + p[i][j] - j`. Note the second term is a constant. Use a rolling max from `0` to `j` so that we won\\'t calculate `max(dp[i - 1][k] + k)` each time using `O(n)`.\\n2. for `k = j,...,n`: `-abs(k - j) = -(j - k) = - k + j`. `dp[i][j] = max_k(dp[i - 1][k] - k) + p[i][j] + j`. Similarly, use a rolling max from `n - 1` to `j`.\\n\\nRolling max: the idea is that \"the maximum of the first `n` element\" is the maximum of \"the maximum the first `n - 1` elements\" and \"the `n`-th element\". \\n\\nI.e.`max{a[0],...,a[n]} = max{max{a[0],...,a[n - 1]}, a[n]}`. \\n\\nTime complexity: $O(mn)$\\n\\nSpace complexity: $O(mn)$ or $O(n)$\\n\\n```\\nclass Solution:\\n    def maxPoints(self, p: List[List[int]]) -> int:\\n        m, n = len(p), len(p[0])\\n        dp = p[0]\\n        tmp = [x for x in dp]\\n        pre_max, suf_max = [0] * n, [0] * n\\n        for i in range(1, m):\\n            pre_max[0] = tmp[0] + 0\\n            for k in range(1, n):\\n                pre_max[k] = max(pre_max[k - 1], tmp[k] + k)\\n            suf_max[n - 1] = tmp[n - 1] - (n - 1)\\n            for k in range(n - 2, -1, -1):\\n                suf_max[k] = max(suf_max[k + 1], tmp[k] - k)\\n            for j in range(n):\\n                dp[j] = max(pre_max[j] + p[i][j] - j, suf_max[j] + p[i][j] + j)\\n            tmp, dp = dp, tmp\\n        return max(tmp)\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, p: List[List[int]]) -> int:\\n        m, n = len(p), len(p[0])\\n        dp = p[0]\\n        tmp = [x for x in dp]\\n        pre_max, suf_max = [0] * n, [0] * n\\n        for i in range(1, m):\\n            pre_max[0] = tmp[0] + 0\\n            for k in range(1, n):\\n                pre_max[k] = max(pre_max[k - 1], tmp[k] + k)\\n            suf_max[n - 1] = tmp[n - 1] - (n - 1)\\n            for k in range(n - 2, -1, -1):\\n                suf_max[k] = max(suf_max[k + 1], tmp[k] - k)\\n            for j in range(n):\\n                dp[j] = max(pre_max[j] + p[i][j] - j, suf_max[j] + p[i][j] + j)\\n            tmp, dp = dp, tmp\\n        return max(tmp)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1345120,
                "title": "well-explained-88-faster-dp-pre-suff",
                "content": "## Idea :\\n\\n* Find prefix and suffix for each row\\n* then at each iteration find the max from both array and adding in current row values.\\n\\nFor index j in current row :\\ncurr[j] = max(left[j],right[j])+points[i][j]\\nthen\\npre = curr[:]\\n\\nFor a certain index j, the maximum value could from its left, or right(including itself). Thus we build two arrays, left, right, and focus on the maximum value only coming from its left or right.\\n\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        m = len(points)\\n        n = len(points[0])\\n        \\n        if m==1:\\n            return max(points[0])\\n        \\n        if n==1:\\n            s=0\\n            for j in range(m):\\n                s+=points[j][0]\\n            return s\\n        \\n        def lt(row):\\n            left = [ele for ele in row]\\n            for i in range(1,len(left)):\\n                left[i] = max(left[i], left[i-1]-1)\\n            return left\\n        \\n        def rt(row):\\n            right = [ele for ele in row]\\n            for i in range(len(row)-2,-1,-1):\\n                right[i] = max(right[i],right[i+1]-1)\\n            return right\\n        \\n        pre  = points[0]\\n        for i in range(1,m):\\n            left = lt(pre)\\n            right= rt(pre)\\n            curr = [0 for _ in range(n)]\\n            for j in range(n):\\n                curr[j] = points[i][j]+max(left[j],right[j])    \\n            pre = curr[:]\\n                        \\n        return max(pre)\\n\\nHope it would be helpful.\\n**Thanks!!** \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "## Idea :\\n\\n* Find prefix and suffix for each row\\n* then at each iteration find the max from both array and adding in current row values.\\n\\nFor index j in current row :\\ncurr[j] = max(left[j],right[j])+points[i][j]\\nthen\\npre = curr[:]\\n\\nFor a certain index j, the maximum value could from its left, or right(including itself). Thus we build two arrays, left, right, and focus on the maximum value only coming from its left or right.\\n\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        m = len(points)\\n        n = len(points[0])\\n        \\n        if m==1:\\n            return max(points[0])\\n        \\n        if n==1:\\n            s=0\\n            for j in range(m):\\n                s+=points[j][0]\\n            return s\\n        \\n        def lt(row):\\n            left = [ele for ele in row]\\n            for i in range(1,len(left)):\\n                left[i] = max(left[i], left[i-1]-1)\\n            return left\\n        \\n        def rt(row):\\n            right = [ele for ele in row]\\n            for i in range(len(row)-2,-1,-1):\\n                right[i] = max(right[i],right[i+1]-1)\\n            return right\\n        \\n        pre  = points[0]\\n        for i in range(1,m):\\n            left = lt(pre)\\n            right= rt(pre)\\n            curr = [0 for _ in range(n)]\\n            for j in range(n):\\n                curr[j] = points[i][j]+max(left[j],right[j])    \\n            pre = curr[:]\\n                        \\n        return max(pre)\\n\\nHope it would be helpful.\\n**Thanks!!** \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 2294332,
                "title": "python-o-m-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        prev = [0 for x in range(n)]\\n        \\n        # for each row\\n        for i in range(m):\\n            for j in range(1, n):\\n                prev[j] = max(prev[j], prev[j-1]-1)\\n            for j in range(n-2, -1, -1):\\n                prev[j] = max(prev[j], prev[j+1]-1)\\n            \\n            curr = points[i]\\n            curr = [x+y for x, y in zip(curr, prev)]\\n            prev = curr\\n        return max(curr)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        prev = [0 for x in range(n)]\\n        \\n        # for each row\\n        for i in range(m):\\n            for j in range(1, n):\\n                prev[j] = max(prev[j], prev[j-1]-1)\\n            for j in range(n-2, -1, -1):\\n                prev[j] = max(prev[j], prev[j+1]-1)\\n            \\n            curr = points[i]\\n            curr = [x+y for x, y in zip(curr, prev)]\\n            prev = curr\\n        return max(curr)",
                "codeTag": "Java"
            },
            {
                "id": 2191586,
                "title": "java-solution-o-m-n",
                "content": "```\\nclass Solution \\n{\\n    public long maxPoints(int[][] points)\\n    {\\n        long[] dp = new long[points[0].length];\\n        long max = 0;\\n        for(int i = 0;i<points[0].length;i++)\\n        {\\n            dp[i] = points[0][i];\\n            max = Math.max(max,dp[i]);\\n        }\\n        \\n        int n = points[0].length;\\n        for(int i = 1;i<points.length;i++)\\n        {\\n            \\n            long[] lr = new long[n];\\n            long[] rl = new long[n];\\n            long[] temp = new long[n];\\n            \\n            lr[0] = dp[0];\\n            rl[n-1] = dp[n-1] - (n-1);\\n            \\n            \\n            for(int j = 1;j<n;j++)\\n            {\\n                lr[j] = Math.max(lr[j-1],dp[j]+j);\\n            }\\n            \\n            for(int j = n-2;j>=0;j--)\\n            {\\n                rl[j] = Math.max(rl[j+1],dp[j]-j);\\n            }\\n            \\n            for(int j = 0;j<n;j++)\\n            {\\n                temp[j] = Math.max(rl[j]+points[i][j]+j , lr[j]+points[i][j]-j);\\n            }\\n            dp = temp;\\n        }\\n        \\n        for(long ele : dp) max = Math.max(max,ele);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    public long maxPoints(int[][] points)\\n    {\\n        long[] dp = new long[points[0].length];\\n        long max = 0;\\n        for(int i = 0;i<points[0].length;i++)\\n        {\\n            dp[i] = points[0][i];\\n            max = Math.max(max,dp[i]);\\n        }\\n        \\n        int n = points[0].length;\\n        for(int i = 1;i<points.length;i++)\\n        {\\n            \\n            long[] lr = new long[n];\\n            long[] rl = new long[n];\\n            long[] temp = new long[n];\\n            \\n            lr[0] = dp[0];\\n            rl[n-1] = dp[n-1] - (n-1);\\n            \\n            \\n            for(int j = 1;j<n;j++)\\n            {\\n                lr[j] = Math.max(lr[j-1],dp[j]+j);\\n            }\\n            \\n            for(int j = n-2;j>=0;j--)\\n            {\\n                rl[j] = Math.max(rl[j+1],dp[j]-j);\\n            }\\n            \\n            for(int j = 0;j<n;j++)\\n            {\\n                temp[j] = Math.max(rl[j]+points[i][j]+j , lr[j]+points[i][j]-j);\\n            }\\n            dp = temp;\\n        }\\n        \\n        for(long ele : dp) max = Math.max(max,ele);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165051,
                "title": "c-dynamic-programming-o-m-n",
                "content": "```\\n// please upvote if you like\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        ll m = points.size(), n = points[0].size();\\n        vector<ll>prev(n);\\n        for(int i = 0; i < n; i++) prev[i] = points[0][i];\\n        for(int i = 1; i < m; i++) {\\n            vector<ll>curr(n, 0);\\n            auto left = curr, right = curr;\\n            \\n            left[0] = prev[0];\\n            for(int j = 1; j < n; j++) left[j] = max(left[j - 1] - 1, prev[j]);\\n            \\n            right[n - 1] = prev[n - 1];\\n            for(int j = n - 2; j >= 0; j--) right[j] = max(right[j + 1] - 1, prev[j]);\\n            \\n            for(int j = 0; j < n; j++) curr[j] = points[i][j] + max(left[j], right[j]);\\n            prev = curr;\\n        }\\n        ll ans = prev[0];\\n        for(auto &i: prev) ans = max(ans, i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// please upvote if you like\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        ll m = points.size(), n = points[0].size();\\n        vector<ll>prev(n);\\n        for(int i = 0; i < n; i++) prev[i] = points[0][i];\\n        for(int i = 1; i < m; i++) {\\n            vector<ll>curr(n, 0);\\n            auto left = curr, right = curr;\\n            \\n            left[0] = prev[0];\\n            for(int j = 1; j < n; j++) left[j] = max(left[j - 1] - 1, prev[j]);\\n            \\n            right[n - 1] = prev[n - 1];\\n            for(int j = n - 2; j >= 0; j--) right[j] = max(right[j + 1] - 1, prev[j]);\\n            \\n            for(int j = 0; j < n; j++) curr[j] = points[i][j] + max(left[j], right[j]);\\n            prev = curr;\\n        }\\n        ll ans = prev[0];\\n        for(auto &i: prev) ans = max(ans, i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152523,
                "title": "t-o-m-n-m-o-m-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<long long> current_max_sum(m);\\n\\n        for(int i=0;i<n;i++) {\\n\\n            vector<long long> current_row(m);\\n            long long cur = 0;\\n            for(int j=0;j<m;j++) {\\n                long long current_point = current_max_sum[j] + points[i][j];\\n                current_row[j] = max(current_point, cur);\\n                cur = max(cur, current_point) - 1;\\n            }\\n            \\n            cur = 0;\\n            for(int j=m-1;j>=0;j--) {\\n                long long current_point = current_max_sum[j] + points[i][j];\\n                current_row[j] = max(current_row[j], max(current_point, cur));\\n                cur = max(cur, current_point) - 1;\\n            }\\n            \\n            current_max_sum = current_row;\\n        }\\n        \\n        long long max_val = 0;\\n        for(int j=0;j<m;j++) max_val = max(max_val, current_max_sum[j]);\\n        \\n        return max_val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(), m = points[0].size();\\n        vector<long long> current_max_sum(m);\\n\\n        for(int i=0;i<n;i++) {\\n\\n            vector<long long> current_row(m);\\n            long long cur = 0;\\n            for(int j=0;j<m;j++) {\\n                long long current_point = current_max_sum[j] + points[i][j];\\n                current_row[j] = max(current_point, cur);\\n                cur = max(cur, current_point) - 1;\\n            }\\n            \\n            cur = 0;\\n            for(int j=m-1;j>=0;j--) {\\n                long long current_point = current_max_sum[j] + points[i][j];\\n                current_row[j] = max(current_row[j], max(current_point, cur));\\n                cur = max(cur, current_point) - 1;\\n            }\\n            \\n            current_max_sum = current_row;\\n        }\\n        \\n        long long max_val = 0;\\n        for(int j=0;j<m;j++) max_val = max(max_val, current_max_sum[j]);\\n        \\n        return max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111498,
                "title": "java-o-m-n-1d-dp-solution",
                "content": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long ret = Long.MIN_VALUE;\\n        int n = points.length;\\n        int m = points[0].length;\\n        long[] max = new long[m];\\n        for (int i = 0; i < n; ++i) {\\n            // Add points to maxes from last iteration\\n            for (int j = 0; j < m; ++j)\\n                max[j] += points[i][j];\\n            \\n            // Compare every max to the column to the left minus the penalty\\n            for (int j = 1; j < m; ++j)\\n                max[j] = Math.max(max[j], max[j-1] - 1);\\n            \\n            // Compare every max to the column to the right minus the penalty\\n            for (int j = m - 2; j >= 0; --j)\\n                max[j] = Math.max(max[j], max[j+1] - 1);\\n        }\\n        \\n        // Find the max value in our array and return it\\n        for (int i = 0; i < m; ++i)\\n            ret = Math.max(ret, max[i]);\\n        \\n        return ret;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long maxPoints(int[][] points) {\\n        long ret = Long.MIN_VALUE;\\n        int n = points.length;\\n        int m = points[0].length;\\n        long[] max = new long[m];\\n        for (int i = 0; i < n; ++i) {\\n            // Add points to maxes from last iteration\\n            for (int j = 0; j < m; ++j)\\n                max[j] += points[i][j];\\n            \\n            // Compare every max to the column to the left minus the penalty\\n            for (int j = 1; j < m; ++j)\\n                max[j] = Math.max(max[j], max[j-1] - 1);\\n            \\n            // Compare every max to the column to the right minus the penalty\\n            for (int j = m - 2; j >= 0; --j)\\n                max[j] = Math.max(max[j], max[j+1] - 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2057111,
                "title": "from-naive-dp-approach-to-optimised-dp",
                "content": "**Naive DP approach:**\\n\\nTime Complexity - O(n * m * m)\\nWill give TLE\\n\\n```\\nclass Solution {\\npublic:\\n    long long helper(vector<vector<int>>& points, int n , int m , int currRow , int currCol ,     vector<vector<int>>& dp)\\n    {\\n        if(currRow==n-1)\\n        {\\n            return points[currRow][currCol];\\n        }\\n        \\n        if(dp[currRow][currCol]!=-1)\\n        {\\n            return dp[currRow][currCol];\\n        }\\n        \\n        long long int maxi = 0 ;\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            long long int ans = helper(points , n , m , currRow+1 , i , dp);\\n            long long int res =  ans + points[currRow][currCol] - abs(currCol-i);\\n            if(maxi < res)\\n            {\\n                maxi = res;\\n            }\\n        }\\n        return dp[currRow][currCol]=maxi;\\n        \\n    }\\n    \\n    long long maxPoints(vector<vector<int>>& points) {\\n         int n = points.size();\\n         int m = points[0].size();\\n        \\n         vector<vector<int>> dp;\\n         dp.resize( n , vector<int>(m , -1));\\n        \\n         long long maxi=0;\\n         for(int i = 0; i  < m ;  i++)\\n         {\\n             long long int ans = helper(points , n , m , 0 , i , dp);\\n             if(ans >  maxi)\\n             {\\n                maxi = ans;\\n             }\\n         }\\n          \\n        return maxi;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\nBefore moving to below approach I will recommend to solve [https://leetcode.com/problems/best-sightseeing-pair/](https://leetcode.com/problems/best-sightseeing-pair/)\\n\\n**Optimised DP approach:**\\n\\nTime Complexity - O(n * m)\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        long long int n = points.size();\\n        long long int m = points[0].size();\\n        \\n        \\n        \\n        vector<vector<long long int>> dp;\\n        dp.resize(n , vector<long long int>(m , -1));\\n        \\n        \\n        for(int  i = 0 ; i < m ; i++)\\n        {\\n            dp[0][i]=points[0][i];\\n        }\\n        \\n        \\n        \\n        for(int i = 1 ; i < n ; i++)\\n        {  \\n            \\n            vector<long long int> leftMax(m);\\n            vector<long long int> rightMax(m);\\n            \\n            long long int maxi = 0;\\n            for(int j = 0 ; j < m ; j++)//calculating left maxi\\n            {\\n                maxi=max(maxi-1 , dp[i-1][j]);\\n                leftMax[j] = maxi;\\n            }\\n            \\n            maxi = 0;\\n            for(int j = m-1 ; j >= 0 ; j--)//calculating right maxi\\n            {\\n                 maxi=max(maxi-1 , dp[i-1][j]);\\n                 rightMax[j] = maxi;\\n            }\\n            \\n            \\n            \\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                \\n            dp[i][j]=max(leftMax[j] , rightMax[j])+points[i][j];  \\n                \\n            }\\n            \\n        }\\n    \\n        \\n        \\n        long long int ans =0;\\n        for(int i = 0 ; i <  m ; i++)\\n        {\\n            ans=max(dp[n-1][i] , ans);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(vector<vector<int>>& points, int n , int m , int currRow , int currCol ,     vector<vector<int>>& dp)\\n    {\\n        if(currRow==n-1)\\n        {\\n            return points[currRow][currCol];\\n        }\\n        \\n        if(dp[currRow][currCol]!=-1)\\n        {\\n            return dp[currRow][currCol];\\n        }\\n        \\n        long long int maxi = 0 ;\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            long long int ans = helper(points , n , m , currRow+1 , i , dp);\\n            long long int res =  ans + points[currRow][currCol] - abs(currCol-i);\\n            if(maxi < res)\\n            {\\n                maxi = res;\\n            }\\n        }\\n        return dp[currRow][currCol]=maxi;\\n        \\n    }\\n    \\n    long long maxPoints(vector<vector<int>>& points) {\\n         int n = points.size();\\n         int m = points[0].size();\\n        \\n         vector<vector<int>> dp;\\n         dp.resize( n , vector<int>(m , -1));\\n        \\n         long long maxi=0;\\n         for(int i = 0; i  < m ;  i++)\\n         {\\n             long long int ans = helper(points , n , m , 0 , i , dp);\\n             if(ans >  maxi)\\n             {\\n                maxi = ans;\\n             }\\n         }\\n          \\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        long long int n = points.size();\\n        long long int m = points[0].size();\\n        \\n        \\n        \\n        vector<vector<long long int>> dp;\\n        dp.resize(n , vector<long long int>(m , -1));\\n        \\n        \\n        for(int  i = 0 ; i < m ; i++)\\n        {\\n            dp[0][i]=points[0][i];\\n        }\\n        \\n        \\n        \\n        for(int i = 1 ; i < n ; i++)\\n        {  \\n            \\n            vector<long long int> leftMax(m);\\n            vector<long long int> rightMax(m);\\n            \\n            long long int maxi = 0;\\n            for(int j = 0 ; j < m ; j++)//calculating left maxi\\n            {\\n                maxi=max(maxi-1 , dp[i-1][j]);\\n                leftMax[j] = maxi;\\n            }\\n            \\n            maxi = 0;\\n            for(int j = m-1 ; j >= 0 ; j--)//calculating right maxi\\n            {\\n                 maxi=max(maxi-1 , dp[i-1][j]);\\n                 rightMax[j] = maxi;\\n            }\\n            \\n            \\n            \\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                \\n            dp[i][j]=max(leftMax[j] , rightMax[j])+points[i][j];  \\n                \\n            }\\n            \\n        }\\n    \\n        \\n        \\n        long long int ans =0;\\n        for(int i = 0 ; i <  m ; i++)\\n        {\\n            ans=max(dp[n-1][i] , ans);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016409,
                "title": "python-dp-solution-with-explanation-and-examples",
                "content": "```\\n\\n\\'\\'\\'\\nThe solution to the problem boils down to iteratively adding the maximum gain from previous row to current row.\\n\\nThe first row has no gain so it remains unchanged. \\nFor each element in the 2nd row we can iterate through the previous row and calculate the max points that can be gained for the element. \\nWe then update the elemnt\\'s value to max and repeat the process. The complexity is O(m.n^2)\\n\\nThe above can be optimized to yield an O(m.n) solution. \\nInstead of iterating through an entire row for each element we can use DP to calculate a max gain array from the previous row.\\nWe can add the gain to current row in O(m) time.\\nPlease note that gains can be different when going left->right vs right->left. So we\\'ll need to calculate 2 gains and take the maximum. \\nCalculating the gain array is similar to the problem 104. Best sightseeing pair \\n\\nLet\\'s consider the example below\\n\\n[[14, 1, 1, 1, 1, 1, 15],\\n[1, 1, 5, 1, 1, 1, 1]]\\n\\nWhat would be the maximum gain array from the first row if we are traversing right to left? \\nThe answer is [14, 10, 11, 12, 13, 14, 15] (Manually verifiable)\\nSimilarly if we iterate from right to left then the maximum gain array is [14, 13, 12, 11, 10, 9, 15]\\n\\nWhy are we iterating twice? As you can see in this example many elements have a different gain based on the direction of iteration. \\nThis is because need to iterate from both the ends to make sure that we are checking all possible gains and take the maximum. \\nThe gain arrays can be created in O(m) time (check code) and adding the gain to all elements of the row in another O(m) operation. \\nTotal time per row is 3*O(m) = O(m). For the entire grid it\\'s O(m.n)\\n\\nPS: I found this problem hard. Understanding the intuition behind problem 104 is very helpful. \\nBut even after that it took me an couple hours to find the O(m.n) solution.\\n\\n\\'\\'\\'\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def right_gain_array(arr):\\n            out = []\\n            _max = arr[-1]\\n            for i in range(len(arr)-1, -1, -1):\\n                _max = max(arr[i], _max)\\n                out.append(_max)\\n                _max -= 1\\n            out.reverse()\\n            return out\\n        \\n        def left_gain_array(arr):\\n            out = []\\n            _max = arr[0]\\n            for i in range(len(arr)):\\n                _max = max(arr[i], _max)\\n                out.append(_max)\\n                _max -= 1\\n            return out\\n        \\n        for i in range(1, len(points)):\\n            right_gain_arr, left_gain_arr = right_gain_array(points[i-1]), left_gain_array(points[i-1])\\n            for j in range(len(points[i])):\\n                points[i][j] += max(right_gain_arr[j], left_gain_arr[j])\\n        return max(points[-1])\\n                \\n    \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\'\\'\\'\\nThe solution to the problem boils down to iteratively adding the maximum gain from previous row to current row.\\n\\nThe first row has no gain so it remains unchanged. \\nFor each element in the 2nd row we can iterate through the previous row and calculate the max points that can be gained for the element. \\nWe then update the elemnt\\'s value to max and repeat the process. The complexity is O(m.n^2)\\n\\nThe above can be optimized to yield an O(m.n) solution. \\nInstead of iterating through an entire row for each element we can use DP to calculate a max gain array from the previous row.\\nWe can add the gain to current row in O(m) time.\\nPlease note that gains can be different when going left->right vs right->left. So we\\'ll need to calculate 2 gains and take the maximum. \\nCalculating the gain array is similar to the problem 104. Best sightseeing pair \\n\\nLet\\'s consider the example below\\n\\n[[14, 1, 1, 1, 1, 1, 15],\\n[1, 1, 5, 1, 1, 1, 1]]\\n\\nWhat would be the maximum gain array from the first row if we are traversing right to left? \\nThe answer is [14, 10, 11, 12, 13, 14, 15] (Manually verifiable)\\nSimilarly if we iterate from right to left then the maximum gain array is [14, 13, 12, 11, 10, 9, 15]\\n\\nWhy are we iterating twice? As you can see in this example many elements have a different gain based on the direction of iteration. \\nThis is because need to iterate from both the ends to make sure that we are checking all possible gains and take the maximum. \\nThe gain arrays can be created in O(m) time (check code) and adding the gain to all elements of the row in another O(m) operation. \\nTotal time per row is 3*O(m) = O(m). For the entire grid it\\'s O(m.n)\\n\\nPS: I found this problem hard. Understanding the intuition behind problem 104 is very helpful. \\nBut even after that it took me an couple hours to find the O(m.n) solution.\\n\\n\\'\\'\\'\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def right_gain_array(arr):\\n            out = []\\n            _max = arr[-1]\\n            for i in range(len(arr)-1, -1, -1):\\n                _max = max(arr[i], _max)\\n                out.append(_max)\\n                _max -= 1\\n            out.reverse()\\n            return out\\n        \\n        def left_gain_array(arr):\\n            out = []\\n            _max = arr[0]\\n            for i in range(len(arr)):\\n                _max = max(arr[i], _max)\\n                out.append(_max)\\n                _max -= 1\\n            return out\\n        \\n        for i in range(1, len(points)):\\n            right_gain_arr, left_gain_arr = right_gain_array(points[i-1]), left_gain_array(points[i-1])\\n            for j in range(len(points[i])):\\n                points[i][j] += max(right_gain_arr[j], left_gain_arr[j])\\n        return max(points[-1])\\n                \\n    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956652,
                "title": "c-o-mn-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/maximum-number-of-points-with-cost/\\n    \\n    We process row by row:\\n        for each position \\'j\\' in curr row, we need to know the max effective value from prev\\n        row for this pos \\'j\\'.\\n        We track the max from left to right and update the max value seen for each col position,\\n        to account for |ci - cj|, we can just subtract 1 from max value seen so far when we iterate \\n        forward each time.\\n        Repeat the process for right to left, for each pos pick the highest value.\\n        Finally add the repsective points value for each col position of curr row.\\n*/\\n\\nclass Solution {\\npublic:\\n    // TC: O(MN)\\n    long long maxPoints(vector<vector<int>>& points) {\\n        if(points.empty())\\n            return 0;\\n        \\n        const int M = points.size(), N = points[0].size();\\n        // prev[j] = max point path till col j of previous row\\n        vector<long long> prev (N, 0);\\n        // curr[j] = max point path till col j of curr row\\n        vector<long long> curr(N, 0);\\n        \\n        for(int i = 0; i < M; i++) {\\n            // for the current row, find out the max value (accounting for |ci - cj| as well)\\n            // for each of the positions\\n            long long max_so_far = prev[0]; \\n            // left to right scan\\n            for(int j = 0; j < N; j++) {\\n                // when the max is chosen for current, its value is again decreased by 1\\n                max_so_far = max(max_so_far-1, prev[j]);\\n                curr[j] = max_so_far;\\n            }\\n            // right to left scan\\n            max_so_far = prev[N-1];\\n            for(int j = N-1; j >= 0; j--) {\\n                max_so_far = max(max_so_far-1, curr[j]);\\n                curr[j] = max(curr[j], max_so_far);\\n            }\\n            \\n            // Now that we know about the max effective element for each position,\\n            // update the path value for current row\\n            for(int j = 0; j < N; j++)\\n                curr[j] += points[i][j];\\n            \\n            swap(prev, curr);\\n        }\\n                    \\n        return *max_element(prev.begin(), prev.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/maximum-number-of-points-with-cost/\\n    \\n    We process row by row:\\n        for each position \\'j\\' in curr row, we need to know the max effective value from prev\\n        row for this pos \\'j\\'.\\n        We track the max from left to right and update the max value seen for each col position,\\n        to account for |ci - cj|, we can just subtract 1 from max value seen so far when we iterate \\n        forward each time.\\n        Repeat the process for right to left, for each pos pick the highest value.\\n        Finally add the repsective points value for each col position of curr row.\\n*/\\n\\nclass Solution {\\npublic:\\n    // TC: O(MN)\\n    long long maxPoints(vector<vector<int>>& points) {\\n        if(points.empty())\\n            return 0;\\n        \\n        const int M = points.size(), N = points[0].size();\\n        // prev[j] = max point path till col j of previous row\\n        vector<long long> prev (N, 0);\\n        // curr[j] = max point path till col j of curr row\\n        vector<long long> curr(N, 0);\\n        \\n        for(int i = 0; i < M; i++) {\\n            // for the current row, find out the max value (accounting for |ci - cj| as well)\\n            // for each of the positions\\n            long long max_so_far = prev[0]; \\n            // left to right scan\\n            for(int j = 0; j < N; j++) {\\n                // when the max is chosen for current, its value is again decreased by 1\\n                max_so_far = max(max_so_far-1, prev[j]);\\n                curr[j] = max_so_far;\\n            }\\n            // right to left scan\\n            max_so_far = prev[N-1];\\n            for(int j = N-1; j >= 0; j--) {\\n                max_so_far = max(max_so_far-1, curr[j]);\\n                curr[j] = max(curr[j], max_so_far);\\n            }\\n            \\n            // Now that we know about the max effective element for each position,\\n            // update the path value for current row\\n            for(int j = 0; j < N; j++)\\n                curr[j] += points[i][j];\\n            \\n            swap(prev, curr);\\n        }\\n                    \\n        return *max_element(prev.begin(), prev.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871116,
                "title": "javascript-intuitive-solution-from-o-mnn-to-o-mn",
                "content": "According to the question, we can define our dp like this:\\n```\\ndp[i][j] => the maximum number of points we can achieve at i-th row, j-th col\\n```\\nWe iterate each cell and get the dp function as below:\\n```\\nfor(let i = 0; i < m; i++)\\n    for(let j = 0; j < n; j++)\\n        for(let k = 0; i < n; k++)\\n            dp[i][j] = Max(dp[i-1][k] + points[i][j] - abs(k-j));\\n```\\n\\nNow, the time complexity is O(m*n*n) which is TLE. Let\\'s focus on this part => abs(k-j) to see how can we make it more efficient. As we know, we can discuss the absolute value into two scenarios:\\n```\\n1. if k >= j, then abs(k - j) = k - j\\n\\t\\tWe have dp[i-1][k] + points[i][j] - k + j, k = j, j+1, j+2, ..., n-1;\\n\\t\\tOur dp function becomes:\\n\\t\\t=> dp[i][j] = Max(dp[i-1][k] + points[i][j] - abs(k-j));\\n\\t\\t=> dp[i][j] = Max(dp[i-1][k] + points[i][j] - k + j);\\n\\t\\t// since points[i][j] and j are constants to i and j loop, we can move it out\\n\\t\\t=> dp[i][j] = Max(dp[i-1][k] - k) + points[i][j] + j;\\n\\n2. if k <= j, then abs(k - j) = -(k - j) = j - k\\n\\t\\t We have dp[i-1][k] + points[i][j] + k - j, k = 0, 1, ..., j;\\n\\t\\t => dp[i][j] = Max(dp[i-1][k] + k) + points[i][j] - j;\\n\\nThis is rolling max\\n```\\nNow, we can code: You can also improve the 2D dp array into 1D.\\n```\\n// Caution, initial the rollingMax to Number.MIN_VALUE will fail \\nMath.max(Number.MIN_VALUE, -7)   // return 5e-324\\n```\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar maxPoints = function (points) {\\n\\tlet m = points.length;\\n\\tlet n = points[0].length;\\n\\tlet dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\\n\\tdp[0] = points[0];\\n\\n\\tfor (let i = 1; i < m; i++) {\\n\\t\\t//if k <= j, abs(k-j) = -k+j\\n\\t\\tlet rollingMax = Number.NEGATIVE_INFINITY;\\n\\t\\tfor (let j = 0; j < n; j++) {\\n\\t\\t\\trollingMax = Math.max(rollingMax, dp[i - 1][j] + j);\\n\\t\\t\\tdp[i][j] = Math.max(dp[i][j], rollingMax + points[i][j] - j);\\n\\t\\t}\\n\\n\\t\\t//if k >= j, abs(k-j) = k-j\\n\\t\\trollingMax = Number.NEGATIVE_INFINITY;\\n\\t\\tfor (let j = n - 1; j >= 0; j--) {\\n\\t\\t\\trollingMax = Math.max(rollingMax, dp[i - 1][j] - j);\\n\\t\\t\\tdp[i][j] = Math.max(dp[i][j], rollingMax + points[i][j] + j);\\n\\t\\t}\\n\\t}\\n\\treturn Math.max(...dp[m - 1]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][j] => the maximum number of points we can achieve at i-th row, j-th col\\n```\n```\\nfor(let i = 0; i < m; i++)\\n    for(let j = 0; j < n; j++)\\n        for(let k = 0; i < n; k++)\\n            dp[i][j] = Max(dp[i-1][k] + points[i][j] - abs(k-j));\\n```\n```\\n1. if k >= j, then abs(k - j) = k - j\\n\\t\\tWe have dp[i-1][k] + points[i][j] - k + j, k = j, j+1, j+2, ..., n-1;\\n\\t\\tOur dp function becomes:\\n\\t\\t=> dp[i][j] = Max(dp[i-1][k] + points[i][j] - abs(k-j));\\n\\t\\t=> dp[i][j] = Max(dp[i-1][k] + points[i][j] - k + j);\\n\\t\\t// since points[i][j] and j are constants to i and j loop, we can move it out\\n\\t\\t=> dp[i][j] = Max(dp[i-1][k] - k) + points[i][j] + j;\\n\\n2. if k <= j, then abs(k - j) = -(k - j) = j - k\\n\\t\\t We have dp[i-1][k] + points[i][j] + k - j, k = 0, 1, ..., j;\\n\\t\\t => dp[i][j] = Max(dp[i-1][k] + k) + points[i][j] - j;\\n\\nThis is rolling max\\n```\n```\\n// Caution, initial the rollingMax to Number.MIN_VALUE will fail \\nMath.max(Number.MIN_VALUE, -7)   // return 5e-324\\n```\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar maxPoints = function (points) {\\n\\tlet m = points.length;\\n\\tlet n = points[0].length;\\n\\tlet dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\\n\\tdp[0] = points[0];\\n\\n\\tfor (let i = 1; i < m; i++) {\\n\\t\\t//if k <= j, abs(k-j) = -k+j\\n\\t\\tlet rollingMax = Number.NEGATIVE_INFINITY;\\n\\t\\tfor (let j = 0; j < n; j++) {\\n\\t\\t\\trollingMax = Math.max(rollingMax, dp[i - 1][j] + j);\\n\\t\\t\\tdp[i][j] = Math.max(dp[i][j], rollingMax + points[i][j] - j);\\n\\t\\t}\\n\\n\\t\\t//if k >= j, abs(k-j) = k-j\\n\\t\\trollingMax = Number.NEGATIVE_INFINITY;\\n\\t\\tfor (let j = n - 1; j >= 0; j--) {\\n\\t\\t\\trollingMax = Math.max(rollingMax, dp[i - 1][j] - j);\\n\\t\\t\\tdp[i][j] = Math.max(dp[i][j], rollingMax + points[i][j] + j);\\n\\t\\t}\\n\\t}\\n\\treturn Math.max(...dp[m - 1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1721549,
                "title": "java-explained-two-approaches",
                "content": "Simple intuitive approach of top-down dp would give you TLE even if you convert this to bottom-up as the time complexity ids gonna be O(n*m*m) as we are checking m columns for each element.\\n```\\nclass Solution {\\n    private long solve(int row,int col,int n,int m,int[][] points,long[][] dp){\\n        if(row==n)\\n            return 0;\\n        if(dp[row][col]!=Long.MIN_VALUE)\\n            return dp[row][col];\\n        long ans=Long.MIN_VALUE;\\n        for(int i=0;i<m;i++)\\n           ans=Math.max(ans,points[row][col]-Math.abs(col-i)+solve(row+1,i,n,m,points,dp));\\n        return dp[row][col]=ans;\\n    }\\n    public long maxPoints(int[][] points) {\\n        int n=points.length,m=points[0].length;\\n        long[][] dp=new long[n+1][m+1];\\n        for(long[] arr:dp)\\n            Arrays.fill(arr,Long.MIN_VALUE);\\n        long ans=Long.MIN_VALUE;\\n        for(int i=0;i<m;i++)\\n            ans=Math.max(ans,solve(0,i,n,m,points,dp));\\n        return ans;\\n    }\\n}\\n```\\nNow the real explaination:\\nwe have to limit the no. of comparisions for each element. so first we will copy the elements of the first row in a array(i.e. prev[] here) .Now starting from the first row, we will first traverse from the left to find the left max and then traverse from the right to get the right max and store the max(left,right) in the prev array.\\nleft traversal:\\n\\tkeep a variable left=0 now for the element at j th index compare the left-1( minus 1 because we are taking an element from the prev column) and points[i][j]. max(left-1,prev[j])+points[i][j] will be stored in the temp array.\\nright traversal:\\n\\tdo the same for the right taversal and update the prev array with the maximum element got from each traversal.\\nAt last give the maximum of the prev array.\\nDo dry run the code for better understanding.\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int n=points.length,m=points[0].length;\\n        long ans=Long.MIN_VALUE;\\n        long[] prev=new long[m];\\n        for(int i=0;i<m;i++)\\n            prev[i]=points[0][i];\\n        for(int i=1;i<n;i++){\\n            long[] dp=new long[m];\\n            long left=0;\\n            for(int j=0;j<m;j++){\\n                long temp=Math.max(prev[j],left-1);\\n                dp[j]=temp+points[i][j];\\n                left=temp;\\n            }\\n            long right=0;\\n            for(int j=m-1;j>=0;j--){\\n                long temp=Math.max(prev[j],right-1);\\n                dp[j]=Math.max(dp[j],temp+points[i][j]);\\n                right=temp;\\n                prev[j]=dp[j];\\n            }\\n            \\n        }\\n        ans=Arrays.stream(prev).max().getAsLong();\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private long solve(int row,int col,int n,int m,int[][] points,long[][] dp){\\n        if(row==n)\\n            return 0;\\n        if(dp[row][col]!=Long.MIN_VALUE)\\n            return dp[row][col];\\n        long ans=Long.MIN_VALUE;\\n        for(int i=0;i<m;i++)\\n           ans=Math.max(ans,points[row][col]-Math.abs(col-i)+solve(row+1,i,n,m,points,dp));\\n        return dp[row][col]=ans;\\n    }\\n    public long maxPoints(int[][] points) {\\n        int n=points.length,m=points[0].length;\\n        long[][] dp=new long[n+1][m+1];\\n        for(long[] arr:dp)\\n            Arrays.fill(arr,Long.MIN_VALUE);\\n        long ans=Long.MIN_VALUE;\\n        for(int i=0;i<m;i++)\\n            ans=Math.max(ans,solve(0,i,n,m,points,dp));\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int n=points.length,m=points[0].length;\\n        long ans=Long.MIN_VALUE;\\n        long[] prev=new long[m];\\n        for(int i=0;i<m;i++)\\n            prev[i]=points[0][i];\\n        for(int i=1;i<n;i++){\\n            long[] dp=new long[m];\\n            long left=0;\\n            for(int j=0;j<m;j++){\\n                long temp=Math.max(prev[j],left-1);\\n                dp[j]=temp+points[i][j];\\n                left=temp;\\n            }\\n            long right=0;\\n            for(int j=m-1;j>=0;j--){\\n                long temp=Math.max(prev[j],right-1);\\n                dp[j]=Math.max(dp[j],temp+points[i][j]);\\n                right=temp;\\n                prev[j]=dp[j];\\n            }\\n            \\n        }\\n        ans=Arrays.stream(prev).max().getAsLong();\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718591,
                "title": "c-dp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) \\n    {\\n           long long r = points.size();\\n           long long c = points[0].size();\\n        vector<vector< long long>>dp(r,vector< long long>(c,0));\\n        for(int i=0;i<c;i++)\\n            dp[0][i]  = points[0][i];\\n        \\n         for(int i=1;i<r;i++)\\n         {\\n              long long ma = INT_MIN;\\n                for(int j=0;j<c;j++)\\n                {\\n                    ma= max(ma, dp[i-1][j]+j);\\n                    dp[i][j] = points[i][j]+ma-j;\\n                }\\n             ma = INT_MIN;\\n             for(int j=c-1;j>=0;j--)\\n             {\\n                 ma= max(ma, dp[i-1][j] - j);\\n                 dp[i][j] = max(dp[i][j] ,points[i][j]+ma+j);\\n             }   \\n         }\\n         long long ans = dp[r-1][0];\\n        for(int i=1;i<c;i++)\\n        {\\n            ans = max(ans, dp[r-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) \\n    {\\n           long long r = points.size();\\n           long long c = points[0].size();\\n        vector<vector< long long>>dp(r,vector< long long>(c,0));\\n        for(int i=0;i<c;i++)\\n            dp[0][i]  = points[0][i];\\n        \\n         for(int i=1;i<r;i++)\\n         {\\n              long long ma = INT_MIN;\\n                for(int j=0;j<c;j++)\\n                {\\n                    ma= max(ma, dp[i-1][j]+j);\\n                    dp[i][j] = points[i][j]+ma-j;\\n                }\\n             ma = INT_MIN;\\n             for(int j=c-1;j>=0;j--)\\n             {\\n                 ma= max(ma, dp[i-1][j] - j);\\n                 dp[i][j] = max(dp[i][j] ,points[i][j]+ma+j);\\n             }   \\n         }\\n         long long ans = dp[r-1][0];\\n        for(int i=1;i<c;i++)\\n        {\\n            ans = max(ans, dp[r-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692275,
                "title": "why-top-down-o-n-m-with-memo-giving-tle",
                "content": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long[][] memo = new long[points.length][points[0].length];\\n        for(long[] m : memo)\\n            Arrays.fill(m,-1);\\n        return dfs(points, 0, 0, memo);\\n        \\n        \\n    }\\n    \\n    public long dfs(int[][] points, int row, int col, long[][] memo){\\n        long max=0;\\n        if(row==points.length)\\n            return 0;\\n        if(memo[row][col]!=-1)\\n            return memo[row][col];\\n        \\n        for(int i=0;i<points[0].length;i++){\\n            if(row==0)\\n                max = Math.max(max, points[row][i] + dfs(points, row+1, i, memo) );\\n            else\\n                max = Math.max(max, points[row][i] -Math.abs(i-col) + dfs(points, row+1, i, memo) );\\n            \\n        }\\n        memo[row][col] = max;\\n        return memo[row][col];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long[][] memo = new long[points.length][points[0].length];\\n        for(long[] m : memo)\\n            Arrays.fill(m,-1);\\n        return dfs(points, 0, 0, memo);\\n        \\n        \\n    }\\n    \\n    public long dfs(int[][] points, int row, int col, long[][] memo){\\n        long max=0;\\n        if(row==points.length)\\n            return 0;\\n        if(memo[row][col]!=-1)\\n            return memo[row][col];\\n        \\n        for(int i=0;i<points[0].length;i++){\\n            if(row==0)\\n                max = Math.max(max, points[row][i] + dfs(points, row+1, i, memo) );\\n            else\\n                max = Math.max(max, points[row][i] -Math.abs(i-col) + dfs(points, row+1, i, memo) );\\n            \\n        }\\n        memo[row][col] = max;\\n        return memo[row][col];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573449,
                "title": "c-dp-o-mn-solution",
                "content": "One way to find the maximum in row m is to go throught every col in m-1 row which will result it m*n^2 in run time.\\nWe can however reduce the runtime by finding the max value from left and right with Math.Max(max -1, cur).\\n\\nRuntime: O(mn)\\nSpace: O(m)\\n```\\npublic class Solution {\\n    public long MaxPoints(int[][] points) {\\n        var prv = new long[points[0].Length];\\n        foreach(var p in points)\\n        {\\n            FindLocalMax(prv, p);\\n        }\\n        \\n        return prv.Max();\\n    }\\n    \\n    private void FindLocalMax(long[] prv, int[] cur)\\n    {\\n        var fromLeft = new long[cur.Length];\\n        var fromRight = new long[cur.Length];\\n        \\n        var len = cur.Length -1;\\n        for(var i = 0; i <= len; i++)\\n        {\\n            fromLeft[i] = i == 0 ? prv[0] : Math.Max(fromLeft[i-1]-1, prv[i]);\\n            fromRight[len - i] = len - i == len ? prv[len] : Math.Max(fromRight[len - i +1] - 1, prv[len - i]);\\n        }\\n        \\n        for(var i = 0; i < cur.Length; i++)\\n        {\\n            prv[i] = Math.Max(fromLeft[i], fromRight[i]) + cur[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long MaxPoints(int[][] points) {\\n        var prv = new long[points[0].Length];\\n        foreach(var p in points)\\n        {\\n            FindLocalMax(prv, p);\\n        }\\n        \\n        return prv.Max();\\n    }\\n    \\n    private void FindLocalMax(long[] prv, int[] cur)\\n    {\\n        var fromLeft = new long[cur.Length];\\n        var fromRight = new long[cur.Length];\\n        \\n        var len = cur.Length -1;\\n        for(var i = 0; i <= len; i++)\\n        {\\n            fromLeft[i] = i == 0 ? prv[0] : Math.Max(fromLeft[i-1]-1, prv[i]);\\n            fromRight[len - i] = len - i == len ? prv[len] : Math.Max(fromRight[len - i +1] - 1, prv[len - i]);\\n        }\\n        \\n        for(var i = 0; i < cur.Length; i++)\\n        {\\n            prv[i] = Math.Max(fromLeft[i], fromRight[i]) + cur[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565397,
                "title": "c-short-dp-solution",
                "content": "/*\\n    for(int i=0; i<m; i++)\\n        for(int j=0; j<n; j++)\\n            for(int k=0; k<n; k++)\\n                dp[i][j]=max{dp[i-1][k] + points[i][j] - abs(j-k)}\\n    \\n    \\n    dp[i][j]=max{dp[i-1][k]} + points[i][j] - (j-k)        whenj>=k         k=0,1,2,3,4,...j\\n    ->dp[i][j]=max{dp[i-1][k]} + k + points[i][j] - j\\n    ->rollingmax=max{dp[i-1][k]} + k //the changing part in the equation above\\n    \\n    dp[i][j]=max{dp[i-1][k]} + points[i][j] - (j-k)        whenj>=k         k=j+1, j+2...., n-1\\n    ->dp[i][j]=max{dp[i-1][k]} - k + points[i][j] + j   \\n    ->dp[i][j]=max{dp[i-1][k]} - k //the changing part in the equation above\\n    \\n    then finish the dp part\\n    we finally find the max in the last row of our dp, which gives the answer\\n*/\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int m=points.size();\\n        int n=points[0].size();\\n        long long ans=0;\\n        vector<vector<long long>> dp(m, vector<long long>(n, INT_MIN));\\n        \\n        //assign values for the first row of our dp\\n        for(int j=0; j<n; j++){\\n            dp[0][j] = points[0][j];\\n        }\\n        \\n        for(int i=1; i<m; i++){\\n            long long rollingMax=INT_MIN;\\n            for(int j=0; j<n; j++){//loop through beginning to our k\\n                rollingMax=max(rollingMax, dp[i-1][j]+j);\\n                dp[i][j]=max(dp[i][j], rollingMax+points[i][j]-j);\\n            }\\n            \\n            rollingMax=INT_MIN;\\n            for(int j=n-1; j>=0; j--){//loop through ending to our k\\n                rollingMax=max(rollingMax, dp[i-1][j]-j);\\n                dp[i][j]=max(dp[i][j], rollingMax+points[i][j]+j);\\n            }\\n        }\\n        \\n        //now we are gonna find the max in the last row to get the answer\\n        for(int j=0; j<n; j++){\\n            ans=max(ans, dp[m-1][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int m=points.size();\\n        int n=points[0].size();\\n        long long ans=0;\\n        vector<vector<long long>> dp(m, vector<long long>(n, INT_MIN));\\n        \\n        //assign values for the first row of our dp\\n        for(int j=0; j<n; j++){\\n            dp[0][j] = points[0][j];\\n        }\\n        \\n        for(int i=1; i<m; i++){\\n            long long rollingMax=INT_MIN;\\n            for(int j=0; j<n; j++){//loop through beginning to our k\\n                rollingMax=max(rollingMax, dp[i-1][j]+j);\\n                dp[i][j]=max(dp[i][j], rollingMax+points[i][j]-j);\\n            }\\n            \\n            rollingMax=INT_MIN;\\n            for(int j=n-1; j>=0; j--){//loop through ending to our k\\n                rollingMax=max(rollingMax, dp[i-1][j]-j);\\n                dp[i][j]=max(dp[i][j], rollingMax+points[i][j]+j);\\n            }\\n        }\\n        \\n        //now we are gonna find the max in the last row to get the answer\\n        for(int j=0; j<n; j++){\\n            ans=max(ans, dp[m-1][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542901,
                "title": "intuitive-python-dp-solution",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n\\n        if not points:\\n            return 0\\n        res = max(points[0])\\n        \\n        for r in range(1, len(points)):\\n            dp = points[r-1]\\n            for d in range(1, len(points[0])):\\n                dp[d] = max(dp[d], dp[d-1]-1)\\n                \\n            \\n            for e in range(len(points[0])-2, -1, -1):\\n                dp[e] = max(dp[e], dp[e+1]-1)\\n    \\n            \\n            for c in range(len(points[0])):\\n                points[r][c] += dp[c]\\n                \\n                res = max(res,  points[r][c])\\n                \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n\\n        if not points:\\n            return 0\\n        res = max(points[0])\\n        \\n        for r in range(1, len(points)):\\n            dp = points[r-1]\\n            for d in range(1, len(points[0])):\\n                dp[d] = max(dp[d], dp[d-1]-1)\\n                \\n            \\n            for e in range(len(points[0])-2, -1, -1):\\n                dp[e] = max(dp[e], dp[e+1]-1)\\n    \\n            \\n            for c in range(len(points[0])):\\n                points[r][c] += dp[c]\\n                \\n                res = max(res,  points[r][c])\\n                \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524686,
                "title": "java-simple-solution-with-explanation-using-dp",
                "content": "# Please upvote if you like the soulution \\n\\n```\\nclass Solution {\\n    \\n     /*\\n        Basic Intuition\\n            1.  1st row >> same value as points matrix\\n            2.  2nd row onwards check for previous values\\n\\n                Solution-1 : Time complexity  O(n * m * m) // Timeout error\\n                    dp[i][j] = Max(dp[i - 1][k])  k = column 0 - k\\n                                dp[i][j] = dp[i - 1][k] - Math.abs(k - j)\\n\\n                 Solution-2 : Time complexity  O(n * m)\\n                     case-1 : k < j i.e. the left part\\n                              dp[i][j] = dp[i-1][k] + points[i][j] - (j - k)\\n                                       = (dp[i-1][k] + k) + (points[i][j] - j)\\n\\n                     case-2 : k > j i.e. the right part\\n                              dp[i][j] = dp[i-1][k] + points[i][j] - (k - j)\\n                                       = (dp[i-1][k] - k) + (points[i][j] + j)\\n\\n    */\\n    public long maxPoints(int[][] points) {\\n\\n        int height = points.length;\\n        int width = points[0].length;\\n\\n        long[][] dp = new long[height][width];\\n\\n        // 1st row >> same value as points matrix\\n        for (int j = 0; j < width; j++) {\\n            dp[0][j] = points[0][j];\\n        }\\n\\n        /**\\n         * Solution-1 : Time complexity  O(n * m * m)\\n         */\\n        /* for(int i = 1 ; i < points.length ; i++){\\n             int col = 0;\\n             while(col < points[i].length){\\n                 for(int j = 0 ; j < points[i].length ; j++){\\n                     dp[i][col] = Math.max(dp[i][col], dp[i - 1][j] - Math.abs(col - j) + points[i][col]);\\n                 }\\n                 col++;\\n             }\\n         }*/\\n\\n\\n        /**\\n         * Solution-2 : Time complexity  O(n * m)\\n         */\\n        for (int i = 1; i < height; i++) {\\n\\n\\n            /*\\n             *  case-1 : k < j i.e. the left part\\n             *       dp[i][j] = dp[i-1][k] + points[i][j] - (j - k)\\n             *                = (dp[i-1][k] + k) + (points[i][j] - j)\\n             *\\n             *       To avoid the n * m * m time complexity we can use an extra array to hold the maxValue from its left.\\n             *       i.e. each element will hold the maximum value which can be formed from left.\\n             *       So, for that from the above equation we will avoid the (points[i][j] - j) for now.\\n             */\\n            long[] leftMax = new long[width];\\n            // First element will be the maxValue for its position\\n            leftMax[0] = dp[i - 1][0];\\n\\n            for (int k = 1; k < width; k++) {\\n                /*\\n                 * Formula : dp[i][j] = dp[i-1][k] + points[i][j] - (j - k)\\n                 *                    = (dp[i-1][k] + k) + (points[i][j] - j)\\n                 *\\n                 * Note : we will avoid the (points[i][j] - j) while calculating the leftMax value.\\n                 */\\n                leftMax[k] = Math.max(leftMax[k - 1], (dp[i - 1][k] + k));\\n            }\\n\\n            /*\\n             *  case-2 : k > j i.e. the right part\\n             *       dp[i][j] = dp[i-1][k] + points[i][j] - (k - j)\\n             *                = (dp[i-1][k] - k) + (points[i][j] + j)\\n             *\\n             *       To avoid the n * m * m time complexity we can use an extra array to hold the maxValue from its right side.\\n             *       i.e. each element will hold the maximum value which can be formed from right.\\n             *       So, for that from the above equation we will avoid the (points[i][j] + j) for now.\\n             */\\n            long[] rightMax = new long[width];\\n            rightMax[width - 1] = dp[i - 1][width - 1] - (width - 1);\\n\\n            for (int k = width - 2; k >= 0; k--) {\\n                /*\\n                 * Formula :  dp[i][j] = dp[i-1][k] + points[i][j] - (k - j)\\n                 *                     = (dp[i-1][k] - k) + (points[i][j] + j)\\n                 *\\n                 * Note : we will avoid the (points[i][j] + j) while calculating the rightMax value.\\n                 */\\n                rightMax[k] = Math.max(rightMax[k + 1], (dp[i - 1][k] - k));\\n            }\\n\\n            /*\\n             * Will calculate the point part along with the left and right max array.\\n             * For Left Array :  (points[i][j] - j)\\n             * For Right Array : (points[i][j] + j)\\n             * So it will be\\n             * dp[i][k] = Math.max( (leftMax[k] + points[i][k] - k) , (rightMax[k] + points[i][k] + k) );\\n             *          = Math.max(leftMax[k] - k, rightMax[k] + k) + points[i][k]; // Taking out the common part\\n             */\\n            for (int k = 0; k < width; k++) {\\n                dp[i][k] = Math.max(leftMax[k] - k, rightMax[k] + k) + points[i][k];\\n            }\\n        }\\n\\n        /**\\n         * Look for the max sum value in the last row of dp array\\n         */\\n        long maxSum = 0;\\n        for (int j = 0; j < width; j++) {\\n            maxSum = Math.max(maxSum, dp[height - 1][j]);\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n     /*\\n        Basic Intuition\\n            1.  1st row >> same value as points matrix\\n            2.  2nd row onwards check for previous values\\n\\n                Solution-1 : Time complexity  O(n * m * m) // Timeout error\\n                    dp[i][j] = Max(dp[i - 1][k])  k = column 0 - k\\n                                dp[i][j] = dp[i - 1][k] - Math.abs(k - j)\\n\\n                 Solution-2 : Time complexity  O(n * m)\\n                     case-1 : k < j i.e. the left part\\n                              dp[i][j] = dp[i-1][k] + points[i][j] - (j - k)\\n                                       = (dp[i-1][k] + k) + (points[i][j] - j)\\n\\n                     case-2 : k > j i.e. the right part\\n                              dp[i][j] = dp[i-1][k] + points[i][j] - (k - j)\\n                                       = (dp[i-1][k] - k) + (points[i][j] + j)\\n\\n    */\\n    public long maxPoints(int[][] points) {\\n\\n        int height = points.length;\\n        int width = points[0].length;\\n\\n        long[][] dp = new long[height][width];\\n\\n        // 1st row >> same value as points matrix\\n        for (int j = 0; j < width; j++) {\\n            dp[0][j] = points[0][j];\\n        }\\n\\n        /**\\n         * Solution-1 : Time complexity  O(n * m * m)\\n         */\\n        /* for(int i = 1 ; i < points.length ; i++){\\n             int col = 0;\\n             while(col < points[i].length){\\n                 for(int j = 0 ; j < points[i].length ; j++){\\n                     dp[i][col] = Math.max(dp[i][col], dp[i - 1][j] - Math.abs(col - j) + points[i][col]);\\n                 }\\n                 col++;\\n             }\\n         }*/\\n\\n\\n        /**\\n         * Solution-2 : Time complexity  O(n * m)\\n         */\\n        for (int i = 1; i < height; i++) {\\n\\n\\n            /*\\n             *  case-1 : k < j i.e. the left part\\n             *       dp[i][j] = dp[i-1][k] + points[i][j] - (j - k)\\n             *                = (dp[i-1][k] + k) + (points[i][j] - j)\\n             *\\n             *       To avoid the n * m * m time complexity we can use an extra array to hold the maxValue from its left.\\n             *       i.e. each element will hold the maximum value which can be formed from left.\\n             *       So, for that from the above equation we will avoid the (points[i][j] - j) for now.\\n             */\\n            long[] leftMax = new long[width];\\n            // First element will be the maxValue for its position\\n            leftMax[0] = dp[i - 1][0];\\n\\n            for (int k = 1; k < width; k++) {\\n                /*\\n                 * Formula : dp[i][j] = dp[i-1][k] + points[i][j] - (j - k)\\n                 *                    = (dp[i-1][k] + k) + (points[i][j] - j)\\n                 *\\n                 * Note : we will avoid the (points[i][j] - j) while calculating the leftMax value.\\n                 */\\n                leftMax[k] = Math.max(leftMax[k - 1], (dp[i - 1][k] + k));\\n            }\\n\\n            /*\\n             *  case-2 : k > j i.e. the right part\\n             *       dp[i][j] = dp[i-1][k] + points[i][j] - (k - j)\\n             *                = (dp[i-1][k] - k) + (points[i][j] + j)\\n             *\\n             *       To avoid the n * m * m time complexity we can use an extra array to hold the maxValue from its right side.\\n             *       i.e. each element will hold the maximum value which can be formed from right.\\n             *       So, for that from the above equation we will avoid the (points[i][j] + j) for now.\\n             */\\n            long[] rightMax = new long[width];\\n            rightMax[width - 1] = dp[i - 1][width - 1] - (width - 1);\\n\\n            for (int k = width - 2; k >= 0; k--) {\\n                /*\\n                 * Formula :  dp[i][j] = dp[i-1][k] + points[i][j] - (k - j)\\n                 *                     = (dp[i-1][k] - k) + (points[i][j] + j)\\n                 *\\n                 * Note : we will avoid the (points[i][j] + j) while calculating the rightMax value.\\n                 */\\n                rightMax[k] = Math.max(rightMax[k + 1], (dp[i - 1][k] - k));\\n            }\\n\\n            /*\\n             * Will calculate the point part along with the left and right max array.\\n             * For Left Array :  (points[i][j] - j)\\n             * For Right Array : (points[i][j] + j)\\n             * So it will be\\n             * dp[i][k] = Math.max( (leftMax[k] + points[i][k] - k) , (rightMax[k] + points[i][k] + k) );\\n             *          = Math.max(leftMax[k] - k, rightMax[k] + k) + points[i][k]; // Taking out the common part\\n             */\\n            for (int k = 0; k < width; k++) {\\n                dp[i][k] = Math.max(leftMax[k] - k, rightMax[k] + k) + points[i][k];\\n            }\\n        }\\n\\n        /**\\n         * Look for the max sum value in the last row of dp array\\n         */\\n        long maxSum = 0;\\n        for (int j = 0; j < width; j++) {\\n            maxSum = Math.max(maxSum, dp[height - 1][j]);\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416211,
                "title": "java-dp-one-dimensional-o-mn-96-compact-code-with-explanation",
                "content": "// dp[j] is what is the best sum possible before row \\'i\\', for points[i][j] to be picked\\n// so current sum will be (dp[j] + points[i][j]), which can be compared and stored in max if greater\\n\\n// then for the next row (i+1), update dp[j],  if any of dp[0 to n except j] is greater along with the penalty\\n// dp[j] = Math.max(dp[j], dp[j-1] - 1); when iterating from left\\n// dp[j] = Math.max(dp[j], dp[j+1] - 1); when iterating from right\\n\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m = points.length;\\n        int n = points[0].length;\\n\\n        long[] dp = new long[n];\\n        long max = 0;\\n\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                dp[j] += points[i][j];\\n                max = Math.max(max, dp[j]);\\n            }\\n\\n            for(int j=1; j<n; j++) {\\n                dp[j] = Math.max(dp[j], dp[j-1] - 1);\\n            }\\n\\n            for(int j=n-2; j>=0; j--) {\\n                dp[j] = Math.max(dp[j], dp[j+1] - 1);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m = points.length;\\n        int n = points[0].length;\\n\\n        long[] dp = new long[n];\\n        long max = 0;\\n\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                dp[j] += points[i][j];\\n                max = Math.max(max, dp[j]);\\n            }\\n\\n            for(int j=1; j<n; j++) {\\n                dp[j] = Math.max(dp[j], dp[j-1] - 1);\\n            }\\n\\n            for(int j=n-2; j>=0; j--) {\\n                dp[j] = Math.max(dp[j], dp[j+1] - 1);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350217,
                "title": "easy-java-6ms-100-o-n-m-dp-with-comments",
                "content": "My first straightforward DP  solution O(N * M * M) gave me TLE at case 152/157.\\nTo get rid of inner cycle and replace O(N^3) -> O(N^2) please refer to the second solution\\n\\nThe first solution O(N * M * M)\\n```\\n     public long maxPoints(int[][] points) {\\n        int n = points.length, m = points[0].length;\\n        long[][] dp = new long[n][m];\\n        \\n        for(int j=0;j<m;j++)\\n            dp[0][j] = points[0][j];\\n        \\n        //select for each item in row the best option in previous row, store the result for exact index in row\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                for(int k=0;k<m;k++)\\n                    dp[i][j] = Math.max(dp[i][j], points[i][j] + dp[i-1][k] - Math.abs(j-k));\\n\\n        //find max in the latest row    \\n        long res = 0;\\n        for(int j=0;j<m;j++)\\n            res = Math.max(res, dp[n-1][j]);\\n            \\n        return res;\\n    }\\n```\\nThe second solution O(N * M)\\n```\\n     public long maxPoints(int[][] points) {\\n        int n = points.length, m = points[0].length;\\n        long[] dp = new long[m]; //long is just needed to avoid int overflow in test cases\\n        \\n        for(int j=0;j<m;j++)\\n            dp[j] = points[0][j];\\n        \\n        //find the max possible score for each index selection in row\\n        //for example for sequences:\\n        //1,2,3,4,5 -> 1,2,3,4,5\\n        //1,1,1,1,7 -> 3,4,5,6,7\\n        //7,1,1,1,1 -> 7,6,5,4,3 \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++)\\n                dp[j] = Math.max(dp[j], dp[j-1]-1);\\n            for(int j=m-2;j>=0;j--)\\n                dp[j] = Math.max(dp[j], dp[j+1]-1);\\n            \\n            //combine best choice for each indexed item with the next row corresponding values\\n            for(int j=0;j<m;j++)\\n                dp[j] += points[i][j];\\n            \\n            //repeat with the result until the latest row\\n        }\\n\\n\\t\\t//find max after the latest row addition    \\n        long res = 0;\\n        for(int j=0;j<m;j++)\\n            res = Math.max(res, dp[j]);\\n            \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     public long maxPoints(int[][] points) {\\n        int n = points.length, m = points[0].length;\\n        long[][] dp = new long[n][m];\\n        \\n        for(int j=0;j<m;j++)\\n            dp[0][j] = points[0][j];\\n        \\n        //select for each item in row the best option in previous row, store the result for exact index in row\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                for(int k=0;k<m;k++)\\n                    dp[i][j] = Math.max(dp[i][j], points[i][j] + dp[i-1][k] - Math.abs(j-k));\\n\\n        //find max in the latest row    \\n        long res = 0;\\n        for(int j=0;j<m;j++)\\n            res = Math.max(res, dp[n-1][j]);\\n            \\n        return res;\\n    }\\n```\n```\\n     public long maxPoints(int[][] points) {\\n        int n = points.length, m = points[0].length;\\n        long[] dp = new long[m]; //long is just needed to avoid int overflow in test cases\\n        \\n        for(int j=0;j<m;j++)\\n            dp[j] = points[0][j];\\n        \\n        //find the max possible score for each index selection in row\\n        //for example for sequences:\\n        //1,2,3,4,5 -> 1,2,3,4,5\\n        //1,1,1,1,7 -> 3,4,5,6,7\\n        //7,1,1,1,1 -> 7,6,5,4,3 \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++)\\n                dp[j] = Math.max(dp[j], dp[j-1]-1);\\n            for(int j=m-2;j>=0;j--)\\n                dp[j] = Math.max(dp[j], dp[j+1]-1);\\n            \\n            //combine best choice for each indexed item with the next row corresponding values\\n            for(int j=0;j<m;j++)\\n                dp[j] += points[i][j];\\n            \\n            //repeat with the result until the latest row\\n        }\\n\\n\\t\\t//find max after the latest row addition    \\n        long res = 0;\\n        for(int j=0;j<m;j++)\\n            res = Math.max(res, dp[j]);\\n            \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1346684,
                "title": "c-clean-solution",
                "content": "recomended [1014. Best Sightseeing Pair](htthttps://leetcode.com/problems/best-sightseeing-pair/p://) Solve this first\\n\\n```\\nclass Solution {\\npublic:\\n    long long max(long long a,long long b){\\n        return a > b ? a : b;\\n    }\\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        int m = points.size();\\n        int n = points[0].size();\\n        \\n        vector<vector<long long>> dp(m,vector<long long>(n));\\n        \\n        for(int j = 0; j < n; j++){\\n            dp[0][j] = points[0][j];\\n        }\\n        \\n        for(int i = 1; i < m; i++){\\n            vector<long long> left(n);\\n            vector<long long> right(n);\\n            vector<long long> &prev = dp[i-1];\\n            \\n            left[0] = prev[0];\\n            for(int k = 1;k < n; k++){\\n                left[k] = max(prev[k],left[k-1]-1);\\n            }\\n            \\n            right[n-1] = prev[n-1];\\n            \\n            for(int k = n-2; k >= 0; k--){\\n                right[k] = max(prev[k],right[k+1]-1);\\n            }\\n            \\n            for(int j = 0; j < n; j++){\\n                dp[i][j] = max(left[j],right[j])+points[i][j];\\n            }\\n            \\n            \\n        }\\n        \\n        long long ans = INT_MIN;\\n        for(int j = 0; j < n; j++){\\n            ans = max(ans,dp[m-1][j]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long max(long long a,long long b){\\n        return a > b ? a : b;\\n    }\\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        int m = points.size();\\n        int n = points[0].size();\\n        \\n        vector<vector<long long>> dp(m,vector<long long>(n));\\n        \\n        for(int j = 0; j < n; j++){\\n            dp[0][j] = points[0][j];\\n        }\\n        \\n        for(int i = 1; i < m; i++){\\n            vector<long long> left(n);\\n            vector<long long> right(n);\\n            vector<long long> &prev = dp[i-1];\\n            \\n            left[0] = prev[0];\\n            for(int k = 1;k < n; k++){\\n                left[k] = max(prev[k],left[k-1]-1);\\n            }\\n            \\n            right[n-1] = prev[n-1];\\n            \\n            for(int k = n-2; k >= 0; k--){\\n                right[k] = max(prev[k],right[k+1]-1);\\n            }\\n            \\n            for(int j = 0; j < n; j++){\\n                dp[i][j] = max(left[j],right[j])+points[i][j];\\n            }\\n            \\n            \\n        }\\n        \\n        long long ans = INT_MIN;\\n        for(int j = 0; j < n; j++){\\n            ans = max(ans,dp[m-1][j]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345041,
                "title": "dp-sliding-window-o-m-n",
                "content": "1. Maintain decreasing deque for (i + 1)th row\\n2. optimize dp[i][j], left to right sliding window\\n3. optimize dp[i][j], right to left sliding window\\n\\n\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m = points.length;\\n        int n = points[0].length;\\n        \\n        long[][] dp = new long[m][n];\\n        for (int j = 0; j < n; j++){\\n            dp[m - 1][j] = points[m - 1][j];\\n        }\\n        for (int i = m - 2; i >= 0; i--){         \\n            ArrayDeque<Integer> deque = new ArrayDeque<>();            \\n            for (int j = 0; j < n; j++){\\n                while(!deque.isEmpty() && dp[i + 1][deque.peekLast()] - (j - deque.peekLast()) <= dp[i + 1][j]){\\n                    deque.removeLast();\\n                }        \\n                deque.addLast(j);\\n                dp[i][j] = Math.max(dp[i][j], dp[i + 1][deque.peekFirst()] + points[i][j] - (j - deque.peekFirst()));\\n            }          \\n            deque.clear();            \\n            for (int j = n - 1; j >= 0; j--){\\n                while(!deque.isEmpty() && dp[i + 1][deque.peekLast()] - (deque.peekLast() - j) <= dp[i + 1][j]){\\n                    deque.removeLast();\\n                }        \\n                deque.addLast(j);\\n                dp[i][j] = Math.max(dp[i][j], dp[i + 1][deque.peekFirst()] + points[i][j] - (deque.peekFirst() - j));\\n            }\\n        } \\n        long max = 0;\\n        for (int j = 0; j < n; j++){\\n            max = Math.max(max, dp[0][j]);\\n        }        \\n        return max;\\n        \\n    }\\n}\\n```\\n\\nwithout sliding window(optimized)\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m = points.length;\\n        int n = points[0].length;\\n        long[][] dp = new long[m][n];\\n        for (int j = 0; j < n; j++){\\n            dp[m - 1][j] = points[m - 1][j];\\n        }\\n        \\n        for (int i = m - 2; i >= 0; i--){\\n            int pre = 0;\\n            for (int j = 0; j < n; j++){\\n                if(dp[i + 1][pre] - (j - pre) <= dp[i + 1][j])\\n                    pre = j;\\n                dp[i][j] = Math.max(dp[i][j], dp[i + 1][pre] - (j - pre) + points[i][j]);\\n            }\\n            \\n            pre = n - 1;\\n            for (int j = n - 1; j >= 0; j--){\\n                if((dp[i + 1][pre] - (pre - j)) <= dp[i + 1][j])\\n                    pre = j;\\n                dp[i][j] = Math.max(dp[i][j], dp[i + 1][pre] - (pre - j) + points[i][j]);\\n            }\\n        }\\n        \\n        long max = 0;\\n        for (int j = 0; j < n; j++){\\n            max = Math.max(max, dp[0][j]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m = points.length;\\n        int n = points[0].length;\\n        \\n        long[][] dp = new long[m][n];\\n        for (int j = 0; j < n; j++){\\n            dp[m - 1][j] = points[m - 1][j];\\n        }\\n        for (int i = m - 2; i >= 0; i--){         \\n            ArrayDeque<Integer> deque = new ArrayDeque<>();            \\n            for (int j = 0; j < n; j++){\\n                while(!deque.isEmpty() && dp[i + 1][deque.peekLast()] - (j - deque.peekLast()) <= dp[i + 1][j]){\\n                    deque.removeLast();\\n                }        \\n                deque.addLast(j);\\n                dp[i][j] = Math.max(dp[i][j], dp[i + 1][deque.peekFirst()] + points[i][j] - (j - deque.peekFirst()));\\n            }          \\n            deque.clear();            \\n            for (int j = n - 1; j >= 0; j--){\\n                while(!deque.isEmpty() && dp[i + 1][deque.peekLast()] - (deque.peekLast() - j) <= dp[i + 1][j]){\\n                    deque.removeLast();\\n                }        \\n                deque.addLast(j);\\n                dp[i][j] = Math.max(dp[i][j], dp[i + 1][deque.peekFirst()] + points[i][j] - (deque.peekFirst() - j));\\n            }\\n        } \\n        long max = 0;\\n        for (int j = 0; j < n; j++){\\n            max = Math.max(max, dp[0][j]);\\n        }        \\n        return max;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m = points.length;\\n        int n = points[0].length;\\n        long[][] dp = new long[m][n];\\n        for (int j = 0; j < n; j++){\\n            dp[m - 1][j] = points[m - 1][j];\\n        }\\n        \\n        for (int i = m - 2; i >= 0; i--){\\n            int pre = 0;\\n            for (int j = 0; j < n; j++){\\n                if(dp[i + 1][pre] - (j - pre) <= dp[i + 1][j])\\n                    pre = j;\\n                dp[i][j] = Math.max(dp[i][j], dp[i + 1][pre] - (j - pre) + points[i][j]);\\n            }\\n            \\n            pre = n - 1;\\n            for (int j = n - 1; j >= 0; j--){\\n                if((dp[i + 1][pre] - (pre - j)) <= dp[i + 1][j])\\n                    pre = j;\\n                dp[i][j] = Math.max(dp[i][j], dp[i + 1][pre] - (pre - j) + points[i][j]);\\n            }\\n        }\\n        \\n        long max = 0;\\n        for (int j = 0; j < n; j++){\\n            max = Math.max(max, dp[0][j]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345021,
                "title": "javascript-easy-dp",
                "content": "Main idea: use a 2D dp Array, to save current max score in each dp[i][j], the answer is the max value of the final row.\\n\\nExample 1: \\n/* dp of each row\\n[1,2,3]\\n\\nmax(1+1,1+2-1,1+3-2) max(5+1-1, 5+2, 5+3-1)  max(1+1 -2, 1+2-1, 1+3)\\n[2,7,4]\\n\\nmax(3+2, 3+7-1, 3+4-2)  max(1+2-1, 1+7, 1+4-1) max(1+2-2, 1+7-1, 1+4)\\n[9,8,7]\\n*/\\n\\n```\\nconst abs = Math.abs;\\nconst maxPoints = (g) => {\\n    let n = g.length;\\n    let m = g[0].length;\\n    let dp = initialize2DArrayNew(n, m); // dp[i][j]: save max sum score of row [0 ... i - 1] + g[i][j]\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (i == 0) {\\n                dp[i][j] = g[i][j]; // first row sum score is the same as grid\\n            } else {\\n                let max = 0; // get max plus score from previous row i-1 of all cols (dp[i-1][col]), add to dp[i][j]\\n                for (let col = 0; col < m; col++) {\\n                    let colDiff = abs(j - col);\\n                    let plus = g[i][j] + dp[i - 1][col] - colDiff; // dp[i-1][col]: current sum score of previous row all cols\\n                    max = Math.max(max, plus)\\n                }\\n                dp[i][j] += max;\\n            }\\n        }\\n    }\\n    return Math.max.apply(Math, dp[n - 1]); // result should be max value of the final row\\n};\\n\\n// this is 2D array initialization, you may use your own way. I tested in js, this way is the fastest\\n// in Java:   int[][] a = new int[n][m];\\nconst initialize2DArrayNew = (n, m) => { let data = []; for (let i = 0; i < n; i++) { let tmp = Array(m).fill(0); data.push(tmp); } return data; };\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst abs = Math.abs;\\nconst maxPoints = (g) => {\\n    let n = g.length;\\n    let m = g[0].length;\\n    let dp = initialize2DArrayNew(n, m); // dp[i][j]: save max sum score of row [0 ... i - 1] + g[i][j]\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (i == 0) {\\n                dp[i][j] = g[i][j]; // first row sum score is the same as grid\\n            } else {\\n                let max = 0; // get max plus score from previous row i-1 of all cols (dp[i-1][col]), add to dp[i][j]\\n                for (let col = 0; col < m; col++) {\\n                    let colDiff = abs(j - col);\\n                    let plus = g[i][j] + dp[i - 1][col] - colDiff; // dp[i-1][col]: current sum score of previous row all cols\\n                    max = Math.max(max, plus)\\n                }\\n                dp[i][j] += max;\\n            }\\n        }\\n    }\\n    return Math.max.apply(Math, dp[n - 1]); // result should be max value of the final row\\n};\\n\\n// this is 2D array initialization, you may use your own way. I tested in js, this way is the fastest\\n// in Java:   int[][] a = new int[n][m];\\nconst initialize2DArrayNew = (n, m) => { let data = []; for (let i = 0; i < n; i++) { let tmp = Array(m).fill(0); data.push(tmp); } return data; };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344977,
                "title": "java-o-m-n-two-pass-dp",
                "content": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        //tried to come up with an m*n time complexity dp as suspected from Constraints\\n        int M=points.length;\\n        int N=points[0].length;\\n        long[][] dp=new long[M+1][N+1];\\n        long res=0;\\n        \\n        for (int n=0; n<N; n++){\\n            dp[0][n]=points[0][n];    \\n        }        \\n        for (int m=0; m<M-1; m++){ \\n            long maxL=0;\\n            for (int n=0; n<N; n++){\\n                maxL=Math.max(maxL-1,dp[m][n]);\\n                dp[m+1][n]=maxL+points[m+1][n];\\n            }\\n            \\n            long maxR=0;\\n            for (int n=N-1; n>=0; n--){\\n                maxR=Math.max(maxR-1,dp[m][n]);\\n                dp[m+1][n]=Math.max(dp[m+1][n],maxR+points[m+1][n]);\\n            }            \\n        }\\n        \\n        for (int n=0; n<N; n++){\\n            res=Math.max(dp[M-1][n],res);\\n        }\\n        return res;\\n    }\\n}\\n```\\nAmong all bottom up dp questions, this is one of the easier ones that we can further reduce Space complexitiy to trivial O(N). We only need two rows of array.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        //tried to come up with an m*n time complexity dp as suspected from Constraints\\n        int M=points.length;\\n        int N=points[0].length;\\n        long[][] dp=new long[M+1][N+1];\\n        long res=0;\\n        \\n        for (int n=0; n<N; n++){\\n            dp[0][n]=points[0][n];    \\n        }        \\n        for (int m=0; m<M-1; m++){ \\n            long maxL=0;\\n            for (int n=0; n<N; n++){\\n                maxL=Math.max(maxL-1,dp[m][n]);\\n                dp[m+1][n]=maxL+points[m+1][n];\\n            }\\n            \\n            long maxR=0;\\n            for (int n=N-1; n>=0; n--){\\n                maxR=Math.max(maxR-1,dp[m][n]);\\n                dp[m+1][n]=Math.max(dp[m+1][n],maxR+points[m+1][n]);\\n            }            \\n        }\\n        \\n        for (int n=0; n<N; n++){\\n            res=Math.max(dp[M-1][n],res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344920,
                "title": "why-is-this-giving-tle-memoization",
                "content": "```\\n vector<vector<long long>>dp;\\n    long long  solve(vector<vector<int>>& p,int r, int c){  \\n        \\n        if(r==p.size())\\n        {   \\n            return  0; \\n        }\\n        \\n        if(dp[r][c]!=-1)\\n        {\\n            return dp[r][c];  \\n        }\\n        \\n        long long ans = 0;\\n        long long val,res;\\n        int i,j;  \\n        \\n        for(i=0;i<p[r].size();i++)\\n        {\\n            val = solve(p,r+1,i); \\n            val = val + p[r][i]; \\n            if(r!=0)\\n            {\\n              val =  val - abs(c-i);\\n            }\\n            if(ans < val)\\n            {\\n                ans = val; \\n            }\\n        }\\n         \\n        dp[r][c]=ans; \\n        \\n        return ans;  \\n    }\\n    long long maxPoints(vector<vector<int>>& p) { \\n       \\n       for(int i=0;i<p.size();i++)\\n       {\\n           vector<long long>a; \\n           for(int j=0;j<p[i].size();j++)\\n           {\\n               a.push_back(-1); \\n           }\\n           \\n           dp.push_back(a); \\n       }\\n        \\n       solve(p,0,0); \\n       return dp[0][0];   \\n    }",
                "solutionTags": [],
                "code": "```\\n vector<vector<long long>>dp;\\n    long long  solve(vector<vector<int>>& p,int r, int c){  \\n        \\n        if(r==p.size())\\n        {   \\n            return  0; \\n        }\\n        \\n        if(dp[r][c]!=-1)\\n        {\\n            return dp[r][c];  \\n        }\\n        \\n        long long ans = 0;\\n        long long val,res;\\n        int i,j;  \\n        \\n        for(i=0;i<p[r].size();i++)\\n        {\\n            val = solve(p,r+1,i); \\n            val = val + p[r][i]; \\n            if(r!=0)\\n            {\\n              val =  val - abs(c-i);\\n            }\\n            if(ans < val)\\n            {\\n                ans = val; \\n            }\\n        }\\n         \\n        dp[r][c]=ans; \\n        \\n        return ans;  \\n    }\\n    long long maxPoints(vector<vector<int>>& p) { \\n       \\n       for(int i=0;i<p.size();i++)\\n       {\\n           vector<long long>a; \\n           for(int j=0;j<p[i].size();j++)\\n           {\\n               a.push_back(-1); \\n           }\\n           \\n           dp.push_back(a); \\n       }\\n        \\n       solve(p,0,0); \\n       return dp[0][0];   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2958475,
                "title": "c-dfs-memorization-is-all-your-need",
                "content": "### Naive DFS+MEMO\\n\\nLet\\'s start from the following code, note that it will get TLE:\\n\\n```\\nclass Solution {\\npublic:\\n    int abs(int a, int b){\\n        return a>b?a-b:b-a;\\n    }\\n    long long dfs(vector<vector<int>>& mat_, int row, int col){\\n        if(row==(m_-1)){\\n            return mat_[row][col];\\n        }\\n        if(dp_[row][col]!=-1){\\n            return dp_[row][col];\\n        }\\n\\n        long long res=0;\\n        for(int j=0;j<n_;j++){\\n            if((mat_[row+1][j]-abs(j,col))<0) continue;\\n            res=max(res, mat_[row][col]+dfs(mat_, row+1, j)-abs(j,col));\\n        }\\n        return dp_[row][col]=res;\\n    }\\n    long long maxPoints(vector<vector<int>>& points) {\\n        m_=points.size();\\n        n_=points[0].size();\\n        dp_.resize(m_);\\n        for(int i=0;i<m_;i++){\\n            dp_[i]=vector<long long>(n_,-1);\\n        }\\n        long long res=0;\\n        for(int j=0;j<n_;j++){\\n            res = max(res, dfs(points,0,j));\\n        }\\n        return res;\\n    }\\nprivate:\\n    vector<vector<long long>> dp_;\\n    int m_,n_;\\n};\\n```\\n\\n### A more efficient approach\\n\\nI rewrite the dp alg in a top-down way. The key idea is to reduce the time cost of **max(dfs(mat_, row+1, j)-abs(j,col) for j in range(n))**. \\n\\nI convert it to **max(lgt_[row][col], rgt_[row][col])** as lgt_[row][col] and rgt_[row][col] denote **max(dfs(mat_, row+1, j)-abs(j,col) for j in range(col+1))** and **max(dfs(mat_, row+1, j)-abs(j,col) for j in range(col,n))** respectively.\\n\\n\\nReference: https://leetcode.com/problems/maximum-number-of-points-with-cost/solutions/1344908/c-java-python-3-dp-explanation-with-pictures-o-mn-time-o-n-space/\\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\nclass Solution {\\npublic:\\n    long long dfs(vector<vector<int>>& mat_, int row, int col){\\n        if(row==(m_-1)){\\n            return mat_[row][col];\\n        }\\n\\n        if(lgt_[row][0]==-1){\\n            lgt_[row][0]=dfs(mat_,row+1,0);\\n            rgt_[row][n_-1]=dfs(mat_,row+1,n_-1);\\n            for(int j=1;j<n_;j++){\\n                lgt_[row][j]=max(lgt_[row][j-1]-1, dfs(mat_,row+1,j));\\n            }\\n            for(int j=n_-2;j>=0;j--){\\n                rgt_[row][j]=max(rgt_[row][j+1]-1, dfs(mat_,row+1,j));\\n            }\\n        }\\n\\n        long long res = mat_[row][col] + max(lgt_[row][col], rgt_[row][col]);\\n        return res;\\n    }\\n    long long maxPoints(vector<vector<int>>& points) {\\n        m_=points.size();\\n        n_=points[0].size();\\n        lgt_.resize(m_);\\n        rgt_.resize(m_);\\n        for(int i=0;i<m_;i++){\\n            lgt_[i]=vector<long long>(n_,-1);\\n            rgt_[i]=vector<long long>(n_,-1);\\n        }\\n        long long res=0;\\n        for(int j=0;j<n_;j++){\\n            res = max(res, dfs(points,0,j));\\n        }\\n        return res;\\n    }\\nprivate:\\n    vector<vector<long long>> lgt_, rgt_;\\n    int m_,n_;\\n};\\n```\\n\\n### Complexity\\n- Time complexity: $$O(m*n)$$ in average\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int abs(int a, int b){\\n        return a>b?a-b:b-a;\\n    }\\n    long long dfs(vector<vector<int>>& mat_, int row, int col){\\n        if(row==(m_-1)){\\n            return mat_[row][col];\\n        }\\n        if(dp_[row][col]!=-1){\\n            return dp_[row][col];\\n        }\\n\\n        long long res=0;\\n        for(int j=0;j<n_;j++){\\n            if((mat_[row+1][j]-abs(j,col))<0) continue;\\n            res=max(res, mat_[row][col]+dfs(mat_, row+1, j)-abs(j,col));\\n        }\\n        return dp_[row][col]=res;\\n    }\\n    long long maxPoints(vector<vector<int>>& points) {\\n        m_=points.size();\\n        n_=points[0].size();\\n        dp_.resize(m_);\\n        for(int i=0;i<m_;i++){\\n            dp_[i]=vector<long long>(n_,-1);\\n        }\\n        long long res=0;\\n        for(int j=0;j<n_;j++){\\n            res = max(res, dfs(points,0,j));\\n        }\\n        return res;\\n    }\\nprivate:\\n    vector<vector<long long>> dp_;\\n    int m_,n_;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long dfs(vector<vector<int>>& mat_, int row, int col){\\n        if(row==(m_-1)){\\n            return mat_[row][col];\\n        }\\n\\n        if(lgt_[row][0]==-1){\\n            lgt_[row][0]=dfs(mat_,row+1,0);\\n            rgt_[row][n_-1]=dfs(mat_,row+1,n_-1);\\n            for(int j=1;j<n_;j++){\\n                lgt_[row][j]=max(lgt_[row][j-1]-1, dfs(mat_,row+1,j));\\n            }\\n            for(int j=n_-2;j>=0;j--){\\n                rgt_[row][j]=max(rgt_[row][j+1]-1, dfs(mat_,row+1,j));\\n            }\\n        }\\n\\n        long long res = mat_[row][col] + max(lgt_[row][col], rgt_[row][col]);\\n        return res;\\n    }\\n    long long maxPoints(vector<vector<int>>& points) {\\n        m_=points.size();\\n        n_=points[0].size();\\n        lgt_.resize(m_);\\n        rgt_.resize(m_);\\n        for(int i=0;i<m_;i++){\\n            lgt_[i]=vector<long long>(n_,-1);\\n            rgt_[i]=vector<long long>(n_,-1);\\n        }\\n        long long res=0;\\n        for(int j=0;j<n_;j++){\\n            res = max(res, dfs(points,0,j));\\n        }\\n        return res;\\n    }\\nprivate:\\n    vector<vector<long long>> lgt_, rgt_;\\n    int m_,n_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827593,
                "title": "c-clean-10-lines-dp-solution-time-n-m-space-m",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        vector<long long> res ((int) points[0].size(), 0);\\n        for (auto i = 0; i < points.size(); i++) {\\n            for (auto j = 0; j < points[i].size(); j++) {\\n                res[j] += points[i][j]; // Here, res[j] is the total points we have if we pick the j-th number in the i-th row.\\n                if (j > 0) res[j] = max (res[j], res[j - 1] - 1); // Here, we prepare vector res for the next row\\'s points\\n            }\\n            for (int j = points[i].size() - 2; j >= 0; j--)\\n                res[j] = max (res[j], res[j + 1] - 1); // Here, we are still preparing vector res for the next row\\'s points\\n        }\\n        return *max_element(res.begin(), res.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        vector<long long> res ((int) points[0].size(), 0);\\n        for (auto i = 0; i < points.size(); i++) {\\n            for (auto j = 0; j < points[i].size(); j++) {\\n                res[j] += points[i][j]; // Here, res[j] is the total points we have if we pick the j-th number in the i-th row.\\n                if (j > 0) res[j] = max (res[j], res[j - 1] - 1); // Here, we prepare vector res for the next row\\'s points\\n            }\\n            for (int j = points[i].size() - 2; j >= 0; j--)\\n                res[j] = max (res[j], res[j + 1] - 1); // Here, we are still preparing vector res for the next row\\'s points\\n        }\\n        return *max_element(res.begin(), res.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582137,
                "title": "easy-to-understand-commented-c",
                "content": "Converted n3 to n2 is a sub problem from :\\n\\nhttps://leetcode.com/problems/trapping-rain-water/\\n\\n\\n```\\nlong long maxPoints(vector<vector<int>>& points) {\\n        int r = points.size();\\n        int c = points[0].size();\\n        \\n        vector<long long> dp(c,0);\\n        vector<long long> dpPrev(c,0);\\n   \\n        for (int i = 0; i < c; i++) {\\n            dpPrev[i] = points[0][i];\\n        }\\n        \\n        vector<long long> leftMax(c,0);\\n        vector<long long> rightMax(c,0);\\n            \\n        for (int i = 1; i < r; i++) {\\n            // figure out the left Max from the current index\\n            // leftMost index has no neighbor so it is only max\\n            leftMax[0] = dpPrev[0];\\n            for (int j = 1; j < c; j++) {\\n                // current max till j-1 is reduced by 1 and previous same column max\\n                // one of these 2 will be maxium\\n                leftMax[j] = max(leftMax[j-1]-1, dpPrev[j]);\\n            }\\n            \\n            // right most number has no member hence it is the max\\n            rightMax[c-1] = dpPrev[c-1];\\n            for (int j = c-2; j >= 0; j--) {\\n                // current max from right -1 as we are shifting to left or max you are getting from \\n                // same column from previous iteration.\\n                rightMax[j] = max(rightMax[j+1]-1, dpPrev[j]);\\n            }\\n            \\n            for (int j = 0; j < c; j++) {\\n                // so far any point result will be current sum and max of left Max and right Max\\n                dp[j] = points[i][j] + max(leftMax[j],rightMax[j]);\\n            }\\n            swap(dpPrev,dp);\\n        }\\n        return *max_element(dpPrev.begin(),dpPrev.end());\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nlong long maxPoints(vector<vector<int>>& points) {\\n        int r = points.size();\\n        int c = points[0].size();\\n        \\n        vector<long long> dp(c,0);\\n        vector<long long> dpPrev(c,0);\\n   \\n        for (int i = 0; i < c; i++) {\\n            dpPrev[i] = points[0][i];\\n        }\\n        \\n        vector<long long> leftMax(c,0);\\n        vector<long long> rightMax(c,0);\\n            \\n        for (int i = 1; i < r; i++) {\\n            // figure out the left Max from the current index\\n            // leftMost index has no neighbor so it is only max\\n            leftMax[0] = dpPrev[0];\\n            for (int j = 1; j < c; j++) {\\n                // current max till j-1 is reduced by 1 and previous same column max\\n                // one of these 2 will be maxium\\n                leftMax[j] = max(leftMax[j-1]-1, dpPrev[j]);\\n            }\\n            \\n            // right most number has no member hence it is the max\\n            rightMax[c-1] = dpPrev[c-1];\\n            for (int j = c-2; j >= 0; j--) {\\n                // current max from right -1 as we are shifting to left or max you are getting from \\n                // same column from previous iteration.\\n                rightMax[j] = max(rightMax[j+1]-1, dpPrev[j]);\\n            }\\n            \\n            for (int j = 0; j < c; j++) {\\n                // so far any point result will be current sum and max of left Max and right Max\\n                dp[j] = points[i][j] + max(leftMax[j],rightMax[j]);\\n            }\\n            swap(dpPrev,dp);\\n        }\\n        return *max_element(dpPrev.begin(),dpPrev.end());\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494892,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        a=len(points[0])\\n        b=len(points)\\n        s=[]\\n        for i in range((b)-1):\\n            for j in range(1,(a)):\\n                points[i][j]=max(points[i][j], points[i][j - 1] - 1)\\n            for j in range(a-2,-1,-1):\\n                points[i][j]=max(points[i][j], points[i][j + 1] - 1)\\n            for j in range(a):\\n                points[i+1][j]+=points[i][j]\\n        for i in range(len(points)):\\n            s.append(max(points[i]))\\n        return max(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        a=len(points[0])\\n        b=len(points)\\n        s=[]\\n        for i in range((b)-1):\\n            for j in range(1,(a)):\\n                points[i][j]=max(points[i][j], points[i][j - 1] - 1)\\n            for j in range(a-2,-1,-1):\\n                points[i][j]=max(points[i][j], points[i][j + 1] - 1)\\n            for j in range(a):\\n                points[i+1][j]+=points[i][j]\\n        for i in range(len(points)):\\n            s.append(max(points[i]))\\n        return max(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434877,
                "title": "converting-an-o-m-n-n-solution-to-o-m-n",
                "content": "This question at first reminded me about the path sum problem, which is one of the standard dp problem in which we need to calculate the minimum cost of traversal from first row to the last row.\\n\\nCode 1 - Memoization (TLE)\\n![image](https://assets.leetcode.com/users/images/3ebe94ef-e792-4931-a2bb-6154e81e3d5a_1660664196.205652.png)\\n\\nTC : O(M x N x N)\\n\\nThe complexity for tabulation version is also going to be same but just for reference, here is the tabulation version of the above code\\n![image](https://assets.leetcode.com/users/images/659ec716-8978-4bc4-9fe3-57f6c9a8d406_1660664251.4899764.png)\\n\\nBefore reading from here, I would highly recommend reading this [post](https://leetcode.com/problems/maximum-number-of-points-with-cost/discuss/1346996/Why-this-is-a-good-problem-and-what-you-can-learn-from-what-I-learned) \\n*Basically it asks us to solve 2 question before solving this problem*\\n[121. Best time to buy and sell a stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n[104. Best sightseeing pair ](https://leetcode.com/problems/best-sightseeing-pair/)\\n\\nAfter solving both the questions, the trick to reduce the complexity would become very intuitive\\nCode - 3 : Accepted\\nTC : O(M x N)\\n![image](https://assets.leetcode.com/users/images/2474bd25-1cf8-43f8-9252-64562dd27501_1660664623.3111506.png)\\n\\n\\n",
                "solutionTags": [],
                "code": "This question at first reminded me about the path sum problem, which is one of the standard dp problem in which we need to calculate the minimum cost of traversal from first row to the last row.\\n\\nCode 1 - Memoization (TLE)\\n![image](https://assets.leetcode.com/users/images/3ebe94ef-e792-4931-a2bb-6154e81e3d5a_1660664196.205652.png)\\n\\nTC : O(M x N x N)\\n\\nThe complexity for tabulation version is also going to be same but just for reference, here is the tabulation version of the above code\\n![image](https://assets.leetcode.com/users/images/659ec716-8978-4bc4-9fe3-57f6c9a8d406_1660664251.4899764.png)\\n\\nBefore reading from here, I would highly recommend reading this [post](https://leetcode.com/problems/maximum-number-of-points-with-cost/discuss/1346996/Why-this-is-a-good-problem-and-what-you-can-learn-from-what-I-learned) \\n*Basically it asks us to solve 2 question before solving this problem*\\n[121. Best time to buy and sell a stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n[104. Best sightseeing pair ](https://leetcode.com/problems/best-sightseeing-pair/)\\n\\nAfter solving both the questions, the trick to reduce the complexity would become very intuitive\\nCode - 3 : Accepted\\nTC : O(M x N)\\n![image](https://assets.leetcode.com/users/images/2474bd25-1cf8-43f8-9252-64562dd27501_1660664623.3111506.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2386972,
                "title": "c-dp-memoization-tle-down-up-similar-to-path-sum-questions",
                "content": "##  Memoization -> TLE \\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    ll func(vector<vector<int>> &grid , int r , int prev_col , vector<vector<ll>> &dp , int m , int n)\\n    {\\n        if(r>=m)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[r][prev_col]!=-1)\\n        {\\n            return dp[r][prev_col];\\n        }\\n        \\n        ll ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ll curr = grid[r][i] - abs(i-prev_col) + func(grid , r+1 , i , dp , m , n);\\n            \\n            \\n            ans=max(ans , curr);\\n        }\\n        \\n        return dp[r][prev_col] = ans;\\n    }\\n     long long maxPoints(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<ll>> dp(m+1 , vector<ll>(n+1 , -1));\\n         \\n         ll ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ll curr = grid[0][i] +func(grid , 1 , i , dp , m , n );\\n            ans=max(ans , curr);\\n        }\\n         \\n         return ans;\\n         \\n     }\\n\\n    \\n    \\n```\\n\\n## Bottom UP DP ->\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition -> We have to make the array of max points taken array \\n    \\n    // lets say we have taken consideration for example 1 of given testcase\\n    \\n    // [ 3 , 1 , 1] \\n    // we have to put the max value can be taken at each index (left-right array)\\n    \\n    // [ 3 , 2 , 1] \\n    \\n    // now add the corresponding values from above row  -> [ 4 , 7 , 2] \\n    \\n    // now apply same algo for it  firstly from left to right-> [ 4 , 7 , 6] \\n    \\n    // then right to left [ 6 , 7 , 6] \\n    \\n    // add corresponding value -> [ 7 , 9 , 9] -> this is the final array \\n    \\n    long long maxPoints(vector<vector<int>>& grid) {\\n        \\n        // this is the question based falling path sum \\n        \\n        // going bottom to up \\n        \\n        // taking the max sum value array \\n        \\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<ll> nums(n , 0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=grid[m-1][i];\\n        }\\n        \\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                nums[j]=max(nums[j-1]-1 , nums[j] );\\n            }\\n            \\n            for(int j=n-2;j>=0;j--)\\n            {\\n                nums[j]=max(nums[j+1]-1 , nums[j]);\\n            }\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                nums[j]+=grid[i][j];\\n            }\\n        }\\n        \\n        ll ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ans=max(ans , nums[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    ll func(vector<vector<int>> &grid , int r , int prev_col , vector<vector<ll>> &dp , int m , int n)\\n    {\\n        if(r>=m)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[r][prev_col]!=-1)\\n        {\\n            return dp[r][prev_col];\\n        }\\n        \\n        ll ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ll curr = grid[r][i] - abs(i-prev_col) + func(grid , r+1 , i , dp , m , n);\\n            \\n            \\n            ans=max(ans , curr);\\n        }\\n        \\n        return dp[r][prev_col] = ans;\\n    }\\n     long long maxPoints(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<ll>> dp(m+1 , vector<ll>(n+1 , -1));\\n         \\n         ll ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ll curr = grid[0][i] +func(grid , 1 , i , dp , m , n );\\n            ans=max(ans , curr);\\n        }\\n         \\n         return ans;\\n         \\n     }\\n\\n    \\n    \\n```\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition -> We have to make the array of max points taken array \\n    \\n    // lets say we have taken consideration for example 1 of given testcase\\n    \\n    // [ 3 , 1 , 1] \\n    // we have to put the max value can be taken at each index (left-right array)\\n    \\n    // [ 3 , 2 , 1] \\n    \\n    // now add the corresponding values from above row  -> [ 4 , 7 , 2] \\n    \\n    // now apply same algo for it  firstly from left to right-> [ 4 , 7 , 6] \\n    \\n    // then right to left [ 6 , 7 , 6] \\n    \\n    // add corresponding value -> [ 7 , 9 , 9] -> this is the final array \\n    \\n    long long maxPoints(vector<vector<int>>& grid) {\\n        \\n        // this is the question based falling path sum \\n        \\n        // going bottom to up \\n        \\n        // taking the max sum value array \\n        \\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<ll> nums(n , 0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=grid[m-1][i];\\n        }\\n        \\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                nums[j]=max(nums[j-1]-1 , nums[j] );\\n            }\\n            \\n            for(int j=n-2;j>=0;j--)\\n            {\\n                nums[j]=max(nums[j+1]-1 , nums[j]);\\n            }\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                nums[j]+=grid[i][j];\\n            }\\n        }\\n        \\n        ll ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ans=max(ans , nums[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269935,
                "title": "c-precomputations-explaination-easy-to-understand-solution",
                "content": "1). consider matrix  \\n\\t1 2 5\\n\\t7 5 4\\n\\tlets take A = (5 from the 1st row,) now for A there are 2 options , either take point from left of second row or right of second row\\n\\tNow instead of running a loop to check best option , we can see that if there is some row like 7 5 4 , best element for A would be 7 \\n\\tas column for 7 is 1 and for A is 3 and (7+5 - (3-1) = 10) , we can see that if we shift A from right to column 1 it would become 3 and (7+3 = 10) . so instead of running loop we can precompute the above rows to see what is best option for current element in the above row.\\n\\tfor eg. the above matrix after precomputation in 1st row will become\\n\\t3 4 5\\n\\t7 5 4\\n\\tnow we just add the best option from above row for current column and similarly move to next row.\\n\\twhen precomputing left and right options we are taking the maximum till now and subtracting 1 for every shift *(if the previous maximum can still be maximum after shifting it and subtracting 1) *since that is the distance which will subtract if the below element choose this element for eg , if 7 takes A (which is 5 of 1st row) the distance between them is 2 that is why we store 3 above 7. \\n\\nIf any doubt ask in comments  :)\\n\\n```\\nclass Solution {\\npublic:\\n   long long maxPoints(vector<vector<int>>& p) {\\n        int n = (int)p.size() , m = (int)p[0].size();\\n        vector<vector<int64_t>>points;   //making points as a matrix holding int64_t for larger calculations\\n        for(auto temp : p){\\n            vector<int64_t>lost;\\n            for(auto r : temp){\\n                int64_t x = (int64_t)r;\\n                lost.push_back(x);\\n            }\\n            points.push_back(lost);\\n        }\\n       \\n        int64_t ans = (int64_t)-1;\\n        for(int i = 1 ; i<n; i++){\\n            vector<int64_t>left(m,(int64_t)0),right(m,(int64_t)0);\\n            int64_t mx = 0ll;\\n            for(int j = 0 ; j<m; j++){\\n                left[j] = max(mx-(int64_t)1,(int64_t)points[i-1][j]);// calculating the best points the current element at (i,j) should take from left of above row.\\n                mx = left[j];\\n            }\\n            mx = 0;\\n            for(int j = m-1 ; j>=0; j--){\\n                right[j] = max(mx-(int64_t)1,(int64_t)points[i-1][j]);// calculating the best points the current element at (i,j) should take from right of above row.\\n                mx = right[j];\\n            }\\n            for(int j = 0 ; j<m; j++){\\n                points[i][j] = max(left[j],right[j]) + (int64_t)points[i][j]; //taking the maximum of both the left,right and adding the current point.\\n            }\\n        }\\n        for(int i = 0 ; i<m; i++){\\n            ans = max((int64_t)points[n-1][i],ans);\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   long long maxPoints(vector<vector<int>>& p) {\\n        int n = (int)p.size() , m = (int)p[0].size();\\n        vector<vector<int64_t>>points;   //making points as a matrix holding int64_t for larger calculations\\n        for(auto temp : p){\\n            vector<int64_t>lost;\\n            for(auto r : temp){\\n                int64_t x = (int64_t)r;\\n                lost.push_back(x);\\n            }\\n            points.push_back(lost);\\n        }\\n       \\n        int64_t ans = (int64_t)-1;\\n        for(int i = 1 ; i<n; i++){\\n            vector<int64_t>left(m,(int64_t)0),right(m,(int64_t)0);\\n            int64_t mx = 0ll;\\n            for(int j = 0 ; j<m; j++){\\n                left[j] = max(mx-(int64_t)1,(int64_t)points[i-1][j]);// calculating the best points the current element at (i,j) should take from left of above row.\\n                mx = left[j];\\n            }\\n            mx = 0;\\n            for(int j = m-1 ; j>=0; j--){\\n                right[j] = max(mx-(int64_t)1,(int64_t)points[i-1][j]);// calculating the best points the current element at (i,j) should take from right of above row.\\n                mx = right[j];\\n            }\\n            for(int j = 0 ; j<m; j++){\\n                points[i][j] = max(left[j],right[j]) + (int64_t)points[i][j]; //taking the maximum of both the left,right and adding the current point.\\n            }\\n        }\\n        for(int i = 0 ; i<m; i++){\\n            ans = max((int64_t)points[n-1][i],ans);\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268082,
                "title": "python3",
                "content": "class Solution:\\n\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m,n = len(points),len(points[0])\\n        prev = points[0]\\n        left = [0]*n\\n        right = [0]*n\\n        \\n        for i in range(1,m):\\n            curr = points[i]\\n            left[0] = prev[0] \\n            right[-1] = prev[-1]\\n            for j in range(1,n):\\n                left[j] = max(left[j-1]-1,prev[j])\\n            for j in reversed(range(n-1)):\\n                right[j] = max(right[j+1]-1,prev[j])\\n            for j in range(n):\\n                curr[j]+=max(left[j],right[j])\\n            prev = curr\\n        \\n        return max(prev)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m,n = len(points),len(points[0])\\n        prev = points[0]\\n        left = [0]*n\\n        right = [0]*n\\n        \\n        for i in range(1,m):\\n            curr = points[i]\\n            left[0] = prev[0] \\n            right[-1] = prev[-1]\\n            for j in range(1,n):\\n                left[j] = max(left[j-1]-1,prev[j])\\n            for j in reversed(range(n-1)):\\n                right[j] = max(right[j+1]-1,prev[j])\\n            for j in range(n):\\n                curr[j]+=max(left[j],right[j])\\n            prev = curr\\n        \\n        return max(prev)",
                "codeTag": "Java"
            },
            {
                "id": 2189621,
                "title": "c-simple-dp-solution-tc-o-nxm-precomputation",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        int m=points[0].size();\\n        vector<vector<ll>> dp(n,vector<ll>(m));\\n        for(ll i=0;i<m;i++)\\n        {\\n            dp[0][i]=points[0][i];\\n        }\\n        for(ll i=1;i<n;i++)\\n        {\\n            vector<ll> pre(m),post(m);\\n            pre[0]=dp[i-1][0];\\n            post[m-1]=dp[i-1][m-1]-(m-1);\\n            for(ll k=1;k<m;k++)\\n            {\\n                pre[k]=max(pre[k-1],dp[i-1][k]+k);\\n            }\\n            for(ll k=m-2;k>=0;k--)\\n            {\\n                post[k]=max(post[k+1],dp[i-1][k]-k);\\n            }\\n            for(ll j=0;j<m;j++)\\n            {\\n                dp[i][j]=max(points[i][j]+j+post[j],points[i][j]-j+pre[j]);\\n            }\\n        }\\n        ll ans=0;\\n        for(ll i=0;i<m;i++)\\n        {\\n            ans=max(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        int m=points[0].size();\\n        vector<vector<ll>> dp(n,vector<ll>(m));\\n        for(ll i=0;i<m;i++)\\n        {\\n            dp[0][i]=points[0][i];\\n        }\\n        for(ll i=1;i<n;i++)\\n        {\\n            vector<ll> pre(m),post(m);\\n            pre[0]=dp[i-1][0];\\n            post[m-1]=dp[i-1][m-1]-(m-1);\\n            for(ll k=1;k<m;k++)\\n            {\\n                pre[k]=max(pre[k-1],dp[i-1][k]+k);\\n            }\\n            for(ll k=m-2;k>=0;k--)\\n            {\\n                post[k]=max(post[k+1],dp[i-1][k]-k);\\n            }\\n            for(ll j=0;j<m;j++)\\n            {\\n                dp[i][j]=max(points[i][j]+j+post[j],points[i][j]-j+pre[j]);\\n            }\\n        }\\n        ll ans=0;\\n        for(ll i=0;i<m;i++)\\n        {\\n            ans=max(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123627,
                "title": "c-dp",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    long long maxPoints(vector<vector<int>>& points)\\n    {\\n        int n=points.size();\\n        int m=points[0].size();\\n        long long ar[m+1];\\n        long long res[m+1];\\n        for(int j=0; j<m; j++)res[j]=points[0][j];\\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)ar[j]=0;\\n            long long  ma=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                ma=max(ma,res[j]);\\n                ar[j]=ma;\\n                ma--;\\n            }\\n            ma=0;\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                ma=max(ma,res[j]);\\n                ar[j]=max(ma,ar[j]);\\n                ma--;\\n            }\\n            for(int j=0; j<m; j++)\\n            {\\n                res[j]=ar[j]+points[i][j];\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0; i<m; i++)\\n        {\\n            ans=max(ans,res[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long maxPoints(vector<vector<int>>& points)\\n    {\\n        int n=points.size();\\n        int m=points[0].size();\\n        long long ar[m+1];\\n        long long res[m+1];\\n        for(int j=0; j<m; j++)res[j]=points[0][j];\\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)ar[j]=0;\\n            long long  ma=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                ma=max(ma,res[j]);\\n                ar[j]=ma;\\n                ma--;\\n            }\\n            ma=0;\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                ma=max(ma,res[j]);\\n                ar[j]=max(ma,ar[j]);\\n                ma--;\\n            }\\n            for(int j=0; j<m; j++)\\n            {\\n                res[j]=ar[j]+points[i][j];\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0; i<m; i++)\\n        {\\n            ans=max(ans,res[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038609,
                "title": "python-using-left-and-right-max-takeout-from-the-prev",
                "content": "(1) as most algo posted here, precompute the max takeout from left and right positions;\\n(2) and then add to the current row position\\n\\n```\\ndef maxPoints(self, points: List[List[int]]) -> int:\\n        m=len(points)\\n        n=len(points[0])\\n        def getleft(arr):\\n            ans=[arr[0]]\\n            mx=ans[-1]\\n            for i in range(1,len(arr)):\\n                mx=max(arr[i], mx-1)\\n                ans.append(mx)\\n            return ans\\n        def getright(arr):\\n            ans=[arr[-1]]\\n            mx=arr[-1]\\n            for i in range(len(arr)-2,-1,-1):\\n                mx=max(arr[i],mx-1)\\n                ans.append(mx)\\n            return ans[::-1]\\n            \\n        prev=points[0]\\n        for i in range(1,m):\\n            left=getleft(prev)\\n            right=getright(prev)\\n            prev=[p+max(a,b) for a,b,p in zip(left,right,points[i])]\\n            \\n        return max(prev)",
                "solutionTags": [],
                "code": "(1) as most algo posted here, precompute the max takeout from left and right positions;\\n(2) and then add to the current row position\\n\\n```\\ndef maxPoints(self, points: List[List[int]]) -> int:\\n        m=len(points)\\n        n=len(points[0])\\n        def getleft(arr):\\n            ans=[arr[0]]\\n            mx=ans[-1]\\n            for i in range(1,len(arr)):\\n                mx=max(arr[i], mx-1)\\n                ans.append(mx)\\n            return ans\\n        def getright(arr):\\n            ans=[arr[-1]]\\n            mx=arr[-1]\\n            for i in range(len(arr)-2,-1,-1):\\n                mx=max(arr[i],mx-1)\\n                ans.append(mx)\\n            return ans[::-1]\\n            \\n        prev=points[0]\\n        for i in range(1,m):\\n            left=getleft(prev)\\n            right=getright(prev)\\n            prev=[p+max(a,b) for a,b,p in zip(left,right,points[i])]\\n            \\n        return max(prev)",
                "codeTag": "Python3"
            },
            {
                "id": 2006378,
                "title": "o-n-m-easy-c-solution-using-prefix-suffix-max-and-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    void processPreSuf(vector<long long>& dp,vector<long long>&preMax,vector<long long>&sufMax){\\n        preMax[0]=dp[0];\\n        int m=dp.size();\\n        for(int i=1;i<m;i++){\\n            if(preMax[i-1]>dp[i]){\\n                preMax[i]=preMax[i-1]-1;\\n            }else{\\n                preMax[i]=dp[i];\\n            }\\n        }\\n        sufMax[m-1]=dp[m-1];\\n        for(int i=m-2;i>=0;i--){\\n            if(sufMax[i+1]>dp[i]){\\n                sufMax[i]=sufMax[i+1]-1;\\n            }else{\\n                sufMax[i]=dp[i];\\n            }\\n        }\\n    }\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),m=points[0].size();\\n        vector<long long>dp(m),preMax(m),sufMax(m);\\n        for(int i=0;i<m;i++){\\n            dp[i]=points[0][i];\\n        }\\n        processPreSuf(dp,preMax,sufMax);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[j]=points[i][j]+max(preMax[j],sufMax[j]);\\n            }\\n            processPreSuf(dp,preMax,sufMax);\\n        }\\n        long long ans=dp[0];\\n        for(int i=1;i<m;i++){\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void processPreSuf(vector<long long>& dp,vector<long long>&preMax,vector<long long>&sufMax){\\n        preMax[0]=dp[0];\\n        int m=dp.size();\\n        for(int i=1;i<m;i++){\\n            if(preMax[i-1]>dp[i]){\\n                preMax[i]=preMax[i-1]-1;\\n            }else{\\n                preMax[i]=dp[i];\\n            }\\n        }\\n        sufMax[m-1]=dp[m-1];\\n        for(int i=m-2;i>=0;i--){\\n            if(sufMax[i+1]>dp[i]){\\n                sufMax[i]=sufMax[i+1]-1;\\n            }else{\\n                sufMax[i]=dp[i];\\n            }\\n        }\\n    }\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),m=points[0].size();\\n        vector<long long>dp(m),preMax(m),sufMax(m);\\n        for(int i=0;i<m;i++){\\n            dp[i]=points[0][i];\\n        }\\n        processPreSuf(dp,preMax,sufMax);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[j]=points[i][j]+max(preMax[j],sufMax[j]);\\n            }\\n            processPreSuf(dp,preMax,sufMax);\\n        }\\n        long long ans=dp[0];\\n        for(int i=1;i<m;i++){\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977445,
                "title": "kotlin-3-pass-dp-solution-o-m-n",
                "content": "```kotlin\\nclass Solution {\\n    fun maxPoints(points: Array<IntArray>): Long {\\n        val m = points.size\\n        val n = points[0].size\\n        val dp = LongArray(n)\\n        for(i in 0 until m) {\\n            for(j in 0 until n) {\\n                dp[j] += points[i][j].toLong()\\n            }\\n            for(j in 1 until n) {\\n                dp[j] = maxOf(dp[j], dp[j-1] - 1)\\n            }\\n            for(j in n-2 downTo 0) {\\n                dp[j] = maxOf(dp[j], dp[j+1] - 1)\\n            }\\n        }\\n        \\n        var maxPoint = 0L\\n        for(i in 0 until n) {\\n            maxPoint = maxOf(maxPoint, dp[i])\\n        }\\n        \\n        return maxPoint\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```kotlin\\nclass Solution {\\n    fun maxPoints(points: Array<IntArray>): Long {\\n        val m = points.size\\n        val n = points[0].size\\n        val dp = LongArray(n)\\n        for(i in 0 until m) {\\n            for(j in 0 until n) {\\n                dp[j] += points[i][j].toLong()\\n            }\\n            for(j in 1 until n) {\\n                dp[j] = maxOf(dp[j], dp[j-1] - 1)\\n            }\\n            for(j in n-2 downTo 0) {\\n                dp[j] = maxOf(dp[j], dp[j+1] - 1)\\n            }\\n        }\\n        \\n        var maxPoint = 0L\\n        for(i in 0 until n) {\\n            maxPoint = maxOf(maxPoint, dp[i])\\n        }\\n        \\n        return maxPoint\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965221,
                "title": "ruby-solution-o-mn",
                "content": "```\\ndef max_points(points)\\n  result = 0\\n  \\n  # start in 2nd row\\n  # replace each cell with the max value that can be passed down\\n  i = 1\\n  while i < points.length\\n    points[i].each_with_index do |num, j|\\n      points[i][j] = points[i-1].each_with_index.map{ |n, k| n + points[i][j] - (j-k).abs }.max\\n      \\n      if i == points.length - 1\\n        result = [result, points[i][j]].max\\n      end\\n    end\\n    \\n    i += 1\\n  end\\n  \\n  result\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef max_points(points)\\n  result = 0\\n  \\n  # start in 2nd row\\n  # replace each cell with the max value that can be passed down\\n  i = 1\\n  while i < points.length\\n    points[i].each_with_index do |num, j|\\n      points[i][j] = points[i-1].each_with_index.map{ |n, k| n + points[i][j] - (j-k).abs }.max\\n      \\n      if i == points.length - 1\\n        result = [result, points[i][j]].max\\n      end\\n    end\\n    \\n    i += 1\\n  end\\n  \\n  result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1958946,
                "title": "python3-analysis-of-three-different-approaches-included-brute-force",
                "content": "**Brute-force solution**: Instructive for understanding what is going on.\\n\\n```\\nclass Solution:\\n\\tdef maxPoints(self, points: List[List[int]]) -> int:\\n\\t\\t# Time: O(cols ^ rows) exponential time!\\n\\t\\t# Space: O(rows) stack space\\n\\t\\t#\\n\\t\\t# do a dfs exploration to find all paths starting from (i, j) and \\n\\t\\t# calculate maxsum downwards\\n\\t\\t#\\n\\t\\tdef dfs(i, j):\\n\\t\\t\\tif i == rows-1: return points[-1][j]\\n\\t\\t\\tmaxsum = float(\\'-inf\\')\\n\\t\\t\\tfor k in range(cols):\\n\\t\\t\\t\\tmaxsum = max(maxsum, points[i][j] + dfs(i+1, k) - abs(k - j))\\n\\t\\t\\treturn maxsum\\n\\n\\t\\t# now call dfs() on each element of the first row\\n\\t\\tmaxsum = float(\\'-inf\\')\\n\\t\\tfor j in range(cols):\\n\\t\\t\\tmaxsum = max(maxsum, dfs(0, j))\\n\\n\\t\\t# final result\\n\\t\\treturn(maxsum)\\n```\\n\\nNow that brue-force is out of our system, let\\'s try memoization. Following is a naive memoization, \\nit reduces the time cost from O(cols ^ rows) to O(rows * cols * cols). We improve from exponential\\ntime to polynomial time! Still bad and TLE.\\n\\n```\\nclass Solution:\\n\\tdef maxPoints(self, points: List[List[int]]) -> int:\\n\\t\\t# naive memoization\\n\\t\\trows, cols = len(points), len(points[0])\\n\\t\\tmemo = [0] * cols\\n\\t\\tprev = [x for x in points[0]]\\n\\n\\t\\tfor i in range(1, rows):\\n\\t\\t\\t# this represents the jth position on current row\\n\\t\\t\\tfor j in range(cols):\\n\\t\\t\\t\\tval = points[i][j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tmaxval = float(\\'-inf\\')\\n\\t\\t\\t\\t# this loop represents kth poistion on prev row\\n\\t\\t\\t\\tfor k in range(cols):\\n\\t\\t\\t\\t\\tmaxval = max(maxval, val + prev[k] - abs(k - j))\\n\\n\\t\\t\\t\\tmemo[j] = maxval\\n\\n\\t\\t\\t# now switch pointers\\n\\t\\t\\tprev, memo = memo, prev\\n\\n\\t\\t# prev represents the last row value\\n\\t\\treturn max(prev)\\n```\\n\\nThe above algorithm is O(n^3), and the j-k loop is the problem. Since, we are using maxium, \\nthere is a clever technique to break this cubic time complexity and make it O(n^2). To be \\nspecific, it will be O(rows * cols). This is the algorithm other folks have posted here on the\\ndiscussion forum. I am just pasting here to complete the analysis. Please note, **only the \\nfollowing algorithm will solve this problem** within the time limit.\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n\\t    \\'\\'\\'\\n\\t\\tTime complexitiy: O(rows * columns)\\n\\t\\tSpace complexity: O(columns)\\n\\t\\t\\'\\'\\'\\n        rows, cols = len(points), len(points[0])\\n        \\n        # three memos\\n        left = [0] * cols\\n        right = [0] * cols\\n        memo = [x for x in points[0]]\\n        \\n        for i in range(1, rows):\\n            # the following is so clever, I wish, I could\\n            # come up with it!\\n            \\n            # left sweep\\n            left[0] = memo[0]\\n            for j in range(1, cols):\\n                left[j] = max(left[j-1] - 1, memo[j])\\n            \\n            # right sweep\\n            right[-1] = memo[-1]\\n            for j in range(cols-2, -1, -1):\\n                right[j] = max(right[j+1] - 1, memo[j])\\n            \\n            # update the memo and get ready for the next\\n            # row\\n            for j in range(cols):\\n                memo[j] = points[i][j] + max(left[j], right[j])\\n            \\n        return max(memo)\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n\\tdef maxPoints(self, points: List[List[int]]) -> int:\\n\\t\\t# Time: O(cols ^ rows) exponential time!\\n\\t\\t# Space: O(rows) stack space\\n\\t\\t#\\n\\t\\t# do a dfs exploration to find all paths starting from (i, j) and \\n\\t\\t# calculate maxsum downwards\\n\\t\\t#\\n\\t\\tdef dfs(i, j):\\n\\t\\t\\tif i == rows-1: return points[-1][j]\\n\\t\\t\\tmaxsum = float(\\'-inf\\')\\n\\t\\t\\tfor k in range(cols):\\n\\t\\t\\t\\tmaxsum = max(maxsum, points[i][j] + dfs(i+1, k) - abs(k - j))\\n\\t\\t\\treturn maxsum\\n\\n\\t\\t# now call dfs() on each element of the first row\\n\\t\\tmaxsum = float(\\'-inf\\')\\n\\t\\tfor j in range(cols):\\n\\t\\t\\tmaxsum = max(maxsum, dfs(0, j))\\n\\n\\t\\t# final result\\n\\t\\treturn(maxsum)\\n```\n```\\nclass Solution:\\n\\tdef maxPoints(self, points: List[List[int]]) -> int:\\n\\t\\t# naive memoization\\n\\t\\trows, cols = len(points), len(points[0])\\n\\t\\tmemo = [0] * cols\\n\\t\\tprev = [x for x in points[0]]\\n\\n\\t\\tfor i in range(1, rows):\\n\\t\\t\\t# this represents the jth position on current row\\n\\t\\t\\tfor j in range(cols):\\n\\t\\t\\t\\tval = points[i][j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tmaxval = float(\\'-inf\\')\\n\\t\\t\\t\\t# this loop represents kth poistion on prev row\\n\\t\\t\\t\\tfor k in range(cols):\\n\\t\\t\\t\\t\\tmaxval = max(maxval, val + prev[k] - abs(k - j))\\n\\n\\t\\t\\t\\tmemo[j] = maxval\\n\\n\\t\\t\\t# now switch pointers\\n\\t\\t\\tprev, memo = memo, prev\\n\\n\\t\\t# prev represents the last row value\\n\\t\\treturn max(prev)\\n```\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n\\t    \\'\\'\\'\\n\\t\\tTime complexitiy: O(rows * columns)\\n\\t\\tSpace complexity: O(columns)\\n\\t\\t\\'\\'\\'\\n        rows, cols = len(points), len(points[0])\\n        \\n        # three memos\\n        left = [0] * cols\\n        right = [0] * cols\\n        memo = [x for x in points[0]]\\n        \\n        for i in range(1, rows):\\n            # the following is so clever, I wish, I could\\n            # come up with it!\\n            \\n            # left sweep\\n            left[0] = memo[0]\\n            for j in range(1, cols):\\n                left[j] = max(left[j-1] - 1, memo[j])\\n            \\n            # right sweep\\n            right[-1] = memo[-1]\\n            for j in range(cols-2, -1, -1):\\n                right[j] = max(right[j+1] - 1, memo[j])\\n            \\n            # update the memo and get ready for the next\\n            # row\\n            for j in range(cols):\\n                memo[j] = points[i][j] + max(left[j], right[j])\\n            \\n        return max(memo)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920600,
                "title": "python-two-pointer-solution-o-mn-time-o-n-space",
                "content": "\\n```python\\nclass Solution:\\n    def maxPoints(self, mat: List[List[int]]) -> int:\\n        M, N = len(mat), len(mat[0])\\n        \\n        points = mat[0][:]\\n        for layer in range(1, M):\\n            row = mat[layer]\\n            \\n            # Compute av_points, an arr of len(N) based on\\n            # the maximum points transferrable from previous layer\\n            av_points = [0] * N\\n            \\n            # For this, run a left pointer search then a right pointer search\\n            \\n            # left pointer search\\n            cur_best = 0\\n            for i in range(N):\\n                if points[i] > cur_best:\\n                    cur_best = points[i]\\n                \\n                av_points[i] = max(av_points[i], cur_best)\\n                \\n                cur_best -= 1 # Once we move right, the best contribution\\n                    # from the left decreases by 1\\n            \\n            # right pointer search\\n            cur_best = 0\\n            for i in range(N-1, -1, -1):\\n                if points[i] > cur_best:\\n                    cur_best = points[i]\\n                \\n                av_points[i] = max(av_points[i], cur_best)\\n                \\n                cur_best -= 1 # Once we move left, the best contribution\\n                    # from the right decreases by 1\\n            \\n            \\n            points = [av_best + elem for (av_best, elem) in zip(av_points, row)]\\n                \\n        return max(points)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxPoints(self, mat: List[List[int]]) -> int:\\n        M, N = len(mat), len(mat[0])\\n        \\n        points = mat[0][:]\\n        for layer in range(1, M):\\n            row = mat[layer]\\n            \\n            # Compute av_points, an arr of len(N) based on\\n            # the maximum points transferrable from previous layer\\n            av_points = [0] * N\\n            \\n            # For this, run a left pointer search then a right pointer search\\n            \\n            # left pointer search\\n            cur_best = 0\\n            for i in range(N):\\n                if points[i] > cur_best:\\n                    cur_best = points[i]\\n                \\n                av_points[i] = max(av_points[i], cur_best)\\n                \\n                cur_best -= 1 # Once we move right, the best contribution\\n                    # from the left decreases by 1\\n            \\n            # right pointer search\\n            cur_best = 0\\n            for i in range(N-1, -1, -1):\\n                if points[i] > cur_best:\\n                    cur_best = points[i]\\n                \\n                av_points[i] = max(av_points[i], cur_best)\\n                \\n                cur_best -= 1 # Once we move left, the best contribution\\n                    # from the right decreases by 1\\n            \\n            \\n            points = [av_best + elem for (av_best, elem) in zip(av_points, row)]\\n                \\n        return max(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895475,
                "title": "c-dp-solution-o-r-c",
                "content": "Runtime: 328 ms, faster than 72.22% of C++ online submissions for Maximum Number of Points with Cost.\\nMemory Usage: 83.7 MB, less than 81.74% of C++ online submissions for Maximum Number of Points with Cost.\\n\\n\\n```\\nCalculate the previous row max values for each position and store in DP array.\\nUpdate next row max result values in each position based on previous row DP values.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        int r = points.size();\\n        int c = points[0].size();\\n        \\n        // create 1D DP array and res array to store the\\n        // previous row relative max values in each position\\n        vector<long long>res(points[0].begin(),points[0].end());\\n        vector<long long>dp(points[0].begin(),points[0].end());\\n        \\n        for(int i=1;i<r;i++)\\n        {\\n            // running left and right max values\\n            long long left = 0;\\n            long long right = 0;\\n            \\n            for(int j=0;j<c;j++)\\n            {\\n                // get the max values among previous row updated and non-updated values\\n                // and running left and right values\\n                dp[j] = max({res[j],dp[j],left});\\n                dp[c-1-j] = max({res[c-1-j],dp[c-1-j],right});\\n                left = dp[j];\\n                right = dp[c-1-j];\\n                left--;\\n                right--;\\n            }\\n            \\n            // update current row max scores based on previous row max score for each position\\n            for(int j=0;j<c;j++)\\n            {\\n                dp[j] = dp[j] + (long long)points[i][j];\\n                res[j] = dp[j];\\n            }\\n        }\\n        \\n        // return max value from dp array at last\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nCalculate the previous row max values for each position and store in DP array.\\nUpdate next row max result values in each position based on previous row DP values.\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        \\n        int r = points.size();\\n        int c = points[0].size();\\n        \\n        // create 1D DP array and res array to store the\\n        // previous row relative max values in each position\\n        vector<long long>res(points[0].begin(),points[0].end());\\n        vector<long long>dp(points[0].begin(),points[0].end());\\n        \\n        for(int i=1;i<r;i++)\\n        {\\n            // running left and right max values\\n            long long left = 0;\\n            long long right = 0;\\n            \\n            for(int j=0;j<c;j++)\\n            {\\n                // get the max values among previous row updated and non-updated values\\n                // and running left and right values\\n                dp[j] = max({res[j],dp[j],left});\\n                dp[c-1-j] = max({res[c-1-j],dp[c-1-j],right});\\n                left = dp[j];\\n                right = dp[c-1-j];\\n                left--;\\n                right--;\\n            }\\n            \\n            // update current row max scores based on previous row max score for each position\\n            for(int j=0;j<c;j++)\\n            {\\n                dp[j] = dp[j] + (long long)points[i][j];\\n                res[j] = dp[j];\\n            }\\n        }\\n        \\n        // return max value from dp array at last\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889727,
                "title": "java-solution-with-comments-time-o-mn-space-o-n",
                "content": "The idea behind the solution is that we update our result row by row. \\nWhen we update the current row, we could use what we got from last row as input.\\nA navie solution when we update current row, we do a for loop to our last result for each position then choose the bigest value as curent. The total complexity will be n * n * m\\nA better solution is we use a leftMost array and rightMost array to gather the information from our last result, so when we update our current row, all we need to do is  make a choice of add leftMost[i] or rightMost[i]. Then this make the total time complexity from n * n * m to n * m.\\n\\nPS: When I update the leftMost array, I added the value of current number\\'s position from index 0 before I made the compare to meet the requirement. It works like we move the number from current place to index 0, so we will need to add the distance value to it before we make the comparision. So if we use leftMost array to update our final result, since the value was made as they are in the very beginning of the array, we the need to minus the current distance from it according to th requirement of this question.\\nRightMost array also works the same way with minor modifications.\\n\\n```\\nclass Solution {     \\n    public long maxPoints(int[][] points) {       \\n        long[] left = new long[points[0].length];\\n        long[] right = new long[points[0].length];\\n        long[] cur = new long[points[0].length];\\n        // Initialize the array with the value as the first line of the matrix points\\n        for(int i = 0; i < cur.length; i++) cur[i] = points[0][i];            \\n        // Update the value in our array row by row\\n        for(int i = 0; i < points.length; i++) helper(cur, left, right, points, i);        \\n        // Choose the highest value as our final result\\n        long result = 0;\\n        for(int i = 0; i < cur.length; i++) result = Math.max(result, cur[i]);   \\n        return result;\\n    }    \\n    private void helper(long[] result, long[] left, long[] right, int[][] points, int row){\\n        // We update the value in our array if it is not the first row.(first row does not need any update)\\n        if(row != 0){\\n            for(int i = 0; i < result.length; i++){  \\n                result[i] = points[row][i] + Math.max(left[i] - i, right[i] - (result.length - i - 1));\\n            }\\n        }        \\n        long max = 0;\\n        // Update the left max array, we add i to the orignal value as we move from left to right\\n        for(int i = 0; i < result.length; i++){\\n            max = Math.max(max, result[i] + i);\\n            left[i] = max;\\n        }\\n        max = 0;\\n        // Update the right max array, we add result.length - i - 1 to the orignal value as we move from right to left\\n        for(int i = result.length - 1; i >= 0; i--){\\n            max = Math.max(max, result[i] + (result.length - i - 1));\\n            right[i] = max;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {     \\n    public long maxPoints(int[][] points) {       \\n        long[] left = new long[points[0].length];\\n        long[] right = new long[points[0].length];\\n        long[] cur = new long[points[0].length];\\n        // Initialize the array with the value as the first line of the matrix points\\n        for(int i = 0; i < cur.length; i++) cur[i] = points[0][i];            \\n        // Update the value in our array row by row\\n        for(int i = 0; i < points.length; i++) helper(cur, left, right, points, i);        \\n        // Choose the highest value as our final result\\n        long result = 0;\\n        for(int i = 0; i < cur.length; i++) result = Math.max(result, cur[i]);   \\n        return result;\\n    }    \\n    private void helper(long[] result, long[] left, long[] right, int[][] points, int row){\\n        // We update the value in our array if it is not the first row.(first row does not need any update)\\n        if(row != 0){\\n            for(int i = 0; i < result.length; i++){  \\n                result[i] = points[row][i] + Math.max(left[i] - i, right[i] - (result.length - i - 1));\\n            }\\n        }        \\n        long max = 0;\\n        // Update the left max array, we add i to the orignal value as we move from left to right\\n        for(int i = 0; i < result.length; i++){\\n            max = Math.max(max, result[i] + i);\\n            left[i] = max;\\n        }\\n        max = 0;\\n        // Update the right max array, we add result.length - i - 1 to the orignal value as we move from right to left\\n        for(int i = result.length - 1; i >= 0; i--){\\n            max = Math.max(max, result[i] + (result.length - i - 1));\\n            right[i] = max;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843725,
                "title": "spent-a-whole-day-on-this-question",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if not points:\\n            return 0\\n        \\n        rows, cols = len(points), len(points[0])\\n        \\n        lmax = [0 for i in range(cols)]\\n        \\n\\n        for r in range(rows):\\n            rmax = lmax[:]\\n            temp1 = lmax[:]\\n            temp2 = temp1[:]\\n            for c in range(cols):\\n                temp1[c] = max(lmax[c], temp1[c-1]-1 if c else 0)\\n                \\n            for c in range(cols-1, -1, -1):\\n                temp2[c] = max(rmax[c], temp2[c+1]-1 if c<cols-1 else 0)\\n\\n            for c in range(cols):\\n                points[r][c] = max(temp1[c], temp2[c], points[r-1][c] if r else 0) + points[r][c] \\n            \\n            lmax = rmax = points[r]\\n                \\n        return max(lmax)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if not points:\\n            return 0\\n        \\n        rows, cols = len(points), len(points[0])\\n        \\n        lmax = [0 for i in range(cols)]\\n        \\n\\n        for r in range(rows):\\n            rmax = lmax[:]\\n            temp1 = lmax[:]\\n            temp2 = temp1[:]\\n            for c in range(cols):\\n                temp1[c] = max(lmax[c], temp1[c-1]-1 if c else 0)\\n                \\n            for c in range(cols-1, -1, -1):\\n                temp2[c] = max(rmax[c], temp2[c+1]-1 if c<cols-1 else 0)\\n\\n            for c in range(cols):\\n                points[r][c] = max(temp1[c], temp2[c], points[r-1][c] if r else 0) + points[r][c] \\n            \\n            lmax = rmax = points[r]\\n                \\n        return max(lmax)",
                "codeTag": "Java"
            },
            {
                "id": 1815269,
                "title": "java-brute-force-dp-easy-approach-tle",
                "content": "\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n          int m=points[0].length;  int n= points.length;\\n       \\n        long dp[][] = new long[points.length][points[0].length];\\n        \\n    return fun(n,m,dp,points);\\n    }\\n    \\n    static long fun(int n,int m,long dp[][],int points[][]){\\n        long Tmax=Long.MIN_VALUE;\\n        // base case for (0th) row;\\n        for(int j=0; j<m; j++){       \\n            dp[0][j]=points[0][j];}\\n        \\n            for(int i=1; i<n; i++){\\n                for(int j=0; j<m; j++){   // current row columns;\\n                    long max=0;\\n                    for(int k=0; k<m; k++){   //  prev row columns;\\n                        \\n                      long  pt= points[i][j]-Math.abs(j-k) + dp[i-1][k];\\n                        max=(long)Math.max(max,pt);\\n                    }\\n                    dp[i][j]=max;\\n                }\\n                }\\n        \\n// Tmax from all the (n-1)th row;\\n        for(int j=0; j<m; j++){\\n            Tmax= Math.max(Tmax,dp[n-1][j]);\\n        }\\n        return Tmax;\\n        }\\n}\\n",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public long maxPoints(int[][] points) {\\n          int m=points[0].length;  int n= points.length;\\n       \\n        long dp[][] = new long[points.length][points[0].length];\\n        \\n    return fun(n,m,dp,points);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1747851,
                "title": "c-bottom-top-dp-optimized-solution-easy-to-understand",
                "content": "**Intuition:**\\n\\nState of each element at points[i][j] depends on values from previous row points[i-1][j].\\n\\nTo obtain state transition function for each element in points[i][j], we need to understand all possible values added to the current value of element points[i][j] which are as below:\\n1. From same column, but one row above points \\n`points[i-1][j]`\\n2. From left side of columns from current column, but one row above (For m*n matrix)\\n`Max(points[i-1][0], points[i-1][1], points[i-1][2], .... points[i-1][j-1] `\\n3. From right side of columns from current column, but one row above (For m*n matrix)\\n`Max(points[i-1][m-1], points[i-1][m-2], points[i-1][m-3], .... points[i-1][m-j-1] `\\n\\nIn the solution below, I am maintaining 3 arrays as below:\\n1. Maintain calculated values from previous row\\n2. Start picking values from left to right\\n3. Start picking values from right to left\\n\\nTo calculate Maximum number of points with cost, below is the state transition function:\\n\\n`dp[i][j] = points[i][j] + Math.Max(left[j], right[j])`\\n \\n```\\npublic long MaxPoints(int[][] points) {\\n\\tint row = points.Length;\\n\\tint column = points[0].Length;\\n\\n\\t//Store calculation from previous row\\n\\tlong[] dp = new long[column];\\n\\n\\t//Store current row calculation when start to pick value from left to right\\n\\tlong[] left = new long[column];\\n\\tArray.Fill(left, 0);\\n\\t//Store current row calculation when start to pick value from right to left\\n\\tlong[] right = new long[column];\\n\\tArray.Fill(right, 0);\\n\\n\\t//Fill the dp array with first row of input points as it is\\n\\tfor (int i = 0; i < column; i++)\\n\\t{\\n\\t\\tdp[i] = points[0][i];\\n\\t}\\n\\n\\t//Iterate through entire points matrix to find maximum cost\\n\\t//Start iterating from 2nd row\\n\\tfor (int r = 1; r < row; r++)\\n\\t{\\n\\t\\n\\t\\t//Start iterating from left column to right column by subtracing 1 upon moving from every column from left to right\\n\\t\\tfor (int c = 0; c < column; c++)\\n\\t\\t{\\n\\t\\t\\tif (c == 0)\\n\\t\\t\\t\\tleft[c] = dp[c];\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft[c] = Math.Max(left[c-1] -1, dp[c]);\\n\\t\\t}\\n\\t\\t\\n\\t\\t//Start iterating from left column to right column by subtracing 1 upon moving from every column from left to right\\n\\t\\tfor (int c = column - 1; c >= 0; c--)\\n\\t\\t{\\n\\t\\t\\tif (c == column - 1)\\n\\t\\t\\t\\tright[c] = dp[c];\\n\\t\\t\\telse\\n\\t\\t\\t\\tright[c] = Math.Max(right[c+1] - 1, dp[c]);\\n\\t\\t}\\n\\n\\t\\t//Final calculation of dp[i][j] with picking Max value from calculated left and right for current row\\n\\t\\tfor (int c = 0; c < column; c++)\\n\\t\\t{\\n\\t\\t\\tdp[c] = points[r][c] + Math.Max(left[c], right[c]);\\n\\t\\t}\\n\\t}\\n\\treturn dp.Max();\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic long MaxPoints(int[][] points) {\\n\\tint row = points.Length;\\n\\tint column = points[0].Length;\\n\\n\\t//Store calculation from previous row\\n\\tlong[] dp = new long[column];\\n\\n\\t//Store current row calculation when start to pick value from left to right\\n\\tlong[] left = new long[column];\\n\\tArray.Fill(left, 0);\\n\\t//Store current row calculation when start to pick value from right to left\\n\\tlong[] right = new long[column];\\n\\tArray.Fill(right, 0);\\n\\n\\t//Fill the dp array with first row of input points as it is\\n\\tfor (int i = 0; i < column; i++)\\n\\t{\\n\\t\\tdp[i] = points[0][i];\\n\\t}\\n\\n\\t//Iterate through entire points matrix to find maximum cost\\n\\t//Start iterating from 2nd row\\n\\tfor (int r = 1; r < row; r++)\\n\\t{\\n\\t\\n\\t\\t//Start iterating from left column to right column by subtracing 1 upon moving from every column from left to right\\n\\t\\tfor (int c = 0; c < column; c++)\\n\\t\\t{\\n\\t\\t\\tif (c == 0)\\n\\t\\t\\t\\tleft[c] = dp[c];\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft[c] = Math.Max(left[c-1] -1, dp[c]);\\n\\t\\t}\\n\\t\\t\\n\\t\\t//Start iterating from left column to right column by subtracing 1 upon moving from every column from left to right\\n\\t\\tfor (int c = column - 1; c >= 0; c--)\\n\\t\\t{\\n\\t\\t\\tif (c == column - 1)\\n\\t\\t\\t\\tright[c] = dp[c];\\n\\t\\t\\telse\\n\\t\\t\\t\\tright[c] = Math.Max(right[c+1] - 1, dp[c]);\\n\\t\\t}\\n\\n\\t\\t//Final calculation of dp[i][j] with picking Max value from calculated left and right for current row\\n\\t\\tfor (int c = 0; c < column; c++)\\n\\t\\t{\\n\\t\\t\\tdp[c] = points[r][c] + Math.Max(left[c], right[c]);\\n\\t\\t}\\n\\t}\\n\\treturn dp.Max();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737455,
                "title": "python-solution-failing-on-time-limit-but-it-is-dp",
                "content": "Hi - Can someone help me understand why I am exceeding the time limit? This is a DP solution and passes most of the tests. \\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        M = len(points)\\n        N = len(points[0])\\n        dp = [[0]*N for _ in range(M)]\\n        \\n        for i in range(N):\\n            dp[0][i] = points[0][i]\\n            \\n        for i in range(1, M):\\n            rollingMax = float(\\'-inf\\')\\n            for j in range(N):\\n                rollingMax = max(rollingMax, dp[i-1][j] + j)\\n                dp[i][j] = points[i][j] + rollingMax - j\\n                \\n            rollingMax = float(\\'-inf\\')\\n            for j in range(N-1, -1, -1):\\n                rollingMax = max(rollingMax, dp[i-1][j] - j)\\n                dp[i][j] = max(dp[i][j], points[i][j] + rollingMax + j)\\n            \\n        \\n        return max(dp[M-1])\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        M = len(points)\\n        N = len(points[0])\\n        dp = [[0]*N for _ in range(M)]\\n        \\n        for i in range(N):\\n            dp[0][i] = points[0][i]\\n            \\n        for i in range(1, M):\\n            rollingMax = float(\\'-inf\\')\\n            for j in range(N):\\n                rollingMax = max(rollingMax, dp[i-1][j] + j)\\n                dp[i][j] = points[i][j] + rollingMax - j\\n                \\n            rollingMax = float(\\'-inf\\')\\n            for j in range(N-1, -1, -1):\\n                rollingMax = max(rollingMax, dp[i-1][j] - j)\\n                dp[i][j] = max(dp[i][j], points[i][j] + rollingMax + j)\\n            \\n        \\n        return max(dp[M-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673645,
                "title": "c-beginner-friendly-explanation-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /* Idea : \\n     * Left -> right\\n     * dp[i][j] = points[i][j] + points[i-1][k] - (j-k)        (k<=j and k is index on the left side of dp[i][j] in previous row k = 0...j)\\n     * this equation can be written as \\n     * dp[i][j] = points[i][j] - j + points[i-1][k] + k  \\n     *\\n     * Similarly when k>=j and k is index on the right side of dp[i][j] in previous row k = j.....m\\n     */\\n    long long maxPoints(vector<vector<int>>& points) {\\n        long long n = points.size();\\n        long long m = points[0].size();\\n        \\n        vector<vector<long long>> dp(n, vector<long long> (m, INT_MIN));\\n        for(int i=0;i<m;i++){\\n            dp[0][i] = points[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            long long val1 = INT_MIN;\\n            long long val2 = INT_MIN;\\n            // left to right (checking for the max points that can be obtained using only left side values)\\n            for(int j=0;j<m;j++){\\n                if(dp[i-1][j] + j > val1){\\n                    val1 = dp[i-1][j] + j;\\n                }\\n                if(points[i][j] - j + val1 > dp[i][j]){\\n                    dp[i][j] = points[i][j] - j + val1;\\n                }\\n                \\n            }\\n            // right to left (checking for the max points that can be obtained using only right side values) and updating the dp array\\n            for(int j=m-1;j>=0;j--){\\n                if(dp[i-1][j] - j > val2){\\n                    val2 = dp[i-1][j] - j;\\n                }\\n                if(points[i][j] + j + val2 > dp[i][j]){\\n                    dp[i][j] = points[i][j] + j + val2;\\n                }\\n                \\n            }\\n        }\\n        long long ans = INT_MIN;\\n        // Iterating last row of DP array for getting the largest possible value \\n        for(int i=0;i<m;i++){\\n            if(dp[n-1][i] > ans){\\n                ans = dp[n-1][i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /* Idea : \\n     * Left -> right\\n     * dp[i][j] = points[i][j] + points[i-1][k] - (j-k)        (k<=j and k is index on the left side of dp[i][j] in previous row k = 0...j)\\n     * this equation can be written as \\n     * dp[i][j] = points[i][j] - j + points[i-1][k] + k  \\n     *\\n     * Similarly when k>=j and k is index on the right side of dp[i][j] in previous row k = j.....m\\n     */\\n    long long maxPoints(vector<vector<int>>& points) {\\n        long long n = points.size();\\n        long long m = points[0].size();\\n        \\n        vector<vector<long long>> dp(n, vector<long long> (m, INT_MIN));\\n        for(int i=0;i<m;i++){\\n            dp[0][i] = points[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            long long val1 = INT_MIN;\\n            long long val2 = INT_MIN;\\n            // left to right (checking for the max points that can be obtained using only left side values)\\n            for(int j=0;j<m;j++){\\n                if(dp[i-1][j] + j > val1){\\n                    val1 = dp[i-1][j] + j;\\n                }\\n                if(points[i][j] - j + val1 > dp[i][j]){\\n                    dp[i][j] = points[i][j] - j + val1;\\n                }\\n                \\n            }\\n            // right to left (checking for the max points that can be obtained using only right side values) and updating the dp array\\n            for(int j=m-1;j>=0;j--){\\n                if(dp[i-1][j] - j > val2){\\n                    val2 = dp[i-1][j] - j;\\n                }\\n                if(points[i][j] + j + val2 > dp[i][j]){\\n                    dp[i][j] = points[i][j] + j + val2;\\n                }\\n                \\n            }\\n        }\\n        long long ans = INT_MIN;\\n        // Iterating last row of DP array for getting the largest possible value \\n        for(int i=0;i<m;i++){\\n            if(dp[n-1][i] > ans){\\n                ans = dp[n-1][i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595970,
                "title": "why-tle-on-top-down-recursion-memoization",
                "content": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        return dfs(points, 0, -1, new HashMap<>());\\n    }\\n    \\n    private int dfs(int[][] points, int i, int prevj, Map<String, Integer> memo){\\n        if(memo.containsKey(i + \":\" + prevj)){\\n            return memo.get(i + \":\" + prevj);\\n        }\\n        \\n        if(i == points.length){\\n            return 0;\\n        }\\n        \\n        if(i == points.length - 1){\\n            int res = Integer.MIN_VALUE;\\n            for(int k=0; k<points[0].length; k++){\\n                res = Math.max(res, points[i][k] - (prevj == - 1 ? 0 : Math.abs(k - prevj)));\\n            }\\n            \\n            memo.put(i + \":\" + prevj, res);\\n            return res;\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        for(int k=0; k<points[i].length; k++){\\n            res = Math.max(res, points[i][k] + dfs(points, i + 1, k, memo) - (prevj == - 1 ? 0 : Math.abs(k - prevj)));\\n        }\\n        \\n        memo.put(i + \":\" + prevj, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        return dfs(points, 0, -1, new HashMap<>());\\n    }\\n    \\n    private int dfs(int[][] points, int i, int prevj, Map<String, Integer> memo){\\n        if(memo.containsKey(i + \":\" + prevj)){\\n            return memo.get(i + \":\" + prevj);\\n        }\\n        \\n        if(i == points.length){\\n            return 0;\\n        }\\n        \\n        if(i == points.length - 1){\\n            int res = Integer.MIN_VALUE;\\n            for(int k=0; k<points[0].length; k++){\\n                res = Math.max(res, points[i][k] - (prevj == - 1 ? 0 : Math.abs(k - prevj)));\\n            }\\n            \\n            memo.put(i + \":\" + prevj, res);\\n            return res;\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        for(int k=0; k<points[i].length; k++){\\n            res = Math.max(res, points[i][k] + dfs(points, i + 1, k, memo) - (prevj == - 1 ? 0 : Math.abs(k - prevj)));\\n        }\\n        \\n        memo.put(i + \":\" + prevj, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567183,
                "title": "python3-easy-dp-method-with-thorough-explanation",
                "content": "Two things about how to solve this:\\n\\n1) Need to split this into two different problems, memoization from the left side and memoization from the right side. Do them separately otherwise it\\'s too complicated.\\n2) in the code below, the \"left\" array will calculate the maximum path from the left side. If you want the maximum value for cell (i, j), it\\'s either the cell directly above you, that is (i - 1, j), or it\\'s **the entry in left directly left of you, minus 1**.  The one to the left in the array is simply the maximum value of either what is above it, or to its left in the left array. This is where the memoization occurs. So since we know that will be the maximum for that cell, for the current cell, we consider that less one or the cell above it, which has no penalty, there minus 0.\\n3) Now go from the right direction, and it\\'s the opposite. Either the max value is the cell above you, or the entry to the right of you in the \"right\" array minus 1.\\n4) Now, calculate the maximum for each cell in that row by adding the max of the right array and the left array, plus the current contents in the cell (i, j)\\n5) Once you\\'re done, just get the maximum of the last row.\\n\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        M = len(points)\\n        N = len(points[0])\\n        \\n        for i in range(1,M):\\n            left = [points[i - 1][0]] * N\\n            for j in range(1, N):\\n                left[j] = max(points[i - 1][j], left[j - 1] - 1)\\n                    \\n            right = [points[i-1][N -1]] * N\\n            for j in range(N - 1)[::-1]:\\n                right[j] = max(points[i - 1][j], right[j + 1] - 1)\\n                    \\n            for j in range(N):\\n                points[i][j] += max(left[j], right[j])\\n                    \\n        return max(points[M - 1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        M = len(points)\\n        N = len(points[0])\\n        \\n        for i in range(1,M):\\n            left = [points[i - 1][0]] * N\\n            for j in range(1, N):\\n                left[j] = max(points[i - 1][j], left[j - 1] - 1)\\n                    \\n            right = [points[i-1][N -1]] * N\\n            for j in range(N - 1)[::-1]:\\n                right[j] = max(points[i - 1][j], right[j + 1] - 1)\\n                    \\n            for j in range(N):\\n                points[i][j] += max(left[j], right[j])\\n                    \\n        return max(points[M - 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541201,
                "title": "easy-to-understand-java-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        \\n        int m = points.length;\\n        int n = points[0].length;\\n        \\n        long previous[] = new long[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            previous[i] = points[0][i];\\n        }\\n        \\n        for(int i = 1; i < m; i++){\\n            \\n            long left[] = new long[n];\\n            long right[] = new long[n];\\n            long current[] = new long[n];\\n            \\n            left[0] = previous[0];\\n            right[n-1] = previous[n-1];\\n            \\n            for(int j = 1; j < n; j++){\\n                left[j] = Math.max(left[j-1] - 1, previous[j]);  \\n            }\\n            \\n            for(int j = n - 2; j >= 0; j--){\\n                right[j] = Math.max(right[j+1] - 1, previous[j]);\\n            }\\n            \\n            for(int j = 0; j < n; j++){\\n                current[j] = Math.max(left[j], right[j]) + points[i][j];\\n            }\\n\\n            previous = current;\\n        }\\n        \\n        long max = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            max = Math.max(max, previous[i]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        \\n        int m = points.length;\\n        int n = points[0].length;\\n        \\n        long previous[] = new long[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            previous[i] = points[0][i];\\n        }\\n        \\n        for(int i = 1; i < m; i++){\\n            \\n            long left[] = new long[n];\\n            long right[] = new long[n];\\n            long current[] = new long[n];\\n            \\n            left[0] = previous[0];\\n            right[n-1] = previous[n-1];\\n            \\n            for(int j = 1; j < n; j++){\\n                left[j] = Math.max(left[j-1] - 1, previous[j]);  \\n            }\\n            \\n            for(int j = n - 2; j >= 0; j--){\\n                right[j] = Math.max(right[j+1] - 1, previous[j]);\\n            }\\n            \\n            for(int j = 0; j < n; j++){\\n                current[j] = Math.max(left[j], right[j]) + points[i][j];\\n            }\\n\\n            previous = current;\\n        }\\n        \\n        long max = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            max = Math.max(max, previous[i]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469966,
                "title": "python-o-m-n-time-o-n-space-solution",
                "content": "```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m = len(points)\\n        if m == 1:\\n            return max(points[-1])\\n        n = len(points[0])\\n        results = [i for i in points[-1]]\\n        for j in range(m-2, -1, -1):\\n            left = [0 for _ in range(n)]\\n            left[0] = results[0]\\n            for i in range(1,n,1):\\n                left[i] = max(results[i], left[i-1] - 1)\\n            right = [0 for _ in range(n)]\\n            right[-1] = results[-1]\\n            for i in range(n-2, -1, -1):\\n                right[i] = max(results[i], right[i+1] - 1)\\n            for i in range(n):\\n                results[i] = points[j][i] + max(left[i], right[i])\\n                \\n                \\n        return max(results)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m = len(points)\\n        if m == 1:\\n            return max(points[-1])\\n        n = len(points[0])\\n        results = [i for i in points[-1]]\\n        for j in range(m-2, -1, -1):\\n            left = [0 for _ in range(n)]\\n            left[0] = results[0]\\n            for i in range(1,n,1):\\n                left[i] = max(results[i], left[i-1] - 1)\\n            right = [0 for _ in range(n)]\\n            right[-1] = results[-1]\\n            for i in range(n-2, -1, -1):\\n                right[i] = max(results[i], right[i+1] - 1)\\n            for i in range(n):\\n                results[i] = points[j][i] + max(left[i], right[i])\\n                \\n                \\n        return max(results)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461735,
                "title": "c-13lines-o-m-n-dp-with-space-optimization",
                "content": "**Solution**\\n\\nThe basic idea is to use dp solution.\\n\\nwe use arrays `l2r` (left to righ) and `r2l` (right to left) to record **the maximal value** we can get in previous row. Then, we use it to add the point above it. We process all points front bottom to top.\\n\\n**Code**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int m = points.size(), n = points[0].size();\\n        vector<long long> dp(n, 0);\\n        \\n        long long ans = 0;\\n        for(int i = m - 1; i >= 0; i--) {\\n            vector<long long> l2r(n), r2l(n);\\n            l2r[0] = dp[0], r2l[n - 1] = dp[n - 1];\\n            for(int j = 1; j < n; j++) {\\n                l2r[j] = max(l2r[j - 1] - 1, dp[j]);\\n                r2l[n - 1 - j] = max(r2l[n - j] - 1, dp[n - 1 - j]);\\n            }\\n            for(int j = 0; j < n; j++) \\n                dp[j] = points[i][j] + max(l2r[j], r2l[j]);\\n        }\\n        \\n        for(int j = 0; j < n; j++)\\n            ans = max(ans, dp[j]);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Optimized Space Solution**\\n\\nWe can optimize its space by removing temporary arrays (`l2r` and `r2l`), and allow all operations in `dp` array.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int m = points.size(), n = points[0].size();\\n        vector<long long> dp(n, 0);\\n        for(int i = m - 1; i >= 0; i--) {\\n            for(int j = 1; j < n; j++) {\\n                dp[j] = max(dp[j - 1] - 1, dp[j]);\\n                dp[n - 1 - j] = max(dp[n - j] - 1, dp[n - 1 - j]);\\n            }\\n            for(int j = 0; j < n; j++) \\n                dp[j] += points[i][j];\\n        }\\n        long long ans = 0;\\n        for(int j = 0; j < n; j++)\\n            ans = max(ans, dp[j]);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Complexity**\\n\\nTime complexity: O(m * n)\\n\\nSpace complexity: O(n)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int m = points.size(), n = points[0].size();\\n        vector<long long> dp(n, 0);\\n        \\n        long long ans = 0;\\n        for(int i = m - 1; i >= 0; i--) {\\n            vector<long long> l2r(n), r2l(n);\\n            l2r[0] = dp[0], r2l[n - 1] = dp[n - 1];\\n            for(int j = 1; j < n; j++) {\\n                l2r[j] = max(l2r[j - 1] - 1, dp[j]);\\n                r2l[n - 1 - j] = max(r2l[n - j] - 1, dp[n - 1 - j]);\\n            }\\n            for(int j = 0; j < n; j++) \\n                dp[j] = points[i][j] + max(l2r[j], r2l[j]);\\n        }\\n        \\n        for(int j = 0; j < n; j++)\\n            ans = max(ans, dp[j]);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int m = points.size(), n = points[0].size();\\n        vector<long long> dp(n, 0);\\n        for(int i = m - 1; i >= 0; i--) {\\n            for(int j = 1; j < n; j++) {\\n                dp[j] = max(dp[j - 1] - 1, dp[j]);\\n                dp[n - 1 - j] = max(dp[n - j] - 1, dp[n - 1 - j]);\\n            }\\n            for(int j = 0; j < n; j++) \\n                dp[j] += points[i][j];\\n        }\\n        long long ans = 0;\\n        for(int j = 0; j < n; j++)\\n            ans = max(ans, dp[j]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459148,
                "title": "c-o-m-n-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int rows = points.size();\\n        int cols = points[0].size();\\n        vector<long long>p;\\n        vector<long long>q(points[0].size());\\n        vector<long long>left(points[0].size());\\n        vector<long long>right(points[0].size());\\n        int i, j;\\n        for(i = 0; i < cols; i++){\\n            p.push_back(points[0][i]);\\n        }\\n        for(i = 1; i < rows; i++){\\n            left[0] = p[0];\\n            for(j = 1; j < cols; j++){\\n                left[j] = max(left[j - 1] - 1, p[j]);\\n            }\\n            right[cols - 1] = p[cols - 1];\\n            for(j = cols - 2; j >= 0; j--){\\n                right[j] = max(right[j + 1] - 1, p[j]);\\n            } \\n            for(j = 0; j < cols; j++){\\n                q[j] = points[i][j] + max(left[j], right[j]);\\n            }\\n            p = q;\\n        }\\n        return *max_element(p.begin(), p.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int rows = points.size();\\n        int cols = points[0].size();\\n        vector<long long>p;\\n        vector<long long>q(points[0].size());\\n        vector<long long>left(points[0].size());\\n        vector<long long>right(points[0].size());\\n        int i, j;\\n        for(i = 0; i < cols; i++){\\n            p.push_back(points[0][i]);\\n        }\\n        for(i = 1; i < rows; i++){\\n            left[0] = p[0];\\n            for(j = 1; j < cols; j++){\\n                left[j] = max(left[j - 1] - 1, p[j]);\\n            }\\n            right[cols - 1] = p[cols - 1];\\n            for(j = cols - 2; j >= 0; j--){\\n                right[j] = max(right[j + 1] - 1, p[j]);\\n            } \\n            for(j = 0; j < cols; j++){\\n                q[j] = points[i][j] + max(left[j], right[j]);\\n            }\\n            p = q;\\n        }\\n        return *max_element(p.begin(), p.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415266,
                "title": "python-o-m-n-solution-using-dp",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        for i in range(1,len(points)):\\n            left, right = self.left(points[i-1]), self.right(points[i-1])\\n            for j in range(len(points[0])):\\n                points[i][j] = max(left[j],right[j]) + points[i][j]\\n        return max(points[-1])\\n    \\n    def left(self,lst):\\n        cur = [lst[0]] + [0] * (len(lst)-1)\\n        for i in range(1, len(lst)):\\n            cur[i] = max(lst[i], cur[i-1]-1)\\n        return cur\\n    \\n    def right(self,lst):\\n        cur = [0] * (len(lst) - 1) + [lst[-1]]\\n        for i in range(len(lst)-2, -1, -1):\\n            cur[i] = max(lst[i], cur[i+1]-1)\\n        return cur\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        for i in range(1,len(points)):\\n            left, right = self.left(points[i-1]), self.right(points[i-1])\\n            for j in range(len(points[0])):\\n                points[i][j] = max(left[j],right[j]) + points[i][j]\\n        return max(points[-1])\\n    \\n    def left(self,lst):\\n        cur = [lst[0]] + [0] * (len(lst)-1)\\n        for i in range(1, len(lst)):\\n            cur[i] = max(lst[i], cur[i-1]-1)\\n        return cur\\n    \\n    def right(self,lst):\\n        cur = [0] * (len(lst) - 1) + [lst[-1]]\\n        for i in range(len(lst)-2, -1, -1):\\n            cur[i] = max(lst[i], cur[i+1]-1)\\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350055,
                "title": "java-neat-solution-time-o-m-n-memory-o-n",
                "content": "```\\npublic long maxPoints(int[][] points) {\\n        long[] dp = new long[points[0].length];\\n        long[] leftMax   = new long [dp.length];\\n        long[] rightMax = new long [dp.length];\\n        \\n        for(int i = 0; i<points.length; i++){\\n            leftMax[0] = dp[0];\\n            for(int j = 1; j<dp.length; j++){\\n                leftMax[j] = Math.max(leftMax[j-1], dp[j]+j);\\n            }\\n            \\n            rightMax[dp.length-1] = dp[dp.length-1]-dp.length+1 ;\\n            for(int j = points[0].length-2; j>=0; j--){\\n                rightMax[j] = Math.max(rightMax[j+1], dp[j]-j);   \\n            }\\n            \\n            for(int j = 0; j<dp.length; j++){\\n                dp[j] = points[i][j] +  Math.max(leftMax[j]-j, rightMax[j]+j);\\n            }\\n        }\\n        \\n        long max = Long.MIN_VALUE;\\n        for(int i=0; i<dp.length; i++){\\n            max = Math.max(max, dp[i]);\\n        }\\n        \\n        return max;   \\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic long maxPoints(int[][] points) {\\n        long[] dp = new long[points[0].length];\\n        long[] leftMax   = new long [dp.length];\\n        long[] rightMax = new long [dp.length];\\n        \\n        for(int i = 0; i<points.length; i++){\\n            leftMax[0] = dp[0];\\n            for(int j = 1; j<dp.length; j++){\\n                leftMax[j] = Math.max(leftMax[j-1], dp[j]+j);\\n            }\\n            \\n            rightMax[dp.length-1] = dp[dp.length-1]-dp.length+1 ;\\n            for(int j = points[0].length-2; j>=0; j--){\\n                rightMax[j] = Math.max(rightMax[j+1], dp[j]-j);   \\n            }\\n            \\n            for(int j = 0; j<dp.length; j++){\\n                dp[j] = points[i][j] +  Math.max(leftMax[j]-j, rightMax[j]+j);\\n            }\\n        }\\n        \\n        long max = Long.MIN_VALUE;\\n        for(int i=0; i<dp.length; i++){\\n            max = Math.max(max, dp[i]);\\n        }\\n        \\n        return max;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1349329,
                "title": "javascript-solution",
                "content": "This algorithm will first find the largest possible in a row after doing the column subtraction, then add the values in the next row.\\n\\nFor example, let\\'s say our example starts with:\\n```\\n[\\n  [1,2,100,2,1],\\n  ...\\n]\\n```\\n\\nAfter going through our first row, we will simply get `[98,99,100,99,98]`. Each of this element will be added into the next row.\\n\\n```javascript\\nvar maxPoints = function (points) {\\n  const accRow = points[0].map((_d) => 0);\\n  points.forEach((row, ri) => {\\n    row.forEach((c, i) => {\\n      accRow[i] += c;\\n    });\\n\\n    accRow.forEach((c, i) => {\\n      if (i === 0) {\\n        return;\\n      }\\n\\n      accRow[i] = Math.max(accRow[i], accRow[i - 1] - 1);\\n    });\\n\\n    accRow.forEach((c, i) => {\\n      if (i === 0) {\\n        // ignores the last one\\n        return;\\n      }\\n\\n      const backIndex = accRow.length - i - 1;\\n      accRow[backIndex] = Math.max(\\n        accRow[backIndex],\\n        accRow[backIndex + 1] - 1\\n      );\\n    });\\n  });\\n\\n  return Math.max(...accRow);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[\\n  [1,2,100,2,1],\\n  ...\\n]\\n```\n```javascript\\nvar maxPoints = function (points) {\\n  const accRow = points[0].map((_d) => 0);\\n  points.forEach((row, ri) => {\\n    row.forEach((c, i) => {\\n      accRow[i] += c;\\n    });\\n\\n    accRow.forEach((c, i) => {\\n      if (i === 0) {\\n        return;\\n      }\\n\\n      accRow[i] = Math.max(accRow[i], accRow[i - 1] - 1);\\n    });\\n\\n    accRow.forEach((c, i) => {\\n      if (i === 0) {\\n        // ignores the last one\\n        return;\\n      }\\n\\n      const backIndex = accRow.length - i - 1;\\n      accRow[backIndex] = Math.max(\\n        accRow[backIndex],\\n        accRow[backIndex + 1] - 1\\n      );\\n    });\\n  });\\n\\n  return Math.max(...accRow);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348321,
                "title": "javascript-time-o-n-m-finding-max-of-left-prefix-right-suffix",
                "content": "Basic Intuition for the below approach is gained from: https://leetcode.com/problems/maximum-number-of-points-with-cost/discuss/1344908/Python-3-DP-Explanation-with-pictures.\\n\\nAfter going through the intuition I could gather a pattern of sorts.\\n* So for every cell except for the first row we need to find the max points accumulated taking that cell.\\n* For finding the max points we need to find a perfect cell from prev row which accounts for max \\n* As traversing the whole row takes O(N) and increases time complexity so need to find a other way\\n* After observation we see that for` points[row][col]` the result will be from either LEFT SIDE - `Math.max( points[row-1][0] - ( col - 0 ), points[row-1][1] - (col - 1) .... points[row-1][col] - (col - col))`  or  RIGHT SIDE -  `Math.max( points[row-1][n-1] - ( n - 1 - col ),  points[row - 1][n-2] - ( n - 2 - col) .... points[row - 1][col] - (col - col) )`\\n* Above equation may look messy and overwhelming but putting that into a whiteboard with an example will clear things up better\\n* Now generalising the above equation for left side we get `Math.max( points[row-1][j] - (col - j)....points[row-1][col] - (col - col) )`  to `Math.max( points[row-1][j] + j ...... points[ row-1][col] + col ) - col` by taking `col` outside as col is common\\n* Similar can be done for Right side \\n* Above equation can be before calculating for each row from previous row\\n\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar maxPoints = function(points) {\\n    let m = points.length, n = points[0].length;\\n    let dp = Array(m).fill(0).map(_=>Array(n).fill(0));\\n    \\n    for(let j = 0;j<n;j++){\\n        dp[0][j] = points[0][j];\\n    }\\n    \\n    for(let row = 1;row < m; row++){\\n        \\n        let left = Array(n).fill(0), right = Array(n).fill(0), prev = -Infinity;\\n        \\n        for(let j = 0; j < n; j++){\\n            left[j] = Math.max(dp[row-1][j] + j, prev);\\n            prev = left[j];\\n        }\\n        prev = -Infinity;\\n        for(let j = n-1; j>=0 ; j--){\\n            right[j] = Math.max(dp[row-1][j] -j, prev);\\n            prev = right[j];\\n        }\\n        \\n\\t\\t//As we have to subtract \\'col\\' taken common from equation for left and add \\'col\\' for right side\\n        for(let col = 0; col< n; col++){\\n            dp[row][col] = points[row][col] + Math.max(left[col] - col, right[col] + col);\\n        }\\n    }\\n    \\n    \\n    return Math.max(...dp[m-1])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar maxPoints = function(points) {\\n    let m = points.length, n = points[0].length;\\n    let dp = Array(m).fill(0).map(_=>Array(n).fill(0));\\n    \\n    for(let j = 0;j<n;j++){\\n        dp[0][j] = points[0][j];\\n    }\\n    \\n    for(let row = 1;row < m; row++){\\n        \\n        let left = Array(n).fill(0), right = Array(n).fill(0), prev = -Infinity;\\n        \\n        for(let j = 0; j < n; j++){\\n            left[j] = Math.max(dp[row-1][j] + j, prev);\\n            prev = left[j];\\n        }\\n        prev = -Infinity;\\n        for(let j = n-1; j>=0 ; j--){\\n            right[j] = Math.max(dp[row-1][j] -j, prev);\\n            prev = right[j];\\n        }\\n        \\n\\t\\t//As we have to subtract \\'col\\' taken common from equation for left and add \\'col\\' for right side\\n        for(let col = 0; col< n; col++){\\n            dp[row][col] = points[row][col] + Math.max(left[col] - col, right[col] + col);\\n        }\\n    }\\n    \\n    \\n    return Math.max(...dp[m-1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347989,
                "title": "votrubac-method-in-3-pass-o-nm-code-comments-without-explanation",
                "content": "```\\n# https://leetcode.com/problems/maximum-number-of-points-with-cost/discuss/1344893/Similar-to-931.-Minimum-Falling-Path-Sum\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        # current row depends on previous row\\n        # for each element in current row\\n        # take the max cost of the previous - abs col difference \\n        # and add it to the current position (change / increment)\\n        n, m = len(points), len(points[0])\\n        \\n        for r in range(1, n):\\n            # votrubac, two pass leftmax and rightmax \\n            runningMax = 0\\n            leftChange = [0]*m\\n            for c in range(m):\\n                # new abs() == 0, prev -1 (coz distance increased)\\n                runningMax = max(runningMax-1, points[r-1][c]) \\n                leftChange[c] = runningMax\\n            \\n            runningMax = 0\\n            rightChange = [0]*m\\n            for c in range(m-1,-1,-1):\\n                runningMax = max(runningMax-1, points[r-1][c]) \\n                rightChange[c] = runningMax\\n                \\n            for c in range(m):\\n                points[r][c] += max(leftChange[c], rightChange[c])\\n        \\n        return max(points[-1])\\n    \\n\"\"\"\\nImportant Test Cases\\n\\n[[1,2,3],[1,5,1],[3,1,1]]\\n[[1,5],[2,3],[4,2]]\\n[[0,3,0,4,2],[5,4,2,4,1],[5,0,0,5,1],[2,0,1,0,3]]\\n\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# https://leetcode.com/problems/maximum-number-of-points-with-cost/discuss/1344893/Similar-to-931.-Minimum-Falling-Path-Sum\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        # current row depends on previous row\\n        # for each element in current row\\n        # take the max cost of the previous - abs col difference \\n        # and add it to the current position (change / increment)\\n        n, m = len(points), len(points[0])\\n        \\n        for r in range(1, n):\\n            # votrubac, two pass leftmax and rightmax \\n            runningMax = 0\\n            leftChange = [0]*m\\n            for c in range(m):\\n                # new abs() == 0, prev -1 (coz distance increased)\\n                runningMax = max(runningMax-1, points[r-1][c]) \\n                leftChange[c] = runningMax\\n            \\n            runningMax = 0\\n            rightChange = [0]*m\\n            for c in range(m-1,-1,-1):\\n                runningMax = max(runningMax-1, points[r-1][c]) \\n                rightChange[c] = runningMax\\n                \\n            for c in range(m):\\n                points[r][c] += max(leftChange[c], rightChange[c])\\n        \\n        return max(points[-1])\\n    \\n\"\"\"\\nImportant Test Cases\\n\\n[[1,2,3],[1,5,1],[3,1,1]]\\n[[1,5],[2,3],[4,2]]\\n[[0,3,0,4,2],[5,4,2,4,1],[5,0,0,5,1],[2,0,1,0,3]]\\n\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346409,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m = points.length;\\n        int n = points[0].length;\\n        long[][] dp = new long[m][n];\\n        long result = 0;\\n        \\n        for(int i =0; i<m;i++){\\n            long[] left = new long[n];\\n            long[] right = new long[n];\\n            if(i>0){\\n\\n                left[0] = dp[i-1][0];\\n                for(int j =1; j<n;j++){\\n                    left[j] = Math.max(left[j-1]-1,dp[i-1][j]);\\n                }\\n                right[n-1] =dp[i-1][n-1];\\n                for(int j =n-2;j>-1;j--){\\n                    right[j] = Math.max(right[j+1]-1,dp[i-1][j]);\\n                }\\n            }\\n            for(int j =0; j<n;j++){\\n                dp[i][j] = Math.max(left[j],right[j])+points[i][j];\\n                if(i==m-1) result = Math.max(dp[i][j],result);\\n            }\\n            \\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m = points.length;\\n        int n = points[0].length;\\n        long[][] dp = new long[m][n];\\n        long result = 0;\\n        \\n        for(int i =0; i<m;i++){\\n            long[] left = new long[n];\\n            long[] right = new long[n];\\n            if(i>0){\\n\\n                left[0] = dp[i-1][0];\\n                for(int j =1; j<n;j++){\\n                    left[j] = Math.max(left[j-1]-1,dp[i-1][j]);\\n                }\\n                right[n-1] =dp[i-1][n-1];\\n                for(int j =n-2;j>-1;j--){\\n                    right[j] = Math.max(right[j+1]-1,dp[i-1][j]);\\n                }\\n            }\\n            for(int j =0; j<n;j++){\\n                dp[i][j] = Math.max(left[j],right[j])+points[i][j];\\n                if(i==m-1) result = Math.max(dp[i][j],result);\\n            }\\n            \\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346338,
                "title": "python-3-priority-queue-o-m-n-log-n",
                "content": "For each previous row, we kept two priority queues ```left``` and ```right``` to indicate any numbers before or after current column.\\nFor left queue, the maximum is ```p[row][A] + p[row-1][B] - (A - B)``` which we need to maximize ``` p[row-1][B] + B```\\nFor right queue, the maximum is ```p[row][A] + p[row-1][B] - (B - A)``` which we need to maximize ``` p[row-1][B] - B```\\n\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        \\n        for i in range(1, m):\\n            right = []\\n            for j, x in enumerate(points[i-1]):\\n                heappush(right, (-(x - j), j))\\n            left = []\\n            for j in range(n):\\n                tmp = points[i][j] + points[i-1][j]\\n                while right and j >= right[0][1]:\\n                    heappop(right)\\n\\n                if j > 0:\\n                    heappush(left, (-points[i-1][j-1] - (j-1), j-1))\\n                if right:\\n                    tmp = max(tmp, points[i][j] + j - right[0][0])\\n                if left:\\n                    tmp = max(tmp, points[i][j] - j - left[0][0])\\n                points[i][j] = tmp\\n\\n        return max(points[-1])",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```left```\n```right```\n```p[row][A] + p[row-1][B] - (A - B)```\n``` p[row-1][B] + B```\n```p[row][A] + p[row-1][B] - (B - A)```\n``` p[row-1][B] - B```",
                "codeTag": "Unknown"
            },
            {
                "id": 1346269,
                "title": "very-easy-ntutive-c-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        int m = p[0].size();\\n        \\n        vector<vector<ll>>dp(n , vector<ll>(m,0));\\n        \\n        for(int i = 0 ; i < m;i++)\\n            dp[0][i] = p[0][i];\\n        \\n        // iterate from the second row \\n        \\n        for(int i = 1 ; i < n ;i++)\\n        {\\n             // create a leftmax and rightmax pointer\\n             ll leftmax = 0 ; \\n            // left traversal\\n            for(int j = 0 ; j < m ;j++)\\n            {\\n                leftmax = max(leftmax - 1 , dp[i-1][j]);\\n                dp[i][j] = p[i][j] + leftmax;\\n            }\\n            ll rightmax = 0 ;\\n            // right traversal\\n            \\n            for(int j = m-1;j>=0;j--)\\n            {\\n                rightmax = max(rightmax - 1 , dp[i-1][j]);\\n                ll r = dp[i][j] ;\\n                r = max(r ,  p[i][j] + rightmax);\\n                dp[i][j] = r ;\\n            }\\n        }\\n        ll ans = -1;\\n        for(int i = 0 ; i < m;i++)\\n            ans = max(ans , dp[n-1][i]);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n    long long maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        int m = p[0].size();\\n        \\n        vector<vector<ll>>dp(n , vector<ll>(m,0));\\n        \\n        for(int i = 0 ; i < m;i++)\\n            dp[0][i] = p[0][i];\\n        \\n        // iterate from the second row \\n        \\n        for(int i = 1 ; i < n ;i++)\\n        {\\n             // create a leftmax and rightmax pointer\\n             ll leftmax = 0 ; \\n            // left traversal\\n            for(int j = 0 ; j < m ;j++)\\n            {\\n                leftmax = max(leftmax - 1 , dp[i-1][j]);\\n                dp[i][j] = p[i][j] + leftmax;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1345975,
                "title": "c-dp-solution-time-o-m-n-space-o-m",
                "content": "NOTE : If you will not take **long long int**, then you\\'ll get **runtime error**. The reason is that the size of matrix is quite large ,so **int can overflow**.\\n.\\n```\\n#include <bits/stdc++.h>\\nusing namespace std; \\n\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int r=points.size(),c=points[0].size();\\n        vector<ll> prev(c,0);\\n\\n        for(int j=0;j<c;j++)\\n            prev[j]=points[0][j];\\n\\n        for(int i=1;i<r;i++){\\n            //copy the value of current row in points\\n            vector<ll> left(c,0),right(c,0);\\n\\n            //max from the left side\\n            left[0]=prev[0];\\n            for(int j=1;j<c;j++)\\n                left[j]=max(prev[j],left[j-1]-1);\\n\\n            //max from the right side\\n            right[c-1]=prev[c-1];\\n            for(int j=c-2;j>=0;j--)\\n                right[j]=max(prev[j],right[j+1]-1);\\n            \\n            //new vector for the current row\\n            vector<ll> cur(c,0);\\n            //find the max value for each cell\\n            for(int j=0;j<c;j++)\\n                cur[j]=max(left[j],right[j])+points[i][j];\\n\\n            //assinging for next iteration\\n            prev=cur;\\n        }\\n        return *max_element(prev.begin(),prev.end());\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std; \\n\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int r=points.size(),c=points[0].size();\\n        vector<ll> prev(c,0);\\n\\n        for(int j=0;j<c;j++)\\n            prev[j]=points[0][j];\\n\\n        for(int i=1;i<r;i++){\\n            //copy the value of current row in points\\n            vector<ll> left(c,0),right(c,0);\\n\\n            //max from the left side\\n            left[0]=prev[0];\\n            for(int j=1;j<c;j++)\\n                left[j]=max(prev[j],left[j-1]-1);\\n\\n            //max from the right side\\n            right[c-1]=prev[c-1];\\n            for(int j=c-2;j>=0;j--)\\n                right[j]=max(prev[j],right[j+1]-1);\\n            \\n            //new vector for the current row\\n            vector<ll> cur(c,0);\\n            //find the max value for each cell\\n            for(int j=0;j<c;j++)\\n                cur[j]=max(left[j],right[j])+points[i][j];\\n\\n            //assinging for next iteration\\n            prev=cur;\\n        }\\n        return *max_element(prev.begin(),prev.end());\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1345635,
                "title": "python-very-easily-explained-solution",
                "content": "First I would like to recommend you to solve the question : - https://leetcode.com/problems/best-sightseeing-pair/ for a better and inuitive understanding.\\n\\n```\\nimport heapq\\nclass Solution:\\n    def maxPoints(self, arr: List[List[int]]) -> int:\\n        # It\\'s similar to the https://leetcode.com/problems/best-sightseeing-pair/\\n        prevRow = arr[0]\\n        for i in range(1,len(arr)):\\n            res, curr = 0, 0\\n            temp = prevRow[:]\\n            # Here we are doing sightseeing from the left to right side and storing the maximum value.\\n            # Keep in mind that the maximum from the previous is decreasing by 1 on every right move\\n            # Simultaneously we are updating the prevRow\\n            for j in range(len(arr[0])):\\n                res = arr[i][j] + max(temp[j], curr - 1)\\n                curr = max(curr-1, temp[j])\\n                temp[j] = res\\n            res, curr = 0, 0\\n            # Here we are doing sightseeing from the right to left side and storing the maximum value.\\n            # Keep in mind that the maximum from the previous is decreasing by 1 on every left move\\n            # Simultaneously we are updating the prevRow\\n            for j in range(len(arr[0])-1, -1, -1):\\n                res = arr[i][j] + max(prevRow[j], curr - 1)\\n                curr = max(curr-1, prevRow[j])\\n                prevRow[j] = max(temp[j], res)\\n        return max(prevRow)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def maxPoints(self, arr: List[List[int]]) -> int:\\n        # It\\'s similar to the https://leetcode.com/problems/best-sightseeing-pair/\\n        prevRow = arr[0]\\n        for i in range(1,len(arr)):\\n            res, curr = 0, 0\\n            temp = prevRow[:]\\n            # Here we are doing sightseeing from the left to right side and storing the maximum value.\\n            # Keep in mind that the maximum from the previous is decreasing by 1 on every right move\\n            # Simultaneously we are updating the prevRow\\n            for j in range(len(arr[0])):\\n                res = arr[i][j] + max(temp[j], curr - 1)\\n                curr = max(curr-1, temp[j])\\n                temp[j] = res\\n            res, curr = 0, 0\\n            # Here we are doing sightseeing from the right to left side and storing the maximum value.\\n            # Keep in mind that the maximum from the previous is decreasing by 1 on every left move\\n            # Simultaneously we are updating the prevRow\\n            for j in range(len(arr[0])-1, -1, -1):\\n                res = arr[i][j] + max(prevRow[j], curr - 1)\\n                curr = max(curr-1, prevRow[j])\\n                prevRow[j] = max(temp[j], res)\\n        return max(prevRow)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345080,
                "title": "c-o-m-n-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        long long ans=0;\\n        int m=points.size(),n=points[0].size();\\n        vector<vector<long long>> dp(m,vector<long long>(n));\\n\\t\\t\\n\\t\\t// We can also use 1-d array instead of 2-d array for storing previous values\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=points[i][j];\\n            }\\n        }\\n\\t\\t\\n        for(int i=0;i<m;i++){\\n\\t\\t\\n\\t\\t\\t// Adding value of above cell (i-1,j). Here we are not looking for other columns [(i-1,j-1)... (i-1,j+1)...] \\n\\t\\t\\t// bcoz we have already processed this by traversing from left to right and right to left.\\n            for(int j=0;j<n;j++){\\n                if(i>0){\\n                    dp[i][j]+=dp[i-1][j];\\n                }\\n            } \\n            ans=max(ans,dp[i][0]);\\n\\t\\t\\t\\n\\t\\t\\t// Traversing from left to right and checking if left value -1 is greater than the current cell value. \\n\\t\\t\\t//  if yes,then we will update current cell value. Here we are decrement left value by one because there is difference of one in the columns\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=max(dp[i][j],dp[i][j-1]-1);\\n                ans=max(ans,dp[i][j]);\\n            } \\n\\t\\t\\t\\n\\t\\t\\t// Traversing from right to left\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=max(dp[i][j],dp[i][j+1]-1);\\n                ans=max(ans,dp[i][j]);\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Hit upvote if u like it ;)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        long long ans=0;\\n        int m=points.size(),n=points[0].size();\\n        vector<vector<long long>> dp(m,vector<long long>(n));\\n\\t\\t\\n\\t\\t// We can also use 1-d array instead of 2-d array for storing previous values\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=points[i][j];\\n            }\\n        }\\n\\t\\t\\n        for(int i=0;i<m;i++){\\n\\t\\t\\n\\t\\t\\t// Adding value of above cell (i-1,j). Here we are not looking for other columns [(i-1,j-1)... (i-1,j+1)...] \\n\\t\\t\\t// bcoz we have already processed this by traversing from left to right and right to left.\\n            for(int j=0;j<n;j++){\\n                if(i>0){\\n                    dp[i][j]+=dp[i-1][j];\\n                }\\n            } \\n            ans=max(ans,dp[i][0]);\\n\\t\\t\\t\\n\\t\\t\\t// Traversing from left to right and checking if left value -1 is greater than the current cell value. \\n\\t\\t\\t//  if yes,then we will update current cell value. Here we are decrement left value by one because there is difference of one in the columns\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=max(dp[i][j],dp[i][j-1]-1);\\n                ans=max(ans,dp[i][j]);\\n            } \\n\\t\\t\\t\\n\\t\\t\\t// Traversing from right to left\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=max(dp[i][j],dp[i][j+1]-1);\\n                ans=max(ans,dp[i][j]);\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344903,
                "title": "python-bottom-up-dp-with-pre-compute-step",
                "content": "The standard DP approach is O(m * n ^ 2), because you need to check all columns in the inner loop (for each column, taking the max over every other column). However, we can use a linear time pre-compute step for each row and get the algorithm down to O(m * n).\\n\\nAs an example:\\n\\n[1, 5, 3, 1, 7]\\n\\nafter the first pre-compute for loop: [1, 5, 4, 1, 7]\\nafter the second pre-compute for loop: [4, 5, 5, 6, 7]\\n\\nNow that we have the max previous value, then we just need to sum the current row with the pre-computed result.\\n\\n```py\\nclass Solution:\\n\\n    def process(self, row):\\n        for i in range(1, len(row)):\\n            row[i] = max(row[i], row[i - 1] - 1)\\n        for i in reversed(range(len(row) - 1)):\\n            row[i] = max(row[i], row[i + 1] - 1)\\n\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        prev = points[0]\\n        for row in points[1:]:\\n            self.process(prev)\\n            prev = list(map(sum, zip(row, prev)))\\n        return max(prev)\\n```\\n\\nThe unoptimized TLE approach (bottom-up O(m * n ^ 2) DP), for reference:\\n\\n```py\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        rows, cols = len(points), len(points[0])\\n\\n        prev = points[0]\\n        curr = [0] * cols\\n        for row in points[1:]:\\n            for col in range(cols):\\n                curr[col] = row[col] + max(prev[c] - abs(col - c) for c in range(cols))\\n            curr, prev = prev, curr\\n\\n        return max(prev)\\n",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n\\n    def process(self, row):\\n        for i in range(1, len(row)):\\n            row[i] = max(row[i], row[i - 1] - 1)\\n        for i in reversed(range(len(row) - 1)):\\n            row[i] = max(row[i], row[i + 1] - 1)\\n\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        prev = points[0]\\n        for row in points[1:]:\\n            self.process(prev)\\n            prev = list(map(sum, zip(row, prev)))\\n        return max(prev)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344868,
                "title": "c-2-pass-with-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int h = points.size();\\n        int w = points[0].size();\\n        vector<vector<long long>> dp(h, vector<long long>(w, INT_MIN));\\n        \\n        long long ans = INT_MIN;\\n        for (int c = 0; c < w; ++c) {\\n            dp[0][c] = points[0][c];\\n            \\n            if (h == 1) {\\n                ans = max(ans, dp[0][c]);\\n            }\\n        }\\n    \\n        for (int r = 0; r < h - 1; ++r) {\\n            priority_queue<long long> pq_left, pq_right;\\n            \\n            for (int c = 0; c < w; ++c) {\\n                pq_left.push(dp[r][c] + c);\\n                dp[r + 1][c] = max(dp[r + 1][c], pq_left.top() - c + points[r + 1][c]);\\n                \\n                int rhs_idx = w - c - 1;\\n                pq_right.push(dp[r][rhs_idx] + c);\\n                dp[r + 1][rhs_idx] = max(dp[r + 1][rhs_idx], pq_right.top() - c + points[r + 1][rhs_idx]);\\n                \\n                if (r + 1 == h - 1) {\\n                    ans = max(ans, dp[r + 1][c]);\\n                    ans = max(ans, dp[r + 1][rhs_idx]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int h = points.size();\\n        int w = points[0].size();\\n        vector<vector<long long>> dp(h, vector<long long>(w, INT_MIN));\\n        \\n        long long ans = INT_MIN;\\n        for (int c = 0; c < w; ++c) {\\n            dp[0][c] = points[0][c];\\n            \\n            if (h == 1) {\\n                ans = max(ans, dp[0][c]);\\n            }\\n        }\\n    \\n        for (int r = 0; r < h - 1; ++r) {\\n            priority_queue<long long> pq_left, pq_right;\\n            \\n            for (int c = 0; c < w; ++c) {\\n                pq_left.push(dp[r][c] + c);\\n                dp[r + 1][c] = max(dp[r + 1][c], pq_left.top() - c + points[r + 1][c]);\\n                \\n                int rhs_idx = w - c - 1;\\n                pq_right.push(dp[r][rhs_idx] + c);\\n                dp[r + 1][rhs_idx] = max(dp[r + 1][rhs_idx], pq_right.top() - c + points[r + 1][rhs_idx]);\\n                \\n                if (r + 1 == h - 1) {\\n                    ans = max(ans, dp[r + 1][c]);\\n                    ans = max(ans, dp[r + 1][rhs_idx]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077931,
                "title": "detailed-explanation-in-c-tc-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing that strike into my mind is **Dynamic Programming**. \\nOne important clue is that: \\n- `m: num_rows, n: num_cols`\\n- `i: curr_row, j: curr_col`\\n- `dp[i][j] = points[i][j] + (max(dp[i-1][j]) for all j)`\\n\\nWhen applying this approach directly, the overall time complexity is `O(m * n * n)` because we need to go through the previous row for each cell, \\n\\nTo make it more efficient, I need to figure out a way to find the best index in the previous row.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I would like to introduce how to efficiently find the best index in the prevous row.\\n\\nThe idea is leverage the intermediate result of **previous column index**\\n\\nFirstly, given an index `i`, we put the current row into two groups. One is cells with `index < i` and the other is cells with `index > i`. Suppose we can figure out the best index in the first group and in the second group individually, we can easily \\n\\nTo determine the best index within the right group. I would create an array called `max_from_right`. This array keeps track of the maximum dynamic programming results in the previous row. \\n\\nSpecifically, `max_from_right[i]` will recored the maximum values from index `i` to `n-1`. Note that in order to remove the effect of cost, we need to substract their own index from their original value.\\n\\nTherefore, we can know the best index in the right group by looking up `max_from_right`\\n\\nLastly, as you might noticed, we just need to compare the best one in the lefft group with new incoming one. Then update the best index within the left group accordingly.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing pll = pair<long long, long long>;\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n\\n        const int m = points.size(), n = points[0].size();\\n        vector<vector<long long>> dp(m, vector<long long>(n, 0));\\n        for(int i=0; i<n; ++i){\\n            dp[0][i] = points[0][i];\\n        }\\n\\n\\n        for(int i=1; i<m; ++i){\\n            vector<pll> max_from_right(n);\\n            for(int j=0; j<n; ++j){\\n                max_from_right[j] = {dp[i-1][j] - j, j};\\n            }\\n\\n            for(int j=n-2; j>=0; --j){\\n                if(max_from_right[j].first <= max_from_right[j+1].first){\\n                    max_from_right[j] = max_from_right[j+1];\\n                }\\n            }\\n\\n            long long left_max = INT_MIN;\\n            for(int j=0; j<n; ++j){\\n                dp[i][j] = (long long)points[i][j] + max(left_max, (max_from_right[j].first + j));\\n\\n                if(max_from_right[j].second == j){\\n                    left_max = max(left_max, (max_from_right[j].first + max_from_right[j].second));\\n                }\\n\\n                if(left_max != INT_MIN){\\n                    left_max -= 1;\\n                }\\n            }\\n        }\\n\\n        long long max_scores = 0;\\n        for(int i=0; i<n; ++i){\\n            max_scores = max(max_scores, (dp.back())[i]);\\n        }\\n        return max_scores;\\n    }\\n};\\n\\n/*\\npoints\\n[5,2,1,2],\\n[2,1,5,2],\\n[5,5,5,0]\\n\\ndp\\n[5,2,1,2],\\n[7,5,8,4],\\n[0,0,0,0],\\n\\nmax_from_right\\nval: [5,2,1,2] -> [5,1,-1,-1] -> [5,1,-1,-1]\\nidx:                             [0,1, 3, 3]\\n\\nwhen i == 1:\\nleft_max = INT_MIN\\ndp[i][0] = 2 + 5 = 7\\n\\nleft_max = 4\\ndp[i][1] = 1 + 4 = 5\\n\\nleft_max = 3\\ndp[i][2] = 5 + 3 = 8\\n\\nleft_max = 2\\ndp[i][3] = 2 + 2 = 4\\n\\nmax_from_right\\nval: [7,5,8,4] -> [7,4,6,1] -> [7,6,6,1]\\nidx:                           [0,2,2,3]\\n\\nwhen i == 2:\\nleft_max = INT_MIN\\ndp[i][0] = 5 + max(INT_MIN, (7+0)) = 12\\n\\nleft_max = 6\\ndp[i][1] = 5 + max(6, (6+1)) = 12\\n\\nleft_max = 5\\ndp[i][2] = 5 + max(5, (6+2)) = 13\\n\\nleft_max = 7\\ndp[i][3] = 0 + max(7, 4) = 7\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing pll = pair<long long, long long>;\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n\\n        const int m = points.size(), n = points[0].size();\\n        vector<vector<long long>> dp(m, vector<long long>(n, 0));\\n        for(int i=0; i<n; ++i){\\n            dp[0][i] = points[0][i];\\n        }\\n\\n\\n        for(int i=1; i<m; ++i){\\n            vector<pll> max_from_right(n);\\n            for(int j=0; j<n; ++j){\\n                max_from_right[j] = {dp[i-1][j] - j, j};\\n            }\\n\\n            for(int j=n-2; j>=0; --j){\\n                if(max_from_right[j].first <= max_from_right[j+1].first){\\n                    max_from_right[j] = max_from_right[j+1];\\n                }\\n            }\\n\\n            long long left_max = INT_MIN;\\n            for(int j=0; j<n; ++j){\\n                dp[i][j] = (long long)points[i][j] + max(left_max, (max_from_right[j].first + j));\\n\\n                if(max_from_right[j].second == j){\\n                    left_max = max(left_max, (max_from_right[j].first + max_from_right[j].second));\\n                }\\n\\n                if(left_max != INT_MIN){\\n                    left_max -= 1;\\n                }\\n            }\\n        }\\n\\n        long long max_scores = 0;\\n        for(int i=0; i<n; ++i){\\n            max_scores = max(max_scores, (dp.back())[i]);\\n        }\\n        return max_scores;\\n    }\\n};\\n\\n/*\\npoints\\n[5,2,1,2],\\n[2,1,5,2],\\n[5,5,5,0]\\n\\ndp\\n[5,2,1,2],\\n[7,5,8,4],\\n[0,0,0,0],\\n\\nmax_from_right\\nval: [5,2,1,2] -> [5,1,-1,-1] -> [5,1,-1,-1]\\nidx:                             [0,1, 3, 3]\\n\\nwhen i == 1:\\nleft_max = INT_MIN\\ndp[i][0] = 2 + 5 = 7\\n\\nleft_max = 4\\ndp[i][1] = 1 + 4 = 5\\n\\nleft_max = 3\\ndp[i][2] = 5 + 3 = 8\\n\\nleft_max = 2\\ndp[i][3] = 2 + 2 = 4\\n\\nmax_from_right\\nval: [7,5,8,4] -> [7,4,6,1] -> [7,6,6,1]\\nidx:                           [0,2,2,3]\\n\\nwhen i == 2:\\nleft_max = INT_MIN\\ndp[i][0] = 5 + max(INT_MIN, (7+0)) = 12\\n\\nleft_max = 6\\ndp[i][1] = 5 + max(6, (6+1)) = 12\\n\\nleft_max = 5\\ndp[i][2] = 5 + max(5, (6+2)) = 13\\n\\nleft_max = 7\\ndp[i][3] = 0 + max(7, 4) = 7\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978474,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long[] dp = new long[points[0].length];\\n        for(int row=0; row<points.length; row++){\\n            for(int col=0; col<points[0].length; col++){\\n                dp[col]+=points[row][col];\\n            }\\n            for(int col=1; col<points[0].length; col++){\\n                dp[col]=Math.max(dp[col],dp[col-1]-1);\\n            }\\n            for(int col=points[0].length-2; col>=0; col--){\\n                dp[col]=Math.max(dp[col],dp[col+1]-1);\\n            }\\n        }\\n        long maxCost = 0L;\\n        for(int col=0; col<points[0].length; col++){\\n            maxCost=Math.max(dp[col],maxCost);\\n        }\\n        return maxCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long[] dp = new long[points[0].length];\\n        for(int row=0; row<points.length; row++){\\n            for(int col=0; col<points[0].length; col++){\\n                dp[col]+=points[row][col];\\n            }\\n            for(int col=1; col<points[0].length; col++){\\n                dp[col]=Math.max(dp[col],dp[col-1]-1);\\n            }\\n            for(int col=points[0].length-2; col>=0; col--){\\n                dp[col]=Math.max(dp[col],dp[col+1]-1);\\n            }\\n        }\\n        long maxCost = 0L;\\n        for(int col=0; col<points[0].length; col++){\\n            maxCost=Math.max(dp[col],maxCost);\\n        }\\n        return maxCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922457,
                "title": "java-o-mn-2-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n         int m = points.length;\\n        int n = points[0].length;\\n        long[][] dp = new long[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = points[i][j];\\n            }\\n        }\\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                long max=0;\\n                for (int k = 0; k < n; k++) {\\n                    long pt = dp[i - 1][k] + points[i][j] - Math.abs(j - k);\\n                    max=Math.max(pt, max);\\n                    \\n                }\\n                dp[i][j]=max;\\n            }\\n        }\\n\\n        long maxScore = 0;\\n        for (int j = 0; j < n; j++) {\\n            maxScore = Math.max(maxScore, dp[m - 1][j]);\\n        }\\n\\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n         int m = points.length;\\n        int n = points[0].length;\\n        long[][] dp = new long[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = points[i][j];\\n            }\\n        }\\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                long max=0;\\n                for (int k = 0; k < n; k++) {\\n                    long pt = dp[i - 1][k] + points[i][j] - Math.abs(j - k);\\n                    max=Math.max(pt, max);\\n                    \\n                }\\n                dp[i][j]=max;\\n            }\\n        }\\n\\n        long maxScore = 0;\\n        for (int j = 0; j < n; j++) {\\n            maxScore = Math.max(maxScore, dp[m - 1][j]);\\n        }\\n\\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851125,
                "title": "easy-understand-c-space-o-n-time-o-mn",
                "content": "# Intuition\\nmemo[i][j]: The profit for must choose points[i][j].\\nThen, optimize the space to memo[N].\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. memo[i][j] = points[i][j] + profit form up row (memo[i-1]).\\n2. How to get profit from memo[i-1] efficiently?\\nKey: Precompute the right max, rmax[k] = max(rmax[k+1], memo[k]-k);\\n3. Can use my API show() and show2() to print out the content. It would be usdful.\\n\\nIf this solution is useful, please upvote. Thanks!.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(MN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using T = long long;\\n    long long maxPoints(vector<vector<int>>& points) {\\n        auto m = points.size();\\n        auto n = points[0].size();\\n        //vector<vector<T>> memo(m, vector<T>(n, INT_MIN));\\n        vector<T> memo(n, INT_MIN);\\n        \\n        for (int j = 0; j < n; j++) {\\n            memo[j] = points[0][j];\\n        }\\n        for (int i = 1; i < m; i++) {\\n            vector<T> rmax(n+1);\\n            rmax[n] = INT_MIN;\\n            for (int k = n-1; k >= 1; k--) {\\n                rmax[k] = max(rmax[k+1], memo[k]-k);\\n            }\\n            T lmax = memo[0];\\n            for (int j = 0; j < n; j++) {                \\n                lmax = max(lmax-1, memo[j]);\\n                memo[j] = points[i][j] + max(rmax[j+1]+j, lmax);               \\n            }\\n        }\\n        return *max_element(memo.begin(), memo.end());\\n    }\\n    void show(vector<vector<int>>& vec) {\\n        for (auto& a: vec) {\\n            for (auto b : a) {\\n                cout << b << \" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n    }\\n    void show2(vector<int>& vec) {\\n        for (auto a: vec) {            \\n                cout << a << \" \";\\n        }\\n        cout << \"\\\\n\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using T = long long;\\n    long long maxPoints(vector<vector<int>>& points) {\\n        auto m = points.size();\\n        auto n = points[0].size();\\n        //vector<vector<T>> memo(m, vector<T>(n, INT_MIN));\\n        vector<T> memo(n, INT_MIN);\\n        \\n        for (int j = 0; j < n; j++) {\\n            memo[j] = points[0][j];\\n        }\\n        for (int i = 1; i < m; i++) {\\n            vector<T> rmax(n+1);\\n            rmax[n] = INT_MIN;\\n            for (int k = n-1; k >= 1; k--) {\\n                rmax[k] = max(rmax[k+1], memo[k]-k);\\n            }\\n            T lmax = memo[0];\\n            for (int j = 0; j < n; j++) {                \\n                lmax = max(lmax-1, memo[j]);\\n                memo[j] = points[i][j] + max(rmax[j+1]+j, lmax);               \\n            }\\n        }\\n        return *max_element(memo.begin(), memo.end());\\n    }\\n    void show(vector<vector<int>>& vec) {\\n        for (auto& a: vec) {\\n            for (auto b : a) {\\n                cout << b << \" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n    }\\n    void show2(vector<int>& vec) {\\n        for (auto a: vec) {            \\n                cout << a << \" \";\\n        }\\n        cout << \"\\\\n\";\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3775249,
                "title": "dynamic-programming-python3-beats-100",
                "content": "# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        n = len(points)\\n        m = len(points[0])\\n        prev = points[0]\\n        for i in range(1, n):\\n            maxer = None\\n            new = [0]*m\\n            for j in range(m):\\n                if not maxer or maxer <= prev[j]:\\n                    maxer = prev[j]\\n                new[j] = maxer+points[i][j]\\n                maxer -= 1\\n            maxer = None\\n            for j in range(m-1,-1,-1):\\n                if not maxer or maxer <= prev[j]:\\n                    maxer = prev[j]\\n                new[j] = max(new[j],maxer+points[i][j])\\n                maxer -= 1\\n            # print(prev, new)\\n            prev = list(new)\\n        return max(prev)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        n = len(points)\\n        m = len(points[0])\\n        prev = points[0]\\n        for i in range(1, n):\\n            maxer = None\\n            new = [0]*m\\n            for j in range(m):\\n                if not maxer or maxer <= prev[j]:\\n                    maxer = prev[j]\\n                new[j] = maxer+points[i][j]\\n                maxer -= 1\\n            maxer = None\\n            for j in range(m-1,-1,-1):\\n                if not maxer or maxer <= prev[j]:\\n                    maxer = prev[j]\\n                new[j] = max(new[j],maxer+points[i][j])\\n                maxer -= 1\\n            # print(prev, new)\\n            prev = list(new)\\n        return max(prev)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606771,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        n = len(points)\\n        m = len(points[0])\\n        max_achievable = points[0] # maximum points achievable from top by picking current cell\\n        for i in range(1, n):\\n            max_left = [max_achievable[0]] # maximum value of (max_achievable[j] + j) up to j from left\\n            for j in range(1, m):\\n                max_left.append(max(max_achievable[j] + j, max_left[j - 1]))\\n            max_right = [0] * (m - 1) + [max_achievable[-1] - (m - 1)] # maximum value of (max_achievable[j] - j) up to j from right\\n            for j in range(m - 2, -1, -1):\\n                max_right[j] = max(max_achievable[j] - j, max_right[j + 1])\\n            for j in range(m):\\n                max_achievable[j] = points[i][j] + max(max_left[j] - j, max_right[j] + j)\\n        return max(max_achievable)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        n = len(points)\\n        m = len(points[0])\\n        max_achievable = points[0] # maximum points achievable from top by picking current cell\\n        for i in range(1, n):\\n            max_left = [max_achievable[0]] # maximum value of (max_achievable[j] + j) up to j from left\\n            for j in range(1, m):\\n                max_left.append(max(max_achievable[j] + j, max_left[j - 1]))\\n            max_right = [0] * (m - 1) + [max_achievable[-1] - (m - 1)] # maximum value of (max_achievable[j] - j) up to j from right\\n            for j in range(m - 2, -1, -1):\\n                max_right[j] = max(max_achievable[j] - j, max_right[j + 1])\\n            for j in range(m):\\n                max_achievable[j] = points[i][j] + max(max_left[j] - j, max_right[j] + j)\\n        return max(max_achievable)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577513,
                "title": "left-rigt-dp-clean-code-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        // brute force: n^3\\n        // improved: n^2\\n        // left + right DP\\n\\n        vector<long long> leftDP(points[0].size(), 0);\\n        vector<long long> rightDP(points[0].size(), 0);\\n\\n        vector<long long> last_layer(points[0].size(), 0);\\n        long long result = 0;\\n        for(int i = 0; i < points.size(); i++){\\n            // traverse left\\n            leftDP[0] = last_layer[0] + points[i][0];\\n            for(int j = 1; j < points[0].size(); j++){\\n                leftDP[j] = max(leftDP[j - 1] - 1, last_layer[j] + points[i][j]);\\n            }\\n            // traverse right\\n            rightDP[points[0].size() - 1] = last_layer[points[0].size() - 1] + points[i][points[0].size() - 1];\\n            for (int j = points[0].size() - 2; j >= 0; j--){\\n                rightDP[j] = max(rightDP[j + 1] - 1, last_layer[j] + points[i][j]);\\n            }\\n            // update last_layer to be the value of current layer\\n            for (int j = 0; j < points[0].size(); j++){\\n                last_layer[j] = max(rightDP[j], leftDP[j]);\\n                result = max(result, last_layer[j]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        // brute force: n^3\\n        // improved: n^2\\n        // left + right DP\\n\\n        vector<long long> leftDP(points[0].size(), 0);\\n        vector<long long> rightDP(points[0].size(), 0);\\n\\n        vector<long long> last_layer(points[0].size(), 0);\\n        long long result = 0;\\n        for(int i = 0; i < points.size(); i++){\\n            // traverse left\\n            leftDP[0] = last_layer[0] + points[i][0];\\n            for(int j = 1; j < points[0].size(); j++){\\n                leftDP[j] = max(leftDP[j - 1] - 1, last_layer[j] + points[i][j]);\\n            }\\n            // traverse right\\n            rightDP[points[0].size() - 1] = last_layer[points[0].size() - 1] + points[i][points[0].size() - 1];\\n            for (int j = points[0].size() - 2; j >= 0; j--){\\n                rightDP[j] = max(rightDP[j + 1] - 1, last_layer[j] + points[i][j]);\\n            }\\n            // update last_layer to be the value of current layer\\n            for (int j = 0; j < points[0].size(); j++){\\n                last_layer[j] = max(rightDP[j], leftDP[j]);\\n                result = max(result, last_layer[j]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558346,
                "title": "i-don-t-like-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic long maxPoints(int[][] points) {\\nint n=points.length;\\nint m=points[0].length;\\n    long dp[][]=new long[n][m];\\n    \\n    for(int i=0;i<m;i++)\\n        dp[0][i]=points[0][i];\\n    \\n    long left[]=new long[m];\\n    long right[]=new long[m];\\n    \\n    for(int i=1;i<n;i++)\\n    {\\n        left[0]=dp[i-1][0];\\n        right[m-1]=dp[i-1][m-1];\\n        \\n        for(int j=1;j<m;j++)\\n            left[j]=Math.max(dp[i-1][j],left[j-1]-1);\\n        \\n        for(int j=m-2;j>=0;j--)\\n            right[j]=Math.max(dp[i-1][j],right[j+1]-1);\\n        \\n        for(int j=0;j<m;j++)\\n            dp[i][j]=Math.max(left[j],right[j])+points[i][j];\\n    }\\n    \\n    long ans=0;\\n    \\n    for(int i=0;i<m;i++)\\n        ans=Math.max(ans,dp[n-1][i]);\\n    \\n    return ans;\\n}}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic long maxPoints(int[][] points) {\\nint n=points.length;\\nint m=points[0].length;\\n    long dp[][]=new long[n][m];\\n    \\n    for(int i=0;i<m;i++)\\n        dp[0][i]=points[0][i];\\n    \\n    long left[]=new long[m];\\n    long right[]=new long[m];\\n    \\n    for(int i=1;i<n;i++)\\n    {\\n        left[0]=dp[i-1][0];\\n        right[m-1]=dp[i-1][m-1];\\n        \\n        for(int j=1;j<m;j++)\\n            left[j]=Math.max(dp[i-1][j],left[j-1]-1);\\n        \\n        for(int j=m-2;j>=0;j--)\\n            right[j]=Math.max(dp[i-1][j],right[j+1]-1);\\n        \\n        for(int j=0;j<m;j++)\\n            dp[i][j]=Math.max(left[j],right[j])+points[i][j];\\n    }\\n    \\n    long ans=0;\\n    \\n    for(int i=0;i<m;i++)\\n        ans=Math.max(ans,dp[n-1][i]);\\n    \\n    return ans;\\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516565,
                "title": "maximum-number-of-points-with-cost",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        \\n        dp = points[0]\\n        \\n        left = [0] * n ## left side contribution\\n        right = [0] * n ## right side contribution\\n        \\n        for r in range(1, m):\\n            for c in range(n):\\n                if c == 0:\\n                    left[c] = dp[c]\\n                else:\\n                    left[c] = max(left[c - 1] - 1, dp[c])\\n            \\n            for c in range(n - 1, -1, -1):\\n                if c == n-1:\\n                    right[c] = dp[c]\\n                else:\\n                    right[c] = max(right[c + 1] - 1, dp[c])\\n                    \\n            for c in range(n):\\n                dp[c] = points[r][c] + max(left[c], right[c])\\n                \\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        \\n        dp = points[0]\\n        \\n        left = [0] * n ## left side contribution\\n        right = [0] * n ## right side contribution\\n        \\n        for r in range(1, m):\\n            for c in range(n):\\n                if c == 0:\\n                    left[c] = dp[c]\\n                else:\\n                    left[c] = max(left[c - 1] - 1, dp[c])\\n            \\n            for c in range(n - 1, -1, -1):\\n                if c == n-1:\\n                    right[c] = dp[c]\\n                else:\\n                    right[c] = max(right[c + 1] - 1, dp[c])\\n                    \\n            for c in range(n):\\n                dp[c] = points[r][c] + max(left[c], right[c])\\n                \\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481806,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long[][] dp = new long[points.length][points[0].length];\\n        long res = 0;\\n        for(int i=0;i<points[0].length;i++){\\n            dp[0][i] = points[0][i];\\n            res = Math.max(res, dp[0][i]);\\n        }\\n        \\n        for(int i=1;i<points.length;i++){\\n            long left[] = new long[points[0].length];\\n            long right[] = new long[points[0].length];\\n            int prev = i-1;\\n            for(int j=0;j<points[0].length;j++){\\n                if(j==0){\\n                    left[j] = dp[prev][j];\\n                }\\n                else{\\n                    left[j] = Math.max(left[j-1]-1, dp[prev][j]);\\n                }\\n            }\\n            \\n            for(int j=points[0].length-1;j>=0;j--){\\n                if(j==points[0].length-1){\\n                    right[j] = dp[prev][j];\\n                }\\n                else{\\n                    right[j] = Math.max(dp[prev][j], right[j+1]-1);\\n                }\\n            }\\n            for(int j=0;j<points[0].length;j++){\\n                dp[i][j] = points[i][j] + Math.max(left[j], right[j]);\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long[][] dp = new long[points.length][points[0].length];\\n        long res = 0;\\n        for(int i=0;i<points[0].length;i++){\\n            dp[0][i] = points[0][i];\\n            res = Math.max(res, dp[0][i]);\\n        }\\n        \\n        for(int i=1;i<points.length;i++){\\n            long left[] = new long[points[0].length];\\n            long right[] = new long[points[0].length];\\n            int prev = i-1;\\n            for(int j=0;j<points[0].length;j++){\\n                if(j==0){\\n                    left[j] = dp[prev][j];\\n                }\\n                else{\\n                    left[j] = Math.max(left[j-1]-1, dp[prev][j]);\\n                }\\n            }\\n            \\n            for(int j=points[0].length-1;j>=0;j--){\\n                if(j==points[0].length-1){\\n                    right[j] = dp[prev][j];\\n                }\\n                else{\\n                    right[j] = Math.max(dp[prev][j], right[j+1]-1);\\n                }\\n            }\\n            for(int j=0;j<points[0].length;j++){\\n                dp[i][j] = points[i][j] + Math.max(left[j], right[j]);\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460926,
                "title": "easy-to-understand-solution-in-java-using-dp-and-pre-computation-using-prefix-and-suffix-max",
                "content": "# Intuition and Approach\\n\\n**BRUTE FORCE**:\\nThe first way to think this problem is to fnd all the possiblities of selecting which will be O(column^row) reach row has column number of choices and we have row number of rows hence O(column^row).\\n\\n**dp O(n^3)**\\nfor each row starting from row 1 check the columns in the row above. and calculate the value \\n= max from above - cost to pick that\\n\\n**dp optimized with pre computed values. O(n^2)**\\n1. calculate the prefixMax and suffixMax (the trick is useful to find the max at position i in a linear array in linear time if you have precomputed values )\\n2. One small variation is when you compare the prefix max and suffix max subtract one from the left and right respectively to accomodate the cost of going far from the\\n3. for every row starting from row 1 calculate the prefix max and suffix \\n   max. and fill the ans table . \\n\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m =points.length;\\n        int n = points[0].length;\\n        long ans[][] = new long[m][n];\\n        long max=0;\\n\\n        for(int j=0;j<n;j++)\\n        {\\n            ans[0][j] = points[0][j];\\n            max=Math.max(ans[0][j],max);\\n        }\\n        for(int i=1;i<m;i++)\\n        {\\n            max=0;\\n            long[] prefixMax = new long[n];\\n            prefixMax[0]=ans[i-1][0];\\n            long[] suffixMax = new long[n];\\n            suffixMax[n-1]=ans[i-1][n-1];\\n//calculating prefix and suffix\\n            for(int j=n-2;j>=0;j--)\\n            {\\n                suffixMax[j] = Math.max(ans[i-1][j],suffixMax[j+1]-1);\\n            }   \\n            for(int j=1;j<n;j++)\\n            {   \\n                prefixMax[j]= Math.max(ans[i-1][j],prefixMax[j-1] -1);\\n            }\\n\\n//for every row calculate in linear time the max\\n            for(int j=0;j<n;j++)\\n            {\\n                ans[i][j] = Math.max(prefixMax[j],suffixMax[j])+points[i][j];\\n                max=Math.max(ans[i][j],max);\\n            }\\n          \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        int m =points.length;\\n        int n = points[0].length;\\n        long ans[][] = new long[m][n];\\n        long max=0;\\n\\n        for(int j=0;j<n;j++)\\n        {\\n            ans[0][j] = points[0][j];\\n            max=Math.max(ans[0][j],max);\\n        }\\n        for(int i=1;i<m;i++)\\n        {\\n            max=0;\\n            long[] prefixMax = new long[n];\\n            prefixMax[0]=ans[i-1][0];\\n            long[] suffixMax = new long[n];\\n            suffixMax[n-1]=ans[i-1][n-1];\\n//calculating prefix and suffix\\n            for(int j=n-2;j>=0;j--)\\n            {\\n                suffixMax[j] = Math.max(ans[i-1][j],suffixMax[j+1]-1);\\n            }   \\n            for(int j=1;j<n;j++)\\n            {   \\n                prefixMax[j]= Math.max(ans[i-1][j],prefixMax[j-1] -1);\\n            }\\n\\n//for every row calculate in linear time the max\\n            for(int j=0;j<n;j++)\\n            {\\n                ans[i][j] = Math.max(prefixMax[j],suffixMax[j])+points[i][j];\\n                max=Math.max(ans[i][j],max);\\n            }\\n          \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425323,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(cols)\\n * where `rows` is the number of the rows of the matrix `points`\\n *       `cols` is the number of the columns of the matrix `points`\\n */\\nclass Solution {\\n public:\\n  long long maxPoints(const vector<vector<int>> &points) {\\n    constexpr int range = 2;\\n    const int rows = static_cast<int>(points.size());\\n    const int cols = static_cast<int>(points.front().size());\\n    long long dp[range][cols];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    for (int c = 0; c < cols; ++c) {\\n      dp[previous][c] = points.front()[c];\\n    }\\n    \\n    for (int r = 1; r < rows; ++r) {\\n      long long left[cols];\\n      long long right[cols];\\n      left[0] = dp[previous][0];\\n      right[cols - 1] = dp[previous][cols - 1];\\n      for (int c = 1; c < cols; ++c) {\\n        left[c] = max(left[c - 1], dp[previous][c] + c);\\n        right[cols - c - 1] = max(right[cols - c], dp[previous][cols - c - 1] + c);\\n      }\\n      \\n      for (int c = 0; c < cols; ++c) {\\n        dp[current][c] = points[r][c] + max(left[c] - c, right[c] - (cols - c - 1));\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return *max_element(dp[previous], dp[previous] + cols);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(cols)\\n * where `rows` is the number of the rows of the matrix `points`\\n *       `cols` is the number of the columns of the matrix `points`\\n */\\nclass Solution {\\n public:\\n  long long maxPoints(const vector<vector<int>> &points) {\\n    constexpr int range = 2;\\n    const int rows = static_cast<int>(points.size());\\n    const int cols = static_cast<int>(points.front().size());\\n    long long dp[range][cols];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    for (int c = 0; c < cols; ++c) {\\n      dp[previous][c] = points.front()[c];\\n    }\\n    \\n    for (int r = 1; r < rows; ++r) {\\n      long long left[cols];\\n      long long right[cols];\\n      left[0] = dp[previous][0];\\n      right[cols - 1] = dp[previous][cols - 1];\\n      for (int c = 1; c < cols; ++c) {\\n        left[c] = max(left[c - 1], dp[previous][c] + c);\\n        right[cols - c - 1] = max(right[cols - c], dp[previous][cols - c - 1] + c);\\n      }\\n      \\n      for (int c = 0; c < cols; ++c) {\\n        dp[current][c] = points[r][c] + max(left[c] - c, right[c] - (cols - c - 1));\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return *max_element(dp[previous], dp[previous] + cols);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348879,
                "title": "javascript-1937-maximum-number-of-points-with-cost",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nFarther Indexes reduce points by 1 each times, each side\\n\\n```\\n -3     -2      -1       *      -1     -2     -3\\n            lMax - 1\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1. Time limit exceed - Fail\\n```\\nvar maxPoints = function (a) {\\n    let m = a.length;\\n    let n = a[0].length;\\n\\n    let f = Array.from({ length: 2 }, () => new Array(n).fill(0));\\n\\n    for (let c = 0; c < n; c++) {\\n        f[0][c] = a[0][c];\\n    }\\n\\n    for (let r = 1; r < m; r++) {\\n        let cr = r % 2; // curr row (cr)                curr column (cc)\\n        let pr = 1 - (r % 2); // prev row (pr)          prev column (pc)\\n        for (let pc = 0; pc < n; pc++) {\\n            for (let cc = 0; cc < n; cc++) {\\n                f[cr][cc] = Math.max(\\n                    f[cr][cc], //\\n                    f[pr][pc] + //\\n                        a[r][cc] -\\n                        Math.abs(pc - cc)\\n                );\\n            }\\n        }\\n    }\\n    return Math.max(...f[(m - 1) % 2]);\\n};\\n```\\n\\n2. Pass\\n```\\nvar maxPoints = function (points) {\\n    let m = points.length;\\n    let n = points[0].length;\\n\\n    let cur = new Array(n).fill(0);\\n    for (let i = 0; i < m; i++) {\\n        let next = new Array(n);\\n\\n        let lMax = 0;\\n        for (let j = 0; j < n; j++) {\\n            lMax = Math.max(lMax - 1, cur[j]);\\n            next[j] = lMax;\\n        }\\n        let rMax = 0;\\n        for (let j = n - 1; j >= 0; j--) {\\n            rMax = Math.max(rMax - 1, cur[j]);\\n            next[j] = Math.max(next[j], rMax);\\n        }\\n\\n        for (let j = 0; j < n; j++) {\\n            cur[j] = next[j] + points[i][j];\\n        }\\n    }\\n\\n    return Math.max(...cur);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n -3     -2      -1       *      -1     -2     -3\\n            lMax - 1\\n```\n```\\nvar maxPoints = function (a) {\\n    let m = a.length;\\n    let n = a[0].length;\\n\\n    let f = Array.from({ length: 2 }, () => new Array(n).fill(0));\\n\\n    for (let c = 0; c < n; c++) {\\n        f[0][c] = a[0][c];\\n    }\\n\\n    for (let r = 1; r < m; r++) {\\n        let cr = r % 2; // curr row (cr)                curr column (cc)\\n        let pr = 1 - (r % 2); // prev row (pr)          prev column (pc)\\n        for (let pc = 0; pc < n; pc++) {\\n            for (let cc = 0; cc < n; cc++) {\\n                f[cr][cc] = Math.max(\\n                    f[cr][cc], //\\n                    f[pr][pc] + //\\n                        a[r][cc] -\\n                        Math.abs(pc - cc)\\n                );\\n            }\\n        }\\n    }\\n    return Math.max(...f[(m - 1) % 2]);\\n};\\n```\n```\\nvar maxPoints = function (points) {\\n    let m = points.length;\\n    let n = points[0].length;\\n\\n    let cur = new Array(n).fill(0);\\n    for (let i = 0; i < m; i++) {\\n        let next = new Array(n);\\n\\n        let lMax = 0;\\n        for (let j = 0; j < n; j++) {\\n            lMax = Math.max(lMax - 1, cur[j]);\\n            next[j] = lMax;\\n        }\\n        let rMax = 0;\\n        for (let j = n - 1; j >= 0; j--) {\\n            rMax = Math.max(rMax - 1, cur[j]);\\n            next[j] = Math.max(next[j], rMax);\\n        }\\n\\n        for (let j = 0; j < n; j++) {\\n            cur[j] = next[j] + points[i][j];\\n        }\\n    }\\n\\n    return Math.max(...cur);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3333910,
                "title": "python-beats-99-47-with-intuition",
                "content": "# Intuition\\nfor every cell in every row row, we want to know the best value to pick in the previous row. add that value for every cell, then go left and right across the current row to update the best values so that the next row can use them. the sums cascade down the rows so just return the maximum at the bottom row\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def goright(row): \\n            for i in range(1, len(row)):\\n                if row[i-1] - 1 > row[i]: \\n                    row[i] = row[i-1]-1\\n\\n        def goleft(row): \\n            for i in range(len(row)-2, -1, -1):\\n                if row[i+1]-1 > row[i]:\\n                    row[i] = row[i+1]-1\\n\\n        goright(points[0])\\n        goleft(points[0])\\n\\n        res = 0\\n        for i in range(1, len(points)):\\n            for j in range(len(points[i])):\\n                points[i][j] += points[i-1][j]\\n            goright(points[i])\\n            goleft(points[i])\\n\\n        return max(points[-1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def goright(row): \\n            for i in range(1, len(row)):\\n                if row[i-1] - 1 > row[i]: \\n                    row[i] = row[i-1]-1\\n\\n        def goleft(row): \\n            for i in range(len(row)-2, -1, -1):\\n                if row[i+1]-1 > row[i]:\\n                    row[i] = row[i+1]-1\\n\\n        goright(points[0])\\n        goleft(points[0])\\n\\n        res = 0\\n        for i in range(1, len(points)):\\n            for j in range(len(points[i])):\\n                points[i][j] += points[i-1][j]\\n            goright(points[i])\\n            goleft(points[i])\\n\\n        return max(points[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300447,
                "title": "c-9-line-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n//  dp[j] = max dp[i] - abs(i-j) =j + max dp[i]-i when i>=j \\n//                              =-j + max dp[i]+i when i<=j\\n\\n    long long maxPoints(vector<vector<int>>& points) {\\n        const int n = points.size(), m = points[0].size();\\n        vector<long long> pre(m), cur(m, -1e9), maxPlus(m+1, -1e9), maxMinus(m+1, -1e9);\\n        for(auto& v:points){\\n            for(int i=0;i<m;i++) maxPlus[i+1] = max(maxPlus[i], pre[i]+i);\\n            for(int i=m-1;i>=0;i--) maxMinus[i] = max(maxMinus[i+1], pre[i]-i);\\n            for(int i=0;i<m;i++) cur[i] = v[i] + max(-i+maxPlus[i+1], i+maxMinus[i]);                \\n            pre = move(cur);\\n            cur = vector<long long>(m, 0);\\n        }\\n        return *max_element(pre.begin(), pre.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//  dp[j] = max dp[i] - abs(i-j) =j + max dp[i]-i when i>=j \\n//                              =-j + max dp[i]+i when i<=j\\n\\n    long long maxPoints(vector<vector<int>>& points) {\\n        const int n = points.size(), m = points[0].size();\\n        vector<long long> pre(m), cur(m, -1e9), maxPlus(m+1, -1e9), maxMinus(m+1, -1e9);\\n        for(auto& v:points){\\n            for(int i=0;i<m;i++) maxPlus[i+1] = max(maxPlus[i], pre[i]+i);\\n            for(int i=m-1;i>=0;i--) maxMinus[i] = max(maxMinus[i+1], pre[i]-i);\\n            for(int i=0;i<m;i++) cur[i] = v[i] + max(-i+maxPlus[i+1], i+maxMinus[i]);                \\n            pre = move(cur);\\n            cur = vector<long long>(m, 0);\\n        }\\n        return *max_element(pre.begin(), pre.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240013,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_points(points: Vec<Vec<i32>>) -> i64 {\\n        let col_len = points[0].len();\\n        let mut ans: Vec<i64> = points[0].iter().map(|&num| i64::from(num)).collect();\\n        for row in points.iter().skip(1) {\\n            let mut dp: Vec<i64> = ans.clone();\\n            let mut left = ans[0];\\n            let mut right = ans[col_len - 1];\\n            for i in 1..col_len {\\n                left = (left - 1).max(ans[i]);\\n                dp[i] = dp[i].max(left);\\n\\n                let j = col_len - 1 - i;\\n                right = (right - 1).max(ans[j]);\\n                dp[j] = dp[j].max(right);\\n            }\\n            for i in 0..col_len {\\n                ans[i] = dp[i] + i64::from(row[i]);\\n            }\\n        }\\n        *ans.iter().max().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_points(points: Vec<Vec<i32>>) -> i64 {\\n        let col_len = points[0].len();\\n        let mut ans: Vec<i64> = points[0].iter().map(|&num| i64::from(num)).collect();\\n        for row in points.iter().skip(1) {\\n            let mut dp: Vec<i64> = ans.clone();\\n            let mut left = ans[0];\\n            let mut right = ans[col_len - 1];\\n            for i in 1..col_len {\\n                left = (left - 1).max(ans[i]);\\n                dp[i] = dp[i].max(left);\\n\\n                let j = col_len - 1 - i;\\n                right = (right - 1).max(ans[j]);\\n                dp[j] = dp[j].max(right);\\n            }\\n            for i in 0..col_len {\\n                ans[i] = dp[i] + i64::from(row[i]);\\n            }\\n        }\\n        *ans.iter().max().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3191611,
                "title": "java-dp-o-mn-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long ans=0;\\n        int m=points.length;\\n        int n=points[0].length;\\n        long dp[]=new long[n]; \\n        for(int i=m-1;i>=0;i--){\\n            for(int j=1;j<n;j++){\\n                dp[j]=Math.max(dp[j],dp[j-1]-1);\\n            }\\n            for(int j=n-2;j>=0;j--){\\n                dp[j]=Math.max(dp[j],dp[j+1]-1);\\n            }\\n            for(int j=0;j<n;j++){\\n                dp[j]+=points[i][j];\\n                ans=Math.max(ans,dp[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPoints(int[][] points) {\\n        long ans=0;\\n        int m=points.length;\\n        int n=points[0].length;\\n        long dp[]=new long[n]; \\n        for(int i=m-1;i>=0;i--){\\n            for(int j=1;j<n;j++){\\n                dp[j]=Math.max(dp[j],dp[j-1]-1);\\n            }\\n            for(int j=n-2;j>=0;j--){\\n                dp[j]=Math.max(dp[j],dp[j+1]-1);\\n            }\\n            for(int j=0;j<n;j++){\\n                dp[j]+=points[i][j];\\n                ans=Math.max(ans,dp[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099628,
                "title": "easiest-explanation-standard-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is like an extension of the following problem:\\n[https://leetcode.com/problems/minimum-falling-path-sum/description/]()\\n\\nI recommend you to solve the above problem first and then return to this problem!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, we will follow the standard dynamic programming approach, similar to the one in the Minimum Falling Path Sum problem; but with a twist.\\n\\n1. We maintain a **curr** array which contains the maximum sum till any i-th row.\\n2. Then we have to calculate two more arrays, **left** and **right**.\\nThe left array stores the maximum value till now to the left, and the right one does the same for the right.\\n3. To maintain these two arrays, we keep comparing curr[j] and left[j-1]-1 which means we compare the value just above and the previous maximum value-1.\\nWe follow this approach for the right array as well.\\n4. Lastly, we select the max value amongst the left and right array and points[i][j] to it to get the max sum till that point.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) \\n    {\\n        int m=points.size();\\n        int n=points[0].size();\\n        long long int curr[n];\\n\\n        for(int i=0; i<n; i++)\\n            curr[i]=points[0][i];\\n\\n        for(int i=1; i<m; i++)\\n        {\\n            long long int left[n];\\n            long long int right[n];\\n\\n            for(int j=0; j<n; j++)\\n            {\\n                if(j==0)\\n                    left[j]=curr[j];\\n                else\\n                    left[j]=max(curr[j], left[j-1]-1);\\n            }\\n\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                if(j==n-1)\\n                    right[j]=curr[j];\\n                else\\n                    right[j]=max(curr[j], right[j+1]-1);\\n            }\\n\\n            for(int j=0; j<n; j++)\\n                curr[j]=max(left[j], right[j])+points[i][j];\\n        }                \\n\\n        return *max_element(curr, curr+n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) \\n    {\\n        int m=points.size();\\n        int n=points[0].size();\\n        long long int curr[n];\\n\\n        for(int i=0; i<n; i++)\\n            curr[i]=points[0][i];\\n\\n        for(int i=1; i<m; i++)\\n        {\\n            long long int left[n];\\n            long long int right[n];\\n\\n            for(int j=0; j<n; j++)\\n            {\\n                if(j==0)\\n                    left[j]=curr[j];\\n                else\\n                    left[j]=max(curr[j], left[j-1]-1);\\n            }\\n\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                if(j==n-1)\\n                    right[j]=curr[j];\\n                else\\n                    right[j]=max(curr[j], right[j+1]-1);\\n            }\\n\\n            for(int j=0; j<n; j++)\\n                curr[j]=max(left[j], right[j])+points[i][j];\\n        }                \\n\\n        return *max_element(curr, curr+n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096225,
                "title": "dp-o-nm-left-right-abs-intuition-explained",
                "content": "The trick behind solving this in O(nm) time complexity is that for a value at index (i, j) we want to find the value in previous row(i-1)th that maximises its value. \\n\\nThe reason we have to use two different loops inside the outer loop is to simplify the definition of abs(c1-c2).\\n\\nFor a value at (i, c1) if the maximum value in previous row lies on right of it (i-1, c2) s.t. c2>c1. We know since c2>c1 abs(c2-c1)=c2-c1. So dp[i][c1]=points[i][c1]+maxRight-c1. Where maxRight=dp[i-1][c2]-c2.\\n\\nBut if it lies on the left of it i.e., c1>c2 then abs(c2-c1)=c1-c2.\\nSo dp[i][c1]=points[i][c2]+maxLeft+c1. Where maxLeft=dp[i-1][c2]+c2.\\n\\n\\nAnd for each (i,c1) we assign the bigger of the two values.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int m=points.size();\\n        int n=points[0].size();\\n        vector<vector<long long>> dp(m+1, vector<long long> (n+1, 0));\\n        long long maxLeft, maxRight;\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            maxLeft=INT_MIN;\\n            maxRight=INT_MIN;\\n            for(int j=0; j<n; j++)\\n            {\\n                maxLeft=max(maxLeft, dp[i][j+1]+(j+1));\\n                dp[i+1][j+1]=max(dp[i+1][j+1], points[i][j]+maxLeft-(j+1));\\n            }\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                maxRight=max(maxRight, dp[i][j+1]-(j+1));\\n                dp[i+1][j+1]=max(dp[i+1][j+1], points[i][j]+maxRight+(j+1));\\n            }\\n\\n        }\\n\\n        return *max_element(dp[m].begin(), dp[m].end());\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int m=points.size();\\n        int n=points[0].size();\\n        vector<vector<long long>> dp(m+1, vector<long long> (n+1, 0));\\n        long long maxLeft, maxRight;\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            maxLeft=INT_MIN;\\n            maxRight=INT_MIN;\\n            for(int j=0; j<n; j++)\\n            {\\n                maxLeft=max(maxLeft, dp[i][j+1]+(j+1));\\n                dp[i+1][j+1]=max(dp[i+1][j+1], points[i][j]+maxLeft-(j+1));\\n            }\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                maxRight=max(maxRight, dp[i][j+1]-(j+1));\\n                dp[i+1][j+1]=max(dp[i+1][j+1], points[i][j]+maxRight+(j+1));\\n            }\\n\\n        }\\n\\n        return *max_element(dp[m].begin(), dp[m].end());\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066228,
                "title": "from-o-n-m-m-to-o-n-m",
                "content": "\\n- $$O(n*m*m)$$ TLE\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& pts) {\\n        long long ans = -1;\\n        vector<vector<long long>>dp(pts.size(), vector<long long>(pts[0].size(),-1));\\n\\n        for(int i=0; i< pts[0].size();i++){\\n            ans = max(ans, dfs(pts, dp, 0, i));\\n        }\\n\\n        return ans;\\n    }\\n\\n    long long dfs(vector<vector<int>>& pts, vector<vector<long long>>& dp, int r, int c){\\n        if(dp[r][c] != -1) return dp[r][c];\\n        \\n        long long ans = 0;        \\n        \\n        for(int j = 0; j< pts[0].size(); j++)\\n            if(r+1 < pts.size()) ans = max(ans, dfs(pts, dp, r+1, j) - abs(c-j));\\n            else break;\\n        \\n\\n        dp[r][c] = ans + pts[r][c];\\n\\n        return dp[r][c];\\n    }\\n\\n\\n};\\n\\n```\\n\\n\\n- $$O(n*m)$$ Accepted\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& pts) {\\n        long long ans = -1, m = pts[0].size();\\n        vector<long long> left(m,0);\\n        vector<long long> right(m,0);\\n        vector<long long> dp(pts[0].begin(), pts[0].end());\\n        \\n        for(int i=1; i< pts.size();i++){            \\n            left[0] = dp[0];            \\n            for(int c = 1; c < m ; c++ )\\n                left[c] = max(left[c-1], dp[c] + c);\\n            \\n            \\n            right[m-1] = dp[m-1] - (m-1);\\n            for(int c = m-2; c > -1; c--)\\n                right[c] = max(right[c+1], dp[c] - c);\\n\\n\\n            for(int c = 0; c < m ; c++)\\n                dp[c] = pts[i][c] + max(left[c] - c, right[c] +c );\\n        }\\n        \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& pts) {\\n        long long ans = -1;\\n        vector<vector<long long>>dp(pts.size(), vector<long long>(pts[0].size(),-1));\\n\\n        for(int i=0; i< pts[0].size();i++){\\n            ans = max(ans, dfs(pts, dp, 0, i));\\n        }\\n\\n        return ans;\\n    }\\n\\n    long long dfs(vector<vector<int>>& pts, vector<vector<long long>>& dp, int r, int c){\\n        if(dp[r][c] != -1) return dp[r][c];\\n        \\n        long long ans = 0;        \\n        \\n        for(int j = 0; j< pts[0].size(); j++)\\n            if(r+1 < pts.size()) ans = max(ans, dfs(pts, dp, r+1, j) - abs(c-j));\\n            else break;\\n        \\n\\n        dp[r][c] = ans + pts[r][c];\\n\\n        return dp[r][c];\\n    }\\n\\n\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& pts) {\\n        long long ans = -1, m = pts[0].size();\\n        vector<long long> left(m,0);\\n        vector<long long> right(m,0);\\n        vector<long long> dp(pts[0].begin(), pts[0].end());\\n        \\n        for(int i=1; i< pts.size();i++){            \\n            left[0] = dp[0];            \\n            for(int c = 1; c < m ; c++ )\\n                left[c] = max(left[c-1], dp[c] + c);\\n            \\n            \\n            right[m-1] = dp[m-1] - (m-1);\\n            for(int c = m-2; c > -1; c--)\\n                right[c] = max(right[c+1], dp[c] - c);\\n\\n\\n            for(int c = 0; c < m ; c++)\\n                dp[c] = pts[i][c] + max(left[c] - c, right[c] +c );\\n        }\\n        \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029592,
                "title": "swift-easy-solution-with-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nfunc maxPoints(_ points: [[Int]]) -> Int {\\n    var row = points.count\\n    var col = points[0].count\\n    var dp = Array(repeating: 0, count:col)\\n    var left = Array(repeating: 0, count:col)\\n    var right = Array(repeating: 0, count:col)\\n    for i in 0..<col{\\n        dp[i] = points[0][i]\\n    }\\n    \\n    for i in 1..<row{\\n        for j in 0..<col{\\n            if j == 0{\\n                left[j] = dp[j]\\n            }else{\\n                left[j] = max(dp[j],left[j-1]-1)\\n            }\\n            \\n        }\\n        for k in (0..<col).reversed(){\\n            if k == col-1{\\n                right[k] = dp[k]\\n            }else{\\n                right[k] = max(dp[k],right[k+1]-1)\\n            }\\n        }\\n        \\n        for c in 0..<col{\\n            dp[c] = points[i][c] + max(left[c],right[c])\\n        }\\n    }\\n    return dp.max()!\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\nfunc maxPoints(_ points: [[Int]]) -> Int {\\n    var row = points.count\\n    var col = points[0].count\\n    var dp = Array(repeating: 0, count:col)\\n    var left = Array(repeating: 0, count:col)\\n    var right = Array(repeating: 0, count:col)\\n    for i in 0..<col{\\n        dp[i] = points[0][i]\\n    }\\n    \\n    for i in 1..<row{\\n        for j in 0..<col{\\n            if j == 0{\\n                left[j] = dp[j]\\n            }else{\\n                left[j] = max(dp[j],left[j-1]-1)\\n            }\\n            \\n        }\\n        for k in (0..<col).reversed(){\\n            if k == col-1{\\n                right[k] = dp[k]\\n            }else{\\n                right[k] = max(dp[k],right[k+1]-1)\\n            }\\n        }\\n        \\n        for c in 0..<col{\\n            dp[c] = points[i][c] + max(left[c],right[c])\\n        }\\n    }\\n    return dp.max()!\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017807,
                "title": "c-dp-within-dp-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int m = points[0].size();\\n        int64 dp[n][m];\\n        memset(dp, 0, sizeof(dp));\\n        for(int j = 0; j < m; j++) {\\n            dp[0][j] = points[0][j];\\n        }\\n\\n        for(int i = 1; i < n; i++) {\\n            vector<int64> ldp(m); // max from left\\n            ldp[0] = dp[i - 1][0];\\n            for(int k = 1; k < m; k++) {\\n                ldp[k] = max(ldp[k - 1], dp[i - 1][k] + k);\\n            }\\n            vector<int64> rdp(m); // max from right\\n            rdp[m - 1] = dp[i - 1][m - 1] - (m - 1);   \\n            for(int k = m - 2; k >= 0; k--) {\\n                rdp[k] = max(rdp[k + 1], dp[i - 1][k] - k);\\n            }\\n            for(int j = 0; j < m; j++) {\\n                dp[i][j] = max(ldp[j] - j + points[i][j], rdp[j] + j + points[i][j]);\\n            }\\n        }\\n\\n        int64 ans = 0;\\n        for(int j = 0; j < m; j++) {\\n            ans = max(ans, dp[n - 1][j]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n-----------------------------------------------------------------------\\n\\n/// TLE Approach : \\n\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int m = points[0].size();\\n        int dp[n][m];\\n        memset(dp, 0, sizeof(dp));\\n        for(int j = 0; j < m; j++) {\\n            dp[0][j] = points[0][j];\\n        }\\n\\n        for(int i = 1; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                for(int pj = 0; pj < m; pj++) {\\n                    dp[i][j] = max(dp[i][j], dp[i - 1][pj] + points[i][j] - abs(j - pj));\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int j = 0; j < m; j++) {\\n            ans = max(ans, dp[n - 1][j]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int m = points[0].size();\\n        int64 dp[n][m];\\n        memset(dp, 0, sizeof(dp));\\n        for(int j = 0; j < m; j++) {\\n            dp[0][j] = points[0][j];\\n        }\\n\\n        for(int i = 1; i < n; i++) {\\n            vector<int64> ldp(m); // max from left\\n            ldp[0] = dp[i - 1][0];\\n            for(int k = 1; k < m; k++) {\\n                ldp[k] = max(ldp[k - 1], dp[i - 1][k] + k);\\n            }\\n            vector<int64> rdp(m); // max from right\\n            rdp[m - 1] = dp[i - 1][m - 1] - (m - 1);   \\n            for(int k = m - 2; k >= 0; k--) {\\n                rdp[k] = max(rdp[k + 1], dp[i - 1][k] - k);\\n            }\\n            for(int j = 0; j < m; j++) {\\n                dp[i][j] = max(ldp[j] - j + points[i][j], rdp[j] + j + points[i][j]);\\n            }\\n        }\\n\\n        int64 ans = 0;\\n        for(int j = 0; j < m; j++) {\\n            ans = max(ans, dp[n - 1][j]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n-----------------------------------------------------------------------\\n\\n/// TLE Approach : \\n\\nclass Solution {\\npublic:\\n    long long maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int m = points[0].size();\\n        int dp[n][m];\\n        memset(dp, 0, sizeof(dp));\\n        for(int j = 0; j < m; j++) {\\n            dp[0][j] = points[0][j];\\n        }\\n\\n        for(int i = 1; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                for(int pj = 0; pj < m; pj++) {\\n                    dp[i][j] = max(dp[i][j], dp[i - 1][pj] + points[i][j] - abs(j - pj));\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int j = 0; j < m; j++) {\\n            ans = max(ans, dp[n - 1][j]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014098,
                "title": "python-o-mn",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxPoints(self, P: List[List[int]]) -> int:\\n        m, n = len(P), len(P[0])\\n        def left(arr):\\n            lft = [arr[0]] + [0]*(n-1)\\n            for i in range(1,n): \\n                lft[i] = max(lft[i-1]-1, arr[i])\\n            return lft\\n        def right(arr):\\n            rgt = [0]*(n-1) + [arr[-1]]\\n            for i in range(n-2, -1, -1):\\n                rgt[i] = max(rgt[i+1] - 1, arr[i])\\n            return rgt\\n        prev = P[0]\\n        for i in range(1, m):\\n            lft, rgt, cur = left(prev), right(prev), [0]*n\\n            for j in range(n):\\n                cur[j] = P[i][j] + max(lft[j], rgt[j])\\n            prev = cur\\n        return max(prev)        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, P: List[List[int]]) -> int:\\n        m, n = len(P), len(P[0])\\n        def left(arr):\\n            lft = [arr[0]] + [0]*(n-1)\\n            for i in range(1,n): \\n                lft[i] = max(lft[i-1]-1, arr[i])\\n            return lft\\n        def right(arr):\\n            rgt = [0]*(n-1) + [arr[-1]]\\n            for i in range(n-2, -1, -1):\\n                rgt[i] = max(rgt[i+1] - 1, arr[i])\\n            return rgt\\n        prev = P[0]\\n        for i in range(1, m):\\n            lft, rgt, cur = left(prev), right(prev), [0]*n\\n            for j in range(n):\\n                cur[j] = P[i][j] + max(lft[j], rgt[j])\\n            prev = cur\\n        return max(prev)        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564618,
                "content": [
                    {
                        "username": "scalacs",
                        "content": "Tried to solve this problem in contest 250 but just couldn\\'t wrap my head around to improve my O(n3) solution to O(n2). After I read other\\'s solution I think there\\'s a neat trick that is required to solve this problem. And this trick could be useful for future problems. So here\\'s what I learned.\\n\\nAs pointed out by @lee215, the most related probelm is probably [104. Best sightseeing pair ](https://leetcode.com/problems/best-sightseeing-pair).  And 104 is related to [121. Best time to buy and sell a stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n\\nIf you haven\\'t solved 121 and 104, try to solve them. Once you do that, the trick you used to improve the brute force O(n2) solution to O(n) is what you can applied here to improve the O(n3) solution to O(n2).\\n\\nI\\'m not posting my solution here, I encourage you to go thru the process (121 -> 104 -> 1937) and think about the connections between the problems, that\\'s how you really make the trick yours.\\n"
                    },
                    {
                        "username": "banand358",
                        "content": "Thank you. I was able to solve it after solving those two questions that you mentioned. "
                    },
                    {
                        "username": "whoami_112",
                        "content": "it should be (1014->931->1937) .\n"
                    },
                    {
                        "username": "Kotorin",
                        "content": "At my company, we have a general guideline (or even a rule) to not ask DP questions or do not expect the most optimal DP solutions since using DP hardly gives any signal about one\\'s ability to write good software.\\n\\nDoes Google expect the perfect DP solution in this case?"
                    },
                    {
                        "username": "flying_colors",
                        "content": "Yes. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard..."
                    },
                    {
                        "username": "jethalel",
                        "content": "Yeah not a pieceofpie."
                    },
                    {
                        "username": "ParthRohilla",
                        "content": "This problem can be broken into 2 subproblems similar to https://leetcode.com/problems/best-sightseeing-pair/ and https://leetcode.com/problems/minimum-falling-path-sum/. Give them a try if you are struggling in this one."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "This is such a good question. Don\\'t look up solution too quickly, try to optimize from O(N^3) to O(N^2), it\\'s worth it."
                    },
                    {
                        "username": "JParks1982",
                        "content": "This is NOT a medium problem. I\\'ve solved a number of \"hard\" problems for which the solution was more intuitive than this."
                    }
                ]
            },
            {
                "id": 1568746,
                "content": [
                    {
                        "username": "scalacs",
                        "content": "Tried to solve this problem in contest 250 but just couldn\\'t wrap my head around to improve my O(n3) solution to O(n2). After I read other\\'s solution I think there\\'s a neat trick that is required to solve this problem. And this trick could be useful for future problems. So here\\'s what I learned.\\n\\nAs pointed out by @lee215, the most related probelm is probably [104. Best sightseeing pair ](https://leetcode.com/problems/best-sightseeing-pair).  And 104 is related to [121. Best time to buy and sell a stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n\\nIf you haven\\'t solved 121 and 104, try to solve them. Once you do that, the trick you used to improve the brute force O(n2) solution to O(n) is what you can applied here to improve the O(n3) solution to O(n2).\\n\\nI\\'m not posting my solution here, I encourage you to go thru the process (121 -> 104 -> 1937) and think about the connections between the problems, that\\'s how you really make the trick yours.\\n"
                    },
                    {
                        "username": "banand358",
                        "content": "Thank you. I was able to solve it after solving those two questions that you mentioned. "
                    },
                    {
                        "username": "whoami_112",
                        "content": "it should be (1014->931->1937) .\n"
                    },
                    {
                        "username": "Kotorin",
                        "content": "At my company, we have a general guideline (or even a rule) to not ask DP questions or do not expect the most optimal DP solutions since using DP hardly gives any signal about one\\'s ability to write good software.\\n\\nDoes Google expect the perfect DP solution in this case?"
                    },
                    {
                        "username": "flying_colors",
                        "content": "Yes. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard..."
                    },
                    {
                        "username": "jethalel",
                        "content": "Yeah not a pieceofpie."
                    },
                    {
                        "username": "ParthRohilla",
                        "content": "This problem can be broken into 2 subproblems similar to https://leetcode.com/problems/best-sightseeing-pair/ and https://leetcode.com/problems/minimum-falling-path-sum/. Give them a try if you are struggling in this one."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "This is such a good question. Don\\'t look up solution too quickly, try to optimize from O(N^3) to O(N^2), it\\'s worth it."
                    },
                    {
                        "username": "JParks1982",
                        "content": "This is NOT a medium problem. I\\'ve solved a number of \"hard\" problems for which the solution was more intuitive than this."
                    }
                ]
            },
            {
                "id": 1733413,
                "content": [
                    {
                        "username": "scalacs",
                        "content": "Tried to solve this problem in contest 250 but just couldn\\'t wrap my head around to improve my O(n3) solution to O(n2). After I read other\\'s solution I think there\\'s a neat trick that is required to solve this problem. And this trick could be useful for future problems. So here\\'s what I learned.\\n\\nAs pointed out by @lee215, the most related probelm is probably [104. Best sightseeing pair ](https://leetcode.com/problems/best-sightseeing-pair).  And 104 is related to [121. Best time to buy and sell a stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n\\nIf you haven\\'t solved 121 and 104, try to solve them. Once you do that, the trick you used to improve the brute force O(n2) solution to O(n) is what you can applied here to improve the O(n3) solution to O(n2).\\n\\nI\\'m not posting my solution here, I encourage you to go thru the process (121 -> 104 -> 1937) and think about the connections between the problems, that\\'s how you really make the trick yours.\\n"
                    },
                    {
                        "username": "banand358",
                        "content": "Thank you. I was able to solve it after solving those two questions that you mentioned. "
                    },
                    {
                        "username": "whoami_112",
                        "content": "it should be (1014->931->1937) .\n"
                    },
                    {
                        "username": "Kotorin",
                        "content": "At my company, we have a general guideline (or even a rule) to not ask DP questions or do not expect the most optimal DP solutions since using DP hardly gives any signal about one\\'s ability to write good software.\\n\\nDoes Google expect the perfect DP solution in this case?"
                    },
                    {
                        "username": "flying_colors",
                        "content": "Yes. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard..."
                    },
                    {
                        "username": "jethalel",
                        "content": "Yeah not a pieceofpie."
                    },
                    {
                        "username": "ParthRohilla",
                        "content": "This problem can be broken into 2 subproblems similar to https://leetcode.com/problems/best-sightseeing-pair/ and https://leetcode.com/problems/minimum-falling-path-sum/. Give them a try if you are struggling in this one."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "This is such a good question. Don\\'t look up solution too quickly, try to optimize from O(N^3) to O(N^2), it\\'s worth it."
                    },
                    {
                        "username": "JParks1982",
                        "content": "This is NOT a medium problem. I\\'ve solved a number of \"hard\" problems for which the solution was more intuitive than this."
                    }
                ]
            },
            {
                "id": 1994938,
                "content": [
                    {
                        "username": "scalacs",
                        "content": "Tried to solve this problem in contest 250 but just couldn\\'t wrap my head around to improve my O(n3) solution to O(n2). After I read other\\'s solution I think there\\'s a neat trick that is required to solve this problem. And this trick could be useful for future problems. So here\\'s what I learned.\\n\\nAs pointed out by @lee215, the most related probelm is probably [104. Best sightseeing pair ](https://leetcode.com/problems/best-sightseeing-pair).  And 104 is related to [121. Best time to buy and sell a stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n\\nIf you haven\\'t solved 121 and 104, try to solve them. Once you do that, the trick you used to improve the brute force O(n2) solution to O(n) is what you can applied here to improve the O(n3) solution to O(n2).\\n\\nI\\'m not posting my solution here, I encourage you to go thru the process (121 -> 104 -> 1937) and think about the connections between the problems, that\\'s how you really make the trick yours.\\n"
                    },
                    {
                        "username": "banand358",
                        "content": "Thank you. I was able to solve it after solving those two questions that you mentioned. "
                    },
                    {
                        "username": "whoami_112",
                        "content": "it should be (1014->931->1937) .\n"
                    },
                    {
                        "username": "Kotorin",
                        "content": "At my company, we have a general guideline (or even a rule) to not ask DP questions or do not expect the most optimal DP solutions since using DP hardly gives any signal about one\\'s ability to write good software.\\n\\nDoes Google expect the perfect DP solution in this case?"
                    },
                    {
                        "username": "flying_colors",
                        "content": "Yes. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard..."
                    },
                    {
                        "username": "jethalel",
                        "content": "Yeah not a pieceofpie."
                    },
                    {
                        "username": "ParthRohilla",
                        "content": "This problem can be broken into 2 subproblems similar to https://leetcode.com/problems/best-sightseeing-pair/ and https://leetcode.com/problems/minimum-falling-path-sum/. Give them a try if you are struggling in this one."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "This is such a good question. Don\\'t look up solution too quickly, try to optimize from O(N^3) to O(N^2), it\\'s worth it."
                    },
                    {
                        "username": "JParks1982",
                        "content": "This is NOT a medium problem. I\\'ve solved a number of \"hard\" problems for which the solution was more intuitive than this."
                    }
                ]
            },
            {
                "id": 1914978,
                "content": [
                    {
                        "username": "scalacs",
                        "content": "Tried to solve this problem in contest 250 but just couldn\\'t wrap my head around to improve my O(n3) solution to O(n2). After I read other\\'s solution I think there\\'s a neat trick that is required to solve this problem. And this trick could be useful for future problems. So here\\'s what I learned.\\n\\nAs pointed out by @lee215, the most related probelm is probably [104. Best sightseeing pair ](https://leetcode.com/problems/best-sightseeing-pair).  And 104 is related to [121. Best time to buy and sell a stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n\\nIf you haven\\'t solved 121 and 104, try to solve them. Once you do that, the trick you used to improve the brute force O(n2) solution to O(n) is what you can applied here to improve the O(n3) solution to O(n2).\\n\\nI\\'m not posting my solution here, I encourage you to go thru the process (121 -> 104 -> 1937) and think about the connections between the problems, that\\'s how you really make the trick yours.\\n"
                    },
                    {
                        "username": "banand358",
                        "content": "Thank you. I was able to solve it after solving those two questions that you mentioned. "
                    },
                    {
                        "username": "whoami_112",
                        "content": "it should be (1014->931->1937) .\n"
                    },
                    {
                        "username": "Kotorin",
                        "content": "At my company, we have a general guideline (or even a rule) to not ask DP questions or do not expect the most optimal DP solutions since using DP hardly gives any signal about one\\'s ability to write good software.\\n\\nDoes Google expect the perfect DP solution in this case?"
                    },
                    {
                        "username": "flying_colors",
                        "content": "Yes. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard..."
                    },
                    {
                        "username": "jethalel",
                        "content": "Yeah not a pieceofpie."
                    },
                    {
                        "username": "ParthRohilla",
                        "content": "This problem can be broken into 2 subproblems similar to https://leetcode.com/problems/best-sightseeing-pair/ and https://leetcode.com/problems/minimum-falling-path-sum/. Give them a try if you are struggling in this one."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "This is such a good question. Don\\'t look up solution too quickly, try to optimize from O(N^3) to O(N^2), it\\'s worth it."
                    },
                    {
                        "username": "JParks1982",
                        "content": "This is NOT a medium problem. I\\'ve solved a number of \"hard\" problems for which the solution was more intuitive than this."
                    }
                ]
            },
            {
                "id": 2071463,
                "content": [
                    {
                        "username": "scalacs",
                        "content": "Tried to solve this problem in contest 250 but just couldn\\'t wrap my head around to improve my O(n3) solution to O(n2). After I read other\\'s solution I think there\\'s a neat trick that is required to solve this problem. And this trick could be useful for future problems. So here\\'s what I learned.\\n\\nAs pointed out by @lee215, the most related probelm is probably [104. Best sightseeing pair ](https://leetcode.com/problems/best-sightseeing-pair).  And 104 is related to [121. Best time to buy and sell a stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n\\nIf you haven\\'t solved 121 and 104, try to solve them. Once you do that, the trick you used to improve the brute force O(n2) solution to O(n) is what you can applied here to improve the O(n3) solution to O(n2).\\n\\nI\\'m not posting my solution here, I encourage you to go thru the process (121 -> 104 -> 1937) and think about the connections between the problems, that\\'s how you really make the trick yours.\\n"
                    },
                    {
                        "username": "banand358",
                        "content": "Thank you. I was able to solve it after solving those two questions that you mentioned. "
                    },
                    {
                        "username": "whoami_112",
                        "content": "it should be (1014->931->1937) .\n"
                    },
                    {
                        "username": "Kotorin",
                        "content": "At my company, we have a general guideline (or even a rule) to not ask DP questions or do not expect the most optimal DP solutions since using DP hardly gives any signal about one\\'s ability to write good software.\\n\\nDoes Google expect the perfect DP solution in this case?"
                    },
                    {
                        "username": "flying_colors",
                        "content": "Yes. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard..."
                    },
                    {
                        "username": "jethalel",
                        "content": "Yeah not a pieceofpie."
                    },
                    {
                        "username": "ParthRohilla",
                        "content": "This problem can be broken into 2 subproblems similar to https://leetcode.com/problems/best-sightseeing-pair/ and https://leetcode.com/problems/minimum-falling-path-sum/. Give them a try if you are struggling in this one."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "This is such a good question. Don\\'t look up solution too quickly, try to optimize from O(N^3) to O(N^2), it\\'s worth it."
                    },
                    {
                        "username": "JParks1982",
                        "content": "This is NOT a medium problem. I\\'ve solved a number of \"hard\" problems for which the solution was more intuitive than this."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Genetic Difference Query",
        "question_content": "<p>There is a rooted tree consisting of <code>n</code> nodes numbered <code>0</code> to <code>n - 1</code>. Each node&#39;s number denotes its <strong>unique genetic value</strong> (i.e. the genetic value of node <code>x</code> is <code>x</code>). The <strong>genetic difference</strong> between two genetic values is defined as the <strong>bitwise-</strong><strong>XOR</strong> of their values. You are given the integer array <code>parents</code>, where <code>parents[i]</code> is the parent for node <code>i</code>. If node <code>x</code> is the <strong>root</strong> of the tree, then <code>parents[x] == -1</code>.</p>\n\n<p>You are also given the array <code>queries</code> where <code>queries[i] = [node<sub>i</sub>, val<sub>i</sub>]</code>. For each query <code>i</code>, find the <strong>maximum genetic difference</strong> between <code>val<sub>i</sub></code> and <code>p<sub>i</sub></code>, where <code>p<sub>i</sub></code> is the genetic value of any node that is on the path between <code>node<sub>i</sub></code> and the root (including <code>node<sub>i</sub></code> and the root). More formally, you want to maximize <code>val<sub>i</sub> XOR p<sub>i</sub></code>.</p>\n\n<p>Return <em>an array </em><code>ans</code><em> where </em><code>ans[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/c1.png\" style=\"width: 118px; height: 163px;\" />\n<pre>\n<strong>Input:</strong> parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]\n<strong>Output:</strong> [2,3,7]\n<strong>Explanation: </strong>The queries are processed as follows:\n- [0,2]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2.\n- [3,2]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3.\n- [2,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/c2.png\" style=\"width: 256px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]\n<strong>Output:</strong> [6,14,7]\n<strong>Explanation: </strong>The queries are processed as follows:\n- [4,6]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6.\n- [1,15]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14.\n- [0,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= parents.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= parents[i] &lt;= parents.length - 1</code> for every node <code>i</code> that is <strong>not</strong> the root.</li>\n\t<li><code>parents[root] == -1</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= node<sub>i</sub> &lt;= parents.length - 1</code></li>\n\t<li><code>0 &lt;= val<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1344913,
                "title": "c-java-python-dfs-trie-compute-queries-by-nodes-clean-concise",
                "content": "**Idea**\\n- DFS from `root` to its children, so we can have the path from `root` down to current `node`.\\n- Build Binary Trie, so we can get the maximum XOR result between a value `val` and a number in our Trie in `O(1)`, our Trie will keep all elements in the path from `root` down to the current `node`.\\n\\t- When visit the `node`, we add it into our Trie.\\n\\t- After finishing visit the `node`, we remove it from our Trie.\\n- Compute queries by nodes.\\n- How to get the maximum XOR result between a value `val` and a number in our Trie in `O(1)`? \\n\\t- The idea is exactly the same with this problem **[421. Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/1345905)**\\n\\t- Our Trie will store numbers in form of their 18 bit presentation, store the **most significant bit** near the root.\\n\\t- Why store 18 bits? Because 17th bit (zero-based indexing) is `2^17=131072` can present the maximum number which is `10^5`.\\n\\t- Since in `XOR` operator, 2 bit is different will result bit `1`, that is `1^0=1`, `0^1=1`, otherwise will be 0.\\n\\t- To find the maximum XOR of a value `val` with numbers in our Trie, we traverse 18 bits of `val` with the  **most significant bit** first.\\n\\t\\t- If the current bit of `val` is `1`, we check if exist a number with bit `0` in the Trie, if exist then the bit result is `1`.\\n\\t\\t- If the current bit of `val` is `0`, we check if exist a number with bit `1` in the Trie, if exist then the bit result is `1`.\\n\\t\\t- Else the bit result is `0`.\\n\\n<iframe src=\"https://leetcode.com/playground/Smt9iKn3/shared\" frameBorder=\"0\" width=\"100%\" height=\"800\"></iframe>\\n\\nComplexity:\\n- Time: `O(18 * (N + M))`, where `N <= 10^5` is number of nodes, `M <= 3 * 10^4` is number of queries\\n- Space: `O(18 * (N + M))`\\n\\n---\\n**BONUS C++ use TriePool, (608-484)/608 ~ 20% faster than new TrieNode()**\\n<iframe src=\"https://leetcode.com/playground/gVa3G4Xk/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "solutionTags": [],
                "code": "**Idea**\\n- DFS from `root` to its children, so we can have the path from `root` down to current `node`.\\n- Build Binary Trie, so we can get the maximum XOR result between a value `val` and a number in our Trie in `O(1)`, our Trie will keep all elements in the path from `root` down to the current `node`.\\n\\t- When visit the `node`, we add it into our Trie.\\n\\t- After finishing visit the `node`, we remove it from our Trie.\\n- Compute queries by nodes.\\n- How to get the maximum XOR result between a value `val` and a number in our Trie in `O(1)`? \\n\\t- The idea is exactly the same with this problem **[421. Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/1345905)**\\n\\t- Our Trie will store numbers in form of their 18 bit presentation, store the **most significant bit** near the root.\\n\\t- Why store 18 bits? Because 17th bit (zero-based indexing) is `2^17=131072` can present the maximum number which is `10^5`.\\n\\t- Since in `XOR` operator, 2 bit is different will result bit `1`, that is `1^0=1`, `0^1=1`, otherwise will be 0.\\n\\t- To find the maximum XOR of a value `val` with numbers in our Trie, we traverse 18 bits of `val` with the  **most significant bit** first.\\n\\t\\t- If the current bit of `val` is `1`, we check if exist a number with bit `0` in the Trie, if exist then the bit result is `1`.\\n\\t\\t- If the current bit of `val` is `0`, we check if exist a number with bit `1` in the Trie, if exist then the bit result is `1`.\\n\\t\\t- Else the bit result is `0`.\\n\\n<iframe src=\"https://leetcode.com/playground/Smt9iKn3/shared\" frameBorder=\"0\" width=\"100%\" height=\"800\"></iframe>\\n\\nComplexity:\\n- Time: `O(18 * (N + M))`, where `N <= 10^5` is number of nodes, `M <= 3 * 10^4` is number of queries\\n- Space: `O(18 * (N + M))`\\n\\n---\\n**BONUS C++ use TriePool, (608-484)/608 ~ 20% faster than new TrieNode()**\\n<iframe src=\"https://leetcode.com/playground/gVa3G4Xk/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1345128,
                "title": "bit-trie-with-picture",
                "content": "There are 3 sub-problems that we need to solve here. I solved similar problems before, but this one is just long so I did not finish it in time.\\n\\n#### 1: Answer Query in O(log n)\\nSay, we do a query for a node. That node can have up to `n` ancestors, so it can take O(n) to answer that query. To answer it in O(log n), we need to build a **bit trie**. \\n\\nTo understand how the **bit trie** works, check [1803. Count Pairs With XOR in a Range](https://leetcode.com/problems/count-pairs-with-xor-in-a-range/discuss/1122495/C%2B%2B-with-picture). Copying a picture here for your reference.\\n\\n![image](https://assets.leetcode.com/users/images/a594079c-781f-40f1-9bf4-6434d881e4c9_1626586346.1496418.png)\\n\\n#### 2: Build Bit Trie\\nIt is expensive to build a **bit trie** for each node. Instead, we can traverse our genetic **tree** from the root using DFS, and add/remove numbers to/from **bit trie**. A trick here is to count numbers that hit each node of **bit trie**. Instead of actually removing a number, we just decrement the count for respective nodes.\\n\\nTo traverse our genetic **tree** from the root, we need to build an adjacency list (`al`).\\n\\n#### 3: Match Nodes and Queries\\nAs we traverse our genetic **tree**, we now have the populated **bit trie** for each node. So, we can efficiently answer all queries for that node. To find those queries, we can use a hashmap `q` to link a node to all its queries `{i, val}`, where `i` is the original order of a query.\\n\\n**C++**\\n```cpp\\nstruct Trie {\\n    Trie* ch[2] = {};\\n    int cnt = 0;\\n    void increment(int val, int d, int pos = 17) {\\n        cnt += d;\\n        if (pos >= 0) {\\n            bool b = val & (1 << pos);\\n            if (ch[b] == nullptr)\\n                ch[b] = new Trie();\\n            ch[b]->increment(val, d, pos - 1);\\n        }\\n    }\\n    int match(int val, int pos = 17) {\\n        if (pos < 0)\\n            return 0;\\n        bool b = val & (1 << pos);\\n        if (ch[!b] != nullptr && ch[!b]->cnt > 0)\\n            return (1 << pos) + ch[!b]->match(val, pos - 1);\\n        return ch[b] == nullptr ? 0 : ch[b]->match(val, pos - 1);\\n    }\\n};\\nTrie t;\\nvoid dfs(unordered_map<int, vector<pair<int, int>>> &q, vector<vector<int>> &al, vector<int> &res, int ni) {\\n    t.increment(ni, 1);\\n    for (auto [i, val] : q[ni])\\n        res[i] = t.match(val);\\n    for (auto nj : al[ni])\\n        dfs(q, al, res, nj);\\n    t.increment(ni, -1);\\n}\\nvector<int> maxGeneticDifference(vector<int>& pars, vector<vector<int>>& qs) {\\n    vector<vector<int>> al(pars.size());\\n    vector<int> res(qs.size());\\n    int root = -1;\\n    unordered_map<int, vector<pair<int, int>>> q;\\n    for (int i = 0; i < qs.size(); ++i)\\n        q[qs[i][0]].push_back({i, qs[i][1]});\\n    for (int i = 0; i < pars.size(); ++i)\\n        if (pars[i] == -1)\\n            root = i;\\n        else\\n            al[pars[i]].push_back(i);\\n    dfs(q, al, res, root);\\n    return res;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nstruct Trie {\\n    Trie* ch[2] = {};\\n    int cnt = 0;\\n    void increment(int val, int d, int pos = 17) {\\n        cnt += d;\\n        if (pos >= 0) {\\n            bool b = val & (1 << pos);\\n            if (ch[b] == nullptr)\\n                ch[b] = new Trie();\\n            ch[b]->increment(val, d, pos - 1);\\n        }\\n    }\\n    int match(int val, int pos = 17) {\\n        if (pos < 0)\\n            return 0;\\n        bool b = val & (1 << pos);\\n        if (ch[!b] != nullptr && ch[!b]->cnt > 0)\\n            return (1 << pos) + ch[!b]->match(val, pos - 1);\\n        return ch[b] == nullptr ? 0 : ch[b]->match(val, pos - 1);\\n    }\\n};\\nTrie t;\\nvoid dfs(unordered_map<int, vector<pair<int, int>>> &q, vector<vector<int>> &al, vector<int> &res, int ni) {\\n    t.increment(ni, 1);\\n    for (auto [i, val] : q[ni])\\n        res[i] = t.match(val);\\n    for (auto nj : al[ni])\\n        dfs(q, al, res, nj);\\n    t.increment(ni, -1);\\n}\\nvector<int> maxGeneticDifference(vector<int>& pars, vector<vector<int>>& qs) {\\n    vector<vector<int>> al(pars.size());\\n    vector<int> res(qs.size());\\n    int root = -1;\\n    unordered_map<int, vector<pair<int, int>>> q;\\n    for (int i = 0; i < qs.size(); ++i)\\n        q[qs[i][0]].push_back({i, qs[i][1]});\\n    for (int i = 0; i < pars.size(); ++i)\\n        if (pars[i] == -1)\\n            root = i;\\n        else\\n            al[pars[i]].push_back(i);\\n    dfs(q, al, res, root);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345574,
                "title": "python-2-solutions-trie-dfs-and-without-trie-explained",
                "content": "This solution is inspired by several other solutions I saw here in discussion. The main idea you should ask youself when you see this problem: what to do with XOR? You should look for familiar patterns and the most closest problem here is **421. Maximum XOR of Two Numbers in an Array**. There are different ways to solve this problem and it is very important to understand differend ways so you can extend it for more general cases like we have here.\\n\\nGeneral idea is the following: we traverse our tree using dfs and each time we update our **trie**, where we keep binary representation of numbers. We need both to insert and to remove elements from trie, because once we finish traverse some node in dfs, we no longer need it. Here I spend some time in python to avoid TLE, and finally we have Trie class as following:\\n\\n1. We keep embedded dictionary of dictionaries. Key `-1` corresponding for frequency: we need this when we add and delete binary numbers from trie.\\n2. Also we use knowledge that all `vals` in queries are no bigger than `2*10^5 < 2^18`. so we always will add binary numbers with leading zeroes, for example when we add `11101`, we add `000000000000011101` in fact. Also we update frequencies: increase if we add and decrease if we delete.\\n3. Now, for `find` it is classical if you already solved **421**: Each time we try to find bit such that XOR of bits is equal to `1` and go to accoridng branch of our trie. If it is not possible, we go to another branch. Note, that some frequencies can be `0`, so we need to make sure that we go only if it is not zero.\\n\\nNow, let us talk about original funcion:\\n1. First of all, we need to rearrange queries to defaultdict `Q`: where for each node we keep pair `(index, value)`.\\n2. Also we create graph from our `parents` nodes.\\n3. Now, we traverse our tree, using dfs: first insert value when we first visit it, then for each pair `i, val` for this node update `ans`, run function recursively for all children and finally remove value from trie.\\n\\n#### Complexity\\nLet `M` be maximum number of bits possible in queries. Then we have time complexity `O((n+q)*M)`, where `n` is size of our tree and `q` is number of queries. Time complexity is `O(n*M)`. In python however it works quite slow, even though I use ints, not strings, I was a bit suprised that it did not make my code faster, anybody have any ideas?\\n\\n#### Code\\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.root = {-1: 0}\\n\\n    def insert(self, num, f):\\n        d = self.root\\n        for i in range(18, -1, -1):\\n            bit = (num >> i) & 1\\n            d = d.setdefault(bit, dict())\\n            d[-1] = d.get(-1, 0) + f\\n\\n    def find(self, num):\\n        node = self.root\\n        res = 0\\n        for i in range(18, -1, -1):\\n            bit = (num >> i) & 1\\n            desired = 1-bit if 1-bit in node and node[1-bit][-1] > 0 else bit\\n            res += (desired ^ bit) << i\\n            node = node[desired]\\n        return res\\n\\nclass Solution:\\n    def maxGeneticDifference(self, parents, queries):\\n        Q, graph = defaultdict(list), defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            Q[node].append((i, val))\\n            \\n        for i, x in enumerate(parents):\\n            graph[x].append(i)\\n        \\n        ans, trie = [-1 for _ in queries], Trie()\\n        \\n        def dfs(node):\\n            trie.insert(node, 1)\\n            for i, val in Q[node]: ans[i] = trie.find(val)\\n            for neib in graph[node]: dfs(neib)\\n            trie.insert(node, -1)\\n                \\n        dfs(graph[-1][0]) \\n        return ans\\n```\\n\\n#### Solution 2\\nMy trie solution was working not very fast, so I decided to rewrite it, using the following idea: imagine, that we have number `1011`, then we going to add all prefixes to list of Counters: `1` to prefixes of length `0,` `10` to prefixes of length `2` and so on. Then it is easier to update all counters when we add or remove some number. Also the logic to find the maximum exactly the same as previous and `dfs` prat is almost the same.\\n**UPD** If we use not Counters, but lists then we have more gain in speed, now it is around 5000ms (choose one of two lines where we defined cnts)\\n\\n1.  `cnts = [Counter() for _ in range(M)]`\\n2.  `cnts = [[0]*(1<<(M-i)) for i in range(M)]`\\n\\n#### Complexity\\nIt is the same as previous approach.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxGeneticDifference(self, parents, queries):\\n        def query(num):\\n            ans = 0\\n            for i in range(M-1, -1, -1):\\n                bit = (num >> i) & 1\\n                c1, c2 = ans * 2 + (1-bit), ans * 2 + bit\\n                ans = c1 if cnts[i][c1] > 0 else c2\\n            return ans ^ num\\n        \\n        Q, graph = defaultdict(list), defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            Q[node].append((i,val))\\n            \\n        for i, x in enumerate(parents):\\n            graph[x].append(i)\\n            \\n        ans, M = [-1 for _ in queries], 18\\n        cnts = [[0]*(1<<(M-i)) for i in range(M)]\\n        \\n        def dfs(node):\\n            for i in range(M): cnts[i][node>>i] += 1\\n            for i, val in Q[node]: ans[i] = query(val)\\n            for neib in graph[node]: dfs(neib)\\n            for i in range(M): cnts[i][node>>i] -= 1\\n                \\n        dfs(graph[-1][0]) \\n        return ans\\n```\\n\\n#### Similar problems\\n**421.** Maximum XOR of Two Numbers in an Array\\n**1803.** Count Pairs With XOR in a Range\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```python\\nclass Trie:\\n    def __init__(self):\\n        self.root = {-1: 0}\\n\\n    def insert(self, num, f):\\n        d = self.root\\n        for i in range(18, -1, -1):\\n            bit = (num >> i) & 1\\n            d = d.setdefault(bit, dict())\\n            d[-1] = d.get(-1, 0) + f\\n\\n    def find(self, num):\\n        node = self.root\\n        res = 0\\n        for i in range(18, -1, -1):\\n            bit = (num >> i) & 1\\n            desired = 1-bit if 1-bit in node and node[1-bit][-1] > 0 else bit\\n            res += (desired ^ bit) << i\\n            node = node[desired]\\n        return res\\n\\nclass Solution:\\n    def maxGeneticDifference(self, parents, queries):\\n        Q, graph = defaultdict(list), defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            Q[node].append((i, val))\\n            \\n        for i, x in enumerate(parents):\\n            graph[x].append(i)\\n        \\n        ans, trie = [-1 for _ in queries], Trie()\\n        \\n        def dfs(node):\\n            trie.insert(node, 1)\\n            for i, val in Q[node]: ans[i] = trie.find(val)\\n            for neib in graph[node]: dfs(neib)\\n            trie.insert(node, -1)\\n                \\n        dfs(graph[-1][0]) \\n        return ans\\n```\n```python\\nclass Solution:\\n    def maxGeneticDifference(self, parents, queries):\\n        def query(num):\\n            ans = 0\\n            for i in range(M-1, -1, -1):\\n                bit = (num >> i) & 1\\n                c1, c2 = ans * 2 + (1-bit), ans * 2 + bit\\n                ans = c1 if cnts[i][c1] > 0 else c2\\n            return ans ^ num\\n        \\n        Q, graph = defaultdict(list), defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            Q[node].append((i,val))\\n            \\n        for i, x in enumerate(parents):\\n            graph[x].append(i)\\n            \\n        ans, M = [-1 for _ in queries], 18\\n        cnts = [[0]*(1<<(M-i)) for i in range(M)]\\n        \\n        def dfs(node):\\n            for i in range(M): cnts[i][node>>i] += 1\\n            for i, val in Q[node]: ans[i] = query(val)\\n            for neib in graph[node]: dfs(neib)\\n            for i in range(M): cnts[i][node>>i] -= 1\\n                \\n        dfs(graph[-1][0]) \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344872,
                "title": "trie-dfs-similar-questions",
                "content": "\\n1. Start DFS from root.\\n2. Add each node to a trie as we traverse. Remove the node from trie after all of its child nodes are traversed. This way, we will maintain all the nodes that are in path from current to root.\\n3. To find max value, for each ```i```th bit(```i``` from most significant bit```logn``` -> least significant bit `0`) that is set to ```X```  in ```query.val```, see if there is a trie node with value ```!X```. This will help us get this significant bit ```greedily``` set to ```1``` (since ```X ^ !X``` = 1)\\n\\n```\\nclass Solution {\\n    int logN = (int)(Math.log10(100000) / Math.log10(2)) + 1;\\n    public class Trie {\\n        Node root = new Node();\\n\\n        public class Node {\\n            Node[] child = new Node[2];\\n            int count = 0;\\n        }\\n\\n        public void insert(int num) {\\n            Node start = root;\\n            for (int i = logN; i >= 0; --i) {\\n                if (start.child[((num >> i) & 1)] == null) {\\n                    start.child[((num >> i) & 1)] = new Node();\\n                }\\n                start = start.child[((num >> i) & 1)];\\n                start.count++;\\n            }\\n        }\\n\\n        public void remove(int num) {\\n            Node start = root;\\n            for (int i = logN; i >= 0; --i) {\\n                start.child[((num >> i) & 1)].count--;\\n                if (start.child[((num >> i) & 1)].count == 0) {\\n                    start.child[((num >> i) & 1)] = null;\\n                    return;\\n                }\\n                start = start.child[((num >> i) & 1)];\\n            }\\n        }\\n\\n        public int max(int num) {\\n            Node start = root;\\n            int max = 0;\\n            for (int i = logN; i >= 0; --i) {\\n                if (start.child[1 - ((num >> i) & 1)] != null) {\\n                    max += (1 << i);\\n                    start = start.child[1 - ((num >> i) & 1)];\\n                } else if (start.child[((num >> i) & 1)] != null) {\\n                    start = start.child[((num >> i) & 1)];\\n                }\\n            }\\n\\n            return max;\\n        }\\n    }\\n\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        List<List<Integer>> g = new ArrayList<>();\\n        int n = parents.length;\\n\\n        for (int i = 0; i < n; ++i) {\\n            g.add(new ArrayList<>());\\n        }\\n        int root = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (parents[i] != -1) {\\n                g.get(parents[i]).add(i);\\n                g.get(i).add(parents[i]);\\n            } else {\\n                root = i;\\n            }\\n        }\\n        int m = queries.length;\\n        int[] ans = new int[m];\\n\\n        List<List<Integer>> q = new ArrayList<>();\\n\\n        for (int i = 0; i < n; ++i) q.add(new ArrayList<>());\\n        for (int i = 0; i < m; ++i) {\\n            q.get(queries[i][0]).add(i);\\n        }\\n\\n        Trie t = new Trie();\\n        dfs(root, g, q, queries, ans, t, -1);\\n\\n        return ans;\\n    }\\n\\n    // Trie maintains all the elements that are there from cur to root of tree\\n    private void dfs(int cur, List<List<Integer>> g, List<List<Integer>> q, int[][] queries, int[] ans, Trie t, int last) {\\n        t.insert(cur);\\n        for (int i = 0; i < q.get(cur).size(); ++i) {\\n            ans[q.get(cur).get(i)] = t.max(queries[q.get(cur).get(i)][1]);\\n        }\\n        for (int i = 0; i < g.get(cur).size(); ++i) {\\n            int ntb = g.get(cur).get(i);\\n            if (ntb != last) {\\n                dfs(ntb, g, q, queries, ans, t, cur);\\n            }\\n        }\\n        t.remove(cur);\\n    }\\n}\\n```\\nComplexity : ```O(n*log(n) + q*log(n))```\\n\\nSimilar questions: \\nhttps://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/\\nhttps://leetcode.com/problems/maximum-xor-with-an-element-from-array/",
                "solutionTags": [],
                "code": "```i```\n```i```\n```logn```\n```X```\n```query.val```\n```!X```\n```greedily```\n```1```\n```X ^ !X```\n```\\nclass Solution {\\n    int logN = (int)(Math.log10(100000) / Math.log10(2)) + 1;\\n    public class Trie {\\n        Node root = new Node();\\n\\n        public class Node {\\n            Node[] child = new Node[2];\\n            int count = 0;\\n        }\\n\\n        public void insert(int num) {\\n            Node start = root;\\n            for (int i = logN; i >= 0; --i) {\\n                if (start.child[((num >> i) & 1)] == null) {\\n                    start.child[((num >> i) & 1)] = new Node();\\n                }\\n                start = start.child[((num >> i) & 1)];\\n                start.count++;\\n            }\\n        }\\n\\n        public void remove(int num) {\\n            Node start = root;\\n            for (int i = logN; i >= 0; --i) {\\n                start.child[((num >> i) & 1)].count--;\\n                if (start.child[((num >> i) & 1)].count == 0) {\\n                    start.child[((num >> i) & 1)] = null;\\n                    return;\\n                }\\n                start = start.child[((num >> i) & 1)];\\n            }\\n        }\\n\\n        public int max(int num) {\\n            Node start = root;\\n            int max = 0;\\n            for (int i = logN; i >= 0; --i) {\\n                if (start.child[1 - ((num >> i) & 1)] != null) {\\n                    max += (1 << i);\\n                    start = start.child[1 - ((num >> i) & 1)];\\n                } else if (start.child[((num >> i) & 1)] != null) {\\n                    start = start.child[((num >> i) & 1)];\\n                }\\n            }\\n\\n            return max;\\n        }\\n    }\\n\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        List<List<Integer>> g = new ArrayList<>();\\n        int n = parents.length;\\n\\n        for (int i = 0; i < n; ++i) {\\n            g.add(new ArrayList<>());\\n        }\\n        int root = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (parents[i] != -1) {\\n                g.get(parents[i]).add(i);\\n                g.get(i).add(parents[i]);\\n            } else {\\n                root = i;\\n            }\\n        }\\n        int m = queries.length;\\n        int[] ans = new int[m];\\n\\n        List<List<Integer>> q = new ArrayList<>();\\n\\n        for (int i = 0; i < n; ++i) q.add(new ArrayList<>());\\n        for (int i = 0; i < m; ++i) {\\n            q.get(queries[i][0]).add(i);\\n        }\\n\\n        Trie t = new Trie();\\n        dfs(root, g, q, queries, ans, t, -1);\\n\\n        return ans;\\n    }\\n\\n    // Trie maintains all the elements that are there from cur to root of tree\\n    private void dfs(int cur, List<List<Integer>> g, List<List<Integer>> q, int[][] queries, int[] ans, Trie t, int last) {\\n        t.insert(cur);\\n        for (int i = 0; i < q.get(cur).size(); ++i) {\\n            ans[q.get(cur).get(i)] = t.max(queries[q.get(cur).get(i)][1]);\\n        }\\n        for (int i = 0; i < g.get(cur).size(); ++i) {\\n            int ntb = g.get(cur).get(i);\\n            if (ntb != last) {\\n                dfs(ntb, g, q, queries, ans, t, cur);\\n            }\\n        }\\n        t.remove(cur);\\n    }\\n}\\n```\n```O(n*log(n) + q*log(n))```",
                "codeTag": "Java"
            },
            {
                "id": 1345227,
                "title": "java-solution-without-trie-o-n-q-87ms",
                "content": "Since most solutions use trie,\\nshare my solution without using a trie.\\nThe idea is to record the first ancestor with a common bitwise prefix \"before\" each bit postion.\\nThat is, this position is the first different bit between current and the ancestor.\\nfor example: 1 -> 2 -> 3, then for node 3, we record [1,2].\\nExplain: since for lowest bit, 2 is the first ancestor with common prefix and diffs at this lowest bit;\\nand for the second-to-lowest bit, 1 is the first ancestor that diffs at this bit (common prefix are all zeros). We don\\'t care about the lowest bit here. \\n\\nFor each query, we scan bits from left to right, compare with its ancestors, starting from current node:\\n- if bits mismatch, we have a XOR value of 1\\n- if bits matches, we try to jump to the ancestor with different bit at this position, if success, we can still have a XOR value of 1, otherwise this query bit is skipped\\n- since we scan from left to right, we will get the maximum value\\n\\nComplexity: build O(32 * N), query O(32 * Q)\\n\\ncode:\\n```\\nclass Solution {\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        int n = parents.length;\\n        int[][] fd = new int[n][]; // first ancestor with common prefix before each pos\\n        for (int i = 0; i < n; i++) {\\n            fill(parents, n, fd, i);\\n        }\\n        int[] ret = new int[queries.length];\\n        for (int q = 0; q < queries.length; q++) {\\n            int cur = queries[q][0], value = queries[q][1];\\n            for (int p = 30; p >= 0; p--) {\\n                int msk = 1 << p;\\n                if ((value & msk) != (cur & msk)) {\\n                    ret[q] |= msk;\\n                } else if (fd[cur][p] >= 0) {\\n                    ret[q] |= msk;\\n                    cur = fd[cur][p];\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    private void fill(int[] parents, int n, int[][] fd, int i) {\\n        if (fd[i] == null) {\\n            fd[i] = new int[31];\\n            int a = parents[i]; // ancestor\\n            if (a >= 0) {\\n                fill(parents, n, fd, a);\\n            }\\n            for (int p = 30; p >= 0; p--) {\\n                if (a == -1) {\\n                    // no such common prefix before p\\n                    fd[i][p] = -1;\\n                } else {\\n                    if ((i & (1 << p)) == (a & (1 << p))) {\\n                        // so far the prefix are same\\n                        fd[i][p] = fd[a][p];\\n                    } else {\\n                        // this is the first diff pos\\n                        fd[i][p] = a;\\n                        a = fd[a][p];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        int n = parents.length;\\n        int[][] fd = new int[n][]; // first ancestor with common prefix before each pos\\n        for (int i = 0; i < n; i++) {\\n            fill(parents, n, fd, i);\\n        }\\n        int[] ret = new int[queries.length];\\n        for (int q = 0; q < queries.length; q++) {\\n            int cur = queries[q][0], value = queries[q][1];\\n            for (int p = 30; p >= 0; p--) {\\n                int msk = 1 << p;\\n                if ((value & msk) != (cur & msk)) {\\n                    ret[q] |= msk;\\n                } else if (fd[cur][p] >= 0) {\\n                    ret[q] |= msk;\\n                    cur = fd[cur][p];\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    private void fill(int[] parents, int n, int[][] fd, int i) {\\n        if (fd[i] == null) {\\n            fd[i] = new int[31];\\n            int a = parents[i]; // ancestor\\n            if (a >= 0) {\\n                fill(parents, n, fd, a);\\n            }\\n            for (int p = 30; p >= 0; p--) {\\n                if (a == -1) {\\n                    // no such common prefix before p\\n                    fd[i][p] = -1;\\n                } else {\\n                    if ((i & (1 << p)) == (a & (1 << p))) {\\n                        // so far the prefix are same\\n                        fd[i][p] = fd[a][p];\\n                    } else {\\n                        // this is the first diff pos\\n                        fd[i][p] = a;\\n                        a = fd[a][p];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345073,
                "title": "c-trie-dfs",
                "content": "```\\nstruct Trie{\\n    Trie* ptr[2];\\n    Trie(){\\n        ptr[0] = NULL;\\n        ptr[1] = NULL;\\n    }\\n};\\ntypedef Trie* bptr;\\nvoid clear(bptr &t){\\n    if(!t)return;\\n    clear(t->ptr[0]);\\n    clear(t->ptr[1]);\\n    delete t;\\n}\\nvoid insert(bptr &T,int n){\\n    bptr t = T;\\n    for(int i=31;i>=0;i--){\\n        int b = ((n>>i)&1);\\n        if(!t->ptr[b])t->ptr[b] = new Trie();\\n        t = t->ptr[b];\\n    }\\n}\\nint findMaxXorOfN(bptr &T,int n){\\n    bptr t = T;\\n    int ans = 0;\\n    for(int i=31;i>=0;i--){\\n        int b = ((n>>i)&1);\\n        ans = ans<<1;\\n        if(t->ptr[!b]){\\n            t = t->ptr[!b];\\n            ans|=1;\\n        }else{\\n            t = t->ptr[b];\\n            ans|=0;\\n        }\\n    }\\n    return ans;\\n}\\nbptr remove(bptr &t,int num,int i){\\n    if(!t)return NULL;\\n    if(i==-1)return NULL;\\n    int b = ((1<<i) & num)>0;\\n    t->ptr[b] = remove(t->ptr[b],num,i-1);\\n    if(t->ptr[1-b] || t->ptr[b])return t;\\n    else return NULL;\\n}\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>>q;\\n    vector<int>ans;\\n    void dfs(vector<int>g[],int u,bptr t){\\n        insert(t,u);\\n        for(auto [val,idx] : q[u]){\\n            ans[idx] = findMaxXorOfN(t,val);\\n        }\\n        for(int v : g[u]){\\n            dfs(g,v,t);\\n        }\\n        t = remove(t,u,31);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        ans.resize(m);\\n        for(int i=0;i<m;i++){\\n            q[queries[i][0]].emplace_back(queries[i][1],i);\\n        }\\n        int n = parents.size();\\n        vector<int>g[n];\\n        int root = 0;\\n        for(int i=0;i<n;i++){\\n            if(parents[i]==-1)root = i;\\n            else g[parents[i]].emplace_back(i);\\n        }\\n        bptr t = new Trie();\\n        dfs(g,root,t);\\n\\t\\t\\n\\t\\tclear(t);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nstruct Trie{\\n    Trie* ptr[2];\\n    Trie(){\\n        ptr[0] = NULL;\\n        ptr[1] = NULL;\\n    }\\n};\\ntypedef Trie* bptr;\\nvoid clear(bptr &t){\\n    if(!t)return;\\n    clear(t->ptr[0]);\\n    clear(t->ptr[1]);\\n    delete t;\\n}\\nvoid insert(bptr &T,int n){\\n    bptr t = T;\\n    for(int i=31;i>=0;i--){\\n        int b = ((n>>i)&1);\\n        if(!t->ptr[b])t->ptr[b] = new Trie();\\n        t = t->ptr[b];\\n    }\\n}\\nint findMaxXorOfN(bptr &T,int n){\\n    bptr t = T;\\n    int ans = 0;\\n    for(int i=31;i>=0;i--){\\n        int b = ((n>>i)&1);\\n        ans = ans<<1;\\n        if(t->ptr[!b]){\\n            t = t->ptr[!b];\\n            ans|=1;\\n        }else{\\n            t = t->ptr[b];\\n            ans|=0;\\n        }\\n    }\\n    return ans;\\n}\\nbptr remove(bptr &t,int num,int i){\\n    if(!t)return NULL;\\n    if(i==-1)return NULL;\\n    int b = ((1<<i) & num)>0;\\n    t->ptr[b] = remove(t->ptr[b],num,i-1);\\n    if(t->ptr[1-b] || t->ptr[b])return t;\\n    else return NULL;\\n}\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>>q;\\n    vector<int>ans;\\n    void dfs(vector<int>g[],int u,bptr t){\\n        insert(t,u);\\n        for(auto [val,idx] : q[u]){\\n            ans[idx] = findMaxXorOfN(t,val);\\n        }\\n        for(int v : g[u]){\\n            dfs(g,v,t);\\n        }\\n        t = remove(t,u,31);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        ans.resize(m);\\n        for(int i=0;i<m;i++){\\n            q[queries[i][0]].emplace_back(queries[i][1],i);\\n        }\\n        int n = parents.size();\\n        vector<int>g[n];\\n        int root = 0;\\n        for(int i=0;i<n;i++){\\n            if(parents[i]==-1)root = i;\\n            else g[parents[i]].emplace_back(i);\\n        }\\n        bptr t = new Trie();\\n        dfs(g,root,t);\\n\\t\\t\\n\\t\\tclear(t);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344900,
                "title": "python-dfs-while-maintaining-a-trie",
                "content": "I assume you know how a trie works.\\n\\nYou need a trie data structure that supports\\n\\n- Adding an element\\n- Given query `val`, find the value `p` such that `p XOR val` is the maximum\\n- Deleting element\\n\\nOutline of the approach\\n\\n- When you enter a node, you add the node value into the trie\\n- Then for every query on the node, find the best result and save the result\\n- Then enter each of the child node and repeat the operation (this is the depth-first search)\\n- When you exit the node, you delete the node value from the trie\\n\\nIf you have a static trie, you can maximise the result by trying to find the complement bit value in the current node. If the complement bit value is not on the current node in the trie, you have to settle for the same value. As the trie is always not empty, you will definitely find a value.\\n\\nThe challenge I face was implementing deletion. If the subtree of the trie is empty, you need to prune it to avoid visiting that subtree in the future.\\n\\nI got the base code from https://github.com/cheran-senthil/PyRival/blob/master/pyrival/data_structures/Trie.py and I added the XOR search function and added pruning in the deletion.\\n\\nEach deletion, addition and search is of time complexity `log(k)`. Therefore the complexity is `n log(k) + q log(k)`\\n\\n```\\nclass Trie:\\n    def __init__(self, *words):\\n        self.root = dict()\\n        for word in words:\\n            self.add(word)\\n\\n    def add(self, word):\\n        current_dict = self.root\\n        for letter in word:\\n            current_dict = current_dict.setdefault(letter, dict())\\n        current_dict[\"_end_\"] = True\\n\\n    def __contains__(self, word):\\n        current_dict = self.root\\n        for letter in word:\\n            if letter not in current_dict:\\n                return False\\n            current_dict = current_dict[letter]\\n        return \"_end_\" in current_dict\\n        \\n    def find(self, word):\\n        current_dict = self.root\\n        res = \"\"\\n        for letter in word:\\n            # try to match \"1\" to \"0\" and vice versa\\n            desired = \"1\" if letter == \"0\" else \"0\"\\n\\n            if not desired in current_dict:  # if not possible to match\\n                desired = letter  # settle for the same letter\\n            res += desired\\n            current_dict = current_dict[desired]  # advance to the next node in the trie\\n        return res\\n    \\n    def delete(self, word):\\n        current_dict = self.root\\n        nodes = [current_dict]\\n        objects = []\\n        for letter in word:\\n            current_dict = current_dict[letter]\\n            nodes.append(current_dict)\\n            objects.append(current_dict)\\n            \\n        del current_dict[\"_end_\"]\\n        \\n        for c,obj in zip(word[::-1], objects[:-1][::-1]):\\n            if not obj[c]:\\n                del obj[c]\\n            else:\\n                break\\n        \\n        # assert word not in self  # confirm that the number has been removed\\n\\n\\n\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        # maintain a trie while doing dfs\\n        \\n        def makebin(x):\\n            # convert to binary and prepend zeroes until there are 20 characters\\n            # we need all binary strings to be of the same length\\n            return bin(x)[2:].zfill(20)\\n        \\n        query_node_to_query_list = defaultdict(list)\\n        for i,(node, val) in enumerate(queries):\\n            query_node_to_query_list[node].append((i,val))\\n            \\n        graph = defaultdict(list)\\n        for i,x in enumerate(parents):\\n            graph[x].append(i)\\n        \\n        res = [-1 for _ in queries]\\n        t = Trie()\\n        \\n        def dfs(node):\\n            nodestr = makebin(node)\\n            t.add(nodestr)\\n            \\n            for i,val in query_node_to_query_list[node]:\\n                valstr = makebin(val)\\n                targetstr = t.find(valstr)  # find the best target value in the trie\\n                res[i] = int(targetstr,2) ^ val  # store the result\\n                \\n            for nex in graph[node]:\\n                dfs(nex)  # continue with dfs\\n                \\n            t.delete(nodestr)\\n                \\n        dfs(graph[-1][0])  # solve from root\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie:\\n    def __init__(self, *words):\\n        self.root = dict()\\n        for word in words:\\n            self.add(word)\\n\\n    def add(self, word):\\n        current_dict = self.root\\n        for letter in word:\\n            current_dict = current_dict.setdefault(letter, dict())\\n        current_dict[\"_end_\"] = True\\n\\n    def __contains__(self, word):\\n        current_dict = self.root\\n        for letter in word:\\n            if letter not in current_dict:\\n                return False\\n            current_dict = current_dict[letter]\\n        return \"_end_\" in current_dict\\n        \\n    def find(self, word):\\n        current_dict = self.root\\n        res = \"\"\\n        for letter in word:\\n            # try to match \"1\" to \"0\" and vice versa\\n            desired = \"1\" if letter == \"0\" else \"0\"\\n\\n            if not desired in current_dict:  # if not possible to match\\n                desired = letter  # settle for the same letter\\n            res += desired\\n            current_dict = current_dict[desired]  # advance to the next node in the trie\\n        return res\\n    \\n    def delete(self, word):\\n        current_dict = self.root\\n        nodes = [current_dict]\\n        objects = []\\n        for letter in word:\\n            current_dict = current_dict[letter]\\n            nodes.append(current_dict)\\n            objects.append(current_dict)\\n            \\n        del current_dict[\"_end_\"]\\n        \\n        for c,obj in zip(word[::-1], objects[:-1][::-1]):\\n            if not obj[c]:\\n                del obj[c]\\n            else:\\n                break\\n        \\n        # assert word not in self  # confirm that the number has been removed\\n\\n\\n\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        # maintain a trie while doing dfs\\n        \\n        def makebin(x):\\n            # convert to binary and prepend zeroes until there are 20 characters\\n            # we need all binary strings to be of the same length\\n            return bin(x)[2:].zfill(20)\\n        \\n        query_node_to_query_list = defaultdict(list)\\n        for i,(node, val) in enumerate(queries):\\n            query_node_to_query_list[node].append((i,val))\\n            \\n        graph = defaultdict(list)\\n        for i,x in enumerate(parents):\\n            graph[x].append(i)\\n        \\n        res = [-1 for _ in queries]\\n        t = Trie()\\n        \\n        def dfs(node):\\n            nodestr = makebin(node)\\n            t.add(nodestr)\\n            \\n            for i,val in query_node_to_query_list[node]:\\n                valstr = makebin(val)\\n                targetstr = t.find(valstr)  # find the best target value in the trie\\n                res[i] = int(targetstr,2) ^ val  # store the result\\n                \\n            for nex in graph[node]:\\n                dfs(nex)  # continue with dfs\\n                \\n            t.delete(nodestr)\\n                \\n        dfs(graph[-1][0])  # solve from root\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498571,
                "title": "bit-trie-dfs-c-clean-code",
                "content": "**Similar Questions :**\\n\\n*  [Maximum XOR of two numbers in an array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)\\n*  [Maximum XOR with an element from array](https://leetcode.com/problems/maximum-xor-with-an-element-from-array/)\\n\\n# Code: \\n\\n```\\nstruct Node {\\n    Node* arr[2];\\n    int count = 0;   // Count of number of elements till current node (same prefix)\\n    int val;            \\n    \\n    // Insert new node at bitNo \\n    void put(int bitNo, Node* newNode) { \\n        arr[bitNo] = newNode;\\n    }\\n    \\n    // Check if bitNo is present or not\\n    bool contains(int bitNo) {  \\n        return arr[bitNo] != NULL;\\n    }\\n    \\n    Node* getNext(int bitNo) {\\n        return arr[bitNo];\\n    }\\n    \\n    void setCount(int bitVal, int d) { \\n        arr[bitVal]->count += d;  // Here if d>0 means insert element, and d<0 means remove element\\n    }\\n    \\n    int getCount(int bitVal) {\\n        return arr[bitVal]->count;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    Node* root = new Node();\\n    \\n    void update(int num, int d) {\\n        Node* temp = root;\\n        for(int bit = 18; bit>=0; bit--) {\\n            int bitVal = (bool)(num & (1<<bit));\\n            \\n            if(!temp->contains(bitVal)) {\\n                temp->put(bitVal, new Node());\\n            }\\n            temp->setCount(bitVal, d);\\n            temp = temp->getNext(bitVal);\\n        }        \\n        temp->val = num;\\n    }\\n    \\n    int getMaxXOR(int num) {\\n        Node* temp = root;\\n        for(int bit=18; bit>=0; bit--) {\\n            int bitVal = !(bool)(num & (1<<bit));\\n            if(temp->contains(bitVal) && temp->getCount(bitVal)) {\\n                temp = temp->getNext(bitVal);\\n            }\\n            else if(temp->contains(1-bitVal)) {\\n                temp = temp->getNext(1-bitVal);\\n            }\\n        }\\n        return num ^ (temp->val);\\n    }\\n    \\n    void traverse(vector<vector<int>>& adj, unordered_map<int, vector<pair<int, int>>>& queries, vector<int>& ans, int node) {\\n        \\n        // Insert node into trie\\n        update(node, 1);\\n        \\n        // Find Maximum XOR for each query with given node\\n        for(auto& i : queries[node]) {\\n            ans[i.second] = getMaxXOR(i.first);\\n        }\\n        \\n        // Preorder Traversal \\n        for(auto& v : adj[node]) {\\n            traverse(adj, queries, ans, v);\\n        }\\n        \\n        // Remove node from trie\\n        update(node, -1);\\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        \\n        int n = parents.size();\\n        int m = queries.size();\\n        vector<vector<int>> adj(n);  // Make it as a graph on which we can do a Traversal\\n        int start = 0;\\n        for(int i=0; i<n; i++) { \\n            if(parents[i] == -1) start = i;\\n            else adj[parents[i]].push_back(i);\\n        }\\n        \\n        // Store queries in modified format. \\n        // So that we can easily access the node from start node -> root path\\n        // newQueries[node(i)] = {val(i), i} \\n        unordered_map<int, vector<pair<int, int>>> newQueries;\\n        for(int i=0; i<m; i++) {\\n            newQueries[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        \\n        vector<int> ans(m); // Store the result of all queries\\n        traverse(adj, newQueries, ans, start); // Preorder traversal on Tree\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n    Node* arr[2];\\n    int count = 0;   // Count of number of elements till current node (same prefix)\\n    int val;            \\n    \\n    // Insert new node at bitNo \\n    void put(int bitNo, Node* newNode) { \\n        arr[bitNo] = newNode;\\n    }\\n    \\n    // Check if bitNo is present or not\\n    bool contains(int bitNo) {  \\n        return arr[bitNo] != NULL;\\n    }\\n    \\n    Node* getNext(int bitNo) {\\n        return arr[bitNo];\\n    }\\n    \\n    void setCount(int bitVal, int d) { \\n        arr[bitVal]->count += d;  // Here if d>0 means insert element, and d<0 means remove element\\n    }\\n    \\n    int getCount(int bitVal) {\\n        return arr[bitVal]->count;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    Node* root = new Node();\\n    \\n    void update(int num, int d) {\\n        Node* temp = root;\\n        for(int bit = 18; bit>=0; bit--) {\\n            int bitVal = (bool)(num & (1<<bit));\\n            \\n            if(!temp->contains(bitVal)) {\\n                temp->put(bitVal, new Node());\\n            }\\n            temp->setCount(bitVal, d);\\n            temp = temp->getNext(bitVal);\\n        }        \\n        temp->val = num;\\n    }\\n    \\n    int getMaxXOR(int num) {\\n        Node* temp = root;\\n        for(int bit=18; bit>=0; bit--) {\\n            int bitVal = !(bool)(num & (1<<bit));\\n            if(temp->contains(bitVal) && temp->getCount(bitVal)) {\\n                temp = temp->getNext(bitVal);\\n            }\\n            else if(temp->contains(1-bitVal)) {\\n                temp = temp->getNext(1-bitVal);\\n            }\\n        }\\n        return num ^ (temp->val);\\n    }\\n    \\n    void traverse(vector<vector<int>>& adj, unordered_map<int, vector<pair<int, int>>>& queries, vector<int>& ans, int node) {\\n        \\n        // Insert node into trie\\n        update(node, 1);\\n        \\n        // Find Maximum XOR for each query with given node\\n        for(auto& i : queries[node]) {\\n            ans[i.second] = getMaxXOR(i.first);\\n        }\\n        \\n        // Preorder Traversal \\n        for(auto& v : adj[node]) {\\n            traverse(adj, queries, ans, v);\\n        }\\n        \\n        // Remove node from trie\\n        update(node, -1);\\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        \\n        int n = parents.size();\\n        int m = queries.size();\\n        vector<vector<int>> adj(n);  // Make it as a graph on which we can do a Traversal\\n        int start = 0;\\n        for(int i=0; i<n; i++) { \\n            if(parents[i] == -1) start = i;\\n            else adj[parents[i]].push_back(i);\\n        }\\n        \\n        // Store queries in modified format. \\n        // So that we can easily access the node from start node -> root path\\n        // newQueries[node(i)] = {val(i), i} \\n        unordered_map<int, vector<pair<int, int>>> newQueries;\\n        for(int i=0; i<m; i++) {\\n            newQueries[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        \\n        vector<int> ans(m); // Store the result of all queries\\n        traverse(adj, newQueries, ans, start); // Preorder traversal on Tree\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345063,
                "title": "timing-is-too-tight-at-least-for-c",
                "content": "TLE for an `O(n*log(n)+m*log(max(val)))` solution like the one below. Unfortunately, leetcode prefers global variables and allocations at once. The same solution with poor man\\'s allocator (global vector as a pool of Node objects) passes...\\n\\n```\\nclass Solution\\n{\\n    static const int depth = 18;\\n    class Node\\n    {\\n        Node* left;\\n        Node* right;\\n        int value;\\n        Node(int value) : left(NULL), right(NULL), value(value) { }\\n    public:\\n        static Node* create(int value)\\n        {\\n            Node* root = new Node(value);\\n            Node* node = root;\\n            for (int i = depth - 1; i >= 0; i--) {\\n                Node* next = new Node(value);\\n                if (value & (1 << i)) node->right = next;\\n                else node->left = next;\\n                node = next;\\n            }\\n            return root;\\n        }\\n        Node* insert(int value)\\n        {\\n            Node* root = create(value);\\n            Node* o = this;\\n            Node* n = root;\\n            while (n && o) {\\n                if (n->left) {\\n                    n->right = o->right;\\n                    n = n->left;\\n                    o = o->left;\\n                }\\n                else {\\n                    n->left = o->left;\\n                    n = n->right;\\n                    o = o->right;\\n                }\\n            }\\n            return root;\\n        }\\n        int query(int value)\\n        {\\n            Node* node = this;\\n            for (int i = depth - 1; i >= 0; i--) {\\n                if (value & (1 << i)) {\\n                    if (node->left) node = node->left;\\n                    else node = node->right;\\n                }\\n                else {\\n                    if (node->right) node = node->right;\\n                    else node = node->left;\\n                }\\n            }\\n            return node->value;\\n        }\\n    };\\n    void setNode(vector<int>& parents, vector<Node*>& nodes, int i)\\n    {\\n        if (nodes[i]) return;\\n        if (parents[i] != -1) {\\n            setNode(parents, nodes, parents[i]);\\n            nodes[i] = nodes[parents[i]]->insert(i);\\n        }\\n        else {\\n            nodes[i] = Node::create(i);\\n        }\\n    }\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries)\\n    {\\n        int n = parents.size();\\n        vector<Node*> nodes(n);\\n        for (int i = 0; i < n; i++) {\\n            setNode(parents, nodes, i);\\n        }\\n        int m = queries.size();\\n        vector<int> ret(m);\\n        for (int i = 0; i < m; i++)\\n            ret[i] = queries[i][1] ^ nodes[queries[i][0]]->query(queries[i][1]);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    static const int depth = 18;\\n    class Node\\n    {\\n        Node* left;\\n        Node* right;\\n        int value;\\n        Node(int value) : left(NULL), right(NULL), value(value) { }\\n    public:\\n        static Node* create(int value)\\n        {\\n            Node* root = new Node(value);\\n            Node* node = root;\\n            for (int i = depth - 1; i >= 0; i--) {\\n                Node* next = new Node(value);\\n                if (value & (1 << i)) node->right = next;\\n                else node->left = next;\\n                node = next;\\n            }\\n            return root;\\n        }\\n        Node* insert(int value)\\n        {\\n            Node* root = create(value);\\n            Node* o = this;\\n            Node* n = root;\\n            while (n && o) {\\n                if (n->left) {\\n                    n->right = o->right;\\n                    n = n->left;\\n                    o = o->left;\\n                }\\n                else {\\n                    n->left = o->left;\\n                    n = n->right;\\n                    o = o->right;\\n                }\\n            }\\n            return root;\\n        }\\n        int query(int value)\\n        {\\n            Node* node = this;\\n            for (int i = depth - 1; i >= 0; i--) {\\n                if (value & (1 << i)) {\\n                    if (node->left) node = node->left;\\n                    else node = node->right;\\n                }\\n                else {\\n                    if (node->right) node = node->right;\\n                    else node = node->left;\\n                }\\n            }\\n            return node->value;\\n        }\\n    };\\n    void setNode(vector<int>& parents, vector<Node*>& nodes, int i)\\n    {\\n        if (nodes[i]) return;\\n        if (parents[i] != -1) {\\n            setNode(parents, nodes, parents[i]);\\n            nodes[i] = nodes[parents[i]]->insert(i);\\n        }\\n        else {\\n            nodes[i] = Node::create(i);\\n        }\\n    }\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries)\\n    {\\n        int n = parents.size();\\n        vector<Node*> nodes(n);\\n        for (int i = 0; i < n; i++) {\\n            setNode(parents, nodes, i);\\n        }\\n        int m = queries.size();\\n        vector<int> ret(m);\\n        for (int i = 0; i < m; i++)\\n            ret[i] = queries[i][1] ^ nodes[queries[i][0]]->query(queries[i][1]);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345098,
                "title": "dfs-trie-c-concise-code",
                "content": "Apply Dfs, whenever you visit some node just insert it into the trie, and whenever you leave remove it from the trie.\\nThis basically insert all the node from root to current node into the trie, andthen  evaluate all the queries having the node equals to current node.\\n\\n```\\n#define ll long long int\\n\\nstruct BitTrie{\\n    const ll B = 18;\\n    BitTrie *left, *right;\\n    ll cnt;\\n    BitTrie(){\\n        left = right = NULL;\\n        cnt = 0;\\n    }\\n\\n    // insert a number llo the trie\\n    void insert(ll n){\\n        BitTrie *root = this;\\n        for(ll bit = B - 1; bit >= 0; bit--){\\n            ll x = n & (1ll << bit);\\n            if(x){\\n                if(root -> right == NULL){\\n                    root -> right = new BitTrie();\\n                }\\n                root = root -> right;\\n            }else{\\n                if(root -> left == NULL){\\n                    root -> left = new BitTrie();\\n                }\\n                root = root -> left;\\n            }\\n            root -> cnt += 1;\\n        }\\n    }\\n    \\n    // delete a number from a trie\\n    \\n    void remove(ll n){\\n        BitTrie *root = this;\\n        for(ll bit = B - 1; bit >= 0; bit--){\\n            ll x = n & (1ll << bit);\\n            if(x){\\n                root -> right -> cnt--;\\n                if(root -> right -> cnt == 0){\\n                    root -> right = NULL;\\n                    break;\\n                }\\n                root = root -> right;\\n            }else{\\n                root -> left -> cnt--;\\n                if(root -> left -> cnt == 0){\\n                    root -> left = NULL;\\n                    break;\\n                }\\n                root = root -> left;\\n            }\\n        }\\n    }\\n\\n    // find max xor pair\\n    ll find_max_pair(ll ele){\\n        BitTrie *root = this;\\n        ll res = 0;\\n        for(ll bit = B - 1; bit >= 0; bit--){\\n            ll x = ele & (1ll << bit);\\n            if(x){\\n                if(root->left != NULL){\\n                    res += (1ll << bit);\\n                    root = root->left;\\n                }else{\\n                    root = root->right;\\n                }\\n            }else{\\n                if(root->right != NULL){\\n                    res += (1ll << bit);\\n                    root = root->right;\\n                }else{\\n                    root = root->left;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        BitTrie trie;\\n        ll n = parents.size();\\n        vector<vector<ll>> adj(n, vector<ll>());\\n        int root = 0;\\n        for(ll i = 0; i < n; i++){\\n            if(parents[i] != -1){\\n                adj[parents[i]].push_back(i);\\n            }else{\\n                root = i;\\n            }\\n        }\\n        \\n        unordered_map<ll, vector<array<ll, 2>>> Q;\\n        for(ll i = 0; i < queries.size(); i++){\\n            Q[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        ll m = queries.size();\\n        vector<int> res(m);\\n        function<void(ll, ll)> dfs = [&](ll u, ll p){\\n            trie.insert(u);\\n            for(auto v : Q[u]){\\n                res[v[1]] = trie.find_max_pair(v[0]);\\n            }\\n            for(ll v : adj[u]){\\n                if(v == p) continue;\\n                dfs(v, u);\\n            }\\n            trie.remove(u);\\n        };\\n        dfs(root, -1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n\\nstruct BitTrie{\\n    const ll B = 18;\\n    BitTrie *left, *right;\\n    ll cnt;\\n    BitTrie(){\\n        left = right = NULL;\\n        cnt = 0;\\n    }\\n\\n    // insert a number llo the trie\\n    void insert(ll n){\\n        BitTrie *root = this;\\n        for(ll bit = B - 1; bit >= 0; bit--){\\n            ll x = n & (1ll << bit);\\n            if(x){\\n                if(root -> right == NULL){\\n                    root -> right = new BitTrie();\\n                }\\n                root = root -> right;\\n            }else{\\n                if(root -> left == NULL){\\n                    root -> left = new BitTrie();\\n                }\\n                root = root -> left;\\n            }\\n            root -> cnt += 1;\\n        }\\n    }\\n    \\n    // delete a number from a trie\\n    \\n    void remove(ll n){\\n        BitTrie *root = this;\\n        for(ll bit = B - 1; bit >= 0; bit--){\\n            ll x = n & (1ll << bit);\\n            if(x){\\n                root -> right -> cnt--;\\n                if(root -> right -> cnt == 0){\\n                    root -> right = NULL;\\n                    break;\\n                }\\n                root = root -> right;\\n            }else{\\n                root -> left -> cnt--;\\n                if(root -> left -> cnt == 0){\\n                    root -> left = NULL;\\n                    break;\\n                }\\n                root = root -> left;\\n            }\\n        }\\n    }\\n\\n    // find max xor pair\\n    ll find_max_pair(ll ele){\\n        BitTrie *root = this;\\n        ll res = 0;\\n        for(ll bit = B - 1; bit >= 0; bit--){\\n            ll x = ele & (1ll << bit);\\n            if(x){\\n                if(root->left != NULL){\\n                    res += (1ll << bit);\\n                    root = root->left;\\n                }else{\\n                    root = root->right;\\n                }\\n            }else{\\n                if(root->right != NULL){\\n                    res += (1ll << bit);\\n                    root = root->right;\\n                }else{\\n                    root = root->left;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        BitTrie trie;\\n        ll n = parents.size();\\n        vector<vector<ll>> adj(n, vector<ll>());\\n        int root = 0;\\n        for(ll i = 0; i < n; i++){\\n            if(parents[i] != -1){\\n                adj[parents[i]].push_back(i);\\n            }else{\\n                root = i;\\n            }\\n        }\\n        \\n        unordered_map<ll, vector<array<ll, 2>>> Q;\\n        for(ll i = 0; i < queries.size(); i++){\\n            Q[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        ll m = queries.size();\\n        vector<int> res(m);\\n        function<void(ll, ll)> dfs = [&](ll u, ll p){\\n            trie.insert(u);\\n            for(auto v : Q[u]){\\n                res[v[1]] = trie.find_max_pair(v[0]);\\n            }\\n            for(ll v : adj[u]){\\n                if(v == p) continue;\\n                dfs(v, u);\\n            }\\n            trie.remove(u);\\n        };\\n        dfs(root, -1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344930,
                "title": "c-reusing-logic-of-lc-421-trie-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    class node{\\n        public:\\n        int val;\\n        node*child[2];\\n        int count;\\n        node(int x){\\n            this->val = x;\\n            child[0]=child[1]=NULL;\\n            this->count = 1;\\n        }\\n    };\\n    void del(node* root,int x,int i=31){\\n        if(i<0)return;\\n        bool v = x&(1<<i);\\n        del(root->child[v],x,i-1);\\n        root->child[v]->count--;\\n        if(root->child[v]->count==0){\\n            root->child[v] = NULL;\\n        }\\n    }\\n    void insert(node* root,int x){\\n        for(int i=31;i>=0;i--){ \\n            bool v = x&(1<<i);\\n            if(!root->child[v])root->child[v] = new node(x);\\n            else root->child[v]->count++; \\n            root = root->child[v];\\n            \\n        }\\n    }\\n    int getAns(node* root,int x){\\n        for(int i=31;i>=0;i--){\\n            bool v = x&(1<<i);\\n            if(root->child[1-v]){\\n                root = root->child[1-v];\\n            }else root = root->child[v];\\n        }\\n        return x^root->val;\\n    }\\n    vector<int>adj[100001];\\n    unordered_map<int,vector<int>>m;\\n    vector<int>ans;\\n    void traverse(node* root,int u,vector<vector<int>>& que){\\n       insert(root,u);\\n       if(m.count(u)){\\n           while(!m[u].empty()){\\n               ans[m[u].back()] = getAns(root,que[m[u].back()][1]);\\n               m[u].pop_back();\\n           }\\n       }\\n       for(auto x:adj[u]){\\n           traverse(root,x,que);\\n       }\\n        del(root,u);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& p, vector<vector<int>>& que) {\\n        int par=0;\\n        for(int i=0;i<p.size();i++){\\n            if(p[i]==-1)par=i;\\n            else adj[p[i]].push_back(i);\\n        }\\n        for(int i=0;i<que.size();i++){\\n            m[que[i][0]].push_back(i);\\n        }\\n        ans.resize(que.size());\\n        node* root = new node(-1);\\n        traverse(root,par,que);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    class node{\\n        public:\\n        int val;\\n        node*child[2];\\n        int count;\\n        node(int x){\\n            this->val = x;\\n            child[0]=child[1]=NULL;\\n            this->count = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2700790,
                "title": "c-easy-dfs",
                "content": "\\n# Code\\n```\\nstruct TrieNode {\\n    TrieNode* child[2] = {};\\n    int go = 0; \\n    void increase(int number, int d) {\\n        TrieNode* cur = this;\\n        for (int i = 17; i >= 0; --i) {\\n            int bit = (number >> i) & 1;\\n            if (cur->child[bit] == nullptr) cur->child[bit] = new TrieNode();\\n            cur = cur->child[bit];\\n            cur->go += d;\\n        }\\n    }\\n    int findMax(int number) {\\n        TrieNode* cur = this;\\n        int ans = 0;\\n        for (int i = 17; i >= 0; --i) {\\n            int bit = (number >> i) & 1;\\n            if (cur->child[1 - bit] != nullptr && cur->child[1 - bit]->go > 0) {\\n                cur = cur->child[1 - bit];\\n                ans |= (1 << i);\\n            } else cur = cur->child[bit];\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution { \\npublic:\\n    TrieNode trieRoot;\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& qs) {\\n        int n = parents.size(), m = qs.size(), root = -1;\\n        vector<vector<int>> graph(n);\\n        for (int i = 0; i < n; ++i)\\n            if (parents[i] == -1) root = i;\\n            else graph[parents[i]].push_back(i);\\n        vector<vector<pair<int, int>>> queryByNode(n);\\n        for (int i = 0; i < m; ++i)\\n            queryByNode[qs[i][0]].push_back(make_pair(qs[i][1], i)); \\n\\n        vector<int> ans(m);\\n        dfs(root, graph, queryByNode, ans);\\n        return ans;\\n    }\\n    void dfs(int u, vector<vector<int>>& graph, vector<vector<pair<int, int>>>& queryByNode, vector<int>& ans) {\\n        trieRoot.increase(u, 1);\\n        for (auto& p : queryByNode[u])\\n            ans[p.second] = trieRoot.findMax(p.first);\\n        for (int& v : graph[u])\\n            dfs(v, graph, queryByNode, ans);\\n        trieRoot.increase(u, -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct TrieNode {\\n    TrieNode* child[2] = {};\\n    int go = 0; \\n    void increase(int number, int d) {\\n        TrieNode* cur = this;\\n        for (int i = 17; i >= 0; --i) {\\n            int bit = (number >> i) & 1;\\n            if (cur->child[bit] == nullptr) cur->child[bit] = new TrieNode();\\n            cur = cur->child[bit];\\n            cur->go += d;\\n        }\\n    }\\n    int findMax(int number) {\\n        TrieNode* cur = this;\\n        int ans = 0;\\n        for (int i = 17; i >= 0; --i) {\\n            int bit = (number >> i) & 1;\\n            if (cur->child[1 - bit] != nullptr && cur->child[1 - bit]->go > 0) {\\n                cur = cur->child[1 - bit];\\n                ans |= (1 << i);\\n            } else cur = cur->child[bit];\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution { \\npublic:\\n    TrieNode trieRoot;\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& qs) {\\n        int n = parents.size(), m = qs.size(), root = -1;\\n        vector<vector<int>> graph(n);\\n        for (int i = 0; i < n; ++i)\\n            if (parents[i] == -1) root = i;\\n            else graph[parents[i]].push_back(i);\\n        vector<vector<pair<int, int>>> queryByNode(n);\\n        for (int i = 0; i < m; ++i)\\n            queryByNode[qs[i][0]].push_back(make_pair(qs[i][1], i)); \\n\\n        vector<int> ans(m);\\n        dfs(root, graph, queryByNode, ans);\\n        return ans;\\n    }\\n    void dfs(int u, vector<vector<int>>& graph, vector<vector<pair<int, int>>>& queryByNode, vector<int>& ans) {\\n        trieRoot.increase(u, 1);\\n        for (auto& p : queryByNode[u])\\n            ans[p.second] = trieRoot.findMax(p.first);\\n        for (int& v : graph[u])\\n            dfs(v, graph, queryByNode, ans);\\n        trieRoot.increase(u, -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578808,
                "title": "python-may-the-rngesus-be-with-you",
                "content": "![image](https://assets.leetcode.com/users/images/aa9a1996-d4f3-407e-84c5-79dbedfbe1a0_1663232251.2917502.png)\\n\\n**Solution**:\\nUse trie tree and dfs to solve this problem. Start by building an adjacency list mapped all nodes to their child and a queries dict mapped nodes to their values. Preserve the orignal position of each query so that we return the correct order of results. In order to avoid sorting results, we will use an ordered dict mapped queries position to their results.\\n\\nStart dfs through all nodes starting from the root. For each node, add it into a trie tree and calculate results of queries correspond to such node. Then, dfs through its child before removing such node from the trie tree and backtracking. \\n\\nFinally, pray that leetcode will accept your code.\\n\\nOptimization Performed:\\n1. Dynamic depth for Trie tree\\n2. Use OrderedDict to avoid sorting results\\n3. Iterative DFS\\n4. Trie tree pruning using sets for quicker find and remove. It is actually run slower because we have to maintain sets for every node in the trie tree.\\n\\n**Complexity**:\\n    Time: O(m n) where is m is the number of node and n is the number of queries\\n    Space: O (m + n)\\n\\t\\n```\\nfrom collections import OrderedDict, defaultdict\\n\\n#Trie tree with no pruning \\nclass TrieNode:\\n\\n    # Instantiate a trie node of a fix bits length\\n    def __init__(self, bits=0) -> None:\\n\\n        # A dict mapped this trie node to its child trie nodes\\n        self.children = defaultdict(TrieNode)\\n\\n        # A variable to keep track of the bits length starting from this node\\n        self.bits = bits\\n\\n        # A variable to store the value correspond to bits starting from the root to this node\\n        self.val = None\\n\\n    # Add a value into the trie node\\n    def add(self, val):\\n\\n        # Intialize the current node\\n        node = self\\n\\n        # Iterate through all bits of the value starting from the most significant bit\\n        for offset in range(self.bits - 1, -1, -1):\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # Continue to the next node based on the current bit\\n            node = node.children[bit]\\n\\n        # Save the value at the last node\\n        node.val = val\\n\\n    # Given a value, find an existing value in the trie node such that both values xor to the largest possible value\\n    def find(self, val):\\n\\n        # Initialize the current node\\n        node = self\\n\\n        # Iterate through all bits of the value starting from the most significant bit\\n        for offset in range(self.bits - 1, -1, -1):\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # If there exists a trie node correspond to the opposite of the current bit, go there\\n            # Else, go to the trie node correspond to the current bit\\n            node = (\\n                node.children[1 - bit]\\n                if 1 - bit in node.children\\n                else node.children[bit]\\n            )\\n\\n        # Return the value of the last node\\n        return node.val\\n\\n    # Remove a value from the trie node\\n    def remove(self, val):\\n\\n        # DFS through the trie node\\n        def dfs(offset, node):\\n\\n            # Stop the search once we reach -1 bit\\n            if offset == -1:\\n                return\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # Go to the child trie node base on the current bit\\n            dfs(offset - 1, node.children[bit])\\n\\n            # If the child trie node has no children, remove the such node from the current node\\n            if len(node.children[bit].children) == 0:\\n                node.children.pop(bit)\\n\\n        # Call dfs starting on the root\\n        dfs(self.bits - 1, self)\\n\\n\\nclass Solution:\\n    def maxGeneticDifference(\\n        self, parents: list[int], queries: list[list[int]]\\n    ) -> list[int]:\\n\\n        # Find the number of nodes and queries\\n        m, n = len(parents), len(queries)\\n\\n        # Build an adjacency list\\n        root, adj = None, defaultdict(list)\\n        for dst, src in enumerate(parents):\\n            if src == -1:\\n                root = dst\\n                continue\\n            adj[src].append(dst)\\n\\n        # Create a dict mapped nodes to their queries positions and values\\n        query = defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            query[node].append((i, val))\\n\\n        # Intialize an OrderedDict to store the result\\n        res = OrderedDict({i: -1 for i in range(n)})\\n\\n        # Intialize the trie node\\n        trie = TrieNode(m.bit_length())\\n\\n        # Iterative DFS\\n        # Initalize a stack and a list of keep track of previous nodes\\n        stack, previous = [(-1, root)], []\\n\\n        # Iterate until the stack is empty\\n        while stack:\\n\\n            # Pop a node from the stack\\n            parent, node = stack.pop()\\n\\n            # If the parent of the current node is not the last node in the list of previous nodes\\n            while previous and previous[-1] != parent:\\n\\n                # Pop it from the list and remove such node from the trie node\\n                trie.remove(previous.pop())\\n\\n            # Add the current node to the trie node\\n            trie.add(node)\\n\\n            # Append the current node to the list of previous nodes\\n            previous.append(node)\\n\\n            # Calculate queries correspond to the current node\\n            for i, val in query[node]:\\n                res[i] = trie.find(val) ^ val\\n\\n            # Add the child of the current node onto the stack\\n            for nextNode in adj[node]:\\n                stack.append((node, nextNode))\\n\\n        # Return results as a list\\n        return list(res.values())\\n```\\n\\n\\n```\\n#Trie tree with pruning using set for quicker find and remove.\\nclass TrieNode:\\n\\n    # Instantiate a trie node of a fix bits length\\n    def __init__(self, bits=0) -> None:\\n\\n        # A dict mapped this trie node to its child trie nodes\\n        self.children = defaultdict(TrieNode)\\n\\n        # A variable to keep track of the bits length starting from this node\\n        self.bits = bits\\n\\n        # A variable to store values correspond to this bit\\n        self.vals = defaultdict(set)\\n\\n    # Add a value into the trie node\\n    def add(self, val):\\n\\n        # Intialize the current node\\n        node = self\\n\\n        # Iterate through all bits of the value starting from the most significant bit\\n        for offset in range(self.bits - 1, -1, -1):\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # Add the value to the current bit\\n            node.vals[bit].add(val)\\n\\n            # Continue to the next node based on the current bit\\n            node = node.children[bit]\\n\\n    # Given a value, find an existing value in the trie node such that both values xor to the largest possible value\\n    def find(self, val):\\n\\n        # Initialize the current node\\n        node = self\\n\\n        # Iterate through all bits of the value starting from the most significant bit\\n        for offset in range(self.bits - 1, -1, -1):\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # If there is one value correspond to the opposite bit, return such value\\n            if 1 - bit in node.children and len(node.vals[1 - bit]) == 1:\\n                return list(node.vals[1 - bit])[0]\\n\\n            # Else, if there is no value correspond to the opposite bit but there is a single value correspond to the current bit, return such value\\n            elif len(node.vals[1 - bit]) == 0 and len(node.vals[bit]) == 1:\\n                return list(node.vals[bit])[0]\\n\\n            # If there exists a trie node correspond to the opposite of the current bit, go there\\n            # Else, go to the trie node correspond to the current bit\\n            node = (\\n                node.children[1 - bit]\\n                if 1 - bit in node.children\\n                else node.children[bit]\\n            )\\n\\n    # Remove a value from the trie node\\n    def remove(self, val):\\n\\n        # Initialize the current node\\n        node = self\\n\\n        # Iterate through all bits of the value starting from the most significant bit\\n        for offset in range(self.bits - 1, -1, -1):\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # Remove the value from the current bit\\n            node.vals[bit].remove(val)\\n\\n            # If there is no value correspond to the current bit, pop the node correspond to such bit from the children of the current node\\n            if len(node.vals[bit]) == 0:\\n                node.children.pop(bit)\\n                return\\n\\n            # Else, go to the next node based on the current bit\\n            node = node.children[bit]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import OrderedDict, defaultdict\\n\\n#Trie tree with no pruning \\nclass TrieNode:\\n\\n    # Instantiate a trie node of a fix bits length\\n    def __init__(self, bits=0) -> None:\\n\\n        # A dict mapped this trie node to its child trie nodes\\n        self.children = defaultdict(TrieNode)\\n\\n        # A variable to keep track of the bits length starting from this node\\n        self.bits = bits\\n\\n        # A variable to store the value correspond to bits starting from the root to this node\\n        self.val = None\\n\\n    # Add a value into the trie node\\n    def add(self, val):\\n\\n        # Intialize the current node\\n        node = self\\n\\n        # Iterate through all bits of the value starting from the most significant bit\\n        for offset in range(self.bits - 1, -1, -1):\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # Continue to the next node based on the current bit\\n            node = node.children[bit]\\n\\n        # Save the value at the last node\\n        node.val = val\\n\\n    # Given a value, find an existing value in the trie node such that both values xor to the largest possible value\\n    def find(self, val):\\n\\n        # Initialize the current node\\n        node = self\\n\\n        # Iterate through all bits of the value starting from the most significant bit\\n        for offset in range(self.bits - 1, -1, -1):\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # If there exists a trie node correspond to the opposite of the current bit, go there\\n            # Else, go to the trie node correspond to the current bit\\n            node = (\\n                node.children[1 - bit]\\n                if 1 - bit in node.children\\n                else node.children[bit]\\n            )\\n\\n        # Return the value of the last node\\n        return node.val\\n\\n    # Remove a value from the trie node\\n    def remove(self, val):\\n\\n        # DFS through the trie node\\n        def dfs(offset, node):\\n\\n            # Stop the search once we reach -1 bit\\n            if offset == -1:\\n                return\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # Go to the child trie node base on the current bit\\n            dfs(offset - 1, node.children[bit])\\n\\n            # If the child trie node has no children, remove the such node from the current node\\n            if len(node.children[bit].children) == 0:\\n                node.children.pop(bit)\\n\\n        # Call dfs starting on the root\\n        dfs(self.bits - 1, self)\\n\\n\\nclass Solution:\\n    def maxGeneticDifference(\\n        self, parents: list[int], queries: list[list[int]]\\n    ) -> list[int]:\\n\\n        # Find the number of nodes and queries\\n        m, n = len(parents), len(queries)\\n\\n        # Build an adjacency list\\n        root, adj = None, defaultdict(list)\\n        for dst, src in enumerate(parents):\\n            if src == -1:\\n                root = dst\\n                continue\\n            adj[src].append(dst)\\n\\n        # Create a dict mapped nodes to their queries positions and values\\n        query = defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            query[node].append((i, val))\\n\\n        # Intialize an OrderedDict to store the result\\n        res = OrderedDict({i: -1 for i in range(n)})\\n\\n        # Intialize the trie node\\n        trie = TrieNode(m.bit_length())\\n\\n        # Iterative DFS\\n        # Initalize a stack and a list of keep track of previous nodes\\n        stack, previous = [(-1, root)], []\\n\\n        # Iterate until the stack is empty\\n        while stack:\\n\\n            # Pop a node from the stack\\n            parent, node = stack.pop()\\n\\n            # If the parent of the current node is not the last node in the list of previous nodes\\n            while previous and previous[-1] != parent:\\n\\n                # Pop it from the list and remove such node from the trie node\\n                trie.remove(previous.pop())\\n\\n            # Add the current node to the trie node\\n            trie.add(node)\\n\\n            # Append the current node to the list of previous nodes\\n            previous.append(node)\\n\\n            # Calculate queries correspond to the current node\\n            for i, val in query[node]:\\n                res[i] = trie.find(val) ^ val\\n\\n            # Add the child of the current node onto the stack\\n            for nextNode in adj[node]:\\n                stack.append((node, nextNode))\\n\\n        # Return results as a list\\n        return list(res.values())\\n```\n```\\n#Trie tree with pruning using set for quicker find and remove.\\nclass TrieNode:\\n\\n    # Instantiate a trie node of a fix bits length\\n    def __init__(self, bits=0) -> None:\\n\\n        # A dict mapped this trie node to its child trie nodes\\n        self.children = defaultdict(TrieNode)\\n\\n        # A variable to keep track of the bits length starting from this node\\n        self.bits = bits\\n\\n        # A variable to store values correspond to this bit\\n        self.vals = defaultdict(set)\\n\\n    # Add a value into the trie node\\n    def add(self, val):\\n\\n        # Intialize the current node\\n        node = self\\n\\n        # Iterate through all bits of the value starting from the most significant bit\\n        for offset in range(self.bits - 1, -1, -1):\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # Add the value to the current bit\\n            node.vals[bit].add(val)\\n\\n            # Continue to the next node based on the current bit\\n            node = node.children[bit]\\n\\n    # Given a value, find an existing value in the trie node such that both values xor to the largest possible value\\n    def find(self, val):\\n\\n        # Initialize the current node\\n        node = self\\n\\n        # Iterate through all bits of the value starting from the most significant bit\\n        for offset in range(self.bits - 1, -1, -1):\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # If there is one value correspond to the opposite bit, return such value\\n            if 1 - bit in node.children and len(node.vals[1 - bit]) == 1:\\n                return list(node.vals[1 - bit])[0]\\n\\n            # Else, if there is no value correspond to the opposite bit but there is a single value correspond to the current bit, return such value\\n            elif len(node.vals[1 - bit]) == 0 and len(node.vals[bit]) == 1:\\n                return list(node.vals[bit])[0]\\n\\n            # If there exists a trie node correspond to the opposite of the current bit, go there\\n            # Else, go to the trie node correspond to the current bit\\n            node = (\\n                node.children[1 - bit]\\n                if 1 - bit in node.children\\n                else node.children[bit]\\n            )\\n\\n    # Remove a value from the trie node\\n    def remove(self, val):\\n\\n        # Initialize the current node\\n        node = self\\n\\n        # Iterate through all bits of the value starting from the most significant bit\\n        for offset in range(self.bits - 1, -1, -1):\\n\\n            # Find the current bit\\n            bit = (val & 1 << offset) >> offset\\n\\n            # Remove the value from the current bit\\n            node.vals[bit].remove(val)\\n\\n            # If there is no value correspond to the current bit, pop the node correspond to such bit from the children of the current node\\n            if len(node.vals[bit]) == 0:\\n                node.children.pop(bit)\\n                return\\n\\n            # Else, go to the next node based on the current bit\\n            node = node.children[bit]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402427,
                "title": "c-bit-trie-dfs",
                "content": "```cpp\\nclass Node{\\npublic:\\n    Node* links[2];\\n    int cnt=0;\\n    bool containsKey(int x){\\n        return (this->links[x]!=NULL);\\n    }\\n    void put(int x,Node* node){\\n        this->links[x]=node;\\n    }\\n    Node* get(int x){\\n        return this->links[x];\\n    }\\n};\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root=new Node();\\n    }\\n    void update(int x,bool add){\\n        Node* node=root;\\n        for(int i=30;i>=0;i--){\\n            int currbit=(x>>i)&1;\\n            if(!node->containsKey(currbit)) node->put(currbit,new Node());\\n            node=node->get(currbit);\\n            if(add) node->cnt++;\\n            else node->cnt--;\\n        }\\n    }\\n    int maxxor(int x){\\n        Node* node=root;\\n        int ans=0;\\n        for(int i=30;i>=0;i--){\\n            int currbit=(x>>i)&1;\\n            if(node->containsKey(currbit^1)&&node->links[currbit^1]->cnt>0){\\n                ans+=(1<<i);\\n                node=node->get(currbit^1);\\n            }\\n            else node=node->get(currbit);\\n        }\\n        return ans;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int>adj[100005];\\n    map<int,vector<pair<int,int>>>mp;\\n    Trie* t;\\n    vector<int>ans;\\n    void dfs(int src){\\n        t->update(src,true);\\n        for(auto x:mp[src]) ans[x.second]=t->maxxor(x.first);\\n        for(auto edge:adj[src]) dfs(edge);    \\n        t->update(src,false);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int start=-1;\\n        for(int i=0;i<parents.size();i++){\\n            if(parents[i]==-1) start=i;\\n            else adj[parents[i]].push_back(i);\\n        }\\n        for(int i=0;i<queries.size();i++) mp[queries[i][0]].push_back({queries[i][1],i});\\n        ans.resize((int)queries.size());\\n        t=new Trie();\\n        dfs(start);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int>adj[100005];\\n    map<int,vector<pair<int,int>>>mp;\\n    Trie* t;\\n    vector<int>ans;\\n    void dfs(int src){\\n        t->update(src,true);\\n        for(auto x:mp[src]) ans[x.second]=t->maxxor(x.first);\\n        for(auto edge:adj[src]) dfs(edge);    \\n        t->update(src,false);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1355918,
                "title": "python3-bit-trie",
                "content": "\\n```\\nclass Trie: \\n    def __init__(self): \\n        self.root = {}\\n    \\n    def insert(self, x): \\n        node = self.root\\n        for i in range(18, -1, -1): \\n            bit = (x >> i) & 1\\n            node = node.setdefault(bit, {})\\n            node[\"mult\"] = 1 + node.get(\"mult\", 0)\\n        node[\"#\"] = x # sentinel \\n        \\n    def search(self, x): \\n        node = self.root\\n        for i in range(18, -1, -1): \\n            bit = (x >> i) & 1\\n            if 1^bit in node: node = node[1^bit]\\n            else: node = node[bit]\\n        return x ^ node[\"#\"]\\n    \\n    def remove(self, x): \\n        node = self.root\\n        for i in range(18, -1, -1): \\n            bit = (x >> i) & 1\\n            node[bit][\"mult\"] -= 1\\n            if node[bit][\"mult\"] == 0: \\n                node.pop(bit)\\n                break \\n            node = node[bit]\\n        \\n\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        mp = {}\\n        for i, (node, val) in enumerate(queries): \\n            mp.setdefault(node, []).append([val, i])\\n        \\n        tree, root = {}, -1\\n        for i, x in enumerate(parents): \\n            if x == -1: root = i\\n            else: tree.setdefault(x, []).append(i)\\n        \\n        ans = [0]*len(queries)\\n        trie = Trie()\\n        \\n        def fn(x): \\n            \"\"\"Collect query results while traversing the tree.\"\"\"\\n            trie.insert(x)\\n            for v, i in mp.get(x, []): ans[i] = trie.search(v)\\n            for xx in tree.get(x, []): fn(xx)\\n            trie.remove(x)\\n        \\n        fn(root)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Trie: \\n    def __init__(self): \\n        self.root = {}\\n    \\n    def insert(self, x): \\n        node = self.root\\n        for i in range(18, -1, -1): \\n            bit = (x >> i) & 1\\n            node = node.setdefault(bit, {})\\n            node[\"mult\"] = 1 + node.get(\"mult\", 0)\\n        node[\"#\"] = x # sentinel \\n        \\n    def search(self, x): \\n        node = self.root\\n        for i in range(18, -1, -1): \\n            bit = (x >> i) & 1\\n            if 1^bit in node: node = node[1^bit]\\n            else: node = node[bit]\\n        return x ^ node[\"#\"]\\n    \\n    def remove(self, x): \\n        node = self.root\\n        for i in range(18, -1, -1): \\n            bit = (x >> i) & 1\\n            node[bit][\"mult\"] -= 1\\n            if node[bit][\"mult\"] == 0: \\n                node.pop(bit)\\n                break \\n            node = node[bit]\\n        \\n\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        mp = {}\\n        for i, (node, val) in enumerate(queries): \\n            mp.setdefault(node, []).append([val, i])\\n        \\n        tree, root = {}, -1\\n        for i, x in enumerate(parents): \\n            if x == -1: root = i\\n            else: tree.setdefault(x, []).append(i)\\n        \\n        ans = [0]*len(queries)\\n        trie = Trie()\\n        \\n        def fn(x): \\n            \"\"\"Collect query results while traversing the tree.\"\"\"\\n            trie.insert(x)\\n            for v, i in mp.get(x, []): ans[i] = trie.search(v)\\n            for xx in tree.get(x, []): fn(xx)\\n            trie.remove(x)\\n        \\n        fn(root)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348514,
                "title": "javascript-dfs-trie-and-deleting-from-a-trie-comments",
                "content": "* **Intuition**\\n\\nA naive way of going about this is a DFS and a stack. In that stack I keep the values of the ancestors of my current node and the current node included. By checking the xor of VAL with every value inside the stack, I can answer any query of the form [curnode, VAL]. That would of course result in a  O(N^2) runtime and would therefore TLE. \\nOne can notice, however, that in order to maximize the xor of any number X with some others [y1,y2,...y3] the ideal solution would be to pick a yi such that yi^X have a set bit that\\'s as left as possible because this is how the maximum xor occurs. If there are 2 or more such yis that have a set bit let\\'s say 14 positions to the left, the same logic applies for any position <14 . So if there was a way for storing my numbers in terms of bits that I could rapidly traverse, that would be great.\\nA trie is an excellent candidate for my task. All that my trie needs is a pointer to 0 or 1 if any numbers that have the k-th bit unset/set respectively are stored inside the Trie. \\nDuring the stack Implementation, one would need to pop a value from the stack once a dfs step  was finished, so that the current value is NOT available for different branches inside the stack. \\nConsider this case:\\n**Root**\\n| \\\\\\\\\\n**B**  **C**\\nB should never be available when the time comes to decide on any solution of the form [C,VAL]\\ntherefore after I finish answering queries on B, the stack should go from [ROOT,B] to just [ROOT]\\n\\nIn order for me to achieve this in my Trie, I store the first change that was ever made inside that Trie, and I cut the branch once the dfs step finishes.\\n\\n* **Implementation**\\n```\\nclass Trie{\\n    constructor(){\\n        this.T=[-1,-1]\\n    }\\n    insert(val){\\n        let cur=this.T,firstchangeNode=null,fcIndex=null\\n        for(let i=17;i>=0;i--){ // a node can be up to (1e5), whose log2 is 17, so at most we need 17 bits\\n            let next=Number(Boolean(val&(1<<i)))\\n            if(cur[next]===-1){\\n                if(firstchangeNode===null)\\n                    firstchangeNode=cur,fcIndex=next\\n                cur[next]=[-1,-1]\\n            }\\n            cur=cur[next]\\n        }\\n        // memorize the first change (if any) that was made during the insertion of val\\n        return [firstchangeNode,fcIndex] \\n    }\\n    search(val){\\n        let cur=this.T,res=0\\n        for(let i=17;i>=0;i--){\\n            let xor= 1^Number(Boolean(val&(1<<i)))\\n            if(cur[xor]!==-1)\\n                cur=cur[xor],res|=(1<<i)\\n            else\\n                cur=cur[xor^1]\\n        }\\n        return res\\n    }\\n}\\nvar maxGeneticDifference = function(parents, queries) {\\n    let root,n=parents.length,res=[...Array(n)].map(d=>{}),\\n        Q=[...Array(n)].map(d=>[]),adj=[...Array(n)].map(d=>[])\\n    // create some objects for fast access to the results\\n    for(let [node,val] of queries)\\n        Q[node].push(val),\\n        res[node]={},res[node][val]=undefined\\n    // create an adjacency list that points to the next node \\n    for(let i=0;i<parents.length;i++)\\n        if(parents[i]!==-1)\\n            adj[parents[i]].push(i)\\n        else \\n            root=i\\n    let T=new Trie()\\n    //traverse the tree\\n    let dfs=(node)=>{\\n        let [fnode,index]=T.insert(node) //insert the value of a node to our trie\\n        for(let q of Q[node]) //answer all the queries for our current node\\n            res[node][q]=T.search(q) \\n        for(let nei of adj[node]) // dfs to the children nodes\\n            dfs(nei)\\n        if(fnode!==null) // if my trie was altered during this turn, revert the change\\n            fnode[index]=-1\\n    }\\n    dfs(root)\\n    //return the results, which have already been calculated \\n    return queries.map( ([node,val])=>res[node][val])\\n};\\n```\\n* **Complexity**\\n\\nO(N) Time and Space",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\n    constructor(){\\n        this.T=[-1,-1]\\n    }\\n    insert(val){\\n        let cur=this.T,firstchangeNode=null,fcIndex=null\\n        for(let i=17;i>=0;i--){ // a node can be up to (1e5), whose log2 is 17, so at most we need 17 bits\\n            let next=Number(Boolean(val&(1<<i)))\\n            if(cur[next]===-1){\\n                if(firstchangeNode===null)\\n                    firstchangeNode=cur,fcIndex=next\\n                cur[next]=[-1,-1]\\n            }\\n            cur=cur[next]\\n        }\\n        // memorize the first change (if any) that was made during the insertion of val\\n        return [firstchangeNode,fcIndex] \\n    }\\n    search(val){\\n        let cur=this.T,res=0\\n        for(let i=17;i>=0;i--){\\n            let xor= 1^Number(Boolean(val&(1<<i)))\\n            if(cur[xor]!==-1)\\n                cur=cur[xor],res|=(1<<i)\\n            else\\n                cur=cur[xor^1]\\n        }\\n        return res\\n    }\\n}\\nvar maxGeneticDifference = function(parents, queries) {\\n    let root,n=parents.length,res=[...Array(n)].map(d=>{}),\\n        Q=[...Array(n)].map(d=>[]),adj=[...Array(n)].map(d=>[])\\n    // create some objects for fast access to the results\\n    for(let [node,val] of queries)\\n        Q[node].push(val),\\n        res[node]={},res[node][val]=undefined\\n    // create an adjacency list that points to the next node \\n    for(let i=0;i<parents.length;i++)\\n        if(parents[i]!==-1)\\n            adj[parents[i]].push(i)\\n        else \\n            root=i\\n    let T=new Trie()\\n    //traverse the tree\\n    let dfs=(node)=>{\\n        let [fnode,index]=T.insert(node) //insert the value of a node to our trie\\n        for(let q of Q[node]) //answer all the queries for our current node\\n            res[node][q]=T.search(q) \\n        for(let nei of adj[node]) // dfs to the children nodes\\n            dfs(nei)\\n        if(fnode!==null) // if my trie was altered during this turn, revert the change\\n            fnode[index]=-1\\n    }\\n    dfs(root)\\n    //return the results, which have already been calculated \\n    return queries.map( ([node,val])=>res[node][val])\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348380,
                "title": "clean-code-beats-100-time-memory-c",
                "content": "```\\nstruct TrieNode{\\n    TrieNode *child[2];\\n    int c;\\n    TrieNode(){\\n        child[0]=child[1]=NULL;\\n        c=0;\\n    }\\n};\\nvoid incre(TrieNode *root,int n,int d){\\n    for(int i=20;i>=0;i--){\\n        bool x=n&(1<<i);\\n        if(!root->child[x]){\\n            root->child[x]=new TrieNode();\\n        }\\n        root->child[x]->c+=d;\\n        root=root->child[x];\\n    }\\n}\\nint findmax(TrieNode *root,int n){\\n    int s=0;\\n    for(int i=20;i>=0 && root;i--){\\n        bool x=n&(1<<i);\\n        if(root->child[1-x] && root->child[1-x]->c>0){\\n            s|=(1<<i);\\n            root=root->child[1-x];\\n        }\\n        else{\\n        root=root->child[x];\\n        }\\n    }\\n    return s;\\n}\\nTrieNode *root=new TrieNode();\\nvoid dfs(int u,vector<vector<int>> &graph,vector<vector<pair<int,int>>> &processvalue,vector<int> &ans){\\n    incre(root,u,1);\\n    for(auto &x : processvalue[u]){\\n        ans[x.second]=findmax(root,x.first);\\n    }\\n    for(auto v : graph[u]){\\n        dfs(v,graph,processvalue,ans);\\n    }\\n    incre(root,u,-1);\\n}\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n=parents.size();\\n        vector<vector<int>> graph(n);\\n        vector<vector<pair<int,int>>> processvalue(n);\\n        vector<int> ans(queries.size());\\n        int r;\\n        for(int i=0;i<n;i++){\\n            if(parents[i]!=-1)graph[parents[i]].push_back(i);\\n            else{r=i;}\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            processvalue[queries[i][0]].push_back({queries[i][1],i});\\n        }\\n        dfs(r,graph,processvalue,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct TrieNode{\\n    TrieNode *child[2];\\n    int c;\\n    TrieNode(){\\n        child[0]=child[1]=NULL;\\n        c=0;\\n    }\\n};\\nvoid incre(TrieNode *root,int n,int d){\\n    for(int i=20;i>=0;i--){\\n        bool x=n&(1<<i);\\n        if(!root->child[x]){\\n            root->child[x]=new TrieNode();\\n        }\\n        root->child[x]->c+=d;\\n        root=root->child[x];\\n    }\\n}\\nint findmax(TrieNode *root,int n){\\n    int s=0;\\n    for(int i=20;i>=0 && root;i--){\\n        bool x=n&(1<<i);\\n        if(root->child[1-x] && root->child[1-x]->c>0){\\n            s|=(1<<i);\\n            root=root->child[1-x];\\n        }\\n        else{\\n        root=root->child[x];\\n        }\\n    }\\n    return s;\\n}\\nTrieNode *root=new TrieNode();\\nvoid dfs(int u,vector<vector<int>> &graph,vector<vector<pair<int,int>>> &processvalue,vector<int> &ans){\\n    incre(root,u,1);\\n    for(auto &x : processvalue[u]){\\n        ans[x.second]=findmax(root,x.first);\\n    }\\n    for(auto v : graph[u]){\\n        dfs(v,graph,processvalue,ans);\\n    }\\n    incre(root,u,-1);\\n}\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n=parents.size();\\n        vector<vector<int>> graph(n);\\n        vector<vector<pair<int,int>>> processvalue(n);\\n        vector<int> ans(queries.size());\\n        int r;\\n        for(int i=0;i<n;i++){\\n            if(parents[i]!=-1)graph[parents[i]].push_back(i);\\n            else{r=i;}\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            processvalue[queries[i][0]].push_back({queries[i][1],i});\\n        }\\n        dfs(r,graph,processvalue,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345061,
                "title": "why-is-my-trie-dfs-python-solution-tle",
                "content": "From reading other solutions, it seems my solution has the right idea. But it\\'s TLE. Would anyone kindly help me understand why? Much appreciated!\\n\\n```\\nBITS = 18\\n\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.count = 1\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node(None)\\n    \\n    def insert(self, num):\\n        curr = self.root\\n        for i in range(BITS, -1, -1):\\n            bit = (num >> i) & 1\\n            if bit not in curr.children:\\n                curr.children[bit] = Node(bit)\\n            else:\\n                curr.children[bit].count += 1\\n            curr = curr.children[bit]\\n    \\n    def delete(self, num):\\n        curr = self.root\\n        for i in range(BITS, -1, -1):\\n            bit = (num >> i) & 1\\n            child = curr.children[bit]\\n            if child.count == 1:\\n                curr.children.pop(bit, None)\\n                break\\n            child.count -= 1\\n            curr = child\\n\\n    def query(self, num):\\n        ans = 0\\n        curr = self.root\\n        if len(curr.children) == 0:\\n            return -1\\n        \\n        for i in range(BITS, -1, -1):\\n            bit = (num >> i) & 1\\n            node = 1 - bit if 1 - bit in curr.children else bit\\n            ans += (node ^ bit) << i\\n            curr = curr.children[node]\\n        return ans\\n\\n    \\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        tree = defaultdict(list)\\n        for (child, parent) in enumerate(parents):\\n            tree[parent].append(child)\\n        query_dict = defaultdict(list)\\n        for idx, (node, val) in enumerate(queries):\\n            query_dict[node].append((val, idx))\\n        ans = [0 for _ in range(len(queries))]\\n        \\n        trie = Trie()\\n        def dfs(node):\\n            if node != -1:\\n                trie.insert(node)\\n                for (val, idx) in query_dict[node]:\\n                    ans[idx] = trie.query(val)\\n            \\n            for child in tree[node]:\\n                dfs(child)\\n            \\n            if node != -1:\\n                trie.delete(node)\\n        \\n        dfs(-1)\\n        return ans        \\n```",
                "solutionTags": [],
                "code": "```\\nBITS = 18\\n\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.count = 1\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node(None)\\n    \\n    def insert(self, num):\\n        curr = self.root\\n        for i in range(BITS, -1, -1):\\n            bit = (num >> i) & 1\\n            if bit not in curr.children:\\n                curr.children[bit] = Node(bit)\\n            else:\\n                curr.children[bit].count += 1\\n            curr = curr.children[bit]\\n    \\n    def delete(self, num):\\n        curr = self.root\\n        for i in range(BITS, -1, -1):\\n            bit = (num >> i) & 1\\n            child = curr.children[bit]\\n            if child.count == 1:\\n                curr.children.pop(bit, None)\\n                break\\n            child.count -= 1\\n            curr = child\\n\\n    def query(self, num):\\n        ans = 0\\n        curr = self.root\\n        if len(curr.children) == 0:\\n            return -1\\n        \\n        for i in range(BITS, -1, -1):\\n            bit = (num >> i) & 1\\n            node = 1 - bit if 1 - bit in curr.children else bit\\n            ans += (node ^ bit) << i\\n            curr = curr.children[node]\\n        return ans\\n\\n    \\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        tree = defaultdict(list)\\n        for (child, parent) in enumerate(parents):\\n            tree[parent].append(child)\\n        query_dict = defaultdict(list)\\n        for idx, (node, val) in enumerate(queries):\\n            query_dict[node].append((val, idx))\\n        ans = [0 for _ in range(len(queries))]\\n        \\n        trie = Trie()\\n        def dfs(node):\\n            if node != -1:\\n                trie.insert(node)\\n                for (val, idx) in query_dict[node]:\\n                    ans[idx] = trie.query(val)\\n            \\n            for child in tree[node]:\\n                dfs(child)\\n            \\n            if node != -1:\\n                trie.delete(node)\\n        \\n        dfs(-1)\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344969,
                "title": "java-dfs-trie-t-o-n-q-s-o-n-q-detailed-explanation-with-comments",
                "content": "```\\n/*\\n The solution is similar as the problem to find the maximum XOR of a pair of numbers from an array of numbers.\\n Here, we start from the root and traverse the tree in the form of DFS.\\n For a node, we insert the node\\'s value in a trie and for each query involving the particular node, we find the\\n number from the trie for which the value of XOR between the given query value and the number is maximum.\\n Then we traverse to its child\\'s nodes. While retreating back we remove the node\\'s value from the trie.\\n*/\\nclass Solution {\\n    Trie root;\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n       \\n        // For each node, the queries corresponding to the node is inserted, along with index of the query.\\n        int k=0;\\n        HashMap<Integer,List<int[]>>hmap=new HashMap<>();\\n        for(int []q:queries){\\n            hmap.putIfAbsent(q[0],new ArrayList<>());\\n            hmap.get(q[0]).add(new int[]{k++,q[1]});\\n        }\\n       \\n        int n=parents.length;\\n       \\n        // Creating the graph.\\n        List<Integer>list[]=new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            list[i]=new ArrayList<>();\\n        int r=-1;\\n        for(int i=0;i<n;i++){\\n            if(parents[i]==-1)\\n                r=i;\\n            else\\n                list[parents[i]].add(i);\\n        }\\n       \\n       \\n        int q=queries.length;\\n        int []ans=new int[q];\\n        root=new Trie(0);        \\n       \\n        // tree traversal\\n        dfs(r,hmap,list,ans);\\n        return ans;\\n    }\\n    public void dfs(int u, HashMap<Integer,List<int[]>>hmap, List<Integer>list[], int []ans){\\n        // we insert the node\\'s value to the trie.\\n        insert(u);\\n        // for each query involving the node, we find the value of maximum XOR possible.\\n        if(hmap.containsKey(u)){\\n            for(int []e:hmap.get(u)){\\n                ans[e[0]]=find(e[1]);\\n            }\\n        }\\n        // traversal of the child nodes.\\n        for(int v:list[u]){\\n            dfs(v,hmap,list,ans);\\n        }\\n        // removing the node\\'s value from the trie.\\n        remove(u);\\n    }\\n    public void insert(int v){\\n        /*\\n            Convert the given value to a binary string of length 32.\\n            Insert the value into the trie.\\n            We go to the left, if we find a bit to be 0, and right if 1.\\n            val stores the frequency of numbers.\\n        */\\n        Trie tr=root;\\n        StringBuilder sbr=new StringBuilder(Integer.toBinaryString(v)).reverse();\\n        while(sbr.length()<32)\\n            sbr.append(\\'0\\');\\n        String s=sbr.reverse().toString();\\n        for(char c:s.toCharArray()){\\n            if(c==\\'0\\'){\\n                if(tr.left==null){\\n                    tr.left=new Trie(1);\\n                    tr=tr.left;\\n                }\\n                else{\\n                    tr=tr.left;\\n                    tr.val++;\\n                }\\n            }\\n            else{\\n                if(tr.right==null){\\n                    tr.right=new Trie(1);\\n                    tr=tr.right;\\n                }\\n                else{\\n                    tr=tr.right;\\n                    tr.val++;\\n                }\\n            }\\n        }\\n    }\\n    public int find(int v){\\n        /*\\n            Find maximum XOR between the given value and any number from the trie.            \\n        */\\n        Trie tr=root;\\n        StringBuilder sbr=new StringBuilder(Integer.toBinaryString(v)).reverse();\\n        while(sbr.length()<32)\\n            sbr.append(\\'0\\');\\n        String s=sbr.reverse().toString();\\n        int ans=0;\\n        long t=(1l<<31);\\n        for(char c:s.toCharArray()){\\n            if(c==\\'0\\'){\\n                if(tr.right==null||tr.right.val==0)\\n                    tr=tr.left;                \\n                else{\\n                    tr=tr.right;\\n                    ans|=t;\\n                }\\n            }\\n            else{\\n                if(tr.left==null||tr.left.val==0)\\n                    tr=tr.right;                \\n                else{\\n                    tr=tr.left;\\n                    ans|=t;\\n                }\\n            }\\n            t>>=1;\\n        }\\n        return ans;\\n    }\\n    public void remove(int v){\\n        /*\\n            We remove the given value from the trie.\\n        */\\n        Trie tr=root;\\n        StringBuilder sbr=new StringBuilder(Integer.toBinaryString(v)).reverse();\\n        while(sbr.length()<32)\\n            sbr.append(\\'0\\');\\n        String s=sbr.reverse().toString();\\n        for(char c:s.toCharArray()){\\n            if(c==\\'0\\'){                \\n                tr=tr.left;\\n                tr.val--;\\n            }\\n            else{\\n                tr=tr.right;\\n                tr.val--;\\n            }\\n        }        \\n    }\\n}\\nclass Trie{\\n    int val;\\n    Trie left,right;\\n    Trie(int v){\\n        val=v;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n The solution is similar as the problem to find the maximum XOR of a pair of numbers from an array of numbers.\\n Here, we start from the root and traverse the tree in the form of DFS.\\n For a node, we insert the node\\'s value in a trie and for each query involving the particular node, we find the\\n number from the trie for which the value of XOR between the given query value and the number is maximum.\\n Then we traverse to its child\\'s nodes. While retreating back we remove the node\\'s value from the trie.\\n*/\\nclass Solution {\\n    Trie root;\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n       \\n        // For each node, the queries corresponding to the node is inserted, along with index of the query.\\n        int k=0;\\n        HashMap<Integer,List<int[]>>hmap=new HashMap<>();\\n        for(int []q:queries){\\n            hmap.putIfAbsent(q[0],new ArrayList<>());\\n            hmap.get(q[0]).add(new int[]{k++,q[1]});\\n        }\\n       \\n        int n=parents.length;\\n       \\n        // Creating the graph.\\n        List<Integer>list[]=new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            list[i]=new ArrayList<>();\\n        int r=-1;\\n        for(int i=0;i<n;i++){\\n            if(parents[i]==-1)\\n                r=i;\\n            else\\n                list[parents[i]].add(i);\\n        }\\n       \\n       \\n        int q=queries.length;\\n        int []ans=new int[q];\\n        root=new Trie(0);        \\n       \\n        // tree traversal\\n        dfs(r,hmap,list,ans);\\n        return ans;\\n    }\\n    public void dfs(int u, HashMap<Integer,List<int[]>>hmap, List<Integer>list[], int []ans){\\n        // we insert the node\\'s value to the trie.\\n        insert(u);\\n        // for each query involving the node, we find the value of maximum XOR possible.\\n        if(hmap.containsKey(u)){\\n            for(int []e:hmap.get(u)){\\n                ans[e[0]]=find(e[1]);\\n            }\\n        }\\n        // traversal of the child nodes.\\n        for(int v:list[u]){\\n            dfs(v,hmap,list,ans);\\n        }\\n        // removing the node\\'s value from the trie.\\n        remove(u);\\n    }\\n    public void insert(int v){\\n        /*\\n            Convert the given value to a binary string of length 32.\\n            Insert the value into the trie.\\n            We go to the left, if we find a bit to be 0, and right if 1.\\n            val stores the frequency of numbers.\\n        */\\n        Trie tr=root;\\n        StringBuilder sbr=new StringBuilder(Integer.toBinaryString(v)).reverse();\\n        while(sbr.length()<32)\\n            sbr.append(\\'0\\');\\n        String s=sbr.reverse().toString();\\n        for(char c:s.toCharArray()){\\n            if(c==\\'0\\'){\\n                if(tr.left==null){\\n                    tr.left=new Trie(1);\\n                    tr=tr.left;\\n                }\\n                else{\\n                    tr=tr.left;\\n                    tr.val++;\\n                }\\n            }\\n            else{\\n                if(tr.right==null){\\n                    tr.right=new Trie(1);\\n                    tr=tr.right;\\n                }\\n                else{\\n                    tr=tr.right;\\n                    tr.val++;\\n                }\\n            }\\n        }\\n    }\\n    public int find(int v){\\n        /*\\n            Find maximum XOR between the given value and any number from the trie.            \\n        */\\n        Trie tr=root;\\n        StringBuilder sbr=new StringBuilder(Integer.toBinaryString(v)).reverse();\\n        while(sbr.length()<32)\\n            sbr.append(\\'0\\');\\n        String s=sbr.reverse().toString();\\n        int ans=0;\\n        long t=(1l<<31);\\n        for(char c:s.toCharArray()){\\n            if(c==\\'0\\'){\\n                if(tr.right==null||tr.right.val==0)\\n                    tr=tr.left;                \\n                else{\\n                    tr=tr.right;\\n                    ans|=t;\\n                }\\n            }\\n            else{\\n                if(tr.left==null||tr.left.val==0)\\n                    tr=tr.right;                \\n                else{\\n                    tr=tr.left;\\n                    ans|=t;\\n                }\\n            }\\n            t>>=1;\\n        }\\n        return ans;\\n    }\\n    public void remove(int v){\\n        /*\\n            We remove the given value from the trie.\\n        */\\n        Trie tr=root;\\n        StringBuilder sbr=new StringBuilder(Integer.toBinaryString(v)).reverse();\\n        while(sbr.length()<32)\\n            sbr.append(\\'0\\');\\n        String s=sbr.reverse().toString();\\n        for(char c:s.toCharArray()){\\n            if(c==\\'0\\'){                \\n                tr=tr.left;\\n                tr.val--;\\n            }\\n            else{\\n                tr=tr.right;\\n                tr.val--;\\n            }\\n        }        \\n    }\\n}\\nclass Trie{\\n    int val;\\n    Trie left,right;\\n    Trie(int v){\\n        val=v;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987706,
                "title": "awesome-trie-erase-function",
                "content": "# Code\\n```\\nclass node{\\npublic:\\n    node* child[2];\\n    int cnt;\\n    node(){\\n        child[0]=child[1]=NULL;\\n        cnt=0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>> mp;\\n    vector<int> ans;\\n    node* root=new node();\\n    void insert(int num){\\n        node* temp=root;\\n        for(int i=20;i>=0;i--){\\n            int bit_num=(bool)(num & (1<<i));\\n            if(!temp->child[bit_num]){\\n                temp->child[bit_num]=new node();\\n            }\\n            temp->child[bit_num]->cnt++;\\n            temp=temp->child[bit_num];\\n        }\\n    }\\n    void erase(int num){\\n        node* temp=root;\\n        for(int i=20;i>=0;i--){\\n            int bit_num=(bool)(num & (1<<i));\\n            temp->child[bit_num]->cnt--;\\n            if(temp->child[bit_num]==0){\\n                temp->child[bit_num]=NULL;\\n                break;\\n            }\\n            temp=temp->child[bit_num];\\n        }\\n    }\\n    int func(int num){\\n        node* temp=root;\\n        int sum=0;\\n        for(int i=20;i>=0;i--){\\n            int bit_num=(bool)(num & (1<<i));\\n            if(temp->child[1-bit_num] && (temp->child[1-bit_num]->cnt)>0){\\n                sum+=(1<<i);\\n                temp=temp->child[1-bit_num];\\n            }else{\\n                temp=temp->child[bit_num];\\n            }\\n        }\\n        return sum;\\n    }\\n    void dfs(int node,vector<int> &vis,vector<vector<int>> &adj){\\n        vis[node]=1;\\n        insert(node);\\n        if(mp.find(node)!=mp.end()){\\n            for(auto it:mp[node]){\\n                ans[it.second]=func(it.first);\\n            }\\n        }\\n        for(int it:adj[node]){\\n            if(vis[it]==0) dfs(it,vis,adj);\\n        }\\n        erase(node);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        ans.resize(queries.size());\\n        for(int i=0;i<queries.size();i++){\\n            mp[queries[i][0]].push_back({queries[i][1],i});\\n        }\\n        int n=parents.size();\\n        vector<vector<int>> adj(n);\\n        int par=-1;\\n        for(int i=0;i<n;i++){\\n            int u=parents[i];\\n            if(u==-1){ \\n                par=i;\\n                continue;\\n            }\\n            adj[u].push_back(i);\\n            adj[i].push_back(u);\\n        }\\n        vector<int> vis(n,0);\\n        dfs(par,vis,adj);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass node{\\npublic:\\n    node* child[2];\\n    int cnt;\\n    node(){\\n        child[0]=child[1]=NULL;\\n        cnt=0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>> mp;\\n    vector<int> ans;\\n    node* root=new node();\\n    void insert(int num){\\n        node* temp=root;\\n        for(int i=20;i>=0;i--){\\n            int bit_num=(bool)(num & (1<<i));\\n            if(!temp->child[bit_num]){\\n                temp->child[bit_num]=new node();\\n            }\\n            temp->child[bit_num]->cnt++;\\n            temp=temp->child[bit_num];\\n        }\\n    }\\n    void erase(int num){\\n        node* temp=root;\\n        for(int i=20;i>=0;i--){\\n            int bit_num=(bool)(num & (1<<i));\\n            temp->child[bit_num]->cnt--;\\n            if(temp->child[bit_num]==0){\\n                temp->child[bit_num]=NULL;\\n                break;\\n            }\\n            temp=temp->child[bit_num];\\n        }\\n    }\\n    int func(int num){\\n        node* temp=root;\\n        int sum=0;\\n        for(int i=20;i>=0;i--){\\n            int bit_num=(bool)(num & (1<<i));\\n            if(temp->child[1-bit_num] && (temp->child[1-bit_num]->cnt)>0){\\n                sum+=(1<<i);\\n                temp=temp->child[1-bit_num];\\n            }else{\\n                temp=temp->child[bit_num];\\n            }\\n        }\\n        return sum;\\n    }\\n    void dfs(int node,vector<int> &vis,vector<vector<int>> &adj){\\n        vis[node]=1;\\n        insert(node);\\n        if(mp.find(node)!=mp.end()){\\n            for(auto it:mp[node]){\\n                ans[it.second]=func(it.first);\\n            }\\n        }\\n        for(int it:adj[node]){\\n            if(vis[it]==0) dfs(it,vis,adj);\\n        }\\n        erase(node);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        ans.resize(queries.size());\\n        for(int i=0;i<queries.size();i++){\\n            mp[queries[i][0]].push_back({queries[i][1],i});\\n        }\\n        int n=parents.size();\\n        vector<vector<int>> adj(n);\\n        int par=-1;\\n        for(int i=0;i<n;i++){\\n            int u=parents[i];\\n            if(u==-1){ \\n                par=i;\\n                continue;\\n            }\\n            adj[u].push_back(i);\\n            adj[i].push_back(u);\\n        }\\n        vector<int> vis(n,0);\\n        dfs(par,vis,adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970587,
                "title": "c-solution-using-trie",
                "content": "# Code\\n```\\nstruct Node {\\n    Node* links[2];\\n    int flag = 0, count=0;\\n\\n    bool containsKey(int bit){\\n        if(links[bit])\\n            return true;\\n        return false;\\n    }\\n\\n    void put(int bit, Node* node){\\n        links[bit] = node;\\n    }\\n\\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n\\n    bool isEnd(){\\n        return flag;\\n    }\\n\\n    void setEnd(){\\n        flag = true;\\n    }\\n\\n    void incrementCount(){\\n        ++count;\\n    }\\n\\n    int getCount(){\\n        return count;\\n    }\\n\\n    void decrementCount(){\\n        --count;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n\\n    void insert(int num){\\n        Node* node = root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i) & 1;\\n            if(!node -> containsKey(bit)){\\n                node -> put(bit, new Node());\\n            }\\n\\n            node -> incrementCount();\\n            node = node -> get(bit);\\n        }\\n\\n        node -> incrementCount();\\n        node -> setEnd();\\n    }\\n\\n    void remove(int num){\\n        Node* node = root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i) & 1;\\n            node -> decrementCount();\\n            Node* temp = node -> get(bit);\\n            if(temp -> getCount() == 1){\\n                node -> links[bit] = NULL;\\n                return;\\n            }\\n            node = temp;\\n        }\\n    }\\n\\n    int maxXor(int num){\\n        Node* node = root;\\n        int res = 0;\\n\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i) & 1;\\n            if(node -> containsKey(1-bit)){\\n                res+=(1<<i);\\n                node = node -> get(1-bit);\\n            }\\n            else{\\n                node = node -> get(bit);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void solve(map<int, vector<vector<int>>>&q, vector<int>adj[], int node, Trie* trie, vector<int>&res){\\n        trie -> insert(node);\\n        for(auto it: q[node]){\\n            int val = it[0];\\n            int index = it[1];\\n            res[index] = trie -> maxXor(val);\\n        }\\n\\n        for(auto it: adj[node]){\\n            solve(q, adj, it, trie, res);\\n        }\\n\\n        trie -> remove(node);\\n    }\\n\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size();\\n        vector<int>adj[n];\\n        int root = 0;\\n        for(int i=0;i<n;i++){\\n            if(parents[i] != -1){\\n                adj[parents[i]].push_back(i);\\n            }\\n            else\\n                root = i;\\n        }\\n\\n        map<int, vector<vector<int>>>q;\\n        for(int i=0;i<queries.size();i++){\\n            q[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n\\n        int m = queries.size();\\n        vector<int>res(m);\\n        Trie* trie = new Trie();\\n        solve(q, adj, root, trie, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n    Node* links[2];\\n    int flag = 0, count=0;\\n\\n    bool containsKey(int bit){\\n        if(links[bit])\\n            return true;\\n        return false;\\n    }\\n\\n    void put(int bit, Node* node){\\n        links[bit] = node;\\n    }\\n\\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n\\n    bool isEnd(){\\n        return flag;\\n    }\\n\\n    void setEnd(){\\n        flag = true;\\n    }\\n\\n    void incrementCount(){\\n        ++count;\\n    }\\n\\n    int getCount(){\\n        return count;\\n    }\\n\\n    void decrementCount(){\\n        --count;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n\\n    void insert(int num){\\n        Node* node = root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i) & 1;\\n            if(!node -> containsKey(bit)){\\n                node -> put(bit, new Node());\\n            }\\n\\n            node -> incrementCount();\\n            node = node -> get(bit);\\n        }\\n\\n        node -> incrementCount();\\n        node -> setEnd();\\n    }\\n\\n    void remove(int num){\\n        Node* node = root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i) & 1;\\n            node -> decrementCount();\\n            Node* temp = node -> get(bit);\\n            if(temp -> getCount() == 1){\\n                node -> links[bit] = NULL;\\n                return;\\n            }\\n            node = temp;\\n        }\\n    }\\n\\n    int maxXor(int num){\\n        Node* node = root;\\n        int res = 0;\\n\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i) & 1;\\n            if(node -> containsKey(1-bit)){\\n                res+=(1<<i);\\n                node = node -> get(1-bit);\\n            }\\n            else{\\n                node = node -> get(bit);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void solve(map<int, vector<vector<int>>>&q, vector<int>adj[], int node, Trie* trie, vector<int>&res){\\n        trie -> insert(node);\\n        for(auto it: q[node]){\\n            int val = it[0];\\n            int index = it[1];\\n            res[index] = trie -> maxXor(val);\\n        }\\n\\n        for(auto it: adj[node]){\\n            solve(q, adj, it, trie, res);\\n        }\\n\\n        trie -> remove(node);\\n    }\\n\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size();\\n        vector<int>adj[n];\\n        int root = 0;\\n        for(int i=0;i<n;i++){\\n            if(parents[i] != -1){\\n                adj[parents[i]].push_back(i);\\n            }\\n            else\\n                root = i;\\n        }\\n\\n        map<int, vector<vector<int>>>q;\\n        for(int i=0;i<queries.size();i++){\\n            q[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n\\n        int m = queries.size();\\n        vector<int>res(m);\\n        Trie* trie = new Trie();\\n        solve(q, adj, root, trie, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933161,
                "title": "faster-than-100-simple-idea-using-trie",
                "content": "# Intuition\\nAny path from root to node can be think of as an array , now consider each query which involves this node , now this problems resembles exactly to find maximum xor for each query in a array which can be done using Trie\\n# Approach\\nMaintain a Trie which will have the information of every node from root to current node , this kind of information is easily maintainable using dfs (Refer to code for more clarity)\\n# Complexity\\n- Time complexity:\\n  O(N+Qlog(N))\\n- Space complexity:\\n- O(N+Qlog(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct node{\\n    node *child[2];\\n    int ct;\\n    node(){\\n        ct=0;\\n        child[0]=child[1]=NULL;\\n    }\\n};\\nvector<vector<int>>g;\\nvector<vector<pair<int,int>>>Q;\\nvector<int>ans;\\nvoid insert(node *root,int num){\\n    for(int i=17;i>=0;i--){\\n        int x=((1<<i)&num)?1:0;\\n        root->ct++;\\n        if(!root->child[x]){\\n            root->child[x]=new node();\\n        }\\n        root=root->child[x];\\n    }\\n    root->ct++;\\n}\\nvoid remove(node *root,int num){\\n    for(int i=17;i>=0;i--){\\n        int x=((1<<i)&num)?1:0;\\n        root->ct--;\\n        root=root->child[x];\\n    }\\n    root->ct--;\\n}\\nint find(node *cur,int num){\\n    int ans=0;\\n    for(int i=17;i>=0;i--){\\n        int x=((1<<i)&num)?1:0;\\n        if(cur->child[x^1] && cur->child[1^x]->ct){\\n            ans|=(1<<i);\\n            cur=cur->child[1^x];\\n        }\\n        else{\\n            cur=cur->child[x];\\n        }\\n    }\\n    return ans;\\n}\\nclass Solution {\\npublic:\\n    void dfs(int v,node *cur){\\n        insert(cur,v);\\n        for(auto p:Q[v]){\\n            ans[p.first]=find(cur,p.second);\\n        }\\n        for(auto u:g[v]){\\n            dfs(u,cur);\\n        }\\n        remove(cur,v);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n=parents.size();\\n        int q=queries.size();\\n        ans.assign(q,0);\\n        g.assign(n,vector<int>());\\n        int par=0;\\n        Q.assign(n,vector<pair<int,int>>());\\n        for(int i=0;i<n;i++){\\n            if(parents[i]!=-1){\\n                g[parents[i]].push_back(i);\\n            }\\n            else par=i;\\n        }\\n        for(int i=0;i<q;i++){\\n           Q[queries[i][0]].push_back({i,queries[i][1]});\\n        }\\n        node *root=new node();\\n        dfs(par,root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct node{\\n    node *child[2];\\n    int ct;\\n    node(){\\n        ct=0;\\n        child[0]=child[1]=NULL;\\n    }\\n};\\nvector<vector<int>>g;\\nvector<vector<pair<int,int>>>Q;\\nvector<int>ans;\\nvoid insert(node *root,int num){\\n    for(int i=17;i>=0;i--){\\n        int x=((1<<i)&num)?1:0;\\n        root->ct++;\\n        if(!root->child[x]){\\n            root->child[x]=new node();\\n        }\\n        root=root->child[x];\\n    }\\n    root->ct++;\\n}\\nvoid remove(node *root,int num){\\n    for(int i=17;i>=0;i--){\\n        int x=((1<<i)&num)?1:0;\\n        root->ct--;\\n        root=root->child[x];\\n    }\\n    root->ct--;\\n}\\nint find(node *cur,int num){\\n    int ans=0;\\n    for(int i=17;i>=0;i--){\\n        int x=((1<<i)&num)?1:0;\\n        if(cur->child[x^1] && cur->child[1^x]->ct){\\n            ans|=(1<<i);\\n            cur=cur->child[1^x];\\n        }\\n        else{\\n            cur=cur->child[x];\\n        }\\n    }\\n    return ans;\\n}\\nclass Solution {\\npublic:\\n    void dfs(int v,node *cur){\\n        insert(cur,v);\\n        for(auto p:Q[v]){\\n            ans[p.first]=find(cur,p.second);\\n        }\\n        for(auto u:g[v]){\\n            dfs(u,cur);\\n        }\\n        remove(cur,v);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n=parents.size();\\n        int q=queries.size();\\n        ans.assign(q,0);\\n        g.assign(n,vector<int>());\\n        int par=0;\\n        Q.assign(n,vector<pair<int,int>>());\\n        for(int i=0;i<n;i++){\\n            if(parents[i]!=-1){\\n                g[parents[i]].push_back(i);\\n            }\\n            else par=i;\\n        }\\n        for(int i=0;i<q;i++){\\n           Q[queries[i][0]].push_back({i,queries[i][1]});\\n        }\\n        node *root=new node();\\n        dfs(par,root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905979,
                "title": "easy-hashmap-solution-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        adj_map = collections.defaultdict(set)\\n        root = None\\n        for i, node in enumerate(parents):\\n            if node == -1:\\n                root = i\\n            else:\\n                adj_map[node].add(i)\\n        queries_map = collections.defaultdict(set)\\n\\n        for q in queries:\\n            queries_map[q[0]].add(q[1])\\n        self.res_map = {}\\n        def helperDFS(curr_root,prefix_map):\\n\\n            if curr_root in queries_map:\\n                for val in queries_map[curr_root]:\\n                    bin_rep = format(val, \\'020b\\')\\n                    best_bin = \"\"\\n                    print(bin_rep)\\n                    for i in range(20):\\n                        if prefix_map[best_bin+str(1-int(bin_rep[i]))]:\\n                            best_bin += str(1-int(bin_rep[i]))\\n                        else:\\n                            best_bin += bin_rep[i]\\n                    self.res_map[(curr_root,val)] = int(best_bin,2) ^ val \\n            for child in adj_map[curr_root]:\\n                bin_rep = format(child, \\'020b\\')\\n                for i in range(1, len(bin_rep)+1):\\n                    prefix_map[bin_rep[0:i]].add(child)\\n                helperDFS(child, prefix_map)\\n                for i in range(1, len(bin_rep)+1):\\n                    prefix_map[bin_rep[0:i]].remove(child)\\n\\n        initial_prefixmap = collections.defaultdict(set)\\n        root_rep = format(root, \\'020b\\')\\n        for i in range(1,21):\\n            initial_prefixmap[root_rep[0:i]].add(root)\\n        helperDFS(root, initial_prefixmap)\\n        res = []\\n        for q in queries:\\n            res.append(self.res_map[(q[0],q[1])])\\n        return res\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        adj_map = collections.defaultdict(set)\\n        root = None\\n        for i, node in enumerate(parents):\\n            if node == -1:\\n                root = i\\n            else:\\n                adj_map[node].add(i)\\n        queries_map = collections.defaultdict(set)\\n\\n        for q in queries:\\n            queries_map[q[0]].add(q[1])\\n        self.res_map = {}\\n        def helperDFS(curr_root,prefix_map):\\n\\n            if curr_root in queries_map:\\n                for val in queries_map[curr_root]:\\n                    bin_rep = format(val, \\'020b\\')\\n                    best_bin = \"\"\\n                    print(bin_rep)\\n                    for i in range(20):\\n                        if prefix_map[best_bin+str(1-int(bin_rep[i]))]:\\n                            best_bin += str(1-int(bin_rep[i]))\\n                        else:\\n                            best_bin += bin_rep[i]\\n                    self.res_map[(curr_root,val)] = int(best_bin,2) ^ val \\n            for child in adj_map[curr_root]:\\n                bin_rep = format(child, \\'020b\\')\\n                for i in range(1, len(bin_rep)+1):\\n                    prefix_map[bin_rep[0:i]].add(child)\\n                helperDFS(child, prefix_map)\\n                for i in range(1, len(bin_rep)+1):\\n                    prefix_map[bin_rep[0:i]].remove(child)\\n\\n        initial_prefixmap = collections.defaultdict(set)\\n        root_rep = format(root, \\'020b\\')\\n        for i in range(1,21):\\n            initial_prefixmap[root_rep[0:i]].add(root)\\n        helperDFS(root, initial_prefixmap)\\n        res = []\\n        for q in queries:\\n            res.append(self.res_map[(q[0],q[1])])\\n        return res\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905978,
                "title": "easy-hashmap-solution-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        adj_map = collections.defaultdict(set)\\n        root = None\\n        for i, node in enumerate(parents):\\n            if node == -1:\\n                root = i\\n            else:\\n                adj_map[node].add(i)\\n        queries_map = collections.defaultdict(set)\\n\\n        for q in queries:\\n            queries_map[q[0]].add(q[1])\\n        self.res_map = {}\\n        def helperDFS(curr_root,prefix_map):\\n\\n            if curr_root in queries_map:\\n                for val in queries_map[curr_root]:\\n                    bin_rep = format(val, \\'020b\\')\\n                    best_bin = \"\"\\n                    print(bin_rep)\\n                    for i in range(20):\\n                        if prefix_map[best_bin+str(1-int(bin_rep[i]))]:\\n                            best_bin += str(1-int(bin_rep[i]))\\n                        else:\\n                            best_bin += bin_rep[i]\\n                    self.res_map[(curr_root,val)] = int(best_bin,2) ^ val \\n            for child in adj_map[curr_root]:\\n                bin_rep = format(child, \\'020b\\')\\n                for i in range(1, len(bin_rep)+1):\\n                    prefix_map[bin_rep[0:i]].add(child)\\n                helperDFS(child, prefix_map)\\n                for i in range(1, len(bin_rep)+1):\\n                    prefix_map[bin_rep[0:i]].remove(child)\\n\\n        initial_prefixmap = collections.defaultdict(set)\\n        root_rep = format(root, \\'020b\\')\\n        for i in range(1,21):\\n            initial_prefixmap[root_rep[0:i]].add(root)\\n        helperDFS(root, initial_prefixmap)\\n        res = []\\n        for q in queries:\\n            res.append(self.res_map[(q[0],q[1])])\\n        return res\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        adj_map = collections.defaultdict(set)\\n        root = None\\n        for i, node in enumerate(parents):\\n            if node == -1:\\n                root = i\\n            else:\\n                adj_map[node].add(i)\\n        queries_map = collections.defaultdict(set)\\n\\n        for q in queries:\\n            queries_map[q[0]].add(q[1])\\n        self.res_map = {}\\n        def helperDFS(curr_root,prefix_map):\\n\\n            if curr_root in queries_map:\\n                for val in queries_map[curr_root]:\\n                    bin_rep = format(val, \\'020b\\')\\n                    best_bin = \"\"\\n                    print(bin_rep)\\n                    for i in range(20):\\n                        if prefix_map[best_bin+str(1-int(bin_rep[i]))]:\\n                            best_bin += str(1-int(bin_rep[i]))\\n                        else:\\n                            best_bin += bin_rep[i]\\n                    self.res_map[(curr_root,val)] = int(best_bin,2) ^ val \\n            for child in adj_map[curr_root]:\\n                bin_rep = format(child, \\'020b\\')\\n                for i in range(1, len(bin_rep)+1):\\n                    prefix_map[bin_rep[0:i]].add(child)\\n                helperDFS(child, prefix_map)\\n                for i in range(1, len(bin_rep)+1):\\n                    prefix_map[bin_rep[0:i]].remove(child)\\n\\n        initial_prefixmap = collections.defaultdict(set)\\n        root_rep = format(root, \\'020b\\')\\n        for i in range(1,21):\\n            initial_prefixmap[root_rep[0:i]].add(root)\\n        helperDFS(root, initial_prefixmap)\\n        res = []\\n        for q in queries:\\n            res.append(self.res_map[(q[0],q[1])])\\n        return res\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898212,
                "title": "trie-without-pointer-s",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<vector<int>> graph;\\n    vector<vector<pair<int, int>>> qr;\\n    int N = 0;\\n    vector<vector<int>> trie;\\n    void dfs(int src, int par){\\n        int temp = 0, cnt = 0, PN = N, Temp1 = -1, Temp2 = -1;\\n        for(int i=20;i>=0;i--){\\n            if(((1<<i)&src)){\\n                if(trie[temp][1] != 0){\\n                    temp = trie[temp][1];\\n                }\\n                else{\\n                    trie.push_back(vector<int>(2));\\n                    trie[temp][1] = ++N;\\n                    if(Temp1 == -1){\\n                        Temp1 = temp, Temp2 = 1;\\n                    }\\n                    temp = trie[temp][1];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                if(trie[temp][0] != 0){\\n                    temp = trie[temp][0];\\n                }\\n                else{\\n                    trie.push_back(vector<int>(2));\\n                    trie[temp][0] = ++N;\\n                    if(Temp1 == -1){\\n                        Temp1 = temp, Temp2 = 0;\\n                    }\\n                    temp = trie[temp][0];\\n                    cnt++;\\n                }\\n            }\\n        }\\n        // Processing Answer .............\\n        for(auto nuts : qr[src]){\\n            pair<int, int> P = nuts;\\n            int val = P.first, idx = P.second, maxi = 0;\\n            // ans[idx] = maxi;\\n            temp = 0;\\n            for(int i=20;i>=0;i--){\\n                if(((1<<i)&val)){\\n                    if(trie[temp][0] != 0){\\n                        temp = trie[temp][0];\\n                        maxi += (1<<i);\\n                    }\\n                    else{\\n                        temp = trie[temp][1];\\n                    }\\n                }\\n                else{\\n                    if(trie[temp][1] != 0){\\n                        temp = trie[temp][1];\\n                        maxi += (1<<i);\\n                    }\\n                    else{\\n                        temp = trie[temp][0];\\n                    }\\n                }\\n            }\\n            ans[idx] = maxi;\\n        }\\n        //................................\\n        for(auto neigh : graph[src]){\\n            if(neigh != par){\\n                dfs(neigh, src);\\n            }\\n        }\\n        N = PN;\\n        for(int i=0;i<cnt;i++){\\n            trie.pop_back();\\n        }\\n        if(Temp1 != -1){\\n            trie[Temp1][Temp2] = 0;\\n        }\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& par, vector<vector<int>>& query) {\\n        int n = par.size(), root = -1;\\n        graph = vector<vector<int>> (n);\\n        trie = vector<vector<int>>(1, vector<int>(2));\\n        qr = vector<vector<pair<int, int>>> (n);\\n        for(int i=0;i<n;i++){\\n            if(par[i] == -1){\\n                root = i;\\n                continue;\\n            }\\n            graph[i].push_back(par[i]);\\n            graph[par[i]].push_back(i);\\n        }\\n        int q = query.size();\\n        ans = vector<int> (q);\\n        for(int i=0;i<q;i++){\\n            int x = query[i][0], val = query[i][1];\\n            qr[x].push_back({val, i});\\n        }\\n        dfs(root, root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<vector<int>> graph;\\n    vector<vector<pair<int, int>>> qr;\\n    int N = 0;\\n    vector<vector<int>> trie;\\n    void dfs(int src, int par){\\n        int temp = 0, cnt = 0, PN = N, Temp1 = -1, Temp2 = -1;\\n        for(int i=20;i>=0;i--){\\n            if(((1<<i)&src)){\\n                if(trie[temp][1] != 0){\\n                    temp = trie[temp][1];\\n                }\\n                else{\\n                    trie.push_back(vector<int>(2));\\n                    trie[temp][1] = ++N;\\n                    if(Temp1 == -1){\\n                        Temp1 = temp, Temp2 = 1;\\n                    }\\n                    temp = trie[temp][1];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                if(trie[temp][0] != 0){\\n                    temp = trie[temp][0];\\n                }\\n                else{\\n                    trie.push_back(vector<int>(2));\\n                    trie[temp][0] = ++N;\\n                    if(Temp1 == -1){\\n                        Temp1 = temp, Temp2 = 0;\\n                    }\\n                    temp = trie[temp][0];\\n                    cnt++;\\n                }\\n            }\\n        }\\n        // Processing Answer .............\\n        for(auto nuts : qr[src]){\\n            pair<int, int> P = nuts;\\n            int val = P.first, idx = P.second, maxi = 0;\\n            // ans[idx] = maxi;\\n            temp = 0;\\n            for(int i=20;i>=0;i--){\\n                if(((1<<i)&val)){\\n                    if(trie[temp][0] != 0){\\n                        temp = trie[temp][0];\\n                        maxi += (1<<i);\\n                    }\\n                    else{\\n                        temp = trie[temp][1];\\n                    }\\n                }\\n                else{\\n                    if(trie[temp][1] != 0){\\n                        temp = trie[temp][1];\\n                        maxi += (1<<i);\\n                    }\\n                    else{\\n                        temp = trie[temp][0];\\n                    }\\n                }\\n            }\\n            ans[idx] = maxi;\\n        }\\n        //................................\\n        for(auto neigh : graph[src]){\\n            if(neigh != par){\\n                dfs(neigh, src);\\n            }\\n        }\\n        N = PN;\\n        for(int i=0;i<cnt;i++){\\n            trie.pop_back();\\n        }\\n        if(Temp1 != -1){\\n            trie[Temp1][Temp2] = 0;\\n        }\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& par, vector<vector<int>>& query) {\\n        int n = par.size(), root = -1;\\n        graph = vector<vector<int>> (n);\\n        trie = vector<vector<int>>(1, vector<int>(2));\\n        qr = vector<vector<pair<int, int>>> (n);\\n        for(int i=0;i<n;i++){\\n            if(par[i] == -1){\\n                root = i;\\n                continue;\\n            }\\n            graph[i].push_back(par[i]);\\n            graph[par[i]].push_back(i);\\n        }\\n        int q = query.size();\\n        ans = vector<int> (q);\\n        for(int i=0;i<q;i++){\\n            int x = query[i][0], val = query[i][1];\\n            qr[x].push_back({val, i});\\n        }\\n        dfs(root, root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881565,
                "title": "trie-dfs",
                "content": "# Code\\n```\\nstruct Node\\n{\\n    Node* links[2];\\n    int prf=0;\\n\\n    bool containsKey(int key)\\n    {\\n        if(links[key] && links[key]->prf>0)\\n            return true;\\n        return false;\\n    }\\n\\n    void put(int key, Node* node)\\n    {\\n        links[key] = node;\\n    }\\n\\n    Node* get(int key)\\n    {\\n        return links[key];\\n    }\\n};\\n\\nclass Trie\\n{\\n    Node* root;\\n    public:\\n    Trie()\\n    {\\n        root = new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node* node = root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (num>>i)&1;\\n            if(!node->containsKey(bit))\\n            {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n            node->prf++;\\n        }\\n    }\\n\\n    void remove(int num)\\n    {\\n        Node* node = root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (num>>i)&1;\\n            if(node)\\n            {\\n                node = node->get(bit);\\n                if (node)\\n                    node->prf--;\\n            }\\n        }\\n    }\\n\\n    int getMaxXor(int val)\\n    {\\n        Node* node = root;\\n        int res = 0;\\n        int i = 0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (val>>i)&1;\\n            if(node && node->containsKey(1-bit))\\n            {\\n                res = res | (1<<i);\\n                node = node->get(1 - bit);\\n            }\\n            else if(node)\\n            {\\n                node=node->get(bit);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    Trie tr;\\n    void dfs(int node, vector<vector<int>> &graph, vector<vector<pair<int, int>>> &vec, vector<int> &res)\\n    {\\n        tr.insert(node);\\n        for(auto it : vec[node])\\n        {\\n            int val = it.second;\\n            res[it.first] = tr.getMaxXor(val);\\n        }\\n        for(auto it : graph[node])\\n        {\\n            dfs(it, graph, vec, res);\\n        }\\n        tr.remove(node);\\n    }\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size();\\n        vector<vector<int>> graph(n);\\n        int root = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(parents[i] == -1)\\n                root = i;\\n            else\\n            {\\n                graph[parents[i]].push_back(i);\\n            }\\n        }\\n        int m = queries.size();\\n        vector<vector<pair<int, int>>> vec(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            vec[queries[i][0]].push_back({i, queries[i][1]});\\n        }\\n        vector<int> res(m);\\n        dfs(root, graph, vec, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node\\n{\\n    Node* links[2];\\n    int prf=0;\\n\\n    bool containsKey(int key)\\n    {\\n        if(links[key] && links[key]->prf>0)\\n            return true;\\n        return false;\\n    }\\n\\n    void put(int key, Node* node)\\n    {\\n        links[key] = node;\\n    }\\n\\n    Node* get(int key)\\n    {\\n        return links[key];\\n    }\\n};\\n\\nclass Trie\\n{\\n    Node* root;\\n    public:\\n    Trie()\\n    {\\n        root = new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node* node = root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (num>>i)&1;\\n            if(!node->containsKey(bit))\\n            {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n            node->prf++;\\n        }\\n    }\\n\\n    void remove(int num)\\n    {\\n        Node* node = root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (num>>i)&1;\\n            if(node)\\n            {\\n                node = node->get(bit);\\n                if (node)\\n                    node->prf--;\\n            }\\n        }\\n    }\\n\\n    int getMaxXor(int val)\\n    {\\n        Node* node = root;\\n        int res = 0;\\n        int i = 0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (val>>i)&1;\\n            if(node && node->containsKey(1-bit))\\n            {\\n                res = res | (1<<i);\\n                node = node->get(1 - bit);\\n            }\\n            else if(node)\\n            {\\n                node=node->get(bit);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    Trie tr;\\n    void dfs(int node, vector<vector<int>> &graph, vector<vector<pair<int, int>>> &vec, vector<int> &res)\\n    {\\n        tr.insert(node);\\n        for(auto it : vec[node])\\n        {\\n            int val = it.second;\\n            res[it.first] = tr.getMaxXor(val);\\n        }\\n        for(auto it : graph[node])\\n        {\\n            dfs(it, graph, vec, res);\\n        }\\n        tr.remove(node);\\n    }\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size();\\n        vector<vector<int>> graph(n);\\n        int root = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(parents[i] == -1)\\n                root = i;\\n            else\\n            {\\n                graph[parents[i]].push_back(i);\\n            }\\n        }\\n        int m = queries.size();\\n        vector<vector<pair<int, int>>> vec(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            vec[queries[i][0]].push_back({i, queries[i][1]});\\n        }\\n        vector<int> res(m);\\n        dfs(root, graph, vec, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879669,
                "title": "python-recursive-before-order-calculation",
                "content": "# Intuition\\nLet\\'s rephrase problem little bit: if we have query `node,val` can answer have bit prefix `mask`? This gives us next ideas\\n1. valid `mask` is always some bit prefix of `p^val` for some parent `p` of `node` (including `node`) \\n2. To get the answer we can incrementally improve `mask` prefix. \\nLet\\'s say we have `cnt[l,mask]` - count of all `l`-prefixes of all parents of `node` (including `node`). `mask` is valid `l`-prefix for `val` ifff `cnt[l,mask^val[:l]>0` (here `val[:l]` denotes `l`-prefix of val). If `mask` is valid `l`-prefix then either `mask<0>` is valid `l+1`-prefix or `mask<1>` is. So if we can  append `1` then we should do it, so we maximize valid prefix. And in the end it will be our answer.\\n3. To maintain `cnt[l,mask]` and answer `queries` we use next recursive traversal procedure: increment `cnt` before children with all prefixes of `node`,  then answer all queries with `node`, then traverse children, then decrement `cnt` after children. \\nSo at each `node` we always have up-to-date `cnt` and can answer all queries with `node`.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: `O(max_bit * (n+q))`, where `n=len(parents)`, `q=len(queries)`, `max_bit=log2(max(n,val))==17` for given constraints.\\n\\n- Space complexity: `O(2**max_bit)+O(q)+O(n)`\\n\\n# Code\\n```\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        max_bit=17\\n        child=defaultdict(list)\\n        for i,p in enumerate(parents):\\n            child[p].append(i)\\n        cnt=defaultdict(int)\\n        q_by_c=defaultdict(list)\\n        for i,(c,_) in enumerate(queries):\\n            q_by_c[c].append(i)\\n        res=[-1]*len(queries)\\n        def traverse(p):\\n            if p>=0:\\n                for l in range(max_bit+1):\\n                    cnt[l,p>>l]+=1\\n            for i in q_by_c[p]:\\n                val=queries[i][1]\\n                mask=0\\n                for l in range(max_bit,-1,-1):\\n                    val_l = val>>l\\n                    mask0=mask<<1\\n                    mask1=mask0+1\\n                    mask=mask1 if cnt[l,val_l^mask1]>0 else mask0\\n                res[i]=mask\\n            for c in child[p]:\\n                traverse(c)\\n            if p>=0:\\n                for l in range(max_bit+1):\\n                    cnt[l,p>>l]-=1            \\n        traverse(-1)\\n        return res\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        max_bit=17\\n        child=defaultdict(list)\\n        for i,p in enumerate(parents):\\n            child[p].append(i)\\n        cnt=defaultdict(int)\\n        q_by_c=defaultdict(list)\\n        for i,(c,_) in enumerate(queries):\\n            q_by_c[c].append(i)\\n        res=[-1]*len(queries)\\n        def traverse(p):\\n            if p>=0:\\n                for l in range(max_bit+1):\\n                    cnt[l,p>>l]+=1\\n            for i in q_by_c[p]:\\n                val=queries[i][1]\\n                mask=0\\n                for l in range(max_bit,-1,-1):\\n                    val_l = val>>l\\n                    mask0=mask<<1\\n                    mask1=mask0+1\\n                    mask=mask1 if cnt[l,val_l^mask1]>0 else mask0\\n                res[i]=mask\\n            for c in child[p]:\\n                traverse(c)\\n            if p>=0:\\n                for l in range(max_bit+1):\\n                    cnt[l,p>>l]-=1            \\n        traverse(-1)\\n        return res\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758954,
                "title": "walk-tree-to-solve-query-with-bit-trie-add-del-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Trie {\\n    struct TrieNode {\\n        int cnt;\\n        TrieNode* t[2];\\n\\n        TrieNode() : cnt(0) {\\n            t[0] = t[1] = NULL;\\n        }\\n    };\\n\\n    // delete bits[bit...0] of num from subtree at parent\\n    TrieNode* delUtil(TrieNode* node, int num, int bit) {\\n        if (bit >= 0) {\\n            int b = (num >> bit) & 0x1;\\n            node->t[b] = delUtil(node->t[b], num, bit - 1);\\n        }\\n\\n        if (--node->cnt == 0) {\\n            delete node;\\n            node = NULL;\\n        }\\n\\n        return node;\\n    }\\n\\n    TrieNode* root;\\n    // nunmber of bits supported by this Trie\\n    int bits;\\npublic:\\n    Trie(int cnt) {\\n        root = new TrieNode();\\n        bits = cnt;\\n    }\\n\\n    void add(int num) {\\n        TrieNode* node = root;\\n        node->cnt++;\\n        for (int i = bits; i >= 0; i--) {\\n            int b = (num >> i) & 0x1;\\n            if (node->t[b] == NULL) {\\n                node->t[b] = new TrieNode();\\n            }\\n            node = node->t[b];\\n            node->cnt++;\\n        }\\n    }\\n\\n    void del(int num) {\\n        int b = (num >> bits) & 0x1;\\n        root->t[b] = delUtil(root->t[b], num, bits - 1);\\n    }\\n\\n    int maxXor(int num) {\\n        if (root->cnt == 0) {\\n            return 0;\\n        }\\n\\n        TrieNode* node = root;\\n        int ans = 0;\\n        for (int i = bits; i >= 0; i--) {\\n            int b = (num >> i) & 0x1;\\n            if (node->t[b ^ 1] != NULL) {\\n                ans |= 1 << i;\\n                node = node->t[b ^ 1];\\n            } else {\\n                node = node->t[b];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\n    void walkGeneticTree(int node, vector<vector<int>>& adj, unordered_map<int, vector<int>>& table,\\n                         vector<vector<int>>& queries, vector<int>& ans, Trie* trie) {\\n        trie->add(node);\\n\\n        for (int i : table[node]) {\\n            ans[i] = trie->maxXor(queries[i][1]);\\n        }\\n\\n        for (auto child : adj[node]) {\\n            walkGeneticTree(child, adj, table, queries, ans, trie);\\n        }\\n\\n        trie->del(node);\\n    }\\npublic:\\n    /*\\n    Observations:\\n    1. Walk the genetic tree, build bit trie with current path values.\\n       The trie supports remove value, so remove node before dfs exits.\\n    2. Find maxXor along the bit Trie Tree, O(1) time.\\n\\n    tree; trie; bit manipulation; hash table; dfs;\\n    O(n + m) space and time;\\n    */\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size(), m = queries.size();\\n        int root = -1;\\n        // parent to children\\n        vector<vector<int>> adj(n);\\n        for (int i = 0; i < n; i++) {\\n            if (parents[i] == -1) {\\n                root = i;\\n            } else {\\n                adj[parents[i]].push_back(i);\\n            }\\n        }\\n\\n        // node -> list of queries\\n        unordered_map<int, vector<int>> table;\\n        for (int i = 0; i < queries.size(); i++) {\\n            int node = queries[i][0];\\n            table[node].push_back(i);\\n        }\\n\\n        vector<int> ans(m);\\n        Trie* trie = new Trie(17);\\n        walkGeneticTree(root, adj, table, queries, ans, trie);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Trie {\\n    struct TrieNode {\\n        int cnt;\\n        TrieNode* t[2];\\n\\n        TrieNode() : cnt(0) {\\n            t[0] = t[1] = NULL;\\n        }\\n    };\\n\\n    // delete bits[bit...0] of num from subtree at parent\\n    TrieNode* delUtil(TrieNode* node, int num, int bit) {\\n        if (bit >= 0) {\\n            int b = (num >> bit) & 0x1;\\n            node->t[b] = delUtil(node->t[b], num, bit - 1);\\n        }\\n\\n        if (--node->cnt == 0) {\\n            delete node;\\n            node = NULL;\\n        }\\n\\n        return node;\\n    }\\n\\n    TrieNode* root;\\n    // nunmber of bits supported by this Trie\\n    int bits;\\npublic:\\n    Trie(int cnt) {\\n        root = new TrieNode();\\n        bits = cnt;\\n    }\\n\\n    void add(int num) {\\n        TrieNode* node = root;\\n        node->cnt++;\\n        for (int i = bits; i >= 0; i--) {\\n            int b = (num >> i) & 0x1;\\n            if (node->t[b] == NULL) {\\n                node->t[b] = new TrieNode();\\n            }\\n            node = node->t[b];\\n            node->cnt++;\\n        }\\n    }\\n\\n    void del(int num) {\\n        int b = (num >> bits) & 0x1;\\n        root->t[b] = delUtil(root->t[b], num, bits - 1);\\n    }\\n\\n    int maxXor(int num) {\\n        if (root->cnt == 0) {\\n            return 0;\\n        }\\n\\n        TrieNode* node = root;\\n        int ans = 0;\\n        for (int i = bits; i >= 0; i--) {\\n            int b = (num >> i) & 0x1;\\n            if (node->t[b ^ 1] != NULL) {\\n                ans |= 1 << i;\\n                node = node->t[b ^ 1];\\n            } else {\\n                node = node->t[b];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\n    void walkGeneticTree(int node, vector<vector<int>>& adj, unordered_map<int, vector<int>>& table,\\n                         vector<vector<int>>& queries, vector<int>& ans, Trie* trie) {\\n        trie->add(node);\\n\\n        for (int i : table[node]) {\\n            ans[i] = trie->maxXor(queries[i][1]);\\n        }\\n\\n        for (auto child : adj[node]) {\\n            walkGeneticTree(child, adj, table, queries, ans, trie);\\n        }\\n\\n        trie->del(node);\\n    }\\npublic:\\n    /*\\n    Observations:\\n    1. Walk the genetic tree, build bit trie with current path values.\\n       The trie supports remove value, so remove node before dfs exits.\\n    2. Find maxXor along the bit Trie Tree, O(1) time.\\n\\n    tree; trie; bit manipulation; hash table; dfs;\\n    O(n + m) space and time;\\n    */\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size(), m = queries.size();\\n        int root = -1;\\n        // parent to children\\n        vector<vector<int>> adj(n);\\n        for (int i = 0; i < n; i++) {\\n            if (parents[i] == -1) {\\n                root = i;\\n            } else {\\n                adj[parents[i]].push_back(i);\\n            }\\n        }\\n\\n        // node -> list of queries\\n        unordered_map<int, vector<int>> table;\\n        for (int i = 0; i < queries.size(); i++) {\\n            int node = queries[i][0];\\n            table[node].push_back(i);\\n        }\\n\\n        vector<int> ans(m);\\n        Trie* trie = new Trie(17);\\n        walkGeneticTree(root, adj, table, queries, ans, trie);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682999,
                "title": "c-trie-easy-to-understand",
                "content": "# Approach\\n1. Implement Trie that can handle add, remove, and find maximum xor of given value\\n2. DFS: For each node, answer all queries with given node (Remember to remove node from Trie after DFS).\\n\\nIf you find my solution helpful, please give me upvote. Thank you.\\n\\n# Code\\n```\\nstruct Node{\\n    Node* child[2];\\n    int count;\\n    Node(){\\n        count = 0;\\n        child[0] = nullptr;\\n        child[1] = nullptr;\\n    }\\n};\\n\\nvoid add(Node* root, int a){\\n    Node* current = root;\\n    for(int i=31; i>=0; i--){\\n        if(a&(1<<i)){\\n            if(current->child[1] == nullptr){\\n                current->child[1] = new Node();\\n            }\\n            current = current->child[1];\\n        }\\n        else{\\n            if(current->child[0] == nullptr){\\n                current->child[0] = new Node();\\n            }\\n            current = current->child[0];\\n        }\\n    }\\n    current->count ++;\\n}\\n\\nbool isEmpty(Node* temp){\\n    if(temp->child[0] != nullptr){\\n        return false;\\n    }\\n    if(temp->child[1] != nullptr){\\n        return false;\\n    }\\n    return true;\\n}\\n\\nbool remove(Node* root, int a, int b = 31){\\n    if(!root){\\n        return true;\\n    }\\n    if(b == -1){\\n        if(root->count > 0){\\n            root->count--;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    int c = 0;\\n    if(a&(1<<b)){\\n        c = 1;\\n    }\\n\\n    if(!root->child[c]){\\n        return false;\\n    }\\n\\n    bool isRemove = remove(root->child[c], a, b-1);\\n    Node* temp =  root->child[c];\\n\\n    if(isRemove && temp->count == 0 && isEmpty(temp)){\\n        delete root->child[c];\\n        root->child[c] = nullptr;\\n    }\\n    return isRemove;\\n}\\n\\nint find(Node* root, int a){\\n    int res = 0;\\n    Node* current = root;\\n    for(int i=31; i>=0; i--){\\n        int b = 0;\\n        if(a&(1<<i)){\\n            b = 1;\\n        }\\n        if(b == 1){\\n            if(current->child[0]){\\n                current = current->child[0];\\n            }\\n            else{\\n                current = current->child[1];\\n                res += (1<<i);\\n            }\\n        }\\n        else{\\n            if(current->child[1]){\\n                current = current->child[1];\\n                res += (1<<i);\\n            }\\n            else{\\n                current = current->child[0];\\n            }\\n        }\\n    }\\n    return res ^ a;\\n}\\n\\nvoid dfs(int current, int prev, Node* root, vector<vector<int>> &childs, vector<vector<vector<int>>> &ques, vector<int> &res){\\n    add(root, current);\\n    for(auto q: ques[current]){\\n        res[q[1]] = find(root, q[0]);\\n    }\\n    for(auto u: childs[current]){\\n        if(u != prev){\\n            dfs(u, current, root, childs, ques, res);\\n        }\\n    }\\n    remove(root, current);\\n}\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        Node* root = new Node();\\n        vector<vector<int>> childs(parents.size());\\n        int r = 0;\\n        for(int i=0; i<parents.size(); i++){\\n            if(parents[i] == -1){\\n                r = i;\\n                continue;\\n            }\\n            childs[parents[i]].push_back(i);\\n        }\\n        vector<vector<vector<int>>> ques(parents.size());\\n        for(int i=0; i<queries.size(); i++){\\n            ques[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        vector<int> res(queries.size());\\n        dfs(r, r, root, childs, ques, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* child[2];\\n    int count;\\n    Node(){\\n        count = 0;\\n        child[0] = nullptr;\\n        child[1] = nullptr;\\n    }\\n};\\n\\nvoid add(Node* root, int a){\\n    Node* current = root;\\n    for(int i=31; i>=0; i--){\\n        if(a&(1<<i)){\\n            if(current->child[1] == nullptr){\\n                current->child[1] = new Node();\\n            }\\n            current = current->child[1];\\n        }\\n        else{\\n            if(current->child[0] == nullptr){\\n                current->child[0] = new Node();\\n            }\\n            current = current->child[0];\\n        }\\n    }\\n    current->count ++;\\n}\\n\\nbool isEmpty(Node* temp){\\n    if(temp->child[0] != nullptr){\\n        return false;\\n    }\\n    if(temp->child[1] != nullptr){\\n        return false;\\n    }\\n    return true;\\n}\\n\\nbool remove(Node* root, int a, int b = 31){\\n    if(!root){\\n        return true;\\n    }\\n    if(b == -1){\\n        if(root->count > 0){\\n            root->count--;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    int c = 0;\\n    if(a&(1<<b)){\\n        c = 1;\\n    }\\n\\n    if(!root->child[c]){\\n        return false;\\n    }\\n\\n    bool isRemove = remove(root->child[c], a, b-1);\\n    Node* temp =  root->child[c];\\n\\n    if(isRemove && temp->count == 0 && isEmpty(temp)){\\n        delete root->child[c];\\n        root->child[c] = nullptr;\\n    }\\n    return isRemove;\\n}\\n\\nint find(Node* root, int a){\\n    int res = 0;\\n    Node* current = root;\\n    for(int i=31; i>=0; i--){\\n        int b = 0;\\n        if(a&(1<<i)){\\n            b = 1;\\n        }\\n        if(b == 1){\\n            if(current->child[0]){\\n                current = current->child[0];\\n            }\\n            else{\\n                current = current->child[1];\\n                res += (1<<i);\\n            }\\n        }\\n        else{\\n            if(current->child[1]){\\n                current = current->child[1];\\n                res += (1<<i);\\n            }\\n            else{\\n                current = current->child[0];\\n            }\\n        }\\n    }\\n    return res ^ a;\\n}\\n\\nvoid dfs(int current, int prev, Node* root, vector<vector<int>> &childs, vector<vector<vector<int>>> &ques, vector<int> &res){\\n    add(root, current);\\n    for(auto q: ques[current]){\\n        res[q[1]] = find(root, q[0]);\\n    }\\n    for(auto u: childs[current]){\\n        if(u != prev){\\n            dfs(u, current, root, childs, ques, res);\\n        }\\n    }\\n    remove(root, current);\\n}\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        Node* root = new Node();\\n        vector<vector<int>> childs(parents.size());\\n        int r = 0;\\n        for(int i=0; i<parents.size(); i++){\\n            if(parents[i] == -1){\\n                r = i;\\n                continue;\\n            }\\n            childs[parents[i]].push_back(i);\\n        }\\n        vector<vector<vector<int>>> ques(parents.size());\\n        for(int i=0; i<queries.size(); i++){\\n            ques[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        vector<int> res(queries.size());\\n        dfs(r, r, root, childs, ques, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679552,
                "title": "trie-based-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTrie\\n\\n# Complexity\\n- Time complexity:\\n- O(n(logd)) where d is 32 the number of bits in a 32-bit integer\\n\\n- Space complexity:\\n- O(n(logd)) where i is the number of bits in a 32-bit integer\\n\\n# Code\\n```\\nstruct Tree{\\n    Tree* left;\\n    Tree* right;\\n    int count;\\n    Tree(){\\n        left=NULL;\\n        right=NULL;\\n        count=0;\\n    }\\n};\\n\\nvoid insert(Tree *root, int val){\\n    if(!root){\\n        root=new Tree();\\n    }\\n    for (int i = 31; i >= 0; i--){\\n        if ((val>>i) & 1){\\n            if(!root->right){\\n                root->right=new Tree();\\n            }\\n            root=root->right;\\n            root->count++;\\n        }\\n        else{\\n            if(!root->left){\\n                root->left=new Tree();\\n            }\\n            root=root->left;\\n            root->count++;\\n        }\\n    }\\n}\\n\\nint get_max(Tree *root, int val){\\n    int ans=0;\\n    for(int i=31;i>=0;i--){\\n        if((val>>i)&1){\\n            if(root->left){\\n                root=root->left;\\n                ans+=(1<<i);\\n            }\\n            else{\\n                root=root->right;\\n            }\\n        }else{\\n            if(root->right){\\n                root=root->right;\\n                ans+=(1<<i);\\n            }\\n            else{\\n                root=root->left;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n\\nvoid delete_node(Tree *root, int val){\\n    for(int i=31;i>=0;i--){\\n        if((val>>i)&1){\\n            Tree* node=root->right;\\n            node->count--;\\n            if(node->count==0){\\n                root->right=NULL;\\n                break;\\n            }\\n            else{\\n                root=node;\\n            }\\n        }\\n        else{\\n            Tree* node=root->left;\\n            node->count--;\\n            if(node->count==0){\\n                root->left=NULL;\\n                break;\\n            }\\n            else{\\n                root=node;\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size();\\n        vector<vector<int>> graph(n);\\n        int root_node=INT_MIN;\\n        for(int i=0;i<parents.size();i++){\\n            if(parents[i]==-1){\\n                root_node=i;\\n            }\\n            else{\\n                graph[parents[i]].push_back(i);\\n            }\\n        }\\n        vector<vector<pair<int, int>>> node_queries(n);\\n        for(int i=0;i<queries.size();i++){\\n            node_queries[queries[i][0]].emplace_back(i, queries[i][1]);\\n        }\\n        Tree *root = new Tree();\\n        vector<int> solution(queries.size());\\n        function<void(int)> dfs=[&](int u){\\n            insert(root, u);\\n            for(auto query : node_queries[u]){\\n                solution[query.first] = get_max(root, query.second);\\n            }\\n            for(int v : graph[u]){\\n                dfs(v);\\n            }\\n            delete_node(root, u);\\n        };\\n        dfs(root_node);\\n        return solution;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nstruct Tree{\\n    Tree* left;\\n    Tree* right;\\n    int count;\\n    Tree(){\\n        left=NULL;\\n        right=NULL;\\n        count=0;\\n    }\\n};\\n\\nvoid insert(Tree *root, int val){\\n    if(!root){\\n        root=new Tree();\\n    }\\n    for (int i = 31; i >= 0; i--){\\n        if ((val>>i) & 1){\\n            if(!root->right){\\n                root->right=new Tree();\\n            }\\n            root=root->right;\\n            root->count++;\\n        }\\n        else{\\n            if(!root->left){\\n                root->left=new Tree();\\n            }\\n            root=root->left;\\n            root->count++;\\n        }\\n    }\\n}\\n\\nint get_max(Tree *root, int val){\\n    int ans=0;\\n    for(int i=31;i>=0;i--){\\n        if((val>>i)&1){\\n            if(root->left){\\n                root=root->left;\\n                ans+=(1<<i);\\n            }\\n            else{\\n                root=root->right;\\n            }\\n        }else{\\n            if(root->right){\\n                root=root->right;\\n                ans+=(1<<i);\\n            }\\n            else{\\n                root=root->left;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n\\nvoid delete_node(Tree *root, int val){\\n    for(int i=31;i>=0;i--){\\n        if((val>>i)&1){\\n            Tree* node=root->right;\\n            node->count--;\\n            if(node->count==0){\\n                root->right=NULL;\\n                break;\\n            }\\n            else{\\n                root=node;\\n            }\\n        }\\n        else{\\n            Tree* node=root->left;\\n            node->count--;\\n            if(node->count==0){\\n                root->left=NULL;\\n                break;\\n            }\\n            else{\\n                root=node;\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size();\\n        vector<vector<int>> graph(n);\\n        int root_node=INT_MIN;\\n        for(int i=0;i<parents.size();i++){\\n            if(parents[i]==-1){\\n                root_node=i;\\n            }\\n            else{\\n                graph[parents[i]].push_back(i);\\n            }\\n        }\\n        vector<vector<pair<int, int>>> node_queries(n);\\n        for(int i=0;i<queries.size();i++){\\n            node_queries[queries[i][0]].emplace_back(i, queries[i][1]);\\n        }\\n        Tree *root = new Tree();\\n        vector<int> solution(queries.size());\\n        function<void(int)> dfs=[&](int u){\\n            insert(root, u);\\n            for(auto query : node_queries[u]){\\n                solution[query.first] = get_max(root, query.second);\\n            }\\n            for(int v : graph[u]){\\n                dfs(v);\\n            }\\n            delete_node(root, u);\\n        };\\n        dfs(root_node);\\n        return solution;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373117,
                "title": "o-32-nlogn-mlogn-python-tle-can-take-realtime-queries",
                "content": "# Intuition\\nFuck this tle based on constraints this should be fine\\n\\n# Code\\n```\\nclass Node:\\n    def __init__(self):\\n        self.containedRanges = {0: [], 1: []}\\n        self.children = defaultdict(Node)\\n\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        graph = defaultdict(list)\\n        root = None\\n        bitTreeRoot = Node()\\n        highestNode = len(parents) - 1\\n        maxBits = int(math.log(highestNode, 2)) + 1\\n        for i,parent in enumerate(parents):\\n            if parent == -1:\\n                root = i\\n            else:\\n                graph[parent].append(i)\\n\\n        nodeId = {}\\n        nodeRange = {} # node: [l,r] inclusive\\n        @cache\\n        def subtreeSize(curr):\\n            return 1 + sum(subtreeSize(nxt) for nxt in graph[curr])\\n        def numberAndRange(curr, l):\\n            nodeId[curr] = l\\n            nxtL = l + 1\\n            for nxt in graph[curr]:\\n                nxtSize = subtreeSize(nxt)\\n                numberAndRange(nxt, nxtL)\\n                nxtL += nxtSize\\n            nodeRange[curr] = [l,nxtL-1]\\n        numberAndRange(root, 0)\\n\\n        def findRange(x, ranges):\\n            # finds if x is in any range\\n            # find right-most (highest) range where range[0] <= x\\n            l, r = 0, len(ranges)-1\\n            found = None\\n            while l <= r:\\n                m = l+(r-l)//2\\n                if ranges[m][0] <= x:\\n                    found = m\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n            if found is not None and ranges[found][1] >= x:\\n                return found\\n            return None\\n\\n        def dfs(curr):\\n            bitTreeNode = bitTreeRoot\\n            currBit = maxBits - 1\\n            while currBit >= 0:\\n                bit = int(bool(curr & 1<<currBit))\\n                rangeIdx = findRange(nodeId[curr], bitTreeNode.containedRanges[bit])\\n                if rangeIdx is None:\\n                    bitTreeNode.containedRanges[bit].append(nodeRange[curr])\\n                currBit -= 1\\n                bitTreeNode = bitTreeNode.children[bit]\\n            for nxt in graph[curr]:\\n                dfs(nxt)\\n        dfs(root)\\n\\n        seen = {}\\n\\n        ret = []\\n        for node,val in queries:\\n            bitTreeNode = bitTreeRoot\\n            currBit = maxBits - 1\\n            bestValue = max(0, val - (val & ((1<<maxBits)-1)))\\n            while currBit >= 0:\\n                bit = int(bool(val & 1<<currBit))\\n                rangeIdx = findRange(nodeId[node], bitTreeNode.containedRanges[1-bit])\\n                good = rangeIdx is not None\\n                pick = 1-bit if good else bit\\n                bestValue += (1<<currBit) if good else 0\\n                currBit -= 1\\n                bitTreeNode = bitTreeNode.children[pick]\\n            ret.append(bestValue)\\n\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.containedRanges = {0: [], 1: []}\\n        self.children = defaultdict(Node)\\n\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        graph = defaultdict(list)\\n        root = None\\n        bitTreeRoot = Node()\\n        highestNode = len(parents) - 1\\n        maxBits = int(math.log(highestNode, 2)) + 1\\n        for i,parent in enumerate(parents):\\n            if parent == -1:\\n                root = i\\n            else:\\n                graph[parent].append(i)\\n\\n        nodeId = {}\\n        nodeRange = {} # node: [l,r] inclusive\\n        @cache\\n        def subtreeSize(curr):\\n            return 1 + sum(subtreeSize(nxt) for nxt in graph[curr])\\n        def numberAndRange(curr, l):\\n            nodeId[curr] = l\\n            nxtL = l + 1\\n            for nxt in graph[curr]:\\n                nxtSize = subtreeSize(nxt)\\n                numberAndRange(nxt, nxtL)\\n                nxtL += nxtSize\\n            nodeRange[curr] = [l,nxtL-1]\\n        numberAndRange(root, 0)\\n\\n        def findRange(x, ranges):\\n            # finds if x is in any range\\n            # find right-most (highest) range where range[0] <= x\\n            l, r = 0, len(ranges)-1\\n            found = None\\n            while l <= r:\\n                m = l+(r-l)//2\\n                if ranges[m][0] <= x:\\n                    found = m\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n            if found is not None and ranges[found][1] >= x:\\n                return found\\n            return None\\n\\n        def dfs(curr):\\n            bitTreeNode = bitTreeRoot\\n            currBit = maxBits - 1\\n            while currBit >= 0:\\n                bit = int(bool(curr & 1<<currBit))\\n                rangeIdx = findRange(nodeId[curr], bitTreeNode.containedRanges[bit])\\n                if rangeIdx is None:\\n                    bitTreeNode.containedRanges[bit].append(nodeRange[curr])\\n                currBit -= 1\\n                bitTreeNode = bitTreeNode.children[bit]\\n            for nxt in graph[curr]:\\n                dfs(nxt)\\n        dfs(root)\\n\\n        seen = {}\\n\\n        ret = []\\n        for node,val in queries:\\n            bitTreeNode = bitTreeRoot\\n            currBit = maxBits - 1\\n            bestValue = max(0, val - (val & ((1<<maxBits)-1)))\\n            while currBit >= 0:\\n                bit = int(bool(val & 1<<currBit))\\n                rangeIdx = findRange(nodeId[node], bitTreeNode.containedRanges[1-bit])\\n                good = rangeIdx is not None\\n                pick = 1-bit if good else bit\\n                bestValue += (1<<currBit) if good else 0\\n                currBit -= 1\\n                bitTreeNode = bitTreeNode.children[pick]\\n            ret.append(bestValue)\\n\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988586,
                "title": "easy-trie-implementation-c",
                "content": "\\n\\n# Code\\n```\\nclass Node\\n{\\n    public:\\n        Node* child[2] = {};\\n        int val = 0;\\n};\\n\\nclass Trie\\n{\\n    private:\\n        Node* root;\\n    public:\\n        Trie()\\n        {\\n            root = new Node();\\n        }\\n        \\n        void insert(int num, int d)\\n        {\\n            Node* cur = root;\\n            for (int i = 17; i >= 0; --i) {\\n                int bit = (num>>i) & (1);\\n                if (cur->child[bit] == NULL) cur->child[bit] = new Node();\\n                cur = cur->child[bit];\\n                cur->val += d;\\n            }\\n        }\\n\\n        int findMax(int num){\\n            Node* cur = root;\\n            int ans = 0;\\n            for (int i = 17; i >= 0; --i) {\\n                int bit = (num>>i) & (1);\\n                if (cur->child[1 - bit] != NULL && cur->child[1 - bit]->val > 0) {\\n                    cur = cur->child[1 - bit];\\n                    ans |= (1 << i);\\n                } \\n                else cur = cur->child[bit];\\n            }\\n            return ans;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    Trie trie;\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& qs) {\\n        int n = parents.size(), m = qs.size(), root = -1;\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(parents[i]==-1) root = i;\\n            else adj[parents[i]].push_back(i);\\n        }\\n        vector<vector<pair<int,int>>> queryByNode(n);\\n        for(int i=0;i<m;i++){\\n            queryByNode[qs[i][0]].push_back({qs[i][1],i});\\n        }\\n        vector<int> ans(m);\\n        dfs(root, adj, queryByNode, ans);\\n        return ans;\\n    }\\n\\n    void dfs(int u, vector<int> adj[], vector<vector<pair<int,int>>> &queryByNode,vector<int> &ans)\\n    {\\n        trie.insert(u,1);\\n        for(auto &p:queryByNode[u]){\\n            ans[p.second] = trie.findMax(p.first);\\n        }\\n        for(int &v:adj[u]){\\n            dfs(v,adj,queryByNode,ans);\\n        }\\n        trie.insert(u,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node\\n{\\n    public:\\n        Node* child[2] = {};\\n        int val = 0;\\n};\\n\\nclass Trie\\n{\\n    private:\\n        Node* root;\\n    public:\\n        Trie()\\n        {\\n            root = new Node();\\n        }\\n        \\n        void insert(int num, int d)\\n        {\\n            Node* cur = root;\\n            for (int i = 17; i >= 0; --i) {\\n                int bit = (num>>i) & (1);\\n                if (cur->child[bit] == NULL) cur->child[bit] = new Node();\\n                cur = cur->child[bit];\\n                cur->val += d;\\n            }\\n        }\\n\\n        int findMax(int num){\\n            Node* cur = root;\\n            int ans = 0;\\n            for (int i = 17; i >= 0; --i) {\\n                int bit = (num>>i) & (1);\\n                if (cur->child[1 - bit] != NULL && cur->child[1 - bit]->val > 0) {\\n                    cur = cur->child[1 - bit];\\n                    ans |= (1 << i);\\n                } \\n                else cur = cur->child[bit];\\n            }\\n            return ans;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    Trie trie;\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& qs) {\\n        int n = parents.size(), m = qs.size(), root = -1;\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(parents[i]==-1) root = i;\\n            else adj[parents[i]].push_back(i);\\n        }\\n        vector<vector<pair<int,int>>> queryByNode(n);\\n        for(int i=0;i<m;i++){\\n            queryByNode[qs[i][0]].push_back({qs[i][1],i});\\n        }\\n        vector<int> ans(m);\\n        dfs(root, adj, queryByNode, ans);\\n        return ans;\\n    }\\n\\n    void dfs(int u, vector<int> adj[], vector<vector<pair<int,int>>> &queryByNode,vector<int> &ans)\\n    {\\n        trie.insert(u,1);\\n        for(auto &p:queryByNode[u]){\\n            ans[p.second] = trie.findMax(p.first);\\n        }\\n        for(int &v:adj[u]){\\n            dfs(v,adj,queryByNode,ans);\\n        }\\n        trie.insert(u,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653923,
                "title": "c-trie-solution",
                "content": "```\\n\\nclass Node{\\n    public:\\n        Node* children[2];\\n        int cnt;\\n        Node(){\\n            children[0] = NULL;\\n            children[1] = NULL;\\n            cnt = 0;\\n        }\\n};\\n\\nclass Trie{\\n    public:\\n        Node *root;\\n        Trie(){\\n            root = new Node();\\n        }\\n        void insert(int number){\\n            Node* node = root;\\n            for (int i=31;i>=0;i--){\\n                int direction = ((1<<i)&number);\\n                if (direction) direction=1;\\n                if (!node->children[direction]){\\n                    node->children[direction] = new Node();\\n                }\\n                node = node->children[direction];\\n                node->cnt++;\\n            }\\n        }\\n        void remove(int number){\\n            Node* node = root;\\n            for (int i=31;i>=0;i--){\\n                int direction = ((1<<i)&number);\\n                if (direction) direction=1;\\n                if (!node->children[direction]){\\n                    node->children[direction] = new Node();\\n                }\\n                node = node->children[direction];\\n                node->cnt--;\\n            }\\n        }\\n    \\n    int query(int number){\\n        int res = 0;\\n        Node* node = root;\\n        for (int i=31;i>=0;i--){\\n            int direction = ((1<<i)&number);\\n            if (direction) direction=1;\\n            direction = 1-direction;\\n            if ((node->children[direction]) && ((node->children[direction])->cnt>0)){\\n                node = node->children[direction];\\n                res |= (1<<i);\\n            }\\n            else{\\n                node = node->children[1-direction];\\n            }\\n        }\\n        return res;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<vector<int>> adj;\\n    unordered_map<int,vector<pair<int,int>>> q;\\n    \\n    void dfs(int node, int par, Trie trie){\\n        trie.insert(node);\\n        for (auto v:q[node]){\\n            int ans = trie.query(v.first);\\n            res[v.second] = ans;\\n            }\\n        \\n        for (auto c:adj[node]){\\n            dfs(c,node,trie);\\n            }\\n        trie.remove(node);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        Trie trie;\\n        for (int i=0;i<queries.size();i++){\\n            int node = queries[i][0] , val = queries[i][1];\\n            q[node].push_back({val,i});\\n        }\\n        int root = -1, n = parents.size();\\n        adj.resize(n);\\n        res.resize(queries.size());\\n        for (int i=0;i<n;i++){\\n            int node = i, par=parents[i];\\n            if (par==-1) root = i;\\n            else adj[par].push_back(i);\\n        }\\n        dfs(root,-1,trie);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Node{\\n    public:\\n        Node* children[2];\\n        int cnt;\\n        Node(){\\n            children[0] = NULL;\\n            children[1] = NULL;\\n            cnt = 0;\\n        }\\n};\\n\\nclass Trie{\\n    public:\\n        Node *root;\\n        Trie(){\\n            root = new Node();\\n        }\\n        void insert(int number){\\n            Node* node = root;\\n            for (int i=31;i>=0;i--){\\n                int direction = ((1<<i)&number);\\n                if (direction) direction=1;\\n                if (!node->children[direction]){\\n                    node->children[direction] = new Node();\\n                }\\n                node = node->children[direction];\\n                node->cnt++;\\n            }\\n        }\\n        void remove(int number){\\n            Node* node = root;\\n            for (int i=31;i>=0;i--){\\n                int direction = ((1<<i)&number);\\n                if (direction) direction=1;\\n                if (!node->children[direction]){\\n                    node->children[direction] = new Node();\\n                }\\n                node = node->children[direction];\\n                node->cnt--;\\n            }\\n        }\\n    \\n    int query(int number){\\n        int res = 0;\\n        Node* node = root;\\n        for (int i=31;i>=0;i--){\\n            int direction = ((1<<i)&number);\\n            if (direction) direction=1;\\n            direction = 1-direction;\\n            if ((node->children[direction]) && ((node->children[direction])->cnt>0)){\\n                node = node->children[direction];\\n                res |= (1<<i);\\n            }\\n            else{\\n                node = node->children[1-direction];\\n            }\\n        }\\n        return res;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<vector<int>> adj;\\n    unordered_map<int,vector<pair<int,int>>> q;\\n    \\n    void dfs(int node, int par, Trie trie){\\n        trie.insert(node);\\n        for (auto v:q[node]){\\n            int ans = trie.query(v.first);\\n            res[v.second] = ans;\\n            }\\n        \\n        for (auto c:adj[node]){\\n            dfs(c,node,trie);\\n            }\\n        trie.remove(node);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        Trie trie;\\n        for (int i=0;i<queries.size();i++){\\n            int node = queries[i][0] , val = queries[i][1];\\n            q[node].push_back({val,i});\\n        }\\n        int root = -1, n = parents.size();\\n        adj.resize(n);\\n        res.resize(queries.size());\\n        for (int i=0;i<n;i++){\\n            int node = i, par=parents[i];\\n            if (par==-1) root = i;\\n            else adj[par].push_back(i);\\n        }\\n        dfs(root,-1,trie);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394041,
                "title": "c-trie",
                "content": "class Node{\\n    public:\\n    Node *left,*right;\\n    int count;\\n    Node(){\\n        count=0;\\n        left=NULL;\\n        right=NULL;\\n    }\\n};\\nclass Solution {\\npublic:\\n    void insert(Node* root,int val){\\n        for(int i=20;i>=0;i--){\\n            if(val&(1<<i)){\\n                if(root->right) {\\n                    root->right->count++;\\n                    root=root->right;\\n                }\\n                else{\\n                    Node* n=new Node();\\n                    root->right=n;\\n                    n->count++;\\n                    root=n;\\n                }\\n            }else{\\n                 if(root->left){\\n                     root->left->count++;\\n                     root=root->left;\\n                 }\\n                else{\\n                    Node* n=new Node();\\n                    root->left=n;\\n                    n->count++;\\n                    root=n;\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    int find(Node* root,int val){\\n        int ans=0;\\n        for(int i=20;i>=0;i--){\\n            if(val&(1<<i)){\\n                if(root->left and root->left->count>0){\\n                    ans=ans|(1<<i);\\n                    root=root->left;\\n                }else{\\n                    root=root->right;\\n                }\\n            }else{\\n                if(root->right and root->right->count>0){\\n                    ans=ans|(1<<i);\\n                    root=root->right;\\n                }else root=root->left;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void delet(Node* root,int val){\\n       for(int i=20;i>=0;i--){\\n           if(val&(1<<i)){\\n               root->right->count--;\\n               root=root->right;\\n           }else{\\n               root->left->count--;\\n               root=root->left;\\n           }\\n       }\\n    }\\n    \\n    vector<vector<pair<int,int>>> q;\\n    void dfs(vector<int> adj[],int sv,int p,Node* root,vector<int> &ans){\\n        insert(root,sv);\\n       \\n       for(auto p:q[sv]){\\n           int x=find(root,p.first);\\n           ans[p.second]=x;\\n       }\\n        for(auto c:adj[sv]){\\n            if(c!=p) dfs(adj,c,sv,root,ans);\\n        }\\n        delet(root,sv);\\n        \\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n=parents.size();\\n        vector<int> adj[n];\\n         q.resize(100001);\\n        int sv;\\n        for(int i=0;i<n;i++){\\n            if(parents[i]!=-1){\\n                adj[parents[i]].push_back(i);\\n            }else sv=i;\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            q[queries[i][0]].push_back({queries[i][1],i});\\n        }\\n        vector<int> ans(queries.size());\\n        Node* root=new Node();\\n        dfs(adj,sv,sv,root,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    void insert(Node* root,int val){\\n        for(int i=20;i>=0;i--){\\n            if(val&(1<<i)){\\n                if(root->right) {\\n                    root->right->count++;\\n                    root=root->right;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2370911,
                "title": "dfs-trie-esay-code",
                "content": "\\n    vector<int> ans1;\\n    vector<vector<pair<int,int>>> qr;\\n    vector<vector<int>> g;\\n    void dfs(int nd,vector<int> &v){\\n        int n=nd;\\n        int p=1;\\n        int c=19;\\n        while(c>=0){\\n            if(n&(1<<c)){\\n                p*=2;\\n                v[p]++;\\n            }\\n            else {\\n                p*=2;\\n                p++;\\n                v[p]++;\\n            }\\n           c--;\\n        }\\n        for(int j:g[nd])dfs(j,v);\\n        for(auto m:qr[nd]){\\n            \\n                int val=m.first;\\n                int id=m.second;\\n                int ans=val;\\n                c=19;\\n                n=val;\\n                p=1;\\n                    while(c>=0){\\n            if((n&(1<<c))&&v[2*p+1]){\\n                \\n                p*=2;\\n                p++;\\n                     \\n            \\n            }\\n            else if(((n&(1<<c))==0)&&v[2*p]){\\n                p*=2;\\n              ans^=1<<c;\\n            }\\n            else if(n&(1<<c)){\\n                if(v[2*p]){ ans^=(1<<c);}\\n                p*=2;\\n            }\\n            else {\\n                p*=2;\\n                p++;\\n            }\\n           c--;\\n        }\\n                ans1[id]=ans;\\n                \\n            \\n            \\n        }\\n                n=nd;\\n         p=1;\\n               c=19;\\n      while(c>=0){\\n            if(n&(1<<c)){\\n                p*=2;\\n                v[p]--;\\n            }\\n            else {\\n                p*=2;\\n                p++;\\n                v[p]--;\\n            }\\n           c--;\\n        }\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& p, vector<vector<int>>& q) {\\n        ans1.resize(q.size());\\n        qr.resize(p.size());\\n           g.resize(p.size());\\n        int c=0;\\n        for(auto j:q){ qr[j[0]].push_back({j[1],c}); c++;}\\n        int pr=0;\\n        for(int i=0;i<p.size();i++){ if(p[i]==-1)pr=i; else {\\n            g[p[i]].push_back(i);\\n        } }\\n        vector<int> v(3*1e6+1,0);\\n        dfs(pr,v);\\n            \\n        return ans1;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    vector<int> ans1;\\n    vector<vector<pair<int,int>>> qr;\\n    vector<vector<int>> g;\\n    void dfs(int nd,vector<int> &v){\\n        int n=nd;\\n        int p=1;\\n        int c=19;\\n        while(c>=0){\\n            if(n&(1<<c)){\\n                p*=2;\\n                v[p]++;\\n            }\\n            else {\\n                p*=2;\\n                p++;\\n                v[p]++;\\n            }\\n           c--;\\n        }\\n        for(int j:g[nd])dfs(j,v);\\n        for(auto m:qr[nd]){\\n            \\n                int val=m.first;\\n                int id=m.second;\\n                int ans=val;\\n                c=19;\\n                n=val;\\n                p=1;\\n                    while(c>=0){\\n            if((n&(1<<c))&&v[2*p+1]){\\n                \\n                p*=2;\\n                p++;\\n                     \\n            \\n            }\\n            else if(((n&(1<<c))==0)&&v[2*p]){\\n                p*=2;\\n              ans^=1<<c;\\n            }\\n            else if(n&(1<<c)){\\n                if(v[2*p]){ ans^=(1<<c);}\\n                p*=2;\\n            }\\n            else {\\n                p*=2;\\n                p++;\\n            }\\n           c--;\\n        }\\n                ans1[id]=ans;\\n                \\n            \\n            \\n        }\\n                n=nd;\\n         p=1;\\n               c=19;\\n      while(c>=0){\\n            if(n&(1<<c)){\\n                p*=2;\\n                v[p]--;\\n            }\\n            else {\\n                p*=2;\\n                p++;\\n                v[p]--;\\n            }\\n           c--;\\n        }\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& p, vector<vector<int>>& q) {\\n        ans1.resize(q.size());\\n        qr.resize(p.size());\\n           g.resize(p.size());\\n        int c=0;\\n        for(auto j:q){ qr[j[0]].push_back({j[1],c}); c++;}\\n        int pr=0;\\n        for(int i=0;i<p.size();i++){ if(p[i]==-1)pr=i; else {\\n            g[p[i]].push_back(i);\\n        } }\\n        vector<int> v(3*1e6+1,0);\\n        dfs(pr,v);\\n            \\n        return ans1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2349602,
                "title": "java-o-m-n-trie-dfs",
                "content": "```\\nclass Solution {\\n    \\n    int[] ret;\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        \\n        this.ret = new int[queries.length]; // result array\\n        \\n       \\n        /*map node and index in the queries array*/\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < queries.length; i++) {\\n            \\n            int node = queries[i][0];\\n            map.putIfAbsent(node, new ArrayList<>());\\n            map.get(node).add(i);\\n        }\\n        \\n        /*create a tree graph using hash map */\\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        int root = -1;\\n        for (int i = 0; i < parents.length; i++) {\\n            int parent = parents[i];\\n            int child = i;\\n            \\n            if (parent != -1) {\\n                tree.putIfAbsent(parent, new ArrayList<>());\\n                tree.get(parent).add(child);\\n            }else {\\n                root =i;\\n            }\\n        }\\n        \\n        TrieNode node = new TrieNode(-1);\\n        dfs(parents, root, tree, map, node, queries); // traverse the tree level by level and create a trie using visited node.If the node is seen is queries, calculate the max and put it in ret array.  \\n        return ret;\\n    }\\n    \\n    \\n    public void dfs(int[] parents, int root, Map<Integer, List<Integer>> tree, Map<Integer, List<Integer>> map, TrieNode node, int[][] queries){\\n        \\n        insert(root, node); //insert the current node to trie and increase the trie label by 1\\n        \\n        List<Integer> list = map.get(root); // if the queries nodes are currently visited, update the max value. \\n        if (list != null && list.size() > 0){\\n            for (Integer idx: list) {\\n                int[] q = queries[idx];\\n                int val = q[1];\\n                ret[idx] = getMax(val, node);\\n            }\\n        }\\n        \\n        if (tree.containsKey(root)) { // dfs to next level\\n            for (Integer n: tree.get(root)) {\\n                dfs(parents, n, tree, map, node, queries);\\n            }\\n        }\\n        \\n        \\n        delete(root, node); //delete the node from trie by decreasing label by 1\\n    }\\n    \\n    public void delete (int num, TrieNode root) {\\n        \\n        TrieNode curr = root;\\n        \\n        for (int i = 31; i >= 0; i--) {\\n            int digit = ((num>>i)&1);\\n            Map<Integer, TrieNode> children = curr.children;\\n            children.get(digit).label--;\\n            curr = children.get(digit);\\n        }\\n        \\n        \\n    }\\n    \\n    public int getMax(int val, TrieNode root){\\n        \\n        int ans = 0;\\n        TrieNode curr = root;\\n        \\n        for (int i =31; i >= 0; i--) {\\n            int digit = 1- ((val>>i)&1);\\n            Map<Integer, TrieNode> children = curr.children;\\n            if (children.get(digit) == null || children.get(digit).label == 0) digit = 1-digit;\\n            \\n            \\n            \\n            ans |= (digit<<i);\\n            curr = children.get(digit);\\n        }\\n        \\n        return val^ans;\\n    }\\n    \\n    public void insert(int num, TrieNode node) {\\n        TrieNode curr = node;\\n        \\n        for (int i = 31; i >= 0; i--) {\\n            int digit = ((num >> i)&1);\\n            Map<Integer, TrieNode> children = curr.children;\\n            if (children.get(digit) == null) children.put(digit, new TrieNode(digit));\\n            curr = children.get(digit);\\n            curr.label++;\\n        }\\n    }\\n        \\n        \\n    \\n    class TrieNode {\\n        int val;\\n        Map<Integer,TrieNode> children;\\n        int label;\\n        \\n        public TrieNode(int val){\\n            this.val = val;\\n            this.children = new HashMap<>();\\n            this.label = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[] ret;\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        \\n        this.ret = new int[queries.length]; // result array\\n        \\n       \\n        /*map node and index in the queries array*/\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < queries.length; i++) {\\n            \\n            int node = queries[i][0];\\n            map.putIfAbsent(node, new ArrayList<>());\\n            map.get(node).add(i);\\n        }\\n        \\n        /*create a tree graph using hash map */\\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        int root = -1;\\n        for (int i = 0; i < parents.length; i++) {\\n            int parent = parents[i];\\n            int child = i;\\n            \\n            if (parent != -1) {\\n                tree.putIfAbsent(parent, new ArrayList<>());\\n                tree.get(parent).add(child);\\n            }else {\\n                root =i;\\n            }\\n        }\\n        \\n        TrieNode node = new TrieNode(-1);\\n        dfs(parents, root, tree, map, node, queries); // traverse the tree level by level and create a trie using visited node.If the node is seen is queries, calculate the max and put it in ret array.  \\n        return ret;\\n    }\\n    \\n    \\n    public void dfs(int[] parents, int root, Map<Integer, List<Integer>> tree, Map<Integer, List<Integer>> map, TrieNode node, int[][] queries){\\n        \\n        insert(root, node); //insert the current node to trie and increase the trie label by 1\\n        \\n        List<Integer> list = map.get(root); // if the queries nodes are currently visited, update the max value. \\n        if (list != null && list.size() > 0){\\n            for (Integer idx: list) {\\n                int[] q = queries[idx];\\n                int val = q[1];\\n                ret[idx] = getMax(val, node);\\n            }\\n        }\\n        \\n        if (tree.containsKey(root)) { // dfs to next level\\n            for (Integer n: tree.get(root)) {\\n                dfs(parents, n, tree, map, node, queries);\\n            }\\n        }\\n        \\n        \\n        delete(root, node); //delete the node from trie by decreasing label by 1\\n    }\\n    \\n    public void delete (int num, TrieNode root) {\\n        \\n        TrieNode curr = root;\\n        \\n        for (int i = 31; i >= 0; i--) {\\n            int digit = ((num>>i)&1);\\n            Map<Integer, TrieNode> children = curr.children;\\n            children.get(digit).label--;\\n            curr = children.get(digit);\\n        }\\n        \\n        \\n    }\\n    \\n    public int getMax(int val, TrieNode root){\\n        \\n        int ans = 0;\\n        TrieNode curr = root;\\n        \\n        for (int i =31; i >= 0; i--) {\\n            int digit = 1- ((val>>i)&1);\\n            Map<Integer, TrieNode> children = curr.children;\\n            if (children.get(digit) == null || children.get(digit).label == 0) digit = 1-digit;\\n            \\n            \\n            \\n            ans |= (digit<<i);\\n            curr = children.get(digit);\\n        }\\n        \\n        return val^ans;\\n    }\\n    \\n    public void insert(int num, TrieNode node) {\\n        TrieNode curr = node;\\n        \\n        for (int i = 31; i >= 0; i--) {\\n            int digit = ((num >> i)&1);\\n            Map<Integer, TrieNode> children = curr.children;\\n            if (children.get(digit) == null) children.put(digit, new TrieNode(digit));\\n            curr = children.get(digit);\\n            curr.label++;\\n        }\\n    }\\n        \\n        \\n    \\n    class TrieNode {\\n        int val;\\n        Map<Integer,TrieNode> children;\\n        int label;\\n        \\n        public TrieNode(int val){\\n            this.val = val;\\n            this.children = new HashMap<>();\\n            this.label = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319297,
                "title": "c-maintain-trie-while-dfs-of-tree-o-q-n-time-and-space",
                "content": "```\\n/* \\n    Time: O(q+n)\\n    Space: O(q+n)\\n    Tag: Trie, N-ary Tree\\n    Difficulty: H\\n*/\\nstruct Node {\\n    int count;\\n    vector<Node *> children;\\n    Node() {\\n        children.resize(2, NULL);\\n        count = 0;\\n    }\\n};\\n\\nclass Trie {\\n    Node *root;\\n\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n\\n    void insert(int num) {\\n        Node *cur = root;\\n        for (int i = 18; i >= 0; i--) {\\n            bool bit = (num & (1 << i));\\n            if (!cur->children[bit]) cur->children[bit] = new Node();\\n            cur = cur->children[bit];\\n            cur->count++;\\n        }\\n    }\\n\\n    void remove(int num) {\\n        Node *cur = root;\\n        for (int i = 18; i >= 0; i--) {\\n            bool bit = (num & (1 << i));\\n            cur = cur->children[bit];\\n            cur->count--;\\n        }\\n    }\\n\\n    int search(int num) {\\n        int res = 0;\\n        Node *cur = root;\\n        for (int i = 18; i >= 0; i--) {\\n            bool bit = (num & (1 << i));\\n            if (cur->children[!bit] && cur->children[!bit]->count > 0) {\\n                res += (1 << i);\\n                cur = cur->children[!bit];\\n            } else {\\n                cur = cur->children[bit];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\n\\n    vector<vector<pair<int, int>>> mp;\\n    Trie *t;\\n    vector<int> res;\\n\\n    void dfs(vector<int> gr[], int cur) {\\n        t->insert(cur);\\n        for (auto &child : mp[cur]) {\\n            res[child.second] = t->search(child.first);\\n        }\\n        for (int &child : gr[cur]) {\\n            dfs(gr, child);\\n        }\\n        t->remove(cur);\\n    }\\n\\npublic:\\n    vector<int> maxGeneticDifference(vector<int> &parents, vector<vector<int>> &queries) {\\n        t = new Trie();\\n\\n        int n = parents.size();\\n        vector<int> gr[n];\\n        res.resize(queries.size());\\n\\n        int root = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (parents[i] == -1)\\n                root = i;\\n            else\\n                gr[parents[i]].push_back(i);\\n        }\\n        mp.resize(n);\\n        for (int i = 0; i < queries.size(); i++) {\\n            mp[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n\\n        dfs(gr, root);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n/* \\n    Time: O(q+n)\\n    Space: O(q+n)\\n    Tag: Trie, N-ary Tree\\n    Difficulty: H\\n*/\\nstruct Node {\\n    int count;\\n    vector<Node *> children;\\n    Node() {\\n        children.resize(2, NULL);\\n        count = 0;\\n    }\\n};\\n\\nclass Trie {\\n    Node *root;\\n\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n\\n    void insert(int num) {\\n        Node *cur = root;\\n        for (int i = 18; i >= 0; i--) {\\n            bool bit = (num & (1 << i));\\n            if (!cur->children[bit]) cur->children[bit] = new Node();\\n            cur = cur->children[bit];\\n            cur->count++;\\n        }\\n    }\\n\\n    void remove(int num) {\\n        Node *cur = root;\\n        for (int i = 18; i >= 0; i--) {\\n            bool bit = (num & (1 << i));\\n            cur = cur->children[bit];\\n            cur->count--;\\n        }\\n    }\\n\\n    int search(int num) {\\n        int res = 0;\\n        Node *cur = root;\\n        for (int i = 18; i >= 0; i--) {\\n            bool bit = (num & (1 << i));\\n            if (cur->children[!bit] && cur->children[!bit]->count > 0) {\\n                res += (1 << i);\\n                cur = cur->children[!bit];\\n            } else {\\n                cur = cur->children[bit];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\n\\n    vector<vector<pair<int, int>>> mp;\\n    Trie *t;\\n    vector<int> res;\\n\\n    void dfs(vector<int> gr[], int cur) {\\n        t->insert(cur);\\n        for (auto &child : mp[cur]) {\\n            res[child.second] = t->search(child.first);\\n        }\\n        for (int &child : gr[cur]) {\\n            dfs(gr, child);\\n        }\\n        t->remove(cur);\\n    }\\n\\npublic:\\n    vector<int> maxGeneticDifference(vector<int> &parents, vector<vector<int>> &queries) {\\n        t = new Trie();\\n\\n        int n = parents.size();\\n        vector<int> gr[n];\\n        res.resize(queries.size());\\n\\n        int root = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (parents[i] == -1)\\n                root = i;\\n            else\\n                gr[parents[i]].push_back(i);\\n        }\\n        mp.resize(n);\\n        for (int i = 0; i < queries.size(); i++) {\\n            mp[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n\\n        dfs(gr, root);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213566,
                "title": "python-trie-and-recursion-i-tried-and-succeeded-pun-intended",
                "content": "```\\nclass trie:\\n    def __init__(self):\\n        self.nodes=0\\n        self.child=defaultdict(trie)\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        root=trie()\\n        ma=20\\n        def add(i):\\n            s=bin(i)[2:].zfill(ma)\\n            z=root\\n            for j in s:\\n                z=z.child[j]\\n                z.nodes+=1\\n        def remove(i):\\n            s=bin(i)[2:].zfill(ma)\\n            z=root\\n            for j in s:\\n                z=z.child[j]\\n                z.nodes-=1\\n        def get(i):\\n            s=bin(i)[2:].zfill(ma)\\n            z=root\\n            r=\\'\\'\\n            for j in s:\\n                if j==\\'1\\':\\n                    if z.child[\\'0\\'].nodes>0:\\n                        r+=\\'1\\'\\n                        z=z.child[\\'0\\']\\n                    else:\\n                        r+=\\'0\\'\\n                        z=z.child[\\'1\\']\\n                else:\\n                    if z.child[\\'1\\'].nodes>0:\\n                        r+=\\'1\\'\\n                        z=z.child[\\'1\\']\\n                    else:\\n                        r+=\\'0\\'\\n                        z=z.child[\\'0\\']\\n            return int(r,2)\\n        def f(i):    \\n            add(i)#add to trie\\n            for j,k in y[i]:#handle queries\\n                res[k]=get(j)\\n            for j in x[i]:#go to children\\n                f(j)\\n            remove(i)#remove from trie\\n        n=len(parents)\\n        x=[[] for i in range(n)]\\n        r=0\\n        for i in range(n):\\n            if parents[i]==-1:\\n                r=i\\n            else:\\n                x[parents[i]].append(i)\\n        y=[[] for i in range(n)]\\n        for i in range(len(queries)):\\n            a,b=queries[i]\\n            y[a].append((b,i))\\n        res=[0 for i in range(len(queries))]\\n        f(r)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass trie:\\n    def __init__(self):\\n        self.nodes=0\\n        self.child=defaultdict(trie)\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        root=trie()\\n        ma=20\\n        def add(i):\\n            s=bin(i)[2:].zfill(ma)\\n            z=root\\n            for j in s:\\n                z=z.child[j]\\n                z.nodes+=1\\n        def remove(i):\\n            s=bin(i)[2:].zfill(ma)\\n            z=root\\n            for j in s:\\n                z=z.child[j]\\n                z.nodes-=1\\n        def get(i):\\n            s=bin(i)[2:].zfill(ma)\\n            z=root\\n            r=\\'\\'\\n            for j in s:\\n                if j==\\'1\\':\\n                    if z.child[\\'0\\'].nodes>0:\\n                        r+=\\'1\\'\\n                        z=z.child[\\'0\\']\\n                    else:\\n                        r+=\\'0\\'\\n                        z=z.child[\\'1\\']\\n                else:\\n                    if z.child[\\'1\\'].nodes>0:\\n                        r+=\\'1\\'\\n                        z=z.child[\\'1\\']\\n                    else:\\n                        r+=\\'0\\'\\n                        z=z.child[\\'0\\']\\n            return int(r,2)\\n        def f(i):    \\n            add(i)#add to trie\\n            for j,k in y[i]:#handle queries\\n                res[k]=get(j)\\n            for j in x[i]:#go to children\\n                f(j)\\n            remove(i)#remove from trie\\n        n=len(parents)\\n        x=[[] for i in range(n)]\\n        r=0\\n        for i in range(n):\\n            if parents[i]==-1:\\n                r=i\\n            else:\\n                x[parents[i]].append(i)\\n        y=[[] for i in range(n)]\\n        for i in range(len(queries)):\\n            a,b=queries[i]\\n            y[a].append((b,i))\\n        res=[0 for i in range(len(queries))]\\n        f(r)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197572,
                "title": "c-offline-query-dfs-dynamic-trie",
                "content": "```\\n\\n/*\\nborrow ideas from https://www.acwing.com/solution/content/58041/\\n*/\\n\\nconst int N = 100010, M = 17;\\n\\nclass Solution {\\n    set<int> gh[N];\\n    vector<int> qq[N];\\n    int tr[M * N + 10][2] = {}, idx = 0;\\n    int cnt[M * N + 10];\\n    \\n    void add(int x)\\n    {\\n        int p = 0;\\n        for (int i = M; i >= 0; -- i)\\n        {\\n            int j = x >> i & 1;\\n            if (!tr[p][j]) \\n            {\\n                tr[p][j] = ++ idx;    \\n            }\\n            p = tr[p][j];\\n            cnt[p] ++ ;\\n        }\\n    }\\n    \\n    int find(int x)\\n    {\\n        int p = 0, res = 0;\\n        for (int i = M; i >= 0; -- i)\\n        {\\n            int j = x >> i & 1;\\n            if (tr[p][!j]) \\n            {\\n                res |= 1 << i;\\n                p = tr[p][!j];   \\n            }   \\n            else p = tr[p][j];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void remove(int x)\\n    {\\n        int p = 0;\\n        for (int i = M; i >= 0; -- i)\\n        {\\n            int j = x >> i & 1;\\n            int t = tr[p][j];\\n            if (cnt[t] == 1) \\n            {\\n                tr[p][j] = 0, idx -- ;\\n            }\\n            cnt[t] -- ; \\n            p = t;\\n        }\\n    }\\n    \\n    \\n    bool exist(int x)\\n    {\\n        int p = 0;\\n        for (int i = M; i >= 0; -- i)\\n        {\\n            int j = x >> i & 1;\\n            if (!tr[p][j]) return false;\\n            p = tr[p][j];\\n            cout << cnt[p] << \" \";\\n        }\\n        cout << endl;\\n        return true;\\n    }\\n    \\n    vector<int> ans;\\n    vector<vector<int>> _qs;\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& arr, vector<vector<int>>& qs) {\\n        _qs = qs;\\n        int n = arr.size();\\n        int root;\\n        for (int i = 0; i < n; ++ i)\\n        {\\n            if (arr[i] == -1) root = i;\\n            else gh[arr[i]].insert(i);\\n        }\\n        for (int i = 0; i < qs.size(); ++ i)\\n            qq[qs[i][0]].push_back(i);\\n        \\n        ans.resize(qs.size());\\n\\n        dfs(root);\\n        \\n        return ans;\\n    }\\n    \\n    \\n    void dfs(int u)\\n    {\\n        add(u);\\n        for (int i : qq[u])\\n        {\\n            int v = _qs[i][1];\\n            ans[i] = find(v);\\n        }\\n        \\n        for (int v : gh[u])\\n        {\\n            dfs(v);\\n        }\\n        \\n        remove(u);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/*\\nborrow ideas from https://www.acwing.com/solution/content/58041/\\n*/\\n\\nconst int N = 100010, M = 17;\\n\\nclass Solution {\\n    set<int> gh[N];\\n    vector<int> qq[N];\\n    int tr[M * N + 10][2] = {}, idx = 0;\\n    int cnt[M * N + 10];\\n    \\n    void add(int x)\\n    {\\n        int p = 0;\\n        for (int i = M; i >= 0; -- i)\\n        {\\n            int j = x >> i & 1;\\n            if (!tr[p][j]) \\n            {\\n                tr[p][j] = ++ idx;    \\n            }\\n            p = tr[p][j];\\n            cnt[p] ++ ;\\n        }\\n    }\\n    \\n    int find(int x)\\n    {\\n        int p = 0, res = 0;\\n        for (int i = M; i >= 0; -- i)\\n        {\\n            int j = x >> i & 1;\\n            if (tr[p][!j]) \\n            {\\n                res |= 1 << i;\\n                p = tr[p][!j];   \\n            }   \\n            else p = tr[p][j];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void remove(int x)\\n    {\\n        int p = 0;\\n        for (int i = M; i >= 0; -- i)\\n        {\\n            int j = x >> i & 1;\\n            int t = tr[p][j];\\n            if (cnt[t] == 1) \\n            {\\n                tr[p][j] = 0, idx -- ;\\n            }\\n            cnt[t] -- ; \\n            p = t;\\n        }\\n    }\\n    \\n    \\n    bool exist(int x)\\n    {\\n        int p = 0;\\n        for (int i = M; i >= 0; -- i)\\n        {\\n            int j = x >> i & 1;\\n            if (!tr[p][j]) return false;\\n            p = tr[p][j];\\n            cout << cnt[p] << \" \";\\n        }\\n        cout << endl;\\n        return true;\\n    }\\n    \\n    vector<int> ans;\\n    vector<vector<int>> _qs;\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& arr, vector<vector<int>>& qs) {\\n        _qs = qs;\\n        int n = arr.size();\\n        int root;\\n        for (int i = 0; i < n; ++ i)\\n        {\\n            if (arr[i] == -1) root = i;\\n            else gh[arr[i]].insert(i);\\n        }\\n        for (int i = 0; i < qs.size(); ++ i)\\n            qq[qs[i][0]].push_back(i);\\n        \\n        ans.resize(qs.size());\\n\\n        dfs(root);\\n        \\n        return ans;\\n    }\\n    \\n    \\n    void dfs(int u)\\n    {\\n        add(u);\\n        for (int i : qq[u])\\n        {\\n            int v = _qs[i][1];\\n            ans[i] = find(v);\\n        }\\n        \\n        for (int v : gh[u])\\n        {\\n            dfs(v);\\n        }\\n        \\n        remove(u);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2176345,
                "title": "python-backtracking-bit-trie-xor-clean-code",
                "content": "Before understanding the following, we need to understand the following two.\\n421. Maximum XOR of Two Numbers in an Array https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/2177104/python-bit-trie-easier-to-understand-clean-code\\n1803. Count Pairs With XOR in a Range  https://leetcode.com/problems/count-pairs-with-xor-in-a-range/discuss/1122495/C%2B%2B-with-picture\\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.root = {}\\n        \\n    def add(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur:\\n                cur[c] = {}\\n            cur = cur[c]\\n            \\n    def find(self, word):\\n        cur = self.root\\n        res = \"\"\\n        for c in word:\\n            desired = \"1\" if c == \"0\" else \"0\"\\n            if not desired in cur:\\n                desired = c\\n            res += desired\\n            cur = cur[desired]\\n        return res\\n    \\n    def delete(self, word):\\n        cur = self.root\\n        path = []\\n        for c in word:\\n            path.append(cur)\\n            cur = cur[c]\\n        for c, obj in zip(word[::-1], path[::-1]):\\n            if not obj[c]:\\n                del obj[c]\\n            else:\\n                break\\n        \\n    \\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        #since max(10^5,2*10^5) < 2^18, 18 bits are enough to represent a value or node as a bit string \\n        def makebin(x):\\n            return bin(x)[2:].zfill(18)\\n        node_queries = defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            node_queries[node].append((i,val))\\n        graph = defaultdict(list)\\n        for y, x in enumerate(parents):\\n            graph[x].append(y)\\n        res = [-1 for _ in queries]\\n        tree = Trie()\\n        #dfs traversal\\n        #during the traversal, it is making bit Trie using the nodes from the root to the current node of the graph\\n        def dfs(v):\\n            v_bin = makebin(v)\\n            tree.add(v_bin)\\n            for i, val in node_queries[v]:\\n                val_bin = makebin(val)\\n                target_bin = tree.find(val_bin)\\n                res[i] = int(target_bin,2)^val\\n            for w in graph[v]:\\n                dfs(w)\\n            tree.delete(v_bin)\\n        dfs(graph[-1][0]) #dfs from the root\\n        return res\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Trie"
                ],
                "code": "Before understanding the following, we need to understand the following two.\\n421. Maximum XOR of Two Numbers in an Array https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/2177104/python-bit-trie-easier-to-understand-clean-code\\n1803. Count Pairs With XOR in a Range  https://leetcode.com/problems/count-pairs-with-xor-in-a-range/discuss/1122495/C%2B%2B-with-picture\\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.root = {}\\n        \\n    def add(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur:\\n                cur[c] = {}\\n            cur = cur[c]\\n            \\n    def find(self, word):\\n        cur = self.root\\n        res = \"\"\\n        for c in word:\\n            desired = \"1\" if c == \"0\" else \"0\"\\n            if not desired in cur:\\n                desired = c\\n            res += desired\\n            cur = cur[desired]\\n        return res\\n    \\n    def delete(self, word):\\n        cur = self.root\\n        path = []\\n        for c in word:\\n            path.append(cur)\\n            cur = cur[c]\\n        for c, obj in zip(word[::-1], path[::-1]):\\n            if not obj[c]:\\n                del obj[c]\\n            else:\\n                break\\n        \\n    \\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        #since max(10^5,2*10^5) < 2^18, 18 bits are enough to represent a value or node as a bit string \\n        def makebin(x):\\n            return bin(x)[2:].zfill(18)\\n        node_queries = defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            node_queries[node].append((i,val))\\n        graph = defaultdict(list)\\n        for y, x in enumerate(parents):\\n            graph[x].append(y)\\n        res = [-1 for _ in queries]\\n        tree = Trie()\\n        #dfs traversal\\n        #during the traversal, it is making bit Trie using the nodes from the root to the current node of the graph\\n        def dfs(v):\\n            v_bin = makebin(v)\\n            tree.add(v_bin)\\n            for i, val in node_queries[v]:\\n                val_bin = makebin(val)\\n                target_bin = tree.find(val_bin)\\n                res[i] = int(target_bin,2)^val\\n            for w in graph[v]:\\n                dfs(w)\\n            tree.delete(v_bin)\\n        dfs(graph[-1][0]) #dfs from the root\\n        return res\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2128909,
                "title": "trie-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Node\\n    {\\n        int cnt[2];\\n        Node *child[2];\\n        Node()\\n        {\\n            for(int i=0;i<2;i++)\\n                cnt[i]=0,child[i]=NULL;\\n        }\\n    }*root;\\n    \\n    void add(int n)\\n    {\\n        Node *now=root;\\n        for(int i=30;i>=0;i--)\\n        {\\n            bool x=(n & (1<<i));\\n            if(!now->child[x]) now->child[x]=new Node();\\n            now->cnt[x]++;\\n            now=now->child[x];\\n        }\\n    }\\n    \\n    void remove(int n)\\n    {\\n        Node *now=root;\\n        for(int i=30;i>=0;i--)\\n        {\\n            bool x=(n & (1<<i));\\n            now->cnt[x]--;\\n            if(now->cnt[x]==0)\\n            {\\n                now->child[x]=NULL;\\n                delete(now->child[x]);\\n                return ;\\n            }\\n            now=now->child[x];\\n        }\\n    }\\n    \\n    int get(int val)\\n    {\\n        Node *now=root;\\n        int ans=0;\\n        for(int i=30;i>=0;i--)\\n        {\\n            bool x=(val & (1<<i));\\n            if(x)\\n            {\\n                if(now->cnt[0])\\n                    ans|=(1<<i),now=now->child[0];\\n                else\\n                    now=now->child[1];\\n            }\\n            else\\n            {\\n                if(now->cnt[1])\\n                    ans|=(1<<i),now=now->child[1];\\n                else\\n                    now=now->child[0];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<int> v[100005],ans;\\n    vector<pair<int,int>> q[100005];\\n    \\n    void dfs(int now)\\n    {\\n        add(now);\\n        for(auto to:v[now])\\n            dfs(to);\\n        for(auto i:q[now])\\n            ans[i.second]=get(i.first);\\n        remove(now);\\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& p, vector<vector<int>>& qu) \\n    {\\n        int n=p.size(),rt;\\n        for(int i=0;i<n;i++)\\n            if(p[i]!=-1) v[p[i]].push_back(i);\\n            else  rt=i;\\n        for(int i=0;i<qu.size();i++)\\n            q[qu[i][0]].push_back({qu[i][1],i});\\n        \\n        root=new Node();\\n        ans.resize(qu.size());\\n        dfs(rt);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node\\n    {\\n        int cnt[2];\\n        Node *child[2];\\n        Node()\\n        {\\n            for(int i=0;i<2;i++)\\n                cnt[i]=0,child[i]=NULL;\\n        }\\n    }*root;\\n    \\n    void add(int n)\\n    {\\n        Node *now=root;\\n        for(int i=30;i>=0;i--)\\n        {\\n            bool x=(n & (1<<i));\\n            if(!now->child[x]) now->child[x]=new Node();\\n            now->cnt[x]++;\\n            now=now->child[x];\\n        }\\n    }\\n    \\n    void remove(int n)\\n    {\\n        Node *now=root;\\n        for(int i=30;i>=0;i--)\\n        {\\n            bool x=(n & (1<<i));\\n            now->cnt[x]--;\\n            if(now->cnt[x]==0)\\n            {\\n                now->child[x]=NULL;\\n                delete(now->child[x]);\\n                return ;\\n            }\\n            now=now->child[x];\\n        }\\n    }\\n    \\n    int get(int val)\\n    {\\n        Node *now=root;\\n        int ans=0;\\n        for(int i=30;i>=0;i--)\\n        {\\n            bool x=(val & (1<<i));\\n            if(x)\\n            {\\n                if(now->cnt[0])\\n                    ans|=(1<<i),now=now->child[0];\\n                else\\n                    now=now->child[1];\\n            }\\n            else\\n            {\\n                if(now->cnt[1])\\n                    ans|=(1<<i),now=now->child[1];\\n                else\\n                    now=now->child[0];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<int> v[100005],ans;\\n    vector<pair<int,int>> q[100005];\\n    \\n    void dfs(int now)\\n    {\\n        add(now);\\n        for(auto to:v[now])\\n            dfs(to);\\n        for(auto i:q[now])\\n            ans[i.second]=get(i.first);\\n        remove(now);\\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& p, vector<vector<int>>& qu) \\n    {\\n        int n=p.size(),rt;\\n        for(int i=0;i<n;i++)\\n            if(p[i]!=-1) v[p[i]].push_back(i);\\n            else  rt=i;\\n        for(int i=0;i<qu.size();i++)\\n            q[qu[i][0]].push_back({qu[i][1],i});\\n        \\n        root=new Node();\\n        ans.resize(qu.size());\\n        dfs(rt);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974353,
                "title": "using-hashmap-getting-tle-50-58-passed",
                "content": "``` \\npublic int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        HashMap<Integer , Integer> map = new HashMap();\\n        int n = parents.length;\\n        for(int i = 0; i<n; i++){ \\n            map.put(i , parents[i]);  // storing (node , parent)\\n        }\\n        \\n       \\n        int[] ans = new int[queries.length]; // ans array\\n        int idx = 0;\\n        int max = 0;\\n        \\n        int node = 0;\\n        int xorEle = 0;\\n        for(int i =0; i<queries.length ; i++){\\n            for(int j=0; j<queries[0].length; j++){\\n                max = 0;\\n                \\n                node = queries[i][0];\\n                xorEle = queries[i][1];\\n                \\n                while(node != -1){\\n                    max = Math.max(max , xorEle^node);\\n                    node = map.get(node);\\n                }\\n                \\n                // here max will contain maxXor of entire path correponding to queries[i][0]\\n                ans[i] = max;\\n            }\\n        }\\n        \\n\\n        return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\npublic int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        HashMap<Integer , Integer> map = new HashMap();\\n        int n = parents.length;\\n        for(int i = 0; i<n; i++){ \\n            map.put(i , parents[i]);  // storing (node , parent)\\n        }\\n        \\n       \\n        int[] ans = new int[queries.length]; // ans array\\n        int idx = 0;\\n        int max = 0;\\n        \\n        int node = 0;\\n        int xorEle = 0;\\n        for(int i =0; i<queries.length ; i++){\\n            for(int j=0; j<queries[0].length; j++){\\n                max = 0;\\n                \\n                node = queries[i][0];\\n                xorEle = queries[i][1];\\n                \\n                while(node != -1){\\n                    max = Math.max(max , xorEle^node);\\n                    node = map.get(node);\\n                }\\n                \\n                // here max will contain maxXor of entire path correponding to queries[i][0]\\n                ans[i] = max;\\n            }\\n        }\\n        \\n\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1950958,
                "title": "c-tree-traverse-binary-trie-solution",
                "content": "Runtime: 880 ms, faster than 81.82% of C++ online submissions for Maximum Genetic Difference Query.\\nMemory Usage: 228.6 MB, less than 89.61% of C++ online submissions for Maximum Genetic Difference Query.\\n\\nProblem is same as [1707. Maximum XOR With an Element From Array](https://leetcode.com/problems/maximum-xor-with-an-element-from-array/), [Solution](https://leetcode.com/problems/maximum-xor-with-an-element-from-array/discuss/1950675/C++-Sort-+-Binary-Trie-Solution)\\n\\n```\\nFirst build the tree from given parent list and get the root node.\\nCreate Binary Trie root.\\nStore all queries in the Map of node.\\nTraverse tree in preorder way and calculate all queries related to each node.\\nWhen visit a node, add it to Binary Trie and then calculate query and after coming back\\nfrom its child node remove it from Binary Trie.\\n\\nMax XOR of any value is the maximum possible reverse bit value which we can find\\nin the Binary Trie where all nodes in the path from root are stored.\\n\\nWe are adding counter +1 in the node when inserting value in Binary Trie \\nand counter -1 when removing node from Trie.\\n\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    struct Node\\n    {\\n        Node * child[2];\\n        int c;  // extra counter to check if bit is valid\\n    };\\n    \\n    Node * BTroot;\\n    \\n    Node * createNode()\\n    {\\n        Node * node = new Node();\\n        node->child[0] = NULL;\\n        node->child[1] = NULL;\\n        node->c = 0;\\n        return node;\\n    }\\n    \\n    // update bits of num value in to Binary Trie from MSB to LSB\\n    // +1 with node->c to make bit valid and -1 to make it invalid but not until becomes 0\\n    void update(int num, int d)\\n    {\\n        Node * node = BTroot;\\n        int digit;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            digit = (num>>i) & 1;\\n            \\n            if(node->child[digit]==NULL)\\n                node->child[digit] = createNode();\\n            \\n            node = node->child[digit];\\n            node->c+=d;\\n        }\\n    }\\n    \\n    // search the largest possible reverse bit value of given value\\n    // node->c > 0  makes bit valid, otherwise bit invalid    \\n    int getMaxValue(int num)\\n    {\\n        Node * node = BTroot;\\n        int digit;\\n        int val = 0;\\n        \\n        // loop through value bits MSB to LSB\\n        for(int i=31;i>=0;i--)\\n        {\\n            digit = (num>>i) & 1;\\n            \\n            // for current bit 1, move to 0 bit if possible\\n            if(digit && node->child[digit-1] && node->child[digit-1]->c >0)\\n            {\\n                node = node->child[digit-1];   \\n                val += pow(2,i);    // XOR bit 1, so add value\\n            }\\n            else if(digit && node->child[digit] && node->child[digit]->c >0)node = node->child[digit];\\n            \\n            // for current bit 0, move to 1 bit if possible\\n            else if(!digit && node->child[digit+1] && node->child[digit+1]->c >0)\\n            {\\n                node = node->child[digit+1];\\n                val += pow(2,i);    // XOR bit 1, so add value\\n            }\\n            else if(!digit && node->child[digit] && node->child[digit]->c >0)node = node->child[digit];\\n        }\\n        \\n        return val;        \\n    }\\n    \\n    // traverse tree in preorder way and check any query exists for current node\\n    void preorderTraverse(int node, vector<vector<int>>&tree, unordered_map<int,vector<pair<int,int>>>&query, vector<int>&res)\\n    {\\n        update(node,1); // add node value to BT \\n        \\n        // process all query related to current node\\n        if(query.find(node)!=query.end())\\n        {\\n            for(int k=0;k<query[node].size();k++)\\n                res[query[node][k].second] = getMaxValue(query[node][k].first);            \\n        }\\n\\n        // move forward to child nodes \\n        for(int i=0;i<tree[node].size();i++)\\n            preorderTraverse(tree[node][i],tree,query,res);\\n        \\n        update(node,-1);    // delete node value from BT\\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        \\n        int n = parents.size();\\n        vector<vector<int>>tree(n);\\n        int root;\\n        \\n        // Binary Trie root\\n        BTroot = createNode();\\n        \\n        // create tree from parents list and get the root node\\n        for(int i=0;i<parents.size();i++)\\n        {\\n            if(parents[i]==-1)root = i;\\n            else tree[parents[i]].push_back(i);\\n        }\\n        \\n        // store query value and index in map\\n        unordered_map<int,vector<pair<int,int>>>query;\\n        \\n        for(int i=0;i<queries.size();i++)\\n            query[queries[i][0]].push_back({queries[i][1],i});\\n        \\n        \\n        vector<int>res(queries.size());\\n        \\n        // preorder traverse from root to all child and calculate query result\\n        preorderTraverse(root,tree,query,res);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie",
                    "Binary Tree"
                ],
                "code": "```\\nFirst build the tree from given parent list and get the root node.\\nCreate Binary Trie root.\\nStore all queries in the Map of node.\\nTraverse tree in preorder way and calculate all queries related to each node.\\nWhen visit a node, add it to Binary Trie and then calculate query and after coming back\\nfrom its child node remove it from Binary Trie.\\n\\nMax XOR of any value is the maximum possible reverse bit value which we can find\\nin the Binary Trie where all nodes in the path from root are stored.\\n\\nWe are adding counter +1 in the node when inserting value in Binary Trie \\nand counter -1 when removing node from Trie.\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    struct Node\\n    {\\n        Node * child[2];\\n        int c;  // extra counter to check if bit is valid\\n    };\\n    \\n    Node * BTroot;\\n    \\n    Node * createNode()\\n    {\\n        Node * node = new Node();\\n        node->child[0] = NULL;\\n        node->child[1] = NULL;\\n        node->c = 0;\\n        return node;\\n    }\\n    \\n    // update bits of num value in to Binary Trie from MSB to LSB\\n    // +1 with node->c to make bit valid and -1 to make it invalid but not until becomes 0\\n    void update(int num, int d)\\n    {\\n        Node * node = BTroot;\\n        int digit;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            digit = (num>>i) & 1;\\n            \\n            if(node->child[digit]==NULL)\\n                node->child[digit] = createNode();\\n            \\n            node = node->child[digit];\\n            node->c+=d;\\n        }\\n    }\\n    \\n    // search the largest possible reverse bit value of given value\\n    // node->c > 0  makes bit valid, otherwise bit invalid    \\n    int getMaxValue(int num)\\n    {\\n        Node * node = BTroot;\\n        int digit;\\n        int val = 0;\\n        \\n        // loop through value bits MSB to LSB\\n        for(int i=31;i>=0;i--)\\n        {\\n            digit = (num>>i) & 1;\\n            \\n            // for current bit 1, move to 0 bit if possible\\n            if(digit && node->child[digit-1] && node->child[digit-1]->c >0)\\n            {\\n                node = node->child[digit-1];   \\n                val += pow(2,i);    // XOR bit 1, so add value\\n            }\\n            else if(digit && node->child[digit] && node->child[digit]->c >0)node = node->child[digit];\\n            \\n            // for current bit 0, move to 1 bit if possible\\n            else if(!digit && node->child[digit+1] && node->child[digit+1]->c >0)\\n            {\\n                node = node->child[digit+1];\\n                val += pow(2,i);    // XOR bit 1, so add value\\n            }\\n            else if(!digit && node->child[digit] && node->child[digit]->c >0)node = node->child[digit];\\n        }\\n        \\n        return val;        \\n    }\\n    \\n    // traverse tree in preorder way and check any query exists for current node\\n    void preorderTraverse(int node, vector<vector<int>>&tree, unordered_map<int,vector<pair<int,int>>>&query, vector<int>&res)\\n    {\\n        update(node,1); // add node value to BT \\n        \\n        // process all query related to current node\\n        if(query.find(node)!=query.end())\\n        {\\n            for(int k=0;k<query[node].size();k++)\\n                res[query[node][k].second] = getMaxValue(query[node][k].first);            \\n        }\\n\\n        // move forward to child nodes \\n        for(int i=0;i<tree[node].size();i++)\\n            preorderTraverse(tree[node][i],tree,query,res);\\n        \\n        update(node,-1);    // delete node value from BT\\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        \\n        int n = parents.size();\\n        vector<vector<int>>tree(n);\\n        int root;\\n        \\n        // Binary Trie root\\n        BTroot = createNode();\\n        \\n        // create tree from parents list and get the root node\\n        for(int i=0;i<parents.size();i++)\\n        {\\n            if(parents[i]==-1)root = i;\\n            else tree[parents[i]].push_back(i);\\n        }\\n        \\n        // store query value and index in map\\n        unordered_map<int,vector<pair<int,int>>>query;\\n        \\n        for(int i=0;i<queries.size();i++)\\n            query[queries[i][0]].push_back({queries[i][1],i});\\n        \\n        \\n        vector<int>res(queries.size());\\n        \\n        // preorder traverse from root to all child and calculate query result\\n        preorderTraverse(root,tree,query,res);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891911,
                "title": "rust-dfs-trie",
                "content": "```\\n#[derive(Default,Debug)]\\nstruct Node {\\n    one: Option<Box<Node>>,\\n    zero: Option<Box<Node>>,\\n    child_num: i32,\\n}\\nimpl Node {\\n    pub fn new() -> Self {\\n        Self::default()\\n    }\\n    pub fn insert(&mut self, cur: i32, add: i32) {\\n        let mut node = self;\\n        let mut bit = 1 << 17;\\n        while bit != 0 {\\n            if cur & bit == 0 {\\n                node = node.zero.get_or_insert_with(Box::default);\\n            } else {\\n                node = node.one.get_or_insert_with(Box::default);\\n            }\\n            node.child_num += add;\\n            bit >>= 1;\\n        }\\n    }\\n    fn get_max(&mut self, num: i32) -> i32 {\\n        let mut node = self;\\n        let mut bit = 1 << 17;\\n        let mut res = 0;\\n        while bit != 0 {\\n            match num & bit {\\n                0 => {\\n                    if let Some(v) = node.one.as_deref_mut() {\\n                        if v.child_num > 0 {\\n                            node = v;\\n                            res |= bit;\\n                        } else {\\n                            node = node.zero.as_deref_mut().unwrap();\\n                        }\\n                    } else {\\n                        node = node.zero.as_deref_mut().unwrap();\\n                    }\\n                }\\n                _ => {\\n                    if let Some(v) = node.zero.as_deref_mut() {\\n                        if v.child_num > 0 {\\n                            node = v;\\n                            res |= bit;\\n                        } else {\\n                            node = node.one.as_deref_mut().unwrap();\\n                        }\\n                    } else {\\n                        node = node.one.as_deref_mut().unwrap();\\n                    }\\n                }\\n            }\\n            bit >>= 1;\\n        }\\n        res\\n    }\\n}\\nimpl Solution {\\n    pub fn max_genetic_difference(parents: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let n = queries.len();\\n        let number_of_node = parents.len();\\n        let mut res = vec![0;n];\\n        let mut query_node :Vec<Vec<(i32,usize)>>= vec![vec![];number_of_node];\\n        for (i,v) in queries.iter().enumerate(){\\n            let (node,val) = (v[0] as usize,v[1]);\\n            query_node[node].push((val,i));\\n        }\\n        let mut adj = vec![vec![];number_of_node];\\n        let mut root_num = 0;\\n        for (i,&v) in parents.iter().enumerate(){\\n            if v == -1{\\n                root_num = i;\\n                continue;\\n            }\\n            adj[v as usize].push(i);\\n        }\\n        let mut root = Node::new();\\n        fn dfs(cur:usize,res:&mut Vec<i32>,root: &mut Node,query_node:&Vec<Vec<(i32,usize)>>,\\n               adj:& Vec<Vec<usize>>){\\n            root.insert(cur as i32,1);\\n            for &(v,i) in query_node[cur].iter(){\\n                res[i] = root.get_max(v);\\n            }\\n            for &nxt in adj[cur].iter(){\\n                dfs(nxt,res,root,query_node,adj);\\n            }\\n            root.insert(cur as i32,-1);\\n        }\\n        dfs(root_num,&mut res,&mut root,&query_node,&adj);\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\n#[derive(Default,Debug)]\\nstruct Node {\\n    one: Option<Box<Node>>,\\n    zero: Option<Box<Node>>,\\n    child_num: i32,\\n}\\nimpl Node {\\n    pub fn new() -> Self {\\n        Self::default()\\n    }\\n    pub fn insert(&mut self, cur: i32, add: i32) {\\n        let mut node = self;\\n        let mut bit = 1 << 17;\\n        while bit != 0 {\\n            if cur & bit == 0 {\\n                node = node.zero.get_or_insert_with(Box::default);\\n            } else {\\n                node = node.one.get_or_insert_with(Box::default);\\n            }\\n            node.child_num += add;\\n            bit >>= 1;\\n        }\\n    }\\n    fn get_max(&mut self, num: i32) -> i32 {\\n        let mut node = self;\\n        let mut bit = 1 << 17;\\n        let mut res = 0;\\n        while bit != 0 {\\n            match num & bit {\\n                0 => {\\n                    if let Some(v) = node.one.as_deref_mut() {\\n                        if v.child_num > 0 {\\n                            node = v;\\n                            res |= bit;\\n                        } else {\\n                            node = node.zero.as_deref_mut().unwrap();\\n                        }\\n                    } else {\\n                        node = node.zero.as_deref_mut().unwrap();\\n                    }\\n                }\\n                _ => {\\n                    if let Some(v) = node.zero.as_deref_mut() {\\n                        if v.child_num > 0 {\\n                            node = v;\\n                            res |= bit;\\n                        } else {\\n                            node = node.one.as_deref_mut().unwrap();\\n                        }\\n                    } else {\\n                        node = node.one.as_deref_mut().unwrap();\\n                    }\\n                }\\n            }\\n            bit >>= 1;\\n        }\\n        res\\n    }\\n}\\nimpl Solution {\\n    pub fn max_genetic_difference(parents: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let n = queries.len();\\n        let number_of_node = parents.len();\\n        let mut res = vec![0;n];\\n        let mut query_node :Vec<Vec<(i32,usize)>>= vec![vec![];number_of_node];\\n        for (i,v) in queries.iter().enumerate(){\\n            let (node,val) = (v[0] as usize,v[1]);\\n            query_node[node].push((val,i));\\n        }\\n        let mut adj = vec![vec![];number_of_node];\\n        let mut root_num = 0;\\n        for (i,&v) in parents.iter().enumerate(){\\n            if v == -1{\\n                root_num = i;\\n                continue;\\n            }\\n            adj[v as usize].push(i);\\n        }\\n        let mut root = Node::new();\\n        fn dfs(cur:usize,res:&mut Vec<i32>,root: &mut Node,query_node:&Vec<Vec<(i32,usize)>>,\\n               adj:& Vec<Vec<usize>>){\\n            root.insert(cur as i32,1);\\n            for &(v,i) in query_node[cur].iter(){\\n                res[i] = root.get_max(v);\\n            }\\n            for &nxt in adj[cur].iter(){\\n                dfs(nxt,res,root,query_node,adj);\\n            }\\n            root.insert(cur as i32,-1);\\n        }\\n        dfs(root_num,&mut res,&mut root,&query_node,&adj);\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1801195,
                "title": "c-trie-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    class Trie {\\n        public:\\n            int cnt;\\n            Trie* node[2];\\n    };\\n    \\n    Trie* root = new Trie();\\n    \\n    void insert(string bits) {\\n        Trie* head = root;\\n        int n = bits.size();\\n        for(int i = 0; i < n; i++) {\\n            int val = bits[i] - \\'0\\';\\n            if(head->node[val] == NULL) {\\n                Trie* newNode = new Trie();\\n                newNode->cnt++;\\n                head->node[val] = newNode;\\n                head = newNode;\\n            } else {\\n                head->node[val]->cnt++;\\n                head = head->node[val];\\n            }\\n        }\\n    }\\n    \\n    void deleteNode(string bits) {\\n        Trie* head = root;\\n        int n = bits.size();\\n        for(int i = 0; i < n; i++) {\\n            int val = bits[i] - \\'0\\';\\n            head->node[val]->cnt--;\\n            head = head->node[val];\\n        }\\n    }\\n    \\n    int query(string bits) {\\n        Trie* head = root;\\n        int n = bits.size();\\n        int ans = 0, cur = n-1;\\n        for(int i = 0; i < n; i++) {\\n            int val = bits[i] - \\'0\\';\\n            val = 1 - val;\\n            if(head->node[val] != NULL and head->node[val]->cnt > 0) {\\n                ans += (1<<cur);\\n                head = head->node[val];\\n            } else {\\n                head = head->node[1-val];\\n            }\\n            cur--;\\n        }\\n        return ans;\\n    }\\n    \\n    string intTobits(int temp) {\\n        string bits = \"\";\\n        while(temp) {\\n            if(temp % 2 == 0) {\\n                bits.push_back(\\'0\\');\\n            } else {\\n                bits.push_back(\\'1\\');\\n            }\\n            temp /= 2;\\n        }\\n        while(bits.size() < 18) bits.push_back(\\'0\\');\\n        reverse(bits.begin(), bits.end());\\n        return bits;\\n    } \\n    \\n    int n, rt;\\n    vector<vector<int>> adj;\\n    vector<bool> vis;\\n    unordered_map<int, vector<pair<int,int>>> mp;\\n    \\n    void dfs(int node, vector<int>& ans) {\\n        vis[node] = true;\\n        insert(intTobits(node));\\n        for(auto i : mp[node]) ans[i.first] = query(intTobits(i.second));\\n        for(auto i : adj[node]) if(!vis[i]) dfs(i, ans);\\n        deleteNode(intTobits(node));\\n    }\\n     \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        \\n        vector<int> mpty;\\n        n = parents.size();\\n        \\n        for(int i = 0; i < n+1; i++) {\\n            adj.push_back(mpty);\\n            vis.push_back(false);\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(parents[i] == -1) {\\n                rt = i;\\n                continue;\\n            }\\n            adj[i].push_back(parents[i]);\\n            adj[parents[i]].push_back(i);\\n        }\\n        int len = queries.size();\\n        vector<int> ans(len);\\n        for(int i = 0; i < len; i++) {\\n            mp[queries[i][0]].push_back({i, queries[i][1]});\\n        }\\n        queries.clear();\\n        dfs(rt, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Trie {\\n        public:\\n            int cnt;\\n            Trie* node[2];\\n    };\\n    \\n    Trie* root = new Trie();\\n    \\n    void insert(string bits) {\\n        Trie* head = root;\\n        int n = bits.size();\\n        for(int i = 0; i < n; i++) {\\n            int val = bits[i] - \\'0\\';\\n            if(head->node[val] == NULL) {\\n                Trie* newNode = new Trie();\\n                newNode->cnt++;\\n                head->node[val] = newNode;\\n                head = newNode;\\n            } else {\\n                head->node[val]->cnt++;\\n                head = head->node[val];\\n            }\\n        }\\n    }\\n    \\n    void deleteNode(string bits) {\\n        Trie* head = root;\\n        int n = bits.size();\\n        for(int i = 0; i < n; i++) {\\n            int val = bits[i] - \\'0\\';\\n            head->node[val]->cnt--;\\n            head = head->node[val];\\n        }\\n    }\\n    \\n    int query(string bits) {\\n        Trie* head = root;\\n        int n = bits.size();\\n        int ans = 0, cur = n-1;\\n        for(int i = 0; i < n; i++) {\\n            int val = bits[i] - \\'0\\';\\n            val = 1 - val;\\n            if(head->node[val] != NULL and head->node[val]->cnt > 0) {\\n                ans += (1<<cur);\\n                head = head->node[val];\\n            } else {\\n                head = head->node[1-val];\\n            }\\n            cur--;\\n        }\\n        return ans;\\n    }\\n    \\n    string intTobits(int temp) {\\n        string bits = \"\";\\n        while(temp) {\\n            if(temp % 2 == 0) {\\n                bits.push_back(\\'0\\');\\n            } else {\\n                bits.push_back(\\'1\\');\\n            }\\n            temp /= 2;\\n        }\\n        while(bits.size() < 18) bits.push_back(\\'0\\');\\n        reverse(bits.begin(), bits.end());\\n        return bits;\\n    } \\n    \\n    int n, rt;\\n    vector<vector<int>> adj;\\n    vector<bool> vis;\\n    unordered_map<int, vector<pair<int,int>>> mp;\\n    \\n    void dfs(int node, vector<int>& ans) {\\n        vis[node] = true;\\n        insert(intTobits(node));\\n        for(auto i : mp[node]) ans[i.first] = query(intTobits(i.second));\\n        for(auto i : adj[node]) if(!vis[i]) dfs(i, ans);\\n        deleteNode(intTobits(node));\\n    }\\n     \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        \\n        vector<int> mpty;\\n        n = parents.size();\\n        \\n        for(int i = 0; i < n+1; i++) {\\n            adj.push_back(mpty);\\n            vis.push_back(false);\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(parents[i] == -1) {\\n                rt = i;\\n                continue;\\n            }\\n            adj[i].push_back(parents[i]);\\n            adj[parents[i]].push_back(i);\\n        }\\n        int len = queries.size();\\n        vector<int> ans(len);\\n        for(int i = 0; i < len; i++) {\\n            mp[queries[i][0]].push_back({i, queries[i][1]});\\n        }\\n        queries.clear();\\n        dfs(rt, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690671,
                "title": "java-dfs-trie",
                "content": "~~~java\\n\\nclass Solution {\\n    Node root = new Node();\\n    int n;\\n    List<Integer>[] graph;\\n    List<int[]>[] qs;\\n    \\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        this.n = parents.length;\\n        this.graph = new ArrayList[n];\\n        this.qs = new ArrayList[n];\\n        \\n        // 1. build tree graph\\n        int graphRoot = buildGraph(parents);\\n        \\n        // 2. build {node: [[idx, val]]}\\n        buildQueryMapping(queries);\\n        \\n        // 3. dfs\\n        int[] result = new int[queries.length];\\n        dfs(graphRoot, result);\\n        return result;\\n    }\\n    \\n    private void dfs(int currNode, int[] result) {\\n        add(currNode);\\n        \\n        if (qs[currNode] != null) {\\n            for (int[] q : qs[currNode]) {\\n                int qidx = q[0], qval = q[1];\\n                result[qidx] = find(qval) ^ qval;\\n            }\\n        }\\n        \\n        for (int child : graph[currNode]) {\\n            dfs(child, result);\\n        }\\n        \\n        remove(currNode);\\n    }\\n    \\n    private void add(int x) {\\n        Node curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int a = (x >> i) & 1;\\n            if (curr.children[a] == null) {\\n                curr.children[a] = new Node();\\n            }\\n            curr = curr.children[a];\\n            curr.increase();\\n        }\\n    }\\n    \\n    private void remove(int x) {\\n        Node curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int a = (x >> i) & 1;\\n            curr = curr.children[a];\\n            curr.decrease();\\n        }\\n    }\\n    \\n    private int find(int x) {\\n        Node curr = root;\\n        int result = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int a = (x >> i) & 1;\\n            int b = 1 - a;\\n            if (curr.children[b] != null && curr.children[b].isValid()) {\\n                result |= (b << i);\\n                curr = curr.children[b];\\n            } else {\\n                result |= (a << i);\\n                curr = curr.children[a];\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int buildGraph(int[] parents) {\\n        int graphRoot = -1;\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (parents[i] == -1) {\\n                graphRoot = i;\\n                continue;\\n            }\\n            graph[parents[i]].add(i);\\n        }\\n        return graphRoot;\\n    }\\n    \\n    private void buildQueryMapping(int[][] queries) {\\n        for (int i = 0; i < queries.length; i++) {\\n            int[] q = queries[i];\\n            int node = q[0], val = q[1];\\n            if (qs[node] == null) {\\n                qs[node] = new ArrayList<>();\\n            }\\n            qs[node].add(new int[]{i, val});\\n        }\\n    }\\n    \\n    private class Node {\\n        int cnt = 0;\\n        Node[] children = new Node[2];\\n        \\n        public void increase() {\\n            cnt++;\\n        }\\n        \\n        public void decrease() {\\n            cnt--;\\n        }\\n        \\n        public boolean isValid() {\\n            return cnt > 0;\\n        }\\n    }\\n}\\n\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    Node root = new Node();\\n    int n;\\n    List<Integer>[] graph;\\n    List<int[]>[] qs;\\n    \\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        this.n = parents.length;\\n        this.graph = new ArrayList[n];\\n        this.qs = new ArrayList[n];\\n        \\n        // 1. build tree graph\\n        int graphRoot = buildGraph(parents);\\n        \\n        // 2. build {node: [[idx, val]]}",
                "codeTag": "Java"
            },
            {
                "id": 1496160,
                "title": "trie-preorder-traversal-c-o-n-q-simple-implementation",
                "content": "Firstly, before attemping this problem, attempt \\n[LC 421](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/ )\\n\\nAfter this, we know that we can find the maximum XOR value for any given number in O(1) time, using its bits, and a trie. After that, the next thing is to make sure that we do a preorder traversal from the root of the tree, and in the process, what ever nodes we encounter, we can see if there is any query for that node (here I stored it in a seperate hash map). If there is any query, then we perform a search for that query in the trie. The trie is formed by adding all the values that are currently in our traversal stack. As soon as we return from any path, we need to make sure we remove that nodes value from the trie. This is simple enough. We can keep a count paramter in each node, to keep track of the number of paths that pass through a node. And while searching, we only go towards a path, if more than one path passes through it. \\n\\nWhile going to a node, we increament its path value in the trie, and while returning, we decrease it back to the way it was. The code is pretty much self explainatory. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    struct TrieNode{\\n        vector<TrieNode*> children; \\n        int val, count; \\n        TrieNode(){\\n            children.resize(2,NULL); \\n            val = 0;\\n            count = 0; \\n        }\\n    }; \\n\\n    void insert(TrieNode* root, int val, int incdec){\\n        TrieNode* node = root; \\n        for(int i=31; i>=0 ; i--){\\n            bool curr = (1<<i) & val; \\n            if(!node->children[curr]) node->children[curr] = new TrieNode(); \\n            node->children[curr]->count += incdec; \\n            node = node->children[curr]; \\n        }\\n        node->val = val; \\n    }\\n    \\n    int search(TrieNode* root, int val ){\\n        TrieNode* node = root; \\n        for(int i=31; i>=0; i--){\\n            bool curr = (1<<i ) & val; \\n            if(node->children[1-curr] && node->children[1-curr]->count > 0) node = node->children[1-curr]; \\n            else node = node->children[curr]; \\n        }\\n        return val ^ node->val ; \\n    }\\n    \\n    unordered_map<int,vector<vector<int>>> mp; \\n    vector<vector<int>> adj; \\n    vector<int> visited, res; \\n    \\n    void preorder(TrieNode* root, int treeRoot){ \\n        if(visited[treeRoot]) return ;\\n        visited[treeRoot] = 1; \\n        insert(root, treeRoot,1); \\n        \\n        for(auto &query:mp[treeRoot] ){\\n            res[query[1]] = search(root, query[0]); \\n        }\\n        \\n        for(auto child: adj[treeRoot]) {\\n            preorder(root, child); \\n        }\\n        insert(root, treeRoot, -1); \\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size(); \\n        adj.resize(n), visited.resize(n,0), res.resize(queries.size(), 0);\\n        \\n        TrieNode* root = new TrieNode();\\n        int treeRoot; \\n        \\n        for(int i=0; i<queries.size(); i++) mp[queries[i][0]].push_back({queries[i][1], i}); \\n        \\n        for(int i=0; i<n ; i++){\\n            if(parents[i] == -1) treeRoot = i; \\n            else  adj[parents[i]].push_back(i);\\n        }\\n        preorder(root, treeRoot);\\n        \\n        return res; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct TrieNode{\\n        vector<TrieNode*> children; \\n        int val, count; \\n        TrieNode(){\\n            children.resize(2,NULL); \\n            val = 0;\\n            count = 0; \\n        }\\n    }; \\n\\n    void insert(TrieNode* root, int val, int incdec){\\n        TrieNode* node = root; \\n        for(int i=31; i>=0 ; i--){\\n            bool curr = (1<<i) & val; \\n            if(!node->children[curr]) node->children[curr] = new TrieNode(); \\n            node->children[curr]->count += incdec; \\n            node = node->children[curr]; \\n        }\\n        node->val = val; \\n    }\\n    \\n    int search(TrieNode* root, int val ){\\n        TrieNode* node = root; \\n        for(int i=31; i>=0; i--){\\n            bool curr = (1<<i ) & val; \\n            if(node->children[1-curr] && node->children[1-curr]->count > 0) node = node->children[1-curr]; \\n            else node = node->children[curr]; \\n        }\\n        return val ^ node->val ; \\n    }\\n    \\n    unordered_map<int,vector<vector<int>>> mp; \\n    vector<vector<int>> adj; \\n    vector<int> visited, res; \\n    \\n    void preorder(TrieNode* root, int treeRoot){ \\n        if(visited[treeRoot]) return ;\\n        visited[treeRoot] = 1; \\n        insert(root, treeRoot,1); \\n        \\n        for(auto &query:mp[treeRoot] ){\\n            res[query[1]] = search(root, query[0]); \\n        }\\n        \\n        for(auto child: adj[treeRoot]) {\\n            preorder(root, child); \\n        }\\n        insert(root, treeRoot, -1); \\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size(); \\n        adj.resize(n), visited.resize(n,0), res.resize(queries.size(), 0);\\n        \\n        TrieNode* root = new TrieNode();\\n        int treeRoot; \\n        \\n        for(int i=0; i<queries.size(); i++) mp[queries[i][0]].push_back({queries[i][1], i}); \\n        \\n        for(int i=0; i<n ; i++){\\n            if(parents[i] == -1) treeRoot = i; \\n            else  adj[parents[i]].push_back(i);\\n        }\\n        preorder(root, treeRoot);\\n        \\n        return res; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431128,
                "title": "java-o-n-log-n-dfs-trie",
                "content": "```\\n\\tclass TrieNode{\\n        TrieNode left,right;\\n        int numLeft, numRight;\\n    }\\n    void addToTrie(TrieNode node, int val, int bit){\\n        if(bit>=0){\\n            if((val&(1<<bit))==0){\\n                node.numLeft++;\\n                if(node.left != null){\\n                    addToTrie(node.left,val,bit-1);\\n                }else{\\n                    node.left=new TrieNode();\\n                    addToTrie(node.left,val,bit-1);\\n                }\\n            }else{\\n                node.numRight++;\\n                if(node.right != null){\\n                    addToTrie(node.right,val,bit-1);\\n                }else{\\n                    node.right=new TrieNode();\\n                    addToTrie(node.right,val,bit-1);\\n                }\\n            }\\n        }\\n    }\\n    void removeFromTrie(TrieNode node, int val, int bit){\\n        if(bit>=0){\\n            if((val&(1<<bit))==0){\\n                removeFromTrie(node.left,val,bit-1);\\n                node.numLeft--;\\n                if(node.numLeft==0){\\n                    node.left=null;\\n                }\\n            }else{\\n                removeFromTrie(node.right,val,bit-1);\\n                node.numRight--;\\n                if(node.numRight==0){\\n                    node.right=null;\\n                }\\n            }\\n        }\\n    }\\n    int findMaxDiff(TrieNode node, int val, int bit, int curr){\\n        if(bit<0){\\n            return curr;\\n        }\\n        if(((val&(1<<bit))==0 && node.right!=null) || node.left==null){\\n            return findMaxDiff(node.right,val,bit-1,(curr<<1)|1);\\n        }\\n        return findMaxDiff(node.left,val,bit-1,curr<<1);\\n    }\\n    void dfs(int u, List<Integer> graph[], TrieNode trie, List<Integer> queriesAtNode[], int[][] queries, int ans[]){\\n        addToTrie(trie,u,18);\\n        for(int queryIdx:queriesAtNode[u]){\\n            ans[queryIdx]=queries[queryIdx][1]^findMaxDiff(trie,queries[queryIdx][1],18,0);\\n        }\\n        for(int v:graph[u]){\\n            dfs(v,graph,trie,queriesAtNode,queries,ans);\\n        }\\n        removeFromTrie(trie,u,18);\\n    }\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        int n=parents.length;\\n        TrieNode trie=new TrieNode();\\n        List<Integer> graph[]=new ArrayList[n];\\n        List<Integer> queriesAtNode[]=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i]=new ArrayList<>();\\n            queriesAtNode[i]=new ArrayList<>();\\n        }\\n        int root=0;\\n        for(int u=0;u<n;u++){\\n            if(parents[u]!=-1){\\n                graph[parents[u]].add(u);\\n            }else{\\n                root=u;\\n            }\\n        }\\n        for(int i=0;i<queries.length;i++){\\n            queriesAtNode[queries[i][0]].add(i);\\n        }\\n        int ans[]=new int[queries.length];\\n        dfs(root,graph,trie,queriesAtNode,queries,ans);\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\tclass TrieNode{\\n        TrieNode left,right;\\n        int numLeft, numRight;\\n    }\\n    void addToTrie(TrieNode node, int val, int bit){\\n        if(bit>=0){\\n            if((val&(1<<bit))==0){\\n                node.numLeft++;\\n                if(node.left != null){\\n                    addToTrie(node.left,val,bit-1);\\n                }else{\\n                    node.left=new TrieNode();\\n                    addToTrie(node.left,val,bit-1);\\n                }\\n            }else{\\n                node.numRight++;\\n                if(node.right != null){\\n                    addToTrie(node.right,val,bit-1);\\n                }else{\\n                    node.right=new TrieNode();\\n                    addToTrie(node.right,val,bit-1);\\n                }\\n            }\\n        }\\n    }\\n    void removeFromTrie(TrieNode node, int val, int bit){\\n        if(bit>=0){\\n            if((val&(1<<bit))==0){\\n                removeFromTrie(node.left,val,bit-1);\\n                node.numLeft--;\\n                if(node.numLeft==0){\\n                    node.left=null;\\n                }\\n            }else{\\n                removeFromTrie(node.right,val,bit-1);\\n                node.numRight--;\\n                if(node.numRight==0){\\n                    node.right=null;\\n                }\\n            }\\n        }\\n    }\\n    int findMaxDiff(TrieNode node, int val, int bit, int curr){\\n        if(bit<0){\\n            return curr;\\n        }\\n        if(((val&(1<<bit))==0 && node.right!=null) || node.left==null){\\n            return findMaxDiff(node.right,val,bit-1,(curr<<1)|1);\\n        }\\n        return findMaxDiff(node.left,val,bit-1,curr<<1);\\n    }\\n    void dfs(int u, List<Integer> graph[], TrieNode trie, List<Integer> queriesAtNode[], int[][] queries, int ans[]){\\n        addToTrie(trie,u,18);\\n        for(int queryIdx:queriesAtNode[u]){\\n            ans[queryIdx]=queries[queryIdx][1]^findMaxDiff(trie,queries[queryIdx][1],18,0);\\n        }\\n        for(int v:graph[u]){\\n            dfs(v,graph,trie,queriesAtNode,queries,ans);\\n        }\\n        removeFromTrie(trie,u,18);\\n    }\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        int n=parents.length;\\n        TrieNode trie=new TrieNode();\\n        List<Integer> graph[]=new ArrayList[n];\\n        List<Integer> queriesAtNode[]=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i]=new ArrayList<>();\\n            queriesAtNode[i]=new ArrayList<>();\\n        }\\n        int root=0;\\n        for(int u=0;u<n;u++){\\n            if(parents[u]!=-1){\\n                graph[parents[u]].add(u);\\n            }else{\\n                root=u;\\n            }\\n        }\\n        for(int i=0;i<queries.length;i++){\\n            queriesAtNode[queries[i][0]].add(i);\\n        }\\n        int ans[]=new int[queries.length];\\n        dfs(root,graph,trie,queriesAtNode,queries,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414865,
                "title": "simple-efficient-c-bittrie-dfs",
                "content": "O(18 * (node_count + query_count))\\n1) Perform depth first traversal of the input tree.\\n2) Maintain a bit trie of all nodes on the path from the root to the current node.\\n3) Match queries\\' values to the nodes in the trie.\\n\\n```\\ntemplate<int n>\\nclass BitTrie {\\n\\tint prefixes[1 << (n + 1)]{};\\n\\npublic:\\n\\tvoid add(int x) {\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t\\t++prefixes[(1 << (n - i)) - 1 + (x >> i)];\\n\\t}\\n\\n\\tvoid remove(int x) {\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t\\t--prefixes[(1 << (n - i)) - 1 + (x >> i)];\\n\\t}\\n\\n\\tint match(int x) {\\n\\t\\tfor (int i = n - 1; i >= 0; --i)\\n\\t\\t\\tif (prefixes[(1 << (n - i)) - 1 + (x >> i)] == 0)\\n\\t\\t\\t\\tx ^= 1 << i;\\n\\t\\treturn x;\\n\\t}\\n};\\n\\nclass Solution {\\n\\tstatic constexpr int n = 18, m = (1 << n) - 1;\\n\\n\\tBitTrie<n> trie;\\n\\tvector<vector<int>> tree;\\n\\tvector<vector<pair<int, int>>> values;\\n\\tvector<int> result;\\n\\n\\tvoid search(int parent) {\\n\\t\\ttrie.add(parent);\\n\\t\\tfor (auto [query, value] : values[parent])\\n\\t\\t\\tresult[query] = value ^ trie.match(value ^ m);\\n\\t\\tfor (int child : tree[parent])\\n\\t\\t\\tsearch(child);\\n\\t\\ttrie.remove(parent);\\n\\t}\\n\\npublic:\\n\\tvector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n\\t\\tresult.resize(queries.size());\\n\\t\\ttree.resize(parents.size());\\n\\t\\tvalues.resize(parents.size());\\n\\t\\tint root = -1;\\n\\t\\tfor (int i = 0; i < parents.size(); ++i)\\n\\t\\t\\tif (parents[i] != -1)\\n\\t\\t\\t\\ttree[parents[i]].push_back(i);\\n\\t\\t\\telse\\n\\t\\t\\t\\troot = i;\\n\\t\\tfor (int i = 0; i < queries.size(); ++i)\\n\\t\\t\\tvalues[queries[i][0]].push_back({ i, queries[i][1] });\\n\\t\\tsearch(root);\\n\\t\\treturn result;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntemplate<int n>\\nclass BitTrie {\\n\\tint prefixes[1 << (n + 1)]{};\\n\\npublic:\\n\\tvoid add(int x) {\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t\\t++prefixes[(1 << (n - i)) - 1 + (x >> i)];\\n\\t}\\n\\n\\tvoid remove(int x) {\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t\\t--prefixes[(1 << (n - i)) - 1 + (x >> i)];\\n\\t}\\n\\n\\tint match(int x) {\\n\\t\\tfor (int i = n - 1; i >= 0; --i)\\n\\t\\t\\tif (prefixes[(1 << (n - i)) - 1 + (x >> i)] == 0)\\n\\t\\t\\t\\tx ^= 1 << i;\\n\\t\\treturn x;\\n\\t}\\n};\\n\\nclass Solution {\\n\\tstatic constexpr int n = 18, m = (1 << n) - 1;\\n\\n\\tBitTrie<n> trie;\\n\\tvector<vector<int>> tree;\\n\\tvector<vector<pair<int, int>>> values;\\n\\tvector<int> result;\\n\\n\\tvoid search(int parent) {\\n\\t\\ttrie.add(parent);\\n\\t\\tfor (auto [query, value] : values[parent])\\n\\t\\t\\tresult[query] = value ^ trie.match(value ^ m);\\n\\t\\tfor (int child : tree[parent])\\n\\t\\t\\tsearch(child);\\n\\t\\ttrie.remove(parent);\\n\\t}\\n\\npublic:\\n\\tvector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n\\t\\tresult.resize(queries.size());\\n\\t\\ttree.resize(parents.size());\\n\\t\\tvalues.resize(parents.size());\\n\\t\\tint root = -1;\\n\\t\\tfor (int i = 0; i < parents.size(); ++i)\\n\\t\\t\\tif (parents[i] != -1)\\n\\t\\t\\t\\ttree[parents[i]].push_back(i);\\n\\t\\t\\telse\\n\\t\\t\\t\\troot = i;\\n\\t\\tfor (int i = 0; i < queries.size(); ++i)\\n\\t\\t\\tvalues[queries[i][0]].push_back({ i, queries[i][1] });\\n\\t\\tsearch(root);\\n\\t\\treturn result;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364170,
                "title": "c-trie-with-no-deletion",
                "content": "```cpp\\nclass Node {\\npublic:\\n    Node* ch[2];\\n    \\n    Node() {\\n        ch[0] = ch[1] = nullptr;\\n    }\\n};\\n\\nNode* insert(Node* node, int value, int i) {\\n    if(node == nullptr) {\\n        node = new Node();\\n    } else {\\n        node = new Node(*node);\\n    }\\n    if(i == -1) return node;\\n    int nxt = !!(value & (1 << i));\\n    node->ch[nxt] = insert(node->ch[nxt], value, i - 1);\\n    return node;\\n}\\n\\nint query(Node* node, int value, int i) {\\n    if(i == -1) return 0;\\n    int vv = !!(value & (1 << i));\\n    if(node->ch[!vv]) {\\n        return (1 << i) + query(node->ch[!vv], value, i - 1);\\n    } else {\\n        return query(node->ch[vv], value, i - 1);\\n    }\\n}\\n\\nclass Solution {\\n    int n_;\\n    vector<vector<int>> T;\\n    vector<Node*> tries;\\n    void dfs(int cur, Node* curTrie) {\\n        tries[cur] = insert(curTrie, cur, 18);\\n        for(auto y: T[cur]) {\\n            dfs(y, tries[cur]);\\n        }\\n    }\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        n_ = parents.size();\\n        T.resize(n_);\\n        tries.resize(n_);\\n        int root;\\n        for(int i = 0; i < n_; i++) {\\n            if(parents[i] == -1) {\\n                root = i;\\n            } else {\\n                T[parents[i]].push_back(i);\\n            }\\n        }\\n        dfs(root, nullptr);\\n        vector<int> ans;\\n        for(auto &v: queries) {\\n            ans.push_back(query(tries[v[0]], v[1], 18));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nExplanation: For each node in the original tree, we use a different trie, but instead of create a totally new trie, we can reuse parts of its parent trie, so for each tree node the space and time overhead is about O(log max val).\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Node {\\npublic:\\n    Node* ch[2];\\n    \\n    Node() {\\n        ch[0] = ch[1] = nullptr;\\n    }\\n};\\n\\nNode* insert(Node* node, int value, int i) {\\n    if(node == nullptr) {\\n        node = new Node();\\n    } else {\\n        node = new Node(*node);\\n    }\\n    if(i == -1) return node;\\n    int nxt = !!(value & (1 << i));\\n    node->ch[nxt] = insert(node->ch[nxt], value, i - 1);\\n    return node;\\n}\\n\\nint query(Node* node, int value, int i) {\\n    if(i == -1) return 0;\\n    int vv = !!(value & (1 << i));\\n    if(node->ch[!vv]) {\\n        return (1 << i) + query(node->ch[!vv], value, i - 1);\\n    } else {\\n        return query(node->ch[vv], value, i - 1);\\n    }\\n}\\n\\nclass Solution {\\n    int n_;\\n    vector<vector<int>> T;\\n    vector<Node*> tries;\\n    void dfs(int cur, Node* curTrie) {\\n        tries[cur] = insert(curTrie, cur, 18);\\n        for(auto y: T[cur]) {\\n            dfs(y, tries[cur]);\\n        }\\n    }\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        n_ = parents.size();\\n        T.resize(n_);\\n        tries.resize(n_);\\n        int root;\\n        for(int i = 0; i < n_; i++) {\\n            if(parents[i] == -1) {\\n                root = i;\\n            } else {\\n                T[parents[i]].push_back(i);\\n            }\\n        }\\n        dfs(root, nullptr);\\n        vector<int> ans;\\n        for(auto &v: queries) {\\n            ans.push_back(query(tries[v[0]], v[1], 18));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362964,
                "title": "java-solution-trie-dfs",
                "content": "```\\nclass Solution {\\n    class TrieNode{\\n        Map<Character, TrieNode> children;\\n        int num;\\n        TrieNode(){\\n            children = new HashMap<>();\\n            num = 0;\\n        }\\n    }\\n    int L;\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        L = Integer.toBinaryString(200000).length();\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for(int i = 0; i < parents.length; i++){\\n            if(!graph.containsKey(parents[i])){\\n                graph.put(parents[i], new HashSet<>());\\n            }\\n            graph.get(parents[i]).add(i);\\n        }\\n        \\n        Map<Integer, Set<Pair<Integer, Integer>>> q = new HashMap<>();\\n        for(int i = 0; i < queries.length; i++){\\n            if(!q.containsKey(queries[i][0])){\\n                q.put(queries[i][0], new HashSet<>());\\n            }\\n            q.get(queries[i][0]).add(new Pair<>(queries[i][1], i));\\n        }\\n        \\n        // construct trie\\n        TrieNode root = new TrieNode();\\n        int[] res = new int[queries.length];\\n        for(int x: graph.get(-1)){\\n            dfs(root, q, graph, res, x);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(TrieNode root, \\n                     Map<Integer, Set<Pair<Integer, Integer>>> q, \\n                     Map<Integer, Set<Integer>> graph,\\n                     int[] res,\\n                     int cur){\\n        \\n        add(root, cur);\\n        if(graph.containsKey(cur)){\\n            for(int child: graph.get(cur)){  \\n                dfs(root, q, graph, res, child);\\n            }\\n        }\\n\\n        if(q.containsKey(cur)){\\n            find(root, cur, q, res);\\n            \\n        }\\n        remove(root, cur);\\n    }\\n    \\n    private void find(TrieNode root, \\n                      int cur,\\n                      Map<Integer, Set<Pair<Integer, Integer>>> q, \\n                      int[] res){\\n        for(Pair<Integer, Integer> p: q.get(cur)){\\n            int val = p.getKey(), idx = p.getValue();\\n            String s = Integer.toBinaryString(val | (1 << L)).substring(1);\\n            \\n            TrieNode curNode = root;\\n            int max = 0;\\n            for(char c: s.toCharArray()){\\n                char opposite = c == \\'1\\' ? \\'0\\' : \\'1\\';\\n                if(curNode.children.containsKey(opposite)){\\n                    max = (max << 1) + 1;\\n                    curNode = curNode.children.get(opposite);\\n                }else if(curNode.children.containsKey(c)){\\n                    max = max << 1;\\n                    curNode = curNode.children.get(c);\\n                }else{\\n                    break;\\n                }\\n            }\\n            res[idx] = max;\\n        }\\n    }\\n    \\n    private void remove(TrieNode root, int cur){\\n        String s = Integer.toBinaryString(cur | (1 << L)).substring(1);\\n        TrieNode curNode = root;\\n        for(char c: s.toCharArray()){\\n            curNode.children.get(c).num--;\\n            if(curNode.children.get(c).num == 0){\\n                curNode.children.remove(c);\\n                break;\\n            }\\n            curNode = curNode.children.get(c);\\n        } \\n    }\\n    \\n    private void add(TrieNode root, int cur){\\n        String s = Integer.toBinaryString(cur | (1 << L)).substring(1);   \\n        TrieNode curNode = root;\\n        for(char c: s.toCharArray()){\\n            if(!curNode.children.containsKey(c)){\\n                curNode.children.put(c, new TrieNode());\\n            }\\n            curNode.children.get(c).num++;\\n            curNode = curNode.children.get(c);\\n        }      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class TrieNode{\\n        Map<Character, TrieNode> children;\\n        int num;\\n        TrieNode(){\\n            children = new HashMap<>();\\n            num = 0;\\n        }\\n    }\\n    int L;\\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        L = Integer.toBinaryString(200000).length();\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for(int i = 0; i < parents.length; i++){\\n            if(!graph.containsKey(parents[i])){\\n                graph.put(parents[i], new HashSet<>());\\n            }\\n            graph.get(parents[i]).add(i);\\n        }\\n        \\n        Map<Integer, Set<Pair<Integer, Integer>>> q = new HashMap<>();\\n        for(int i = 0; i < queries.length; i++){\\n            if(!q.containsKey(queries[i][0])){\\n                q.put(queries[i][0], new HashSet<>());\\n            }\\n            q.get(queries[i][0]).add(new Pair<>(queries[i][1], i));\\n        }\\n        \\n        // construct trie\\n        TrieNode root = new TrieNode();\\n        int[] res = new int[queries.length];\\n        for(int x: graph.get(-1)){\\n            dfs(root, q, graph, res, x);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(TrieNode root, \\n                     Map<Integer, Set<Pair<Integer, Integer>>> q, \\n                     Map<Integer, Set<Integer>> graph,\\n                     int[] res,\\n                     int cur){\\n        \\n        add(root, cur);\\n        if(graph.containsKey(cur)){\\n            for(int child: graph.get(cur)){  \\n                dfs(root, q, graph, res, child);\\n            }\\n        }\\n\\n        if(q.containsKey(cur)){\\n            find(root, cur, q, res);\\n            \\n        }\\n        remove(root, cur);\\n    }\\n    \\n    private void find(TrieNode root, \\n                      int cur,\\n                      Map<Integer, Set<Pair<Integer, Integer>>> q, \\n                      int[] res){\\n        for(Pair<Integer, Integer> p: q.get(cur)){\\n            int val = p.getKey(), idx = p.getValue();\\n            String s = Integer.toBinaryString(val | (1 << L)).substring(1);\\n            \\n            TrieNode curNode = root;\\n            int max = 0;\\n            for(char c: s.toCharArray()){\\n                char opposite = c == \\'1\\' ? \\'0\\' : \\'1\\';\\n                if(curNode.children.containsKey(opposite)){\\n                    max = (max << 1) + 1;\\n                    curNode = curNode.children.get(opposite);\\n                }else if(curNode.children.containsKey(c)){\\n                    max = max << 1;\\n                    curNode = curNode.children.get(c);\\n                }else{\\n                    break;\\n                }\\n            }\\n            res[idx] = max;\\n        }\\n    }\\n    \\n    private void remove(TrieNode root, int cur){\\n        String s = Integer.toBinaryString(cur | (1 << L)).substring(1);\\n        TrieNode curNode = root;\\n        for(char c: s.toCharArray()){\\n            curNode.children.get(c).num--;\\n            if(curNode.children.get(c).num == 0){\\n                curNode.children.remove(c);\\n                break;\\n            }\\n            curNode = curNode.children.get(c);\\n        } \\n    }\\n    \\n    private void add(TrieNode root, int cur){\\n        String s = Integer.toBinaryString(cur | (1 << L)).substring(1);   \\n        TrieNode curNode = root;\\n        for(char c: s.toCharArray()){\\n            if(!curNode.children.containsKey(c)){\\n                curNode.children.put(c, new TrieNode());\\n            }\\n            curNode.children.get(c).num++;\\n            curNode = curNode.children.get(c);\\n        }      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359217,
                "title": "rust-bitwise-trie-dfs-solution",
                "content": "Two key points: \\n\\n* use bitwise trie to reduce max XOR finding time to O(1), similar to: [Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)\\n* use backtracking to traverse the graph, updating the trie accordingly, resolve all queries related to certain node when reach it.\\n\\n```rust\\nuse std::collections::HashMap;\\n\\n/// https://en.wikipedia.org/wiki/Trie#Bitwise_tries\\n#[derive(Default, Debug)]\\nstruct Trie {\\n    left: Option<Box<Trie>>,\\n    right: Option<Box<Trie>>,\\n    ct: usize,\\n}\\n\\nimpl Trie {\\n    pub fn new() -> Trie {\\n        Default::default()\\n    }\\n\\n    pub fn insert(&mut self, num: i32) {\\n        let mut cur = self;\\n        for i in (0..18).rev() {\\n            if (num >> i) & 1 > 0 {\\n                if let Some(ref mut r) = cur.right {\\n                    cur = r;\\n                } else {\\n                    cur.right = Some(Box::new(Trie::new()));\\n                    cur = cur.right.as_mut().unwrap();\\n                }\\n                cur.ct += 1;\\n            } else {\\n                if let Some(ref mut l) = cur.left {\\n                    cur = l;\\n                } else {\\n                    cur.left = Some(Box::new(Trie::new()));\\n                    cur = cur.left.as_mut().unwrap();\\n                }\\n                cur.ct += 1;\\n            }\\n        }\\n    }\\n\\n    pub fn remove(&mut self, num: i32) {\\n        let mut cur = self;\\n        for i in (0..18).rev() {\\n            if (num >> i) & 1 > 0 {\\n                cur = cur.right.as_mut().unwrap();\\n                cur.ct -= 1;\\n            } else {\\n                cur = cur.left.as_mut().unwrap();\\n                cur.ct -= 1;\\n            }\\n        }\\n    }\\n\\n    pub fn max_xor(&self, num: i32) -> i32 {\\n        let mut cur = self;\\n        let mut ans = 0;\\n        for i in (0..18).rev() {\\n            ans = ans << 1;\\n            if (num >> i) & 1 > 0 {\\n                match cur.left {\\n                    Some(ref l) if l.ct > 0 => {\\n                        cur = l;\\n                        ans += 1;\\n                    }\\n                    _ => cur = cur.right.as_ref().unwrap(),\\n                }\\n            } else {\\n                match cur.right {\\n                    Some(ref r) if r.ct > 0 => {\\n                        cur = r;\\n                        ans += 1;\\n                    }\\n                    _ => cur = cur.left.as_ref().unwrap(),\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn max_genetic_difference(parents: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let n = parents.len();\\n        let mut root = 0;\\n        let mut adjacency_list = vec![vec![]; n];\\n        for (u, v) in parents.into_iter().enumerate() {\\n            if v == -1 {\\n                root = u as i32;\\n            } else {\\n                adjacency_list[v as usize].push(u);\\n            }\\n        }\\n        // HashMap<u, Vec<(q_val, q_idx)>>\\n        let grouped_queries = {\\n            let mut res = HashMap::new();\\n            for (idx, query) in queries.iter().enumerate() {\\n                let u = query[0];\\n                let p = query[1];\\n                res.entry(u).or_insert(vec![]).push((p, idx));\\n            }\\n            res\\n        };\\n        let mut ans = vec![0; queries.len()];\\n        let mut trie = Trie::new();\\n        Self::dfs(&adjacency_list, &grouped_queries, root, &mut trie, &mut ans);\\n        ans\\n    }\\n\\n    fn dfs(\\n        adjacency_list: &[Vec<usize>],\\n        queries: &HashMap<i32, Vec<(i32, usize)>>,\\n        cur: i32,\\n        trie: &mut Trie,\\n        ans: &mut Vec<i32>,\\n    ) {\\n        trie.insert(cur);\\n        if let Some(list) = queries.get(&cur) {\\n            for query in list {\\n                let q_val = query.0;\\n                let q_idx = query.1;\\n                ans[q_idx] = trie.max_xor(q_val);\\n            }\\n        }\\n        for &u in &adjacency_list[cur as usize] {\\n            Self::dfs(adjacency_list, queries, u as i32, trie, ans);\\n        }\\n        trie.remove(cur);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\n/// https://en.wikipedia.org/wiki/Trie#Bitwise_tries\\n#[derive(Default, Debug)]\\nstruct Trie {\\n    left: Option<Box<Trie>>,\\n    right: Option<Box<Trie>>,\\n    ct: usize,\\n}\\n\\nimpl Trie {\\n    pub fn new() -> Trie {\\n        Default::default()\\n    }\\n\\n    pub fn insert(&mut self, num: i32) {\\n        let mut cur = self;\\n        for i in (0..18).rev() {\\n            if (num >> i) & 1 > 0 {\\n                if let Some(ref mut r) = cur.right {\\n                    cur = r;\\n                } else {\\n                    cur.right = Some(Box::new(Trie::new()));\\n                    cur = cur.right.as_mut().unwrap();\\n                }\\n                cur.ct += 1;\\n            } else {\\n                if let Some(ref mut l) = cur.left {\\n                    cur = l;\\n                } else {\\n                    cur.left = Some(Box::new(Trie::new()));\\n                    cur = cur.left.as_mut().unwrap();\\n                }\\n                cur.ct += 1;\\n            }\\n        }\\n    }\\n\\n    pub fn remove(&mut self, num: i32) {\\n        let mut cur = self;\\n        for i in (0..18).rev() {\\n            if (num >> i) & 1 > 0 {\\n                cur = cur.right.as_mut().unwrap();\\n                cur.ct -= 1;\\n            } else {\\n                cur = cur.left.as_mut().unwrap();\\n                cur.ct -= 1;\\n            }\\n        }\\n    }\\n\\n    pub fn max_xor(&self, num: i32) -> i32 {\\n        let mut cur = self;\\n        let mut ans = 0;\\n        for i in (0..18).rev() {\\n            ans = ans << 1;\\n            if (num >> i) & 1 > 0 {\\n                match cur.left {\\n                    Some(ref l) if l.ct > 0 => {\\n                        cur = l;\\n                        ans += 1;\\n                    }\\n                    _ => cur = cur.right.as_ref().unwrap(),\\n                }\\n            } else {\\n                match cur.right {\\n                    Some(ref r) if r.ct > 0 => {\\n                        cur = r;\\n                        ans += 1;\\n                    }\\n                    _ => cur = cur.left.as_ref().unwrap(),\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn max_genetic_difference(parents: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let n = parents.len();\\n        let mut root = 0;\\n        let mut adjacency_list = vec![vec![]; n];\\n        for (u, v) in parents.into_iter().enumerate() {\\n            if v == -1 {\\n                root = u as i32;\\n            } else {\\n                adjacency_list[v as usize].push(u);\\n            }\\n        }\\n        // HashMap<u, Vec<(q_val, q_idx)>>\\n        let grouped_queries = {\\n            let mut res = HashMap::new();\\n            for (idx, query) in queries.iter().enumerate() {\\n                let u = query[0];\\n                let p = query[1];\\n                res.entry(u).or_insert(vec![]).push((p, idx));\\n            }\\n            res\\n        };\\n        let mut ans = vec![0; queries.len()];\\n        let mut trie = Trie::new();\\n        Self::dfs(&adjacency_list, &grouped_queries, root, &mut trie, &mut ans);\\n        ans\\n    }\\n\\n    fn dfs(\\n        adjacency_list: &[Vec<usize>],\\n        queries: &HashMap<i32, Vec<(i32, usize)>>,\\n        cur: i32,\\n        trie: &mut Trie,\\n        ans: &mut Vec<i32>,\\n    ) {\\n        trie.insert(cur);\\n        if let Some(list) = queries.get(&cur) {\\n            for query in list {\\n                let q_val = query.0;\\n                let q_idx = query.1;\\n                ans[q_idx] = trie.max_xor(q_val);\\n            }\\n        }\\n        for &u in &adjacency_list[cur as usize] {\\n            Self::dfs(adjacency_list, queries, u as i32, trie, ans);\\n        }\\n        trie.remove(cur);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1349900,
                "title": "help-can-anyone-tell-why-this-doesn-t-work-isn-t-it-o-q-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        vector<int> ans;\\n        \\n        for(int i = 0; i < q; i++){\\n            int val = queries[i][1];\\n            int node = queries[i][0];\\n            \\n            \\n                int maxx = val ^ node;\\n                \\n                while(parents[node]!=-1){\\n                    node = parents[node];\\n                     maxx = max(val ^ node, maxx);\\n                    \\n                }\\n                \\n                ans.push_back(maxx);\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        vector<int> ans;\\n        \\n        for(int i = 0; i < q; i++){\\n            int val = queries[i][1];\\n            int node = queries[i][0];\\n            \\n            \\n                int maxx = val ^ node;\\n                \\n                while(parents[node]!=-1){\\n                    node = parents[node];\\n                     maxx = max(val ^ node, maxx);\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1348314,
                "title": "easy-tle-prevention-tricks-in-trie-with-add-remove-searchmax-dfs",
                "content": "DFS will always visit the path to that node, so lets insert into trie while doing DFS and then execute all the queries for current node\\n\\nbefore returning upward, remove the current node from trie\\n\\n\\nHere is a simple optimal code but it will TLE so below I have attached a more optimal version :)\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.root = dict()\\n        # store pointer to next, and frequency in \\'f\\'\\n        \\n    def add(self, x):\\n        # print(\\'add\\',x)\\n        cur = self.root\\n        for pwr in range(18,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 if mask & x else 0\\n            if bit not in cur:\\n                cur[bit] = dict()\\n            \\n            cur = cur[bit]\\n            cur[\\'f\\'] = cur.get(\\'f\\',0) + 1 # increase the frequency :)\\n        \\n        cur[\\'val\\'] = x\\n        \\n    def remove(self, x):\\n        # print(\\'rem\\',x)\\n        cur = self.root\\n        for pwr in range(18,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 if mask & x else 0\\n            cur = cur[bit]\\n            cur[\\'f\\'] = cur.get(\\'f\\',0) - 1 # increase the frequency :)\\n        \\n        cur[\\'val\\'] = x\\n        \\n    def search(self, x):\\n        cur = self.root\\n        res = 0\\n        for pwr in range(18,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 - (1 if mask & x else 0) # searching for opposite\\n            \\n            if bit not in cur or cur[bit][\\'f\\'] == 0:\\n                # cannot find opposite..\\n                cur = cur[1-bit]\\n            else:\\n                cur = cur[bit]\\n        # print(\\'max\\', x,\\'->\\',cur[\\'val\\'])\\n        return cur[\\'val\\'] ^ x\\n    \\nclass Solution:\\n    def getAdj(self, parents):\\n        adj = defaultdict(list)\\n        for i, p in enumerate(parents):\\n            adj[p].append(i)\\n        return adj\\n    \\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        # every node should have a set of all parents i.e. it\\'s `path`\\n        # inside a trie, so it is a \\'DFS\\' which will have the entire path\\n        # and while going backtrack in DFS we pop from trie..\\n        root = [i for i,v in enumerate(parents) if v == -1][0]\\n        adj = self.getAdj(parents) # pointers to the kids \\n        \\n        trie = Trie()\\n\\n        ans = [0]*len(queries)        \\n        queryForNode = defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            queryForNode[node].append((val,i))\\n        \\n        def dfs(node):\\n            nonlocal queryForNode, trie, ans\\n            # at current node, trie contains everyone in my path :)\\n            trie.add(node)\\n            \\n            \\n            for val,idx in queryForNode[node]:\\n                ans[idx] = trie.search(val)\\n            \\n            for kid in adj[node]:\\n                dfs(kid)\\n            \\n            # now backtrack..\\n            trie.remove(node)\\n            \\n        dfs(root)\\n        return ans\\n```\\nInstead of dictionary need to use array and also\\nBecause of linked list style test case, when we reach the last leaf -> all ans[] are computed but still we go upwards removing all nodes one by one ->  I observed that if we dont \\'remove\\' from trie after all answers are found we can pass with 50% time in python \\n\\n```\\nclass Trie: \\n    # dict() will TLE\\n    # [kid0, kid1, freq, val] # this is the structure of Trie\\n    def __init__(self):\\n        self.root = [False, False, 0, False]\\n        # store pointer to next, and frequency in \\'f\\'\\n        \\n    def add(self, x):\\n        # print(\\'add\\',x)\\n        cur = self.root\\n        for pwr in range(17,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 if mask & x else 0\\n            if not cur[bit]:\\n                cur[bit] = [False, False, 0, False]\\n            \\n            cur = cur[bit]\\n            cur[2] += 1 # increase the frequency :)\\n        \\n        cur[3] = x\\n        \\n    def remove(self, x):\\n        # print(\\'rem\\',x)\\n        cur = self.root\\n        for pwr in range(17,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 if mask & x else 0\\n            cur = cur[bit]\\n            cur[2] -= 1 # increase the frequency :)\\n        \\n        \\n    def search(self, x):\\n        cur = self.root\\n        res = 0\\n        for pwr in range(17,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 - (1 if mask & x else 0) # searching for opposite\\n            \\n            if not cur[bit] or cur[bit][2] == 0:\\n                # cannot find opposite..\\n                cur = cur[1-bit]\\n            else:\\n                cur = cur[bit]\\n        # print(\\'max\\', x,\\'->\\',cur[\\'val\\'])\\n        return cur[3] ^ x\\n    \\nclass Solution:\\n    def getAdj(self, parents):\\n        adj = defaultdict(list)\\n        for i, p in enumerate(parents):\\n            adj[p].append(i)\\n        return adj\\n    \\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        # every node should have a set of all parents i.e. it\\'s `path`\\n        # inside a trie, so it is a \\'DFS\\' which will have the entire path\\n        # and while going backtrack in DFS we pop from trie..\\n        root = [i for i,v in enumerate(parents) if v == -1][0]\\n        adj = self.getAdj(parents) # pointers to the kids \\n        \\n        trie = Trie()\\n\\n        ans = [0]*len(queries)        \\n        queryForNode = defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            queryForNode[node].append((val,i))\\n        \\n        self.seen = 0\\n        \\n        def dfs(node):\\n            nonlocal queryForNode, trie, ans\\n            # at current node, trie contains everyone in my path :)\\n            trie.add(node)\\n            \\n            \\n            for val,idx in queryForNode[node]:\\n                ans[idx] = trie.search(val)\\n                self.seen += 1\\n                \\n            for kid in adj[node]:\\n                dfs(kid)\\n            \\n            # now backtrack..\\n            if self.seen < len(ans): # TLE without this\\n                trie.remove(node)\\n            \\n        dfs(root)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.root = dict()\\n        # store pointer to next, and frequency in \\'f\\'\\n        \\n    def add(self, x):\\n        # print(\\'add\\',x)\\n        cur = self.root\\n        for pwr in range(18,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 if mask & x else 0\\n            if bit not in cur:\\n                cur[bit] = dict()\\n            \\n            cur = cur[bit]\\n            cur[\\'f\\'] = cur.get(\\'f\\',0) + 1 # increase the frequency :)\\n        \\n        cur[\\'val\\'] = x\\n        \\n    def remove(self, x):\\n        # print(\\'rem\\',x)\\n        cur = self.root\\n        for pwr in range(18,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 if mask & x else 0\\n            cur = cur[bit]\\n            cur[\\'f\\'] = cur.get(\\'f\\',0) - 1 # increase the frequency :)\\n        \\n        cur[\\'val\\'] = x\\n        \\n    def search(self, x):\\n        cur = self.root\\n        res = 0\\n        for pwr in range(18,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 - (1 if mask & x else 0) # searching for opposite\\n            \\n            if bit not in cur or cur[bit][\\'f\\'] == 0:\\n                # cannot find opposite..\\n                cur = cur[1-bit]\\n            else:\\n                cur = cur[bit]\\n        # print(\\'max\\', x,\\'->\\',cur[\\'val\\'])\\n        return cur[\\'val\\'] ^ x\\n    \\nclass Solution:\\n    def getAdj(self, parents):\\n        adj = defaultdict(list)\\n        for i, p in enumerate(parents):\\n            adj[p].append(i)\\n        return adj\\n    \\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        # every node should have a set of all parents i.e. it\\'s `path`\\n        # inside a trie, so it is a \\'DFS\\' which will have the entire path\\n        # and while going backtrack in DFS we pop from trie..\\n        root = [i for i,v in enumerate(parents) if v == -1][0]\\n        adj = self.getAdj(parents) # pointers to the kids \\n        \\n        trie = Trie()\\n\\n        ans = [0]*len(queries)        \\n        queryForNode = defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            queryForNode[node].append((val,i))\\n        \\n        def dfs(node):\\n            nonlocal queryForNode, trie, ans\\n            # at current node, trie contains everyone in my path :)\\n            trie.add(node)\\n            \\n            \\n            for val,idx in queryForNode[node]:\\n                ans[idx] = trie.search(val)\\n            \\n            for kid in adj[node]:\\n                dfs(kid)\\n            \\n            # now backtrack..\\n            trie.remove(node)\\n            \\n        dfs(root)\\n        return ans\\n```\n```\\nclass Trie: \\n    # dict() will TLE\\n    # [kid0, kid1, freq, val] # this is the structure of Trie\\n    def __init__(self):\\n        self.root = [False, False, 0, False]\\n        # store pointer to next, and frequency in \\'f\\'\\n        \\n    def add(self, x):\\n        # print(\\'add\\',x)\\n        cur = self.root\\n        for pwr in range(17,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 if mask & x else 0\\n            if not cur[bit]:\\n                cur[bit] = [False, False, 0, False]\\n            \\n            cur = cur[bit]\\n            cur[2] += 1 # increase the frequency :)\\n        \\n        cur[3] = x\\n        \\n    def remove(self, x):\\n        # print(\\'rem\\',x)\\n        cur = self.root\\n        for pwr in range(17,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 if mask & x else 0\\n            cur = cur[bit]\\n            cur[2] -= 1 # increase the frequency :)\\n        \\n        \\n    def search(self, x):\\n        cur = self.root\\n        res = 0\\n        for pwr in range(17,-1,-1):\\n            mask = 2**pwr # mask = 1<<pwr\\n            bit = 1 - (1 if mask & x else 0) # searching for opposite\\n            \\n            if not cur[bit] or cur[bit][2] == 0:\\n                # cannot find opposite..\\n                cur = cur[1-bit]\\n            else:\\n                cur = cur[bit]\\n        # print(\\'max\\', x,\\'->\\',cur[\\'val\\'])\\n        return cur[3] ^ x\\n    \\nclass Solution:\\n    def getAdj(self, parents):\\n        adj = defaultdict(list)\\n        for i, p in enumerate(parents):\\n            adj[p].append(i)\\n        return adj\\n    \\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        # every node should have a set of all parents i.e. it\\'s `path`\\n        # inside a trie, so it is a \\'DFS\\' which will have the entire path\\n        # and while going backtrack in DFS we pop from trie..\\n        root = [i for i,v in enumerate(parents) if v == -1][0]\\n        adj = self.getAdj(parents) # pointers to the kids \\n        \\n        trie = Trie()\\n\\n        ans = [0]*len(queries)        \\n        queryForNode = defaultdict(list)\\n        for i, (node, val) in enumerate(queries):\\n            queryForNode[node].append((val,i))\\n        \\n        self.seen = 0\\n        \\n        def dfs(node):\\n            nonlocal queryForNode, trie, ans\\n            # at current node, trie contains everyone in my path :)\\n            trie.add(node)\\n            \\n            \\n            for val,idx in queryForNode[node]:\\n                ans[idx] = trie.search(val)\\n                self.seen += 1\\n                \\n            for kid in adj[node]:\\n                dfs(kid)\\n            \\n            # now backtrack..\\n            if self.seen < len(ans): # TLE without this\\n                trie.remove(node)\\n            \\n        dfs(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347990,
                "title": "c-help-can-someone-explain-why-this-doesn-t-pass",
                "content": "Maximum Genetic Difference Query\\nSubmission Detail\\n58 / 58 test cases passed, but took too long\\n\\n```\\nclass Solution {\\npublic:\\n    int numbits=17;\\n    vector<vector<int>>adjmat;\\n    vector<map<int,int>>qmat;\\n    vector<unordered_map<int,int>>mat;\\n    \\n    void dfs(int root)\\n    {\\n        for(int i=0;i<=numbits;i++)\\n        {\\n            auto t=root;\\n            t=(t>>i);\\n            t=(t<<i);\\n            if(mat[i].find(t)==mat[i].end())\\n                mat[i][t]=root;\\n            else\\n                break;\\n        }\\n        for(auto q:qmat[root])\\n        {\\n            auto val=q.first; \\n            // auto res=q.second;\\n            int mask=0;\\n            int res=0;\\n            for(int i=numbits;i>=0;i--)\\n            {\\n                if((val&(1<<i))!=0)\\n                {\\n                    if(mat[i].find(mask)==mat[i].end())\\n                    {\\n                        mask=mask|(1<<i);\\n                    }\\n                    else\\n                        res=res|(1<<i);\\n                }\\n                else\\n                {\\n                    auto temp=mask|(1<<i);\\n                    if(mat[i].find(temp)!=mat[i].end())\\n                    {\\n                        mask=temp;\\n                        res=res|(1<<i);\\n                    }\\n                }\\n            }\\n            qmat[root][val]=res;\\n        }\\n        for(auto x:adjmat[root])\\n        {\\n            dfs(x);\\n        }\\n        for(int i=0;i<=numbits;i++)\\n        {\\n            auto t=root;\\n            t=(t>>i);\\n            t=(t<<i);\\n            if(mat[i].find(t)!=mat[i].end())\\n            {\\n                if(mat[i][t]==root)\\n                    mat[i].erase(t);\\n            }\\n            else\\n                break;\\n        }\\n    }\\n    \\n    \\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n=parents.size();\\n        int root;\\n        adjmat.resize(n);\\n        qmat.resize(n);\\n        mat.resize(numbits+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(parents[i]==-1)\\n                root=i;\\n            else\\n            {\\n                adjmat[parents[i]].push_back(i);\\n            }\\n        }\\n        for(auto x:queries)\\n        {\\n            qmat[x[0]][x[1]]=x[1]^root;\\n        }\\n        dfs(root);\\n        vector<int>res;\\n        for(auto x:queries)\\n        {\\n            res.push_back(qmat[x[0]][x[1]]);\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numbits=17;\\n    vector<vector<int>>adjmat;\\n    vector<map<int,int>>qmat;\\n    vector<unordered_map<int,int>>mat;\\n    \\n    void dfs(int root)\\n    {\\n        for(int i=0;i<=numbits;i++)\\n        {\\n            auto t=root;\\n            t=(t>>i);\\n            t=(t<<i);\\n            if(mat[i].find(t)==mat[i].end())\\n                mat[i][t]=root;\\n            else\\n                break;\\n        }\\n        for(auto q:qmat[root])\\n        {\\n            auto val=q.first; \\n            // auto res=q.second;\\n            int mask=0;\\n            int res=0;\\n            for(int i=numbits;i>=0;i--)\\n            {\\n                if((val&(1<<i))!=0)\\n                {\\n                    if(mat[i].find(mask)==mat[i].end())\\n                    {\\n                        mask=mask|(1<<i);\\n                    }\\n                    else\\n                        res=res|(1<<i);\\n                }\\n                else\\n                {\\n                    auto temp=mask|(1<<i);\\n                    if(mat[i].find(temp)!=mat[i].end())\\n                    {\\n                        mask=temp;\\n                        res=res|(1<<i);\\n                    }\\n                }\\n            }\\n            qmat[root][val]=res;\\n        }\\n        for(auto x:adjmat[root])\\n        {\\n            dfs(x);\\n        }\\n        for(int i=0;i<=numbits;i++)\\n        {\\n            auto t=root;\\n            t=(t>>i);\\n            t=(t<<i);\\n            if(mat[i].find(t)!=mat[i].end())\\n            {\\n                if(mat[i][t]==root)\\n                    mat[i].erase(t);\\n            }\\n            else\\n                break;\\n        }\\n    }\\n    \\n    \\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n=parents.size();\\n        int root;\\n        adjmat.resize(n);\\n        qmat.resize(n);\\n        mat.resize(numbits+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(parents[i]==-1)\\n                root=i;\\n            else\\n            {\\n                adjmat[parents[i]].push_back(i);\\n            }\\n        }\\n        for(auto x:queries)\\n        {\\n            qmat[x[0]][x[1]]=x[1]^root;\\n        }\\n        dfs(root);\\n        vector<int>res;\\n        for(auto x:queries)\\n        {\\n            res.push_back(qmat[x[0]][x[1]]);\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347530,
                "title": "c-dfs-topologicalsort-trie-o-nlog-n-o-qlogq-w-explanation",
                "content": "For the maximum XOR query, we use a Trie. I\\'ll tell you about it\\'s implementation later. \\n\\nSo, the idea is that when we are searching for resultant value for a particular node, we only need it\\'s ancestor values in the trie. If we use brute-force, it will be ```O(NQ)```, which won\\'t pass the bigger test cases. So we need it to do in one-pass. So if we have queried a node\\'s parent previously, then for this particular query, we need to add only node in the trie if we are coming from the parent node\\'s query. There comes  the Topological Sort. I assigned a priority to the nodes in the order their DFS traversal worked. Then sorted the queries based on that priority. So after a node is queried, we travel to all the queries which are descendants of the current node. After we have traversed all of it\\'s descendants, we remove a node from the trie.\\n\\nNow, to the trie part. We store the binary representation of numbers in the Trie like strings. For a particular bit, for the XOR value to be ```1```, the XOR-ed numbers should have opposite values for this bit position. If there are no numbers which satisfy this property, we go for XOR value to be ```0```. Since we can do this ```O(logN)``` time instead of ```O(N)``` we use trie. I used the same insert function for both insertion and removal. For that I maintained a count in each node, which gives the count of numbers which have the current bit as ```1```. So, while removing, we simply reduce the count of each set bit in this node\\'s value by ```1```. While searching, we look if the node is not ```NULL``` and it has a ```count >0```.\\n\\nComplexity Analysis:\\nThe DFS each takes ```O(N)``` time only. But for searching a particular value, it will take ```O(logN)``` time. So the second DFS  takes ```O(NlogN)```. Since we are sorting the queries, it\\'ll take ```O(QlogQ)``` time.\\n```\\nint priority[100000];\\n#define maxbit 18\\nclass Trie\\n{\\n    Trie *children[2];\\n    int count;\\npublic:\\n    Trie()\\n    {\\n        children[0]=children[1]=NULL;\\n        count=0;\\n    }\\n    void insert(int val,int c)\\n    {\\n        Trie* temp=this;\\n        for(int i=maxbit;i>=0;--i)\\n        {\\n            int j=1<<i;\\n            int bit=(val&j)>0;\\n            if(temp->children[bit]==NULL)\\n                temp->children[bit]=new Trie();\\n            temp=temp->children[bit];\\n            temp->count+=c;\\n        }\\n    }\\n    int search(int val)\\n    {\\n        Trie* temp=this;\\n        int ret=0;\\n        for(int i=maxbit;i>=0;--i)\\n        {\\n            int j=1<<i;\\n            int bit=(val&j)>0;\\n            if(temp->children[!bit]&&temp->children[!bit]->count)\\n            {\\n                ret|=j;\\n                temp=temp->children[!bit];\\n            }\\n            else if(temp->children[bit]&&temp->children[bit]->count)\\n                temp=temp->children[bit];\\n            else return 0;\\n        }\\n        return ret;\\n    }\\n};\\nclass Solution\\n{\\npublic:\\n    int count=0;\\n    Trie* root;\\n    void topologicalSort(int u,vector<vector<int>>& adj,int parent)\\n    {\\n        priority[u]=count++;\\n        for(int v:adj[u])\\n            if(v!=parent)\\n                topologicalSort(v,adj,u);\\n    }\\n    struct fun\\n    {\\n        bool operator()(vector<int>& a,vector<int>& b)\\n        {\\n            return priority[a[0]]<priority[b[0]];\\n        }\\n    };\\n    void dfs(int u,vector<vector<int>>& adj,int& j,vector<int>& ret,vector<vector<int>>& queries,int parent)\\n    {\\n        root->insert(u,1);\\n        while(j<queries.size()&&u==queries[j][0])\\n        {\\n            ret[queries[j][2]]=root->search(queries[j][1]);\\n            j++;\\n        }\\n        for(int v:adj[u])\\n            if(v!=parent)\\n                dfs(v,adj,j,ret,queries,u);\\n        root->insert(u,-1);\\n        \\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries)\\n    {\\n        int n=parents.size();\\n        vector<vector<int>> adj(n);\\n        int u=-1;\\n        for(int i=0;i<parents.size();++i)\\n        {\\n            if(parents[i]==-1)\\n                u=i;\\n            else adj[parents[i]].push_back(i);\\n        }\\n        topologicalSort(u,adj,-1);\\n        for(int i=0;i<queries.size();++i)\\n            queries[i].push_back(i);\\n        sort(queries.begin(),queries.end(),fun());\\n        vector<int> ret(queries.size());\\n        root=new Trie();\\n        int j=0;\\n        dfs(u,adj,j,ret,queries,-1);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Topological Sort",
                    "Trie"
                ],
                "code": "```O(NQ)```\n```1```\n```0```\n```O(logN)```\n```O(N)```\n```1```\n```1```\n```NULL```\n```count >0```\n```O(N)```\n```O(logN)```\n```O(NlogN)```\n```O(QlogQ)```\n```\\nint priority[100000];\\n#define maxbit 18\\nclass Trie\\n{\\n    Trie *children[2];\\n    int count;\\npublic:\\n    Trie()\\n    {\\n        children[0]=children[1]=NULL;\\n        count=0;\\n    }\\n    void insert(int val,int c)\\n    {\\n        Trie* temp=this;\\n        for(int i=maxbit;i>=0;--i)\\n        {\\n            int j=1<<i;\\n            int bit=(val&j)>0;\\n            if(temp->children[bit]==NULL)\\n                temp->children[bit]=new Trie();\\n            temp=temp->children[bit];\\n            temp->count+=c;\\n        }\\n    }\\n    int search(int val)\\n    {\\n        Trie* temp=this;\\n        int ret=0;\\n        for(int i=maxbit;i>=0;--i)\\n        {\\n            int j=1<<i;\\n            int bit=(val&j)>0;\\n            if(temp->children[!bit]&&temp->children[!bit]->count)\\n            {\\n                ret|=j;\\n                temp=temp->children[!bit];\\n            }\\n            else if(temp->children[bit]&&temp->children[bit]->count)\\n                temp=temp->children[bit];\\n            else return 0;\\n        }\\n        return ret;\\n    }\\n};\\nclass Solution\\n{\\npublic:\\n    int count=0;\\n    Trie* root;\\n    void topologicalSort(int u,vector<vector<int>>& adj,int parent)\\n    {\\n        priority[u]=count++;\\n        for(int v:adj[u])\\n            if(v!=parent)\\n                topologicalSort(v,adj,u);\\n    }\\n    struct fun\\n    {\\n        bool operator()(vector<int>& a,vector<int>& b)\\n        {\\n            return priority[a[0]]<priority[b[0]];\\n        }\\n    };\\n    void dfs(int u,vector<vector<int>>& adj,int& j,vector<int>& ret,vector<vector<int>>& queries,int parent)\\n    {\\n        root->insert(u,1);\\n        while(j<queries.size()&&u==queries[j][0])\\n        {\\n            ret[queries[j][2]]=root->search(queries[j][1]);\\n            j++;\\n        }\\n        for(int v:adj[u])\\n            if(v!=parent)\\n                dfs(v,adj,j,ret,queries,u);\\n        root->insert(u,-1);\\n        \\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries)\\n    {\\n        int n=parents.size();\\n        vector<vector<int>> adj(n);\\n        int u=-1;\\n        for(int i=0;i<parents.size();++i)\\n        {\\n            if(parents[i]==-1)\\n                u=i;\\n            else adj[parents[i]].push_back(i);\\n        }\\n        topologicalSort(u,adj,-1);\\n        for(int i=0;i<queries.size();++i)\\n            queries[i].push_back(i);\\n        sort(queries.begin(),queries.end(),fun());\\n        vector<int> ret(queries.size());\\n        root=new Trie();\\n        int j=0;\\n        dfs(u,adj,j,ret,queries,-1);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346945,
                "title": "javascript-trie-solution",
                "content": "In contest, I struggled with the third question, no time to take look at this question.\\n\\nAs my understand, in a given set of number, find max a number xor/and/or with this set of number. These kind of questions we can use Trie to solve it, and TrieNode only have two children, one is 0, the other is 1, which means ith bit is 0 or 1 for every number.\\n\\nIn this question, if we calculate all query in the origianl given order, it will be TLE, becuase we travese tree lots of times(at most query.length times). So we change the query order to follow the tree traverse order, then in our result, we assemble our result follow the query array.\\n\\nUsing DFS to traverse the tree, start from root. \\nUsing Trie to save current path from root to treenode all values. access the treenode , add its value to trie, leave the treenode then delete value from trie. In trie.count to count how many available nodes are ith bit is 0 or 1. In findMax method, we tried to find ith bit as different as possible.\\ntotal running time is 2000ms+, not very fast. I am not sure it is because JavaScript is slow, or my implementation is not good enough.\\n\\n<pre>\\nvar maxGeneticDifference = function(parents, queries) {\\n    var queryMap = new Map(); // key\\uFF1A node\\uFF0C value\\uFF1A [index, val]\\n    for (var i = 0; i < queries.length; i++) {\\n        if (!queryMap.has(queries[i][0])) {\\n            queryMap.set(queries[i][0], []);\\n        }\\n        queryMap.get(queries[i][0]).push([i, queries[i][1]]);\\n    }\\n    var parentMap = new Map(); // key father value, value set of children(1 or 2)\\n    var root;\\n    for (var i = 0; i < parents.length; i++) {\\n        if (parents[i] === -1) {\\n            root = i;\\n        }\\n        if (!parentMap.has(parents[i])) {\\n            parentMap.set(parents[i], new Set());\\n        }\\n        parentMap.get(parents[i]).add(i);\\n    }\\n\\n    var result = new Array(queries.length);\\n    var trie = new Trie();\\n    function traverseTree(parentMap, root, queryMap) {\\n        trie.add(root);\\n        if (queryMap.has(root)) {\\n            var arr = queryMap.get(root);\\n            for (var i = 0; i < arr.length; i++) {\\n                var max = trie.findMax(arr[i][1]);\\n                result[arr[i][0]] = max;\\n            }\\n        }\\n        if (parentMap.has(root)) {\\n            var children = parentMap.get(root);\\n            for (var child of children) {\\n                traverseTree(parentMap, child, queryMap);\\n            }\\n        }\\n        trie.remove(root);\\n    }\\n    traverseTree(parentMap, root, queryMap);\\n    return result;\\n};\\n\\nfunction TrieNode() {\\n    this.count = 0; // how many node in this path\\n    this.children = new Array(2).fill(null);\\n}\\n\\nfunction Trie() {\\n    this.root = new TrieNode();\\n}\\n\\nTrie.prototype.add = function(val) {\\n    var curt = this.root;\\n    for (var i = 18; i >= 0; i--) {\\n        if (val >= (1 << i)) {\\n            val -= (1 << i);\\n            if (curt.children[1] === null) {\\n                curt.children[1] = new TrieNode();\\n            }\\n            curt.children[1].count++;\\n            curt = curt.children[1];\\n        } else {\\n            if (curt.children[0] === null) {\\n                curt.children[0] = new TrieNode();\\n            }\\n            curt.children[0].count++;\\n            curt = curt.children[0];\\n        }\\n    }\\n}\\n\\nTrie.prototype.remove = function(val) {\\n    var curt = this.root;\\n    for (var i = 18; i >= 0; i--) {\\n        if (val >= (1 << i)) {\\n            val -= (1 << i);\\n            curt.children[1].count--;\\n            curt = curt.children[1];\\n        } else {\\n            curt.children[0].count--;\\n            curt = curt.children[0];\\n        }\\n    }\\n}\\n\\nTrie.prototype.findMax = function(val) {\\n    var curt = this.root;\\n    var maxDiff = 0;\\n    for (var i = 18; i >= 0; i--) {\\n        if ((val & (1 << i)) > 0) { // if val ith bit is 1\\n            if (curt.children[0] !== null && curt.children[0].count > 0) {\\n                curt = curt.children[0];\\n                maxDiff += (1 << i);\\n            } else {\\n                curt = curt.children[1];\\n            }\\n        } else { // val ith bit is 0\\n            if (curt.children[1] !== null && curt.children[1].count > 0) {\\n                curt = curt.children[1];\\n                maxDiff += (1 << i);\\n            } else {\\n                curt = curt.children[0];\\n            }\\n        }\\n    }\\n    return maxDiff;\\n}",
                "solutionTags": [],
                "code": "In contest, I struggled with the third question, no time to take look at this question.\\n\\nAs my understand, in a given set of number, find max a number xor/and/or with this set of number. These kind of questions we can use Trie to solve it, and TrieNode only have two children, one is 0, the other is 1, which means ith bit is 0 or 1 for every number.\\n\\nIn this question, if we calculate all query in the origianl given order, it will be TLE, becuase we travese tree lots of times(at most query.length times). So we change the query order to follow the tree traverse order, then in our result, we assemble our result follow the query array.\\n\\nUsing DFS to traverse the tree, start from root. \\nUsing Trie to save current path from root to treenode all values. access the treenode , add its value to trie, leave the treenode then delete value from trie. In trie.count to count how many available nodes are ith bit is 0 or 1. In findMax method, we tried to find ith bit as different as possible.\\ntotal running time is 2000ms+, not very fast. I am not sure it is because JavaScript is slow, or my implementation is not good enough.\\n\\n<pre>\\nvar maxGeneticDifference = function(parents, queries) {\\n    var queryMap = new Map(); // key\\uFF1A node\\uFF0C value\\uFF1A [index, val]\\n    for (var i = 0; i < queries.length; i++) {\\n        if (!queryMap.has(queries[i][0])) {\\n            queryMap.set(queries[i][0], []);\\n        }\\n        queryMap.get(queries[i][0]).push([i, queries[i][1]]);\\n    }\\n    var parentMap = new Map(); // key father value, value set of children(1 or 2)\\n    var root;\\n    for (var i = 0; i < parents.length; i++) {\\n        if (parents[i] === -1) {\\n            root = i;\\n        }\\n        if (!parentMap.has(parents[i])) {\\n            parentMap.set(parents[i], new Set());\\n        }\\n        parentMap.get(parents[i]).add(i);\\n    }\\n\\n    var result = new Array(queries.length);\\n    var trie = new Trie();\\n    function traverseTree(parentMap, root, queryMap) {\\n        trie.add(root);\\n        if (queryMap.has(root)) {\\n            var arr = queryMap.get(root);\\n            for (var i = 0; i < arr.length; i++) {\\n                var max = trie.findMax(arr[i][1]);\\n                result[arr[i][0]] = max;\\n            }\\n        }\\n        if (parentMap.has(root)) {\\n            var children = parentMap.get(root);\\n            for (var child of children) {\\n                traverseTree(parentMap, child, queryMap);\\n            }\\n        }\\n        trie.remove(root);\\n    }\\n    traverseTree(parentMap, root, queryMap);\\n    return result;\\n};\\n\\nfunction TrieNode() {\\n    this.count = 0; // how many node in this path\\n    this.children = new Array(2).fill(null);\\n}\\n\\nfunction Trie() {\\n    this.root = new TrieNode();\\n}\\n\\nTrie.prototype.add = function(val) {\\n    var curt = this.root;\\n    for (var i = 18; i >= 0; i--) {\\n        if (val >= (1 << i)) {\\n            val -= (1 << i);\\n            if (curt.children[1] === null) {\\n                curt.children[1] = new TrieNode();\\n            }\\n            curt.children[1].count++;\\n            curt = curt.children[1];\\n        } else {\\n            if (curt.children[0] === null) {\\n                curt.children[0] = new TrieNode();\\n            }\\n            curt.children[0].count++;\\n            curt = curt.children[0];\\n        }\\n    }\\n}\\n\\nTrie.prototype.remove = function(val) {\\n    var curt = this.root;\\n    for (var i = 18; i >= 0; i--) {\\n        if (val >= (1 << i)) {\\n            val -= (1 << i);\\n            curt.children[1].count--;\\n            curt = curt.children[1];\\n        } else {\\n            curt.children[0].count--;\\n            curt = curt.children[0];\\n        }\\n    }\\n}\\n\\nTrie.prototype.findMax = function(val) {\\n    var curt = this.root;\\n    var maxDiff = 0;\\n    for (var i = 18; i >= 0; i--) {\\n        if ((val & (1 << i)) > 0) { // if val ith bit is 1\\n            if (curt.children[0] !== null && curt.children[0].count > 0) {\\n                curt = curt.children[0];\\n                maxDiff += (1 << i);\\n            } else {\\n                curt = curt.children[1];\\n            }\\n        } else { // val ith bit is 0\\n            if (curt.children[1] !== null && curt.children[1].count > 0) {\\n                curt = curt.children[1];\\n                maxDiff += (1 << i);\\n            } else {\\n                curt = curt.children[0];\\n            }\\n        }\\n    }\\n    return maxDiff;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1346883,
                "title": "provide-my-idea-c",
                "content": "```\\nclass Solution {\\npublic:\\n    struct trieNode {\\n        bool isEnd;\\n        vector<int> cnt;\\n        vector<trieNode*> next;\\n        trieNode () : isEnd(false), cnt(vector<int>(2, 0)), next(vector<trieNode*>(2, nullptr)) {};\\n    };\\n    \\n    trieNode* root;\\n    \\n    void insert(int val) {\\n        if (root == nullptr) root = new trieNode();\\n        trieNode* curr = root;\\n        for (int i = 19; i >= 0; --i) {\\n            int nextVal = ((val & (1 << i)) >> i);\\n            if (curr->next[nextVal] == nullptr)\\n                curr->next[nextVal] = new trieNode();\\n            curr->cnt[nextVal]++;\\n            curr = curr->next[nextVal];\\n        }\\n        curr->isEnd = true;\\n    }\\n    \\n    void remove (int val) {\\n        trieNode* curr = root;\\n        for (int i = 19; i >= 0; --i) {\\n            int nextVal = ((val & (1 << i)) >> i);\\n            curr->cnt[nextVal]--;\\n            if (curr->cnt[nextVal] == 0) {\\n                curr->next[nextVal] = nullptr;\\n                break;\\n            }\\n            curr = curr->next[nextVal];\\n        }\\n    }\\n    \\n    int maxXorValue (int val) {\\n        \\n        int maxVal = 0;\\n        trieNode* curr = root;\\n        \\n        for (int i = 19; i >= 0; --i) {\\n            int nextVal = ((val & (1 << i)) >> i);\\n            if (curr->next[1 - nextVal]) {\\n                maxVal |= (1 << i);\\n                curr = curr->next[1 - nextVal];\\n            } else {\\n                curr = curr->next[nextVal];\\n            }\\n        }\\n        \\n        return maxVal;\\n    }\\n    \\npublic:\\n    \\n    void maxGeneticDifference_(int idx, vector<vector<int>>& conn, vector<int>& res, vector<vector<pair<int, int>>>& qVec) {\\n        \\n        insert(idx);\\n        \\n        for (int i = 0; i < qVec[idx].size(); ++i) {\\n            res[qVec[idx][i].second] = maxXorValue(qVec[idx][i].first);\\n        }\\n        \\n        for (int i = 0; i < conn[idx].size(); ++i) {\\n            maxGeneticDifference_(conn[idx][i], conn, res, qVec);\\n        }\\n        \\n        remove(idx);\\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        vector<vector<int>> conn(parents.size());\\n        int rootNode;\\n        \\n        for (int i = 0; i < parents.size(); ++i) {\\n            if (parents[i] == -1) {\\n                rootNode = i;\\n                continue;\\n            }\\n            conn[parents[i]].push_back(i);\\n        }\\n        \\n        vector<vector<pair<int, int>>> qVec(parents.size());\\n        for (int i = 0; i < queries.size(); ++i) {\\n            qVec[queries[i][0]].push_back(make_pair(queries[i][1], i));\\n        }\\n        \\n        vector<int> res(queries.size(), 0);\\n        \\n        maxGeneticDifference_(rootNode, conn, res, qVec);\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct trieNode {\\n        bool isEnd;\\n        vector<int> cnt;\\n        vector<trieNode*> next;\\n        trieNode () : isEnd(false), cnt(vector<int>(2, 0)), next(vector<trieNode*>(2, nullptr)) {};\\n    };\\n    \\n    trieNode* root;\\n    \\n    void insert(int val) {\\n        if (root == nullptr) root = new trieNode();\\n        trieNode* curr = root;\\n        for (int i = 19; i >= 0; --i) {\\n            int nextVal = ((val & (1 << i)) >> i);\\n            if (curr->next[nextVal] == nullptr)\\n                curr->next[nextVal] = new trieNode();\\n            curr->cnt[nextVal]++;\\n            curr = curr->next[nextVal];\\n        }\\n        curr->isEnd = true;\\n    }\\n    \\n    void remove (int val) {\\n        trieNode* curr = root;\\n        for (int i = 19; i >= 0; --i) {\\n            int nextVal = ((val & (1 << i)) >> i);\\n            curr->cnt[nextVal]--;\\n            if (curr->cnt[nextVal] == 0) {\\n                curr->next[nextVal] = nullptr;\\n                break;\\n            }\\n            curr = curr->next[nextVal];\\n        }\\n    }\\n    \\n    int maxXorValue (int val) {\\n        \\n        int maxVal = 0;\\n        trieNode* curr = root;\\n        \\n        for (int i = 19; i >= 0; --i) {\\n            int nextVal = ((val & (1 << i)) >> i);\\n            if (curr->next[1 - nextVal]) {\\n                maxVal |= (1 << i);\\n                curr = curr->next[1 - nextVal];\\n            } else {\\n                curr = curr->next[nextVal];\\n            }\\n        }\\n        \\n        return maxVal;\\n    }\\n    \\npublic:\\n    \\n    void maxGeneticDifference_(int idx, vector<vector<int>>& conn, vector<int>& res, vector<vector<pair<int, int>>>& qVec) {\\n        \\n        insert(idx);\\n        \\n        for (int i = 0; i < qVec[idx].size(); ++i) {\\n            res[qVec[idx][i].second] = maxXorValue(qVec[idx][i].first);\\n        }\\n        \\n        for (int i = 0; i < conn[idx].size(); ++i) {\\n            maxGeneticDifference_(conn[idx][i], conn, res, qVec);\\n        }\\n        \\n        remove(idx);\\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        vector<vector<int>> conn(parents.size());\\n        int rootNode;\\n        \\n        for (int i = 0; i < parents.size(); ++i) {\\n            if (parents[i] == -1) {\\n                rootNode = i;\\n                continue;\\n            }\\n            conn[parents[i]].push_back(i);\\n        }\\n        \\n        vector<vector<pair<int, int>>> qVec(parents.size());\\n        for (int i = 0; i < queries.size(); ++i) {\\n            qVec[queries[i][0]].push_back(make_pair(queries[i][1], i));\\n        }\\n        \\n        vector<int> res(queries.size(), 0);\\n        \\n        maxGeneticDifference_(rootNode, conn, res, qVec);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346613,
                "title": "javascript-dfs-trie",
                "content": "**Reference**: [421. Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)\\ncopied my Trie-JavaScript code from my previous solution: [JavaScript - Trie solution](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/1123179/JavaScript-Trie-solution)\\n\\nKey points:\\n- how to delete one node? - use `cnt` property \\n- **TLE failed cases** in contest: \\n\\t- on-demand find each query path to compute, multiple DFS\\n\\t- one DFS, but store each path on each node, eg: `node.path = [......]`, uhm, i got \"**Memory** Exceeds\"\\n\\t- **18 bit** is enough for `10^5` , use `2^17 + lowest bit`\\n\\n**JS code:**\\n```js\\nvar maxGeneticDifference = function(parents, queries) {\\n    const n = parents.length;\\n    \\n    // 1. build adj\\n    let root;\\n    const graph = new Array(n).fill(0).map(el=>new Array(0)); // pa_i -> children array\\n    for(let i =0; i<n; i++) {\\n        const p = parents[i];\\n        if(p===-1){\\n            root = i;\\n        }\\n        else {\\n            graph[p].push(i);\\n        }\\n    }\\n    \\n    // 2. pre-process queries and res array\\n    const res = new Array(queries.length).fill(0);\\n    const qmap = new Map();\\n    queries.forEach((q,i)=>{\\n        if(!qmap.has(q[0]))\\n        {\\n            qmap.set(q[0], []);\\n        }\\n        qmap.get(q[0]).push([q[1], i]);\\n    });\\n    \\n    // 3. DFS with Trie\\n    const trie = new TrieNode();\\n    function dfs(node)\\n    {\\n        insert(trie, node);\\n        if(qmap.has(node)) // compute cur node result \\n        {\\n            for(const query of qmap.get(node))\\n            {\\n                const [val, index] = query;\\n                res[index] = calcXOR(trie, val);\\n            }\\n        }\\n        for(const next of graph[node])\\n        {\\n            dfs(next);\\n        }\\n        remove(trie, node);\\n    }\\n    dfs(root);\\n    return res;\\n};\\n\\n/*******************************************************\\n* Trie - JavaScript\\n*******************************************************/\\nclass TrieNode {\\n    constructor() {\\n        this.cnt = 0;\\n        this.children = [null, null];\\n    }\\n}\\n \\nfunction insert(root, a) { // O(n)\\n    var cur = root;\\n    for(var i = 17; i>=0; i--)\\n    {\\n        var bit = (a >> i) & 1;\\n        if(!cur.children[bit])\\n        {\\n            cur.children[bit] = new TrieNode();\\n        }\\n        cur = cur.children[bit];\\n        cur.cnt++;\\n    }\\n}\\n\\nfunction remove(root, a) { \\n    var cur = root;\\n    for(var i = 17; i>=0; i--)\\n    {\\n        var bit = (a >> i) & 1\\n        cur.children[bit].cnt--;\\n        if(cur.children[bit].cnt === 0)\\n        {\\n            cur.children[bit] = null;\\n            return;\\n        }\\n        cur = cur.children[bit];\\n    }\\n}\\n\\nfunction calcXOR(root, num) { // O(n)\\n        let cur = root;\\n        let ans = 0;\\n        for(let i = 17; i>=0; i--)\\n        {\\n            let bit = (num >> i) & 1;\\n            // try to find (1-bit)\\n            if(cur.children[1-bit] !== null)\\n            {\\n                ans += Math.pow(2, i);\\n                cur = cur.children[1-bit];\\n            } \\n            else {\\n                cur = cur.children[bit];\\n            }  \\n        } // end for\\n        return ans;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar maxGeneticDifference = function(parents, queries) {\\n    const n = parents.length;\\n    \\n    // 1. build adj\\n    let root;\\n    const graph = new Array(n).fill(0).map(el=>new Array(0)); // pa_i -> children array\\n    for(let i =0; i<n; i++) {\\n        const p = parents[i];\\n        if(p===-1){\\n            root = i;\\n        }\\n        else {\\n            graph[p].push(i);\\n        }\\n    }\\n    \\n    // 2. pre-process queries and res array\\n    const res = new Array(queries.length).fill(0);\\n    const qmap = new Map();\\n    queries.forEach((q,i)=>{\\n        if(!qmap.has(q[0]))\\n        {\\n            qmap.set(q[0], []);\\n        }\\n        qmap.get(q[0]).push([q[1], i]);\\n    });\\n    \\n    // 3. DFS with Trie\\n    const trie = new TrieNode();\\n    function dfs(node)\\n    {\\n        insert(trie, node);\\n        if(qmap.has(node)) // compute cur node result \\n        {\\n            for(const query of qmap.get(node))\\n            {\\n                const [val, index] = query;\\n                res[index] = calcXOR(trie, val);\\n            }\\n        }\\n        for(const next of graph[node])\\n        {\\n            dfs(next);\\n        }\\n        remove(trie, node);\\n    }\\n    dfs(root);\\n    return res;\\n};\\n\\n/*******************************************************\\n* Trie - JavaScript\\n*******************************************************/\\nclass TrieNode {\\n    constructor() {\\n        this.cnt = 0;\\n        this.children = [null, null];\\n    }\\n}\\n \\nfunction insert(root, a) { // O(n)\\n    var cur = root;\\n    for(var i = 17; i>=0; i--)\\n    {\\n        var bit = (a >> i) & 1;\\n        if(!cur.children[bit])\\n        {\\n            cur.children[bit] = new TrieNode();\\n        }\\n        cur = cur.children[bit];\\n        cur.cnt++;\\n    }\\n}\\n\\nfunction remove(root, a) { \\n    var cur = root;\\n    for(var i = 17; i>=0; i--)\\n    {\\n        var bit = (a >> i) & 1\\n        cur.children[bit].cnt--;\\n        if(cur.children[bit].cnt === 0)\\n        {\\n            cur.children[bit] = null;\\n            return;\\n        }\\n        cur = cur.children[bit];\\n    }\\n}\\n\\nfunction calcXOR(root, num) { // O(n)\\n        let cur = root;\\n        let ans = 0;\\n        for(let i = 17; i>=0; i--)\\n        {\\n            let bit = (num >> i) & 1;\\n            // try to find (1-bit)\\n            if(cur.children[1-bit] !== null)\\n            {\\n                ans += Math.pow(2, i);\\n                cur = cur.children[1-bit];\\n            } \\n            else {\\n                cur = cur.children[bit];\\n            }  \\n        } // end for\\n        return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346070,
                "title": "python-trie-using-dictionary-of-lists-dfs",
                "content": "```\\nclass Trie:\\n    def __init__(self,MAXBIN):\\n        self.MAXBIN = MAXBIN\\n        self.trie = dict() # string length -> list\\n        # ex : trie[1] = [0,0]\\n        #      trie[2] = [0,0,0,0]\\n        #      trie[3] = [0,0,0,0,0,0,0,0]\\n        #      trie[4] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\n        #      trie[18] = [0] * 2**18 \\n        # for a given node, the nodes of its substring will be activated and turned to 1  \\n        # ex: node = 2 = \"000000000000000010\" in binary string\\n        # so the activation path is \\n        # trie[1] : activate \"0\" -> trie[1][0]\\n        # trie[2] : activate \"00\" -> trie[2][0]\\n        # ......\\n        # trie[18] : activate \"000000000000000010\" -> trie[18][2]\\n\\n        # the index to activate can be calculated via a simple formula:\\n        # if next value is \"0\" : trie[l][idx] -> trie[l+1][2*idx]\\n        # if next value is \"1\" : trie[l][idx] -> trie[l+1][2*idx + 1]\\n        for i in range(1,1+self.MAXBIN):\\n            self.trie[i] = [0] * 2 ** (i)\\n    \\n    def add(self,node_str):\\n        idx = 0 #node_str[0]\\n        for i in range(1,1+self.MAXBIN):\\n            c = node_str[i-1]\\n            if c == \"1\":\\n                idx *= 2\\n                idx += 1\\n            else:\\n                idx *= 2\\n            self.trie[i][idx] = 1 # activate\\n            \\n    def remove(self,node:int):\\n        idx = node\\n        for i in range(self.MAXBIN,0,-1):\\n            if idx % 2:\\n                otherchild = idx - 1\\n            else:\\n                otherchild = idx + 1\\n            self.trie[i][idx] = 0 # delete child\\n            if self.trie[i][otherchild] == 1: # this path has another child, we don\\'t need to delete parent \\n                break\\n            idx //= 2 # parent index\\n                \\n                \\n    def find_max_xor(self,V_str:str) -> int:\\n        # largest value possible for val ^ x  is when x =  2 ** 18 - val - 1\\n        # let V = 2 ** 19 - val - 1\\n        # V is not in the nodes, inverting one bit of V at the i-th position (from last) costs 2 ** i\\n        # => We find the max value by traversing down trie, greedily matching V\\n        idx = 0 \\n        for i in range(1,1+self.MAXBIN):\\n            \\n            c = V_str[i-1]\\n            if c == \"1\":\\n                if self.trie[i][2 * idx + 1] == 1 :\\n                    idx = 2 * idx + 1\\n                else:\\n                    idx = 2 * idx\\n            else:\\n                if self.trie[i][2 * idx] == 1 :\\n                    idx = 2 * idx\\n                else:\\n                    idx = 2 * idx + 1\\n        return idx\\n    \\nclass Solution:\\n    \\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        MAXBIN = 18\\n        def pad_binary(x):\\n            return bin(x)[2:].zfill(MAXBIN)\\n        \\n        # convert bottom up tree to top down tree\\n        parent2child = defaultdict(list)\\n        for n,x in enumerate(parents):\\n            # n has parent x -> x has child n\\n            parent2child[x].append(n)\\n            \\n        # attach queries to their respective node\\n        nodes2queries = defaultdict(list)\\n        for i,(node,val) in enumerate(queries):\\n            nodes2queries[node].append((i,val))\\n        \\n        trie = Trie(MAXBIN)\\n        ret = [-1] * len(queries)\\n        \\n        def dfs(node):\\n            node_str = pad_binary(node)\\n            \\n            trie.add(node_str)\\n            for i,q in nodes2queries[node]:\\n                max_target = pad_binary(2 ** 18 - q- 1)\\n                max_xor = trie.find_max_xor(max_target)\\n                ret[i] = max_xor ^ q\\n            for child in parent2child[node]:\\n                dfs(child)\\n            trie.remove(node)\\n        \\n        dfs(parent2child[-1][0])\\n        \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie:\\n    def __init__(self,MAXBIN):\\n        self.MAXBIN = MAXBIN\\n        self.trie = dict() # string length -> list\\n        # ex : trie[1] = [0,0]\\n        #      trie[2] = [0,0,0,0]\\n        #      trie[3] = [0,0,0,0,0,0,0,0]\\n        #      trie[4] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\n        #      trie[18] = [0] * 2**18 \\n        # for a given node, the nodes of its substring will be activated and turned to 1  \\n        # ex: node = 2 = \"000000000000000010\" in binary string\\n        # so the activation path is \\n        # trie[1] : activate \"0\" -> trie[1][0]\\n        # trie[2] : activate \"00\" -> trie[2][0]\\n        # ......\\n        # trie[18] : activate \"000000000000000010\" -> trie[18][2]\\n\\n        # the index to activate can be calculated via a simple formula:\\n        # if next value is \"0\" : trie[l][idx] -> trie[l+1][2*idx]\\n        # if next value is \"1\" : trie[l][idx] -> trie[l+1][2*idx + 1]\\n        for i in range(1,1+self.MAXBIN):\\n            self.trie[i] = [0] * 2 ** (i)\\n    \\n    def add(self,node_str):\\n        idx = 0 #node_str[0]\\n        for i in range(1,1+self.MAXBIN):\\n            c = node_str[i-1]\\n            if c == \"1\":\\n                idx *= 2\\n                idx += 1\\n            else:\\n                idx *= 2\\n            self.trie[i][idx] = 1 # activate\\n            \\n    def remove(self,node:int):\\n        idx = node\\n        for i in range(self.MAXBIN,0,-1):\\n            if idx % 2:\\n                otherchild = idx - 1\\n            else:\\n                otherchild = idx + 1\\n            self.trie[i][idx] = 0 # delete child\\n            if self.trie[i][otherchild] == 1: # this path has another child, we don\\'t need to delete parent \\n                break\\n            idx //= 2 # parent index\\n                \\n                \\n    def find_max_xor(self,V_str:str) -> int:\\n        # largest value possible for val ^ x  is when x =  2 ** 18 - val - 1\\n        # let V = 2 ** 19 - val - 1\\n        # V is not in the nodes, inverting one bit of V at the i-th position (from last) costs 2 ** i\\n        # => We find the max value by traversing down trie, greedily matching V\\n        idx = 0 \\n        for i in range(1,1+self.MAXBIN):\\n            \\n            c = V_str[i-1]\\n            if c == \"1\":\\n                if self.trie[i][2 * idx + 1] == 1 :\\n                    idx = 2 * idx + 1\\n                else:\\n                    idx = 2 * idx\\n            else:\\n                if self.trie[i][2 * idx] == 1 :\\n                    idx = 2 * idx\\n                else:\\n                    idx = 2 * idx + 1\\n        return idx\\n    \\nclass Solution:\\n    \\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        MAXBIN = 18\\n        def pad_binary(x):\\n            return bin(x)[2:].zfill(MAXBIN)\\n        \\n        # convert bottom up tree to top down tree\\n        parent2child = defaultdict(list)\\n        for n,x in enumerate(parents):\\n            # n has parent x -> x has child n\\n            parent2child[x].append(n)\\n            \\n        # attach queries to their respective node\\n        nodes2queries = defaultdict(list)\\n        for i,(node,val) in enumerate(queries):\\n            nodes2queries[node].append((i,val))\\n        \\n        trie = Trie(MAXBIN)\\n        ret = [-1] * len(queries)\\n        \\n        def dfs(node):\\n            node_str = pad_binary(node)\\n            \\n            trie.add(node_str)\\n            for i,q in nodes2queries[node]:\\n                max_target = pad_binary(2 ** 18 - q- 1)\\n                max_xor = trie.find_max_xor(max_target)\\n                ret[i] = max_xor ^ q\\n            for child in parent2child[node]:\\n                dfs(child)\\n            trie.remove(node)\\n        \\n        dfs(parent2child[-1][0])\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345953,
                "title": "clean-cpp-dfs-trie",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    class node {\\n            public:\\n        int count;\\n        node* left, *right;\\n        node() {\\n            count = 0;\\n            left = right = NULL;\\n        }\\n    };\\n    class  trie {\\n        public:\\n        node* root;\\n        trie() {\\n            root = new node();\\n        }\\n        void insert(int x) {\\n            node * temp = root;\\n            for(int i = 31; i >= 0; i--) {\\n                bool bit = ((x >> i)&1);\\n                if(bit) {\\n                    if(temp->right == NULL) {\\n                        temp->right = new node();\\n                    }\\n                    temp = temp->right;\\n                    temp->count += 1;\\n                } else {\\n                    if(temp->left == NULL) {\\n                        temp->left = new node();\\n                    }\\n                    temp = temp->left;\\n                    temp->count += 1;\\n                }\\n            }\\n        }\\n\\n        int findmax(int x) {\\n            node* temp = root;\\n            int ret = 0;\\n            for(int i = 31; i >= 0; i--) {\\n                bool bit = ((x >> i)&1);\\n                if(bit) {\\n                    if(temp->left and temp->left->count) {\\n                        ret += (1 << i);\\n                        temp = temp->left;\\n                    } else {\\n                        temp = temp->right;\\n                    }\\n                } else {\\n                    if(temp->right and temp->right->count) {\\n                        ret += (1 << i);\\n                        temp = temp->right;\\n                    } else {\\n                        temp = temp->left;\\n                    }\\n                } \\n            }\\n            return ret;\\n        }\\n        void deletes(int num) {\\n            node* temp = root;\\n            for(int i = 31; i >= 0; i--) {\\n                bool bit = ((num >> i)&1);\\n                if(bit) {\\n                    temp->right->count -= 1;\\n                    temp = temp->right;\\n                } else {\\n                    temp->left->count -= 1;\\n                    temp = temp->left;\\n                }\\n            }\\n        }\\n    };\\n    trie t;\\n    void dfs(int node, vector<vector<int>>& adj, vector<int>& ans, vector<vector<pair<int,int>>>& qm) {\\n        t.insert(node);\\n        for(auto [val, idx] : qm[node]) {\\n            ans[idx] =  t.findmax(val);\\n        }\\n        for(auto nbr : adj[node]) {\\n            dfs(nbr, adj, ans, qm);\\n        }\\n        t.deletes(node);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parent, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        int n = parent.size();\\n        vector<vector<int>> adj(n);\\n        int start = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(parent[i] == -1) {\\n                start = i;\\n            } else {\\n                adj[parent[i]].push_back(i);\\n            }\\n        }\\n        vector<vector<pair<int,int>>> qm(n);\\n        for(int i = 0;i < m; i++) {\\n            qm[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        vector<int> ans(m);\\n        dfs(start, adj, ans, qm);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    class node {\\n            public:\\n        int count;\\n        node* left, *right;\\n        node() {\\n            count = 0;\\n            left = right = NULL;\\n        }\\n    };\\n    class  trie {\\n        public:\\n        node* root;\\n        trie() {\\n            root = new node();\\n        }\\n        void insert(int x) {\\n            node * temp = root;\\n            for(int i = 31; i >= 0; i--) {\\n                bool bit = ((x >> i)&1);\\n                if(bit) {\\n                    if(temp->right == NULL) {\\n                        temp->right = new node();\\n                    }\\n                    temp = temp->right;\\n                    temp->count += 1;\\n                } else {\\n                    if(temp->left == NULL) {\\n                        temp->left = new node();\\n                    }\\n                    temp = temp->left;\\n                    temp->count += 1;\\n                }\\n            }\\n        }\\n\\n        int findmax(int x) {\\n            node* temp = root;\\n            int ret = 0;\\n            for(int i = 31; i >= 0; i--) {\\n                bool bit = ((x >> i)&1);\\n                if(bit) {\\n                    if(temp->left and temp->left->count) {\\n                        ret += (1 << i);\\n                        temp = temp->left;\\n                    } else {\\n                        temp = temp->right;\\n                    }\\n                } else {\\n                    if(temp->right and temp->right->count) {\\n                        ret += (1 << i);\\n                        temp = temp->right;\\n                    } else {\\n                        temp = temp->left;\\n                    }\\n                } \\n            }\\n            return ret;\\n        }\\n        void deletes(int num) {\\n            node* temp = root;\\n            for(int i = 31; i >= 0; i--) {\\n                bool bit = ((num >> i)&1);\\n                if(bit) {\\n                    temp->right->count -= 1;\\n                    temp = temp->right;\\n                } else {\\n                    temp->left->count -= 1;\\n                    temp = temp->left;\\n                }\\n            }\\n        }\\n    };\\n    trie t;\\n    void dfs(int node, vector<vector<int>>& adj, vector<int>& ans, vector<vector<pair<int,int>>>& qm) {\\n        t.insert(node);\\n        for(auto [val, idx] : qm[node]) {\\n            ans[idx] =  t.findmax(val);\\n        }\\n        for(auto nbr : adj[node]) {\\n            dfs(nbr, adj, ans, qm);\\n        }\\n        t.deletes(node);\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parent, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        int n = parent.size();\\n        vector<vector<int>> adj(n);\\n        int start = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(parent[i] == -1) {\\n                start = i;\\n            } else {\\n                adj[parent[i]].push_back(i);\\n            }\\n        }\\n        vector<vector<pair<int,int>>> qm(n);\\n        for(int i = 0;i < m; i++) {\\n            qm[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        vector<int> ans(m);\\n        dfs(start, adj, ans, qm);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345860,
                "title": "implemented-a-simple-solution-in-python-but-ran-out-of-time",
                "content": "The code is as follows. Loop through the queries. Start from the current node and search in parents until you reach -1. at every point keep accumulating the xor value with a max funtion. \\n\\n```\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        output = []\\n        paths = []\\n        for node, val in queries:\\n            max_val = 0 \\n            parent = parents[node]\\n            max_val = max(max_val, val^node )\\n            while parent != -1:\\n                max_val = max(max_val, val^parent )\\n                parent = parents[parent]\\n                \\n            \\n            output.append(max_val)    \\n            \\n        return output\\n        \\n        \\n```\\n\\nThis passes 50 out of 58. Can anyone suggest ideas to speed up where i dont have to completely modify the code.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        output = []\\n        paths = []\\n        for node, val in queries:\\n            max_val = 0 \\n            parent = parents[node]\\n            max_val = max(max_val, val^node )\\n            while parent != -1:\\n                max_val = max(max_val, val^parent )\\n                parent = parents[parent]\\n                \\n            \\n            output.append(max_val)    \\n            \\n        return output\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345817,
                "title": "c-memory-friendly-implementation-of-trie-and-graph",
                "content": "Here I just want to share my implementation. Here are several good posts explaining how to solve the problem, so I just want to share some implementation tricks which are Heap friendly (in sens of memory allocation in C++).\\nAnd the last but not least (in terms of interview experience), my solution doesn\\'t make any memory leak.\\n```\\nclass Solution {\\n    vector<vector<size_t>> adjList;\\n    vector<bool> go;\\n    size_t root;\\n    unordered_map<size_t, vector<pair<int, size_t>>> searchFor;    \\n    vector<int> answ;\\n    \\n    struct Node\\n    {\\n        Node() { children[0] = 0, children[1] = 0; used = 0; }\\n        size_t used;\\n        size_t children[2];\\n    };\\n    vector<Node> trie;\\n    \\n    void increment(int val, int diff)\\n    {\\n        size_t tNode = 0;\\n        for (size_t msk = 1 << 23; msk > 0; msk >>= 1)\\n        {\\n            auto offs = (val & msk) != 0;\\n            trie[tNode].used += diff;\\n            \\n            if (trie[tNode].children[offs] == 0)\\n            {\\n                trie[tNode].children[offs] = trie.size();\\n                trie.emplace_back();                \\n            }\\n            tNode = trie[tNode].children[offs];\\n        }\\n        trie[tNode].used += diff;\\n    }\\n    \\n    int search(int val)\\n    {\\n        int maxDiff = 0;\\n        size_t tNode = 0;\\n\\n        for (size_t msk = 1 << 23; msk > 0; msk >>= 1, maxDiff <<= 1)\\n        {\\n            auto bit = (val & msk) != 0;\\n            size_t bestChild = trie[tNode].children[bit ^ 1];\\n\\n            if (bestChild && trie[bestChild].used)\\n            {\\n                maxDiff |= 1;\\n                tNode = bestChild;\\n            }\\n            else\\n                tNode = trie[tNode].children[bit];\\n\\n            assert(tNode);\\n        }\\n\\n        return maxDiff >> 1;\\n    }\\n    \\n    bool dfs1(size_t node)\\n    {\\n        bool needVisit = searchFor.count(node) != 0;\\n        \\n        for (auto nxt: adjList[node])\\n            needVisit |= dfs1(nxt);\\n        \\n        go[node] = needVisit;\\n        return needVisit;\\n    }\\n    \\n    void dfs2(size_t node)\\n    {\\n        increment(node, 1);\\n        \\n        auto it = searchFor.find(node);\\n        if (it != searchFor.end())\\n        {\\n            for (auto [val, answOffs]: it->second)\\n                answ[answOffs] = search(val);\\n        }\\n        \\n        for (auto nxt: adjList[node])\\n        {\\n            if (!go[nxt])\\n                continue;\\n            \\n            dfs2(nxt);\\n        }\\n        \\n        increment(node, -1);\\n    }\\n    \\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        adjList.resize(parents.size());\\n        \\n        for (size_t i = 0; i < parents.size(); ++i)\\n        {\\n            if (parents[i] == -1)\\n                root = i;\\n            else\\n                adjList[parents[i]].push_back(i);\\n        }\\n        \\n        searchFor.reserve(queries.size());\\n        for (size_t i = 0; i < queries.size(); ++i)\\n        {\\n            searchFor[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        \\n        go.resize(parents.size());\\n        dfs1(root);\\n        \\n        answ.resize(queries.size());\\n        \\n        trie.emplace_back();\\n        dfs2(root);\\n        \\n        return answ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<size_t>> adjList;\\n    vector<bool> go;\\n    size_t root;\\n    unordered_map<size_t, vector<pair<int, size_t>>> searchFor;    \\n    vector<int> answ;\\n    \\n    struct Node\\n    {\\n        Node() { children[0] = 0, children[1] = 0; used = 0; }\\n        size_t used;\\n        size_t children[2];\\n    };\\n    vector<Node> trie;\\n    \\n    void increment(int val, int diff)\\n    {\\n        size_t tNode = 0;\\n        for (size_t msk = 1 << 23; msk > 0; msk >>= 1)\\n        {\\n            auto offs = (val & msk) != 0;\\n            trie[tNode].used += diff;\\n            \\n            if (trie[tNode].children[offs] == 0)\\n            {\\n                trie[tNode].children[offs] = trie.size();\\n                trie.emplace_back();                \\n            }\\n            tNode = trie[tNode].children[offs];\\n        }\\n        trie[tNode].used += diff;\\n    }\\n    \\n    int search(int val)\\n    {\\n        int maxDiff = 0;\\n        size_t tNode = 0;\\n\\n        for (size_t msk = 1 << 23; msk > 0; msk >>= 1, maxDiff <<= 1)\\n        {\\n            auto bit = (val & msk) != 0;\\n            size_t bestChild = trie[tNode].children[bit ^ 1];\\n\\n            if (bestChild && trie[bestChild].used)\\n            {\\n                maxDiff |= 1;\\n                tNode = bestChild;\\n            }\\n            else\\n                tNode = trie[tNode].children[bit];\\n\\n            assert(tNode);\\n        }\\n\\n        return maxDiff >> 1;\\n    }\\n    \\n    bool dfs1(size_t node)\\n    {\\n        bool needVisit = searchFor.count(node) != 0;\\n        \\n        for (auto nxt: adjList[node])\\n            needVisit |= dfs1(nxt);\\n        \\n        go[node] = needVisit;\\n        return needVisit;\\n    }\\n    \\n    void dfs2(size_t node)\\n    {\\n        increment(node, 1);\\n        \\n        auto it = searchFor.find(node);\\n        if (it != searchFor.end())\\n        {\\n            for (auto [val, answOffs]: it->second)\\n                answ[answOffs] = search(val);\\n        }\\n        \\n        for (auto nxt: adjList[node])\\n        {\\n            if (!go[nxt])\\n                continue;\\n            \\n            dfs2(nxt);\\n        }\\n        \\n        increment(node, -1);\\n    }\\n    \\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        adjList.resize(parents.size());\\n        \\n        for (size_t i = 0; i < parents.size(); ++i)\\n        {\\n            if (parents[i] == -1)\\n                root = i;\\n            else\\n                adjList[parents[i]].push_back(i);\\n        }\\n        \\n        searchFor.reserve(queries.size());\\n        for (size_t i = 0; i < queries.size(); ++i)\\n        {\\n            searchFor[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        \\n        go.resize(parents.size());\\n        dfs1(root);\\n        \\n        answ.resize(queries.size());\\n        \\n        trie.emplace_back();\\n        dfs2(root);\\n        \\n        return answ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345814,
                "title": "simple-c-solution-maintain-a-trie-of-nodes-from-root-to-current-node",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    struct TrieNode{\\n        TrieNode(): left(NULL), right(NULL), cnt(0) {}\\n        TrieNode *left, *right;\\n        int cnt;\\n    };\\n    \\n    int n;\\n    vector<vector<int> > adj;\\n    TrieNode *head;\\n    unordered_map<int, vector<pair<int, int> > > mp;\\n    vector<int> ans;\\n    \\n    void insert(int num){\\n        TrieNode *root=head;\\n        for(int i=17; i>=0; i--){\\n            if((num>>i)&1){\\n                if(root->right==NULL){\\n                    root->right=new TrieNode();\\n                }\\n                root=root->right;\\n            }\\n            else{\\n                if(root->left==NULL){\\n                    root->left=new TrieNode();\\n                }\\n                root=root->left;\\n            }\\n            root->cnt++;\\n        }\\n    }\\n    \\n    int solve(int val){\\n        TrieNode *root=head;\\n        int ans=0;\\n        for(int i=17; i>=0; i--){\\n            if((val>>i)&1){\\n                if(root->left!=NULL && root->left->cnt>0){\\n                    ans|=(1<<i);\\n                    root=root->left;\\n                }\\n                else{\\n                    root=root->right;\\n                }\\n            }\\n            else{\\n                if(root->right!=NULL && root->right->cnt>0){\\n                    ans|=(1<<i);\\n                    root=root->right;\\n                }\\n                else{\\n                    root=root->left;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void del(int num){\\n        TrieNode *root=head;\\n        for(int i=17; i>=0; i--){\\n            if((num>>i)&1){\\n                root=root->right;\\n            }\\n            else{\\n                root=root->left;\\n            }\\n            root->cnt--;\\n        }\\n    }\\n    \\n    void dfs(int v){\\n        insert(v);\\n        if(mp.count(v)){\\n            for(auto itr: mp[v]){\\n                int val=itr.first, idx=itr.second;\\n                ans[idx]=solve(val);\\n            }\\n        }\\n        for(int to: adj[v]){\\n            dfs(to);\\n        }\\n        del(v);\\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        n=parents.size();\\n        head=new TrieNode();\\n        int q=queries.size(), root;\\n        ans=vector<int>(q);\\n        adj=vector<vector<int> >(n);\\n        for(int i=0; i<q; i++){\\n            mp[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        for(int i=0; i<n; i++){\\n            if(parents[i]==-1){\\n                root=i;\\n                continue;\\n            }\\n            adj[parents[i]].push_back(i);\\n        }\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct TrieNode{\\n        TrieNode(): left(NULL), right(NULL), cnt(0) {}\\n        TrieNode *left, *right;\\n        int cnt;\\n    };\\n    \\n    int n;\\n    vector<vector<int> > adj;\\n    TrieNode *head;\\n    unordered_map<int, vector<pair<int, int> > > mp;\\n    vector<int> ans;\\n    \\n    void insert(int num){\\n        TrieNode *root=head;\\n        for(int i=17; i>=0; i--){\\n            if((num>>i)&1){\\n                if(root->right==NULL){\\n                    root->right=new TrieNode();\\n                }\\n                root=root->right;\\n            }\\n            else{\\n                if(root->left==NULL){\\n                    root->left=new TrieNode();\\n                }\\n                root=root->left;\\n            }\\n            root->cnt++;\\n        }\\n    }\\n    \\n    int solve(int val){\\n        TrieNode *root=head;\\n        int ans=0;\\n        for(int i=17; i>=0; i--){\\n            if((val>>i)&1){\\n                if(root->left!=NULL && root->left->cnt>0){\\n                    ans|=(1<<i);\\n                    root=root->left;\\n                }\\n                else{\\n                    root=root->right;\\n                }\\n            }\\n            else{\\n                if(root->right!=NULL && root->right->cnt>0){\\n                    ans|=(1<<i);\\n                    root=root->right;\\n                }\\n                else{\\n                    root=root->left;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void del(int num){\\n        TrieNode *root=head;\\n        for(int i=17; i>=0; i--){\\n            if((num>>i)&1){\\n                root=root->right;\\n            }\\n            else{\\n                root=root->left;\\n            }\\n            root->cnt--;\\n        }\\n    }\\n    \\n    void dfs(int v){\\n        insert(v);\\n        if(mp.count(v)){\\n            for(auto itr: mp[v]){\\n                int val=itr.first, idx=itr.second;\\n                ans[idx]=solve(val);\\n            }\\n        }\\n        for(int to: adj[v]){\\n            dfs(to);\\n        }\\n        del(v);\\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        n=parents.size();\\n        head=new TrieNode();\\n        int q=queries.size(), root;\\n        ans=vector<int>(q);\\n        adj=vector<vector<int> >(n);\\n        for(int i=0; i<q; i++){\\n            mp[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        for(int i=0; i<n; i++){\\n            if(parents[i]==-1){\\n                root=i;\\n                continue;\\n            }\\n            adj[parents[i]].push_back(i);\\n        }\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345306,
                "title": "javascript-dfs-1972ms",
                "content": "```\\nfunction Query(index, val) {\\n    this.index = index;\\n    this.val = val;\\n}\\n\\nconst maxGeneticDifference = (parents, queries) => {\\n    let pn = parents.length, qn = queries.length;\\n    let root = parents.indexOf(-1);\\n    let children = initializeGraph(pn); // save each tree node\\'s child by index\\n    for (let i = 0; i < pn; i++) {\\n        if (i != root) {\\n            children[parents[i]].push(i);\\n        }\\n    }\\n\\t// Example 1: children now is [ [ 1 ], [ 2, 3 ], [], []]\\n    let freq = Array(1 << 20).fill(0);\\n    let queriesByNode = initializeGraph(pn);\\n    for (let i = 0; i < qn; i++) {\\n        let query = queries[i];\\n        queriesByNode[query[0]].push(new Query(i, query[1]));\\n    }\\n\\t// Example 1, queryByNode now is\\n\\t// [ [ Query { index: 0, val: 2 } ], [], [ Query { index: 2, val: 5 } ], [ Query { index: 1, val: 2 } ]]\\n    let res = Array(qn).fill(0);\\n    const dfs = (idx) => {\\n        let y = (1 << 19) + idx;\\n        while (y > 0) {\\n            freq[y]++;\\n            y >>= 1;\\n        }\\n        for (const qnode of queriesByNode[idx]) {\\n            let j = qnode.index, x = qnode.val;\\n            let cum = 0;\\n            let bit = 1 << 18;\\n            while (bit > 0) {\\n                let ii = ((1 << 19) ^ cum ^ x ^ bit) / bit >> 0;\\n                if (freq[ii] > 0) cum += bit;\\n                bit >>= 1;\\n            }\\n            res[j] = cum;\\n        }\\n        for (const child of children[idx]) dfs(child);\\n        y = (1 << 19) + idx;\\n        while (y > 0) {\\n            freq[y]--;\\n            y >>= 1;\\n        }\\n    };\\n    dfs(root);\\n    return res;\\n};\\n\\nconst initializeGraph = (n) => {\\n    let G = [];\\n    for (let i = 0; i < n; i++) G.push([]);\\n    return G;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nfunction Query(index, val) {\\n    this.index = index;\\n    this.val = val;\\n}\\n\\nconst maxGeneticDifference = (parents, queries) => {\\n    let pn = parents.length, qn = queries.length;\\n    let root = parents.indexOf(-1);\\n    let children = initializeGraph(pn); // save each tree node\\'s child by index\\n    for (let i = 0; i < pn; i++) {\\n        if (i != root) {\\n            children[parents[i]].push(i);\\n        }\\n    }\\n\\t// Example 1: children now is [ [ 1 ], [ 2, 3 ], [], []]\\n    let freq = Array(1 << 20).fill(0);\\n    let queriesByNode = initializeGraph(pn);\\n    for (let i = 0; i < qn; i++) {\\n        let query = queries[i];\\n        queriesByNode[query[0]].push(new Query(i, query[1]));\\n    }\\n\\t// Example 1, queryByNode now is\\n\\t// [ [ Query { index: 0, val: 2 } ], [], [ Query { index: 2, val: 5 } ], [ Query { index: 1, val: 2 } ]]\\n    let res = Array(qn).fill(0);\\n    const dfs = (idx) => {\\n        let y = (1 << 19) + idx;\\n        while (y > 0) {\\n            freq[y]++;\\n            y >>= 1;\\n        }\\n        for (const qnode of queriesByNode[idx]) {\\n            let j = qnode.index, x = qnode.val;\\n            let cum = 0;\\n            let bit = 1 << 18;\\n            while (bit > 0) {\\n                let ii = ((1 << 19) ^ cum ^ x ^ bit) / bit >> 0;\\n                if (freq[ii] > 0) cum += bit;\\n                bit >>= 1;\\n            }\\n            res[j] = cum;\\n        }\\n        for (const child of children[idx]) dfs(child);\\n        y = (1 << 19) + idx;\\n        while (y > 0) {\\n            freq[y]--;\\n            y >>= 1;\\n        }\\n    };\\n    dfs(root);\\n    return res;\\n};\\n\\nconst initializeGraph = (n) => {\\n    let G = [];\\n    for (let i = 0; i < n; i++) G.push([]);\\n    return G;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345243,
                "title": "c-use-vector-instead-of-trie",
                "content": "```\\nclass Solution {\\n    \\n    void add(vector<vector<int>> &have, int x) {\\n        for (int i = 17; i >= 0; --i) {\\n            ++have[i][(x >> i) << i];\\n        }\\n    }\\n    \\n    void remove(vector<vector<int>> &have, int x) {\\n        for (int i = 17; i >= 0; --i) {\\n            --have[i][(x >> i) << i];\\n        } \\n    }\\n    \\n    int find(const vector<vector<int>> &have, int x) {\\n        int temp = 0;\\n        for (int i = 17; i >= 0; --i) {\\n           temp |= (((x >> i) & 1) ^ 1) << i;\\n            if (have[i][temp] == 0) {\\n                temp ^= 1 << i;\\n            }\\n        }\\n        return temp ^ x;\\n    }\\n    \\n    void dfs(int x, int p, const vector<vector<int>> &con, const vector<vector<vector<int>>> &q, vector<vector<int>> &have, vector<int> &ans) {\\n        add(have, x);\\n        for (const auto& v : q[x]) {\\n            ans[v[1]] = find(have, v[0]);\\n        }\\n        for (int y : con[x]) {\\n            if (y != p) {\\n                dfs(y, x, con, q, have, ans);\\n            }\\n            \\n        }\\n        remove(have, x);\\n        \\n    }\\n    \\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        const int n = parents.size();\\n        vector<vector<int>> con(n);\\n        int root = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (parents[i] >= 0) {\\n                con[i].push_back(parents[i]);\\n                con[parents[i]].push_back(i);\\n            } else {\\n                root = i;\\n            }\\n        }\\n        const int m = queries.size();\\n        vector<int> ans(m);\\n        vector<vector<vector<int>>> q(n);\\n        for (int i = 0; i < m; ++i) {\\n            q[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        vector<vector<int>> have(18, vector<int>(1 << 18));\\n        dfs(root, -1, con, q, have, ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    void add(vector<vector<int>> &have, int x) {\\n        for (int i = 17; i >= 0; --i) {\\n            ++have[i][(x >> i) << i];\\n        }\\n    }\\n    \\n    void remove(vector<vector<int>> &have, int x) {\\n        for (int i = 17; i >= 0; --i) {\\n            --have[i][(x >> i) << i];\\n        } \\n    }\\n    \\n    int find(const vector<vector<int>> &have, int x) {\\n        int temp = 0;\\n        for (int i = 17; i >= 0; --i) {\\n           temp |= (((x >> i) & 1) ^ 1) << i;\\n            if (have[i][temp] == 0) {\\n                temp ^= 1 << i;\\n            }\\n        }\\n        return temp ^ x;\\n    }\\n    \\n    void dfs(int x, int p, const vector<vector<int>> &con, const vector<vector<vector<int>>> &q, vector<vector<int>> &have, vector<int> &ans) {\\n        add(have, x);\\n        for (const auto& v : q[x]) {\\n            ans[v[1]] = find(have, v[0]);\\n        }\\n        for (int y : con[x]) {\\n            if (y != p) {\\n                dfs(y, x, con, q, have, ans);\\n            }\\n            \\n        }\\n        remove(have, x);\\n        \\n    }\\n    \\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        const int n = parents.size();\\n        vector<vector<int>> con(n);\\n        int root = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (parents[i] >= 0) {\\n                con[i].push_back(parents[i]);\\n                con[parents[i]].push_back(i);\\n            } else {\\n                root = i;\\n            }\\n        }\\n        const int m = queries.size();\\n        vector<int> ans(m);\\n        vector<vector<vector<int>>> q(n);\\n        for (int i = 0; i < m; ++i) {\\n            q[queries[i][0]].push_back({queries[i][1], i});\\n        }\\n        vector<vector<int>> have(18, vector<int>(1 << 18));\\n        dfs(root, -1, con, q, have, ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345222,
                "title": "c",
                "content": "```\\n// val < 2e15\\nstruct node\\n{\\n    node* arr[2];\\n    int cnt[2];\\n    node()\\n    {\\n        arr[0] = nullptr;\\n        arr[1] = nullptr;\\n        cnt[0] = 0;\\n        cnt[1] = 0;\\n    }\\n    void add(int v, int level)\\n    {\\n        if (level < 0) return;\\n        int bit = 1 << level;\\n        int index = 0;\\n        if ((v & bit) == bit)\\n        {\\n            index = 1;\\n        } else {\\n            index = 0;\\n        }\\n        if (arr[index] == nullptr)\\n        {\\n            arr[index] = new node();   \\n            \\n        }\\n        cnt[index]++;\\n        arr[index]->add(v, level - 1);\\n    }\\n    \\n    void remove(int v, int level)\\n    {\\n        if (level < 0) return;\\n        int bit = 1 << level;\\n        int index = 0;\\n        if ((v & bit) == bit)\\n        {\\n            index = 1;\\n        } else {\\n            index = 0;\\n        }\\n        node* c = nullptr;\\n        if (arr[index] != nullptr)\\n        {\\n            c = arr[index];          \\n            c->remove(v, level - 1);\\n            cnt[index]--;\\n            if (cnt[index] == 0)\\n            {\\n                arr[index] = nullptr;\\n            }\\n        }\\n    }\\n    \\n    void search(int& v, const int x, int level)\\n    {\\n        if (level < 0) return;\\n        int bit = 1 << level;\\n        int x1 = x & bit;\\n        int index = 1;\\n        if (x1 != 0) index = 0;\\n        if (arr[index] == nullptr)\\n        {\\n            index = 1 - index;\\n        }\\n        v = ((index << level) | v);\\n        arr[index]->search(v, x, level - 1);\\n    }\\n};\\nclass Solution {\\npublic:\\n    const static int ml = 16;\\n    int n;\\n    vector<node*> dp;\\n    vector<vector<int>> qs;\\n    vector<vector<int>> child;\\n    vector<int> ans;\\n    void dfs(int c, node* r, vector<vector<int>>& queries)\\n    {\\n        //cout << \"in:\" << c << \",\"<<  r->cnt[0] << \",\" << r->cnt[1] << endl;\\n        r->add(c, ml);\\n        \\n        \\n        if (!qs[c].empty())\\n        {\\n            for (auto& q : qs[c])\\n            {\\n                \\n                int v = 0;\\n                r->search(v, queries[q][1], ml);\\n                cout << q << \",\" << v << \",\" << queries[q][1] << endl;\\n                ans[q] = v ^ queries[q][1];\\n            }\\n        }\\n        for (auto& cl : child[c])\\n        {\\n            dfs(cl, r, queries);\\n        }\\n        r->remove(c, ml);\\n        //cout << \"out:\" << c << \",\" << r->cnt[0] << \",\" << r->cnt[1] << endl;\\n        \\n        return;\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        n = parents.size();\\n        \\n        qs.resize(n);\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            qs[queries[i][0]].push_back(i);\\n        }\\n        ans.resize(queries.size());\\n        child.resize(n);\\n        int root = -1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (parents[i] == -1)\\n            {\\n                root = i;\\n            }\\n            else\\n            {\\n                child[parents[i]].push_back(i);\\n            }\\n        }\\n        \\n        \\n        node* r = new node();\\n        dfs(root,  r, queries);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// val < 2e15\\nstruct node\\n{\\n    node* arr[2];\\n    int cnt[2];\\n    node()\\n    {\\n        arr[0] = nullptr;\\n        arr[1] = nullptr;\\n        cnt[0] = 0;\\n        cnt[1] = 0;\\n    }\\n    void add(int v, int level)\\n    {\\n        if (level < 0) return;\\n        int bit = 1 << level;\\n        int index = 0;\\n        if ((v & bit) == bit)\\n        {\\n            index = 1;\\n        } else {\\n            index = 0;\\n        }\\n        if (arr[index] == nullptr)\\n        {\\n            arr[index] = new node();   \\n            \\n        }\\n        cnt[index]++;\\n        arr[index]->add(v, level - 1);\\n    }\\n    \\n    void remove(int v, int level)\\n    {\\n        if (level < 0) return;\\n        int bit = 1 << level;\\n        int index = 0;\\n        if ((v & bit) == bit)\\n        {\\n            index = 1;\\n        } else {\\n            index = 0;\\n        }\\n        node* c = nullptr;\\n        if (arr[index] != nullptr)\\n        {\\n            c = arr[index];          \\n            c->remove(v, level - 1);\\n            cnt[index]--;\\n            if (cnt[index] == 0)\\n            {\\n                arr[index] = nullptr;\\n            }\\n        }\\n    }\\n    \\n    void search(int& v, const int x, int level)\\n    {\\n        if (level < 0) return;\\n        int bit = 1 << level;\\n        int x1 = x & bit;\\n        int index = 1;\\n        if (x1 != 0) index = 0;\\n        if (arr[index] == nullptr)\\n        {\\n            index = 1 - index;\\n        }\\n        v = ((index << level) | v);\\n        arr[index]->search(v, x, level - 1);\\n    }\\n};\\nclass Solution {\\npublic:\\n    const static int ml = 16;\\n    int n;\\n    vector<node*> dp;\\n    vector<vector<int>> qs;\\n    vector<vector<int>> child;\\n    vector<int> ans;\\n    void dfs(int c, node* r, vector<vector<int>>& queries)\\n    {\\n        //cout << \"in:\" << c << \",\"<<  r->cnt[0] << \",\" << r->cnt[1] << endl;\\n        r->add(c, ml);\\n        \\n        \\n        if (!qs[c].empty())\\n        {\\n            for (auto& q : qs[c])\\n            {\\n                \\n                int v = 0;\\n                r->search(v, queries[q][1], ml);\\n                cout << q << \",\" << v << \",\" << queries[q][1] << endl;\\n                ans[q] = v ^ queries[q][1];\\n            }\\n        }\\n        for (auto& cl : child[c])\\n        {\\n            dfs(cl, r, queries);\\n        }\\n        r->remove(c, ml);\\n        //cout << \"out:\" << c << \",\" << r->cnt[0] << \",\" << r->cnt[1] << endl;\\n        \\n        return;\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        n = parents.size();\\n        \\n        qs.resize(n);\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            qs[queries[i][0]].push_back(i);\\n        }\\n        ans.resize(queries.size());\\n        child.resize(n);\\n        int root = -1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (parents[i] == -1)\\n            {\\n                root = i;\\n            }\\n            else\\n            {\\n                child[parents[i]].push_back(i);\\n            }\\n        }\\n        \\n        \\n        node* r = new node();\\n        dfs(root,  r, queries);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1345216,
                "title": "persistent-trie-dp",
                "content": "For each node generate trie from the parent and use persistent trie so it only has new nodes along the bits of the new value and reuses the other nodes from the parent trie. Then for each query check the trie to find the maximum.\\n\\n```\\ntype node struct {\\n    zero, one *node\\n}\\n\\ntype trie struct {\\n    root *node        \\n}\\n\\nfunc (t *trie) add(val int) *trie {\\n    v := &node{t.root.zero, t.root.one}\\n    res := &trie{v}       \\n    \\n    old := t.root\\n    for i := 17; i >= 0; i-- {\\n        if val & (1 << i) != 0 {\\n            old = old.one\\n            if old == nil {\\n                old = &node{nil, nil}\\n            }\\n            v.one = &node{old.zero, old.one}\\n            v = v.one\\n        } else {\\n            old = old.zero\\n            if old == nil {\\n                old = &node{nil, nil}\\n            }\\n            v.zero = &node{old.zero, old.one}\\n            v = v.zero\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc (t *trie) max(u int) int {\\n    v := t.root\\n    res := 0\\n    for i := 17; i >= 0; i-- {\\n        if u & (1 << i) != 0 {\\n            if v.zero != nil {\\n                res |= (1 << i)\\n                v = v.zero\\n            } else {\\n                v = v.one\\n            }\\n        } else {\\n            if v.one != nil {\\n                res |= (1 << i)\\n                v = v.one\\n            } else {\\n                v = v.zero\\n            }\\n        }           \\n    }   \\n    \\n    return res\\n}\\n\\nfunc maxGeneticDifference(p []int, queries [][]int) []int { \\n    n := len(p)\\n    f := make([]*trie, n)\\n    \\n    var dp func(v int) *trie\\n    dp = func(v int) *trie {\\n        if v == -1 {\\n            return &trie{&node{nil, nil}}\\n        }\\n        \\n        if f[v] != nil {\\n            return f[v]\\n        }\\n        \\n        f[v] = dp(p[v]).add(v)\\n        return f[v]\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        dp(i)\\n    }\\n    \\n    res := []int{}\\n    for _, q := range queries {\\n        res = append(res, f[q[0]].max(q[1]))\\n    }\\n    \\n    return res\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\ntype node struct {\\n    zero, one *node\\n}\\n\\ntype trie struct {\\n    root *node        \\n}\\n\\nfunc (t *trie) add(val int) *trie {\\n    v := &node{t.root.zero, t.root.one}\\n    res := &trie{v}       \\n    \\n    old := t.root\\n    for i := 17; i >= 0; i-- {\\n        if val & (1 << i) != 0 {\\n            old = old.one\\n            if old == nil {\\n                old = &node{nil, nil}\\n            }\\n            v.one = &node{old.zero, old.one}\\n            v = v.one\\n        } else {\\n            old = old.zero\\n            if old == nil {\\n                old = &node{nil, nil}\\n            }\\n            v.zero = &node{old.zero, old.one}\\n            v = v.zero\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc (t *trie) max(u int) int {\\n    v := t.root\\n    res := 0\\n    for i := 17; i >= 0; i-- {\\n        if u & (1 << i) != 0 {\\n            if v.zero != nil {\\n                res |= (1 << i)\\n                v = v.zero\\n            } else {\\n                v = v.one\\n            }\\n        } else {\\n            if v.one != nil {\\n                res |= (1 << i)\\n                v = v.one\\n            } else {\\n                v = v.zero\\n            }\\n        }           \\n    }   \\n    \\n    return res\\n}\\n\\nfunc maxGeneticDifference(p []int, queries [][]int) []int { \\n    n := len(p)\\n    f := make([]*trie, n)\\n    \\n    var dp func(v int) *trie\\n    dp = func(v int) *trie {\\n        if v == -1 {\\n            return &trie{&node{nil, nil}}\\n        }\\n        \\n        if f[v] != nil {\\n            return f[v]\\n        }\\n        \\n        f[v] = dp(p[v]).add(v)\\n        return f[v]\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        dp(i)\\n    }\\n    \\n    res := []int{}\\n    for _, q := range queries {\\n        res = append(res, f[q[0]].max(q[1]))\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345188,
                "title": "c-trie-dfs-100-time-1756-ms-100-space",
                "content": "1) Represent all node values and queriy values in 31 bit binary\\n2) Use a Trie tree to with adding a count at each node for adding & removing node values. 0 acount on a node means that the node \"does not\" exist. \\n3) dfs to a) add node value to the Trie tree; b) answer queries regarding the node; c) recuisively call the the children; d) remove the node value from the Trie treee. \\n~~~\\nclass Solution {\\n    struct Trie {\\n        Trie *children[2];\\n        int count;\\n        Trie() {\\n            children[0] = nullptr;\\n            children[1] = nullptr;\\n            count = 0;\\n        }\\n    };\\n    Trie *Treeroot;\\n    void add(vector<int> d) {\\n        Trie *ptr = Treeroot;\\n        for (int i = 30; i >= 0; --i) {\\n            if (ptr->children[d[i]] == nullptr) ptr->children[d[i]] = new Trie();\\n            ptr = ptr->children[d[i]];\\n            ++ptr->count;\\n        }\\n    }\\n    void remove(vector<int> d) {\\n        Trie *ptr = Treeroot;\\n        for (int i = 30; i >= 0; --i) {\\n            --ptr->children[d[i]]->count;\\n            ptr = ptr->children[d[i]];\\n        }\\n    }\\n    \\npublic:\\n    int power;\\n    unordered_map<int, vector<int>> mp;\\n    unordered_map<int, vector<vector<int>>> qq;\\n    void collect(vector<vector<int>> &data, int root, vector<int> &ret) {\\n        add(data[root]);\\n        if (qq.find(root) != qq.end()) {\\n            for (auto &v: qq[root]) {\\n                Trie *ptr = Treeroot;\\n                int temp = power, res = 0, pos = 0, t = v[0];\\n                vector<int> d(31);\\n                while (t > 0) {\\n                    d[pos] = t % 2;\\n                    t /= 2;\\n                    ++pos;\\n                }\\n                for (int i = 30; i >= 0; --i) {\\n                    int b = d[i];\\n                    if (ptr->children[1 - b] != nullptr && ptr->children[1 - b]->count > 0) {\\n                        res += temp;\\n                        ptr = ptr->children[1 - b];\\n                    } else ptr = ptr->children[b];\\n                    temp /= 2;\\n                }\\n                ret[v[1]] = res;\\n            }\\n        }\\n        for (int &u: mp[root]) collect(data, u, ret);\\n        remove(data[root]);\\n    }\\n    \\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int base = 1;\\n        Treeroot = new Trie();\\n        for (int i = 0; i < 30; ++i) base *= 2;\\n        power = base;\\n        int root, n = parents.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (parents[i] == -1) root = i;\\n            else mp[parents[i]].push_back(i);\\n        } \\n        vector<vector<int>> data(n, vector<int>(31));\\n        for (int i = 0; i < n; ++i) {\\n            int pos = 0, temp = i;\\n            while (temp > 0) {\\n                data[i][pos] = temp % 2;\\n                temp /= 2;\\n                ++pos;\\n            }\\n        }\\n        vector<int> ret(queries.size());\\n        \\n        for (int i = 0; i < queries.size(); ++i) {\\n            vector<int> &q = queries[i];\\n            qq[q[0]].push_back(vector<int>{q[1], i});\\n        }\\n        collect(data, root, ret);\\n        return ret;\\n    }\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    struct Trie {\\n        Trie *children[2];\\n        int count;\\n        Trie() {\\n            children[0] = nullptr;\\n            children[1] = nullptr;\\n            count = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1345171,
                "title": "bit-trie-dfs",
                "content": "```\\nstruct trie{\\n    struct trie* par;\\n    struct trie* left;\\n    struct trie* right;\\n};\\n\\nvoid print(struct trie *rr){\\n    int cnt=0;\\n    while(rr!=NULL &&(rr->left || rr->right)){\\n        if(rr->left!=NULL){\\n            cout<<0;\\n            rr=rr->left;\\n        }\\n        else if(rr->right!=NULL){\\n            cout<<1;\\n            rr=rr->right;\\n        }\\n    }\\n}\\nstruct trie* insert(struct trie *rr, int x){\\n    struct trie *zz = rr;\\n    for(int j=20;j>=0;--j){\\n        int ll = (1<<j)&x;\\n        if(ll){\\n            if(rr->right!=NULL)rr=rr->right;\\n            else{\\n                struct trie *xx = new trie();\\n                xx->par = rr;\\n                rr->right = xx;\\n                xx->left = NULL;\\n                xx->right = NULL;\\n                rr=xx;\\n            }\\n        }\\n        else{    \\n            if(rr->left!=NULL)rr = rr->left;\\n            else{\\n                struct trie *xx = new trie();\\n                xx->par = rr;\\n                rr->left = xx;\\n                xx->left = NULL;\\n                xx->right = NULL;\\n                rr=xx;\\n            }\\n        }\\n    }\\n    return zz;\\n}\\nstruct trie* del(struct trie *rr, int x){\\n    struct trie* zz=rr;\\n    int i=20;\\n    while(i>=0&&(rr->left||rr->right)){\\n        if(x&(1<<i))rr=rr->right;\\n        else rr=rr->left;\\n        i--;\\n    }\\n    while(rr!=NULL && rr->left==NULL and rr->right == NULL){\\n       // cout<<\"hello\\\\n\";\\n        struct trie *pp = rr;\\n        rr = rr->par;\\n        if(rr==NULL){\\n            return zz;\\n        }\\n        if(rr->left==pp)rr->left=NULL;\\n        if(rr->right==pp)rr->right = NULL;\\n    }\\n    return zz;\\n}\\nint f(struct trie *rr, int x){\\n    int ans = 0;\\n    for(int i=20;i>=0;--i){\\n        int zz=(1<<i)&x;\\n        if(zz){\\n            if(rr->left!=NULL){\\n                rr=rr->left;\\n                ans = ans + (1<<i);\\n            }\\n            else {\\n                if(rr->right!=NULL){\\n                    rr=rr->right;\\n                }\\n            }\\n        }\\n        else{\\n            if(rr->right!=NULL){\\n                rr=rr->right;\\n                ans = ans + (1<<i);\\n            }\\n            else{\\n                if(rr->left!=NULL)rr=rr->left;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\nvoid dfs(vector<vector<int> > &v, int vis[], int src, struct trie *rr,vector<pair<int,int> > qq[],map<pair<int,int>,int> &mp){\\n       rr = insert(rr,src);\\n       for(int i=0;i<qq[src].size();++i){\\n          pair<int,int> pp=qq[src][i];\\n        mp[qq[src][i]] = f(rr,qq[src][i].second);\\n      }\\n    for(auto x:v[src]){\\n        dfs(v,vis,x,rr,qq,mp);\\n    }\\n    del(rr,src);\\n}\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& p, vector<vector<int>>& q) {\\n        int n=p.size();\\n        vector<vector<int> > v(n+4);\\n        int root=-1;\\n        for(int i=0;i<p.size();++i){\\n            int x = p[i];\\n            if(x==-1){\\n                root=i;\\n                continue;\\n            }\\n            v[x].push_back(i);\\n        }\\n        struct trie* rr = new trie();\\n        rr->par = NULL;\\n        rr->right = NULL;\\n        rr->left = NULL;\\n        vector<pair<int,int> > qq[n+1];\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<q.size();++i){\\n            qq[q[i][0]].push_back({q[i][0],q[i][1]});\\n        }\\n        int vis[n+1];\\n        memset(vis,0,sizeof(vis));\\n        dfs(v,vis,root,rr,qq,mp);\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            res.push_back(mp[{q[i][0],q[i][1]}]);\\n        }\\n        return res;\\n        \\n    }\\n};```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nstruct trie{\\n    struct trie* par;\\n    struct trie* left;\\n    struct trie* right;\\n};\\n\\nvoid print(struct trie *rr){\\n    int cnt=0;\\n    while(rr!=NULL &&(rr->left || rr->right)){\\n        if(rr->left!=NULL){\\n            cout<<0;\\n            rr=rr->left;\\n        }\\n        else if(rr->right!=NULL){\\n            cout<<1;\\n            rr=rr->right;\\n        }\\n    }\\n}\\nstruct trie* insert(struct trie *rr, int x){\\n    struct trie *zz = rr;\\n    for(int j=20;j>=0;--j){\\n        int ll = (1<<j)&x;\\n        if(ll){\\n            if(rr->right!=NULL)rr=rr->right;\\n            else{\\n                struct trie *xx = new trie();\\n                xx->par = rr;\\n                rr->right = xx;\\n                xx->left = NULL;\\n                xx->right = NULL;\\n                rr=xx;\\n            }\\n        }\\n        else{    \\n            if(rr->left!=NULL)rr = rr->left;\\n            else{\\n                struct trie *xx = new trie();\\n                xx->par = rr;\\n                rr->left = xx;\\n                xx->left = NULL;\\n                xx->right = NULL;\\n                rr=xx;\\n            }\\n        }\\n    }\\n    return zz;\\n}\\nstruct trie* del(struct trie *rr, int x){\\n    struct trie* zz=rr;\\n    int i=20;\\n    while(i>=0&&(rr->left||rr->right)){\\n        if(x&(1<<i))rr=rr->right;\\n        else rr=rr->left;\\n        i--;\\n    }\\n    while(rr!=NULL && rr->left==NULL and rr->right == NULL){\\n       // cout<<\"hello\\\\n\";\\n        struct trie *pp = rr;\\n        rr = rr->par;\\n        if(rr==NULL){\\n            return zz;\\n        }\\n        if(rr->left==pp)rr->left=NULL;\\n        if(rr->right==pp)rr->right = NULL;\\n    }\\n    return zz;\\n}\\nint f(struct trie *rr, int x){\\n    int ans = 0;\\n    for(int i=20;i>=0;--i){\\n        int zz=(1<<i)&x;\\n        if(zz){\\n            if(rr->left!=NULL){\\n                rr=rr->left;\\n                ans = ans + (1<<i);\\n            }\\n            else {\\n                if(rr->right!=NULL){\\n                    rr=rr->right;\\n                }\\n            }\\n        }\\n        else{\\n            if(rr->right!=NULL){\\n                rr=rr->right;\\n                ans = ans + (1<<i);\\n            }\\n            else{\\n                if(rr->left!=NULL)rr=rr->left;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\nvoid dfs(vector<vector<int> > &v, int vis[], int src, struct trie *rr,vector<pair<int,int> > qq[],map<pair<int,int>,int> &mp){\\n       rr = insert(rr,src);\\n       for(int i=0;i<qq[src].size();++i){\\n          pair<int,int> pp=qq[src][i];\\n        mp[qq[src][i]] = f(rr,qq[src][i].second);\\n      }\\n    for(auto x:v[src]){\\n        dfs(v,vis,x,rr,qq,mp);\\n    }\\n    del(rr,src);\\n}\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& p, vector<vector<int>>& q) {\\n        int n=p.size();\\n        vector<vector<int> > v(n+4);\\n        int root=-1;\\n        for(int i=0;i<p.size();++i){\\n            int x = p[i];\\n            if(x==-1){\\n                root=i;\\n                continue;\\n            }\\n            v[x].push_back(i);\\n        }\\n        struct trie* rr = new trie();\\n        rr->par = NULL;\\n        rr->right = NULL;\\n        rr->left = NULL;\\n        vector<pair<int,int> > qq[n+1];\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<q.size();++i){\\n            qq[q[i][0]].push_back({q[i][0],q[i][1]});\\n        }\\n        int vis[n+1];\\n        memset(vis,0,sizeof(vis));\\n        dfs(v,vis,root,rr,qq,mp);\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            res.push_back(mp[{q[i][0],q[i][1]}]);\\n        }\\n        return res;\\n        \\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 1345142,
                "title": "trie-dfs",
                "content": "```\\nstruct Trie {\\n    Trie* left;\\n    Trie* right;\\n    void insert(int num) {\\n        insert(num, 19);\\n    }\\n    void insert(int num, int pos) {\\n        bool bit = num & (1 << pos);\\n        if (bit) {\\n            if (right == nullptr) {\\n                right = new Trie();\\n            }\\n            if (pos > 0) {\\n                right->insert(num, pos - 1);\\n            }\\n        } else {\\n            if (left == nullptr) {\\n                left = new Trie();\\n            }\\n            if (pos > 0) {\\n                left->insert(num, pos - 1);\\n            }\\n        }\\n    }\\n    int maximize(int num) {\\n        return maximize(num, 19);\\n    }\\n    int maximize(int num, int pos) {\\n        bool bit = num & (1 << pos);\\n        if (bit) {\\n            if (left) {\\n                return (1 << pos) | (pos ? left->maximize(num, pos - 1) : 0);\\n            } else {\\n                return pos ? right->maximize(num, pos - 1) : 0;\\n            }\\n        } else {\\n            if (right) {\\n                return (1 << pos) | (pos ? right->maximize(num, pos - 1) : 0);\\n            } else {\\n                return pos ? left->maximize(num, pos - 1) : 0;\\n            }\\n        }\\n    }\\n    void remove(int num) {\\n        remove(num, 19);\\n    }\\n    bool remove(int num, int pos) {\\n        bool bit = num & (1 << pos);\\n        if (pos == 0) {\\n            if (bit) {\\n                right = nullptr;\\n                return left == nullptr;\\n            } else {\\n                left = nullptr;\\n                return right == nullptr;\\n            }\\n        } else {\\n            if (bit) {\\n                bool rec = right->remove(num, pos - 1);\\n                if (rec) {\\n                    right = nullptr;\\n                    return left == nullptr;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                bool rec = left->remove(num, pos - 1);\\n                if (rec) {\\n                    left = nullptr;\\n                    return right == nullptr;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        n = parents.size();\\n        qn = queries.size();\\n        ans = vector<int>(qn, 0);\\n        for (int i = 0; i < qn; ++i) {\\n            qmap[queries[i][0]].emplace_back(queries[i][1], i);\\n        }\\n        \\n        graph = vector<vector<int>>(n, vector<int>());\\n        for (int i = 0; i < n; ++i) {\\n            int j = parents[i];\\n            if (j != -1) {\\n                graph[j].emplace_back(i);\\n            } else {\\n                root = i;\\n            }\\n        }\\n        \\n        dfs(root);\\n        return ans;\\n    }\\n    \\nprivate:\\n    void dfs(int nodeId) {\\n        trie.insert(nodeId);\\n        if (auto iter = qmap.find(nodeId); iter != qmap.end()) {\\n            for (auto [val, index]: iter->second) {\\n                ans[index] = trie.maximize(val);\\n            }\\n        }\\n        for (auto childId: graph[nodeId]) {\\n            dfs(childId);\\n        }\\n        trie.remove(nodeId);\\n    }\\n    \\n    int n;\\n    int qn;\\n    vector<int> ans;\\n    unordered_map<int, vector<pair<int, int>>> qmap;\\n    vector<vector<int>> graph;\\n    int root;\\n    Trie trie;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Trie {\\n    Trie* left;\\n    Trie* right;\\n    void insert(int num) {\\n        insert(num, 19);\\n    }\\n    void insert(int num, int pos) {\\n        bool bit = num & (1 << pos);\\n        if (bit) {\\n            if (right == nullptr) {\\n                right = new Trie();\\n            }\\n            if (pos > 0) {\\n                right->insert(num, pos - 1);\\n            }\\n        } else {\\n            if (left == nullptr) {\\n                left = new Trie();\\n            }\\n            if (pos > 0) {\\n                left->insert(num, pos - 1);\\n            }\\n        }\\n    }\\n    int maximize(int num) {\\n        return maximize(num, 19);\\n    }\\n    int maximize(int num, int pos) {\\n        bool bit = num & (1 << pos);\\n        if (bit) {\\n            if (left) {\\n                return (1 << pos) | (pos ? left->maximize(num, pos - 1) : 0);\\n            } else {\\n                return pos ? right->maximize(num, pos - 1) : 0;\\n            }\\n        } else {\\n            if (right) {\\n                return (1 << pos) | (pos ? right->maximize(num, pos - 1) : 0);\\n            } else {\\n                return pos ? left->maximize(num, pos - 1) : 0;\\n            }\\n        }\\n    }\\n    void remove(int num) {\\n        remove(num, 19);\\n    }\\n    bool remove(int num, int pos) {\\n        bool bit = num & (1 << pos);\\n        if (pos == 0) {\\n            if (bit) {\\n                right = nullptr;\\n                return left == nullptr;\\n            } else {\\n                left = nullptr;\\n                return right == nullptr;\\n            }\\n        } else {\\n            if (bit) {\\n                bool rec = right->remove(num, pos - 1);\\n                if (rec) {\\n                    right = nullptr;\\n                    return left == nullptr;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                bool rec = left->remove(num, pos - 1);\\n                if (rec) {\\n                    left = nullptr;\\n                    return right == nullptr;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        n = parents.size();\\n        qn = queries.size();\\n        ans = vector<int>(qn, 0);\\n        for (int i = 0; i < qn; ++i) {\\n            qmap[queries[i][0]].emplace_back(queries[i][1], i);\\n        }\\n        \\n        graph = vector<vector<int>>(n, vector<int>());\\n        for (int i = 0; i < n; ++i) {\\n            int j = parents[i];\\n            if (j != -1) {\\n                graph[j].emplace_back(i);\\n            } else {\\n                root = i;\\n            }\\n        }\\n        \\n        dfs(root);\\n        return ans;\\n    }\\n    \\nprivate:\\n    void dfs(int nodeId) {\\n        trie.insert(nodeId);\\n        if (auto iter = qmap.find(nodeId); iter != qmap.end()) {\\n            for (auto [val, index]: iter->second) {\\n                ans[index] = trie.maximize(val);\\n            }\\n        }\\n        for (auto childId: graph[nodeId]) {\\n            dfs(childId);\\n        }\\n        trie.remove(nodeId);\\n    }\\n    \\n    int n;\\n    int qn;\\n    vector<int> ans;\\n    unordered_map<int, vector<pair<int, int>>> qmap;\\n    vector<vector<int>> graph;\\n    int root;\\n    Trie trie;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345110,
                "title": "query-what-are-the-reasons-for-tle-in-python3-but-not-java",
                "content": "Context:\\nDuring the contest timings , i wrote a python program using DFS + Trie, It got a TLE.  Runtime for the testcase was in range  **4000 - 6000 ms** on my console\\n\\nAfter the contest, wrote a line by line similar Java Based program. It got accepted with runtime around **500 ms**\\n\\nCan someone help me understand what makes my python code slow or are the time constraints not adjusted fairly across different languages. Any inputs to speedup python here will help. Thank you\\n\\nAttaching code:\\n\\nPython\\n```\\nclass Node:\\n    def __init__(self):\\n        self.arr = [None] * 2\\n        self.co = [0] * 2\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = Node()\\n    \\n    def add(self , x):\\n        self.root = self.addr(self.root , x , 18 , 1)\\n    \\n    def addr(self , n  , w , i , v):\\n        if i == -1:\\n            return n\\n        else:\\n            bit = (w >> i) & 1\\n            t = n.arr[bit]\\n            if not t:\\n                t = Node()\\n                n.arr[bit] = t\\n            \\n            n.co[bit] += v\\n            t = self.addr(t , w , i-1 , v)\\n            return n\\n                \\n    \\n    def remove(self , x):\\n        self.root = self.addr(self.root , x , 18 , -1)\\n    \\n    def eval(self , x):\\n        \\n        i = 18\\n        current = self.root\\n        ans = 0\\n        \\n        while i >= 0 and current:\\n            bit = (x >> i)&1\\n            exp = (bit+1)%2\\n            \\n            if current.co[exp]:\\n                current = current.arr[exp]\\n                ans = (ans << 1) | 1\\n            elif current.co[bit]:\\n                current = current.arr[bit]\\n                ans = (ans << 1)\\n            \\n            i -= 1\\n            \\n        return ans\\n        \\n        \\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        g = defaultdict(list)\\n        root = None\\n        \\n        trie = Trie()\\n        \\n        for i , x in enumerate(parents):\\n            g[x].append(i)\\n            if x == -1:\\n                root = i\\n        \\n        qmap = defaultdict(list)\\n        for i , x in enumerate(queries):\\n            qmap[x[0]].append([i , x[1] , -1])\\n         \\n        \\n        def dfs(n):\\n            trie.add(n)\\n            \\n            for li in qmap[n]:\\n                li[2] = trie.eval(li[1])\\n            \\n            for next in g[n]:\\n                dfs(next)\\n            \\n            trie.remove(n)\\n            \\n        dfs(root)\\n        \\n        ans = [-1]*len(queries)\\n        for k in qmap:\\n            for li in qmap[k]:\\n                ans[li[0]] = li[2]\\n        return ans\\n```\\n\\n\\nJava\\n```\\nclass Node {\\n    Node[] arr;\\n    int[] count;\\n    \\n    Node(){\\n        this.arr = new Node[2];\\n        this.count = new int[2];\\n    }\\n}\\n\\nclass Trie {\\n    int h;\\n    Node root;\\n    Trie(){\\n        this.h = 18;\\n        this.root = new Node();\\n    }\\n    \\n    public void add(int x){\\n        root = addr(root , x , 18 , 1);\\n    }\\n    \\n    public void remove(int x){\\n        root = addr(root , x , 18 , -1);\\n    }\\n    \\n    private Node addr(Node n , int x , int i , int v){\\n        if(i == -1){\\n            return n;\\n        }\\n        \\n        int bit = (x >> i) & 1;\\n        Node t = n.arr[bit];\\n        if(t == null){\\n            t = new Node();\\n            n.arr[bit] = t;\\n        }\\n        \\n        n.count[bit] += v;\\n        t = addr(t , x , i - 1 , v);\\n        return n;\\n    }\\n    \\n    public int eval(int x){\\n        \\n        Node current = root;\\n        int index = h;\\n      \\n        int ans = 0;\\n        \\n        while(current != null && index >= 0){\\n            int bit = (x >> index) & 1;\\n            int exp = (bit+1)%2;\\n            \\n            if(current.count[exp] > 0){\\n                ans = (ans << 1) | 1;\\n                current = current.arr[exp];\\n            }else{\\n                ans = (ans << 1) | 0;\\n                current = current.arr[bit];\\n            }\\n        \\n            index -= 1;\\n        }\\n        return ans;\\n        \\n    }\\n\\n}\\n\\nclass Solution {\\n    \\n    Trie trie;\\n    HashMap<Integer , List<Integer>> graph;\\n    HashMap<Integer , List<int[]>> qmap;\\n    \\n    private void dfs(int n){\\n        \\n        trie.add(n);\\n        \\n        for(int[] q : qmap.getOrDefault(n , new ArrayList<>())){\\n            q[2] = trie.eval(q[1]);\\n        }\\n        \\n        for(int next : graph.getOrDefault(n , new ArrayList<>())){\\n            dfs(next);\\n        }\\n        \\n        trie.remove(n);\\n    }\\n    \\n    \\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        trie = new Trie();\\n        qmap = new HashMap<>();\\n        graph = new HashMap<>();\\n        \\n        int k = 0;\\n        for(int[] q : queries){\\n            qmap.putIfAbsent(q[0] , new ArrayList<>());\\n            qmap.get(q[0]).add(new int[]{k++ , q[1] , -1});\\n        }\\n        \\n        int root = -1;\\n        for(int i = 0 ; i < parents.length ; i++){\\n            graph.putIfAbsent(parents[i] , new ArrayList<>());\\n            graph.get(parents[i]).add(i);\\n            if(parents[i] == -1){\\n                root = i;\\n            }\\n        }\\n        \\n        dfs(root);\\n    \\n        int[] ans = new int[queries.length];\\n        for(List<int[]> v : qmap.values()){\\n            for(int[] vv : v){\\n                ans[vv[0]] = vv[2];\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n    \\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.arr = [None] * 2\\n        self.co = [0] * 2\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = Node()\\n    \\n    def add(self , x):\\n        self.root = self.addr(self.root , x , 18 , 1)\\n    \\n    def addr(self , n  , w , i , v):\\n        if i == -1:\\n            return n\\n        else:\\n            bit = (w >> i) & 1\\n            t = n.arr[bit]\\n            if not t:\\n                t = Node()\\n                n.arr[bit] = t\\n            \\n            n.co[bit] += v\\n            t = self.addr(t , w , i-1 , v)\\n            return n\\n                \\n    \\n    def remove(self , x):\\n        self.root = self.addr(self.root , x , 18 , -1)\\n    \\n    def eval(self , x):\\n        \\n        i = 18\\n        current = self.root\\n        ans = 0\\n        \\n        while i >= 0 and current:\\n            bit = (x >> i)&1\\n            exp = (bit+1)%2\\n            \\n            if current.co[exp]:\\n                current = current.arr[exp]\\n                ans = (ans << 1) | 1\\n            elif current.co[bit]:\\n                current = current.arr[bit]\\n                ans = (ans << 1)\\n            \\n            i -= 1\\n            \\n        return ans\\n        \\n        \\nclass Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        g = defaultdict(list)\\n        root = None\\n        \\n        trie = Trie()\\n        \\n        for i , x in enumerate(parents):\\n            g[x].append(i)\\n            if x == -1:\\n                root = i\\n        \\n        qmap = defaultdict(list)\\n        for i , x in enumerate(queries):\\n            qmap[x[0]].append([i , x[1] , -1])\\n         \\n        \\n        def dfs(n):\\n            trie.add(n)\\n            \\n            for li in qmap[n]:\\n                li[2] = trie.eval(li[1])\\n            \\n            for next in g[n]:\\n                dfs(next)\\n            \\n            trie.remove(n)\\n            \\n        dfs(root)\\n        \\n        ans = [-1]*len(queries)\\n        for k in qmap:\\n            for li in qmap[k]:\\n                ans[li[0]] = li[2]\\n        return ans\\n```\n```\\nclass Node {\\n    Node[] arr;\\n    int[] count;\\n    \\n    Node(){\\n        this.arr = new Node[2];\\n        this.count = new int[2];\\n    }\\n}\\n\\nclass Trie {\\n    int h;\\n    Node root;\\n    Trie(){\\n        this.h = 18;\\n        this.root = new Node();\\n    }\\n    \\n    public void add(int x){\\n        root = addr(root , x , 18 , 1);\\n    }\\n    \\n    public void remove(int x){\\n        root = addr(root , x , 18 , -1);\\n    }\\n    \\n    private Node addr(Node n , int x , int i , int v){\\n        if(i == -1){\\n            return n;\\n        }\\n        \\n        int bit = (x >> i) & 1;\\n        Node t = n.arr[bit];\\n        if(t == null){\\n            t = new Node();\\n            n.arr[bit] = t;\\n        }\\n        \\n        n.count[bit] += v;\\n        t = addr(t , x , i - 1 , v);\\n        return n;\\n    }\\n    \\n    public int eval(int x){\\n        \\n        Node current = root;\\n        int index = h;\\n      \\n        int ans = 0;\\n        \\n        while(current != null && index >= 0){\\n            int bit = (x >> index) & 1;\\n            int exp = (bit+1)%2;\\n            \\n            if(current.count[exp] > 0){\\n                ans = (ans << 1) | 1;\\n                current = current.arr[exp];\\n            }else{\\n                ans = (ans << 1) | 0;\\n                current = current.arr[bit];\\n            }\\n        \\n            index -= 1;\\n        }\\n        return ans;\\n        \\n    }\\n\\n}\\n\\nclass Solution {\\n    \\n    Trie trie;\\n    HashMap<Integer , List<Integer>> graph;\\n    HashMap<Integer , List<int[]>> qmap;\\n    \\n    private void dfs(int n){\\n        \\n        trie.add(n);\\n        \\n        for(int[] q : qmap.getOrDefault(n , new ArrayList<>())){\\n            q[2] = trie.eval(q[1]);\\n        }\\n        \\n        for(int next : graph.getOrDefault(n , new ArrayList<>())){\\n            dfs(next);\\n        }\\n        \\n        trie.remove(n);\\n    }\\n    \\n    \\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n        trie = new Trie();\\n        qmap = new HashMap<>();\\n        graph = new HashMap<>();\\n        \\n        int k = 0;\\n        for(int[] q : queries){\\n            qmap.putIfAbsent(q[0] , new ArrayList<>());\\n            qmap.get(q[0]).add(new int[]{k++ , q[1] , -1});\\n        }\\n        \\n        int root = -1;\\n        for(int i = 0 ; i < parents.length ; i++){\\n            graph.putIfAbsent(parents[i] , new ArrayList<>());\\n            graph.get(parents[i]).add(i);\\n            if(parents[i] == -1){\\n                root = i;\\n            }\\n        }\\n        \\n        dfs(root);\\n    \\n        int[] ans = new int[queries.length];\\n        for(List<int[]> v : qmap.values()){\\n            for(int[] vv : v){\\n                ans[vv[0]] = vv[2];\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345093,
                "title": "test-case-too-strict-change-to-instead-of-passes",
                "content": "Time: O(18 * (N + M)), where N <= 10^5 is number of nodes, M <= 3 * 10^4 is number of queries.\\n\\nIf we change following code from ```best <<= 1```  to ```best *= 1```, it fails.\\nLeetcode\\'s problems usually do not fail a solutions just because some O(1) defects. \\n\\n```\\nstruct Node {\\n    // We cannot use vector here, because vector is slow.\\n    // vector<Node*> next = vector<Node*>(2, NULL);\\n    Node* next[2];\\n    Node() {\\n        fill(next, next + 2, nullptr);\\n    }\\n};\\nint M = 19;\\nclass Solution {\\npublic:\\n    vector<vector<pair<int,int>>> q; // query index, value\\n    vector<vector<int>> w;\\n    int n = 0; \\n    int root = 0;\\n    vector<int> ans;\\n    Node * trio = new Node();\\n    vector<int> getBi(int x) {\\n        vector<int> ans = vector<int>(20, 0);\\n        for (int i = 0; i < M; i++) {\\n            ans[M - 1 - i] = x % 2;\\n            x /= 2;\\n        }\\n        return ans;\\n    }\\n    void dfs(int cur) {\\n        vector<int> curBi = getBi(cur);\\n        insertTrio(curBi);\\n        for (auto i: q[cur]) {\\n            long long best = 0;\\n            vector<int> x = getBi(i.second);\\n            auto p = trio;\\n            for (int i = 0; i < M; i++) {\\n                // We cannot use multiply here, we need to use <<\\n                // best *= 2;\\n                best <<= 1;\\n                if (p->next[!x[i]]) {\\n                    best += 1;\\n                    p = p->next[!x[i]];\\n                } else {\\n                    p = p->next[x[i]];\\n                }\\n            }\\n            ans[i.first] = best;\\n        }\\n        for (auto next: w[cur]) {\\n            dfs(next);\\n        }\\n        erase(curBi, trio, 0);\\n    }\\n    void erase(vector<int> &curBi, Node *p, int d) {\\n        if (d == M-1) {\\n            p->next[curBi[d]] = NULL;\\n            return;\\n        }\\n        auto next = p->next[curBi[d]];\\n        erase(curBi, next, d+1);\\n        if (next->next[0] == NULL && next->next[1] == NULL) {\\n            p->next[curBi[d]] = NULL;\\n        }\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& pa, vector<vector<int>>& queries) {\\n    \\tint n = pa.size();\\n        ans = vector<int> (queries.size(), 0);\\n        q = vector<vector<pair<int,int>>> (n);\\n        w = vector<vector<int>>(n);\\n        for (int i = 0; i < queries.size(); i++) {\\n            q[queries[i][0]].push_back({i, queries[i][1]});\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (pa[i] >= 0) {\\n                w[pa[i]].push_back(i);    \\n            } else {\\n                root = i;\\n            }\\n        }\\n        \\n        dfs(root);\\n        return ans;\\n    }\\n    \\n    void insertTrio(vector<int> &x) {\\n        auto p = trio;\\n        for (int i = 0; i < M; i++) {\\n            if (p->next[x[i]] == NULL) {\\n                p->next[x[i]] = new Node();\\n            }\\n            p = p->next[x[i]];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```best <<= 1```\n```best *= 1```\n```\\nstruct Node {\\n    // We cannot use vector here, because vector is slow.\\n    // vector<Node*> next = vector<Node*>(2, NULL);\\n    Node* next[2];\\n    Node() {\\n        fill(next, next + 2, nullptr);\\n    }\\n};\\nint M = 19;\\nclass Solution {\\npublic:\\n    vector<vector<pair<int,int>>> q; // query index, value\\n    vector<vector<int>> w;\\n    int n = 0; \\n    int root = 0;\\n    vector<int> ans;\\n    Node * trio = new Node();\\n    vector<int> getBi(int x) {\\n        vector<int> ans = vector<int>(20, 0);\\n        for (int i = 0; i < M; i++) {\\n            ans[M - 1 - i] = x % 2;\\n            x /= 2;\\n        }\\n        return ans;\\n    }\\n    void dfs(int cur) {\\n        vector<int> curBi = getBi(cur);\\n        insertTrio(curBi);\\n        for (auto i: q[cur]) {\\n            long long best = 0;\\n            vector<int> x = getBi(i.second);\\n            auto p = trio;\\n            for (int i = 0; i < M; i++) {\\n                // We cannot use multiply here, we need to use <<\\n                // best *= 2;\\n                best <<= 1;\\n                if (p->next[!x[i]]) {\\n                    best += 1;\\n                    p = p->next[!x[i]];\\n                } else {\\n                    p = p->next[x[i]];\\n                }\\n            }\\n            ans[i.first] = best;\\n        }\\n        for (auto next: w[cur]) {\\n            dfs(next);\\n        }\\n        erase(curBi, trio, 0);\\n    }\\n    void erase(vector<int> &curBi, Node *p, int d) {\\n        if (d == M-1) {\\n            p->next[curBi[d]] = NULL;\\n            return;\\n        }\\n        auto next = p->next[curBi[d]];\\n        erase(curBi, next, d+1);\\n        if (next->next[0] == NULL && next->next[1] == NULL) {\\n            p->next[curBi[d]] = NULL;\\n        }\\n    }\\n    vector<int> maxGeneticDifference(vector<int>& pa, vector<vector<int>>& queries) {\\n    \\tint n = pa.size();\\n        ans = vector<int> (queries.size(), 0);\\n        q = vector<vector<pair<int,int>>> (n);\\n        w = vector<vector<int>>(n);\\n        for (int i = 0; i < queries.size(); i++) {\\n            q[queries[i][0]].push_back({i, queries[i][1]});\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (pa[i] >= 0) {\\n                w[pa[i]].push_back(i);    \\n            } else {\\n                root = i;\\n            }\\n        }\\n        \\n        dfs(root);\\n        return ans;\\n    }\\n    \\n    void insertTrio(vector<int> &x) {\\n        auto p = trio;\\n        for (int i = 0; i < M; i++) {\\n            if (p->next[x[i]] == NULL) {\\n                p->next[x[i]] = new Node();\\n            }\\n            p = p->next[x[i]];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345092,
                "title": "dfs-trie-greedy-bitmask-get-max-2-number-xor-result",
                "content": "### Related question\\nThis question can be solved using the same Trie method in question [Maximum XOR of Two Numbers in an Array ](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/). To understand why trie is used as an optimization for that question, we\\'d better understand its hashset based solution first. But we\\'ll skip the discussion of hashset solution. \\n\\n### Analysis\\nRecap on XOR property: \\n```\\na ^ b = c  \\u21D2 equals to \\u21D2  a ^ c = b \\na 0 1 1\\nb 0 1 0\\nc 0 0 1\\n```\\n\\nSuppose `tmp` is the max result of XOR of two number `a` and `b`.\\nIn `tmp`,  bit i can be set as long as there is two prefix b[31th bit ... ith bit] and c[31th bit ... ith bit] satisfy \\n`a ^ b = tmp ==> tmp ^ prefix c = prefix b in trie`\\nIn other words, our goal is to find a number `b` in trie that is the closest to `(!a)` by greedily trying from the highest bit. \\n\\nComplexity constraints on implementation:\\n```\\nm: len(queries) ~ O(3 * 10^4)\\nn: len(parents) ~  O(10^5)\\nconstructTrie: worse case O(n) ~ O(10^5)\\n```\\n\\n\\nOption1: O(n * m) cannot pass\\n```\\nfor each node_i: ~ O(m)\\n  get parents to generate trie ~ O(n)\\n  calculate max xor of two number in array\\n```\\n\\nOption2: O(n + m)\\n```\\npreprocessing:\\n  from queries: index -> node_i\\n  to   hashmap: node_i -> index\\n\\ndfs to traverse each node_i: \\n  each path from root to node_i, construct trie\\n  get xor of 2 number in array(path, including self)\\n```\\n\\n### Solution\\n\\n```\\nclass Solution {\\n  int[] res;\\n  int[][] queries;\\n  \\n  public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n    Map<Integer, List<Integer>> node2Index = new HashMap<>();  // for queries result\\n    int m = queries.length;\\n    int n = parents.length;\\n    res = new int[m];\\n    this.queries = queries;\\n    for (int i = 0; i < m; i++) {\\n      List<Integer> indices = node2Index.getOrDefault(queries[i][0], new ArrayList<>());\\n      indices.add(i);\\n      node2Index.put(queries[i][0], indices);\\n    }\\n    \\n    int root = 0;\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    for (int i = 0; i < n; i++) {\\n      if (parents[i] == -1) {\\n        root = i;\\n        continue;\\n      }\\n      List<Integer> children = graph.getOrDefault(parents[i], new ArrayList<>());\\n      children.add(i);\\n      graph.put(parents[i], children);\\n    }\\n    \\n    Trie trie = new Trie();\\n    trie.insert(root);\\n    dfs(root, graph, trie, node2Index);\\n    return res;\\n  }\\n  \\n  private void dfs(int node, Map<Integer, List<Integer>> graph, Trie trie, Map<Integer, List<Integer>> node2Index) {\\n    if (node2Index.containsKey(node)) {\\n      List<Integer> indices = node2Index.get(node);\\n      for (int qIndex : indices) {\\n        res[qIndex] = trie.search(queries[qIndex][1]);\\n      }\\n    }\\n    \\n    List<Integer> children = graph.get(node);\\n    if (children != null) {\\n      for (int child : children) {\\n        trie.insert(child);\\n        dfs(child, graph, trie, node2Index);\\n        trie.delete(child);\\n      }\\n    }\\n  }\\n  \\n  public class Trie {\\n    TrieNode root;\\n    public Trie() {\\n      root = new TrieNode();\\n    }\\n    \\n    public void insert(int x) {\\n      TrieNode cur = root;\\n      for (int i = 31; i >= 0; i--) {\\n        int bit = (x >>> i) & 1;\\n        TrieNode next = cur.next[bit];\\n        if (next == null) {\\n          next = new TrieNode();\\n          cur.next[bit] = next;\\n        }\\n        next.count++;\\n        cur = next;\\n      }\\n    }\\n    \\n    public int search(int x) {\\n      TrieNode cur = root;\\n      int res = 0;\\n      for (int i = 31; i >= 0; i--) {\\n        int bit = (x >>> i) & 1;\\n        TrieNode next = cur.next[1 - bit];\\n        if (next == null) {\\n          cur = cur.next[bit];\\n        }\\n        else {\\n          res |= (1 << i);\\n          cur = next;\\n        }\\n      }\\n      return res;\\n    }\\n    \\n    public void delete(int x) {\\n      TrieNode cur = root;\\n      for (int i = 31; i >= 0; i--) {\\n        int bit = (x >>> i) & 1;\\n        TrieNode next = cur.next[bit];\\n        next.count--;\\n        if (next.count == 0) {\\n          cur.next[bit] = null;\\n          break;\\n        }\\n        cur = next;\\n      }\\n    }\\n  }\\n  \\n  public class TrieNode {\\n    TrieNode[] next;\\n    int count;\\n    \\n    public TrieNode() {\\n      next = new TrieNode[2];\\n      count = 0;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\na ^ b = c  \\u21D2 equals to \\u21D2  a ^ c = b \\na 0 1 1\\nb 0 1 0\\nc 0 0 1\\n```\n```\\nm: len(queries) ~ O(3 * 10^4)\\nn: len(parents) ~  O(10^5)\\nconstructTrie: worse case O(n) ~ O(10^5)\\n```\n```\\nfor each node_i: ~ O(m)\\n  get parents to generate trie ~ O(n)\\n  calculate max xor of two number in array\\n```\n```\\npreprocessing:\\n  from queries: index -> node_i\\n  to   hashmap: node_i -> index\\n\\ndfs to traverse each node_i: \\n  each path from root to node_i, construct trie\\n  get xor of 2 number in array(path, including self)\\n```\n```\\nclass Solution {\\n  int[] res;\\n  int[][] queries;\\n  \\n  public int[] maxGeneticDifference(int[] parents, int[][] queries) {\\n    Map<Integer, List<Integer>> node2Index = new HashMap<>();  // for queries result\\n    int m = queries.length;\\n    int n = parents.length;\\n    res = new int[m];\\n    this.queries = queries;\\n    for (int i = 0; i < m; i++) {\\n      List<Integer> indices = node2Index.getOrDefault(queries[i][0], new ArrayList<>());\\n      indices.add(i);\\n      node2Index.put(queries[i][0], indices);\\n    }\\n    \\n    int root = 0;\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    for (int i = 0; i < n; i++) {\\n      if (parents[i] == -1) {\\n        root = i;\\n        continue;\\n      }\\n      List<Integer> children = graph.getOrDefault(parents[i], new ArrayList<>());\\n      children.add(i);\\n      graph.put(parents[i], children);\\n    }\\n    \\n    Trie trie = new Trie();\\n    trie.insert(root);\\n    dfs(root, graph, trie, node2Index);\\n    return res;\\n  }\\n  \\n  private void dfs(int node, Map<Integer, List<Integer>> graph, Trie trie, Map<Integer, List<Integer>> node2Index) {\\n    if (node2Index.containsKey(node)) {\\n      List<Integer> indices = node2Index.get(node);\\n      for (int qIndex : indices) {\\n        res[qIndex] = trie.search(queries[qIndex][1]);\\n      }\\n    }\\n    \\n    List<Integer> children = graph.get(node);\\n    if (children != null) {\\n      for (int child : children) {\\n        trie.insert(child);\\n        dfs(child, graph, trie, node2Index);\\n        trie.delete(child);\\n      }\\n    }\\n  }\\n  \\n  public class Trie {\\n    TrieNode root;\\n    public Trie() {\\n      root = new TrieNode();\\n    }\\n    \\n    public void insert(int x) {\\n      TrieNode cur = root;\\n      for (int i = 31; i >= 0; i--) {\\n        int bit = (x >>> i) & 1;\\n        TrieNode next = cur.next[bit];\\n        if (next == null) {\\n          next = new TrieNode();\\n          cur.next[bit] = next;\\n        }\\n        next.count++;\\n        cur = next;\\n      }\\n    }\\n    \\n    public int search(int x) {\\n      TrieNode cur = root;\\n      int res = 0;\\n      for (int i = 31; i >= 0; i--) {\\n        int bit = (x >>> i) & 1;\\n        TrieNode next = cur.next[1 - bit];\\n        if (next == null) {\\n          cur = cur.next[bit];\\n        }\\n        else {\\n          res |= (1 << i);\\n          cur = next;\\n        }\\n      }\\n      return res;\\n    }\\n    \\n    public void delete(int x) {\\n      TrieNode cur = root;\\n      for (int i = 31; i >= 0; i--) {\\n        int bit = (x >>> i) & 1;\\n        TrieNode next = cur.next[bit];\\n        next.count--;\\n        if (next.count == 0) {\\n          cur.next[bit] = null;\\n          break;\\n        }\\n        cur = next;\\n      }\\n    }\\n  }\\n  \\n  public class TrieNode {\\n    TrieNode[] next;\\n    int count;\\n    \\n    public TrieNode() {\\n      next = new TrieNode[2];\\n      count = 0;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345077,
                "title": "ac-c-dfs-trie-o-n-q-however-the-time-limit-is-too-strict",
                "content": "I implemented the expected O(N + Q) solution using DFS + Trie, however the same solution replacing the `next` Array with an UnorderedMap is TLE.\\n\\n```\\nclass Node {\\n    public:\\n    \\n    Node *next[2];                    // <- If use this line the solution is AC\\n    //unordered_map<int, Node*> next; // <- If use this line the solution is TLE\\n    \\n    int size;\\n    Node() {\\n        size = 0;\\n        next[0] = next[1] = NULL;\\n    }\\n};\\n\\nclass Solution {\\n    Node *root;\\n    vector<int> output;\\n    unordered_map<int, vector<pair<int, int> > > pending;\\n\\n    void insert(int n) {\\n        Node *cursor = root;\\n        for(int i=21;i>=0;i--) {\\n            int d = (n >> i) & 1;\\n            if (!cursor->next[d]) cursor->next[d] = new Node();\\n            cursor = cursor->next[d];\\n            cursor->size++;\\n        }\\n    }\\n    \\n    void erase(int n) {\\n        Node *cursor = root;\\n        for(int i=21;i>=0;i--) {\\n            int d = (n >> i) & 1;\\n            cursor = cursor->next[d];\\n            cursor->size--;\\n        }\\n    }\\n    \\n    int solve(int val) {\\n        int best = 0;\\n        Node *cursor = root;\\n        for(int i=21;i>=0;i--) {\\n            int active = (val >> i) & 1;\\n            if (cursor->next[ 1 - active ] && cursor->next[ 1 - active ]->size > 0) {\\n                best |= (1 << i);\\n                cursor = cursor->next[1 - active];\\n            } else \\n                cursor = cursor->next[active];\\n        }\\n        return best;\\n    }\\n    \\n    void dfs(int v, vector<vector<int> > &ady) {\\n        insert(v);\\n        for(auto q : pending[v]) \\n            output[q.second] = solve(q.first);\\n        for(int u : ady[v]) dfs(u, ady);\\n        erase(v);\\n    }\\n    \\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size();\\n        vector<vector<int> > ady(n);\\n        int r = -1;\\n        for(int i=0;i<parents.size();i++) \\n            if (parents[i] != -1) \\n                ady[parents[i]].push_back(i);\\n            else    \\n                r = i;\\n        \\n        for(int i=0;i<queries.size();i++) \\n            pending[ queries[i][0] ].push_back(make_pair(queries[i][1], i));\\n        output = vector<int>(queries.size());\\n        \\n        root = new Node();\\n        dfs(r, ady);\\n        \\n        return output;            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    public:\\n    \\n    Node *next[2];                    // <- If use this line the solution is AC\\n    //unordered_map<int, Node*> next; // <- If use this line the solution is TLE\\n    \\n    int size;\\n    Node() {\\n        size = 0;\\n        next[0] = next[1] = NULL;\\n    }\\n};\\n\\nclass Solution {\\n    Node *root;\\n    vector<int> output;\\n    unordered_map<int, vector<pair<int, int> > > pending;\\n\\n    void insert(int n) {\\n        Node *cursor = root;\\n        for(int i=21;i>=0;i--) {\\n            int d = (n >> i) & 1;\\n            if (!cursor->next[d]) cursor->next[d] = new Node();\\n            cursor = cursor->next[d];\\n            cursor->size++;\\n        }\\n    }\\n    \\n    void erase(int n) {\\n        Node *cursor = root;\\n        for(int i=21;i>=0;i--) {\\n            int d = (n >> i) & 1;\\n            cursor = cursor->next[d];\\n            cursor->size--;\\n        }\\n    }\\n    \\n    int solve(int val) {\\n        int best = 0;\\n        Node *cursor = root;\\n        for(int i=21;i>=0;i--) {\\n            int active = (val >> i) & 1;\\n            if (cursor->next[ 1 - active ] && cursor->next[ 1 - active ]->size > 0) {\\n                best |= (1 << i);\\n                cursor = cursor->next[1 - active];\\n            } else \\n                cursor = cursor->next[active];\\n        }\\n        return best;\\n    }\\n    \\n    void dfs(int v, vector<vector<int> > &ady) {\\n        insert(v);\\n        for(auto q : pending[v]) \\n            output[q.second] = solve(q.first);\\n        for(int u : ady[v]) dfs(u, ady);\\n        erase(v);\\n    }\\n    \\npublic:\\n    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {\\n        int n = parents.size();\\n        vector<vector<int> > ady(n);\\n        int r = -1;\\n        for(int i=0;i<parents.size();i++) \\n            if (parents[i] != -1) \\n                ady[parents[i]].push_back(i);\\n            else    \\n                r = i;\\n        \\n        for(int i=0;i<queries.size();i++) \\n            pending[ queries[i][0] ].push_back(make_pair(queries[i][1], i));\\n        output = vector<int>(queries.size());\\n        \\n        root = new Node();\\n        dfs(r, ady);\\n        \\n        return output;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": []
    },
    {
        "title": "Users That Actively Request Confirmation Messages",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1785165,
                "content": [
                    {
                        "username": "00marianne",
                        "content": "why i have a runtime error?\\n\\n `with confirm as (\\n    select \\n        user_id, \\n        time_stamp, \\n        lead(time_stamp) over(partition by user_id order by time_stamp) as next_stamp\\n    from confirmations\\n)\\n\\n\\nselect user_id, timediff(next_stamp, time_stamp)\\nfrom confirm`"
                    },
                    {
                        "username": "HardawayLong",
                        "content": "Got the same error, but timediff could used in WHERE"
                    },
                    {
                        "username": "psnakhwa",
                        "content": "SELECT DISTINCT user_id FROM (\\n    SELECT user_id, time_stamp, \\n    LEAD(time_stamp) OVER (PARTITION BY user_id ORDER BY time_stamp) AS next_stamp\\n    FROM Confirmations\\n) a\\nWHERE TIMEDIFF(next_stamp, time_stamp) <= TIME(\\'24:00:00\\')"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Common Subsequence Between Sorted Arrays",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 2072591,
                "content": [
                    {
                        "username": "JParks1982",
                        "content": "Dear Leetcode, title should be \"Longest Common Subsequence **AMONG** Sorted Arrays\". From Merriam-Webster: \"Among may apply to any number; between applies to two only.\" As usual, questions are poorly-written along with inadequate test cases to compensate for said poorly-written question."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: assume the entire first array is the common subsequence;\\nthen traverse other arrays to shrink the assumption.\\n"
                    }
                ]
            },
            {
                "id": 1742117,
                "content": [
                    {
                        "username": "JParks1982",
                        "content": "Dear Leetcode, title should be \"Longest Common Subsequence **AMONG** Sorted Arrays\". From Merriam-Webster: \"Among may apply to any number; between applies to two only.\" As usual, questions are poorly-written along with inadequate test cases to compensate for said poorly-written question."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: assume the entire first array is the common subsequence;\\nthen traverse other arrays to shrink the assumption.\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if All Characters Have Equal Number of Occurrences",
        "question_content": "<p>Given a string <code>s</code>, return <code>true</code><em> if </em><code>s</code><em> is a <strong>good</strong> string, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>A string <code>s</code> is <strong>good</strong> if <strong>all</strong> the characters that appear in <code>s</code> have the <strong>same</strong> number of occurrences (i.e., the same frequency).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abacbc&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The characters that appear in s are &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;. All characters occur 2 times in s.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aaabb&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The characters that appear in s are &#39;a&#39; and &#39;b&#39;.\n&#39;a&#39; occurs 3 times while &#39;b&#39; occurs 2 times, which is not the same number of times.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1359946,
                "title": "commented-java-solution-100-faster-time-o-n-space-o-1",
                "content": "The idea is to count the frequency of the letters in the string and then check all the frequencies if they are the same.\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n\\t\\t// Array to save the frequency of all the 26 lowercase letters\\n        int[] freq = new int[26];\\n        \\n\\t\\t// Increment the frequency of the current letter\\n\\t\\t// Get the index by subtracting the ASCII value of the letter \\'a\\' from the ASCII value of the current letter\\n        for(char c: s.toCharArray()){\\n            freq[c - \\'a\\']++;\\n        }\\n        \\n\\t\\t// Instead of looping over the array to get the first frequency we encounter,\\n\\t\\t// we get the frequency of the first letter in the string (or any letter in the string, it doesn\\'t matter)\\n        int prev = freq[s.charAt(0) - \\'a\\'];\\n        \\n\\t\\t// Compare non-zero frequencies to the frequency of the first letter\\n        for(int num: freq){\\n\\t\\t// Return false if the current frequency is not equal to \"prev\"\\n            if(num != 0 && num != prev){\\n                return false;\\n            }\\n        }\\n        \\n\\t\\t// If we reached here, then all the frequencies are the same\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n\\t\\t// Array to save the frequency of all the 26 lowercase letters\\n        int[] freq = new int[26];\\n        \\n\\t\\t// Increment the frequency of the current letter\\n\\t\\t// Get the index by subtracting the ASCII value of the letter \\'a\\' from the ASCII value of the current letter\\n        for(char c: s.toCharArray()){\\n            freq[c - \\'a\\']++;\\n        }\\n        \\n\\t\\t// Instead of looping over the array to get the first frequency we encounter,\\n\\t\\t// we get the frequency of the first letter in the string (or any letter in the string, it doesn\\'t matter)\\n        int prev = freq[s.charAt(0) - \\'a\\'];\\n        \\n\\t\\t// Compare non-zero frequencies to the frequency of the first letter\\n        for(int num: freq){\\n\\t\\t// Return false if the current frequency is not equal to \"prev\"\\n            if(num != 0 && num != prev){\\n                return false;\\n            }\\n        }\\n        \\n\\t\\t// If we reached here, then all the frequencies are the same\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359715,
                "title": "python3-1-line",
                "content": "\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407800,
                "title": "c-c-java-js-python-1-liner-simple-and-short-solutions-faster-than-100",
                "content": "**Python, One Liner:**\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```\\n**C++, 0ms Faster than 100%:**\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char, int> freq;\\n        for (auto c : s) freq[c]++;\\n        int val = freq[s[0]];\\n        for (auto [a, b] : freq) if (b != val) return false;\\n        return true;\\n    }\\n};\\n```\\n**C / C++, 0 ms Faster than 100%:**\\n```\\nbool areOccurrencesEqual(char * s){\\n    int freq[26] = {0};\\n    char* ptr = s;\\n    while (*ptr) freq[*ptr++ - \\'a\\']++;\\n    \\n    int val = freq[s[0] - \\'a\\'];\\n    for (int i = 0; i < 26; i++)\\n        if (freq[i] && freq[i] != val) return false; \\n    \\n    return true;\\n}\\n```\\n**Java, 1ms Faster than 100%:**\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int[] freq = new int[26];\\n        \\n        for (int i = 0; i < s.length(); i++) freq[s.charAt(i)-\\'a\\']++;\\n\\n        int val = freq[s.charAt(0) - \\'a\\'];\\n        for (int i = 0; i < 26; i++)\\n            if (freq[i] != 0 && freq[i] != val) return false; \\n\\n        return true;\\n    }\\n}\\n```\\n**Javascript:**\\n```\\nvar areOccurrencesEqual = function(s) {\\n    var freq = {}\\n    for (let c of s) freq[c] = (freq[c] || 0) + 1\\n    var val = freq[s[0]]\\n    for (let c in freq) if (freq[c] && freq[c] != val) return false;\\n    return true;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char, int> freq;\\n        for (auto c : s) freq[c]++;\\n        int val = freq[s[0]];\\n        for (auto [a, b] : freq) if (b != val) return false;\\n        return true;\\n    }\\n};\\n```\n```\\nbool areOccurrencesEqual(char * s){\\n    int freq[26] = {0};\\n    char* ptr = s;\\n    while (*ptr) freq[*ptr++ - \\'a\\']++;\\n    \\n    int val = freq[s[0] - \\'a\\'];\\n    for (int i = 0; i < 26; i++)\\n        if (freq[i] && freq[i] != val) return false; \\n    \\n    return true;\\n}\\n```\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int[] freq = new int[26];\\n        \\n        for (int i = 0; i < s.length(); i++) freq[s.charAt(i)-\\'a\\']++;\\n\\n        int val = freq[s.charAt(0) - \\'a\\'];\\n        for (int i = 0; i < 26; i++)\\n            if (freq[i] != 0 && freq[i] != val) return false; \\n\\n        return true;\\n    }\\n}\\n```\n```\\nvar areOccurrencesEqual = function(s) {\\n    var freq = {}\\n    for (let c of s) freq[c] = (freq[c] || 0) + 1\\n    var val = freq[s[0]]\\n    for (let c in freq) if (freq[c] && freq[c] != val) return false;\\n    return true;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359848,
                "title": "thought-process-c-fast-thinking",
                "content": "# THINKING AND APPROACH \\n\\n* Since This was the 1st question ( easiest), you cant afford to spend much time on this\\n* Always think of using an array/map for frequency questions\\n* I thought of using an ordered_map with key as characters of string and value as their frequency\\n* Now just traverse the map and check if all values are same or not\\n# Code :\\n```\\n bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        int cnt= mp[s[0]];\\n        for(auto &it : mp){\\n            if(cnt!=it.second)\\n                return false;\\n        }\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        int cnt= mp[s[0]];\\n        for(auto &it : mp){\\n            if(cnt!=it.second)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1361147,
                "title": "my-java-solution-using-hashmap-can-also-do-with-integer-array",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        if (s.length() == 1)\\n            return true;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char ch : s.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        int freq = map.get(s.charAt(0));\\n        for (char key : map.keySet()) {\\n            if (map.get(key) != freq)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        if (s.length() == 1)\\n            return true;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char ch : s.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        int freq = map.get(s.charAt(0));\\n        for (char key : map.keySet()) {\\n            if (map.get(key) != freq)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361188,
                "title": "c-commented-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s){\\n        vector<int> cnt(26,0);\\n\\t\\t//store freq of each char of s in cnt vector\\n        for(char c : s) cnt[c-\\'a\\']++;\\n\\t\\t//num contains the freq of first char in s\\n        int num=cnt[s[0]-\\'a\\'];\\n\\t\\t//traversing the cnt vector\\n\\t\\t//freq in cnt must be either 0(char is not present in s) or num(if char present in s\\n\\t\\t//than its freq should be same as that of other chars of string) else we will return false\\n        for(int i: cnt){\\n            if(i!=num and i!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage m**e to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s){\\n        vector<int> cnt(26,0);\\n\\t\\t//store freq of each char of s in cnt vector\\n        for(char c : s) cnt[c-\\'a\\']++;\\n\\t\\t//num contains the freq of first char in s\\n        int num=cnt[s[0]-\\'a\\'];\\n\\t\\t//traversing the cnt vector\\n\\t\\t//freq in cnt must be either 0(char is not present in s) or num(if char present in s\\n\\t\\t//than its freq should be same as that of other chars of string) else we will return false\\n        for(int i: cnt){\\n            if(i!=num and i!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359708,
                "title": "max-count",
                "content": "We count all characters, and in the end we verify that each count is either zero, or equal to max count.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return all(cnt == len(s) // len(set(s)) for cnt in Counter(s).values())\\n```\\nor even more concise, as suggested by [tglukhikh](https://leetcode.com/tglukhikh/):\\n```python\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return (len(set(Counter(s).values()))) == 1\\n```\\n**C++**\\n```cpp\\nbool areOccurrencesEqual(string s) {\\n    int cnt[26] = {}, m_cnt = 0;\\n    for (auto ch : s)\\n        m_cnt = max(m_cnt, ++cnt[ch - \\'a\\']);\\n    return all_of(begin(cnt), end(cnt), [&m_cnt](int t){ return t == 0 || t == m_cnt; });\\n}\\n```\\n**Java**\\n```java\\npublic boolean areOccurrencesEqual(String s) {\\n    int cnt[] = new int[26];\\n    s.chars().forEach(ch -> ++cnt[ch - \\'a\\']);\\n    int m_cnt = Arrays.stream(cnt).max().getAsInt();\\n    return Arrays.stream(cnt).filter(c -> c > 0).allMatch(c -> c == m_cnt);\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return all(cnt == len(s) // len(set(s)) for cnt in Counter(s).values())\\n```\n```python\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return (len(set(Counter(s).values()))) == 1\\n```\n```cpp\\nbool areOccurrencesEqual(string s) {\\n    int cnt[26] = {}, m_cnt = 0;\\n    for (auto ch : s)\\n        m_cnt = max(m_cnt, ++cnt[ch - \\'a\\']);\\n    return all_of(begin(cnt), end(cnt), [&m_cnt](int t){ return t == 0 || t == m_cnt; });\\n}\\n```\n```java\\npublic boolean areOccurrencesEqual(String s) {\\n    int cnt[] = new int[26];\\n    s.chars().forEach(ch -> ++cnt[ch - \\'a\\']);\\n    int m_cnt = Arrays.stream(cnt).max().getAsInt();\\n    return Arrays.stream(cnt).filter(c -> c > 0).allMatch(c -> c == m_cnt);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359709,
                "title": "python-multiple-solutions",
                "content": "O(n) Solution Using Hash map and set - \\n\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        dct = dict()\\n        \\n\\t\\t#count occurrences of every character\\n        for i in s:\\n            if dct.get(i):\\n                dct[i] += 1\\n            else:\\n                dct[i] = 1\\n        \\n        res = set()\\n        \\n\\t\\t#create set of all occurrences/frequencies\\n        for i in dct.values():\\n            res.add(i)\\n            \\n\\t\\t#return true if length of set is one (all characters Have same number of occurrences)\\n        return len(res) == 1\\n```\\n\\nOne Liner -\\n\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set([s.count(i) for i in s])) == 1\\n```\\n\\nIf you have any questions/suggestions please comment below : )",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        dct = dict()\\n        \\n\\t\\t#count occurrences of every character\\n        for i in s:\\n            if dct.get(i):\\n                dct[i] += 1\\n            else:\\n                dct[i] = 1\\n        \\n        res = set()\\n        \\n\\t\\t#create set of all occurrences/frequencies\\n        for i in dct.values():\\n            res.add(i)\\n            \\n\\t\\t#return true if length of set is one (all characters Have same number of occurrences)\\n        return len(res) == 1\\n```\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set([s.count(i) for i in s])) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540057,
                "title": "c-without-map-commented-runtime-0-ms-faster-than-100-00-beginner-friendly-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        int len = s.size();\\n        int freq[26]={};     // intializing freq array with 0\\n        for(int i=0;i<len;i++){\\n            freq[s[i] - 97]++;\\n        }\\n        \\n        int x= freq[s[0] - 97]; //getting freq of first term in string \\n        \\n        for(int i=0;i<26;i++){\\n           if(x!=freq[i]&&freq[i]!=0)   //freq!=0 for handling terms not present in string \\n               return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Upvote++ if you got any help from my code.  :-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        int len = s.size();\\n        int freq[26]={};     // intializing freq array with 0\\n        for(int i=0;i<len;i++){\\n            freq[s[i] - 97]++;\\n        }\\n        \\n        int x= freq[s[0] - 97]; //getting freq of first term in string \\n        \\n        for(int i=0;i<26;i++){\\n           if(x!=freq[i]&&freq[i]!=0)   //freq!=0 for handling terms not present in string \\n               return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359896,
                "title": "not-a-good-one-but-my-approach",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n\\n        my_list = []\\n        for i in range(len(s)):\\n            my_list.append(s[i])\\n            \\n        \\n        freq = {}\\n        for items in my_list:\\n            freq[items] = my_list.count(items)\\n            \\n            \\n        res = list(freq.values())\\n        \\n        ss = set(res)\\n        \\n        if(len(ss) == 1): return True\\n        else: return False\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n\\n        my_list = []\\n        for i in range(len(s)):\\n            my_list.append(s[i])\\n            \\n        \\n        freq = {}\\n        for items in my_list:\\n            freq[items] = my_list.count(items)\\n            \\n            \\n        res = list(freq.values())\\n        \\n        ss = set(res)\\n        \\n        if(len(ss) == 1): return True\\n        else: return False\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615496,
                "title": "smooth-js-solution-faster-than-97-87",
                "content": "```\\nvar areOccurrencesEqual = function(s) {\\n    let map = {};\\n    for(let i of s) map[i] = map[i] + 1 || 1;\\n    let arr = new Set(Object.values(map))\\n    return arr.size == 1;\\n};\\n```\\n \\n ![image](https://assets.leetcode.com/users/images/1e45cf5a-73fb-449f-9e36-b996df787b0a_1663964836.554156.png)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nvar areOccurrencesEqual = function(s) {\\n    let map = {};\\n    for(let i of s) map[i] = map[i] + 1 || 1;\\n    let arr = new Set(Object.values(map))\\n    return arr.size == 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1686340,
                "title": "easy-python-solution",
                "content": "```\\ndef areOccurrencesEqual(self, s: str) -> bool:\\n        m=s.count(s[0])\\n        for i in s:\\n            if s.count(i)!=m: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef areOccurrencesEqual(self, s: str) -> bool:\\n        m=s.count(s[0])\\n        for i in s:\\n            if s.count(i)!=m: return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1666757,
                "title": "c-solution-using-map-100-faster-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n   map<char,int> mp;\\n        for(int i=0;i<s.size();i++)mp[s[i]]++;\\n        int cnt= mp[s[0]];\\n        for(auto it : mp){\\n            if(cnt!=it.second)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n   map<char,int> mp;\\n        for(int i=0;i<s.size();i++)mp[s[i]]++;\\n        int cnt= mp[s[0]];\\n        for(auto it : mp){\\n            if(cnt!=it.second)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648076,
                "title": "check-if-all-characters-have-equal-no-of-occurrences",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n     sort(s.begin(),s.end());\\n        vector<int> alphabets(26,0);\\n        for(int i=0;i<s.length();i++){\\n            alphabets[s[i]-\\'a\\']++;\\n        }\\n        bool flag=true;\\n        int count=alphabets[s[0]-\\'a\\'];\\n        for(int i=0;i<26;i++){\\n         if(alphabets[i]>0){\\n             if(alphabets[i]==count){\\n                 flag=true;\\n             }\\n             else{\\n                 flag=false;\\n                 break;\\n             }\\n         }\\n        }\\n   \\n        \\n        if(flag)return true;\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n     sort(s.begin(),s.end());\\n        vector<int> alphabets(26,0);\\n        for(int i=0;i<s.length();i++){\\n            alphabets[s[i]-\\'a\\']++;\\n        }\\n        bool flag=true;\\n        int count=alphabets[s[0]-\\'a\\'];\\n        for(int i=0;i<26;i++){\\n         if(alphabets[i]>0){\\n             if(alphabets[i]==count){\\n                 flag=true;\\n             }\\n             else{\\n                 flag=false;\\n                 break;\\n             }\\n         }\\n        }\\n   \\n        \\n        if(flag)return true;\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433816,
                "title": "java-easy-and-short-java-solution",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int[] alph = new int[26];\\n        int occurance = 0;\\n        \\n        for(int i =0;i< s.length();i++){\\n            alph[s.charAt(i)-\\'a\\']++;\\n            occurance = Math.max(occurance,alph[s.charAt(i)-\\'a\\']);\\n        }\\n        \\n        for(int i = 0;i<26;i++){\\n            if(alph[i] != 0 && alph[i] != occurance) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int[] alph = new int[26];\\n        int occurance = 0;\\n        \\n        for(int i =0;i< s.length();i++){\\n            alph[s.charAt(i)-\\'a\\']++;\\n            occurance = Math.max(occurance,alph[s.charAt(i)-\\'a\\']);\\n        }\\n        \\n        for(int i = 0;i<26;i++){\\n            if(alph[i] != 0 && alph[i] != occurance) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310583,
                "title": "easy-to-understand-c-solution",
                "content": "Creating a map to store frequency of all letters in the given string and simultaneusly updating the maxi variable to store the frequency of the maximum occuring character. As all letters need to occur the same time max has to be equal to frequency of each letter.\\nRunning another loop to compare max frequency with frequency of each letter.\\n\\n# Complexity\\n- Time complexity:\\n(complexity of for loop)* (complexity of accesing key in map)\\n(O(N))*(O(1))\\n= O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int> m;\\n        int maxi = -1;\\n        for( int i = 0; i < s.size(); i++){\\n            m[s[i]] += 1;\\n            maxi = max(m[s[i]],maxi);\\n        }\\n        for(auto it : m){\\n            if( it.second != maxi){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int> m;\\n        int maxi = -1;\\n        for( int i = 0; i < s.size(); i++){\\n            m[s[i]] += 1;\\n            maxi = max(m[s[i]],maxi);\\n        }\\n        for(auto it : m){\\n            if( it.second != maxi){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909332,
                "title": "python-solution-36-ms-beats-86-35",
                "content": "Used Counter function to count the occurence of every character and then stored it in an array. initialized a flag to 1 and Iterated through every element in that array and checked if it is not equal to its next element, if it\\'s not then set flag to 0 and return flag.\\nBelow is the code implementation of the approach  :- \\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        a = Counter(s).values()\\n        flag = 1\\n        nums = []\\n        for i in a:\\n            nums.append(i)\\n\\n        for i in range(len(nums)-1):\\n            if nums[i]!=nums[i+1]:\\n                flag = 0\\n        return flag  \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        a = Counter(s).values()\\n        flag = 1\\n        nums = []\\n        for i in a:\\n            nums.append(i)\\n\\n        for i in range(len(nums)-1):\\n            if nums[i]!=nums[i+1]:\\n                flag = 0\\n        return flag  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866320,
                "title": "python-easy-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        occurances = {}\\n        for i in s:\\n            if i not in occurances:\\n                occurances[i] = 1\\n            else:\\n                occurances[i] += 1\\n        count = sum(occurances.values())/len(occurances)\\n        for key, value in occurances.items():\\n            if value != count:\\n                return False\\n        return True",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "class Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        occurances = {}",
                "codeTag": "Java"
            },
            {
                "id": 1361557,
                "title": "c-easy-with-explanations",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int>v(26,0);\\n\\t\\t// Get frequency of every element\\n        for(int i=0;i<s.size();i++)\\n            v[s[i]-\\'a\\']++;\\n\\t\\t\\t\\n\\t\\t// Freq of first element of string\\n\\t   int freq = v[s[0]-\\'a\\'];\\n        // Check if frequency is not zero , then it should be equal to freq\\n\\t\\tfor(int i=0;i<26;i++)\\n        {\\n            if(v[i]!=0)\\n            {\\n                if(v[i]!=freq)\\n                    return false;\\n            }\\n                \\n        }\\n        return true;\\n            \\n    }\\n};\\n```\\n\\nFeel free to drop comments :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int>v(26,0);\\n\\t\\t// Get frequency of every element\\n        for(int i=0;i<s.size();i++)\\n            v[s[i]-\\'a\\']++;\\n\\t\\t\\t\\n\\t\\t// Freq of first element of string\\n\\t   int freq = v[s[0]-\\'a\\'];\\n        // Check if frequency is not zero , then it should be equal to freq\\n\\t\\tfor(int i=0;i<26;i++)\\n        {\\n            if(v[i]!=0)\\n            {\\n                if(v[i]!=freq)\\n                    return false;\\n            }\\n                \\n        }\\n        return true;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818754,
                "title": "python-easy-97-05-faster-dictionary-o-n-solution",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        d={}\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        t=d[s[0]]\\n        for v in d.values():\\n            if v!=t:\\n                return False\\n        return True\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        d={}\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        t=d[s[0]]\\n        for v in d.values():\\n            if v!=t:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659720,
                "title": "java-self-explanatory",
                "content": "int[] count = new int[26];\\n        int max=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            count[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int x:count){\\n            max = Math.max(max,x);\\n        }\\n        \\n        for(int i=0;i<count.length;i++){\\n         if( (count[i]!=0) && (max!=count[i])){\\n             return false;\\n         }    \\n        }\\n        return true;",
                "solutionTags": [
                    "Java"
                ],
                "code": "int[] count = new int[26];\\n        int max=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            count[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int x:count){\\n            max = Math.max(max,x);\\n        }\\n        \\n        for(int i=0;i<count.length;i++){\\n         if( (count[i]!=0) && (max!=count[i])){\\n             return false;\\n         }    \\n        }\\n        return true;",
                "codeTag": "Unknown"
            },
            {
                "id": 2510346,
                "title": "hashmap-easy-to-understand-java-code",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character,Integer> map= new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(map.containsKey(c)){\\n                map.put(c,map.get(c)+1);\\n            }\\n            else{\\n                map.put(c,1);\\n            }\\n           \\n                }\\n        int val=map.get(s.charAt(0));\\n        \\n        for(int num : map.values()){\\n            if(num!=val)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character,Integer> map= new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(map.containsKey(c)){\\n                map.put(c,map.get(c)+1);\\n            }\\n            else{\\n                map.put(c,1);\\n            }\\n           \\n                }\\n        int val=map.get(s.charAt(0));\\n        \\n        for(int num : map.values()){\\n            if(num!=val)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262149,
                "title": "c-maps-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/32c2e24b-c315-49e9-b7fd-a5270a749bc9_1657434030.8475957.png)\\n\\n**n==s.size()\\nT->O(n) && S->(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool areOccurrencesEqual(string s) {\\n\\t\\t\\tmap<char,int>mp;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\t\\t\\tint t=mp[s[0]];\\n\\t\\t\\tfor(auto i:mp){\\n\\t\\t\\t\\tif(i.second!=t)return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool areOccurrencesEqual(string s) {\\n\\t\\t\\tmap<char,int>mp;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\t\\t\\tint t=mp[s[0]];\\n\\t\\t\\tfor(auto i:mp){\\n\\t\\t\\t\\tif(i.second!=t)return false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2189000,
                "title": "java-for-loop-hashmap-hashset-solution",
                "content": "``I know it is not faster Solution but I hope you find the solution 100% faster \\u270A ``\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        Map<Character, Integer> map = new TreeMap<>();//char,count\\n        for (char c : s.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        return 1 == new HashSet<>(map.values()).size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        Map<Character, Integer> map = new TreeMap<>();//char,count\\n        for (char c : s.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        return 1 == new HashSet<>(map.values()).size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182034,
                "title": "python-beginner-friendly-solution",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        se=[s.count(i) for i in set(s)]\\n        return(se.count(se[0])==len(se))\\n```\\n**Space Complexity : O(N)\\nTime Complexity : O(N)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        se=[s.count(i) for i in set(s)]\\n        return(se.count(se[0])==len(se))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636946,
                "title": "javascript-simple-solution",
                "content": "```\\nvar areOccurrencesEqual = (s) => {\\n  let count = s.split(\\'\\').reduce((obj, cur)=>{\\n    obj.hasOwnProperty(cur)?obj[cur] += 1:obj[cur] = 1\\n    return obj\\n  },{})\\n  return new Set(Object.values(count)).size === 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar areOccurrencesEqual = (s) => {\\n  let count = s.split(\\'\\').reduce((obj, cur)=>{\\n    obj.hasOwnProperty(cur)?obj[cur] += 1:obj[cur] = 1\\n    return obj\\n  },{})\\n  return new Set(Object.values(count)).size === 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1441956,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        d = defaultdict(int)\\n        for c in s:\\n            d[c] += 1\\n        return len(set(d.values())) == 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        d = defaultdict(int)\\n        for c in s:\\n            d[c] += 1\\n        return len(set(d.values())) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365830,
                "title": "javascript",
                "content": "```var areOccurrencesEqual = function(s) {\\n    let mapped = {}\\n\\n    for(let letter of s) {\\n        mapped[letter] = (mapped[letter] || 0) + 1\\n    }\\n\\n    const occurences = new Set(Object.values(mapped))\\n    if(occurences.size === 1) return true\\n    return false\\n};\\n```",
                "solutionTags": [],
                "code": "```var areOccurrencesEqual = function(s) {\\n    let mapped = {}\\n\\n    for(let letter of s) {\\n        mapped[letter] = (mapped[letter] || 0) + 1\\n    }\\n\\n    const occurences = new Set(Object.values(mapped))\\n    if(occurences.size === 1) return true\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365145,
                "title": "java-solution-in-2-lines",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        var freq = s.chars().boxed().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\\n        return freq.values().stream().distinct().count() == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        var freq = s.chars().boxed().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\\n        return freq.values().stream().distinct().count() == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859018,
                "title": "easy-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char,int>mp;\\n        for(auto i:s)\\n        {\\n          mp[i]++;  \\n        }\\n        int num=mp[s[0]];\\n        for(auto i:mp)\\n        {\\n            if(i.second!=num)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char,int>mp;\\n        for(auto i:s)\\n        {\\n          mp[i]++;  \\n        }\\n        int num=mp[s[0]];\\n        for(auto i:mp)\\n        {\\n            if(i.second!=num)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665584,
                "title": "c-using-dictionary",
                "content": "# Approach\\n- Use dictionary to count occurences of each character\\n- Check if all characters have the same count\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool AreOccurrencesEqual(string s)\\n    {\\n        var dictionary = new Dictionary<char, int>();\\n\\n        foreach (var ch in s)\\n        {\\n            dictionary[ch] = dictionary.GetValueOrDefault(ch) + 1;\\n        }\\n\\n        var firstCount = dictionary.First().Value;\\n        \\n        return dictionary.Values.All(x => x == firstCount);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool AreOccurrencesEqual(string s)\\n    {\\n        var dictionary = new Dictionary<char, int>();\\n\\n        foreach (var ch in s)\\n        {\\n            dictionary[ch] = dictionary.GetValueOrDefault(ch) + 1;\\n        }\\n\\n        var firstCount = dictionary.First().Value;\\n        \\n        return dictionary.Values.All(x => x == firstCount);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211053,
                "title": "check-if-all-characters-have-equal-number-of-occurrences",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        res=[]\\n        for i in s:\\n            res.append(s.count(i))\\n        if len(set(res))==1:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        res=[]\\n        for i in s:\\n            res.append(s.count(i))\\n        if len(set(res))==1:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177530,
                "title": "simple-one-liner-with-counter",
                "content": "# Intuition\\nUse Counter()\\n\\n# Approach\\nIff string is good then there is only one frequency\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175808,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n       vector<int>p(27,0);\\n       set<int>st;\\n       for(int i=0;i<s.size();i++) p[s[i]-\\'a\\']++; \\n       for(int i=0;i<p.size();i++) if (p[i]!=0) st.insert(p[i]);\\n       return (st.size()==1);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n       vector<int>p(27,0);\\n       set<int>st;\\n       for(int i=0;i<s.size();i++) p[s[i]-\\'a\\']++; \\n       for(int i=0;i<p.size();i++) if (p[i]!=0) st.insert(p[i]);\\n       return (st.size()==1);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159601,
                "title": "2-lines-python",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSET of all the values shall be 1 for the cases where frequency of every letter is same.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        D = Counter(s)\\n        return len(set(D.values())) == 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        D = Counter(s)\\n        return len(set(D.values())) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092226,
                "title": "easy-hashmap-solution-java",
                "content": "# Using HashMap!\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        int freq = map.get(s.charAt(0));\\n        for(Character c: map.keySet()){\\n            if(map.get(c) != freq){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        int freq = map.get(s.charAt(0));\\n        for(Character c: map.keySet()){\\n            if(map.get(c) != freq){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089352,
                "title": "beats-99-98",
                "content": "# Upvote it :)\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        d = defaultdict(int)\\n        for i in s: d[i] += 1\\n        c = d[s[0]]\\n        for i in d:\\n            if d[i] != c: return 0\\n        return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        d = defaultdict(int)\\n        for i in s: d[i] += 1\\n        c = d[s[0]]\\n        for i in d:\\n            if d[i] != c: return 0\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894497,
                "title": "beginners-method-one-liner-python",
                "content": "The key is using length to check if theres a non dup\\n\\n# Code\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(collections.Counter(s).values()))==1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(collections.Counter(s).values()))==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802825,
                "title": "c-java-faster-than-100-0-ms",
                "content": "# Please Upvote if Usefull,means alot.\\n**Intution **\\nJust Cout Frequency and if frequency is not same return false.\\n![image](https://assets.leetcode.com/users/images/4adff941-2d33-49be-bd94-3f48b80814c1_1668155455.0331652.png)\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        \\n        int f[26]={0};\\n        for( int i=0;i<s.size();i++) f[s[i]-\\'a\\']++;\\n        \\n        int x=f[s[0]-\\'a\\'];\\n        \\n        for( int i=0;i<26;i++){\\n            if(f[i]==0 || ( f[i]==x)) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**java Solution.**\\n\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n        int f[]=new int[26];\\n        for( int i=0;i<s.length();i++) f[s.charAt(i)-\\'a\\']++;\\n        \\n        int x=f[s.charAt(0)-\\'a\\'];\\n        \\n        for( int i=0;i<26;i++){\\n            if(f[i]==0 || ( f[i]==x)) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n        \\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        \\n        int f[26]={0};\\n        for( int i=0;i<s.size();i++) f[s[i]-\\'a\\']++;\\n        \\n        int x=f[s[0]-\\'a\\'];\\n        \\n        for( int i=0;i<26;i++){\\n            if(f[i]==0 || ( f[i]==x)) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n        int f[]=new int[26];\\n        for( int i=0;i<s.length();i++) f[s.charAt(i)-\\'a\\']++;\\n        \\n        int x=f[s.charAt(0)-\\'a\\'];\\n        \\n        for( int i=0;i<26;i++){\\n            if(f[i]==0 || ( f[i]==x)) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668436,
                "title": "java-solution-using-hashmap",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean areOccurrencesEqual(String s) {\\n\\t\\t\\tHashMap<Character,Integer> hm = new HashMap<>();\\n\\t\\t\\tHashSet<Integer>hs=new HashSet<>();\\n\\t\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar ch=s.charAt(i);\\n\\t\\t\\t\\tif(hm.containsKey(ch))\\n\\t\\t\\t\\t\\thm.put(ch,hm.get(ch)+1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thm.put(ch,1);\\n\\t\\t\\t}\\n\\t\\t\\tfor(Map.Entry<Character,Integer>entry:hm.entrySet())\\n\\t\\t\\t\\ths.add(entry.getValue());\\n\\t\\t\\tboolean b=hs.size()==1?true:false;\\n\\t\\t\\treturn b;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean areOccurrencesEqual(String s) {\\n\\t\\t\\tHashMap<Character,Integer> hm = new HashMap<>();\\n\\t\\t\\tHashSet<Integer>hs=new HashSet<>();\\n\\t\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar ch=s.charAt(i);\\n\\t\\t\\t\\tif(hm.containsKey(ch))\\n\\t\\t\\t\\t\\thm.put(ch,hm.get(ch)+1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thm.put(ch,1);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2589813,
                "title": "c-easy-solution-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int> mp;\\n        int len=s.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        \\n        int val=mp[s[0]];\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second!=val)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int> mp;\\n        int len=s.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        \\n        int val=mp[s[0]];\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second!=val)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581889,
                "title": "easy-python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef areOccurrencesEqual(self, s: str) -> bool:\\n\\t\\t\\tif len(set(Counter(s).values())) == 1:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef areOccurrencesEqual(self, s: str) -> bool:\\n\\t\\t\\tif len(set(Counter(s).values())) == 1:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 2028880,
                "title": "1ms-100-faster-java-simple-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int freq[]=new int[26];\\n        for(char c : s.toCharArray())freq[c-\\'a\\']++;\\n        int f=0;\\n        for(int val : freq)\\n            if(f==0)f=val;\\n            else if(f!=0&&val!=0&&f!=val)return false;\\n        return true;\\n    }\\n}\\n```\\nTime : O(n) linear\\nSpace : O(26) => O(1) constant \\n\\nPlease upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int freq[]=new int[26];\\n        for(char c : s.toCharArray())freq[c-\\'a\\']++;\\n        int f=0;\\n        for(int val : freq)\\n            if(f==0)f=val;\\n            else if(f!=0&&val!=0&&f!=val)return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682769,
                "title": "93-6-accuracy-easiest-python-solution",
                "content": "Do UPVOTE if you like my solution\\nCreating a set in which the total occurences of letters in the words are counted and if all repeated the same time the set will have only one number and hence return True :)\\n\\n![image](https://assets.leetcode.com/users/images/4eca9d19-5bcf-4676-805e-3e20d8470dba_1641903831.7354548.png)\\n\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        a = set(s)\\n        d = set()\\n        for i in a:\\n            d.add(s.count(i))\\n        if len(d) == 1:\\n            return True\\n        else:\\n            False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        a = set(s)\\n        d = set()\\n        for i in a:\\n            d.add(s.count(i))\\n        if len(d) == 1:\\n            return True\\n        else:\\n            False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639964,
                "title": "c-linq-solution",
                "content": "```\\npublic class Solution {\\n    public bool AreOccurrencesEqual(string s) {\\n    var grouped = s.GroupBy(x => x).Select(w => new { Letter = w.Key, Counted = w.Count() });\\n    return grouped.All(z =>\\n    {\\n        return z.Counted == grouped.FirstOrDefault().Counted;\\n    });\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool AreOccurrencesEqual(string s) {\\n    var grouped = s.GroupBy(x => x).Select(w => new { Letter = w.Key, Counted = w.Count() });\\n    return grouped.All(z =>\\n    {\\n        return z.Counted == grouped.FirstOrDefault().Counted;\\n    });\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639012,
                "title": "java-easy-solution-faster-than-100-memory-less-than-99-66",
                "content": "```\\npublic boolean areOccurrencesEqual(String s) {\\n   \\tint arr[] = new int[26];\\n    int anyValue = 0;\\n    for(int i = 0; i < s.length(); i++) {\\n        int index = s.charAt(i) - \\'a\\';\\n        arr[index]++;\\n        anyValue = arr[index];\\n    }\\n    for(int i = 0; i < 26; i++) {\\n        if(arr[i] != 0 && arr[i] != anyValue) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean areOccurrencesEqual(String s) {\\n   \\tint arr[] = new int[26];\\n    int anyValue = 0;\\n    for(int i = 0; i < s.length(); i++) {\\n        int index = s.charAt(i) - \\'a\\';\\n        arr[index]++;\\n        anyValue = arr[index];\\n    }\\n    for(int i = 0; i < 26; i++) {\\n        if(arr[i] != 0 && arr[i] != anyValue) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596224,
                "title": "my-java-solution-using-stream-api",
                "content": "public boolean areOccurrencesEqual(String s) {\\n    Map<Character, Integer> map = new HashMap<>();\\n    for(int i=0;i<s.length();i++) {\\n        map.put(s.charAt(i), map.getOrDefault(s.charAt(i),0)+1);\\n    }\\n    List<Integer> list =  map.values().stream().sorted().collect(Collectors.toList());\\n    return list.get(0).equals(list.get(list.size()-1)); ////If the char counts in the sorted list are the same then, the first and last count no will be the same\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public boolean areOccurrencesEqual(String s) {\\n    Map<Character, Integer> map = new HashMap<>();\\n    for(int i=0;i<s.length();i++) {\\n        map.put(s.charAt(i), map.getOrDefault(s.charAt(i),0)+1);\\n    }\\n    List<Integer> list =  map.values().stream().sorted().collect(Collectors.toList());\\n    return list.get(0).equals(list.get(list.size()-1)); ////If the char counts in the sorted list are the same then, the first and last count no will be the same\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1545908,
                "title": "go-time-o-n-0-ms-100-space-o-1-2-3-mb-89-74",
                "content": "```\\nfunc areOccurrencesEqual(s string) bool {\\n    count, prev := make(map[rune]int), 0\\n    \\n    for _, l := range s {\\n        count[l]++\\n    }\\n    \\n    for _, v := range count {\\n        switch {\\n        case prev <= 0:\\n            prev = v\\n        case prev != v:\\n            return false\\n        }\\n    }\\n\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc areOccurrencesEqual(s string) bool {\\n    count, prev := make(map[rune]int), 0\\n    \\n    for _, l := range s {\\n        count[l]++\\n    }\\n    \\n    for _, v := range count {\\n        switch {\\n        case prev <= 0:\\n            prev = v\\n        case prev != v:\\n            return false\\n        }\\n    }\\n\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519373,
                "title": "java-100-faster-and-92-5-less-memory-usage",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int alpha []= new int [26], count=0;\\n        \\n        for(int i=0; i<s.length(); i++)\\n            alpha[s.charAt(i)-\\'a\\']++;\\n        \\n        \\n        for(int i=0; i<26; i++){\\n            \\n            if(count==0 && alpha[i]!=0)\\n                count=alpha[i];\\n            \\n            else if(alpha[i]!=0 && alpha[i]!=count)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int alpha []= new int [26], count=0;\\n        \\n        for(int i=0; i<s.length(); i++)\\n            alpha[s.charAt(i)-\\'a\\']++;\\n        \\n        \\n        for(int i=0; i<26; i++){\\n            \\n            if(count==0 && alpha[i]!=0)\\n                count=alpha[i];\\n            \\n            else if(alpha[i]!=0 && alpha[i]!=count)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487493,
                "title": "python-dictionary-easy-implementation",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        dict1={}\\n        for i in s:\\n            if i in dict1:\\n                \\n                dict1[i]+=1 \\n            \\n            else:\\n                dict1[i]= 1 \\n                \\n        list1=[]\\n        for v in dict1.values():\\n            list1.append(v) \\n        \\n        if len(set(list1))==1:\\n            return True \\n        \\n        else:\\n            return False\\n            \\n            \\n            \\n```\\n\\nif you think it is helpful , do upvote :)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        dict1={}\\n        for i in s:\\n            if i in dict1:\\n                \\n                dict1[i]+=1 \\n            \\n            else:\\n                dict1[i]= 1 \\n                \\n        list1=[]\\n        for v in dict1.values():\\n            list1.append(v) \\n        \\n        if len(set(list1))==1:\\n            return True \\n        \\n        else:\\n            return False\\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474254,
                "title": "java-easy-o-n-hashset",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int arr[] = new int[26];\\n        Set<Integer> set = new HashSet<>();\\n        for(char c:s.toCharArray()) \\n            arr[c%97]++;\\n    \\n        for(int i:arr) \\n            if(i != 0)\\n                set.add(i);\\n        \\n        return set.size() == 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int arr[] = new int[26];\\n        Set<Integer> set = new HashSet<>();\\n        for(char c:s.toCharArray()) \\n            arr[c%97]++;\\n    \\n        for(int i:arr) \\n            if(i != 0)\\n                set.add(i);\\n        \\n        return set.size() == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376846,
                "title": "c-basic-approach-using-hash-map-faster-than-100-till-this-date",
                "content": "**\\n#include<unordered_map>\\nbool areOccurrencesEqual(string s) \\n    {\\n        unordered_map<char, int> map;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            map[s[i]]++;         //we maintain count for every key \\n        }\\n        \\n        int num=map[s[0]];\\n        for(int i=1; i<s.length(); i++)\\n        {\\n            if(num != map[s[i]])       //if any value of count is different then we simply return false\\n            {\\n                return false;\\n                break;\\n            }\\n        }\\n        \\n     return true;\\n        \\n    }**\\n\\t\\n\\t//\"PLEASE UPVOTE THIS SOLUTION IF IT HELPS YOU \"\\n\\t\\'\\'\\'If you are facing any issue comment below i will help you as soon as possible...",
                "solutionTags": [],
                "code": "**\\n#include<unordered_map>\\nbool areOccurrencesEqual(string s) \\n    {\\n        unordered_map<char, int> map;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            map[s[i]]++;         //we maintain count for every key \\n        }\\n        \\n        int num=map[s[0]];\\n        for(int i=1; i<s.length(); i++)\\n        {\\n            if(num != map[s[i]])       //if any value of count is different then we simply return false\\n            {\\n                return false;\\n                break;\\n            }\\n        }\\n        \\n     return true;\\n        \\n    }**\\n\\t\\n\\t//\"PLEASE UPVOTE THIS SOLUTION IF IT HELPS YOU \"\\n\\t\\'\\'\\'If you are facing any issue comment below i will help you as soon as possible...",
                "codeTag": "C++"
            },
            {
                "id": 1369834,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public boolean areOccurrencesEqual(String s) {\\n        int i,j,m=0;\\n        char c[]=new char[s.length()];\\n        int k[]=new int[s.length()];\\n        for(i=0;i<s.length();i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                if(c[j]==s.charAt(i))\\n                    break;\\n            }\\n            if(j==m)\\n            {\\n                c[m]=s.charAt(i);\\n                k[m++]=1;\\n            }\\n            else\\n                k[j]=k[j]+1;\\n        }\\n        for(i=0;i<m-1;i++)\\n        {\\n            if(k[i]!=k[i+1])\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean areOccurrencesEqual(String s) {\\n        int i,j,m=0;\\n        char c[]=new char[s.length()];\\n        int k[]=new int[s.length()];\\n        for(i=0;i<s.length();i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                if(c[j]==s.charAt(i))\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1363174,
                "title": "c-solution",
                "content": "- time: O(n) where n = s.Length\\n- space: O(1)\\n```\\npublic class Solution {\\n    public bool AreOccurrencesEqual(string s) {\\n        \\n        if(String.IsNullOrEmpty(s))\\n            return true;\\n        \\n        int[] freq = new int[26];\\n        for(int i = 0; i < s.Length; i++)\\n            freq[s[i] - \\'a\\']++;\\n        \\n        int freqOfFirstLetter = freq[s[0] - \\'a\\'];\\n        foreach(var f in freq)\\n        {\\n            if(f > 0 && f != freqOfFirstLetter)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool AreOccurrencesEqual(string s) {\\n        \\n        if(String.IsNullOrEmpty(s))\\n            return true;\\n        \\n        int[] freq = new int[26];\\n        for(int i = 0; i < s.Length; i++)\\n            freq[s[i] - \\'a\\']++;\\n        \\n        int freqOfFirstLetter = freq[s[0] - \\'a\\'];\\n        foreach(var f in freq)\\n        {\\n            if(f > 0 && f != freqOfFirstLetter)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360669,
                "title": "c-simple-solution-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char, int> mp;\\n        for(int i=0; i<s.size(); i++){\\n            mp[s[i]]++;\\n        }\\n        int flag=true;\\n        int i=0, abc;\\n        for(auto &x : mp){\\n            if(i>0 && x.second != abc){\\n                flag=false;\\n                break;\\n            }\\n            i++;\\n            abc=x.second;\\n        }\\n        if(flag)    return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char, int> mp;\\n        for(int i=0; i<s.size(); i++){\\n            mp[s[i]]++;\\n        }\\n        int flag=true;\\n        int i=0, abc;\\n        for(auto &x : mp){\\n            if(i>0 && x.second != abc){\\n                flag=false;\\n                break;\\n            }\\n            i++;\\n            abc=x.second;\\n        }\\n        if(flag)    return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360134,
                "title": "easy-java-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> hash = new HashMap<>();\\n        int n = s.length();\\n        \\n        for(int i=0; i<n; i++)\\n            hash.put(s.charAt(i), hash.getOrDefault(s.charAt(i),0)+1);\\n        \\n        int value = hash.get(s.charAt(0));\\n        for(char c: hash.keySet())\\n        {\\n            if(hash.get(c)!=value)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> hash = new HashMap<>();\\n        int n = s.length();\\n        \\n        for(int i=0; i<n; i++)\\n            hash.put(s.charAt(i), hash.getOrDefault(s.charAt(i),0)+1);\\n        \\n        int value = hash.get(s.charAt(0));\\n        for(char c: hash.keySet())\\n        {\\n            if(hash.get(c)!=value)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1359883,
                "title": "java-solution-using-hashmaps",
                "content": "simple java solution using hashmaps\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(map.containsKey(s.charAt(i))){\\n            map.put(s.charAt(i),map.get(s.charAt(i))+1);\\n            } else\\n                map.put(s.charAt(i), 0);\\n        }\\n        int prev = map.get(s.charAt(0));\\n        for(char count: map.keySet()){\\n            if(map.get(count)!= prev)\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(map.containsKey(s.charAt(i))){\\n            map.put(s.charAt(i),map.get(s.charAt(i))+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3938167,
                "title": "easy-c-solution-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char,int>mp;\\n        for(auto i :s){\\n            mp[i]++;\\n        }\\n        int num = mp[s[0]];\\n\\n        for(auto i : mp){\\n        if(i.second !=num){\\n            return false;\\n        }\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char,int>mp;\\n        for(auto i :s){\\n            mp[i]++;\\n        }\\n        int num = mp[s[0]];\\n\\n        for(auto i : mp){\\n        if(i.second !=num){\\n            return false;\\n        }\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797530,
                "title": "easy-and-direct-solution-in-java-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character,Integer> obj=new HashMap<>();\\n        for(Character i:s.toCharArray()){\\n            if(!obj.containsKey(i)){\\n                obj.put(i,1);\\n            }\\n            else{\\n                int a=obj.get(i);\\n                obj.put(i,a+1);\\n            }\\n        }\\n    char c=s.charAt(0);\\n    int oc=obj.get(c);\\n        for(Map.Entry<Character,Integer> e:obj.entrySet()){\\n            if(oc!=e.getValue()){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character,Integer> obj=new HashMap<>();\\n        for(Character i:s.toCharArray()){\\n            if(!obj.containsKey(i)){\\n                obj.put(i,1);\\n            }\\n            else{\\n                int a=obj.get(i);\\n                obj.put(i,a+1);\\n            }\\n        }\\n    char c=s.charAt(0);\\n    int oc=obj.get(c);\\n        for(Map.Entry<Character,Integer> e:obj.entrySet()){\\n            if(oc!=e.getValue()){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765763,
                "title": "java-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        for(char ch : s.toCharArray()){\\n            map.put(ch, map.getOrDefault(ch, 0)+1);\\n            \\n        }\\n        int n = map.get(s.charAt(0));\\n        for (Map.Entry<Character, Integer> entry : map.entrySet()) {\\n            if(entry.getValue() != n){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        for(char ch : s.toCharArray()){\\n            map.put(ch, map.getOrDefault(ch, 0)+1);\\n            \\n        }\\n        int n = map.get(s.charAt(0));\\n        for (Map.Entry<Character, Integer> entry : map.entrySet()) {\\n            if(entry.getValue() != n){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737889,
                "title": "easy-solution-in-c-beats-100-memory-java-python",
                "content": "# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        int temp;\\n        for  (int i=0; i<s.size(); i++)\\n        {\\n            int count=0;\\n            for (int j=0; j<s.size(); j++)\\n            {\\n                if (s[i]==s[j]) count++;\\n            }\\n            if (i==0) temp=count;\\n            if (temp!=count) return false;\\n\\n        }\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int countemp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                countemp++;\\n            }\\n            if(i==0) count=countemp;\\n            if(count!=countemp) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def areOccurrencesEqual(self, s):\\n        temp=s.count(s[0])\\n        for i in range(len(s)):\\n            if s.count(s[i])!=temp:\\n                 return False\\n        return True\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String",
                    "Counting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        int temp;\\n        for  (int i=0; i<s.size(); i++)\\n        {\\n            int count=0;\\n            for (int j=0; j<s.size(); j++)\\n            {\\n                if (s[i]==s[j]) count++;\\n            }\\n            if (i==0) temp=count;\\n            if (temp!=count) return false;\\n\\n        }\\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int countemp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                countemp++;\\n            }\\n            if(i==0) count=countemp;\\n            if(count!=countemp) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def areOccurrencesEqual(self, s):\\n        temp=s.count(s[0])\\n        for i in range(len(s)):\\n            if s.count(s[i])!=temp:\\n                 return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737876,
                "title": "easy-and-simple-solution-in-c-java-and-python-beats-100-memory",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        int temp;\\n        for  (int i=0; i<s.size(); i++)\\n        {\\n            int count=0;\\n            for (int j=0; j<s.size(); j++)\\n            {\\n                if (s[i]==s[j]) count++;\\n            }\\n            if (i==0) temp=count;\\n            if (temp!=count) return false;\\n\\n        }\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int countemp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                countemp++;\\n            }\\n            if(i==0) count=countemp;\\n            if(count!=countemp) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def areOccurrencesEqual(self, s):\\n        temp=s.count(s[0])\\n        for i in range(len(s)):\\n            if s.count(s[i])!=temp:\\n                 return False\\n        return True\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        int temp;\\n        for  (int i=0; i<s.size(); i++)\\n        {\\n            int count=0;\\n            for (int j=0; j<s.size(); j++)\\n            {\\n                if (s[i]==s[j]) count++;\\n            }\\n            if (i==0) temp=count;\\n            if (temp!=count) return false;\\n\\n        }\\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int countemp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                countemp++;\\n            }\\n            if(i==0) count=countemp;\\n            if(count!=countemp) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def areOccurrencesEqual(self, s):\\n        temp=s.count(s[0])\\n        for i in range(len(s)):\\n            if s.count(s[i])!=temp:\\n                 return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674672,
                "title": "c-easy-and-direct-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int> mp;\\n        int n=s.length();\\n        for(int i=0;i<n;i++) mp[s[i]]++;\\n        int same=mp[s[0]];\\n        for(auto it:mp){\\n            if(it.second!=same) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int> mp;\\n        int n=s.length();\\n        for(int i=0;i<n;i++) mp[s[i]]++;\\n        int same=mp[s[0]];\\n        for(auto it:mp){\\n            if(it.second!=same) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584848,
                "title": "beats-75-easy-hashmap-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        myMap = Counter(s)\\n\\n        occ = myMap[s[0]]\\n\\n        for key in myMap.keys():\\n            if myMap[key] != occ:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        myMap = Counter(s)\\n\\n        occ = myMap[s[0]]\\n\\n        for key in myMap.keys():\\n            if myMap[key] != occ:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563684,
                "title": "check-if-all-characters-have-equal-number-of-occurrences-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        int i, freq, flag=0;\\n        unordered_map<char,int> mp;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(flag==0)\\n            {\\n                freq = it.second;\\n                flag=1;\\n            }\\n            else if(it.second!=freq)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/3e5f9e3a-7406-4ad5-acd8-167e50e04510_1685075028.8665283.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        int i, freq, flag=0;\\n        unordered_map<char,int> mp;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(flag==0)\\n            {\\n                freq = it.second;\\n                flag=1;\\n            }\\n            else if(it.second!=freq)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363686,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n  m:number of distinct characters\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n\\n    unordered_map<char, int> m;\\n    for (int i = 0; i < s.size(); i++)\\n        m[s[i]]++;\\n\\n    int count = m[s[0]];\\n    for(auto e:m)\\n        if(e.second != count)\\n            return false;\\n            \\n    return true;\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n\\n    unordered_map<char, int> m;\\n    for (int i = 0; i < s.size(); i++)\\n        m[s[i]]++;\\n\\n    int count = m[s[0]];\\n    for(auto e:m)\\n        if(e.second != count)\\n            return false;\\n            \\n    return true;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261274,
                "title": "best-easiest-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        j=[]\\n        for i in set(s):\\n            j.append(s.count(i))\\n        if len(set(j))!=1:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        j=[]\\n        for i in set(s):\\n            j.append(s.count(i))\\n        if len(set(j))!=1:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192008,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n      unordered_map<char,int>mp;\\n      for(auto it:s){\\n          mp[it]++;\\n      }  \\n      vector<int>v;\\n      for(auto it:mp){\\n          v.push_back(it.second);\\n      }\\n      for(int i=1;i<v.size();i++){\\n          if(v[i]!=v[i-1]){\\n              return false;\\n          }\\n      }\\n      return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n      unordered_map<char,int>mp;\\n      for(auto it:s){\\n          mp[it]++;\\n      }  \\n      vector<int>v;\\n      for(auto it:mp){\\n          v.push_back(it.second);\\n      }\\n      for(int i=1;i<v.size();i++){\\n          if(v[i]!=v[i-1]){\\n              return false;\\n          }\\n      }\\n      return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175785,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char, int>mp;\\n        for(const auto& i : s) mp[i]++;\\n\\n        int prev = mp[s[0]];\\n\\n        for(const auto& i : mp) {\\n            if (i.second != prev) return false;\\n            prev = i.second;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char, int>mp;\\n        for(const auto& i : s) mp[i]++;\\n\\n        int prev = mp[s[0]];\\n\\n        for(const auto& i : mp) {\\n            if (i.second != prev) return false;\\n            prev = i.second;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171774,
                "title": "best-java-solution-0ms-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int [] arr = new int[26];\\n        for (int i = 0; i < s.length(); i++) arr[s.charAt(i) - \\'a\\']++;\\n\\n        int a = arr[s.charAt(0) - \\'a\\'];\\n        for (int i = 0; i < 26; i++) {\\n            if (arr[i] == 0 || arr[i] == a) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int [] arr = new int[26];\\n        for (int i = 0; i < s.length(); i++) arr[s.charAt(i) - \\'a\\']++;\\n\\n        int a = arr[s.charAt(0) - \\'a\\'];\\n        for (int i = 0; i < 26; i++) {\\n            if (arr[i] == 0 || arr[i] == a) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094262,
                "title": "c-solution-2-approaches-map-and-vector-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to store the frequencies of the characters of the string into an array and then compare if all are equal.\\n\\n# Approach - 1 (Using Vector)\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an array of size 26 initialize all elements to 0 \\n2. Use ASCII values to increase the frequencies of characters \\n3. Take the frequency of any character of the string \\n4. Compare other frequencies to this \\n5. If all are equal OR zero (did not occur in the string) return true \\n6. Else return false \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$ - constant size array created\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code - 1 \\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int> freq(26,0) ;\\n\\n        for (int i = 0 ; i < s.length() ; i++)\\n        {\\n            int num = s[i]-\\'a\\' ; \\n            freq[num]++ ; \\n        }\\n        // sort(freq.begin(), freq.end(), greater<int>());\\n\\n        // int temp = freq[0] ; \\n        int temp = freq[s[0]-\\'a\\'];\\n        for (int i = 0 ; i < 26 ; i++)\\n        {\\n            if (temp == freq[i] || freq[i] == 0 )\\n            {\\n                continue ; \\n            }\\n            else \\n            {\\n                return false ;\\n            }\\n        }\\n        return true ; \\n    }\\n};\\n```\\n\\n# Approach - 2\\n1. Create a map of <char,int> key,value pair \\n2. To store the character and it\\'s corresponding frequency in the string \\n3. Store the frequency of any character into a temporary variable \\n4. Compare if all frequencies are equal to this \\n5. If yes, return true \\n6. Else, return false\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$ - maximum size of the map can be 26\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code - 2\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char, int> mp ; \\n        for (int i = 0 ; i < s.length() ; i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        int temp = mp[s[0]];\\n\\n        for (auto i : mp)\\n        {\\n            if (i.second != temp)\\n            {\\n                return false ;\\n            }\\n        }\\n        return true ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int> freq(26,0) ;\\n\\n        for (int i = 0 ; i < s.length() ; i++)\\n        {\\n            int num = s[i]-\\'a\\' ; \\n            freq[num]++ ; \\n        }\\n        // sort(freq.begin(), freq.end(), greater<int>());\\n\\n        // int temp = freq[0] ; \\n        int temp = freq[s[0]-\\'a\\'];\\n        for (int i = 0 ; i < 26 ; i++)\\n        {\\n            if (temp == freq[i] || freq[i] == 0 )\\n            {\\n                continue ; \\n            }\\n            else \\n            {\\n                return false ;\\n            }\\n        }\\n        return true ; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char, int> mp ; \\n        for (int i = 0 ; i < s.length() ; i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        int temp = mp[s[0]];\\n\\n        for (auto i : mp)\\n        {\\n            if (i.second != temp)\\n            {\\n                return false ;\\n            }\\n        }\\n        return true ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058774,
                "title": "easy-kotlin-solution-with-hashmap-space-usage-beats-100-memory-usage-beats-95",
                "content": "This code uses a HashMap to store the count of occurrences of each character in the input string s. The space complexity of this code is O(n), where n is the number of unique characters in the input string. This is because the HashMap stores key-value pairs, where the key is the count of occurrences of a character and the value is the character itself. The maximum number of key-value pairs that can be stored in the HashMap is equal to the number of unique characters in the input string.\\n\\nThe memory usage of this code is also O(n), as it creates a new HashMap object and stores n key-value pairs in it. The time complexity of this code is O(n) as well, as it iterates through the input string once and performs a constant-time operation for each character to group them by occurrences, and check for the size of the group in the end:)\\n# Code\\n```\\nclass Solution {\\n   fun areOccurrencesEqual(s: String): Boolean {\\n    val map = HashMap<Int, Char>()\\n    s.groupBy { it }.forEach { s -> map[s.value.size] = s.key }\\n    return map.size==1\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n   fun areOccurrencesEqual(s: String): Boolean {\\n    val map = HashMap<Int, Char>()\\n    s.groupBy { it }.forEach { s -> map[s.value.size] = s.key }\\n    return map.size==1\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021306,
                "title": "c-easy-solution-using-unordered-map",
                "content": "# Complexity\\n- Time complexity: $$O(n + m)$$ => $$O(n + n)$$ => $$O(n)$$, where $$n$$ is the number of elements in the input string and $$m$$ is the number of unique letters. Because $$m$$ is less than $$n$$ in any case, then time complexity will be equal to $$O(n)$$.\\n\\n- Space complexity: $$O(n)$$, where $$n$$ is the number of elements in the input string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char, int> freq;\\n\\n        for (char ch: s) {\\n            freq[ch]++;\\n        }\\n\\n        int charCount = freq[s[0]];\\n        for (pair<char, int> keyValue: freq) {\\n            if (keyValue.second != charCount) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n### Please upwote if you like the solution)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char, int> freq;\\n\\n        for (char ch: s) {\\n            freq[ch]++;\\n        }\\n\\n        int charCount = freq[s[0]];\\n        for (pair<char, int> keyValue: freq) {\\n            if (keyValue.second != charCount) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896711,
                "title": "easy-java-solution-with-1ms-runtime-tc-o-n-beats-100-with-out-hash-with-hash",
                "content": "**If you found it easy to understand, Please do upvote :)\\nThankyou!!**\\n**--------------------------------------------------------------------------------------------------**\\n![Today Leetcode Pic.JPG](https://assets.leetcode.com/users/images/f7777010-c1a3-4928-a0a3-f42b06e9179f_1670661040.464251.jpeg)\\n\\n**--------------------------------------------------------------------------------------------------**\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code : With-out Hash\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) \\n    {\\n        int[] freq = new int[26];\\n        int max = 0;\\n        for(char ch : s.toCharArray())\\n        {\\n            int idxFromChar = ch-\\'a\\';\\n            max = Math.max(max, ++freq[idxFromChar]);\\n        }\\n\\n        for(int freqValue : freq)\\n        {\\n            if(freqValue != 0 && freqValue != max) \\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```\\n# Code : With hash\\n```\\n\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) \\n    {\\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\\n        for(char ch : s.toCharArray())\\n        {\\n            map.put(ch, map.getOrDefault(ch, 0)+1);\\n        }\\n\\n        int firstFreq = map.get(s.charAt(0));\\n        for(char key : map.keySet())\\n        {\\n            if(map.get(key) != firstFreq)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) \\n    {\\n        int[] freq = new int[26];\\n        int max = 0;\\n        for(char ch : s.toCharArray())\\n        {\\n            int idxFromChar = ch-\\'a\\';\\n            max = Math.max(max, ++freq[idxFromChar]);\\n        }\\n\\n        for(int freqValue : freq)\\n        {\\n            if(freqValue != 0 && freqValue != max) \\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) \\n    {\\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\\n        for(char ch : s.toCharArray())\\n        {\\n            map.put(ch, map.getOrDefault(ch, 0)+1);\\n        }\\n\\n        int firstFreq = map.get(s.charAt(0));\\n        for(char key : map.keySet())\\n        {\\n            if(map.get(key) != firstFreq)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841823,
                "title": "javascript-solution",
                "content": "**Runtime: 104 ms, faster than 61.11% of JavaScript online submissions for Check if All Characters Have Equal Number of Occurrences.\\nMemory Usage: 43.1 MB, less than 89.20% of JavaScript online submissions for Check if All Characters Have Equal Number of Occurrences.**\\n```\\nvar areOccurrencesEqual = function (s) {\\n  const map = new Map();\\n  for (let i = 0; i < s.length; i++) {\\n    map.set(s[i], map.has(s[i]) ? map.get(s[i]) + 1 : 1);\\n  }\\n  let occurance = map.get(s[0]);\\n  for (const [k, v] of map) {\\n    if (v === occurance) {\\n      continue;\\n    } else {\\n      return false;\\n    }\\n  }\\n  return true;\\n};\\n```\\n**Plz upvote if it helped you**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar areOccurrencesEqual = function (s) {\\n  const map = new Map();\\n  for (let i = 0; i < s.length; i++) {\\n    map.set(s[i], map.has(s[i]) ? map.get(s[i]) + 1 : 1);\\n  }\\n  let occurance = map.get(s[0]);\\n  for (const [k, v] of map) {\\n    if (v === occurance) {\\n      continue;\\n    } else {\\n      return false;\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2811273,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int>mp;\\n        for(char ch:s)mp[ch]++;\\n        int cnt=mp[s[0]];\\n        for(auto x:mp){\\n            if(x.second!=cnt)return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int>mp;\\n        for(char ch:s)mp[ch]++;\\n        int cnt=mp[s[0]];\\n        for(auto x:mp){\\n            if(x.second!=cnt)return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2805845,
                "title": "easy-solution-using-hashmap-in-java-with-explanation",
                "content": "### This code checks if all the characters in a string have the same number of occurrences.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use HashMap to store the characters and their number of occurrences. Then it iterates through the map, checking if all values are equal to each other.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int n= s.length();\\n        int count =0;\\n        // Storing the Characters in HashMap\\n      HashMap<Character,Integer> map = new HashMap<>(); \\n      for(int i=0; i<n; i++) {   \\n          if(map.containsKey(s.charAt(i)))\\n              map.put(s.charAt(i),map.get(s.charAt(i))+1);\\n          else \\n              map.put(s.charAt(i),1);\\n      }\\n        //Check the count      \\n                  count = map.get(s.charAt(0)); \\n\\n    // Comparing the count of the element woth other elements\\n      for(Map.Entry<Character,Integer> e : map.entrySet()){\\n          if(e.getValue()!=count) return false;\\n      }\\n      return true;\\n    }\\n}\\n```\\n## Upvote me if you like the solution.... Happy Coding\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int n= s.length();\\n        int count =0;\\n        // Storing the Characters in HashMap\\n      HashMap<Character,Integer> map = new HashMap<>(); \\n      for(int i=0; i<n; i++) {   \\n          if(map.containsKey(s.charAt(i)))\\n              map.put(s.charAt(i),map.get(s.charAt(i))+1);\\n          else \\n              map.put(s.charAt(i),1);\\n      }\\n        //Check the count      \\n                  count = map.get(s.charAt(0)); \\n\\n    // Comparing the count of the element woth other elements\\n      for(Map.Entry<Character,Integer> e : map.entrySet()){\\n          if(e.getValue()!=count) return false;\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792304,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n        HashMap<Character,Integer>map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            if(!map.containsKey(s.charAt(i))){\\n                map.put(s.charAt(i),1);\\n            }\\n            else{\\n                map.put(s.charAt(i),map.get(s.charAt(i))+1);\\n            }\\n        }\\n        \\n        int a=map.get(s.charAt(0));\\n        for(Character i:map.keySet()){\\n            if(map.get(i)!=a){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n        HashMap<Character,Integer>map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            if(!map.containsKey(s.charAt(i))){\\n                map.put(s.charAt(i),1);\\n            }\\n            else{\\n                map.put(s.charAt(i),map.get(s.charAt(i))+1);\\n            }\\n        }\\n        \\n        int a=map.get(s.charAt(0));\\n        for(Character i:map.keySet()){\\n            if(map.get(i)!=a){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668191,
                "title": "java-solution-using-hashmap-o-n-solution-easy-to-understand",
                "content": "Java Solution with comments\\n\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        if(s.length() == 1) return true;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        int count=0;\\n        for(int i=0; i<s.length();i++){ //add elements and their counts in the hashmap\\n            char ele = s.charAt(i);\\n            if(map.containsKey(ele)){\\n                map.put(ele,map.get(ele)+1);\\n            }\\n            else{\\n                map.put(ele,1);\\n            }\\n            if(i == s.length()-1){\\n                count = map.get(ele); //get frequency of a single character\\n            }\\n        }\\n        \\n        for(Map.Entry<Character,Integer> e: map.entrySet()){ //Using a Iterator to traverse through the hashmap\\n            if(e.getValue() != count){ //Condition to check whether other characters frequency is same or not\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        if(s.length() == 1) return true;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        int count=0;\\n        for(int i=0; i<s.length();i++){ //add elements and their counts in the hashmap\\n            char ele = s.charAt(i);\\n            if(map.containsKey(ele)){\\n                map.put(ele,map.get(ele)+1);\\n            }\\n            else{\\n                map.put(ele,1);\\n            }\\n            if(i == s.length()-1){\\n                count = map.get(ele); //get frequency of a single character\\n            }\\n        }\\n        \\n        for(Map.Entry<Character,Integer> e: map.entrySet()){ //Using a Iterator to traverse through the hashmap\\n            if(e.getValue() != count){ //Condition to check whether other characters frequency is same or not\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662591,
                "title": "java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) \\n    {\\n        Map<Character,Integer> map=new HashMap<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            Character ch=(Character)s.charAt(i);\\n            if(map.containsKey(ch))\\n                map.replace(ch,map.get(ch),map.get(ch)+1);\\n            else\\n                map.put(ch,1);\\n        }\\n        int k=map.get((Character)s.charAt(0));\\n        for(int m : map.values())\\n        {\\n            if(m !=k)\\n                return false;\\n        }\\n            \\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) \\n    {\\n        Map<Character,Integer> map=new HashMap<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            Character ch=(Character)s.charAt(i);\\n            if(map.containsKey(ch))\\n                map.replace(ch,map.get(ch),map.get(ch)+1);\\n            else\\n                map.put(ch,1);\\n        }\\n        int k=map.get((Character)s.charAt(0));\\n        for(int m : map.values())\\n        {\\n            if(m !=k)\\n                return false;\\n        }\\n            \\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656488,
                "title": "simple-python-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        dicta={}\\n        for i in s:\\n            dicta[i]=s.count(i)\\n        d=dicta[s[0]]\\n        print(d)\\n        for i,j in enumerate(dicta):\\n            print(j)\\n            if dicta[j]!=d:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        dicta={}\\n        for i in s:\\n            dicta[i]=s.count(i)\\n        d=dicta[s[0]]\\n        print(d)\\n        for i,j in enumerate(dicta):\\n            print(j)\\n            if dicta[j]!=d:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653727,
                "title": "my-java-solution-using-hashmap",
                "content": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        Map<Character,Integer> map=new HashMap<>();\\n        char ch=s.charAt(0);\\n        int c=0;\\n        for(int i=0;i<s.length();i++){\\n            if(ch==s.charAt(i))\\n                c++;\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        \\n        for(Map.Entry<Character,Integer> entry: map.entrySet()){\\n            if(entry.getValue()!=c)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        Map<Character,Integer> map=new HashMap<>();\\n        char ch=s.charAt(0);\\n        int c=0;\\n        for(int i=0;i<s.length();i++){\\n            if(ch==s.charAt(i))\\n                c++;\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2579311,
                "title": "java-beats-100-fastest-simple",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n        int arr[]=new int[26];\\n        int val=0;\\n        for(char ch:s.toCharArray()) {\\n            arr[ch-\\'a\\']++;\\n            val=arr[ch-\\'a\\'];\\n        }\\n        \\n        for(int i=0;i<=25;i++) {\\n            if(arr[i]!=0) if(val!=arr[i]) return false;\\n        }\\n        \\n        \\n        return true;\\n  \\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n        int arr[]=new int[26];\\n        int val=0;\\n        for(char ch:s.toCharArray()) {\\n            arr[ch-\\'a\\']++;\\n            val=arr[ch-\\'a\\'];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2519486,
                "title": "3-lines",
                "content": "\\n\\tfrom collections import Counter\\n\\t\\tc = Counter(s)\\n        return len(set(c.values())) == 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\tfrom collections import Counter\\n\\t\\tc = Counter(s)\\n        return len(set(c.values())) == 1",
                "codeTag": "Python3"
            },
            {
                "id": 2491304,
                "title": "ruby-1-line-simple-solution",
                "content": "```\\ndef are_occurrences_equal(s)\\n    s.chars.tally.values.uniq.size == 1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef are_occurrences_equal(s)\\n    s.chars.tally.values.uniq.size == 1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2483543,
                "title": "javascript",
                "content": "var areOccurrencesEqual = function(s) {\\n    const map = {};\\n    \\n    for(let letter of s){\\n        if(!map[letter]) map[letter] = 1 \\n        else map[letter] +=1\\n    }\\n    \\n   return !Object.values(map).some(item => item !==  Object.values(map)[0] )\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var areOccurrencesEqual = function(s) {\\n    const map = {};\\n    \\n    for(let letter of s){\\n        if(!map[letter]) map[letter] = 1 \\n        else map[letter] +=1\\n    }\\n    \\n   return !Object.values(map).some(item => item !==  Object.values(map)[0] )\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2434977,
                "title": "java-1-ms-100-faster-character-array-easy-simple-solution",
                "content": "```\\npublic boolean areOccurrencesEqual(String s) {\\n        int[] a = new int[26];\\n        char[] c = s.toCharArray();\\n        for(char i : c) {\\n            a[i-\\'a\\']++;\\n        }\\n        int t = a[c[0]-\\'a\\'];\\n        for(int i : a) {\\n            if(i!=t&&i!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic boolean areOccurrencesEqual(String s) {\\n        int[] a = new int[26];\\n        char[] c = s.toCharArray();\\n        for(char i : c) {\\n            a[i-\\'a\\']++;\\n        }\\n        int t = a[c[0]-\\'a\\'];\\n        for(int i : a) {\\n            if(i!=t&&i!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426345,
                "title": "simple-and-easy-java-solution",
                "content": "**Upvote if it helps**.\\n```\\nclass Solution {\\n\\tpublic boolean areOccurrencesEqual(String s) {\\n\\t\\tHashMap<Character, Integer> Map = new HashMap<Character, Integer>();\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tchar c = s.charAt(i);\\n\\t\\t\\tMap.put(c, Map.getOrDefault(c, 0) + 1);\\n\\t\\t}\\n\\t\\tint size = Map.get(s.charAt(0));\\n\\t\\tfor (int i : Map.values())\\n\\t\\t\\tif (i != size)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic boolean areOccurrencesEqual(String s) {\\n\\t\\tHashMap<Character, Integer> Map = new HashMap<Character, Integer>();\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tchar c = s.charAt(i);\\n\\t\\t\\tMap.put(c, Map.getOrDefault(c, 0) + 1);\\n\\t\\t}\\n\\t\\tint size = Map.get(s.charAt(0));\\n\\t\\tfor (int i : Map.values())\\n\\t\\t\\tif (i != size)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335821,
                "title": "python-short-simple-dictionary",
                "content": "```\\n# using \"Counter\" function and dictionary\\n# using dictionary for storing each element and its frequency\\n# thereafter cheaking for equality\\n def areOccurrencesEqual(self, s: str) -> bool:\\n        dic = Counter(s)\\n        dic1 = {}\\n        flag = 0\\n        for i in dic.values():\\n            if flag == 0 and i not in dic1:\\n                dic1[i] = -1\\n                flag = 1\\n            elif flag == 1 and i not in dic1:\\n                return 0\\n        return 1\\n```\\n\\n   OR\\n\\n```\\n# python One liner solution\\ndef areOccurrencesEqual(self, s: str) -> bool:\\n\\t\\treturn 1 if len(set(Counter(s).values())) == 1 else 0                \\n```\\n\\n**\"Upvote\" if you found it worthy**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# using \"Counter\" function and dictionary\\n# using dictionary for storing each element and its frequency\\n# thereafter cheaking for equality\\n def areOccurrencesEqual(self, s: str) -> bool:\\n        dic = Counter(s)\\n        dic1 = {}\\n        flag = 0\\n        for i in dic.values():\\n            if flag == 0 and i not in dic1:\\n                dic1[i] = -1\\n                flag = 1\\n            elif flag == 1 and i not in dic1:\\n                return 0\\n        return 1\\n```\n```\\n# python One liner solution\\ndef areOccurrencesEqual(self, s: str) -> bool:\\n\\t\\treturn 1 if len(set(Counter(s).values())) == 1 else 0                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2242681,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> ht = new HashMap<Character, Integer>();\\n       \\n        for(int i=0; i<s.length(); i++){\\n            Character c = s.charAt(i);\\n            if (ht.containsKey(c)){\\n                 ht.put(c, ht.get(c) + 1);\\n            }\\n            else{\\n                ht.put(c, 1);\\n            }\\n        }\\n       \\n        int num = Integer.MIN_VALUE;\\n       \\n        Iterator iterator = ht.entrySet().iterator();\\n        while (iterator.hasNext()) {\\n           \\n            Map.Entry mapElement = (Map.Entry)iterator.next();\\n            int n = (int)mapElement.getValue();\\n           \\n            if (num == Integer.MIN_VALUE){\\n                num = n;\\n            }\\n            else{\\n                if (num != n){  \\n                    return false;\\n                }\\n            }\\n        }\\n       \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> ht = new HashMap<Character, Integer>();\\n       \\n        for(int i=0; i<s.length(); i++){\\n            Character c = s.charAt(i);\\n            if (ht.containsKey(c)){\\n                 ht.put(c, ht.get(c) + 1);\\n            }\\n            else{\\n                ht.put(c, 1);\\n            }\\n        }\\n       \\n        int num = Integer.MIN_VALUE;\\n       \\n        Iterator iterator = ht.entrySet().iterator();\\n        while (iterator.hasNext()) {\\n           \\n            Map.Entry mapElement = (Map.Entry)iterator.next();\\n            int n = (int)mapElement.getValue();\\n           \\n            if (num == Integer.MIN_VALUE){\\n                num = n;\\n            }\\n            else{\\n                if (num != n){  \\n                    return false;\\n                }\\n            }\\n        }\\n       \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135594,
                "title": "java-best-slution",
                "content": "****class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<s.length();j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                {\\n                    count++;\\n                }\\n                arr[i]=count;\\n            }\\n        }\\n        int res=0;\\n        for(int i=1;i<arr.length-1;i++){\\n            if(arr[i-1]!=arr[i])\\n            {\\n                res++;\\n            }\\n        }\\n        if(res==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n }",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<s.length();j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                {\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2134899,
                "title": "simple-java-solution-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> m = new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            char x = s.charAt(i);\\n            m.put(x, m.getOrDefault(x, 0) + 1);\\n        }\\n        int std = m.get(s.charAt(0));\\n        for(int i=1; i<s.length(); i++){\\n            if(m.get(s.charAt(i)) != std) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character, Integer> m = new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            char x = s.charAt(i);\\n            m.put(x, m.getOrDefault(x, 0) + 1);\\n        }\\n        int std = m.get(s.charAt(0));\\n        for(int i=1; i<s.length(); i++){\\n            if(m.get(s.charAt(i)) != std) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122454,
                "title": "c-easy-approach-explanation-with-examples",
                "content": "```\\n=> IF THE SOLUTION WAS USEFUL,THEN DO NOT FORGET TO UPVOTE!! \\u2714\\n\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        \\n        map<char,int> map;\\n        int c=0;\\n        bool result = true;\\n        \\n        for(auto i:s)                  //storing the values into map\\n        {                             // for example s = abacbc ..........a=2, b=2, c=2\\n            map[i]++;\\n        }\\n        \\n        \\n        for(auto i:map)\\n        {\\n            if(c==0)             \\n                c=i.second;          //storing the count of first char \\n            else\\n            {\\n                if(c!=i.second)      //checking for all other characters whether they contain same no of char or not\\n                    result=false;    // if not return false\\n            }\\n        }\\n        return result;               //if for loop completes that means all char are having same count of occurences\\n\\t\\t                                   //so return true\\n    }\\n};\\n\\n=> IF THE SOLUTION WAS USEFUL, THEN DO NOT FORGET TO UPVOTE!! \\u2714\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n=> IF THE SOLUTION WAS USEFUL,THEN DO NOT FORGET TO UPVOTE!! \\u2714\\n\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        \\n        map<char,int> map;\\n        int c=0;\\n        bool result = true;\\n        \\n        for(auto i:s)                  //storing the values into map\\n        {                             // for example s = abacbc ..........a=2, b=2, c=2\\n            map[i]++;\\n        }\\n        \\n        \\n        for(auto i:map)\\n        {\\n            if(c==0)             \\n                c=i.second;          //storing the count of first char \\n            else\\n            {\\n                if(c!=i.second)      //checking for all other characters whether they contain same no of char or not\\n                    result=false;    // if not return false\\n            }\\n        }\\n        return result;               //if for loop completes that means all char are having same count of occurences\\n\\t\\t                                   //so return true\\n    }\\n};\\n\\n=> IF THE SOLUTION WAS USEFUL, THEN DO NOT FORGET TO UPVOTE!! \\u2714\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118678,
                "title": "c-clean-easy-unordered-map",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool areOccurrencesEqual(string s) {\\n\\t\\t\\tunordered_map<char,int>m;\\n\\t\\t\\tfor(auto i : s){\\n\\t\\t\\t\\tm[i]++;\\n\\t\\t\\t}\\n\\t\\t\\tint c=m[s[0]];\\n\\t\\t\\tfor(auto x:m){\\n\\t\\t\\t\\tif(c!=x.second)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool areOccurrencesEqual(string s) {\\n\\t\\t\\tunordered_map<char,int>m;\\n\\t\\t\\tfor(auto i : s){\\n\\t\\t\\t\\tm[i]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2087932,
                "title": "java-solution-with-comments-to-understand-the-solution",
                "content": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n        // create the map to map every char with there ouccurrence\\n        HashMap<Character, Integer> Occur = new HashMap<>();\\n        \\n        // puting all the char in hash map\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            char ch = s.charAt(i); \\n            Occur.put(s.charAt(i), Occur.get(ch) == null ? 1 :  Occur.get(ch)+1 );\\n        }\\n        \\n        // just take the freq of the first char\\n        int freq = Occur.get(s.charAt(0));\\n        \\n        // lets check the freq of all the char in map\\n        for(int i=1; i<s.length(); i++)\\n        {\\n            if(Occur.get(s.charAt(i)) != freq)//it should be the same freq as the first one, if it is not then return false\\n                return false;\\n        }\\n        \\n        // is every thing going fine then return true.\\n        return true;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n        // create the map to map every char with there ouccurrence\\n        HashMap<Character, Integer> Occur = new HashMap<>();\\n        \\n        // puting all the char in hash map\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            char ch = s.charAt(i); \\n            Occur.put(s.charAt(i), Occur.get(ch) == null ? 1 :  Occur.get(ch)+1 );\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2070924,
                "title": "faster-than-100-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int> cnt(26);\\n        for(int i=0;i<s.size();++i){\\n            cnt[s[i]-\\'a\\']++;\\n        }\\n        set<int> st;\\n        for(int i=0;i<26;++i){\\n            if(cnt[i]!=0){\\n                st.insert(cnt[i]);\\n            }\\n        }\\n        return st.size()==1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int> cnt(26);\\n        for(int i=0;i<s.size();++i){\\n            cnt[s[i]-\\'a\\']++;\\n        }\\n        set<int> st;\\n        for(int i=0;i<26;++i){\\n            if(cnt[i]!=0){\\n                st.insert(cnt[i]);\\n            }\\n        }\\n        return st.size()==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032153,
                "title": "easy-solution-c-o-n",
                "content": "**Time complexity- O(n)**\\n**Space complexity-O(1)**\\n\\n```\\nbool areOccurrencesEqual(string s) {\\n        vector<int>x(27,0);\\n        for(int i=0;i<s.length();i++) // in array storing all alphabets count\\n        {\\n            x[s[i]-97]++;\\n        }\\n        int c=0;\\n        for(int i=0;i<27;i++) \\n        {\\n            if(x[i]==0)  // ignore all alphabets which is not there in string\\n            {\\n                continue;\\n            }\\n            if(c==0)\\n            {\\n                c=x[i];\\n            }\\n            else if(x[i]!=c)  // which exist compare it with one of first non zero element in array\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        return true;;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nbool areOccurrencesEqual(string s) {\\n        vector<int>x(27,0);\\n        for(int i=0;i<s.length();i++) // in array storing all alphabets count\\n        {\\n            x[s[i]-97]++;\\n        }\\n        int c=0;\\n        for(int i=0;i<27;i++) \\n        {\\n            if(x[i]==0)  // ignore all alphabets which is not there in string\\n            {\\n                continue;\\n            }\\n            if(c==0)\\n            {\\n                c=x[i];\\n            }\\n            else if(x[i]!=c)  // which exist compare it with one of first non zero element in array\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        return true;;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1984799,
                "title": "simple-solution-in-java-hash-table-and-set-o-n",
                "content": "\\'\\'\\'class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        Set<Integer> set = new HashSet<>(map.values());\\n        if(set.size() == 1){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i),0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1980559,
                "title": "python-simple-approach-and-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        a = []\\n        for i in s:\\n            a.append(s.count(i))\\n        print(a)\\n        if a.count(a[0]) == len(a):\\n            return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        a = []\\n        for i in s:\\n            a.append(s.count(i))\\n        print(a)\\n        if a.count(a[0]) == len(a):\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919798,
                "title": "java",
                "content": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        //converting given string to character array\\n        char arr[] = s.toCharArray();\\n        for(char i:arr){\\n            if(map.containsKey(i)){\\n                // If char is present in map,\\n                // incrementing it\\'s count by 1\\n                map.put(i, map.get(i) + 1);\\n            }\\n            else {\\n \\n                // If char is not present in map,\\n                // putting this char to map with 1 as it\\'s value\\n                map.put(i, 1);\\n            }\\n        }\\n        Object value = null;\\n        for (Object entry : map.values()) {\\n          if (value == null) {\\n            value = entry;\\n          } else if (!value.equals(entry)) {\\n            return false;\\n          }\\n        }\\n\\n        return true;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        //converting given string to character array\\n        char arr[] = s.toCharArray();\\n        for(char i:arr){\\n            if(map.containsKey(i)){\\n                // If char is present in map,\\n                // incrementing it\\'s count by 1\\n                map.put(i, map.get(i) + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1898094,
                "title": "100-faster-time-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int> v(26,0);\\n        for(auto it:s){\\n            v[it-\\'a\\']++;\\n        }\\n        int tem=v[s[0]-\\'a\\'];\\n        for(int i=0;i<26;i++){\\n            if(v[i]==tem || v[i]==0)\\n                continue;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int> v(26,0);\\n        for(auto it:s){\\n            v[it-\\'a\\']++;\\n        }\\n        int tem=v[s[0]-\\'a\\'];\\n        for(int i=0;i<26;i++){\\n            if(v[i]==tem || v[i]==0)\\n                continue;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897126,
                "title": "100-faster-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s)\\n    {\\n        int n = s.size();\\n        vector<int>count(26);\\n        for(int i=0;i<n;i++)\\n        {\\n            count[s[i] - \\'a\\']++;\\n        }\\n        int cnt = INT_MAX;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(count[i]>0)\\n            {\\n                if(cnt == INT_MAX)\\n                {\\n                    cnt = count[i];\\n                }\\n                else\\n                {\\n                    if(cnt!=count[i])\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s)\\n    {\\n        int n = s.size();\\n        vector<int>count(26);\\n        for(int i=0;i<n;i++)\\n        {\\n            count[s[i] - \\'a\\']++;\\n        }\\n        int cnt = INT_MAX;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(count[i]>0)\\n            {\\n                if(cnt == INT_MAX)\\n                {\\n                    cnt = count[i];\\n                }\\n                else\\n                {\\n                    if(cnt!=count[i])\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894094,
                "title": "python-solution-100-faster-hashmap-based-two-solutions-clean-code-1-liner",
                "content": "### Solution 1\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        store = defaultdict()\\n        for char in s:\\n            store[char] += 1\\n        if len(set(store.values())) == 1: return True\\n        return False\\n```\\n### Solution 2\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        store = defaultdict()\\n        for char in s:\\n            store[char] += 1\\n        if len(set(store.values())) == 1: return True\\n        return False\\n```\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883126,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n\\n        int[] charValuesCount = new int[26];\\n        Arrays.fill(charValuesCount, -1);\\n        for (int i = 0; i < s.length(); i++) {\\n            charValuesCount[s.charAt(i) - \\'a\\'] += 1;\\n        }\\n        int countToCompare = -1;\\n        for (int val : charValuesCount) {\\n            if (val != -1) {\\n                countToCompare = val;\\n                break;\\n            }\\n        }\\n        for (int val : charValuesCount) {\\n            if (val != -1 && val != countToCompare) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n\\n        int[] charValuesCount = new int[26];\\n        Arrays.fill(charValuesCount, -1);\\n        for (int i = 0; i < s.length(); i++) {\\n            charValuesCount[s.charAt(i) - \\'a\\'] += 1;\\n        }\\n        int countToCompare = -1;\\n        for (int val : charValuesCount) {\\n            if (val != -1) {\\n                countToCompare = val;\\n                break;\\n            }\\n        }\\n        for (int val : charValuesCount) {\\n            if (val != -1 && val != countToCompare) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881963,
                "title": "c-easiest-solution",
                "content": "Hashmap approach made it a piece of cake!\\n\\nPlease give me an upvote this helped you out!\\n\\n```\\nbool areOccurrencesEqual(string s) {\\n        std::unordered_map<char, int> um;\\n\\n        for(const auto& itr : s)\\n            um[itr]++;\\n        \\n        int c = um[s[0]];\\n        \\n        for(const auto& itr : um)\\n            if (itr.second != c)\\n                return false;\\n        \\n        return true;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool areOccurrencesEqual(string s) {\\n        std::unordered_map<char, int> um;\\n\\n        for(const auto& itr : s)\\n            um[itr]++;\\n        \\n        int c = um[s[0]];\\n        \\n        for(const auto& itr : um)\\n            if (itr.second != c)\\n                return false;\\n        \\n        return true;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1877056,
                "title": "both-solutions-inbuilt-hashmap-and-manual-hashing",
                "content": "using manual hashing :\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n    \\tint[] arr=new int[26];\\n    \\tfor(char c:s.toCharArray()) {\\n    \\t\\tarr[c-\\'a\\']++;\\n    \\t}\\n    \\tint num=arr[s.charAt(0)-\\'a\\'];\\n    \\tfor(int i:arr) {\\n    \\t\\tif(i!=0 && num!=i) {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\treturn true;\\n    }\\n}\\n```\\n\\nusing inbuilt hashmap :\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        Map<Character,Integer> map=new HashMap<Character,Integer>();\\n    \\tfor(int i=0;i<s.length();i++) {\\n    \\t\\tchar c=s.charAt(i);\\n    \\t\\tint count=map.getOrDefault(c, 0);\\n    \\t\\tmap.put(c, count+1);\\n    \\t}\\n    \\treturn new HashSet<>(map.values()).size()<=1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n    \\tint[] arr=new int[26];\\n    \\tfor(char c:s.toCharArray()) {\\n    \\t\\tarr[c-\\'a\\']++;\\n    \\t}\\n    \\tint num=arr[s.charAt(0)-\\'a\\'];\\n    \\tfor(int i:arr) {\\n    \\t\\tif(i!=0 && num!=i) {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\treturn true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        Map<Character,Integer> map=new HashMap<Character,Integer>();\\n    \\tfor(int i=0;i<s.length();i++) {\\n    \\t\\tchar c=s.charAt(i);\\n    \\t\\tint count=map.getOrDefault(c, 0);\\n    \\t\\tmap.put(c, count+1);\\n    \\t}\\n    \\treturn new HashSet<>(map.values()).size()<=1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867552,
                "title": "one-line-solution-with-80-less-memory-usage",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set([s.count(i) for i in s])) == 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set([s.count(i) for i in s])) == 1",
                "codeTag": "Java"
            },
            {
                "id": 1849978,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        h = collections.Counter(s)\\n        return len(set(h.values())) == 1\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        h = collections.Counter(s)\\n        return len(set(h.values())) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836676,
                "title": "c-hashmap-solution-100-fast",
                "content": "```\\nbool areOccurrencesEqual(string s) {\\n        unordered_map<char,int> mp;\\n        for(char &c:s)\\n            mp[c]++;\\n        int x = mp[s[0]];\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n            if(x!=(*it).second)\\n                return false;\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool areOccurrencesEqual(string s) {\\n        unordered_map<char,int> mp;\\n        for(char &c:s)\\n            mp[c]++;\\n        int x = mp[s[0]];\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n            if(x!=(*it).second)\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1806924,
                "title": "python-3-solution-93-faster-runtime-2-lines-solution",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        lst = [s.count(i) for i in set(s)]\\n        return len(set(lst)) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        lst = [s.count(i) for i in set(s)]\\n        return len(set(lst)) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789279,
                "title": "java-easy-100-faster-solution",
                "content": "We can do it simply with the use of an array to store the frequency of each alphabet a to z and then check the frequency is either 0 or equal to the frequency of first alphabet in the string...\\n```\\nint a[]= new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int x=(int)s.charAt(i)-97;\\n            a[x]=a[x]+1;\\n        }\\n           int c=a[(int)s.charAt(0)-97];\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]!=0&&a[i]!=c)\\n                return false;\\n        }\\n        return true;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint a[]= new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int x=(int)s.charAt(i)-97;\\n            a[x]=a[x]+1;\\n        }\\n           int c=a[(int)s.charAt(0)-97];\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]!=0&&a[i]!=c)\\n                return false;\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1782278,
                "title": "python3-counter-solution-faster-than-99-45",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        s = set(Counter(s).values())\\n        if len(s) > 1:\\n            return False\\n        \\n        return True\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        s = set(Counter(s).values())\\n        if len(s) > 1:\\n            return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780866,
                "title": "cpp-solution-simple-and-easy-to-understand-using-hashtable",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n       map<int , int>check;\\n        for(auto str : s){\\n            check[str]++;\\n        } // Mapping all elements here\\n        int occ = count(s.begin() , s.end() , s[0]); // Counting the occurances of the first character\\n        for(int i = 0 ; i < s.size() ; i++){\\n            if(check[s[i]]!=occ) // Comparing it with the occurances of other characters\\n                return false;\\n        } \\n        return true;\\n    }\\n};\\n```\\n**Please upvote**\\n*Thank You*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n       map<int , int>check;\\n        for(auto str : s){\\n            check[str]++;\\n        } // Mapping all elements here\\n        int occ = count(s.begin() , s.end() , s[0]); // Counting the occurances of the first character\\n        for(int i = 0 ; i < s.size() ; i++){\\n            if(check[s[i]]!=occ) // Comparing it with the occurances of other characters\\n                return false;\\n        } \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774846,
                "title": "c-solution",
                "content": "public class Solution {\\n    public bool AreOccurrencesEqual(string s) {\\n        var arr = new int[26];\\n\\t\\tfor (int i = 0; i < s.Length; i++)\\n\\t\\t{\\n\\t\\t\\tarr[s[i]-\\'a\\']++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tvar num=arr.Where(c=>c!=0).Distinct();\\n\\t\\tif(num.Count()>1)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public bool AreOccurrencesEqual(string s) {\\n        var arr = new int[26];\\n\\t\\tfor (int i = 0; i < s.Length; i++)\\n\\t\\t{\\n\\t\\t\\tarr[s[i]-\\'a\\']++;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1756946,
                "title": "c-solution-check-if-all-characters-have-equal-number-of-occurrences",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int> arr(26);\\n        for(int i = 0 ; i < s.length(); i++){\\n            int index = s[i] - \\'a\\';\\n            arr[index]++;\\n        }\\n        sort(arr.begin() , arr.end());\\n        int checker = arr[25];\\n        \\n        int k = 24;\\n        while(k>=0 && arr[k]!=0){\\n            if(arr[k] != checker)\\n                return false;\\n            k--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int> arr(26);\\n        for(int i = 0 ; i < s.length(); i++){\\n            int index = s[i] - \\'a\\';\\n            arr[index]++;\\n        }\\n        sort(arr.begin() , arr.end());\\n        int checker = arr[25];\\n        \\n        int k = 24;\\n        while(k>=0 && arr[k]!=0){\\n            if(arr[k] != checker)\\n                return false;\\n            k--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720011,
                "title": "scala-1l-86",
                "content": "```scala\\nobject Solution {\\n    def areOccurrencesEqual(s: String): Boolean = {\\n        s.distinct.map(ch => s.count(_ == ch)).distinct.length == 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nobject Solution {\\n    def areOccurrencesEqual(s: String): Boolean = {\\n        s.distinct.map(ch => s.count(_ == ch)).distinct.length == 1\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1660240,
                "title": "python-simple-20ms-faster-than-80",
                "content": "class Solution(object):\\n    def areOccurrencesEqual(self, s):\\n\\n        count = \"\"\\n        for i in set(s):\\n            c = s.count(i)\\n            if(count==\"\"):\\n                count+=str(c)\\n            if(str(c) not in count):\\n                \\n                return False\\n        return True\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def areOccurrencesEqual(self, s):\\n\\n        count = \"\"\\n        for i in set(s):\\n            c = s.count(i)\\n            if(count==\"\"):\\n                count+=str(c)\\n            if(str(c) not in count):\\n                \\n                return False\\n        return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 1654383,
                "title": "rust-early-return",
                "content": "```\\nimpl Solution {\\n    pub fn are_occurrences_equal(s: String) -> bool {\\n        let mut map = std::collections::HashMap::new();\\n\\n        for c in s.chars() {\\n            *map.entry(c).or_insert(0) += 1;\\n\\n        }\\n\\n        let mut prev: Option<&i32> = None;\\n\\n        for (_, v) in map.iter() {\\n            if prev.is_some() && prev.unwrap() != v {\\n                return false;\\n            }\\n\\n            prev = Some(v);\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn are_occurrences_equal(s: String) -> bool {\\n        let mut map = std::collections::HashMap::new();\\n\\n        for c in s.chars() {\\n            *map.entry(c).or_insert(0) += 1;\\n\\n        }\\n\\n        let mut prev: Option<&i32> = None;\\n\\n        for (_, v) in map.iter() {\\n            if prev.is_some() && prev.unwrap() != v {\\n                return false;\\n            }\\n\\n            prev = Some(v);\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1645147,
                "title": "java-hashmap-solution",
                "content": "Steps:\\n1.Store the characters and its frequencies in a HashMap\\n2.Store all the values of the map in a HashSet\\n3. If the Hashset contains only 1 value, then return true. Else return false.\\n\\nNote: HashSet doesnot store duplicates. It means that if all the values in the map are same, the hashset should have size equal to 1.\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        Map<Character, Integer> map = new HashMap<Character, Integer>();\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(map.containsKey(ch)){\\n                map.put(ch, map.get(ch) + 1);\\n            }\\n            else{\\n                map.put(ch, 1);\\n            }\\n        }\\n        Set<Integer> set = new HashSet<Integer>(map.values());\\n        if(set.size() == 1){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        Map<Character, Integer> map = new HashMap<Character, Integer>();\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(map.containsKey(ch)){\\n                map.put(ch, map.get(ch) + 1);\\n            }\\n            else{\\n                map.put(ch, 1);\\n            }\\n        }\\n        Set<Integer> set = new HashSet<Integer>(map.values());\\n        if(set.size() == 1){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639033,
                "title": "java-easy-solution-100-faster-99-6-space-utilized",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int count[]=new int[26];\\n        for(int i=0;i<s.length();i++) count[s.charAt(i)-97]+=1;\\n        int num=count[s.charAt(0)-97];\\n        for(int i:count) if(i!=0&&i!=num) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int count[]=new int[26];\\n        for(int i=0;i<s.length();i++) count[s.charAt(i)-97]+=1;\\n        int num=count[s.charAt(0)-97];\\n        for(int i:count) if(i!=0&&i!=num) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625362,
                "title": "faster-than-98-88-of-python-online-submissions-hashmaps",
                "content": "![image](https://assets.leetcode.com/users/images/e0d9ac6c-a171-4455-9578-6fbbc65917ab_1639322470.1977582.png)\\n        h={}\\n        a=list(s)\\n        for e in a:\\n            if e in h:\\n                h[e]+=1\\n            else:\\n                h[e]=1\\n        i=0\\n        t=0\\n        for e in h.values():\\n            if i:\\n                if t!=e:\\n                    return False\\n            else:\\n                i=1;t=e\\n        return True",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/e0d9ac6c-a171-4455-9578-6fbbc65917ab_1639322470.1977582.png)\\n        h={}\\n        a=list(s)\\n        for e in a:\\n            if e in h:\\n                h[e]+=1\\n            else:\\n                h[e]=1\\n        i=0\\n        t=0\\n        for e in h.values():\\n            if i:\\n                if t!=e:\\n                    return False\\n            else:\\n                i=1;t=e\\n        return True",
                "codeTag": "Unknown"
            },
            {
                "id": 1624641,
                "title": "python-one-liner-beats-95-submissions",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(Counter(Counter(s).values())) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(Counter(Counter(s).values())) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620409,
                "title": "java",
                "content": "```\\npublic boolean areOccurrencesEqual(String s) {\\n\\tMap<Character, Integer> map = new HashMap<>();\\n\\n\\tfor (char c : s.toCharArray())\\n\\t\\tmap.put(c, map.containsKey(c) ? map.get(c) + 1 : 1);\\n\\n\\treturn (new HashSet<Integer>(map.values())).size() == 1;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean areOccurrencesEqual(String s) {\\n\\tMap<Character, Integer> map = new HashMap<>();\\n\\n\\tfor (char c : s.toCharArray())\\n\\t\\tmap.put(c, map.containsKey(c) ? map.get(c) + 1 : 1);\\n\\n\\treturn (new HashSet<Integer>(map.values())).size() == 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1609730,
                "title": "java-one-line-stream",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        return s.chars()\\n            .boxed()\\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n            .values()\\n            .stream()\\n            .collect(Collectors.toSet()).size() == 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        return s.chars()\\n            .boxed()\\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n            .values()\\n            .stream()\\n            .collect(Collectors.toSet()).size() == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499955,
                "title": "python-1-line-using-counter",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499632,
                "title": "c-using-unordered-map-with-explanation-0ms",
                "content": "![image](https://assets.leetcode.com/users/images/2d5af75b-9204-4eba-8525-19587b81236c_1633203890.5574083.png)\\n \\n first we create an unordered map m , and then we store the frequencies of each element in the map\\n then we compare all the frequencies with the frequency of the first letter , if any frequency does not match , we return false , else we return true\\n ```\\n class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\nunordered_map<int , int>m;\\nfor(auto i :s) m[i]++;\\nint x=m[s[0]];\\nfor(auto i:m)\\n{\\n    if(i.second!=x) return 0;\\n}\\n        return 1;\\n    }\\n};\\n```\\nfound it helpful? upvote it ;)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\nunordered_map<int , int>m;\\nfor(auto i :s) m[i]++;\\nint x=m[s[0]];\\nfor(auto i:m)\\n{\\n    if(i.second!=x) return 0;\\n}\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497054,
                "title": "kotlin-easy",
                "content": "Do upvote if it helps! :)\\n```\\nclass Solution {\\n    fun areOccurrencesEqual(s: String): Boolean {\\n        var num=s.count{it==s[0]}\\n        for (i in 1..s.length-1){\\n            if(num!=s.count{it==s[i]}) return false\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun areOccurrencesEqual(s: String): Boolean {\\n        var num=s.count{it==s[0]}\\n        for (i in 1..s.length-1){\\n            if(num!=s.count{it==s[i]}) return false\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489402,
                "title": "c-with-0ms-runtime-beats-100-00-of-cpp-submissions",
                "content": "creating array of size 27 for count of alphabets ,0-25 index for alphabets and 26th index  for if all alphabets occured and if any alphabet with zero count ,that makes the size of set always 2.upvote if you liked :)\\n```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        int a[27]={0},n=s.length();\\n        for(auto i:s)a[i-\\'a\\']++;\\n        return set<int>(a,a+27).size()==2;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        int a[27]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1486513,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int>arr(26,0);\\n        for(int i=0;i<s.size();i++)\\n            arr[s[i]-\\'a\\']++;\\n        \\n        int prev=0;\\n        \\n        for(int i=0;i<26;i++)\\n        {            \\n            if(arr[i]!=0)\\n            {\\n                prev=arr[i];\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<26;i++)\\n        {            \\n            if(arr[i]!=0 && arr[i]!=prev)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int>arr(26,0);\\n        for(int i=0;i<s.size();i++)\\n            arr[s[i]-\\'a\\']++;\\n        \\n        int prev=0;\\n        \\n        for(int i=0;i<26;i++)\\n        {            \\n            if(arr[i]!=0)\\n            {\\n                prev=arr[i];\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<26;i++)\\n        {            \\n            if(arr[i]!=0 && arr[i]!=prev)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471691,
                "title": "c-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(const string& s) {\\n        vector<int> v(26);\\n        for(auto i:s) ++v[i-\\'a\\'];\\n        int cnt=0;\\n        for(auto i:v)\\n            if(i) {\\n                if(cnt and cnt!=i) return false;\\n                else cnt=i;\\n            }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(const string& s) {\\n        vector<int> v(26);\\n        for(auto i:s) ++v[i-\\'a\\'];\\n        int cnt=0;\\n        for(auto i:v)\\n            if(i) {\\n                if(cnt and cnt!=i) return false;\\n                else cnt=i;\\n            }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471312,
                "title": "python3-collections",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        dictionary = Counter(s)\\n        return len(list(set(list(dictionary.values())))) == 1\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        dictionary = Counter(s)\\n        return len(list(set(list(dictionary.values())))) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451657,
                "title": "javascript-68ms-faster-than-99-41-solution-without-maps-or-object",
                "content": "![image](https://assets.leetcode.com/users/images/ed62ad85-1bf2-4510-8976-e91069586baa_1631084609.6315079.png)\\n```\\nvar areOccurrencesEqual = function(s) {\\n    const arr = s.split(\\'\\').sort(); //Sort string\\n    \\n    let index = 1; //index used to iterate through string, start from 1 as we compare with 0\\n    \\n    let initLen = 0; //used to store count of first char\\n    \\n    while(arr[index] === arr[0]) index++; //Find the count of first char\\n    initLen = index; //Store for length\\n    \\n    while(index < arr.length) {  //Iterate string\\n        //If each new char is not of same count as first or more in count return false\\n        if(arr[index] !== arr[index + initLen - 1] || arr[index] === arr[index + initLen]) {\\n            return false; \\n        } \\n        index = index + initLen;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar areOccurrencesEqual = function(s) {\\n    const arr = s.split(\\'\\').sort(); //Sort string\\n    \\n    let index = 1; //index used to iterate through string, start from 1 as we compare with 0\\n    \\n    let initLen = 0; //used to store count of first char\\n    \\n    while(arr[index] === arr[0]) index++; //Find the count of first char\\n    initLen = index; //Store for length\\n    \\n    while(index < arr.length) {  //Iterate string\\n        //If each new char is not of same count as first or more in count return false\\n        if(arr[index] !== arr[index + initLen - 1] || arr[index] === arr[index + initLen]) {\\n            return false; \\n        } \\n        index = index + initLen;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1450144,
                "title": "24-ms-faster-than-98-67-of-python3-online-submissions",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        \\n        c=Counter(s)\\n        a=c[s[0]]\\n        for i in c:\\n            if c[i]!=a:\\n                return False\\n        return True\\n    \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        \\n        c=Counter(s)\\n        a=c[s[0]]\\n        for i in c:\\n            if c[i]!=a:\\n                return False\\n        return True\\n    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1441974,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char, int> d;\\n        for (auto c: s){\\n            auto it = d.find(c);\\n            if (it != end(d))\\n                d[c]++;\\n            else\\n                d[c] = 1;     \\n        }\\n        auto it = begin(d);\\n        int value = it->second;\\n        for (; it != end(d); ++it)\\n            if (value != it->second)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        map<char, int> d;\\n        for (auto c: s){\\n            auto it = d.find(c);\\n            if (it != end(d))\\n                d[c]++;\\n            else\\n                d[c] = 1;     \\n        }\\n        auto it = begin(d);\\n        int value = it->second;\\n        for (; it != end(d); ++it)\\n            if (value != it->second)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424719,
                "title": "c-one-line-simple-linq-solution",
                "content": "```\\npublic class Solution {\\n    public bool AreOccurrencesEqual(string s) {\\n        return s.GroupBy(o => o).Select(o => o.Count()).Distinct().Count() == 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool AreOccurrencesEqual(string s) {\\n        return s.GroupBy(o => o).Select(o => o.Count()).Distinct().Count() == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412903,
                "title": "simplest-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s)\\n    {\\n        int helper[26] = {0};\\n        for(int i=0;i<s.size();i++)\\n        {\\n            helper[s[i]-97]++;\\n        }\\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(helper[s[i]-97] != helper[s[i+1]-97])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool areOccurrencesEqual(string s)\\n    {\\n        int helper[26] = {0};\\n        for(int i=0;i<s.size();i++)\\n        {\\n            helper[s[i]-97]++;\\n        }\\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(helper[s[i]-97] != helper[s[i+1]-97])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411182,
                "title": "python-java-solution-cool-easy",
                "content": "**python - one liner:**\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```\\n\\n**java - very cute solution:**\\n```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        final Map<String, Integer> counts = new HashMap<>();\\n        for(char c : s.toCharArray()) {\\n            counts.merge(String.valueOf(c), 1, Integer::sum);\\n        }\\n        Set<Integer> keySet = new HashSet<Integer>(counts.values());\\n        return keySet.size() == 1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(Counter(s).values())) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402168,
                "title": "c-0ms-100",
                "content": "```\\nbool areOccurrencesEqual(char * s){\\n    char c, letters[26] = {0};\\n    int i, j, found=0;\\n    \\n    while((c = *s++)) {\\n        letters[c - 97]++;\\n    }\\n    \\n    for(i=0; i<26; i++) {\\n        \\n        j = letters[i];\\n        \\n        if (!j) continue;\\n        \\n        if (!found) found = j;\\n        \\n        if (found != j) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool areOccurrencesEqual(char * s){\\n    char c, letters[26] = {0};\\n    int i, j, found=0;\\n    \\n    while((c = *s++)) {\\n        letters[c - 97]++;\\n    }\\n    \\n    for(i=0; i<26; i++) {\\n        \\n        j = letters[i];\\n        \\n        if (!j) continue;\\n        \\n        if (!found) found = j;\\n        \\n        if (found != j) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401067,
                "title": "easy-python-solution",
                "content": "\\'\\'\\'\\n\\n    def areOccurrencesEqual(self, s):\\n        out = dict()\\n        for i in s:\\n            if out.get(i):\\n                out[i] +=1\\n            else:\\n                out[i] = 1\\n            \\n        if len(set(out.values())) == 1:\\n            return True\\n        else:\\n            return False\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    def areOccurrencesEqual(self, s):\\n        out = dict()\\n        for i in s:\\n            if out.get(i):\\n                out[i] +=1\\n            else:\\n                out[i] = 1\\n            \\n        if len(set(out.values())) == 1:\\n            return True\\n        else:\\n            return False\\n\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1401059,
                "title": "go-lang-solution",
                "content": "```go\\nfunc areOccurrencesEqual(s string) bool {\\n    seen := map[rune]int{}\\n    \\n    for _, val := range s {\\n        seen[val]++\\n    }\\n    \\n    ref := seen[rune(s[0])]\\n\\n    for _, v := range seen {\\n        if v != ref {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc areOccurrencesEqual(s string) bool {\\n    seen := map[rune]int{}\\n    \\n    for _, val := range s {\\n        seen[val]++\\n    }\\n    \\n    ref := seen[rune(s[0])]\\n\\n    for _, v := range seen {\\n        if v != ref {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400471,
                "title": "python-map-and-set-1-liner",
                "content": "```class Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        \\n        return len(set(Counter(s).values())) == 1",
                "solutionTags": [],
                "code": "```class Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        \\n        return len(set(Counter(s).values())) == 1",
                "codeTag": "Java"
            },
            {
                "id": 1396041,
                "title": "java-solution-using-hashmap-and-hashset-8-lines-clean-code-7ms",
                "content": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n        HashMap<Character , Integer> map = new HashMap<Character , Integer>();\\n        for(int i = 0 ; i< s.length() ; i++){\\n            map.put(s.charAt(i) , map.getOrDefault(s.charAt(i) , 0)+ 1);\\n        }\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i< s.length() ; i++){\\n            set.add(map.get(s.charAt(i)));\\n        }\\n        \\n        if(set.size() == 1) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n        HashMap<Character , Integer> map = new HashMap<Character , Integer>();\\n        for(int i = 0 ; i< s.length() ; i++){\\n            map.put(s.charAt(i) , map.getOrDefault(s.charAt(i) , 0)+ 1);\\n        }\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i< s.length() ; i++){\\n            set.add(map.get(s.charAt(i)));\\n        }\\n        \\n        if(set.size() == 1) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392229,
                "title": "easy-solution-in-c",
                "content": "The concept that is used to solve this problem is hashing. First of all count the frequency of each character in the string and stored them in an array or unordered_map ( Here I use unordered_map ). Then find whether the frequency of each character is same or not. If not same then return false else return true. \\n\\n```\\nbool areOccurrencesEqual(string s) {\\n\\t\\tunordered_map<char,int> um;\\n        for(int i=0;i<s.length();i++) // using this for loop i store the frequency of each character in the unordered_map\\n            {\\n                um[s[i]]++;\\n            }\\n        for(int i=0;i<s.length()-1;i++) // This for loop is used to check whether the frequency of each character is same or not\\n            {\\n                if(um[s[i]]!=um[s[i+1]])\\n                    {\\n                        return false;\\n                    }\\n            }\\n        return true;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nbool areOccurrencesEqual(string s) {\\n\\t\\tunordered_map<char,int> um;\\n        for(int i=0;i<s.length();i++) // using this for loop i store the frequency of each character in the unordered_map\\n            {\\n                um[s[i]]++;\\n            }\\n        for(int i=0;i<s.length()-1;i++) // This for loop is used to check whether the frequency of each character is same or not\\n            {\\n                if(um[s[i]]!=um[s[i+1]])\\n                    {\\n                        return false;\\n                    }\\n            }\\n        return true;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389203,
                "title": "simple-python-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        if len(s)==1:\\n            return True\\n        dic={}\\n\\n        for i in s:\\n            if i not in dic:\\n                dic[i]=1\\n            else:\\n                dic[i]+=1\\n        firs= dic.get(s[1])\\n        for key,val in dic.items():\\n            if val!=firs:\\n                return False\\n\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        if len(s)==1:\\n            return True\\n        dic={}\\n\\n        for i in s:\\n            if i not in dic:\\n                dic[i]=1\\n            else:\\n                dic[i]+=1\\n        firs= dic.get(s[1])\\n        for key,val in dic.items():\\n            if val!=firs:\\n                return False\\n\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385796,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n\\t s.toLowerCase();\\n\\t        char c[]={\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'};\\n\\t        int a[]=new int[26];\\n\\t        for(int i=0;i<26;i++){\\n\\t            a[i]=0;\\n\\t        }\\n\\t        for(int i=0;i<s.length();i++){\\n\\t            for(int j=0;j<26;j++){\\n\\t            \\tchar k=s.charAt(i);\\n\\t                if(k==c[j]){\\n\\t                    a[j]++;\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        ArrayList<Integer>l=new ArrayList<Integer>();\\n\\t        for(int i=0;i<26;i++) {\\n\\t        \\tif(a[i]==0) {\\n\\t        \\t\\tcontinue;\\n\\t        \\t}\\n\\t        \\telse {\\n\\t        \\t\\tl.add(a[i]);\\n\\t        \\t}\\n\\t        }\\n\\t        int min=l.get(0);\\n\\t        int max=l.get(0);\\n\\t        for(int i=0;i<l.size();i++) {\\n\\t        \\tif(min>l.get(i)) {\\n\\t        \\t\\tmin=l.get(i);\\n\\t        \\t}\\n\\t        \\tif(l.get(i)>max) {\\n\\t        \\t\\tmax=l.get(i);\\n\\t        \\t}\\n            }\\n\\t        return min==max;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n\\t s.toLowerCase();\\n\\t        char c[]={\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'}",
                "codeTag": "Java"
            },
            {
                "id": 1383089,
                "title": "c-array-o-n-time-o-1-space-99-28-faster-99-28-less-memory-explained",
                "content": "![image](https://assets.leetcode.com/users/images/b6332c27-7f73-479d-a524-186bb73e0731_1628086692.6650836.png)\\n\\n```\\npublic class Solution {\\n    public bool AreOccurrencesEqual(string s) {\\n        // we only need 26 slots in our array, one for each lower case character\\n        var arr = new int[26];\\n        \\n        // each character goes to it\\'s own slot and add one to that slot\\n        foreach(var c in s){\\n            arr[c-\\'a\\']++;\\n        }\\n\\n        // set up a checker for comparison later\\n        var checker = arr[s[0]-\\'a\\'];\\n        \\n        foreach(var n in arr){\\n            //if any non zero int in the array is not equal to checker, return false immediately\\n            if (n != 0 && n != checker){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool AreOccurrencesEqual(string s) {\\n        // we only need 26 slots in our array, one for each lower case character\\n        var arr = new int[26];\\n        \\n        // each character goes to it\\'s own slot and add one to that slot\\n        foreach(var c in s){\\n            arr[c-\\'a\\']++;\\n        }\\n\\n        // set up a checker for comparison later\\n        var checker = arr[s[0]-\\'a\\'];\\n        \\n        foreach(var n in arr){\\n            //if any non zero int in the array is not equal to checker, return false immediately\\n            if (n != 0 && n != checker){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374867,
                "title": "python-one-liner-faster-than-99-71",
                "content": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(collections.Counter(s).values())) == 1\\n```\\n\\nWithout lib:\\n\\n```\\n\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        stemp = sorted(s)\\n        first = stemp[0]\\n        count = 0\\n        maxcount = 0\\n        for i in range(len(stemp)):\\n          if stemp[i] == first:\\n            count+=1\\n          else:\\n            break\\n            \\n        maxcount = count\\n        count = 0  \\n        \\n        for each in stemp:\\n          if each == first:    \\n            count+=1\\n          else:\\n            if count != maxcount:\\n              return False\\n            count = 1\\n            first = each\\n         \\n        return count == maxcount\\n\\t\\t\\n```\\n\\n```\\n\\n\\n            \\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return len(set(collections.Counter(s).values())) == 1\\n```\n```\\n\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        stemp = sorted(s)\\n        first = stemp[0]\\n        count = 0\\n        maxcount = 0\\n        for i in range(len(stemp)):\\n          if stemp[i] == first:\\n            count+=1\\n          else:\\n            break\\n            \\n        maxcount = count\\n        count = 0  \\n        \\n        for each in stemp:\\n          if each == first:    \\n            count+=1\\n          else:\\n            if count != maxcount:\\n              return False\\n            count = 1\\n            first = each\\n         \\n        return count == maxcount\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368486,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    \\n    bool areOccurrencesEqual(string s) {\\n        map<char,int>m;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        vector<int>ans;\\n        for(auto x:m)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        for(int i=0;i<ans.size()-1;i++)\\n        {\\n            if(ans[i]!=ans[i+1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool areOccurrencesEqual(string s) {\\n        map<char,int>m;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1367175,
                "title": "a-few-solutions",
                "content": "Use a map `m` to count occurrences of each character `c` of the input string `s`.  Return `true` if and only if the cardinality of the map\\'s values is equal to `1`, ie. this only occurs when all counts in the map are the same value.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun areOccurrencesEqual(s: String): Boolean {\\n        var m = mutableMapOf<Char, Int>()\\n        s.forEach { m[it] = 1 + m.getOrDefault(it, 0) }\\n        return 1 == m.values.toSet().size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet areOccurrencesEqual = (s, m = new Map()) => {\\n    for (let c of s)\\n        m.set(c, 1 + (m.get(c) || 0));\\n    return 1 == new Set(m.values()).size\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return 1 == len(set(Counter(s).values()))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    using Set = unordered_set<int>;\\n    bool areOccurrencesEqual(string s, Map m = {}, Set unique = {}) {\\n        for (auto c: s)\\n            ++m[c];\\n        for (auto [_, cnt]: m)\\n            unique.insert(cnt);\\n        return 1 == unique.size(); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun areOccurrencesEqual(s: String): Boolean {\\n        var m = mutableMapOf<Char, Int>()\\n        s.forEach { m[it] = 1 + m.getOrDefault(it, 0) }\\n        return 1 == m.values.toSet().size\\n    }\\n}\\n```\n```\\nlet areOccurrencesEqual = (s, m = new Map()) => {\\n    for (let c of s)\\n        m.set(c, 1 + (m.get(c) || 0));\\n    return 1 == new Set(m.values()).size\\n};\\n```\n```\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        return 1 == len(set(Counter(s).values()))\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    using Set = unordered_set<int>;\\n    bool areOccurrencesEqual(string s, Map m = {}, Set unique = {}) {\\n        for (auto c: s)\\n            ++m[c];\\n        for (auto [_, cnt]: m)\\n            unique.insert(cnt);\\n        return 1 == unique.size(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365574,
                "title": "rust-solution-with-array",
                "content": "```\\nimpl Solution {\\n    pub fn are_occurrences_equal(s: String) -> bool {\\n        let mut last_equal = 0;\\n        let arr_count = s.as_bytes().iter().fold([0; 26], |mut acc, b| {\\n            let ind = (*b - b\\'a\\') as usize;\\n            acc[ind] += 1;\\n            last_equal = acc[ind];\\n            acc\\n        });\\n        arr_count\\n            .iter()\\n            .filter(|x| **x > 0)\\n            .all(|x| *x == last_equal)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn are_occurrences_equal(s: String) -> bool {\\n        let mut last_equal = 0;\\n        let arr_count = s.as_bytes().iter().fold([0; 26], |mut acc, b| {\\n            let ind = (*b - b\\'a\\') as usize;\\n            acc[ind] += 1;\\n            last_equal = acc[ind];\\n            acc\\n        });\\n        arr_count\\n            .iter()\\n            .filter(|x| **x > 0)\\n            .all(|x| *x == last_equal)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1711630,
                "content": [
                    {
                        "username": "JavithSadhamHussain",
                        "content": "Combined statement of map.put() & map.getOrDefault()\nis very useful in many problems.\n```map.put(ch, map.getOrDefault(ch, 0)+1);```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Java 1 Line\\nreturn s.chars().distinct().mapToLong(c -> s.chars().filter(ch -> ch == c).count()).distinct().count() == 1;\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int z=mp[s[0]];\\n        for(auto x:mp){\\n            if(x.second!=z){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int>v;\\n      ;\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            for(int j=0;j<s.size();j++){\\n                if(s[i]==s[j]) count++;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        for(int i=1;i<v.size();i++){\\n            if(v[i-1]!=v[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Have used counter collection (Python 3)\\n\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        st = Counter(s)\\n        return len(list(set(list(st.values())))) == 1"
                    },
                    {
                        "username": "sayoojtssjayarajan",
                        "content": "class Solution {\\n   public static boolean areOccurrencesEqual(String s) {\\n\\t      Map<Character,Integer> map=new LinkedHashMap<>();\\n           for(int i=0;i<s.length();i++){\\n               map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n           }\\n        for(Map.Entry<Character,Integer>entry:map.entrySet()){\\n            if(entry.getValue()!=map.get(s.charAt(0))){\\n                return false;\\n            }\\n        }\\n          \\n         return true;\\n\\t           \\n\\t    }\\n\\t\\n\\n}\\n\\n\\n\\ni dont know whats the problem in this code .. its failing in the testcase 123.. anyone please help!!!!!!!!!"
                    },
                    {
                        "username": "Vish_11",
                        "content": "I have written a code for this but I am true for \\'aaabb\\' input but on my laptop its giving me false,\\ndont understand why is this the case?\\nCan anyone help?\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        str_set = list(set(s))\\n        #count=0\\n        list1 =[]\\n        i=0\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if(len(set(list1))==1):\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "try this \\nstr_set = list(set(s))\\n        list1 = []\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if len(set(list1)) == 1:\\n            return True\\n        else:\\n            return False"
                    }
                ]
            },
            {
                "id": 1848177,
                "content": [
                    {
                        "username": "JavithSadhamHussain",
                        "content": "Combined statement of map.put() & map.getOrDefault()\nis very useful in many problems.\n```map.put(ch, map.getOrDefault(ch, 0)+1);```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Java 1 Line\\nreturn s.chars().distinct().mapToLong(c -> s.chars().filter(ch -> ch == c).count()).distinct().count() == 1;\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int z=mp[s[0]];\\n        for(auto x:mp){\\n            if(x.second!=z){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int>v;\\n      ;\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            for(int j=0;j<s.size();j++){\\n                if(s[i]==s[j]) count++;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        for(int i=1;i<v.size();i++){\\n            if(v[i-1]!=v[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Have used counter collection (Python 3)\\n\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        st = Counter(s)\\n        return len(list(set(list(st.values())))) == 1"
                    },
                    {
                        "username": "sayoojtssjayarajan",
                        "content": "class Solution {\\n   public static boolean areOccurrencesEqual(String s) {\\n\\t      Map<Character,Integer> map=new LinkedHashMap<>();\\n           for(int i=0;i<s.length();i++){\\n               map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n           }\\n        for(Map.Entry<Character,Integer>entry:map.entrySet()){\\n            if(entry.getValue()!=map.get(s.charAt(0))){\\n                return false;\\n            }\\n        }\\n          \\n         return true;\\n\\t           \\n\\t    }\\n\\t\\n\\n}\\n\\n\\n\\ni dont know whats the problem in this code .. its failing in the testcase 123.. anyone please help!!!!!!!!!"
                    },
                    {
                        "username": "Vish_11",
                        "content": "I have written a code for this but I am true for \\'aaabb\\' input but on my laptop its giving me false,\\ndont understand why is this the case?\\nCan anyone help?\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        str_set = list(set(s))\\n        #count=0\\n        list1 =[]\\n        i=0\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if(len(set(list1))==1):\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "try this \\nstr_set = list(set(s))\\n        list1 = []\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if len(set(list1)) == 1:\\n            return True\\n        else:\\n            return False"
                    }
                ]
            },
            {
                "id": 1732803,
                "content": [
                    {
                        "username": "JavithSadhamHussain",
                        "content": "Combined statement of map.put() & map.getOrDefault()\nis very useful in many problems.\n```map.put(ch, map.getOrDefault(ch, 0)+1);```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Java 1 Line\\nreturn s.chars().distinct().mapToLong(c -> s.chars().filter(ch -> ch == c).count()).distinct().count() == 1;\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int z=mp[s[0]];\\n        for(auto x:mp){\\n            if(x.second!=z){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int>v;\\n      ;\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            for(int j=0;j<s.size();j++){\\n                if(s[i]==s[j]) count++;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        for(int i=1;i<v.size();i++){\\n            if(v[i-1]!=v[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Have used counter collection (Python 3)\\n\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        st = Counter(s)\\n        return len(list(set(list(st.values())))) == 1"
                    },
                    {
                        "username": "sayoojtssjayarajan",
                        "content": "class Solution {\\n   public static boolean areOccurrencesEqual(String s) {\\n\\t      Map<Character,Integer> map=new LinkedHashMap<>();\\n           for(int i=0;i<s.length();i++){\\n               map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n           }\\n        for(Map.Entry<Character,Integer>entry:map.entrySet()){\\n            if(entry.getValue()!=map.get(s.charAt(0))){\\n                return false;\\n            }\\n        }\\n          \\n         return true;\\n\\t           \\n\\t    }\\n\\t\\n\\n}\\n\\n\\n\\ni dont know whats the problem in this code .. its failing in the testcase 123.. anyone please help!!!!!!!!!"
                    },
                    {
                        "username": "Vish_11",
                        "content": "I have written a code for this but I am true for \\'aaabb\\' input but on my laptop its giving me false,\\ndont understand why is this the case?\\nCan anyone help?\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        str_set = list(set(s))\\n        #count=0\\n        list1 =[]\\n        i=0\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if(len(set(list1))==1):\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "try this \\nstr_set = list(set(s))\\n        list1 = []\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if len(set(list1)) == 1:\\n            return True\\n        else:\\n            return False"
                    }
                ]
            },
            {
                "id": 1840413,
                "content": [
                    {
                        "username": "JavithSadhamHussain",
                        "content": "Combined statement of map.put() & map.getOrDefault()\nis very useful in many problems.\n```map.put(ch, map.getOrDefault(ch, 0)+1);```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Java 1 Line\\nreturn s.chars().distinct().mapToLong(c -> s.chars().filter(ch -> ch == c).count()).distinct().count() == 1;\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int z=mp[s[0]];\\n        for(auto x:mp){\\n            if(x.second!=z){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int>v;\\n      ;\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            for(int j=0;j<s.size();j++){\\n                if(s[i]==s[j]) count++;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        for(int i=1;i<v.size();i++){\\n            if(v[i-1]!=v[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Have used counter collection (Python 3)\\n\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        st = Counter(s)\\n        return len(list(set(list(st.values())))) == 1"
                    },
                    {
                        "username": "sayoojtssjayarajan",
                        "content": "class Solution {\\n   public static boolean areOccurrencesEqual(String s) {\\n\\t      Map<Character,Integer> map=new LinkedHashMap<>();\\n           for(int i=0;i<s.length();i++){\\n               map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n           }\\n        for(Map.Entry<Character,Integer>entry:map.entrySet()){\\n            if(entry.getValue()!=map.get(s.charAt(0))){\\n                return false;\\n            }\\n        }\\n          \\n         return true;\\n\\t           \\n\\t    }\\n\\t\\n\\n}\\n\\n\\n\\ni dont know whats the problem in this code .. its failing in the testcase 123.. anyone please help!!!!!!!!!"
                    },
                    {
                        "username": "Vish_11",
                        "content": "I have written a code for this but I am true for \\'aaabb\\' input but on my laptop its giving me false,\\ndont understand why is this the case?\\nCan anyone help?\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        str_set = list(set(s))\\n        #count=0\\n        list1 =[]\\n        i=0\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if(len(set(list1))==1):\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "try this \\nstr_set = list(set(s))\\n        list1 = []\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if len(set(list1)) == 1:\\n            return True\\n        else:\\n            return False"
                    }
                ]
            },
            {
                "id": 1794802,
                "content": [
                    {
                        "username": "JavithSadhamHussain",
                        "content": "Combined statement of map.put() & map.getOrDefault()\nis very useful in many problems.\n```map.put(ch, map.getOrDefault(ch, 0)+1);```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Java 1 Line\\nreturn s.chars().distinct().mapToLong(c -> s.chars().filter(ch -> ch == c).count()).distinct().count() == 1;\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int z=mp[s[0]];\\n        for(auto x:mp){\\n            if(x.second!=z){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int>v;\\n      ;\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            for(int j=0;j<s.size();j++){\\n                if(s[i]==s[j]) count++;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        for(int i=1;i<v.size();i++){\\n            if(v[i-1]!=v[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Have used counter collection (Python 3)\\n\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        st = Counter(s)\\n        return len(list(set(list(st.values())))) == 1"
                    },
                    {
                        "username": "sayoojtssjayarajan",
                        "content": "class Solution {\\n   public static boolean areOccurrencesEqual(String s) {\\n\\t      Map<Character,Integer> map=new LinkedHashMap<>();\\n           for(int i=0;i<s.length();i++){\\n               map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n           }\\n        for(Map.Entry<Character,Integer>entry:map.entrySet()){\\n            if(entry.getValue()!=map.get(s.charAt(0))){\\n                return false;\\n            }\\n        }\\n          \\n         return true;\\n\\t           \\n\\t    }\\n\\t\\n\\n}\\n\\n\\n\\ni dont know whats the problem in this code .. its failing in the testcase 123.. anyone please help!!!!!!!!!"
                    },
                    {
                        "username": "Vish_11",
                        "content": "I have written a code for this but I am true for \\'aaabb\\' input but on my laptop its giving me false,\\ndont understand why is this the case?\\nCan anyone help?\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        str_set = list(set(s))\\n        #count=0\\n        list1 =[]\\n        i=0\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if(len(set(list1))==1):\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "try this \\nstr_set = list(set(s))\\n        list1 = []\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if len(set(list1)) == 1:\\n            return True\\n        else:\\n            return False"
                    }
                ]
            },
            {
                "id": 1743460,
                "content": [
                    {
                        "username": "JavithSadhamHussain",
                        "content": "Combined statement of map.put() & map.getOrDefault()\nis very useful in many problems.\n```map.put(ch, map.getOrDefault(ch, 0)+1);```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Java 1 Line\\nreturn s.chars().distinct().mapToLong(c -> s.chars().filter(ch -> ch == c).count()).distinct().count() == 1;\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int z=mp[s[0]];\\n        for(auto x:mp){\\n            if(x.second!=z){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int>v;\\n      ;\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            for(int j=0;j<s.size();j++){\\n                if(s[i]==s[j]) count++;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        for(int i=1;i<v.size();i++){\\n            if(v[i-1]!=v[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Have used counter collection (Python 3)\\n\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        st = Counter(s)\\n        return len(list(set(list(st.values())))) == 1"
                    },
                    {
                        "username": "sayoojtssjayarajan",
                        "content": "class Solution {\\n   public static boolean areOccurrencesEqual(String s) {\\n\\t      Map<Character,Integer> map=new LinkedHashMap<>();\\n           for(int i=0;i<s.length();i++){\\n               map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n           }\\n        for(Map.Entry<Character,Integer>entry:map.entrySet()){\\n            if(entry.getValue()!=map.get(s.charAt(0))){\\n                return false;\\n            }\\n        }\\n          \\n         return true;\\n\\t           \\n\\t    }\\n\\t\\n\\n}\\n\\n\\n\\ni dont know whats the problem in this code .. its failing in the testcase 123.. anyone please help!!!!!!!!!"
                    },
                    {
                        "username": "Vish_11",
                        "content": "I have written a code for this but I am true for \\'aaabb\\' input but on my laptop its giving me false,\\ndont understand why is this the case?\\nCan anyone help?\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        str_set = list(set(s))\\n        #count=0\\n        list1 =[]\\n        i=0\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if(len(set(list1))==1):\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "try this \\nstr_set = list(set(s))\\n        list1 = []\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if len(set(list1)) == 1:\\n            return True\\n        else:\\n            return False"
                    }
                ]
            },
            {
                "id": 1736011,
                "content": [
                    {
                        "username": "JavithSadhamHussain",
                        "content": "Combined statement of map.put() & map.getOrDefault()\nis very useful in many problems.\n```map.put(ch, map.getOrDefault(ch, 0)+1);```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "Java 1 Line\\nreturn s.chars().distinct().mapToLong(c -> s.chars().filter(ch -> ch == c).count()).distinct().count() == 1;\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int z=mp[s[0]];\\n        for(auto x:mp){\\n            if(x.second!=z){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    bool areOccurrencesEqual(string s) {\\n        vector<int>v;\\n      ;\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            for(int j=0;j<s.size();j++){\\n                if(s[i]==s[j]) count++;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        for(int i=1;i<v.size();i++){\\n            if(v[i-1]!=v[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Have used counter collection (Python 3)\\n\\nfrom collections import Counter\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        st = Counter(s)\\n        return len(list(set(list(st.values())))) == 1"
                    },
                    {
                        "username": "sayoojtssjayarajan",
                        "content": "class Solution {\\n   public static boolean areOccurrencesEqual(String s) {\\n\\t      Map<Character,Integer> map=new LinkedHashMap<>();\\n           for(int i=0;i<s.length();i++){\\n               map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n           }\\n        for(Map.Entry<Character,Integer>entry:map.entrySet()){\\n            if(entry.getValue()!=map.get(s.charAt(0))){\\n                return false;\\n            }\\n        }\\n          \\n         return true;\\n\\t           \\n\\t    }\\n\\t\\n\\n}\\n\\n\\n\\ni dont know whats the problem in this code .. its failing in the testcase 123.. anyone please help!!!!!!!!!"
                    },
                    {
                        "username": "Vish_11",
                        "content": "I have written a code for this but I am true for \\'aaabb\\' input but on my laptop its giving me false,\\ndont understand why is this the case?\\nCan anyone help?\\nclass Solution:\\n    def areOccurrencesEqual(self, s: str) -> bool:\\n        str_set = list(set(s))\\n        #count=0\\n        list1 =[]\\n        i=0\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if(len(set(list1))==1):\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "try this \\nstr_set = list(set(s))\\n        list1 = []\\n        for i in range(len(str_set)):\\n            count = s.count(str_set[i])\\n            list1.append(count)\\n        if len(set(list1)) == 1:\\n            return True\\n        else:\\n            return False"
                    }
                ]
            }
        ]
    },
    {
        "title": "The Number of the Smallest Unoccupied Chair",
        "question_content": "<p>There is a party where <code>n</code> friends numbered from <code>0</code> to <code>n - 1</code> are attending. There is an <strong>infinite</strong> number of chairs in this party that are numbered from <code>0</code> to <code>infinity</code>. When a friend arrives at the party, they sit on the unoccupied chair with the <strong>smallest number</strong>.</p>\n\n<ul>\n\t<li>For example, if chairs <code>0</code>, <code>1</code>, and <code>5</code> are occupied when a friend comes, they will sit on chair number <code>2</code>.</li>\n</ul>\n\n<p>When a friend leaves the party, their chair becomes unoccupied at the moment they leave. If another friend arrives at that same moment, they can sit in that chair.</p>\n\n<p>You are given a <strong>0-indexed</strong> 2D integer array <code>times</code> where <code>times[i] = [arrival<sub>i</sub>, leaving<sub>i</sub>]</code>, indicating the arrival and leaving times of the <code>i<sup>th</sup></code> friend respectively, and an integer <code>targetFriend</code>. All arrival times are <strong>distinct</strong>.</p>\n\n<p>Return<em> the <strong>chair number</strong> that the friend numbered </em><code>targetFriend</code><em> will sit on</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> times = [[1,4],[2,3],[4,6]], targetFriend = 1\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> \n- Friend 0 arrives at time 1 and sits on chair 0.\n- Friend 1 arrives at time 2 and sits on chair 1.\n- Friend 1 leaves at time 3 and chair 1 becomes empty.\n- Friend 0 leaves at time 4 and chair 0 becomes empty.\n- Friend 2 arrives at time 4 and sits on chair 0.\nSince friend 1 sat on chair 1, we return 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> times = [[3,10],[1,5],[2,6]], targetFriend = 0\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> \n- Friend 1 arrives at time 1 and sits on chair 0.\n- Friend 2 arrives at time 2 and sits on chair 1.\n- Friend 0 arrives at time 3 and sits on chair 2.\n- Friend 1 leaves at time 5 and chair 0 becomes empty.\n- Friend 2 leaves at time 6 and chair 1 becomes empty.\n- Friend 0 leaves at time 10 and chair 2 becomes empty.\nSince friend 0 sat on chair 2, we return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == times.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>times[i].length == 2</code></li>\n\t<li><code>1 &lt;= arrival<sub>i</sub> &lt; leaving<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= targetFriend &lt;= n - 1</code></li>\n\t<li>Each <code>arrival<sub>i</sub></code> time is <strong>distinct</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1359790,
                "title": "c-set-priority-queue-commented",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& a, int t){\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\\n        int f = a[t][0];                              //target friend arrival time\\n        sort(a.begin(), a.end());\\n        int n=0;                                      //starting seat\\n        set<int> s;\\n        for(auto v: a){\\n            int at = v[0];                            //arrival time\\n            int lt = v[1];                            //leaving time\\n            int cs;                                   //current seat\\n            while(!q.empty() && q.top().first<=at){       //it top of priority queue is less than or equal to arrival time push seat number in set..\\n                s.insert(q.top().second);\\n                q.pop();\\n            }\\n\\t\\t\\t//if set size is not 0 then current seat will be s.begin() else current seat will be n\\n            if(s.size()!=0){         \\n                cs=*(s.begin());\\n                s.erase(s.begin());\\n            }\\n            else{\\n                cs=n;\\n                n++;\\n            }\\n            q.push({lt, cs});       //push leaving time and seat number in queue\\n            if(f==at){               //if arrival time of current friend is equal to arrival time of target friend return current seat number  (it is given all arrival time are distinct)\\n                return cs;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```\\n\\n*If you like the solution, please Upvote \\uD83D\\uDC4D!!*",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& a, int t){\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\\n        int f = a[t][0];                              //target friend arrival time\\n        sort(a.begin(), a.end());\\n        int n=0;                                      //starting seat\\n        set<int> s;\\n        for(auto v: a){\\n            int at = v[0];                            //arrival time\\n            int lt = v[1];                            //leaving time\\n            int cs;                                   //current seat\\n            while(!q.empty() && q.top().first<=at){       //it top of priority queue is less than or equal to arrival time push seat number in set..\\n                s.insert(q.top().second);\\n                q.pop();\\n            }\\n\\t\\t\\t//if set size is not 0 then current seat will be s.begin() else current seat will be n\\n            if(s.size()!=0){         \\n                cs=*(s.begin());\\n                s.erase(s.begin());\\n            }\\n            else{\\n                cs=n;\\n                n++;\\n            }\\n            q.push({lt, cs});       //push leaving time and seat number in queue\\n            if(f==at){               //if arrival time of current friend is equal to arrival time of target friend return current seat number  (it is given all arrival time are distinct)\\n                return cs;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359732,
                "title": "multimap-vs-priority-queue",
                "content": "Somehow this problem felt the hardest for me during the contest.\\n\\n1. We first sort times by arrival (remembering the arrival time of our target).\\n2. We track assigned seats with guest departure times in `reserved` multimap (or min heap).\\n2. Before the next guest arrives, we collect all chairs from guests who have left into an `avail` set (or min heap).\\n3. As we seat each guest, we check if we have any seats in `avail`. \\n\\t- If yes, we give the smallest available seat to the guest (first in the set, or top of the min heap).\\n\\t- Otherwise, all chairs are occupied and we add a new chair.\\n\\n#### Multimap and Set\\n**C++**\\n```cpp\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n    int t_arrival = times[targetFriend][0];\\n    sort(begin(times), end(times));\\n    multimap<int, int> reserved;\\n    set<int> avail;\\n    for (auto &t : times) {\\n        while (!reserved.empty() && begin(reserved)->first <= t[0]) {\\n            avail.insert(begin(reserved)->second);\\n            reserved.erase(begin(reserved));\\n        }\\n        if (t[0] == t_arrival)\\n            break;\\n        if (avail.empty())\\n            reserved.insert({t[1], reserved.size()});\\n        else {\\n            reserved.insert({t[1], *begin(avail)});\\n            avail.erase(begin(avail));\\n        }\\n    }\\n    return avail.empty() ? reserved.size() : (*begin(avail));\\n}\\n```\\n#### Two Priority Queue\\n**C++**\\n```cpp\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n    int t_arrival = times[targetFriend][0];\\n    sort(begin(times), end(times));\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> reserved;\\n    priority_queue<int, vector<int>, greater<int>> avail;    \\n    for (auto &t : times) {\\n        while (!reserved.empty() && reserved.top().first <= t[0]) {\\n            avail.push(reserved.top().second);\\n            reserved.pop();\\n        }\\n        if (t[0] == t_arrival)\\n            break;\\n        if (avail.empty())\\n            reserved.push({t[1], reserved.size()});\\n        else {\\n            reserved.push({t[1], avail.top()});\\n            avail.pop();\\n        }\\n    }\\n    return avail.empty() ? reserved.size() : avail.top();\\n}\\n```\\n#### Single Priority Queue\\nIt\\'s not much different from two priority queues, but harder to understand and potentially inefficient. So consider it as for entertainment purposes only.\\n\\nHere, for all guests who left before `t[0]`, and re-inserting their chair into the min heap but with the same departure time: `t[0]`. This way, when a new guest arrives at `t[0]`, the chair at the top of the heap will have the smallest number.\\n\\nThis approach will be quite inefficient when guests stay just for one day and arrive one after another.\\n\\n**C++**\\n```cpp\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n    int t_arrival = times[targetFriend][0];\\n    sort(begin(times), end(times));\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    for (auto &t : times) {\\n        while (!pq.empty() && pq.top().first < t[0]) {\\n            pq.push({t[0], pq.top().second});\\n            pq.pop();\\n        }\\n        if (t[0] == t_arrival)\\n            break;         \\n        if (pq.empty() || pq.top().first > t[0])\\n            pq.push({t[1], pq.size()});\\n        else {\\n            pq.push({t[1], pq.top().second});\\n            pq.pop();\\n        }\\n    }\\n    return !pq.empty() && pq.top().first <= t_arrival ? pq.top().second : pq.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n    int t_arrival = times[targetFriend][0];\\n    sort(begin(times), end(times));\\n    multimap<int, int> reserved;\\n    set<int> avail;\\n    for (auto &t : times) {\\n        while (!reserved.empty() && begin(reserved)->first <= t[0]) {\\n            avail.insert(begin(reserved)->second);\\n            reserved.erase(begin(reserved));\\n        }\\n        if (t[0] == t_arrival)\\n            break;\\n        if (avail.empty())\\n            reserved.insert({t[1], reserved.size()});\\n        else {\\n            reserved.insert({t[1], *begin(avail)});\\n            avail.erase(begin(avail));\\n        }\\n    }\\n    return avail.empty() ? reserved.size() : (*begin(avail));\\n}\\n```\n```cpp\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n    int t_arrival = times[targetFriend][0];\\n    sort(begin(times), end(times));\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> reserved;\\n    priority_queue<int, vector<int>, greater<int>> avail;    \\n    for (auto &t : times) {\\n        while (!reserved.empty() && reserved.top().first <= t[0]) {\\n            avail.push(reserved.top().second);\\n            reserved.pop();\\n        }\\n        if (t[0] == t_arrival)\\n            break;\\n        if (avail.empty())\\n            reserved.push({t[1], reserved.size()});\\n        else {\\n            reserved.push({t[1], avail.top()});\\n            avail.pop();\\n        }\\n    }\\n    return avail.empty() ? reserved.size() : avail.top();\\n}\\n```\n```cpp\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n    int t_arrival = times[targetFriend][0];\\n    sort(begin(times), end(times));\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    for (auto &t : times) {\\n        while (!pq.empty() && pq.top().first < t[0]) {\\n            pq.push({t[0], pq.top().second});\\n            pq.pop();\\n        }\\n        if (t[0] == t_arrival)\\n            break;         \\n        if (pq.empty() || pq.top().first > t[0])\\n            pq.push({t[1], pq.size()});\\n        else {\\n            pq.push({t[1], pq.top().second});\\n            pq.pop();\\n        }\\n    }\\n    return !pq.empty() && pq.top().first <= t_arrival ? pq.top().second : pq.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359784,
                "title": "detailed-explanation-c-easy-to-understand-two-min-heaps",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        \\n        int n = times.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > busy; //departure time as first , index as second\\n        priority_queue<int, vector<int>, greater<int>> free; //min heap of chair index that are unoccupied\\n        \\n\\t\\t//store friend indexes so that they don\\'t get lost after sorting\\n        for(int i=0;i<n;++i){\\n            times[i].push_back(i);\\n        }\\n\\t\\t//Sort according to arrival time\\n        sort(times.begin(),times.end());\\n        \\n\\t\\tint new_chair = 0; //chairs alloted till now \\n        for(int i=0;i<n;++i){\\n            int arrival = times[i][0]; //pop chairs before arrival \\n            int leave_time = times[i][1];\\n            int fr = times[i][2]; //friend index\\n            //free chairs accordingly\\n            while(!busy.empty() && busy.top().first <= arrival){\\n                // cout << \"Chair free \" << busy.top().second << endl;\\n                free.push(busy.top().second);\\n                busy.pop();\\n            }   \\n            //No free chair allot new chair\\n            if(free.empty()){\\n                // cout << \"Alloting new_chair \" << new_chair << \"to\" << fr << endl;\\n                if(fr  == targetFriend) return new_chair;\\n                busy.push({leave_time,new_chair});\\n                new_chair++;\\n            }\\n            else{\\n                int x = free.top();\\n                // cout << \"giving chair \" << x << \"to\" << fr << endl;\\n                free.pop();\\n                if( fr  == targetFriend) return x; \\n                busy.push({leave_time,x});\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```\\n\\nA Quick Note:- Since the arrival times are distinct, we can save only the arrival of targetFriend and return the chair when arrival time while iteration becomes equal to the required one. This would save O(n) space which is used in the given code for storing indices.\\n\\nA similar question you can try:- [Process Tasks Using Servers](https://leetcode.com/problems/process-tasks-using-servers/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        \\n        int n = times.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > busy; //departure time as first , index as second\\n        priority_queue<int, vector<int>, greater<int>> free; //min heap of chair index that are unoccupied\\n        \\n\\t\\t//store friend indexes so that they don\\'t get lost after sorting\\n        for(int i=0;i<n;++i){\\n            times[i].push_back(i);\\n        }\\n\\t\\t//Sort according to arrival time\\n        sort(times.begin(),times.end());\\n        \\n\\t\\tint new_chair = 0; //chairs alloted till now \\n        for(int i=0;i<n;++i){\\n            int arrival = times[i][0]; //pop chairs before arrival \\n            int leave_time = times[i][1];\\n            int fr = times[i][2]; //friend index\\n            //free chairs accordingly\\n            while(!busy.empty() && busy.top().first <= arrival){\\n                // cout << \"Chair free \" << busy.top().second << endl;\\n                free.push(busy.top().second);\\n                busy.pop();\\n            }   \\n            //No free chair allot new chair\\n            if(free.empty()){\\n                // cout << \"Alloting new_chair \" << new_chair << \"to\" << fr << endl;\\n                if(fr  == targetFriend) return new_chair;\\n                busy.push({leave_time,new_chair});\\n                new_chair++;\\n            }\\n            else{\\n                int x = free.top();\\n                // cout << \"giving chair \" << x << \"to\" << fr << endl;\\n                free.pop();\\n                if( fr  == targetFriend) return x; \\n                busy.push({leave_time,x});\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1359844,
                "title": "two-min-heaps-with-explanation",
                "content": "**Approach:**\\n* Store the arrivalTime of targetFriend, since all the the arrival times are distinct this can be used to identify the targetFriend in sorted array.\\n* Store all the available seats(one for each friend) in minHeap as available.\\n* Sort the times array based on arrival time.\\n* Maintain another minHeap to store leavingTime and occupiedSeat.\\n* loop through sorted array\\n\\t* \\tremove all the friends from the heap whose leavingTime is less than or equal to current arraival time and add the occupied seats back to available heap.\\n\\t* \\tif the current start is equal to targetStart return the min available seat.\\n\\t* \\telse add the current leaving time and min available seat to heap.\\n```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int targetStart = times[targetFriend][0];\\n        Arrays.sort(times, (a, b) -> a[0] - b[0]);\\n        \\n        PriorityQueue<Integer> available = new PriorityQueue<>();\\n        for (int i = 0; i < times.length; ++ i) {\\n            available.offer(i);\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        \\n        for (int i = 0; i < times.length; ++ i) {\\n            while (!pq.isEmpty() && pq.peek()[0] <= times[i][0]) {\\n                available.offer(pq.poll()[1]);\\n            }\\n            \\n            if (times[i][0] == targetStart) {\\n                break;\\n            }\\n            \\n            pq.offer(new int[]{times[i][1], available.poll()});\\n        }\\n        \\n        return available.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int targetStart = times[targetFriend][0];\\n        Arrays.sort(times, (a, b) -> a[0] - b[0]);\\n        \\n        PriorityQueue<Integer> available = new PriorityQueue<>();\\n        for (int i = 0; i < times.length; ++ i) {\\n            available.offer(i);\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        \\n        for (int i = 0; i < times.length; ++ i) {\\n            while (!pq.isEmpty() && pq.peek()[0] <= times[i][0]) {\\n                available.offer(pq.poll()[1]);\\n            }\\n            \\n            if (times[i][0] == targetStart) {\\n                break;\\n            }\\n            \\n            pq.offer(new int[]{times[i][1], available.poll()});\\n        }\\n        \\n        return available.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359722,
                "title": "python3-sweeping",
                "content": "\\n```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        vals = []\\n        for i, (arrival, leaving) in enumerate(times): \\n            vals.append((arrival, 1, i))\\n            vals.append((leaving, 0, i))\\n        \\n        k = 0 \\n        pq = [] # available seats \\n        mp = {} # player-to-seat mapping \\n        for _, arrival, i in sorted(vals): \\n            if arrival: \\n                if pq: s = heappop(pq)\\n                else: \\n                    s = k\\n                    k += 1\\n                if i == targetFriend: return s\\n                mp[i] = s\\n            else: heappush(pq, mp[i]) # new seat available\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        vals = []\\n        for i, (arrival, leaving) in enumerate(times): \\n            vals.append((arrival, 1, i))\\n            vals.append((leaving, 0, i))\\n        \\n        k = 0 \\n        pq = [] # available seats \\n        mp = {} # player-to-seat mapping \\n        for _, arrival, i in sorted(vals): \\n            if arrival: \\n                if pq: s = heappop(pq)\\n                else: \\n                    s = k\\n                    k += 1\\n                if i == targetFriend: return s\\n                mp[i] = s\\n            else: heappush(pq, mp[i]) # new seat available\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359713,
                "title": "python-simple-heap-solution-with-explanation",
                "content": "**Explanation:**\\n* Put all arrivals in one heap and all departures in another heap - this helps us to go by the chronogical order of time\\n* If smallest time in arrivals heap is less than smallest time in departures heap, then pop from arrivals heap and occupy the 1st available table with the popped element. \\n* If popped index/friend is the target friend, then return the occupied index\\n* Else if smallest time in departures heap is less than or equal to smallest time in arrivals heap, then pop from departures heap and vacate the table occupied by the popped element\\n\\n```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        arrivals = []\\n        departures = []\\n        for ind, (x, y) in enumerate(times):\\n            heappush(arrivals, (x, ind))\\n            heappush(departures, (y, ind))\\n        d = {}\\n        occupied = [0] * len(times)\\n        while True:\\n            if arrivals and departures and arrivals[0][0] < departures[0][0]:\\n                _, ind = heappop(arrivals)\\n                d[ind] = occupied.index(0)\\n                occupied[d[ind]] = 1\\n                if ind == targetFriend:\\n                    return d[ind]\\n            elif arrivals and departures and arrivals[0][0] >= departures[0][0]:\\n                _, ind = heappop(departures)\\n                occupied[d[ind]] = 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        arrivals = []\\n        departures = []\\n        for ind, (x, y) in enumerate(times):\\n            heappush(arrivals, (x, ind))\\n            heappush(departures, (y, ind))\\n        d = {}\\n        occupied = [0] * len(times)\\n        while True:\\n            if arrivals and departures and arrivals[0][0] < departures[0][0]:\\n                _, ind = heappop(arrivals)\\n                d[ind] = occupied.index(0)\\n                occupied[d[ind]] = 1\\n                if ind == targetFriend:\\n                    return d[ind]\\n            elif arrivals and departures and arrivals[0][0] >= departures[0][0]:\\n                _, ind = heappop(departures)\\n                occupied[d[ind]] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361563,
                "title": "c-2-approaches-go-from-naive-to-optimal-approach",
                "content": "```\\n//Approach-1 (Naive O(n^2) approach that comes to mind first)\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        \\n        vector<int> endTimes(n, -1); //at max we will have 0 to n-1 chairs\\n        \\n        /*\\n            We need to sort the times based on arrival time but we don\\'t want to\\n            loose the friend number after sorting. So, store the arrival time\\n            of targetFriend because it\\'s given in the question that \\n            Each arrival time is distinct.\\n        */\\n        \\n        int targetArrivalTime = times[targetFriend][0];\\n        \\n        sort(begin(times), end(times));\\n        \\n        for(vector<int> &time : times) {\\n            int arrival = time[0];\\n            int depart  = time[1];\\n            //Find the first unoccupied chair\\n            for(int i = 0; i<n; i++) {\\n                if(endTimes[i] <= arrival) {\\n                    endTimes[i] = depart; //update with current friend depart time\\n                    \\n                    if(arrival == targetArrivalTime)\\n                        return i;\\n                    break;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n//Approach - 2 (min heap + set)\\n/*\\n    priority_queue(min heap) - To get the friend with minimum departure time\\n\\tordered_set              - To get the least available chair\\n*/\\n\\nclass Solution {\\npublic:\\n    typedef pair<int, int> p;\\n    priority_queue<p, vector<p>, greater<p>> pq;\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        \\n        int targetArrivalTime = times[targetFriend][0];\\n        \\n        sort(begin(times), end(times));\\n        \\n        set<int> chairNum; //ordered set (we will get the least available chair number in the beginning) (You could also use min heap for this also)\\n        \\n        int lastChair = 0;\\n        \\n        for(vector<int> &time : times) {\\n            int arrival  = time[0];\\n            int depart   = time[1];\\n            int currSeat = -1;\\n \\n            while(!pq.empty() && pq.top().first <= arrival) {\\n                chairNum.insert(pq.top().second); //insert the chairs which are being emptied\\n                pq.pop();\\n            }\\n\\n            if(chairNum.empty()) {\\n                currSeat = lastChair;\\n                lastChair++;\\n            } else {\\n                currSeat = *(chairNum.begin());  //ordered set (we will get the least available chair number in the beginning)\\n                chairNum.erase(currSeat); //this chair is now occupied\\n            }\\n            pq.push({depart, currSeat});\\n            if(arrival == targetArrivalTime)\\n                return currSeat;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Naive O(n^2) approach that comes to mind first)\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        \\n        vector<int> endTimes(n, -1); //at max we will have 0 to n-1 chairs\\n        \\n        /*\\n            We need to sort the times based on arrival time but we don\\'t want to\\n            loose the friend number after sorting. So, store the arrival time\\n            of targetFriend because it\\'s given in the question that \\n            Each arrival time is distinct.\\n        */\\n        \\n        int targetArrivalTime = times[targetFriend][0];\\n        \\n        sort(begin(times), end(times));\\n        \\n        for(vector<int> &time : times) {\\n            int arrival = time[0];\\n            int depart  = time[1];\\n            //Find the first unoccupied chair\\n            for(int i = 0; i<n; i++) {\\n                if(endTimes[i] <= arrival) {\\n                    endTimes[i] = depart; //update with current friend depart time\\n                    \\n                    if(arrival == targetArrivalTime)\\n                        return i;\\n                    break;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n//Approach - 2 (min heap + set)\\n/*\\n    priority_queue(min heap) - To get the friend with minimum departure time\\n\\tordered_set              - To get the least available chair\\n*/\\n\\nclass Solution {\\npublic:\\n    typedef pair<int, int> p;\\n    priority_queue<p, vector<p>, greater<p>> pq;\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        \\n        int targetArrivalTime = times[targetFriend][0];\\n        \\n        sort(begin(times), end(times));\\n        \\n        set<int> chairNum; //ordered set (we will get the least available chair number in the beginning) (You could also use min heap for this also)\\n        \\n        int lastChair = 0;\\n        \\n        for(vector<int> &time : times) {\\n            int arrival  = time[0];\\n            int depart   = time[1];\\n            int currSeat = -1;\\n \\n            while(!pq.empty() && pq.top().first <= arrival) {\\n                chairNum.insert(pq.top().second); //insert the chairs which are being emptied\\n                pq.pop();\\n            }\\n\\n            if(chairNum.empty()) {\\n                currSeat = lastChair;\\n                lastChair++;\\n            } else {\\n                currSeat = *(chairNum.begin());  //ordered set (we will get the least available chair number in the beginning)\\n                chairNum.erase(currSeat); //this chair is now occupied\\n            }\\n            pq.push({depart, currSeat});\\n            if(arrival == targetArrivalTime)\\n                return currSeat;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359714,
                "title": "simple-intuitive-solution-in-c-o-n-2-with-explanation",
                "content": "**You just need to keep track of empty chairs, at arriving time of every friend**\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int tf) {        \\n        vector<int> t = times[tf]; // Store the target friend because after sorting indexes will shuffle\\n        sort(times.begin(), times.end()); // sort the elements\\n        //Intuition behind sorting is that we book first chairs for people coming first in on time.         \\n        int n = times.size();\\n        vector<int> emptyChair(n); // this array will keep track of time when particular chair will get empty \\n        //i.e. indexes of this array represents chair number and values represents leaving time \\n        //and there can only be n(number of friends attending) chairs in use at a time.\\n        \\n        for ( vector <int> x : times ){ // now iterate over given time intervals\\n                for (int i = 0 ; i< n ;i++  ){ // iterating over all the chairs \\n                    if (emptyChair[i] <= x[0] ){\\n                        //if current time greater than leaving time of person sitting on the chair \\n                        //then this chair must be empty now \\n                        emptyChair[i] =  x[1]; // so now we will keep track of when current person will leave this chair\\n                        if (x == t ) return i; // if we have reached at target friend then simply return his chair number.\\n                        else break; //else we got chair number for current person no point in checking next.\\n                    }\\n                }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int tf) {        \\n        vector<int> t = times[tf]; // Store the target friend because after sorting indexes will shuffle\\n        sort(times.begin(), times.end()); // sort the elements\\n        //Intuition behind sorting is that we book first chairs for people coming first in on time.         \\n        int n = times.size();\\n        vector<int> emptyChair(n); // this array will keep track of time when particular chair will get empty \\n        //i.e. indexes of this array represents chair number and values represents leaving time \\n        //and there can only be n(number of friends attending) chairs in use at a time.\\n        \\n        for ( vector <int> x : times ){ // now iterate over given time intervals\\n                for (int i = 0 ; i< n ;i++  ){ // iterating over all the chairs \\n                    if (emptyChair[i] <= x[0] ){\\n                        //if current time greater than leaving time of person sitting on the chair \\n                        //then this chair must be empty now \\n                        emptyChair[i] =  x[1]; // so now we will keep track of when current person will leave this chair\\n                        if (x == t ) return i; // if we have reached at target friend then simply return his chair number.\\n                        else break; //else we got chair number for current person no point in checking next.\\n                    }\\n                }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359894,
                "title": "c-using-two-heaps",
                "content": "**Explanation:**\\n\\n\\t1. Sort in ascending order of arrival time.\\n\\t2. Maintain chair numbers from 0 to (n-1) in min-heap => (pq_chair)\\n\\t3. Maintain departure time in another min-heap => (pq_leaving)\\n\\t4. For every arriving friend, push corresponding departure time along with chair number in pq_leaving;\\n\\t5. Also remove all friends with departure time less than current friend arriving time\\n\\nSimilar Logic (like step 4th and 5th) : \\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/\\n\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int target = times[targetFriend][0];\\n        \\n        sort(times.begin(),times.end());\\n        int n = times.size();\\n        \\n        //minpq for available chair numbers\\n        priority_queue<int,vector<int>, greater<int> > pq_chair;\\n        \\n        for(int i = 0; i < n; i++)\\n            pq_chair.push(i);\\n        \\n        //minpq for departure time\\n        priority_queue<pair<int,int> ,vector<pair<int,int>>, greater<pair<int,int>> > pq_leaving;\\n        \\n        for(auto v : times){\\n            int arrival = v[0], dep = v[1];\\n            while(!pq_leaving.empty() && pq_leaving.top().first <= arrival){\\n                pair<int,int> p = pq_leaving.top();\\n                pq_leaving.pop();\\n                pq_chair.push(p.second);\\n            }\\n            int chair = pq_chair.top();\\n            pq_chair.pop();\\n            pq_leaving.push({dep,chair});\\n            if(arrival == target)\\n                return chair;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int target = times[targetFriend][0];\\n        \\n        sort(times.begin(),times.end());\\n        int n = times.size();\\n        \\n        //minpq for available chair numbers\\n        priority_queue<int,vector<int>, greater<int> > pq_chair;\\n        \\n        for(int i = 0; i < n; i++)\\n            pq_chair.push(i);\\n        \\n        //minpq for departure time\\n        priority_queue<pair<int,int> ,vector<pair<int,int>>, greater<pair<int,int>> > pq_leaving;\\n        \\n        for(auto v : times){\\n            int arrival = v[0], dep = v[1];\\n            while(!pq_leaving.empty() && pq_leaving.top().first <= arrival){\\n                pair<int,int> p = pq_leaving.top();\\n                pq_leaving.pop();\\n                pq_chair.push(p.second);\\n            }\\n            int chair = pq_chair.top();\\n            pq_chair.pop();\\n            pq_leaving.push({dep,chair});\\n            if(arrival == target)\\n                return chair;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359704,
                "title": "c-2-min-heaps",
                "content": "```\\n/*\\nThis question was really tiring to solve. We just have to implement the stuff given in question.\\ncurTime represents the current time going on.\\navail is a min heap which will give us the minimum seat number available.\\npq is also a min heap in which we stores at a particular time which seat will get freed.\\n\\nImportant thing to note :-\\nTotal number of seats are basically total friends since nobody will set on 2 seats lol. Infinite is just to confuse us.\\n\\nThe code is self-explanatory , if  any doubts do ask.\\n\\nPls upvote it motivates me a lot\\n*/\\n\\n\\n\\n\\ntypedef pair<int,int> myPair;\\n\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) { \\n\\n        int old = times[targetFriend][0];\\n        sort(times.begin(),times.end());\\n        int targetInd = 0;\\n        priority_queue<int,vector<int>,greater<int>> avail;\\n        \\n        for(int i = 0; i < times.size(); ++i) {\\n            if(times[i][0] == old) \\n                targetInd = i;\\n            avail.push(i);\\n        }\\n        \\n        vector<int> arr(times.size(),-1);\\n        int curTime = times[0][0],ind = 0; // \\n        priority_queue<myPair,vector<myPair>,greater<myPair>> pq;\\n        \\n        while(ind < times.size()) {\\n            \\n            while(pq.size() != 0 && curTime == pq.top().first) {\\n                avail.push(pq.top().second);\\n                pq.pop();\\n            }\\n            if(curTime == times[ind][0]) {\\n                pq.push({times[ind][1],avail.top()});\\n                if(ind == targetInd) return avail.top();\\n                avail.pop();\\n            }\\n            if(ind + 1 == times.size())\\n                curTime = pq.top().first;\\n            else {\\n                if(pq.size() != 0 && pq.top().first < times[ind+1][0])\\n                    curTime = pq.top().first;\\n                else {\\n                    curTime = times[ind+1][0];\\n                    ind++;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nThis question was really tiring to solve. We just have to implement the stuff given in question.\\ncurTime represents the current time going on.\\navail is a min heap which will give us the minimum seat number available.\\npq is also a min heap in which we stores at a particular time which seat will get freed.\\n\\nImportant thing to note :-\\nTotal number of seats are basically total friends since nobody will set on 2 seats lol. Infinite is just to confuse us.\\n\\nThe code is self-explanatory , if  any doubts do ask.\\n\\nPls upvote it motivates me a lot\\n*/\\n\\n\\n\\n\\ntypedef pair<int,int> myPair;\\n\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) { \\n\\n        int old = times[targetFriend][0];\\n        sort(times.begin(),times.end());\\n        int targetInd = 0;\\n        priority_queue<int,vector<int>,greater<int>> avail;\\n        \\n        for(int i = 0; i < times.size(); ++i) {\\n            if(times[i][0] == old) \\n                targetInd = i;\\n            avail.push(i);\\n        }\\n        \\n        vector<int> arr(times.size(),-1);\\n        int curTime = times[0][0],ind = 0; // \\n        priority_queue<myPair,vector<myPair>,greater<myPair>> pq;\\n        \\n        while(ind < times.size()) {\\n            \\n            while(pq.size() != 0 && curTime == pq.top().first) {\\n                avail.push(pq.top().second);\\n                pq.pop();\\n            }\\n            if(curTime == times[ind][0]) {\\n                pq.push({times[ind][1],avail.top()});\\n                if(ind == targetInd) return avail.top();\\n                avail.pop();\\n            }\\n            if(ind + 1 == times.size())\\n                curTime = pq.top().first;\\n            else {\\n                if(pq.size() != 0 && pq.top().first < times[ind+1][0])\\n                    curTime = pq.top().first;\\n                else {\\n                    curTime = times[ind+1][0];\\n                    ind++;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361224,
                "title": "simplest-approach-no-priority-queue-clear-explanation",
                "content": "Greedy Approach:\\n1. sort the array ith respect to arrival time let be A\\n2. make a chair array\\n3. initially in chair array all index element mark as -1 , which means all the chair are initially empty\\n4. now iterate the A array and person start coming with arrival time\\n5. now for every person who enter check from starting wheter the chair is empty or not\\n    1. if empty put the departure time of that person into the chair\\n    2. else if departure time of chair is less than arrival time of person (that is finding seat)       which means the person which was seated before that person who came was left ,so allot that chair to person and put its departure time on chair\\n    3 for above two steps you can map arrival and departure time to chair index , so that you ccan return your answer\\n\\tPS: you can also use priority queue for find min chair that is empty\\n\\t*if you find it useful you can upvote me, it is free* :)\\n\\t```\\n\\t  struct party{\\n        int arr;\\n        int dep;\\n    };\\n    bool static cmp(party p1,party p2){\\n        if(p1.arr<=p2.arr){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        party a[times.size()];\\n        map<pair<int,int>,int>mp;\\n        int chair[times.size()];\\n        memset(chair,-1,sizeof(chair));\\n        int n=times.size();\\n        for(int i=0;i<times.size();i++){\\n            a[i].arr=times[i][0];\\n            a[i].dep=times[i][1];\\n        }\\n        sort(a,a+n,cmp);\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                if(chair[j]==-1){\\n                    chair[j]=a[i].dep;\\n                    mp[{a[i].arr,a[i].dep}]=j;\\n                    break;\\n                }\\n                else if(a[i].arr>=chair[j]){\\n                    chair[j]=a[i].dep;\\n                    mp[{a[i].arr,a[i].dep}]=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int x1=times[targetFriend][0];\\n        int y1=times[targetFriend][1];\\n        for(auto it:mp){\\n            pair<int,int>p=it.first;\\n            if(x1==p.first&&y1==p.second){\\n                return it.second;\\n            }\\n        }\\n        return 0;\\n    }\\n\\t```\\n\\t\\t4. else move to next chair\\n\\t\\t5.",
                "solutionTags": [],
                "code": "```\\n\\t  struct party{\\n        int arr;\\n        int dep;\\n    };\\n    bool static cmp(party p1,party p2){\\n        if(p1.arr<=p2.arr){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        party a[times.size()];\\n        map<pair<int,int>,int>mp;\\n        int chair[times.size()];\\n        memset(chair,-1,sizeof(chair));\\n        int n=times.size();\\n        for(int i=0;i<times.size();i++){\\n            a[i].arr=times[i][0];\\n            a[i].dep=times[i][1];\\n        }\\n        sort(a,a+n,cmp);\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                if(chair[j]==-1){\\n                    chair[j]=a[i].dep;\\n                    mp[{a[i].arr,a[i].dep}]=j;\\n                    break;\\n                }\\n                else if(a[i].arr>=chair[j]){\\n                    chair[j]=a[i].dep;\\n                    mp[{a[i].arr,a[i].dep}]=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int x1=times[targetFriend][0];\\n        int y1=times[targetFriend][1];\\n        for(auto it:mp){\\n            pair<int,int>p=it.first;\\n            if(x1==p.first&&y1==p.second){\\n                return it.second;\\n            }\\n        }\\n        return 0;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1360410,
                "title": "human-readable-explanations-sweep-line",
                "content": "The idea is to convert times array into an array of triplets:\\n```\\n[arrival time, leaving time] => [time, arrival(1), index]  [time, leaving(0), index] \\n\\n[\\n\\t[1,4],  =>  [1, 1, 0], [4, 0, 0]\\n\\t[2,3],  =>  [2, 1, 1], [3, 0, 1]\\n\\t[4,6]   =>  [4, 1, 2], [6, 0, 2]\\n] \\n```\\n\\nThen we sort the array of triplets, we assign leaving as 0 and arrival as 1 to make sure for people arrive can grab the chair of people just left.\\n\\nWith this sorted array, we just pocess one by one until we see the target friend.  When people arrive, assign the smallest chair available(heap) and save this in a hashmap. When people leave, return the chair back to heap.\\n\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<vector<int>> vec;\\n        \\n        for (int i = 0; i < times.size(); i++) {\\n            vec.push_back({times[i][0], 1, i}); // arrive\\n            vec.push_back({times[i][1], 0, i}); // leave\\n        }\\n        \\n        sort(vec.begin(), vec.end());\\n    \\n        int nextChair = 0;\\n        set<int> s;\\n        unordered_map<int, int> hashmap;\\n        for (int i = 0; i < vec.size(); i++) {\\n            if (vec[i][1] == 1) { // arrive\\n                if (s.size()) {\\n                    hashmap[vec[i][2]] = *s.begin();\\n                    s.erase(s.begin());\\n                } else {\\n                    hashmap[vec[i][2]] = nextChair++;\\n                }\\n                \\n                if (vec[i][2] == targetFriend) {\\n                    return hashmap[vec[i][2]];\\n                }\\n            } else { // leave\\n                s.insert(hashmap[vec[i][2]]);\\n                hashmap.erase(vec[i][2]);\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[arrival time, leaving time] => [time, arrival(1), index]  [time, leaving(0), index] \\n\\n[\\n\\t[1,4],  =>  [1, 1, 0], [4, 0, 0]\\n\\t[2,3],  =>  [2, 1, 1], [3, 0, 1]\\n\\t[4,6]   =>  [4, 1, 2], [6, 0, 2]\\n] \\n```\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<vector<int>> vec;\\n        \\n        for (int i = 0; i < times.size(); i++) {\\n            vec.push_back({times[i][0], 1, i}); // arrive\\n            vec.push_back({times[i][1], 0, i}); // leave\\n        }\\n        \\n        sort(vec.begin(), vec.end());\\n    \\n        int nextChair = 0;\\n        set<int> s;\\n        unordered_map<int, int> hashmap;\\n        for (int i = 0; i < vec.size(); i++) {\\n            if (vec[i][1] == 1) { // arrive\\n                if (s.size()) {\\n                    hashmap[vec[i][2]] = *s.begin();\\n                    s.erase(s.begin());\\n                } else {\\n                    hashmap[vec[i][2]] = nextChair++;\\n                }\\n                \\n                if (vec[i][2] == targetFriend) {\\n                    return hashmap[vec[i][2]];\\n                }\\n            } else { // leave\\n                s.insert(hashmap[vec[i][2]]);\\n                hashmap.erase(vec[i][2]);\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359835,
                "title": "easy-java-solution-using-one-min-heap",
                "content": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        \\n        int n = times.length;\\n        \\n        Pair arr[] = new Pair[n];\\n        Pair dept[] = new Pair[n];\\n        \\n        for(int i=0; i<n; i++){\\n            arr[i] = new Pair(i, times[i][0]);\\n            dept[i] = new Pair(i, times[i][1]);\\n        }\\n        \\n        Arrays.sort(arr, (a, b) -> a.time - b.time);\\n        Arrays.sort(dept, (a, b) -> a.time - b.time);\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=0; i<=10000; i++){\\n            pq.add(i);\\n        }\\n        \\n        int alloted[] = new int[n];\\n        \\n        int i= 0, j = 0;\\n        \\n        while(i<n && j<n){\\n            if(arr[i].time < dept[j].time){\\n                alloted[arr[i].idx] = pq.poll();\\n                i++;\\n            }else if(arr[i].time >= dept[j].time){\\n                pq.add(alloted[dept[j].idx]);\\n                j++;\\n            }\\n        }\\n        return alloted[targetFriend];\\n    }\\n}\\nclass Pair{\\n    int idx, time;\\n    Pair(int idx, int time){\\n        this.idx = idx;\\n        this.time = time;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        \\n        int n = times.length;\\n        \\n        Pair arr[] = new Pair[n];\\n        Pair dept[] = new Pair[n];\\n        \\n        for(int i=0; i<n; i++){\\n            arr[i] = new Pair(i, times[i][0]);\\n            dept[i] = new Pair(i, times[i][1]);\\n        }\\n        \\n        Arrays.sort(arr, (a, b) -> a.time - b.time);\\n        Arrays.sort(dept, (a, b) -> a.time - b.time);\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=0; i<=10000; i++){\\n            pq.add(i);\\n        }\\n        \\n        int alloted[] = new int[n];\\n        \\n        int i= 0, j = 0;\\n        \\n        while(i<n && j<n){\\n            if(arr[i].time < dept[j].time){\\n                alloted[arr[i].idx] = pq.poll();\\n                i++;\\n            }else if(arr[i].time >= dept[j].time){\\n                pq.add(alloted[dept[j].idx]);\\n                j++;\\n            }\\n        }\\n        return alloted[targetFriend];\\n    }\\n}\\nclass Pair{\\n    int idx, time;\\n    Pair(int idx, int time){\\n        this.idx = idx;\\n        this.time = time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490302,
                "title": "simulation-6-line-python-solution",
                "content": "# Notes\\n* `available` is a **min heap** of all available seat numbers. `i.e., 0, ... n`, where `n` is the length of `times` array, or the maximum possible seats.\\n* `leave_times` is a **min heap** of (time when a person will leave, seat number assigned to this person).\\n\\n\\n# Code\\n```python3\\ndef smallestChair(self, times: List[List[int]], target: int) -> int:\\n    available, leave_times = list(range(len(times))), []\\n    for arrival, leaving in sorted(times):\\n        while leave_times and leave_times[0][0] <= arrival:\\n            heappush(available, heappop(leave_times)[1])\\n        if arrival == times[target][0]: return available[0]\\n        heappush(leave_times, (leaving, heappop(available)))\\n\\n```\\n\\n# Explanation\\nSort `times` by arrival time, and simulate the seat assignment process.\\n\\nFor every new friend that wants a seat assigned, first check whether the `arrival` time of that friend is greater than or equal to the leaving time of some other friends. If so, make those seats available.\\n\\nSince all arrival times are unique (given in the problem statement), we can use arrival time to tell whether we have reached the target friend. When we reach the target friend, we return the minimum available seat as required (`if arrival == times[target][0]: return available[0]`).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3\\ndef smallestChair(self, times: List[List[int]], target: int) -> int:\\n    available, leave_times = list(range(len(times))), []\\n    for arrival, leaving in sorted(times):\\n        while leave_times and leave_times[0][0] <= arrival:\\n            heappush(available, heappop(leave_times)[1])\\n        if arrival == times[target][0]: return available[0]\\n        heappush(leave_times, (leaving, heappop(available)))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1388335,
                "title": "most-self-explanatory-c-code-you-ll-ever-see",
                "content": "A simple intuitive c++ code which is well commented to get through your interviews.\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n\\n        // store persons start time, end time, original position\\n        vector<vector<int>> person;\\n        for(int i = 0; i < n; i++)\\n            person.push_back({times[i][0], times[i][1], i});\\n\\n        // sort persons according to arrival time\\n        sort(person.begin(), person.end());\\n\\n        // store empty chairs in min heap\\n        set<int> chair;\\n        for(int i = 0; i <= n; i++) chair.insert(i);\\n\\n        // store occupied chair\\'s end time\\n        set<vector<int>> occupied;\\n        for(int i = 0; i < n; i++) {\\n\\n            // loop through occupied chairs to remove expired ones by checking\\n            // with curr arrival time and insert those chairs into heap \\n            while(!occupied.empty()) {\\n                int x = (*occupied.begin())[0];\\n                int y = (*occupied.begin())[1];\\n                if(x > person[i][0]) break;\\n                chair.insert(y);\\n                occupied.erase(occupied.begin());\\n            }\\n\\n            // check curr person for targetFriend\\n            if(person[i][2] == targetFriend) return (*chair.begin());\\n\\n            // insert curr person in occupied and\\n            // remove occupied chair from heap\\n            occupied.insert({person[i][1], (*chair.begin())});\\n            chair.erase(chair.begin());\\n        }\\n        return 0;\\n    }\\n};\\n```\\nHappy Coding! If you find it useful please upvote! Suggestions welcomed :)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n\\n        // store persons start time, end time, original position\\n        vector<vector<int>> person;\\n        for(int i = 0; i < n; i++)\\n            person.push_back({times[i][0], times[i][1], i});\\n\\n        // sort persons according to arrival time\\n        sort(person.begin(), person.end());\\n\\n        // store empty chairs in min heap\\n        set<int> chair;\\n        for(int i = 0; i <= n; i++) chair.insert(i);\\n\\n        // store occupied chair\\'s end time\\n        set<vector<int>> occupied;\\n        for(int i = 0; i < n; i++) {\\n\\n            // loop through occupied chairs to remove expired ones by checking\\n            // with curr arrival time and insert those chairs into heap \\n            while(!occupied.empty()) {\\n                int x = (*occupied.begin())[0];\\n                int y = (*occupied.begin())[1];\\n                if(x > person[i][0]) break;\\n                chair.insert(y);\\n                occupied.erase(occupied.begin());\\n            }\\n\\n            // check curr person for targetFriend\\n            if(person[i][2] == targetFriend) return (*chair.begin());\\n\\n            // insert curr person in occupied and\\n            // remove occupied chair from heap\\n            occupied.insert({person[i][1], (*chair.begin())});\\n            chair.erase(chair.begin());\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360000,
                "title": "two-pointers-and-a-hashmap-o-n-log-n-time-o-n-space",
                "content": "As far as JS doesn\\'t have MinHeap I decided to improvise and here is the idea I came up. **O(N logN)** avg. **O(N^2)** worst time and **O(N)** space.\\n\\nRuntime: 164 ms, faster than **100.00%** of JavaScript online submissions for The Number of the Smallest Unoccupied Chair.\\nMemory Usage: 48.9 MB, less than **100.00%** of JavaScript online submissions for The Number of the Smallest Unoccupied Chair.\\n\\n```javascript\\n/**\\n * @param {number[][]} times\\n * @param {number} targetFriend\\n * @return {number}\\n */\\nvar smallestChair = function(times, targetFriend) {\\n    const [targetArrival] = times[targetFriend]; // we need only arrival time\\n    const arrivalQueue = times;\\n    const leavingQueue = [...times];\\n    arrivalQueue.sort((a, b) => a[0] - b[0]); // sort by arrival time\\n    leavingQueue.sort((a, b) => (a[1] - b[1]) || (a[0] - b[0])); // sort by leaving time and if they are equal by arrival\\n    const chairsByLeaveTime = new Map(); // key - arrival time, value - chair index\\n    let chairsCount = 0;\\n    let arriving = 0, leaving = 0; // two pointers for keeping track of available chairs\\n    \\n    while (arriving < arrivalQueue.length) {\\n        let chairIdx;\\n        const arrival = arrivalQueue[arriving][0];\\n        const leave = leavingQueue[leaving][1];\\n\\t\\tif (arrival < leave) {\\n            chairIdx = chairsCount++; // if no one is leaving, take a new chair\\n        } else {\\n            let freeChairIdx = leaving;\\n            chairIdx = chairsByLeaveTime.get(leavingQueue[freeChairIdx++][0]); // when arriaval time is less then or equal to the next leaving friend we can take her chair\\n            while (arrival >= leavingQueue[freeChairIdx][1]) { // to avoid situation when a few friends left already and the next chair in leaving queue is not the smallest\\n                const nextChair = chairsByLeaveTime.get(leavingQueue[freeChairIdx][0]);\\n                if (chairIdx > nextChair) {\\n                    [leavingQueue[leaving], leavingQueue[freeChairIdx]] = [leavingQueue[freeChairIdx], leavingQueue[leaving]]; // swap the front of the queue with the smallest chair owner\\n                    chairIdx = nextChair;\\n                }\\n                ++freeChairIdx;\\n            }\\n            ++leaving;\\n        }\\n        if (targetArrival === arrival) { // we found the target, no need to continue\\n            return chairIdx;\\n        }\\n        chairsByLeaveTime.set(arrival, chairIdx); // as far as arrival time is distinct, we can use it as a key\\n        arriving++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} times\\n * @param {number} targetFriend\\n * @return {number}\\n */\\nvar smallestChair = function(times, targetFriend) {\\n    const [targetArrival] = times[targetFriend]; // we need only arrival time\\n    const arrivalQueue = times;\\n    const leavingQueue = [...times];\\n    arrivalQueue.sort((a, b) => a[0] - b[0]); // sort by arrival time\\n    leavingQueue.sort((a, b) => (a[1] - b[1]) || (a[0] - b[0])); // sort by leaving time and if they are equal by arrival\\n    const chairsByLeaveTime = new Map(); // key - arrival time, value - chair index\\n    let chairsCount = 0;\\n    let arriving = 0, leaving = 0; // two pointers for keeping track of available chairs\\n    \\n    while (arriving < arrivalQueue.length) {\\n        let chairIdx;\\n        const arrival = arrivalQueue[arriving][0];\\n        const leave = leavingQueue[leaving][1];\\n\\t\\tif (arrival < leave) {\\n            chairIdx = chairsCount++; // if no one is leaving, take a new chair\\n        } else {\\n            let freeChairIdx = leaving;\\n            chairIdx = chairsByLeaveTime.get(leavingQueue[freeChairIdx++][0]); // when arriaval time is less then or equal to the next leaving friend we can take her chair\\n            while (arrival >= leavingQueue[freeChairIdx][1]) { // to avoid situation when a few friends left already and the next chair in leaving queue is not the smallest\\n                const nextChair = chairsByLeaveTime.get(leavingQueue[freeChairIdx][0]);\\n                if (chairIdx > nextChair) {\\n                    [leavingQueue[leaving], leavingQueue[freeChairIdx]] = [leavingQueue[freeChairIdx], leavingQueue[leaving]]; // swap the front of the queue with the smallest chair owner\\n                    chairIdx = nextChair;\\n                }\\n                ++freeChairIdx;\\n            }\\n            ++leaving;\\n        }\\n        if (targetArrival === arrival) { // we found the target, no need to continue\\n            return chairIdx;\\n        }\\n        chairsByLeaveTime.set(arrival, chairIdx); // as far as arrival time is distinct, we can use it as a key\\n        arriving++;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359811,
                "title": "java-treeset-and-sort-100-runtime",
                "content": "```\\npublic int smallestChair(int[][] times, int targetFriend) {\\n        int n = times.length;\\n        int [][]timeWithIds = new int[2*n][3];\\n        TreeSet<Integer> chairs = new TreeSet();\\n        for(int i=0;i<n;i++){\\n            timeWithIds[i] = new int[]{times[i][0], 1, i};\\n            timeWithIds[n+i] = new int[]{times[i][1], -1, i};\\n            chairs.add(i);\\n        }\\n        Arrays.sort(timeWithIds, Comparator.<int [], Integer>comparing(key -> key[0]).thenComparing(key -> key[1]));\\n        Map<Integer, Integer> personToChairMap = new HashMap();\\n        for(int []time: timeWithIds){\\n            if(time[1] == 1){\\n                int chair = chairs.first();\\n                chairs.remove(chair);\\n                personToChairMap.put(time[2], chair);\\n                if(time[2] == targetFriend){\\n                    return chair;\\n                }\\n            }else{\\n                int chair = personToChairMap.get(time[2]);\\n                chairs.add(chair);\\n                personToChairMap.remove(time[2]);\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int smallestChair(int[][] times, int targetFriend) {\\n        int n = times.length;\\n        int [][]timeWithIds = new int[2*n][3];\\n        TreeSet<Integer> chairs = new TreeSet();\\n        for(int i=0;i<n;i++){\\n            timeWithIds[i] = new int[]{times[i][0], 1, i};\\n            timeWithIds[n+i] = new int[]{times[i][1], -1, i};\\n            chairs.add(i);\\n        }\\n        Arrays.sort(timeWithIds, Comparator.<int [], Integer>comparing(key -> key[0]).thenComparing(key -> key[1]));\\n        Map<Integer, Integer> personToChairMap = new HashMap();\\n        for(int []time: timeWithIds){\\n            if(time[1] == 1){\\n                int chair = chairs.first();\\n                chairs.remove(chair);\\n                personToChairMap.put(time[2], chair);\\n                if(time[2] == targetFriend){\\n                    return chair;\\n                }\\n            }else{\\n                int chair = personToChairMap.get(time[2]);\\n                chairs.add(chair);\\n                personToChairMap.remove(time[2]);\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359781,
                "title": "python-heap-sort-solution",
                "content": "```python\\na = times[targetFriend][0]\\ntimes.sort()\\nchairs, heap, count = [], [], 0\\nfor t1, t2 in times:\\n\\twhile heap and heap[0][0] <= t1:\\n\\t\\t_, i = heapq.heappop(heap)\\n\\t\\tbisect.insort(chairs, i)\\n\\tif t1 == a:\\n\\t\\treturn chairs[0] if chairs else count\\n\\tif not chairs:\\n\\t\\theapq.heappush(heap, (t2, count))\\n\\t\\tcount += 1\\n\\telse:\\n\\t\\theapq.heappush(heap, (t2, chairs.pop(0)))\\n```",
                "solutionTags": [],
                "code": "```python\\na = times[targetFriend][0]\\ntimes.sort()\\nchairs, heap, count = [], [], 0\\nfor t1, t2 in times:\\n\\twhile heap and heap[0][0] <= t1:\\n\\t\\t_, i = heapq.heappop(heap)\\n\\t\\tbisect.insort(chairs, i)\\n\\tif t1 == a:\\n\\t\\treturn chairs[0] if chairs else count\\n\\tif not chairs:\\n\\t\\theapq.heappush(heap, (t2, count))\\n\\t\\tcount += 1\\n\\telse:\\n\\t\\theapq.heappush(heap, (t2, chairs.pop(0)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1772737,
                "title": "java-two-priority-queues",
                "content": "**Intuition**\\n1. We need some data structure to maintain the order of the available chair no\\'s.\\n2. Before assigning a chair to a person, we should make sure to add the chairs emptied by occupied persons.\\n3. We should know when the chair should be added to the avaialble chairs. We can accomplish this by binding chair no with the leaving time of the person.\\n\\n```\\nclass Solution {\\n  \\n    class Pair implements Comparable<Pair> {\\n        int seatNo;\\n        int leavingTime;\\n        \\n        Pair(int seatNo, int leavingTime){\\n            this.seatNo = seatNo;\\n            this.leavingTime = leavingTime;\\n        }\\n        \\n        public int compareTo(Pair o){\\n            return this.leavingTime - o.leavingTime;\\n        }\\n    }\\n    \\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int arrivalTime = times[targetFriend][0];\\n        \\n        Arrays.sort(times, (a, b) -> a[0] - b[0]);\\n        \\n        PriorityQueue<Integer> availableSeats = new PriorityQueue<>();\\n        for(int i = 0; i < times.length; i++){\\n            availableSeats.offer(i);\\n        }\\n        \\n        PriorityQueue<Pair> occupiedSeats = new PriorityQueue<>();\\n        \\n        for(int i = 0; i < times.length; i++){\\n            int[] curr = times[i];\\n            while(occupiedSeats.size() > 0 && occupiedSeats.peek().leavingTime <= curr[0]){\\n                int seatNo = occupiedSeats.poll().seatNo;\\n                availableSeats.offer(seatNo);\\n            }\\n            if(arrivalTime == curr[0]){\\n                return availableSeats.peek();\\n            }\\n            \\n            occupiedSeats.offer(new Pair(availableSeats.poll(), curr[1]));\\n        }\\n        \\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n  \\n    class Pair implements Comparable<Pair> {\\n        int seatNo;\\n        int leavingTime;\\n        \\n        Pair(int seatNo, int leavingTime){\\n            this.seatNo = seatNo;\\n            this.leavingTime = leavingTime;\\n        }\\n        \\n        public int compareTo(Pair o){\\n            return this.leavingTime - o.leavingTime;\\n        }\\n    }\\n    \\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int arrivalTime = times[targetFriend][0];\\n        \\n        Arrays.sort(times, (a, b) -> a[0] - b[0]);\\n        \\n        PriorityQueue<Integer> availableSeats = new PriorityQueue<>();\\n        for(int i = 0; i < times.length; i++){\\n            availableSeats.offer(i);\\n        }\\n        \\n        PriorityQueue<Pair> occupiedSeats = new PriorityQueue<>();\\n        \\n        for(int i = 0; i < times.length; i++){\\n            int[] curr = times[i];\\n            while(occupiedSeats.size() > 0 && occupiedSeats.peek().leavingTime <= curr[0]){\\n                int seatNo = occupiedSeats.poll().seatNo;\\n                availableSeats.offer(seatNo);\\n            }\\n            if(arrivalTime == curr[0]){\\n                return availableSeats.peek();\\n            }\\n            \\n            occupiedSeats.offer(new Pair(availableSeats.poll(), curr[1]));\\n        }\\n        \\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573405,
                "title": "c-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<int> idx(times.size());\\n        iota(idx.begin(), idx.end(), 0);\\n        sort(idx.begin(), idx.end(), [&times] (int i, int j) {\\n            return times[i][0] < times[j][0];\\n        });\\n        map<int, vector<int>> m;\\n        priority_queue<int, vector<int>, greater<int>> pq(idx.begin(), idx.end());\\n        for (int i = 0; i < times.size(); i++) {\\n            int j = idx[i];\\n            for (; !m.empty() && m.begin()->first <= times[j][0];) {\\n                for (auto pos : m.begin()->second)\\n                    pq.push(pos);\\n                m.erase(m.begin());\\n            }\\n            if (j == targetFriend) return pq.top();\\n            m[times[j][1]].push_back(pq.top());\\n            pq.pop();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<int> idx(times.size());\\n        iota(idx.begin(), idx.end(), 0);\\n        sort(idx.begin(), idx.end(), [&times] (int i, int j) {\\n            return times[i][0] < times[j][0];\\n        });\\n        map<int, vector<int>> m;\\n        priority_queue<int, vector<int>, greater<int>> pq(idx.begin(), idx.end());\\n        for (int i = 0; i < times.size(); i++) {\\n            int j = idx[i];\\n            for (; !m.empty() && m.begin()->first <= times[j][0];) {\\n                for (auto pos : m.begin()->second)\\n                    pq.push(pos);\\n                m.erase(m.begin());\\n            }\\n            if (j == targetFriend) return pq.top();\\n            m[times[j][1]].push_back(pq.top());\\n            pq.pop();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364879,
                "title": "python-o-n-log-n-time-using-a-min-heap-and-a-dictionary",
                "content": "* Process the arrivals and departures in sorted order of time, departure first when tied.\\n* Keep track of assigned chairs using a dictionary and available chairs using a min heap (or priority queue).\\n\\n```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        tuples = []\\n        for friend, (arrive, depart) in enumerate(times):\\n            tuples.extend([(depart, 0, friend), (arrive, 1, friend)])\\n        tuples.sort()\\n        \\n        chair = 0\\n        available = []\\n        assigned = defaultdict(int)\\n        \\n        for time, arr_dep, friend in tuples:\\n            if arr_dep == 0: # departure\\n                ch = assigned.pop(friend)\\n                heapq.heappush(available, ch)\\n            else: # arrival\\n                if available:\\n                    ch = heapq.heappop(available)\\n                else:\\n                    ch = chair \\n                    chair += 1\\n                if friend == targetFriend:\\n                    return ch\\n                else:\\n                    assigned[friend] = ch\\n```\\n\\n* To simplify the logic, we can put chairs `0` to `n-1` in the `available`  heap, to begin with\\n\\n```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        \\n        tuples = sorted([triplet for friend, (arrive, depart) in enumerate(times) for triplet in [(depart, 0, friend), (arrive, 1, friend)]])\\n        \\n        available = list(range(len(times)))\\n        heapq.heapify(available)\\n        assigned = defaultdict(int)\\n        \\n        for time, departure, friend in tuples:\\n            if departure:\\n                if friend == targetFriend: \\n                    return heapq.heappop(available)\\n                assigned[friend] = heapq.heappop(available)\\n            else:\\n                heapq.heappush(available, assigned.pop(friend))\\n```\\n\\n* Time: `O(n log n)`, where `n = len(times)`\\n* Space: `O(n)`\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        tuples = []\\n        for friend, (arrive, depart) in enumerate(times):\\n            tuples.extend([(depart, 0, friend), (arrive, 1, friend)])\\n        tuples.sort()\\n        \\n        chair = 0\\n        available = []\\n        assigned = defaultdict(int)\\n        \\n        for time, arr_dep, friend in tuples:\\n            if arr_dep == 0: # departure\\n                ch = assigned.pop(friend)\\n                heapq.heappush(available, ch)\\n            else: # arrival\\n                if available:\\n                    ch = heapq.heappop(available)\\n                else:\\n                    ch = chair \\n                    chair += 1\\n                if friend == targetFriend:\\n                    return ch\\n                else:\\n                    assigned[friend] = ch\\n```\n```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        \\n        tuples = sorted([triplet for friend, (arrive, depart) in enumerate(times) for triplet in [(depart, 0, friend), (arrive, 1, friend)]])\\n        \\n        available = list(range(len(times)))\\n        heapq.heapify(available)\\n        assigned = defaultdict(int)\\n        \\n        for time, departure, friend in tuples:\\n            if departure:\\n                if friend == targetFriend: \\n                    return heapq.heappop(available)\\n                assigned[friend] = heapq.heappop(available)\\n            else:\\n                heapq.heappush(available, assigned.pop(friend))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363165,
                "title": "cpp-solution-two-min-heaps",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int a) {\\n//         storing the target friend\\n        int target=times[a][0];\\n        \\n        sort(times.begin(),times.end());\\n        \\n        priority_queue<int,vector<int>,greater<int>>pq_chair;\\n        \\n        for(int i=0;i<times.size();i++)pq_chair.push(i);  // chairs available \\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq_leaving;\\n        // this will store departure time and chair a friend has occupied\\n        \\n        for(auto x: times){\\n            int arr=x[0];\\n            int dep=x[1];\\n            \\n            while(!pq_leaving.empty() && pq_leaving.top().first <=arr){\\n                \\n                pair<int,int>p=pq_leaving.top();\\n                pq_leaving.pop();\\n                \\n                pq_chair.push(p.second); // again this chair is available\\n                \\n            }\\n            \\n            int chair=pq_chair.top(); // chair that the friend will take\\n            pq_chair.pop();\\n            \\n            pq_leaving.push({dep,chair});\\n            \\n            if(target==arr){\\n                return chair;\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int a) {\\n//         storing the target friend\\n        int target=times[a][0];\\n        \\n        sort(times.begin(),times.end());\\n        \\n        priority_queue<int,vector<int>,greater<int>>pq_chair;\\n        \\n        for(int i=0;i<times.size();i++)pq_chair.push(i);  // chairs available \\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq_leaving;\\n        // this will store departure time and chair a friend has occupied\\n        \\n        for(auto x: times){\\n            int arr=x[0];\\n            int dep=x[1];\\n            \\n            while(!pq_leaving.empty() && pq_leaving.top().first <=arr){\\n                \\n                pair<int,int>p=pq_leaving.top();\\n                pq_leaving.pop();\\n                \\n                pq_chair.push(p.second); // again this chair is available\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1361577,
                "title": "c-easy-priority-queue-commented-code",
                "content": "Hi, this is the same code I submitted in contest, so your insight would be very much appreciated.\\n```\\n#define pii pair<int,int>\\n#define s second\\n#define f first\\n\\n\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        \\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        int n = times.size();\\n\\t\\t\\n\\t\\t// Priority queue of available chairs \\n        for(int i=1;i<=n;i++)\\n            pq.push(i);\\n        \\n\\t\\t// Push all start end time in vector \\n\\t\\t// in format ( time , (1/0 1 -> start , 0-> end ) , (index))\\n\\t\\t\\n\\t\\t// Here start has 1 because if there is friend ending at some time t and also other starting at t , \\n\\t\\t//then end should appear before start , otherwise the calculation might go wrong \\n\\t\\t//How?? -> ( end has smaller chair , and if start comes before it may get bigger chair though it is mentioned in question \\n\\t\\t// that it can get chair of end guy)\\n\\t\\t\\n        vector<pair<int,pair<int,int>>>all;\\n        for(int i=0;i<n;i++)\\n        {\\n            all.push_back({times[i][0],{1,i}});\\n            all.push_back({times[i][1],{0,i}});\\n        }\\n\\t\\t// sort fromt starting from end\\n        sort(all.begin(),all.end());\\n\\t\\t\\n\\t\\t// This maps friend to chair\\n        unordered_map<int,int>mp;\\n\\t\\t\\n        for(int i=0;i<all.size();i++)\\n        {\\n            int tim = all[i].f;\\n            int ind = all[i].s.s;\\n            int in = all[i].s.f;\\n            int ch=n;\\n\\t\\t\\t\\n\\t\\t\\t// If it is start time\\n            if(in==1)\\n            {\\n\\t\\t\\t\\t// get smallest possible chair \\n                ch = pq.top();\\n                pq.pop();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Map it to friend\\n                mp[ind]=ch;\\n\\t\\t\\t\\t// If this is target , return\\n                if(ind==targetFriend)\\n                    return ch-1;\\n            }\\n\\t\\t\\t// else if it is end time\\n            else\\n            {\\n\\t\\t\\t\\t// get the chair from map\\n                ch = mp[ind];\\n\\t\\t\\t\\t// Unmap friend\\n                mp[ind]=0;\\n\\t\\t\\t\\t// Push chair back in priority_queue\\n                pq.push(ch);\\n            }\\n            \\n        }\\n        return n;\\n    }\\n};\\n```\\nFeel free to drop comments :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define pii pair<int,int>\\n#define s second\\n#define f first\\n\\n\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        \\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        int n = times.size();\\n\\t\\t\\n\\t\\t// Priority queue of available chairs \\n        for(int i=1;i<=n;i++)\\n            pq.push(i);\\n        \\n\\t\\t// Push all start end time in vector \\n\\t\\t// in format ( time , (1/0 1 -> start , 0-> end ) , (index))\\n\\t\\t\\n\\t\\t// Here start has 1 because if there is friend ending at some time t and also other starting at t , \\n\\t\\t//then end should appear before start , otherwise the calculation might go wrong \\n\\t\\t//How?? -> ( end has smaller chair , and if start comes before it may get bigger chair though it is mentioned in question \\n\\t\\t// that it can get chair of end guy)\\n\\t\\t\\n        vector<pair<int,pair<int,int>>>all;\\n        for(int i=0;i<n;i++)\\n        {\\n            all.push_back({times[i][0],{1,i}});\\n            all.push_back({times[i][1],{0,i}});\\n        }\\n\\t\\t// sort fromt starting from end\\n        sort(all.begin(),all.end());\\n\\t\\t\\n\\t\\t// This maps friend to chair\\n        unordered_map<int,int>mp;\\n\\t\\t\\n        for(int i=0;i<all.size();i++)\\n        {\\n            int tim = all[i].f;\\n            int ind = all[i].s.s;\\n            int in = all[i].s.f;\\n            int ch=n;\\n\\t\\t\\t\\n\\t\\t\\t// If it is start time\\n            if(in==1)\\n            {\\n\\t\\t\\t\\t// get smallest possible chair \\n                ch = pq.top();\\n                pq.pop();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Map it to friend\\n                mp[ind]=ch;\\n\\t\\t\\t\\t// If this is target , return\\n                if(ind==targetFriend)\\n                    return ch-1;\\n            }\\n\\t\\t\\t// else if it is end time\\n            else\\n            {\\n\\t\\t\\t\\t// get the chair from map\\n                ch = mp[ind];\\n\\t\\t\\t\\t// Unmap friend\\n                mp[ind]=0;\\n\\t\\t\\t\\t// Push chair back in priority_queue\\n                pq.push(ch);\\n            }\\n            \\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360193,
                "title": "java-easy-to-understand-detailed-explaination",
                "content": "**Intuition**\\n* We first need to sort the people based on the arrival times. But since we also need to know the actual ordering of a person, we will store it as part of the `Person` object as `id`\\n* The idea is to maintain the free chairs at any time. Also this need to be sorted in natural ordering so we can use a min-heap so that we can get the lowest available free chair\\n* We will also need to maintain a min-heap `chairs` with the used chairs to keep a track of the id of the chair and when will the chair be free. We need the min-heap so that we can get the chair which will be freed at earliest\\n* Now whenever a person comes we first have to free any used chairs if applicable\\n* Once all the applicable chairs have been freed then we assign the lowest chair to the person. If this is the target person we return the chair with lowest id\\n\\n\\n```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int n = times.length;\\n        Person[] people = new Person[n];\\n\\n        PriorityQueue<Integer> freeChairs = new PriorityQueue<>();\\n        for(int i=0;i<n;i++) {\\n            people[i] = new Person(i, times[i][0], times[i][1]);\\n            freeChairs.add(i);\\n        }\\n        \\n        Arrays.sort(people, (a,b) -> a.arrival-b.arrival);\\n        \\n\\t\\t// If two chairs get free at same time, the chair with lower id will have more priority\\n        PriorityQueue<Chair> chairs = new PriorityQueue<>((a,b)->(a.time==b.time? a.id-b.id : a.time-b.time));\\n        for(int i=0;i<n;i++){\\n            if(chairs.isEmpty()) {\\n                if(people[i].id==targetFriend){\\n                    return freeChairs.poll();\\n                }\\n                Chair chair = new Chair(freeChairs.poll(), people[i].departure);\\n                chairs.add(chair);\\n            } else {\\n\\t\\t\\t\\t// Free all chairs applicable till now\\n                while(!chairs.isEmpty()&&chairs.peek().time<=people[i].arrival){\\n                    freeChairs.add(chairs.poll().id);\\n                }\\n                \\n                if(people[i].id==targetFriend){\\n                    return freeChairs.poll();\\n                }\\n                Chair chair = new Chair(freeChairs.poll(), people[i].departure);\\n                chairs.add(chair);\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n\\nclass Person {\\n    int id;\\n    int arrival;\\n    int departure;\\n    \\n    public Person(int id, int arrival, int departure) {\\n        this.id = id;\\n        this.arrival = arrival;\\n        this.departure = departure;\\n    }\\n}\\n\\nclass Chair {\\n    int id;\\n    int time;\\n    \\n    public Chair(int id, int time) {\\n        this.id = id;\\n        this.time = time;\\n    }\\n}\\n```\\n\\nPlease let me know if you have any doubts. Also upvote if you like it so it could reach others.",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int n = times.length;\\n        Person[] people = new Person[n];\\n\\n        PriorityQueue<Integer> freeChairs = new PriorityQueue<>();\\n        for(int i=0;i<n;i++) {\\n            people[i] = new Person(i, times[i][0], times[i][1]);\\n            freeChairs.add(i);\\n        }\\n        \\n        Arrays.sort(people, (a,b) -> a.arrival-b.arrival);\\n        \\n\\t\\t// If two chairs get free at same time, the chair with lower id will have more priority\\n        PriorityQueue<Chair> chairs = new PriorityQueue<>((a,b)->(a.time==b.time? a.id-b.id : a.time-b.time));\\n        for(int i=0;i<n;i++){\\n            if(chairs.isEmpty()) {\\n                if(people[i].id==targetFriend){\\n                    return freeChairs.poll();\\n                }\\n                Chair chair = new Chair(freeChairs.poll(), people[i].departure);\\n                chairs.add(chair);\\n            } else {\\n\\t\\t\\t\\t// Free all chairs applicable till now\\n                while(!chairs.isEmpty()&&chairs.peek().time<=people[i].arrival){\\n                    freeChairs.add(chairs.poll().id);\\n                }\\n                \\n                if(people[i].id==targetFriend){\\n                    return freeChairs.poll();\\n                }\\n                Chair chair = new Chair(freeChairs.poll(), people[i].departure);\\n                chairs.add(chair);\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n\\nclass Person {\\n    int id;\\n    int arrival;\\n    int departure;\\n    \\n    public Person(int id, int arrival, int departure) {\\n        this.id = id;\\n        this.arrival = arrival;\\n        this.departure = departure;\\n    }\\n}\\n\\nclass Chair {\\n    int id;\\n    int time;\\n    \\n    public Chair(int id, int time) {\\n        this.id = id;\\n        this.time = time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359850,
                "title": "why-does-this-not-work-for-all-test-cases-am-i-missing-something",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        \\n        for(int i = 0; i<n; i++) {\\n            times[i].push_back(i);\\n        }\\n        \\n        auto lambda = [](vector<int>& v1, vector<int>& v2) {\\n            return v1[0] < v2[0];\\n        };\\n        \\n        sort(begin(times), end(times), lambda);\\n                \\n        vector<vector<int>> temp;\\n        temp.push_back(times[0]);\\n        if(times[0][2] == targetFriend)\\n            return 0;\\n        \\n        int chair = 0;\\n        for(int i = 1; i<n; i++) {\\n            chair++;\\n            while(!temp.empty() && temp.back()[1] <= times[i][0]) {\\n                temp.pop_back();\\n                chair--;\\n            }\\n            if(times[i][2] == targetFriend)\\n                return chair;\\n            \\n            \\n            temp.push_back(times[i]);\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        \\n        for(int i = 0; i<n; i++) {\\n            times[i].push_back(i);\\n        }\\n        \\n        auto lambda = [](vector<int>& v1, vector<int>& v2) {\\n            return v1[0] < v2[0];\\n        };\\n        \\n        sort(begin(times), end(times), lambda);\\n                \\n        vector<vector<int>> temp;\\n        temp.push_back(times[0]);\\n        if(times[0][2] == targetFriend)\\n            return 0;\\n        \\n        int chair = 0;\\n        for(int i = 1; i<n; i++) {\\n            chair++;\\n            while(!temp.empty() && temp.back()[1] <= times[i][0]) {\\n                temp.pop_back();\\n                chair--;\\n            }\\n            if(times[i][2] == targetFriend)\\n                return chair;\\n            \\n            \\n            temp.push_back(times[i]);\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359798,
                "title": "c-solution-map",
                "content": "I finished this question with the logest time. it should be the hardest, lol.\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        map<int, int> cnt;\\n        for(int i = 0; i < times.size(); i++) cnt[i] = 1; //init chairs\\n        for(int i = 0; i < times.size(); i++) {\\n            times[i].push_back(i);\\n        }\\n        sort(times.begin(), times.end());\\n        map<int, vector<int> > leave;\\n        for(int i = 0; i < times.size(); i++) {\\n            for(auto it2 = leave.begin(); it2 != leave.end(); ) {\\n                if(it2->first <= times[i][0]) {\\n                    for(auto x : it2->second)\\n                        cnt[x] = 1; //set chair to be available.\\n                    it2 = leave.erase(it2);\\n                    continue;\\n                }\\n                break;\\n            }\\n            auto it = cnt.begin();\\n            if(times[i][2] == targetFriend) {\\n                return it->first;\\n            }\\n            leave[times[i][1]].push_back(it->first);\\n            cnt.erase(it);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        map<int, int> cnt;\\n        for(int i = 0; i < times.size(); i++) cnt[i] = 1; //init chairs\\n        for(int i = 0; i < times.size(); i++) {\\n            times[i].push_back(i);\\n        }\\n        sort(times.begin(), times.end());\\n        map<int, vector<int> > leave;\\n        for(int i = 0; i < times.size(); i++) {\\n            for(auto it2 = leave.begin(); it2 != leave.end(); ) {\\n                if(it2->first <= times[i][0]) {\\n                    for(auto x : it2->second)\\n                        cnt[x] = 1; //set chair to be available.\\n                    it2 = leave.erase(it2);\\n                    continue;\\n                }\\n                break;\\n            }\\n            auto it = cnt.begin();\\n            if(times[i][2] == targetFriend) {\\n                return it->first;\\n            }\\n            leave[times[i][1]].push_back(it->first);\\n            cnt.erase(it);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359788,
                "title": "c-clean-solution-with-comments-two-min-heaps",
                "content": "```\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        priority_queue<int, vector<int>, greater<int>> chairs;   // chairs hold the available chairs\\n        for (int i = 0; i<10002; i++) chairs.push(i);\\n        \\n        int arrivalTime = times[targetFriend][0]; \\n        map<int, vector<int>> end;//  end[1] holds all chairs that become free on end[0] time;\\n        \\n\\t\\tsort(times.begin(), times.end());// sort by arrival time\\n        priority_queue<int, vector<int>, greater<int>> endinTimes;// this heap holds the ending times encountered so far \\n        \\n        for (auto &time: times){\\n            while (!endinTimes.empty() && endinTimes.top()<=time[0]){// at the arrival of each friend,  free up all the\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//chairs for the people who have left\\n                for (auto &chair: end[endinTimes.top()]) {\\n                    chairs.push(chair);// we make the chairs available again\\n                }\\n                end[endinTimes.top()].clear();\\n                endinTimes.pop();\\n                \\n            }\\n            if (time[0]==arrivalTime){ return chairs.top();} // return the assigned chair\\n            end[time[1]].push_back(chairs.top()); // the top available chair is occupied\\n            endinTimes.push(time[1]); \\n            chairs.pop();\\n        }\\n        return chairs.top();\\n    }\\n```\\n\\t\\n",
                "solutionTags": [],
                "code": "```\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        priority_queue<int, vector<int>, greater<int>> chairs;   // chairs hold the available chairs\\n        for (int i = 0; i<10002; i++) chairs.push(i);\\n        \\n        int arrivalTime = times[targetFriend][0]; \\n        map<int, vector<int>> end;//  end[1] holds all chairs that become free on end[0] time;\\n        \\n\\t\\tsort(times.begin(), times.end());// sort by arrival time\\n        priority_queue<int, vector<int>, greater<int>> endinTimes;// this heap holds the ending times encountered so far \\n        \\n        for (auto &time: times){\\n            while (!endinTimes.empty() && endinTimes.top()<=time[0]){// at the arrival of each friend,  free up all the\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//chairs for the people who have left\\n                for (auto &chair: end[endinTimes.top()]) {\\n                    chairs.push(chair);// we make the chairs available again\\n                }\\n                end[endinTimes.top()].clear();\\n                endinTimes.pop();\\n                \\n            }\\n            if (time[0]==arrivalTime){ return chairs.top();} // return the assigned chair\\n            end[time[1]].push_back(chairs.top()); // the top available chair is occupied\\n            endinTimes.push(time[1]); \\n            chairs.pop();\\n        }\\n        return chairs.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359786,
                "title": "c-solution-with-algorithm-explanation",
                "content": "1. We need to track three information from the given times array, when do people arrive, when they depart and what person is assigned what chair.\\n2. Sort the times array based on arrival.\\n3. For each person in order of arrival, keep on adding them in a min priority queue  `leavingTimeQ` based on their departure.\\n4. Before assigning a chair to this person, we remove the people from `leavingTimeQ` whose departure time was less or equal to current person\\'s arrival time. Get the chair that this person was occupying from `chairOccupied` map, then push this chair to `chairsQ` (implying that this chair is now available to use). \\n5. Then we use the `chairsQ` to find the first available chair.\\n6. If the current idx is equal to target friend, we just return our answer.\\n\\n```\\nstruct Node {\\n    int idx;\\n    int arrivalTime;\\n    int leavingTime;\\n    Node(int i, int a, int l) : idx(i), arrivalTime(a), leavingTime(l) {}; \\n};\\nclass myCompare {\\npublic:\\n    bool operator()(Node& n1, Node& n2) {\\n        return n1.leavingTime > n2.leavingTime;\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool customSort(Node& n1, Node& n2) {\\n        return n1.arrivalTime < n2.arrivalTime;\\n    }\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        vector<Node> timesArray;\\n        for (int i = 0; i < n; ++i) {\\n            timesArray.push_back(Node(i, times[i][0], times[i][1]));\\n        }\\n        \\n        // sort\\n        sort(timesArray.begin(), timesArray.end(), customSort);\\n        \\n        // initialize min pq with chairs available\\n        priority_queue<int, vector<int>, greater<int>> chairsQ;\\n        for (int i = 0; i < n; ++i) chairsQ.push(i);\\n        \\n        priority_queue<Node, vector<Node>, myCompare> leavingTimeQ;\\n        unordered_map<int, int> chairOccupied;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            while (!leavingTimeQ.empty() && leavingTimeQ.top().leavingTime <= timesArray[i].arrivalTime) {\\n                Node n = leavingTimeQ.top();\\n                int chairAvailable = chairOccupied[n.idx];\\n                chairsQ.push(chairAvailable);\\n                leavingTimeQ.pop();\\n            }\\n            int chair = chairsQ.top();\\n            chairOccupied[timesArray[i].idx] = chair;\\n            chairsQ.pop();\\n            leavingTimeQ.push(timesArray[i]);\\n            if (targetFriend == timesArray[i].idx) return chair;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct Node {\\n    int idx;\\n    int arrivalTime;\\n    int leavingTime;\\n    Node(int i, int a, int l) : idx(i), arrivalTime(a), leavingTime(l) {}; \\n};\\nclass myCompare {\\npublic:\\n    bool operator()(Node& n1, Node& n2) {\\n        return n1.leavingTime > n2.leavingTime;\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool customSort(Node& n1, Node& n2) {\\n        return n1.arrivalTime < n2.arrivalTime;\\n    }\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        vector<Node> timesArray;\\n        for (int i = 0; i < n; ++i) {\\n            timesArray.push_back(Node(i, times[i][0], times[i][1]));\\n        }\\n        \\n        // sort\\n        sort(timesArray.begin(), timesArray.end(), customSort);\\n        \\n        // initialize min pq with chairs available\\n        priority_queue<int, vector<int>, greater<int>> chairsQ;\\n        for (int i = 0; i < n; ++i) chairsQ.push(i);\\n        \\n        priority_queue<Node, vector<Node>, myCompare> leavingTimeQ;\\n        unordered_map<int, int> chairOccupied;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            while (!leavingTimeQ.empty() && leavingTimeQ.top().leavingTime <= timesArray[i].arrivalTime) {\\n                Node n = leavingTimeQ.top();\\n                int chairAvailable = chairOccupied[n.idx];\\n                chairsQ.push(chairAvailable);\\n                leavingTimeQ.pop();\\n            }\\n            int chair = chairsQ.top();\\n            chairOccupied[timesArray[i].idx] = chair;\\n            chairsQ.pop();\\n            leavingTimeQ.push(timesArray[i]);\\n            if (targetFriend == timesArray[i].idx) return chair;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359710,
                "title": "java-heap",
                "content": "```\\npublic int smallestChair(int[][] times, int targetFriend) {\\n              \\n        PriorityQueue<Integer> seat = new PriorityQueue<>();\\n        PriorityQueue<int[]> comming = new PriorityQueue<int[]>( (a, b) ->a[1] - b[1]);\\n        PriorityQueue<int[]> leaving = new PriorityQueue<int[]>( (a, b) ->a[0] - b[0]);\\n        for(int i = 0; i < times.length; i++) {\\n            seat.offer(i);\\n            comming.offer(new int[]{i, times[i][0], times[i][1]});            \\n        }\\n                          \\n        int currTime = 0;\\n        while(!comming.isEmpty()) {\\n            int[] currFriend = comming.poll();\\n                       \\n            int friendId = currFriend[0], timeArrive = currFriend[1], timeLeave = currFriend[2];\\n       \\n            while(!leaving.isEmpty() && leaving.peek()[0] <= timeArrive) {\\n                int leavingSeat = leaving.poll()[2];\\n                seat.offer(leavingSeat);\\n            }            \\n            int currSeat = seat.poll();                        \\n            leaving.offer(new int[]{timeLeave, timeArrive, currSeat, friendId});  \\n            if(friendId == targetFriend) return currSeat;    \\n            currTime++;            \\n        }        \\n        return -1;                               \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int smallestChair(int[][] times, int targetFriend) {\\n              \\n        PriorityQueue<Integer> seat = new PriorityQueue<>();\\n        PriorityQueue<int[]> comming = new PriorityQueue<int[]>( (a, b) ->a[1] - b[1]);\\n        PriorityQueue<int[]> leaving = new PriorityQueue<int[]>( (a, b) ->a[0] - b[0]);\\n        for(int i = 0; i < times.length; i++) {\\n            seat.offer(i);\\n            comming.offer(new int[]{i, times[i][0], times[i][1]});            \\n        }\\n                          \\n        int currTime = 0;\\n        while(!comming.isEmpty()) {\\n            int[] currFriend = comming.poll();\\n                       \\n            int friendId = currFriend[0], timeArrive = currFriend[1], timeLeave = currFriend[2];\\n       \\n            while(!leaving.isEmpty() && leaving.peek()[0] <= timeArrive) {\\n                int leavingSeat = leaving.poll()[2];\\n                seat.offer(leavingSeat);\\n            }            \\n            int currSeat = seat.poll();                        \\n            leaving.offer(new int[]{timeLeave, timeArrive, currSeat, friendId});  \\n            if(friendId == targetFriend) return currSeat;    \\n            currTime++;            \\n        }        \\n        return -1;                               \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148339,
                "title": "c",
                "content": "```\\nusing PII = pair< int, int> ;\\n\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size() ;\\n        priority_queue<int, vector<int>, greater<>> empty ;\\n        priority_queue<PII, vector<PII>, greater<>> used ;\\n        for(int i = 0; i < n; i++)\\n            empty.push(i) ;\\n        \\n        for(int i = 0; i < n; i++)\\n            times[i].push_back(i) ;\\n        \\n        sort( times.begin(), times.end() ) ;\\n        \\n        for(auto t : times)\\n        {\\n            int start = t[0] ;\\n            int end = t[1] ;\\n            int ID = t[2] ;\\n            \\n            while(!used.empty() && used.top().first <= start)\\n            {\\n                empty.push(used.top().second ) ;\\n                used.pop() ;\\n            }\\n            \\n            int chair = empty.top() ;\\n            empty.pop() ;\\n            if(targetFriend == ID)\\n                return chair ;\\n            used.push({end, chair}) ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nusing PII = pair< int, int> ;\\n\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size() ;\\n        priority_queue<int, vector<int>, greater<>> empty ;\\n        priority_queue<PII, vector<PII>, greater<>> used ;\\n        for(int i = 0; i < n; i++)\\n            empty.push(i) ;\\n        \\n        for(int i = 0; i < n; i++)\\n            times[i].push_back(i) ;\\n        \\n        sort( times.begin(), times.end() ) ;\\n        \\n        for(auto t : times)\\n        {\\n            int start = t[0] ;\\n            int end = t[1] ;\\n            int ID = t[2] ;\\n            \\n            while(!used.empty() && used.top().first <= start)\\n            {\\n                empty.push(used.top().second ) ;\\n                used.pop() ;\\n            }\\n            \\n            int chair = empty.top() ;\\n            empty.pop() ;\\n            if(targetFriend == ID)\\n                return chair ;\\n            used.push({end, chair}) ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004022,
                "title": "python-simple-8-line-solution-two-minheap-time-o-nlogn",
                "content": "We can have two minheap q1 and q2.\\nq1 is used for tracking the current seats\\nq2 is used for tracking the empty **used** seats\\nWith a new user, we will use the seat in q2 first.\\nIf there is NO empty used seats (**empty q2**),  we will assign a brand-new seats.\\n```\\ndef smallestChair(self, times: List[List[int]], idx: int) -> int:\\n\\tt, q1, q2 = times[idx][0], [], []\\n\\tfor s, e in sorted([[ts, te] for ts, te in times if ts<=t]):\\n\\t\\twhile(q1 and q1[0][0]<=s):\\n\\t\\t\\theappush(q2, heappop(q1)[1])\\n\\t\\tidx = heappop(q2) if q2 else len(q1)\\n\\t\\theappush(q1, [e, idx])\\n\\treturn idx\\n```",
                "solutionTags": [],
                "code": "```\\ndef smallestChair(self, times: List[List[int]], idx: int) -> int:\\n\\tt, q1, q2 = times[idx][0], [], []\\n\\tfor s, e in sorted([[ts, te] for ts, te in times if ts<=t]):\\n\\t\\twhile(q1 and q1[0][0]<=s):\\n\\t\\t\\theappush(q2, heappop(q1)[1])\\n\\t\\tidx = heappop(q2) if q2 else len(q1)\\n\\t\\theappush(q1, [e, idx])\\n\\treturn idx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2237133,
                "title": "c-priority-queue-great-question",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pii;\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int arrivalTime = times[targetFriend][0];\\n        int n = times.size();\\n        priority_queue<int, vector<int>, greater<int>> freeSeats;\\n        priority_queue<pii, vector<pii>, greater<pii>> pq; // {departureTime, seat}\\n        int maxUsedSeat = 0;\\n        sort(times.begin(), times.end());\\n        for(int i = 0; i < n; i++) {\\n            int at = times[i][0];\\n            int dt = times[i][1];\\n            int currSeat;\\n            while(!pq.empty()) {\\n                pii tp = pq.top();\\n                if(tp.first <= at) {\\n                    freeSeats.push(tp.second);\\n                    pq.pop();\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            if(freeSeats.size() > 0) {\\n                currSeat = freeSeats.top();\\n                freeSeats.pop();\\n            } else {\\n                currSeat = maxUsedSeat;\\n                maxUsedSeat++;\\n            }\\n            if(at == arrivalTime) {\\n                return currSeat;\\n            }\\n            pq.push({dt, currSeat});   \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pii;\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int arrivalTime = times[targetFriend][0];\\n        int n = times.size();\\n        priority_queue<int, vector<int>, greater<int>> freeSeats;\\n        priority_queue<pii, vector<pii>, greater<pii>> pq; // {departureTime, seat}\\n        int maxUsedSeat = 0;\\n        sort(times.begin(), times.end());\\n        for(int i = 0; i < n; i++) {\\n            int at = times[i][0];\\n            int dt = times[i][1];\\n            int currSeat;\\n            while(!pq.empty()) {\\n                pii tp = pq.top();\\n                if(tp.first <= at) {\\n                    freeSeats.push(tp.second);\\n                    pq.pop();\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            if(freeSeats.size() > 0) {\\n                currSeat = freeSeats.top();\\n                freeSeats.pop();\\n            } else {\\n                currSeat = maxUsedSeat;\\n                maxUsedSeat++;\\n            }\\n            if(at == arrivalTime) {\\n                return currSeat;\\n            }\\n            pq.push({dt, currSeat});   \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944294,
                "title": "c-priority-queue-set-93",
                "content": "```\\nstruct Info {\\n    int index, arrival, leaving, chair;\\n    Info() {}\\n    Info(int a, int b, int c, int d) : index(a), arrival(b), leaving(c), chair(d) {}\\n    bool operator < (const Info& o) const {\\n        return leaving > o.leaving;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = (int)times.size();\\n        \\n        vector<Info> infoList(n);\\n        for (int i = 0; i < n; i++) infoList[i] = Info(i, times[i][0], times[i][1], -1);\\n\\n        sort(infoList.begin(), infoList.end(), [](Info& a, Info& b) {\\n            return a.arrival < b.arrival;\\n        });\\n        \\n        // for (Info& i : infoList) \\n        //     printf(\"index = %d, start = %d, end = %d, chair = %d\\\\n\", i.index, i.arrival, i.leaving, i.chair);\\n        // cout << \"----\\\\n\";\\n        \\n        \\n        int minimumChairRequired = 0;\\n        int ret = -1;\\n        priority_queue<Info> pq;\\n        set<int> freeChairs;\\n        for (int i = 0; i < n; i++) {\\n            int index = infoList[i].index;\\n            int start = infoList[i].arrival;\\n            int end = infoList[i].leaving;\\n            \\n            while (!pq.empty() && start >= pq.top().leaving) {\\n                int freeChair = pq.top().chair;\\n                freeChairs.insert(freeChair);\\n                pq.pop();\\n            }\\n            \\n            Info info = infoList[i];\\n            if (freeChairs.empty()) {\\n                info.chair = (int)pq.size();\\n            } else {\\n                info.chair = *freeChairs.begin();\\n                freeChairs.erase(freeChairs.begin());\\n            }\\n            pq.push(info);\\n            //printf(\"index = %d, start = %d, end = %d, chair = %d\\\\n\", info.index, info.arrival, info.leaving, info.chair);\\n            \\n            minimumChairRequired = max(minimumChairRequired, (int)pq.size());\\n            \\n            if (index == targetFriend) {\\n                ret = info.chair;\\n                break;\\n            }\\n        }\\n        //printf(\"minimumChairRequired = %d\\\\n\", minimumChairRequired);\\n    \\n        return ret;\\n    }\\n};\\n\\n/**\\n\\nIdea: Question can be asked in a different way. Count Minimum number of chairs required for all friends\\n\\n\\nSort - N lg N\\nNext - N lg N - Each item will be pushed and poped once.\\n\\n**/\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nstruct Info {\\n    int index, arrival, leaving, chair;\\n    Info() {}\\n    Info(int a, int b, int c, int d) : index(a), arrival(b), leaving(c), chair(d) {}\\n    bool operator < (const Info& o) const {\\n        return leaving > o.leaving;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = (int)times.size();\\n        \\n        vector<Info> infoList(n);\\n        for (int i = 0; i < n; i++) infoList[i] = Info(i, times[i][0], times[i][1], -1);\\n\\n        sort(infoList.begin(), infoList.end(), [](Info& a, Info& b) {\\n            return a.arrival < b.arrival;\\n        });\\n        \\n        // for (Info& i : infoList) \\n        //     printf(\"index = %d, start = %d, end = %d, chair = %d\\\\n\", i.index, i.arrival, i.leaving, i.chair);\\n        // cout << \"----\\\\n\";\\n        \\n        \\n        int minimumChairRequired = 0;\\n        int ret = -1;\\n        priority_queue<Info> pq;\\n        set<int> freeChairs;\\n        for (int i = 0; i < n; i++) {\\n            int index = infoList[i].index;\\n            int start = infoList[i].arrival;\\n            int end = infoList[i].leaving;\\n            \\n            while (!pq.empty() && start >= pq.top().leaving) {\\n                int freeChair = pq.top().chair;\\n                freeChairs.insert(freeChair);\\n                pq.pop();\\n            }\\n            \\n            Info info = infoList[i];\\n            if (freeChairs.empty()) {\\n                info.chair = (int)pq.size();\\n            } else {\\n                info.chair = *freeChairs.begin();\\n                freeChairs.erase(freeChairs.begin());\\n            }\\n            pq.push(info);\\n            //printf(\"index = %d, start = %d, end = %d, chair = %d\\\\n\", info.index, info.arrival, info.leaving, info.chair);\\n            \\n            minimumChairRequired = max(minimumChairRequired, (int)pq.size());\\n            \\n            if (index == targetFriend) {\\n                ret = info.chair;\\n                break;\\n            }\\n        }\\n        //printf(\"minimumChairRequired = %d\\\\n\", minimumChairRequired);\\n    \\n        return ret;\\n    }\\n};\\n\\n/**\\n\\nIdea: Question can be asked in a different way. Count Minimum number of chairs required for all friends\\n\\n\\nSort - N lg N\\nNext - N lg N - Each item will be pushed and poped once.\\n\\n**/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1782556,
                "title": "no-brainer-sorting-1-minheap",
                "content": "I went through various top voted solutions. Most of them according to me complicated the logic.\\nLet\\'s keep our idea simple. We will sort an array of timeSlots where each timeSlot is of the format {time,arrival/departure,candidate}.\\n(Arrival : 1, Departure: 0)\\n\\nLet\\'s maintain a min-heap of free seats where we store freed seats after the candidate has departed. \\nTo be specific, when we encounter a timeSlot of departure, we free the seat of that candidate. \\nHow do i know what seat the candidate was using ? Let\\'s keep a map (or array) to track the same.\\nNow when I come across a arrival entry, I have to first look if there is any free seat in the minHeap. If so, use it. If not, let\\'s increment the seatNo and use it.\\n\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<vector<int>> timeSlots;\\n        priority_queue<int,vector<int>, greater<int>> freeSeats;\\n        unordered_map<int,int> seats;\\n        for(int i = 0; i < times.size(); i++){\\n            timeSlots.push_back({times[i][0],1,i});\\n            timeSlots.push_back({times[i][1],0,i});\\n        }\\n        \\n        sort(timeSlots.begin(), timeSlots.end());\\n        int seatNo = 0;\\n        \\n        for(int i = 0; i < timeSlots.size(); i++){\\n            if(timeSlots[i][1] == 1){\\n                if(freeSeats.size() != 0){\\n                    int seat = freeSeats.top();\\n                    freeSeats.pop();\\n                    seats[timeSlots[i][2]] = seat;\\n                } else {\\n                    seats[timeSlots[i][2]] = seatNo;\\n                    seatNo++;\\n                }\\n                if(timeSlots[i][2] == targetFriend){\\n                    return seats[timeSlots[i][2]];\\n                }\\n            } else {\\n                int seat = seats[timeSlots[i][2]];\\n                freeSeats.push(seat);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<vector<int>> timeSlots;\\n        priority_queue<int,vector<int>, greater<int>> freeSeats;\\n        unordered_map<int,int> seats;\\n        for(int i = 0; i < times.size(); i++){\\n            timeSlots.push_back({times[i][0],1,i});\\n            timeSlots.push_back({times[i][1],0,i});\\n        }\\n        \\n        sort(timeSlots.begin(), timeSlots.end());\\n        int seatNo = 0;\\n        \\n        for(int i = 0; i < timeSlots.size(); i++){\\n            if(timeSlots[i][1] == 1){\\n                if(freeSeats.size() != 0){\\n                    int seat = freeSeats.top();\\n                    freeSeats.pop();\\n                    seats[timeSlots[i][2]] = seat;\\n                } else {\\n                    seats[timeSlots[i][2]] = seatNo;\\n                    seatNo++;\\n                }\\n                if(timeSlots[i][2] == targetFriend){\\n                    return seats[timeSlots[i][2]];\\n                }\\n            } else {\\n                int seat = seats[timeSlots[i][2]];\\n                freeSeats.push(seat);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776837,
                "title": "c-faster-than-100-min-heap-properly-explained",
                "content": "```\\ntypedef pair<int, pair<int, int>> PIII;\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        // one for next available chairs\\n        // always get the smallest chair\\n        priority_queue<int, vector<int>, greater<int>> available_chairs;\\n        for (int i=0; i<(int)times.size(); i++) {\\n            available_chairs.push(i);\\n        }\\n        \\n        // one for current occupied chairs\\n        // put the chairs back to the \"available\" chairs queue, \\n        //  if current person\\'s arrive time is > occupied chairs\\' leave time.\\n        priority_queue<PIII, vector<PIII>, greater<PIII>> occupied_chairs;   // <leaving time, <chair, friend>>\\n        \\n        // mark each friend\\n        vector<PIII> f_times;\\n        for (int i=0; i<(int)times.size(); i++) {\\n            // <arrive, <leave, friend>>\\n            f_times.push_back({times[i][0], {times[i][1], i}});\\n        }\\n        // sort by arrival time\\n        sort(f_times.begin(), f_times.end());\\n        \\n        \\n        for (auto t : f_times) {\\n            int arrival = t.first;\\n            int leaving = t.second.first;\\n            int fr = t.second.second;\\n\\n            \\n            while (!occupied_chairs.empty() && occupied_chairs.top().first <= arrival) {\\n\\n                int chair = occupied_chairs.top().second.first; \\n                occupied_chairs.pop();\\n                available_chairs.push(chair);\\n            }\\n            int chair = available_chairs.top(); available_chairs.pop();\\n\\n            PIII occupied_chair = make_pair(leaving, make_pair(chair, fr));\\n            occupied_chairs.push(occupied_chair);\\n            if (fr == targetFriend) {\\n                return occupied_chair.second.first;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int, pair<int, int>> PIII;\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        // one for next available chairs\\n        // always get the smallest chair\\n        priority_queue<int, vector<int>, greater<int>> available_chairs;\\n        for (int i=0; i<(int)times.size(); i++) {\\n            available_chairs.push(i);\\n        }\\n        \\n        // one for current occupied chairs\\n        // put the chairs back to the \"available\" chairs queue, \\n        //  if current person\\'s arrive time is > occupied chairs\\' leave time.\\n        priority_queue<PIII, vector<PIII>, greater<PIII>> occupied_chairs;   // <leaving time, <chair, friend>>\\n        \\n        // mark each friend\\n        vector<PIII> f_times;\\n        for (int i=0; i<(int)times.size(); i++) {\\n            // <arrive, <leave, friend>>\\n            f_times.push_back({times[i][0], {times[i][1], i}});\\n        }\\n        // sort by arrival time\\n        sort(f_times.begin(), f_times.end());\\n        \\n        \\n        for (auto t : f_times) {\\n            int arrival = t.first;\\n            int leaving = t.second.first;\\n            int fr = t.second.second;\\n\\n            \\n            while (!occupied_chairs.empty() && occupied_chairs.top().first <= arrival) {\\n\\n                int chair = occupied_chairs.top().second.first; \\n                occupied_chairs.pop();\\n                available_chairs.push(chair);\\n            }\\n            int chair = available_chairs.top(); available_chairs.pop();\\n\\n            PIII occupied_chair = make_pair(leaving, make_pair(chair, fr));\\n            occupied_chairs.push(occupied_chair);\\n            if (fr == targetFriend) {\\n                return occupied_chair.second.first;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734254,
                "title": "c-priority-queue-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        //vector created to store arrival and departure time of friends along with their numbers(indexex), so that we can sort it according to their arrival time and their indexes are also safe with us.\\n        //choose to use vector<pair<int,pair<int,int>>> over vector<vector<int>> because vector operations are costly in time.\\n        vector<pair<int,pair<int,int>>>v;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int atime = times[i][0]; //arrival time\\n            int dtime = times[i][1]; //departure time\\n            int friendNumber = i;    //friend number(index)\\n            v.push_back({atime,{dtime,i}});   // storing arrival time,departure time and friend number(index)\\n        }\\n        sort(v.begin(),v.end()); //sotred \"v\" vector according to arrival time\\n        \\n        priority_queue<int,vector<int>,greater<int>> chairs; //this will contains all the chairs that are available (least numbered chair at the top)\\n        for(int i = 0 ; i < n; i++)   //since there are only \\'n\\' friends so the chairs utilized would be \\'n\\' too.\\n        {\\n            chairs.push(i);\\n        }\\n        \\n        //this  will contain the chairs that are occupied with departure time as key(friend with least departure time will be at top(min heap))\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            while(!pq.empty() && pq.top().first<=v[i].first) //making sure to put chairs back into available pool of chairs available after a friend leaves before another friend arrives.\\n                //depature time of previous friends <= departure time of current friend\\n                //then that chair is available to be used again.\\n            {\\n                int kursi = pq.top().second;  \\n                chairs.push(kursi);\\n                pq.pop();\\n            }\\n            int friendNumber = v[i].second.second;  //friendnumber of current friend\\n            int atime = v[i].first; //arrival time of current friend\\n            int dtime = v[i].second.first;  //departure time of current friend\\n            if(friendNumber==targetFriend)  //if the current friend coming is the \\'targetFriend\\' then return the current chair at the top of available chairs pool(min heap).\\n                return chairs.top();\\n            pq.push({dtime,chairs.top()}); //chair at the top of available chairs pool is given to the current friend and pushed into unavailable pool of chairs which will only get free when the friend will depart\\n            chairs.pop();  \\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        //vector created to store arrival and departure time of friends along with their numbers(indexex), so that we can sort it according to their arrival time and their indexes are also safe with us.\\n        //choose to use vector<pair<int,pair<int,int>>> over vector<vector<int>> because vector operations are costly in time.\\n        vector<pair<int,pair<int,int>>>v;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int atime = times[i][0]; //arrival time\\n            int dtime = times[i][1]; //departure time\\n            int friendNumber = i;    //friend number(index)\\n            v.push_back({atime,{dtime,i}});   // storing arrival time,departure time and friend number(index)\\n        }\\n        sort(v.begin(),v.end()); //sotred \"v\" vector according to arrival time\\n        \\n        priority_queue<int,vector<int>,greater<int>> chairs; //this will contains all the chairs that are available (least numbered chair at the top)\\n        for(int i = 0 ; i < n; i++)   //since there are only \\'n\\' friends so the chairs utilized would be \\'n\\' too.\\n        {\\n            chairs.push(i);\\n        }\\n        \\n        //this  will contain the chairs that are occupied with departure time as key(friend with least departure time will be at top(min heap))\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            while(!pq.empty() && pq.top().first<=v[i].first) //making sure to put chairs back into available pool of chairs available after a friend leaves before another friend arrives.\\n                //depature time of previous friends <= departure time of current friend\\n                //then that chair is available to be used again.\\n            {\\n                int kursi = pq.top().second;  \\n                chairs.push(kursi);\\n                pq.pop();\\n            }\\n            int friendNumber = v[i].second.second;  //friendnumber of current friend\\n            int atime = v[i].first; //arrival time of current friend\\n            int dtime = v[i].second.first;  //departure time of current friend\\n            if(friendNumber==targetFriend)  //if the current friend coming is the \\'targetFriend\\' then return the current chair at the top of available chairs pool(min heap).\\n                return chairs.top();\\n            pq.push({dtime,chairs.top()}); //chair at the top of available chairs pool is given to the current friend and pushed into unavailable pool of chairs which will only get free when the friend will depart\\n            chairs.pop();  \\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727115,
                "title": "intuitive-o-n-2-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    private class pair implements Comparable<pair>{\\n        int a; //arrival time\\n        int l; // leaving time\\n        int i; // friend number\\n        pair(int a,int l,int i){\\n            this.a=a;\\n            this.l=l;\\n            this.i=i;\\n        }\\n        public int compareTo(pair o){\\n            if(this.a!=o.a){\\n                return this.a-o.a;\\n            }else{\\n                return this.l-o.l;\\n            }\\n        }\\n    }\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int n =times.length;\\n        \\n        pair[] arr= new pair[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]= new pair(times[i][0],times[i][1],i);   // ith index is storing object(arrival time, leaving time , friend Number)\\n        }\\n        Arrays.sort(arr);  // sort on the basis of arrival time\\n        \\n        if( arr[0].i==targetFriend ){\\n            return 0;\\n        }\\n        \\n        ArrayList<pair> list= new ArrayList<>();\\n        list.add(arr[0]);\\n        \\n        for(int i=1;i<n;i++){       // traverse on sorted array\\n            boolean added=false;\\n            for(int j=0;j<list.size();j++){   // check if arr[i]th can occupy any chair from 0 to list.size()-1\\n                \\n                if( arr[i].a >= list.get(j).l ){  // means we can occupy\\n                    \\n                    if(arr[i].i==targetFriend){  // is the friend taking a seat is target friend?\\n                        return j;     //then simply return the seat number\\n                    }\\n                    list.set(j,arr[i]);     // updating list (like now arr[i] friend has taken jth seat)\\n                    added=true;\\n                    break;\\n                }\\n            }\\n            if(!added){     // means if we had failed to occupy any chair from 0 to list.size()-1 \\n                list.add(arr[i]);   // then we have to take list.size()th seat\\n                if(arr[i].i==targetFriend){\\n                    return list.size()-1;\\n                }\\n            }\\n        }\\n        return -1;  // Never gonna execute\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    private class pair implements Comparable<pair>{\\n        int a; //arrival time\\n        int l; // leaving time\\n        int i; // friend number\\n        pair(int a,int l,int i){\\n            this.a=a;\\n            this.l=l;\\n            this.i=i;\\n        }\\n        public int compareTo(pair o){\\n            if(this.a!=o.a){\\n                return this.a-o.a;\\n            }else{\\n                return this.l-o.l;\\n            }\\n        }\\n    }\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int n =times.length;\\n        \\n        pair[] arr= new pair[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]= new pair(times[i][0],times[i][1],i);   // ith index is storing object(arrival time, leaving time , friend Number)\\n        }\\n        Arrays.sort(arr);  // sort on the basis of arrival time\\n        \\n        if( arr[0].i==targetFriend ){\\n            return 0;\\n        }\\n        \\n        ArrayList<pair> list= new ArrayList<>();\\n        list.add(arr[0]);\\n        \\n        for(int i=1;i<n;i++){       // traverse on sorted array\\n            boolean added=false;\\n            for(int j=0;j<list.size();j++){   // check if arr[i]th can occupy any chair from 0 to list.size()-1\\n                \\n                if( arr[i].a >= list.get(j).l ){  // means we can occupy\\n                    \\n                    if(arr[i].i==targetFriend){  // is the friend taking a seat is target friend?\\n                        return j;     //then simply return the seat number\\n                    }\\n                    list.set(j,arr[i]);     // updating list (like now arr[i] friend has taken jth seat)\\n                    added=true;\\n                    break;\\n                }\\n            }\\n            if(!added){     // means if we had failed to occupy any chair from 0 to list.size()-1 \\n                list.add(arr[i]);   // then we have to take list.size()th seat\\n                if(arr[i].i==targetFriend){\\n                    return list.size()-1;\\n                }\\n            }\\n        }\\n        return -1;  // Never gonna execute\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591822,
                "title": "easy-c-heap-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int k) {\\n        \\n        //sort the times based on their arrival times\\n        vector<vector<int>> arr(times.size(),vector<int>(3));\\n        \\n        for(int i=0;i<times.size();i++)\\n        {\\n            arr[i]={times[i][0],times[i][1],i};\\n        }\\n        \\n        //sort\\n        sort(arr.begin(),arr.end());\\n        \\n        \\n        \\n        priority_queue<int,vector<int>,greater<int>> avail;\\n        \\n        using pi=pair<int,int>;\\n        \\n        //min heap\\n        priority_queue<pi,vector<pi>,greater<pi>> booked;\\n        \\n        int currChair=0;\\n        int i=0;\\n        while(arr[i][2]!=k)\\n        {\\n            //check if any seat gets freed for the current time\\n            while(!booked.empty() && booked.top().first <= arr[i][0])\\n            {\\n                auto [time,ch]=booked.top();\\n                booked.pop();\\n                avail.push(ch);\\n            }\\n            if(avail.empty())\\n            {\\n                //use the curr chair\\n                booked.push({arr[i][1],currChair});\\n                currChair++;\\n            }\\n            else{\\n                //use the avail chairs\\n                int ch=avail.top();\\n                avail.pop();\\n                booked.push({arr[i][1],ch});\\n            }\\n            i++;\\n        }\\n         while(!booked.empty() && booked.top().first <= arr[i][0])\\n            {\\n                auto [time,ch]=booked.top();\\n                booked.pop();\\n                avail.push(ch);\\n            }\\n        return (avail.empty()) ? currChair :  avail.top();\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int k) {\\n        \\n        //sort the times based on their arrival times\\n        vector<vector<int>> arr(times.size(),vector<int>(3));\\n        \\n        for(int i=0;i<times.size();i++)\\n        {\\n            arr[i]={times[i][0],times[i][1],i};\\n        }\\n        \\n        //sort\\n        sort(arr.begin(),arr.end());\\n        \\n        \\n        \\n        priority_queue<int,vector<int>,greater<int>> avail;\\n        \\n        using pi=pair<int,int>;\\n        \\n        //min heap\\n        priority_queue<pi,vector<pi>,greater<pi>> booked;\\n        \\n        int currChair=0;\\n        int i=0;\\n        while(arr[i][2]!=k)\\n        {\\n            //check if any seat gets freed for the current time\\n            while(!booked.empty() && booked.top().first <= arr[i][0])\\n            {\\n                auto [time,ch]=booked.top();\\n                booked.pop();\\n                avail.push(ch);\\n            }\\n            if(avail.empty())\\n            {\\n                //use the curr chair\\n                booked.push({arr[i][1],currChair});\\n                currChair++;\\n            }\\n            else{\\n                //use the avail chairs\\n                int ch=avail.top();\\n                avail.pop();\\n                booked.push({arr[i][1],ch});\\n            }\\n            i++;\\n        }\\n         while(!booked.empty() && booked.top().first <= arr[i][0])\\n            {\\n                auto [time,ch]=booked.top();\\n                booked.pop();\\n                avail.push(ch);\\n            }\\n        return (avail.empty()) ? currChair :  avail.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568342,
                "title": "python-heapq-simplest-solution-with-explanation",
                "content": "## Logic:\\n1. We will be using two min heaps, one for available chairs and the other for occupied chairs.\\n2. Every time a new friend arrives, we will see that whether there is/are occupied chairs which can be free now(friend sat/sitting on such chairs has left or is leaving) then we pop these chairs from occupied chairs heap and push into available chairs heap.\\n3. Then we pop the minimum number chair from available chairs heap and assign it to the current arrived friend and push it to occupied chairs heap.\\n4. When the target friend arrives, we assign the applicable chair and return its number.\\n\\n```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        friendsCount = len(times)\\n        targetFriendTime = times[targetFriend]\\n        times.sort(key=lambda x: x[0])\\n        chairs = list(range(friendsCount))\\n        heapq.heapify(chairs)\\n        # occupiedChairs will have values like this: [time till it is occupied, chair number]\\n        occupiedChairs = []\\n        heapq.heapify(occupiedChairs)\\n        for arrival, leaving in times:\\n\\t\\t\\t# Vacate all the occupied chairs which are free by now.\\n            while occupiedChairs and occupiedChairs[0][0] <= arrival:\\n                _, chairAvailable = heapq.heappop(occupiedChairs)\\n                heapq.heappush(chairs, chairAvailable)\\n            smallestChairNumberAvailable = heapq.heappop(chairs)\\n            if arrival == targetFriendTime[0] and leaving == targetFriendTime[1]:\\n                return smallestChairNumberAvailable\\n            else:\\n                heapq.heappush(occupiedChairs, (leaving, smallestChairNumberAvailable))\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        friendsCount = len(times)\\n        targetFriendTime = times[targetFriend]\\n        times.sort(key=lambda x: x[0])\\n        chairs = list(range(friendsCount))\\n        heapq.heapify(chairs)\\n        # occupiedChairs will have values like this: [time till it is occupied, chair number]\\n        occupiedChairs = []\\n        heapq.heapify(occupiedChairs)\\n        for arrival, leaving in times:\\n\\t\\t\\t# Vacate all the occupied chairs which are free by now.\\n            while occupiedChairs and occupiedChairs[0][0] <= arrival:\\n                _, chairAvailable = heapq.heappop(occupiedChairs)\\n                heapq.heappush(chairs, chairAvailable)\\n            smallestChairNumberAvailable = heapq.heappop(chairs)\\n            if arrival == targetFriendTime[0] and leaving == targetFriendTime[1]:\\n                return smallestChairNumberAvailable\\n            else:\\n                heapq.heappush(occupiedChairs, (leaving, smallestChairNumberAvailable))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493301,
                "title": "c-priority-queue-and-map",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int smallestChair(vector<vector<int>>& times, int t) {\\n        \\n        int k=times[t][0];\\n        int n=times.size();\\n        sort(times.begin(),times.end());\\n\\n        priority_queue<int> pq;\\n        map<int,vector<int>> mp;\\n        mp[10000000].push_back(0);\\n        pq.push(0);\\n        int next=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            auto it=mp.begin();\\n            while(it!=mp.end() && it->first<=times[i][0])\\n            {\\n                int time=it->first;\\n                for(auto i: mp[time])\\n                {\\n                    pq.push(-i);\\n                }\\n                mp.erase(it);\\n                it++;\\n            }\\n            if(pq.empty())\\n            {\\n                next++;\\n                pq.push(-next);\\n            }\\n            int chair=-1*pq.top();\\n            pq.pop();\\n            mp[times[i][1]].push_back(chair);\\n            if(times[i][0]==k) return chair;\\n        }\\n        return 0;\\n    }\\n};\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int smallestChair(vector<vector<int>>& times, int t) {\\n        \\n        int k=times[t][0];\\n        int n=times.size();\\n        sort(times.begin(),times.end());\\n\\n        priority_queue<int> pq;\\n        map<int,vector<int>> mp;\\n        mp[10000000].push_back(0);\\n        pq.push(0);\\n        int next=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            auto it=mp.begin();\\n            while(it!=mp.end() && it->first<=times[i][0])\\n            {\\n                int time=it->first;\\n                for(auto i: mp[time])\\n                {\\n                    pq.push(-i);\\n                }\\n                mp.erase(it);\\n                it++;\\n            }\\n            if(pq.empty())\\n            {\\n                next++;\\n                pq.push(-next);\\n            }\\n            int chair=-1*pq.top();\\n            pq.pop();\\n            mp[times[i][1]].push_back(chair);\\n            if(times[i][0]==k) return chair;\\n        }\\n        return 0;\\n    }\\n};\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493287,
                "title": "c-priority-queue",
                "content": "class Solution {\\npublic:\\n     struct compare\\n    {\\n       bool operator()( pair<int,int> p1,  pair<int,int> p2)\\n        {\\n            if(p1.first==p2.first)\\n            {\\n                return p1.second >= p2.second;\\n            }\\n            return p1.first>p2.first;    \\n        }\\n    };\\n       \\n   \\n    int smallestChair(vector<vector<int>>& times, int t) {\\n        map<int,int> mp;\\n        int n=times.size();\\n        vector<int>v=times[t];\\n        \\n        sort(times.begin(),times.end());\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>, compare> pq;\\n        int next=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(pq.size() && pq.top().first<=times[i][0])\\n            {\\n    \\n                 queue<int>q;\\n                while(pq.size() &&pq.top().first<=times[i][0])\\n                {       \\n                     q.push(pq.top().second);\\n                     pq.pop();\\n                } \\n                while(q.size())\\n                {\\n                    pq.push({0,q.front()});\\n                    q.pop();\\n                }\\n                    \\n                pair<int,int>pr=pq.top();\\n                pq.pop();\\n                \\n                if(times[i]==v)\\n                {\\n                    return pr.second;\\n                }\\n                \\n                int x=times[i][1];\\n                pr={x,pr.second};\\n                pq.push(pr);\\n            }\\n            else\\n            {\\n                if(times[i]==v)\\n                {\\n                    return next;\\n                }\\n                pq.push({times[i][1],next++});\\n                \\n            }\\n            \\n        }\\n            return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     struct compare\\n    {\\n       bool operator()( pair<int,int> p1,  pair<int,int> p2)\\n        {\\n            if(p1.first==p2.first)\\n            {\\n                return p1.second >= p2.second;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1379665,
                "title": "simple-java-solution-using-two-minheap-and-one-map",
                "content": "1) Split arrival and depature of a person and add into minHeap. Also make sure depature time of first person and arrival time of second person are some give periority to depature person in the minHeap.\\n2) Put max required chairs also from ther minHeap \\n3) When person come in, pick the chair from available Heap and give to the person.\\n4) When person leaves add back the chair into avalable queue.\\n5) Always track which chair given to which person via allocastedChairs map.\\n\\n```\\n\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        PriorityQueue<Integer> availableCharis = new PriorityQueue<>();\\n        Map<Integer, Integer> allocatedCharis = new HashMap<>();\\n        for (int i = 0; i < times.length; i++) {\\n            queue.add(new int[] { times[i][0], 1, i });\\n            queue.add(new int[] { times[i][1], -1, i });\\n            availableCharis.add(i);\\n        }\\n      \\n        while (!queue.isEmpty()) {\\n            int[] details = queue.poll();\\n            // Upon Arrival, Pick the chair from available queue and put into allocated Map.\\n            if (details[1] == 1) {\\n                if (details[2] == targetFriend) {\\n                    return availableCharis.poll();\\n                }\\n                allocatedCharis.put(details[2], availableCharis.poll());\\n            } else {\\n                // Upon Depature remove the chair from allocated map and added into Available Queue.\\n                int freedChair = allocatedCharis.remove(details[2]);\\n                availableCharis.add(freedChair);\\n            }\\n        }\\n\\n        return availableCharis.peek();\\n   }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        PriorityQueue<Integer> availableCharis = new PriorityQueue<>();\\n        Map<Integer, Integer> allocatedCharis = new HashMap<>();\\n        for (int i = 0; i < times.length; i++) {\\n            queue.add(new int[] { times[i][0], 1, i });\\n            queue.add(new int[] { times[i][1], -1, i });\\n            availableCharis.add(i);\\n        }\\n      \\n        while (!queue.isEmpty()) {\\n            int[] details = queue.poll();\\n            // Upon Arrival, Pick the chair from available queue and put into allocated Map.\\n            if (details[1] == 1) {\\n                if (details[2] == targetFriend) {\\n                    return availableCharis.poll();\\n                }\\n                allocatedCharis.put(details[2], availableCharis.poll());\\n            } else {\\n                // Upon Depature remove the chair from allocated map and added into Available Queue.\\n                int freedChair = allocatedCharis.remove(details[2]);\\n                availableCharis.add(freedChair);\\n            }\\n        }\\n\\n        return availableCharis.peek();\\n   }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374801,
                "title": "a-few-solutions",
                "content": "Use a priority queue `q` to assign each available minimal seat `k` for each `i`<sup>th</sup> arrival time.  And use a map `m` to store each assigned seat `k` in order to process seat departures for each `j`<sup>th</sup> departure time.\\n\\n---\\n\\nFor each time interval `i..j` inclusive of the input array `A`:\\n1. process each `k`<sup>th</sup> seat departure from the `last` arrival time `i` non-inclusive until the current arrival time `i` inclusive\\n2. assign seat `k` and insert `k` into the the map `m` departure `j`<sup>th</sup> time slot\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun smallestChair(A: Array<IntArray>, K: Int): Int {\\n        var N = A.size\\n        var T = A[K][0] // \\uD83C\\uDFAF arrival time of the target friend\\n        A.sortWith(Comparator{ a: IntArray, b: IntArray -> a[0].compareTo(b[0]) })\\n        var q = PriorityQueue<Int>()\\n        for (k in 0 until N)\\n            q.add(k)\\n        var m = mutableMapOf<Int, MutableList<Int>>()\\n        var last = 0\\n        for ((i, j) in A) {\\n            // \\uD83D\\uDEEB process departure(s) (ie. give back all k seats)\\n            while (last <= i)\\n                for (k in m.getOrDefault(last++, mutableListOf()))\\n                    q.add(k)\\n            // \\uD83D\\uDEEC process arrival (ie. assign seat k)\\n            var k = q.poll()\\n            if (i == T)\\n                return k\\n            if (!m.contains(j))\\n                m[j] = mutableListOf<Int>()\\n            m[j]!!.add(k)\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet smallestChair = (A, K, m = new Map()) => {\\n    let N = A.length;\\n    let T = A[K][0]; // \\uD83C\\uDFAF arrival time of the target friend\\n    A.sort((a, b) => a[0] - b[0]);\\n    let q = [];\\n    for (let k of [...Array(N).keys()])\\n        heappush(q, k);\\n    let last = 0;\\n    for (let [i, j] of A) {\\n        // \\uD83D\\uDEEB process departure(s) (ie. give back all k seats)\\n        while (last <= i)\\n            for (let k of m.get(last++) || [])\\n                heappush(q, k);\\n        // \\uD83D\\uDEEC process arrival (ie. assign seat k)\\n        let k = heappop(q);\\n        if (i == T)\\n            return k;\\n        if (!m.has(j))\\n            m.set(j, [])\\n        m.get(j).push(k);\\n    }\\n    return -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def smallestChair(self, A: List[List[int]], K: int) -> int:\\n        N = len(A)\\n        T = A[K][0] # \\uD83C\\uDFAF arrival time of the target friend\\n        A.sort()\\n        q = list(range(N))\\n        m = {}\\n        last = 0\\n        for i, j in A:\\n            # \\uD83D\\uDEEB process departure(s) (ie. give back all k seats)\\n            while last <= i:\\n                for k in m[last] if last in m else []:\\n                    heappush(q, k)\\n                last += 1\\n            # \\uD83D\\uDEEC process arrival (ie. assign seat k)\\n            k = heappop(q)\\n            if i == T:\\n                return k\\n            if j not in m:\\n                m[j] = []\\n            m[j].append(k)\\n        return -1\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, VI>;\\n    using Queue = priority_queue<int, VI, greater<int>>;\\n    int smallestChair(VVI& A, int K, Map m = {}, Queue q = {}) {\\n        auto N = A.size();\\n        auto T = A[K][0]; // \\uD83C\\uDFAF arrival time of the target friend\\n        sort(A.begin(), A.end());\\n        for (auto k{ 0 }; k < N; q.push(k++));\\n        auto last = 0;\\n        for (auto& time: A) {\\n            auto [i, j] = tie(time[0], time[1]);\\n            // \\uD83D\\uDEEB process departure(s) (ie. give back all k seats)\\n            while (last <= i)\\n                for (auto k: m[last++])\\n                    q.push(k);\\n            // \\uD83D\\uDEEC process arrival (ie. assign seat k)\\n            auto k = q.top(); q.pop();\\n            if (i == T)\\n                return k;\\n            m[j].push_back(k);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun smallestChair(A: Array<IntArray>, K: Int): Int {\\n        var N = A.size\\n        var T = A[K][0] // \\uD83C\\uDFAF arrival time of the target friend\\n        A.sortWith(Comparator{ a: IntArray, b: IntArray -> a[0].compareTo(b[0]) })\\n        var q = PriorityQueue<Int>()\\n        for (k in 0 until N)\\n            q.add(k)\\n        var m = mutableMapOf<Int, MutableList<Int>>()\\n        var last = 0\\n        for ((i, j) in A) {\\n            // \\uD83D\\uDEEB process departure(s) (ie. give back all k seats)\\n            while (last <= i)\\n                for (k in m.getOrDefault(last++, mutableListOf()))\\n                    q.add(k)\\n            // \\uD83D\\uDEEC process arrival (ie. assign seat k)\\n            var k = q.poll()\\n            if (i == T)\\n                return k\\n            if (!m.contains(j))\\n                m[j] = mutableListOf<Int>()\\n            m[j]!!.add(k)\\n        }\\n        return -1\\n    }\\n}\\n```\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet smallestChair = (A, K, m = new Map()) => {\\n    let N = A.length;\\n    let T = A[K][0]; // \\uD83C\\uDFAF arrival time of the target friend\\n    A.sort((a, b) => a[0] - b[0]);\\n    let q = [];\\n    for (let k of [...Array(N).keys()])\\n        heappush(q, k);\\n    let last = 0;\\n    for (let [i, j] of A) {\\n        // \\uD83D\\uDEEB process departure(s) (ie. give back all k seats)\\n        while (last <= i)\\n            for (let k of m.get(last++) || [])\\n                heappush(q, k);\\n        // \\uD83D\\uDEEC process arrival (ie. assign seat k)\\n        let k = heappop(q);\\n        if (i == T)\\n            return k;\\n        if (!m.has(j))\\n            m.set(j, [])\\n        m.get(j).push(k);\\n    }\\n    return -1;\\n};\\n```\n```\\nclass Solution:\\n    def smallestChair(self, A: List[List[int]], K: int) -> int:\\n        N = len(A)\\n        T = A[K][0] # \\uD83C\\uDFAF arrival time of the target friend\\n        A.sort()\\n        q = list(range(N))\\n        m = {}\\n        last = 0\\n        for i, j in A:\\n            # \\uD83D\\uDEEB process departure(s) (ie. give back all k seats)\\n            while last <= i:\\n                for k in m[last] if last in m else []:\\n                    heappush(q, k)\\n                last += 1\\n            # \\uD83D\\uDEEC process arrival (ie. assign seat k)\\n            k = heappop(q)\\n            if i == T:\\n                return k\\n            if j not in m:\\n                m[j] = []\\n            m[j].append(k)\\n        return -1\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, VI>;\\n    using Queue = priority_queue<int, VI, greater<int>>;\\n    int smallestChair(VVI& A, int K, Map m = {}, Queue q = {}) {\\n        auto N = A.size();\\n        auto T = A[K][0]; // \\uD83C\\uDFAF arrival time of the target friend\\n        sort(A.begin(), A.end());\\n        for (auto k{ 0 }; k < N; q.push(k++));\\n        auto last = 0;\\n        for (auto& time: A) {\\n            auto [i, j] = tie(time[0], time[1]);\\n            // \\uD83D\\uDEEB process departure(s) (ie. give back all k seats)\\n            while (last <= i)\\n                for (auto k: m[last++])\\n                    q.push(k);\\n            // \\uD83D\\uDEEC process arrival (ie. assign seat k)\\n            auto k = q.top(); q.pop();\\n            if (i == T)\\n                return k;\\n            m[j].push_back(k);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366543,
                "title": "c-map-not-multi-map-solution",
                "content": "Main ideas behind my solution:\\n\\n- augment each element of the `times` vector by adding the friend ID;\\n- sort `times` by order of arrival;\\n- keep track of the occupied seats that will get free at some time in the future in a `map` (`e` in my solution): since multiple seats can get free at the same time, the map value should be `vector<int>`;\\n- keep track of the free seats in a set; the set of free seats is populated in advance;\\n- iterate until reaching the `targetFriend`. At each step of the iteration, insert back into `e` the seats that have become free, then assign the first seat available to the friend.\\n\\nSolution below:\\n\\n```    \\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        set<int> free;\\n        map<int, vector<int>> e;\\n        \\n        int n = times.size();\\n        for (int i = 0; i < n; ++i) {\\n            free.insert(i);\\n            times[i].push_back(i);\\n        }\\n        \\n        sort(times.begin(), times.end(), [](const auto& l, const auto& r) {\\n            return l[0] < r[0];\\n        });\\n        \\n        for (int i = 0; i < n; ++i) {\\n            while (e.size() && e.begin()->first <= times[i][0]) {\\n                for (auto val: e.begin()->second) {\\n                    free.insert(val);\\n                }\\n                e.erase(e.begin());\\n            }\\n            \\n            auto seat = *free.begin();\\n            free.erase(free.begin());\\n            \\n            if (times[i][2] == targetFriend) {return seat;}\\n            e[times[i][1]].push_back(seat);\\n        }\\n                \\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "Main ideas behind my solution:\\n\\n- augment each element of the `times` vector by adding the friend ID;\\n- sort `times` by order of arrival;\\n- keep track of the occupied seats that will get free at some time in the future in a `map` (`e` in my solution): since multiple seats can get free at the same time, the map value should be `vector<int>`;\\n- keep track of the free seats in a set; the set of free seats is populated in advance;\\n- iterate until reaching the `targetFriend`. At each step of the iteration, insert back into `e` the seats that have become free, then assign the first seat available to the friend.\\n\\nSolution below:\\n\\n```    \\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        set<int> free;\\n        map<int, vector<int>> e;\\n        \\n        int n = times.size();\\n        for (int i = 0; i < n; ++i) {\\n            free.insert(i);\\n            times[i].push_back(i);\\n        }\\n        \\n        sort(times.begin(), times.end(), [](const auto& l, const auto& r) {\\n            return l[0] < r[0];\\n        });\\n        \\n        for (int i = 0; i < n; ++i) {\\n            while (e.size() && e.begin()->first <= times[i][0]) {\\n                for (auto val: e.begin()->second) {\\n                    free.insert(val);\\n                }\\n                e.erase(e.begin());\\n            }\\n            \\n            auto seat = *free.begin();\\n            free.erase(free.begin());\\n            \\n            if (times[i][2] == targetFriend) {return seat;}\\n            e[times[i][1]].push_back(seat);\\n        }\\n                \\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1364872,
                "title": "python-3-four-lines",
                "content": "# Explanation\\n\\nWe need to choose the minimum available seat a bunch of times... this screams min-heap.\\n\\nWe also need to keep track of the next friends to leave their seats... also a good use of a min-heap.\\n\\nSo we need 2...\\n* Keep track of available seats.\\n  * If none are available, `len(taken)` will give us the next seat number.\\n* Keep track of the expiring seats.\\n  * While time `seat expiration <= current time`, pop the current expiring seat, and add it to available seats.\\n\\nThen we need to actually seat the friends in order by time.\\n1. Sort the friends, keeping track of their original indexes\\n2. When the current index matches the target friend, short circuit and return the seat number\\n\\nBecause we\\'re always returning inside the loop, we don\\'t need a return at the end of the function.\\n\\nTime: `O(n log n)`, where `n` is `len(times)` \\nSpace: `O(n)`\\n\\n# Code\\n\\n```python\\nclass Solution:\\n  def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n    avail = [] # min heap of (seat_number)\\n    taken = [] # min heap of (expire_time, seat_number)\\n\\n    for (t, end), i in sorted(zip(times, count())):\\n      while taken and taken[0][0] <= t:\\n        heappush(avail, heappop(taken)[1])\\n      seat = heappop(avail) if avail else len(taken)\\n      if i == targetFriend:\\n        return seat\\n      heappush(taken, (end, seat))\\n```\\n\\n# In four lines:\\n\\n```python\\nclass Solution:\\n  def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n    avail, taken = [], []\\n    for (t, end), i in sorted(zip(times, count())):\\n      while taken and taken[0][0] <= t: heappush(avail, heappop(taken)[1])\\n      heappush(taken, (end, seat := heappop(avail) if avail else len(taken)))\\n      if i == targetFriend: return seat\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n    avail = [] # min heap of (seat_number)\\n    taken = [] # min heap of (expire_time, seat_number)\\n\\n    for (t, end), i in sorted(zip(times, count())):\\n      while taken and taken[0][0] <= t:\\n        heappush(avail, heappop(taken)[1])\\n      seat = heappop(avail) if avail else len(taken)\\n      if i == targetFriend:\\n        return seat\\n      heappush(taken, (end, seat))\\n```\n```python\\nclass Solution:\\n  def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n    avail, taken = [], []\\n    for (t, end), i in sorted(zip(times, count())):\\n      while taken and taken[0][0] <= t: heappush(avail, heappop(taken)[1])\\n      heappush(taken, (end, seat := heappop(avail) if avail else len(taken)))\\n      if i == targetFriend: return seat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364655,
                "title": "simplest-intuitive-greedy-solution",
                "content": "Just do what it says:\\n1. make arrival and departure arrays, and sort it.\\n2. Now compare them using two pointer: \\n\\ta. if arrival of one is before departure of other, find an empty seat and seat him. If this was the target, simply return it\\n\\tb. else find where this was seated and vacant the seat\\n\\t\\n\\nCODE:\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<pair<int, int>> arrival;\\n        vector<pair<int, int>> departure;\\n        \\n        for(int i = 0; i<times.size(); i++){\\n            arrival.push_back({times[i][0], i+1});\\n            departure.push_back({times[i][1], i+1});\\n        }\\n        \\n        sort(arrival.begin(), arrival.end());\\n        sort(departure.begin(), departure.end());\\n        \\n        int i = 0, j = 0, n = times.size();\\n        \\n        int seat[10001];\\n        \\n        for(int i = 0; i<10001; i++) seat[i] = 0;\\n        \\n        while(i< n && j< n){\\n            if(arrival[i].first < departure[j].first){\\n                // cout<<\"arrived \"<<arrival[i].second<<\" at \"<<arrival[i].first<<\"\\\\n\"; \\n                for(int k = 0; k<=10000; k++){\\n                    if(!seat[k]){\\n                        seat[k] = arrival[i].second;\\n                        \\n                        \\n                        // cout<<\"seated it at : \"<<k<<\"\\\\n\";\\n                        \\n                        if(arrival[i].second == targetFriend+1){\\n                            return k;\\n                        }\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                // cout<<\"departing \"<<departure[j].second<<\" at \"<<departure[j].first<<\"\\\\n\";\\n                for(int k = 0; k<=10000; k++){\\n                    if(seat[k] == departure[j].second)\\n                    {\\n                        // cout<<\"he was seated at : \"<<k<<\"\\\\n\";\\n                        seat[k] = 0;\\n                        break;\\n                    }\\n                    \\n                }\\n                j++;\\n            }\\n        }\\n        return INT_MAX;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<pair<int, int>> arrival;\\n        vector<pair<int, int>> departure;\\n        \\n        for(int i = 0; i<times.size(); i++){\\n            arrival.push_back({times[i][0], i+1});\\n            departure.push_back({times[i][1], i+1});\\n        }\\n        \\n        sort(arrival.begin(), arrival.end());\\n        sort(departure.begin(), departure.end());\\n        \\n        int i = 0, j = 0, n = times.size();\\n        \\n        int seat[10001];\\n        \\n        for(int i = 0; i<10001; i++) seat[i] = 0;\\n        \\n        while(i< n && j< n){\\n            if(arrival[i].first < departure[j].first){\\n                // cout<<\"arrived \"<<arrival[i].second<<\" at \"<<arrival[i].first<<\"\\\\n\"; \\n                for(int k = 0; k<=10000; k++){\\n                    if(!seat[k]){\\n                        seat[k] = arrival[i].second;\\n                        \\n                        \\n                        // cout<<\"seated it at : \"<<k<<\"\\\\n\";\\n                        \\n                        if(arrival[i].second == targetFriend+1){\\n                            return k;\\n                        }\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                // cout<<\"departing \"<<departure[j].second<<\" at \"<<departure[j].first<<\"\\\\n\";\\n                for(int k = 0; k<=10000; k++){\\n                    if(seat[k] == departure[j].second)\\n                    {\\n                        // cout<<\"he was seated at : \"<<k<<\"\\\\n\";\\n                        seat[k] = 0;\\n                        break;\\n                    }\\n                    \\n                }\\n                j++;\\n            }\\n        }\\n        return INT_MAX;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1364260,
                "title": "java-python-beats-100-short-solution-time-o-nlogn-memory-o-n",
                "content": "<iframe src=\"https://leetcode.com/playground/iiyjrHyT/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Java",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/iiyjrHyT/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1363506,
                "title": "python-two-pointers-approach-faster-than-100",
                "content": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        # since arrival time is unique\\n        arrival_of_friend = times[targetFriend][0]\\n        arriving_time = sorted(times, key=itemgetter(0))\\n        leaving_time = sorted(times, key=itemgetter(1))\\n\\n        arriving_index = 0\\n        leaving_index = 0\\n\\n        # arriving time : index of the chair\\n        occupied_chairs = dict()\\n        chairs = [0] * len(times)\\n\\n        # while the target friend didn\\'t come\\n        while arriving_index < len(arriving_time):\\n\\n            arriving = arriving_time[arriving_index][0]\\n            leaving = leaving_time[leaving_index][1]\\n\\n            if arriving < leaving:\\n                next_empty_seat = chairs.index(0)\\n                chairs[next_empty_seat] = arriving\\n                occupied_chairs[arriving] = next_empty_seat\\n                arriving_index += 1\\n\\n                if arriving == arrival_of_friend:\\n                    return next_empty_seat\\n\\n            else:\\n                arrived = leaving_time[leaving_index][0]\\n                index = chairs.index(arrived)\\n                chairs[index] = 0\\n                occupied_chairs[arrived] = 0\\n                leaving_index += 1\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        # since arrival time is unique\\n        arrival_of_friend = times[targetFriend][0]\\n        arriving_time = sorted(times, key=itemgetter(0))\\n        leaving_time = sorted(times, key=itemgetter(1))\\n\\n        arriving_index = 0\\n        leaving_index = 0\\n\\n        # arriving time : index of the chair\\n        occupied_chairs = dict()\\n        chairs = [0] * len(times)\\n\\n        # while the target friend didn\\'t come\\n        while arriving_index < len(arriving_time):\\n\\n            arriving = arriving_time[arriving_index][0]\\n            leaving = leaving_time[leaving_index][1]\\n\\n            if arriving < leaving:\\n                next_empty_seat = chairs.index(0)\\n                chairs[next_empty_seat] = arriving\\n                occupied_chairs[arriving] = next_empty_seat\\n                arriving_index += 1\\n\\n                if arriving == arrival_of_friend:\\n                    return next_empty_seat\\n\\n            else:\\n                arrived = leaving_time[leaving_index][0]\\n                index = chairs.index(arrived)\\n                chairs[index] = 0\\n                occupied_chairs[arrived] = 0\\n                leaving_index += 1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361991,
                "title": "1942-if-past-friends-leave-on-before-current-arrive-allocate-min-of-those-else-next-available",
                "content": "---\\n\\nIn the contest, could not see properly due to poor variable names :)\\n\\n---\\n\\n**Algo**\\n- **Normal seat allocation**\\n  - Sort everyone by arrival times, as we need to give them seats based on that order\\n  - Give the next seat, starting from `0` to the friends who arrive\\n    - Before giving the next seat\\n      - Check if anyone is leaving on-or-before current friend\\'s arrival time ##\\n        - If so\\n          - let them leave, save their seat numbers into `prev_now_available_again`\\n          - Since they are `prev_now_available_again`, take the least (we need to **sort $$**) and assign to current friend who arrived\\n  - Either you allocated from `prev_now_available_again` or next seat you have, push them to `prev_allocated`, later on, we will use this `prev_allocated`, from which we will check above ## & create `prev_now_available_again`\\n  - Each time we allocate, check if this current firend is same as target friend, if so return this seat that is allocated just now\\n- **Seat allocation using Heap**\\n  - *This implementation is not given below*\\n  - The everytime sort (**sort $$** in the above algo) is very costly (see below **ms** in screenshot below)\\n  - To speed up this, we can use Heap, as we don\\'t need to sort entire collection, we just need the min & remove it\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Normal seat allocation**\\n\\n```\\nvar smallestChair = function (times, targetFriend_j) {\\n    let curr_minAvailable = 0;\\n    let prev_allocated = [];\\n    let prev_now_available_again = [];\\n\\n    times.map((ar__le_times, i) => ar__le_times.push(i));                     // add index of person to arrival & leave times\\n    times.sort((a, b) => a[0] - b[0]);                                        // sort by arrival time\\n\\n    for (let [curr_ar_time, curr_le_time, i] of times) {\\n        if (prev_allocated.length) {\\n            prev_allocated.sort((a, b) => a[0] - b[0]);                       // some are allocated, sort by leave time\\n\\n            // prev_allocated[0][0] is the smallest leave time of any person previously allocated, the first one since sorted\\n            while (prev_allocated.length && prev_allocated[0][0] <= curr_ar_time) {\\n                let [prev_le_time, prev_minAvailable] = prev_allocated[0];    // first one is at  prev_le_time\\n                prev_allocated.shift();                                       // this friend leaving time is before current time - so let friend leave\\n                prev_now_available_again.push(prev_minAvailable);             // prev friend seat is now available - save it to prev_now_available_again\\n            }\\n            if (prev_now_available_again.length) {\\n                // there are some which became available from past, and as they are from past so they are smaller than curr_minAvailable\\n                prev_now_available_again.sort((a, b) => a - b);               // sort them,  allocate min of them, to current arriving friend\\n                let min__prev_minAvailable = prev_now_available_again.shift();\\n\\n                prev_allocated.push([curr_le_time, min__prev_minAvailable]);  // allocate min of them, to current arriving friend i\\n                if (i === targetFriend_j) return min__prev_minAvailable;      // found target, return seat number\\n                continue; // done for current friend, continue for next\\n            }\\n        }\\n\\n        prev_allocated.push([curr_le_time, curr_minAvailable]);               // allocate i with current min available\\n        if (i === targetFriend_j) return curr_minAvailable;                   // found target, return seat number\\n        curr_minAvailable++;\\n    }\\n};\\n```\\n\\n**3352 ms**\\n\\n![image](https://assets.leetcode.com/users/images/1d9642cf-f820-4a08-894f-dc0e91c35100_1627220574.8932834.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar smallestChair = function (times, targetFriend_j) {\\n    let curr_minAvailable = 0;\\n    let prev_allocated = [];\\n    let prev_now_available_again = [];\\n\\n    times.map((ar__le_times, i) => ar__le_times.push(i));                     // add index of person to arrival & leave times\\n    times.sort((a, b) => a[0] - b[0]);                                        // sort by arrival time\\n\\n    for (let [curr_ar_time, curr_le_time, i] of times) {\\n        if (prev_allocated.length) {\\n            prev_allocated.sort((a, b) => a[0] - b[0]);                       // some are allocated, sort by leave time\\n\\n            // prev_allocated[0][0] is the smallest leave time of any person previously allocated, the first one since sorted\\n            while (prev_allocated.length && prev_allocated[0][0] <= curr_ar_time) {\\n                let [prev_le_time, prev_minAvailable] = prev_allocated[0];    // first one is at  prev_le_time\\n                prev_allocated.shift();                                       // this friend leaving time is before current time - so let friend leave\\n                prev_now_available_again.push(prev_minAvailable);             // prev friend seat is now available - save it to prev_now_available_again\\n            }\\n            if (prev_now_available_again.length) {\\n                // there are some which became available from past, and as they are from past so they are smaller than curr_minAvailable\\n                prev_now_available_again.sort((a, b) => a - b);               // sort them,  allocate min of them, to current arriving friend\\n                let min__prev_minAvailable = prev_now_available_again.shift();\\n\\n                prev_allocated.push([curr_le_time, min__prev_minAvailable]);  // allocate min of them, to current arriving friend i\\n                if (i === targetFriend_j) return min__prev_minAvailable;      // found target, return seat number\\n                continue; // done for current friend, continue for next\\n            }\\n        }\\n\\n        prev_allocated.push([curr_le_time, curr_minAvailable]);               // allocate i with current min available\\n        if (i === targetFriend_j) return curr_minAvailable;                   // found target, return seat number\\n        curr_minAvailable++;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1361964,
                "title": "python-heapq-beats-100",
                "content": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        n=len(times)\\n        times=[(a,l,idx) for idx,(a,l) in enumerate(times)]\\n        times.sort()\\n        available=list(range(n)) #available chair no\\n        used=[] #used chair (leaving,index)\\n        heapify(available)\\n        for a,l,i in times:\\n            while used and used[0][0]>=a:\\n                _,idx=heappop(used)\\n                heappush(available,idx)\\n            curr=heappop(available)\\n            if i==targetFriend:\\n                return curr\\n            heappush(used,curr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        n=len(times)\\n        times=[(a,l,idx) for idx,(a,l) in enumerate(times)]\\n        times.sort()\\n        available=list(range(n)) #available chair no\\n        used=[] #used chair (leaving,index)\\n        heapify(available)\\n        for a,l,i in times:\\n            while used and used[0][0]>=a:\\n                _,idx=heappop(used)\\n                heappush(available,idx)\\n            curr=heappop(available)\\n            if i==targetFriend:\\n                return curr\\n            heappush(used,curr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361546,
                "title": "line-sweep-set-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        vector<int> st[100001], en[100001];       //st[i] holds all the friends ariving at time i\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //en[i] holds all the friends leaving at time i\\n        set<int> empty_seats;                           //all seats that are presenlty empty\\n        for(int i=0; i<n; i++) {\\n            st[times[i][0]].push_back(i);\\n            en[times[i][1]].push_back(i);\\n            empty_seats.insert(i);\\n        }\\n        int seatBy[n];\\n        for(int i=1; i<100001; i++) {\\n            for(auto e:en[i]) {\\n                empty_seats.insert(seatBy[e]);                  //if a friend is leaving at time i, insert his taken seat to the empty_seats set\\n            }\\n            for(auto s:st[i]) {\\n                seatBy[s]=*empty_seats.begin();              // if a friend arrives give him the minimum number empty seat\\n                empty_seats.erase(empty_seats.begin()); // and erase that seat from empty_seats\\n            }\\n        }\\n        return seatBy[targetFriend];        // return the seat taken by the targetFriend\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        vector<int> st[100001], en[100001];       //st[i] holds all the friends ariving at time i\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   //en[i] holds all the friends leaving at time i\\n        set<int> empty_seats;                           //all seats that are presenlty empty\\n        for(int i=0; i<n; i++) {\\n            st[times[i][0]].push_back(i);\\n            en[times[i][1]].push_back(i);\\n            empty_seats.insert(i);\\n        }\\n        int seatBy[n];\\n        for(int i=1; i<100001; i++) {\\n            for(auto e:en[i]) {\\n                empty_seats.insert(seatBy[e]);                  //if a friend is leaving at time i, insert his taken seat to the empty_seats set\\n            }\\n            for(auto s:st[i]) {\\n                seatBy[s]=*empty_seats.begin();              // if a friend arrives give him the minimum number empty seat\\n                empty_seats.erase(empty_seats.begin()); // and erase that seat from empty_seats\\n            }\\n        }\\n        return seatBy[targetFriend];        // return the seat taken by the targetFriend\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361228,
                "title": "java-solution-with-explanation",
                "content": "Approach:\\n\\n1. Sort the given input `times` in order of arrival times. In implementation, PersonNode is used to capture arrival and departuretimes along with the sequence number at which the person arrives in given `times` array.\\n2. Use queue to maintain the departure times for person who have been allocated chair.\\n3. Iterate through the personNode sorted list.  For a particular person, check in the queue (mentioned in step 2) that whether it contains any person with departure time lesser than or equal to current person arrival time. Keep popping those persons from the queue until the condition is not satisfied. After popping push the chairs allocated to those persons in a separate queue (freeChairs)\\n4. While allocating a chair to current person, check whether the freeChairs contains any chair. If yes allocate the first chair from that freeChairs queue. Else assign the chair based on the running chair count.\\n5. After allocation enter the current person with its departure time and the chair allocated to the queue in step 2.\\n6. Maintain a map for person to chair allocation. Return the chair allocated to the target from that map.\\n\\n```\\nclass Solution {\\n    \\n    class Node {\\n        int time;\\n        int chair;\\n        Node(int time, int chair) {\\n            this.time = time;\\n            this.chair = chair;\\n        }\\n    }\\n    \\n    class PersonNode {\\n        int aTime;\\n        int dTime;\\n        int person;\\n        PersonNode(int aTime, int dTime, int person) {\\n            this.aTime = aTime;\\n            this.dTime = dTime;\\n            this.person = person;\\n        }\\n    }\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        List<PersonNode> personList = new ArrayList<>();\\n        for (int i = 0; i < times.length; i++) {\\n            personList.add(new PersonNode(times[i][0], times[i][1], i));\\n        }\\n        Collections.sort(personList, (p1, p2) -> p1.aTime - p2.aTime);\\n        Queue<Node> q = new PriorityQueue<Node>((a, b) -> a.time - b.time);\\n        Queue<Integer> freeChairs = new PriorityQueue<>();\\n        Map<Integer, Integer> personToChairPosition = new HashMap<>();\\n        int chair = 0;\\n        for (int i = 0; i < personList.size(); i++) {\\n            PersonNode person = personList.get(i);\\n            while (q.size() != 0 && q.peek().time <= person.aTime) {\\n              freeChairs.add(q.poll().chair);\\n            }\\n            int chairToAllot = 0;\\n            if (freeChairs.size() != 0) {\\n                chairToAllot = freeChairs.poll();\\n            } else {\\n                chairToAllot = chair++;\\n            }\\n            personToChairPosition.put(person.person, chairToAllot);\\n            q.add(new Node(person.dTime, chairToAllot));\\n        }\\n        return personToChairPosition.get(targetFriend);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Node {\\n        int time;\\n        int chair;\\n        Node(int time, int chair) {\\n            this.time = time;\\n            this.chair = chair;\\n        }\\n    }\\n    \\n    class PersonNode {\\n        int aTime;\\n        int dTime;\\n        int person;\\n        PersonNode(int aTime, int dTime, int person) {\\n            this.aTime = aTime;\\n            this.dTime = dTime;\\n            this.person = person;\\n        }\\n    }\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        List<PersonNode> personList = new ArrayList<>();\\n        for (int i = 0; i < times.length; i++) {\\n            personList.add(new PersonNode(times[i][0], times[i][1], i));\\n        }\\n        Collections.sort(personList, (p1, p2) -> p1.aTime - p2.aTime);\\n        Queue<Node> q = new PriorityQueue<Node>((a, b) -> a.time - b.time);\\n        Queue<Integer> freeChairs = new PriorityQueue<>();\\n        Map<Integer, Integer> personToChairPosition = new HashMap<>();\\n        int chair = 0;\\n        for (int i = 0; i < personList.size(); i++) {\\n            PersonNode person = personList.get(i);\\n            while (q.size() != 0 && q.peek().time <= person.aTime) {\\n              freeChairs.add(q.poll().chair);\\n            }\\n            int chairToAllot = 0;\\n            if (freeChairs.size() != 0) {\\n                chairToAllot = freeChairs.poll();\\n            } else {\\n                chairToAllot = chair++;\\n            }\\n            personToChairPosition.put(person.person, chairToAllot);\\n            q.add(new Node(person.dTime, chairToAllot));\\n        }\\n        return personToChairPosition.get(targetFriend);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361101,
                "title": "priority-queue-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int targetArrival = times[targetFriend][0];\\n        sort(times.begin(), times.end());\\n        int maxChair = 0;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        priority_queue <int, vector<int>, greater<int> > unOccupied;\\n        \\n        for(int i=0; i<times.size(); i++){\\n            while(pq.size() && pq.top().first <= times[i][0]){\\n                int val = pq.top().second;\\n                unOccupied.push(val);\\n                pq.pop();\\n            }\\n            int chair = -1;\\n            if(unOccupied.size()){\\n                chair = unOccupied.top();\\n                unOccupied.pop();\\n            }else{\\n                chair = maxChair;\\n                maxChair++;\\n            }\\n            pq.push({times[i][1], chair});\\n            if(targetArrival == times[i][0]){\\n            \\n                return chair;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int targetArrival = times[targetFriend][0];\\n        sort(times.begin(), times.end());\\n        int maxChair = 0;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        priority_queue <int, vector<int>, greater<int> > unOccupied;\\n        \\n        for(int i=0; i<times.size(); i++){\\n            while(pq.size() && pq.top().first <= times[i][0]){\\n                int val = pq.top().second;\\n                unOccupied.push(val);\\n                pq.pop();\\n            }\\n            int chair = -1;\\n            if(unOccupied.size()){\\n                chair = unOccupied.top();\\n                unOccupied.pop();\\n            }else{\\n                chair = maxChair;\\n                maxChair++;\\n            }\\n            pq.push({times[i][1], chair});\\n            if(targetArrival == times[i][0]){\\n            \\n                return chair;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360890,
                "title": "faster-than-100-python",
                "content": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], target: int) -> int:\\n        x,y=times[target]\\n        n=len(times)\\n        new=[]\\n        for i in range(0,n):\\n            heapq.heappush(new,i)\\n        heap=[]\\n        times.sort()\\n        min_heap=[]\\n        #print(times)\\n        \\n        for i,j in times:\\n            #print(heap,i,j)\\n            while(heap and heap[0][0]<=i):\\n                heapq.heappush(new,heapq.heappop(heap)[1])\\n                #heapq.heappop(heap)\\n            mini=heapq.heappop(new)\\n            if i==x and j==y:\\n                if heap==[]:\\n                    return 0\\n                else:\\n                    return mini\\n            heapq.heappush(heap,(j,mini))\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], target: int) -> int:\\n        x,y=times[target]\\n        n=len(times)\\n        new=[]\\n        for i in range(0,n):\\n            heapq.heappush(new,i)\\n        heap=[]\\n        times.sort()\\n        min_heap=[]\\n        #print(times)\\n        \\n        for i,j in times:\\n            #print(heap,i,j)\\n            while(heap and heap[0][0]<=i):\\n                heapq.heappush(new,heapq.heappop(heap)[1])\\n                #heapq.heappop(heap)\\n            mini=heapq.heappop(new)\\n            if i==x and j==y:\\n                if heap==[]:\\n                    return 0\\n                else:\\n                    return mini\\n            heapq.heappush(heap,(j,mini))\\n",
                "codeTag": "Java"
            },
            {
                "id": 1360540,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int SmallestChair(int[][] times, int targetFriend) {\\n        int targetStart = times[targetFriend][0];\\n        Array.Sort(times, (x,y) => x[0] - y[0]);\\n        SortedSet<(int time, int chair)> chairs = new SortedSet<(int time, int chair)>();\\n        SortedSet<int> avail = new SortedSet<int>();\\n        \\n        for(int i = 0; i < times.Length; i++) {\\n            avail.Add(i);\\n        }\\n        \\n        for(int i = 0; i < times.Count(); i++) {\\n            int[] friend = times[i];\\n            \\n            if(chairs.Count() > 0) {\\n                var fc = chairs.First();\\n                while(fc.time <= friend[0]) {\\n                    avail.Add(fc.chair);\\n                    chairs.Remove((fc.time, fc.chair));\\n                    if(chairs.Count() <= 0) break;\\n                    fc = chairs.First();\\n                }\\n            }\\n\\n            if(friend[0] == targetStart) break;\\n\\n            chairs.Add((friend[1], avail.First()));\\n            avail.Remove(avail.First());                    \\n        }\\n        \\n        return avail.First();\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SmallestChair(int[][] times, int targetFriend) {\\n        int targetStart = times[targetFriend][0];\\n        Array.Sort(times, (x,y) => x[0] - y[0]);\\n        SortedSet<(int time, int chair)> chairs = new SortedSet<(int time, int chair)>();\\n        SortedSet<int> avail = new SortedSet<int>();\\n        \\n        for(int i = 0; i < times.Length; i++) {\\n            avail.Add(i);\\n        }\\n        \\n        for(int i = 0; i < times.Count(); i++) {\\n            int[] friend = times[i];\\n            \\n            if(chairs.Count() > 0) {\\n                var fc = chairs.First();\\n                while(fc.time <= friend[0]) {\\n                    avail.Add(fc.chair);\\n                    chairs.Remove((fc.time, fc.chair));\\n                    if(chairs.Count() <= 0) break;\\n                    fc = chairs.First();\\n                }\\n            }\\n\\n            if(friend[0] == targetStart) break;\\n\\n            chairs.Add((friend[1], avail.First()));\\n            avail.Remove(avail.First());                    \\n        }\\n        \\n        return avail.First();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360290,
                "title": "python-100-faster-algorithm-explained-use-of-two-heaps-with-hashmap",
                "content": "**Runtime:  faster than 100.00% of Python3 online submissions for The Number of the Smallest Unoccupied Chair.**\\n\\nThe brute force would have been N^2 which would give TLE as the constraints are 10^4 .\\nNow the Efficient Solution will be .\\nModify time array so as to include the index in it  than Sort the times array according to the arrival time. \\nKeep an counter chair which will increase only when the new friend has nowhere to sit .\\n\\nNow the mose important  part maintain two min heap one will include a tuple of (departure_time,index) say heap1 and other will be for empty seats if there are any in future. and a hashmap to track which friend(index will be sotred in hashmap) got which chair. \\nthis hashmap tells directly which chair got empty after the i friend departed.\\n\\n\\nRun a for loop from 1 to length of times. \\n* \\tCheck if arival time is less than departure time (top element in heap1)\\n\\t\\t\\t\\t1)\\tcheck if empty heap length is 0 if not than directly map this friend index to heappop(empty\\n\\t\\t\\t\\t2)\\telse increase the chair count and map it to index again.\\n\\t\\t\\t\\t3)\\tPush the element into the heap1 with same tuple described before.\\n* \\totherwise arival time is greater than or equal to heap1 top then \\n\\t\\t\\t\\t\\t1)\\tpop will heap1 is not empty and the above condition is staisifed\\n\\t\\t\\t\\t\\t2)  while poping make sure to push the chair into the empty_heap to know which chair can be used .\\n\\t\\t\\t\\t\\t3)  at the end pop from empty_heap and assign it to hashmap .and push this element into heap1\\n\\nfinally return the targetFriend.\\n\\nComplexity :- Time complexity O(nlogn) space Complexity O(n)\\nPS - This is my first post anykind of suggestion are welcome . Upvote if you like it.\\n\\n```\\nfrom heapq import *\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        for i in range(len(times)):\\n            times[i] = times[i]+[i]\\n        times.sort()\\n        chair = 0\\n        hea = [(times[0][1],times[0][2])]\\n        empty = []\\n        d = {times[0][2] : 0}\\n\\n        for i in range(1, len(times)):\\n            if times[i][0] < hea[0][0] :\\n                if len(empty)!=0:\\n                    d[times[i][2]] = heappop(empty)\\n                else:\\n                    chair+=1\\n                    d[times[i][2]] = chair\\n                heappush(hea,(times[i][1],times[i][2]))\\n            else :\\n                while( hea and times[i][0] >= hea[0][0]):\\n                    heappush(empty,d[heappop(hea)[1]])\\n                d[times[i][2]] = heappop(empty)\\n                heappush(hea,(times[i][1],times[i][2]))\\n\\n        return d[targetFriend]```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import *\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        for i in range(len(times)):\\n            times[i] = times[i]+[i]\\n        times.sort()\\n        chair = 0\\n        hea = [(times[0][1],times[0][2])]\\n        empty = []\\n        d = {times[0][2] : 0}\\n\\n        for i in range(1, len(times)):\\n            if times[i][0] < hea[0][0] :\\n                if len(empty)!=0:\\n                    d[times[i][2]] = heappop(empty)\\n                else:\\n                    chair+=1\\n                    d[times[i][2]] = chair\\n                heappush(hea,(times[i][1],times[i][2]))\\n            else :\\n                while( hea and times[i][0] >= hea[0][0]):\\n                    heappush(empty,d[heappop(hea)[1]])\\n                d[times[i][2]] = heappop(empty)\\n                heappush(hea,(times[i][1],times[i][2]))\\n\\n        return d[targetFriend]```",
                "codeTag": "Java"
            },
            {
                "id": 1360146,
                "title": "python-heap-easy-implementation-faster-than-100",
                "content": "The trick I use to solve interval questions is: mark the incoming time with `1` and leaving time with `-1`. Next is simply sort the list by time & process based on whether `time[i]` is incoming/leaving.\\n\\n* Use Min Priority Queue (`free`) to get the lowest available seat.\\n* Assign seats to people in a map(dictionary `d` below):\\n\\nHere is the code:\\n\\n```py\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        a = []\\n        for i,(ti,tl) in enumerate(times):\\n            a.append((ti,1,i))\\n            a.append((tl,-1,i))\\n        \\n        targetTime = times[targetFriend][0]\\n        d = defaultdict()\\n        free = []\\n        seat = 0\\n        for t,val,i in sorted(a):\\n            if val == 1:\\n                #person coming\\n                if free:\\n                    x = heappop(free)\\n                    d[i] = x\\n                else:\\n                    d[i] = seat\\n                    seat += 1\\n                if t == targetTime:\\n                    return d[i]\\n            else:\\n                #person leaving\\n                heappush(free,d[i])\\n```",
                "solutionTags": [],
                "code": "```py\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        a = []\\n        for i,(ti,tl) in enumerate(times):\\n            a.append((ti,1,i))\\n            a.append((tl,-1,i))\\n        \\n        targetTime = times[targetFriend][0]\\n        d = defaultdict()\\n        free = []\\n        seat = 0\\n        for t,val,i in sorted(a):\\n            if val == 1:\\n                #person coming\\n                if free:\\n                    x = heappop(free)\\n                    d[i] = x\\n                else:\\n                    d[i] = seat\\n                    seat += 1\\n                if t == targetTime:\\n                    return d[i]\\n            else:\\n                #person leaving\\n                heappush(free,d[i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360136,
                "title": "c-sort-priority-queue-solution",
                "content": "Runtime: 188 ms, faster than 14.29% of C++ online submissions for The Number of the Smallest Unoccupied Chair.\\nMemory Usage: 51.1 MB, less than 14.29% of C++ online submissions for The Number of the Smallest Unoccupied Chair.\\n\\n```\\n1. Sort the times array based on arrival time\\n2. For each friend\\'s arrival time check if any friend is leaving or already left from the priority queue pQ,\\nif then push their chairs in priority queue of avaialble chair fQ\\n3. Check if any chair is available for new arrived friend and if then assign it to him, otherwise assign a new chair\\n4. Push new friend\\'s departure time and chair pair in the priority queue pQ\\n5. When we reach to our target friend we just return the assigned chair to him\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        \\n        // store the target friend time arrival time\\n        int targetFriendArrivalTime = times[targetFriend][0];\\n        \\n        // sort times array based on arrival time in descending order\\n        sort(times.begin(),times.end());\\n        \\n        // store the already arrived friend\\'s departure time and assigned chair \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pQ;\\n        // store the avaialble chairs from friend who left already\\n        priority_queue<int,vector<int>,greater<int>>fQ;\\n        \\n        // curring chair number\\n        int curr = 0;\\n        \\n        // current assigned chair\\n        int chair;\\n        for(auto &t : times)\\n        {\\n            // check if any friend already left from pQ.top() departure time <= current arrival time\\n            // if then assign the chair number in available chair queue fQ\\n            while(!pQ.empty() && pQ.top().first<=t[0])fQ.push(pQ.top().second),pQ.pop();   \\n            \\n            // if chair available then assign fQ.top() to current friend, otherwise assign new chair\\n            if(fQ.empty())chair=curr,curr++;\\n            else chair = fQ.top(),fQ.pop();\\n\\n            // return assigned chair when target friend found\\n            if(t[0]==targetFriendArrivalTime)return chair;\\n\\n            // store current chair number and friend\\'s deprature time in pQ  \\n            pQ.push(make_pair(t[1],chair));\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n1. Sort the times array based on arrival time\\n2. For each friend\\'s arrival time check if any friend is leaving or already left from the priority queue pQ,\\nif then push their chairs in priority queue of avaialble chair fQ\\n3. Check if any chair is available for new arrived friend and if then assign it to him, otherwise assign a new chair\\n4. Push new friend\\'s departure time and chair pair in the priority queue pQ\\n5. When we reach to our target friend we just return the assigned chair to him\\n```\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        \\n        // store the target friend time arrival time\\n        int targetFriendArrivalTime = times[targetFriend][0];\\n        \\n        // sort times array based on arrival time in descending order\\n        sort(times.begin(),times.end());\\n        \\n        // store the already arrived friend\\'s departure time and assigned chair \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pQ;\\n        // store the avaialble chairs from friend who left already\\n        priority_queue<int,vector<int>,greater<int>>fQ;\\n        \\n        // curring chair number\\n        int curr = 0;\\n        \\n        // current assigned chair\\n        int chair;\\n        for(auto &t : times)\\n        {\\n            // check if any friend already left from pQ.top() departure time <= current arrival time\\n            // if then assign the chair number in available chair queue fQ\\n            while(!pQ.empty() && pQ.top().first<=t[0])fQ.push(pQ.top().second),pQ.pop();   \\n            \\n            // if chair available then assign fQ.top() to current friend, otherwise assign new chair\\n            if(fQ.empty())chair=curr,curr++;\\n            else chair = fQ.top(),fQ.pop();\\n\\n            // return assigned chair when target friend found\\n            if(t[0]==targetFriendArrivalTime)return chair;\\n\\n            // store current chair number and friend\\'s deprature time in pQ  \\n            pQ.push(make_pair(t[1],chair));\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360081,
                "title": "one-min-heap-priority-queue-sorting-easy-to-understand",
                "content": "```\\n int smallestChair(vector<vector<int>>& t, int tf) {\\n        int n= t.size();\\n        int st=t[tf][0];  //arrival time of target friend\\n        vector<vector<int>> a,b; \\n        vector<int> z(n);\\n        for(int i=0;i<n;i++){\\n            a.push_back({t[i][0],i}); //arrival time and indexes\\n            b.push_back({t[i][1],i}); // leaving time and indexes\\n           \\n        }\\n        priority_queue <int, vector<int>, greater<int> > pq;  //min heap\\n        sort(a.begin(),a.end());  //sort wrt arrival time\\n        sort(b.begin(),b.end());  //sort wrt  leaving time\\n     \\n         for(int i=0;i<n;i++)        //push all chair to min heap\\n             pq.push(i);               \\n        \\n        int ch;\\n        int j=0,i,k=0;\\n        \\n          for(i=0;i<=st&&(k<n&&j<n);i++){\\n              while(b[k][0]<=i)\\n                  {\\n                  pq.push(z[b[k][1]]);   //push  unoccupied chair in min heap\\n                  k++;\\n                  \\n              } \\n              if(a[j][0]<=i){\\n                  ch=pq.top();  //smallest chair number  which is unoccupied\\n                  z[a[j][1]]=ch;   //occupied chair\\n                  pq.pop(); \\n                      j++;\\n              }  \\n          }\\n     \\n        return ch;  \\n    }\\n\\n\\n``",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n int smallestChair(vector<vector<int>>& t, int tf) {\\n        int n= t.size();\\n        int st=t[tf][0];  //arrival time of target friend\\n        vector<vector<int>> a,b; \\n        vector<int> z(n);\\n        for(int i=0;i<n;i++){\\n            a.push_back({t[i][0],i}); //arrival time and indexes\\n            b.push_back({t[i][1],i}); // leaving time and indexes\\n           \\n        }\\n        priority_queue <int, vector<int>, greater<int> > pq;  //min heap\\n        sort(a.begin(),a.end());  //sort wrt arrival time\\n        sort(b.begin(),b.end());  //sort wrt  leaving time\\n     \\n         for(int i=0;i<n;i++)        //push all chair to min heap\\n             pq.push(i);               \\n        \\n        int ch;\\n        int j=0,i,k=0;\\n        \\n          for(i=0;i<=st&&(k<n&&j<n);i++){\\n              while(b[k][0]<=i)\\n                  {\\n                  pq.push(z[b[k][1]]);   //push  unoccupied chair in min heap\\n                  k++;\\n                  \\n              } \\n              if(a[j][0]<=i){\\n                  ch=pq.top();  //smallest chair number  which is unoccupied\\n                  z[a[j][1]]=ch;   //occupied chair\\n                  pq.pop(); \\n                      j++;\\n              }  \\n          }\\n     \\n        return ch;  \\n    }\\n\\n\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 1360056,
                "title": "javascript-min-pq-200ms",
                "content": "```\\nconst smallestChair = (times, targetFriend) => {\\n    let pq = new MinPriorityQueue({ priority: x => x[1] }); // [start time, end time, index, chair]\\n    let release = new MinPriorityQueue({ priority: x => x }); // released chair\\n    let a = [];\\n    let i = 0;\\n    for (const [start, end] of times) {\\n        a.push([start, end, i, 0]);\\n        release.enqueue(i);\\n        i++;\\n    }\\n    a.sort((x, y) => x[0] - y[0]);\\n    for (const e of a) {\\n        let cur = e;\\n        while (!pq.isEmpty() && pq.front().element[1] <= cur[0]) { // release chair if end time <= current time\\n            release.enqueue(pq.dequeue().element[3]); // released chair\\n        }\\n        let chair = release.dequeue().element;\\n        if (cur[2] == targetFriend) return chair;\\n        cur[cur.length - 1] = chair;\\n        pq.enqueue(cur);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst smallestChair = (times, targetFriend) => {\\n    let pq = new MinPriorityQueue({ priority: x => x[1] }); // [start time, end time, index, chair]\\n    let release = new MinPriorityQueue({ priority: x => x }); // released chair\\n    let a = [];\\n    let i = 0;\\n    for (const [start, end] of times) {\\n        a.push([start, end, i, 0]);\\n        release.enqueue(i);\\n        i++;\\n    }\\n    a.sort((x, y) => x[0] - y[0]);\\n    for (const e of a) {\\n        let cur = e;\\n        while (!pq.isEmpty() && pq.front().element[1] <= cur[0]) { // release chair if end time <= current time\\n            release.enqueue(pq.dequeue().element[3]); // released chair\\n        }\\n        let chair = release.dequeue().element;\\n        if (cur[2] == targetFriend) return chair;\\n        cur[cur.length - 1] = chair;\\n        pq.enqueue(cur);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359985,
                "title": "python-3-heaps",
                "content": "\\tclass Solution:\\n\\t\\tdef smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n\\t\\t\\tarrivals = []\\n\\t\\t\\tleaving = []\\n\\t\\t\\tseats = []\\n\\t\\t\\tused = {}\\n\\t\\t\\tfor i in range(len(times)):\\n\\t\\t\\t\\theappush(arrivals, (times[i][0], i))\\n\\t\\t\\t\\theappush(leaving, (times[i][1], i))\\n\\t\\t\\t\\theappush(seats, i)        \\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif arrivals[0][0] < leaving[0][0]:\\n\\t\\t\\t\\t\\ti, friend = heappop(arrivals)\\n\\t\\t\\t\\t\\tif friend == targetFriend:\\n\\t\\t\\t\\t\\t\\treturn seats[0]\\n\\t\\t\\t\\t\\tused[friend] = heappop(seats)\\n\\t\\t\\t\\telif arrivals[0][0] >= leaving[0][0]:\\n\\t\\t\\t\\t\\ti, friend = heappop(leaving)\\n\\t\\t\\t\\t\\theappush(seats, used[friend])",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n\\t\\t\\tarrivals = []\\n\\t\\t\\tleaving = []\\n\\t\\t\\tseats = []\\n\\t\\t\\tused = {}",
                "codeTag": "Java"
            },
            {
                "id": 1359980,
                "title": "java-priority-queues-clean-code",
                "content": "inspired by https://leetcode.com/problems/the-number-of-the-smallest-unoccupied-chair/discuss/1359844/Two-Min-Heaps-with-explanation\\n```\\npublic int smallestChair(int[][] times, int targetFriend) {\\n        int targetArrival = times[targetFriend][0]; // only need to keep track of arrival time to stop\\n\\n        PriorityQueue<Integer> freeChairs = IntStream.range(0, times.length).boxed().collect(Collectors.toCollection(PriorityQueue::new));  // generate free chair nums\\n\\n        Comparator<int[]> minFirstComparator = Comparator.comparingInt(t -> t[0]);      // comparing first element\\n        Arrays.sort(times, minFirstComparator);                                         // sort by arrival times\\n        PriorityQueue<int[]> leavingChairs = new PriorityQueue<>(minFirstComparator);   // sort by leaving times\\n\\n        for (int i = 0; i < times.length; i++) {    // go through each times, current time will be each arrival time\\n            while (!leavingChairs.isEmpty() && leavingChairs.peek()[0] <= times[i][0])\\n                freeChairs.offer(leavingChairs.poll()[1]);  // release all chairs that should be free by now\\n            \\n            int[] time = times[i];\\n            int arrival = time[0], leaving = time[1];\\n            \\n            if (arrival == targetArrival)   // found our target friend, simply return smallest available chair\\n                break;\\n\\n            leavingChairs.offer(new int[]{leaving, freeChairs.poll()}); // otherwise, take chair and take note of leaving\\n        }\\n\\n        return freeChairs.peek();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int smallestChair(int[][] times, int targetFriend) {\\n        int targetArrival = times[targetFriend][0]; // only need to keep track of arrival time to stop\\n\\n        PriorityQueue<Integer> freeChairs = IntStream.range(0, times.length).boxed().collect(Collectors.toCollection(PriorityQueue::new));  // generate free chair nums\\n\\n        Comparator<int[]> minFirstComparator = Comparator.comparingInt(t -> t[0]);      // comparing first element\\n        Arrays.sort(times, minFirstComparator);                                         // sort by arrival times\\n        PriorityQueue<int[]> leavingChairs = new PriorityQueue<>(minFirstComparator);   // sort by leaving times\\n\\n        for (int i = 0; i < times.length; i++) {    // go through each times, current time will be each arrival time\\n            while (!leavingChairs.isEmpty() && leavingChairs.peek()[0] <= times[i][0])\\n                freeChairs.offer(leavingChairs.poll()[1]);  // release all chairs that should be free by now\\n            \\n            int[] time = times[i];\\n            int arrival = time[0], leaving = time[1];\\n            \\n            if (arrival == targetArrival)   // found our target friend, simply return smallest available chair\\n                break;\\n\\n            leavingChairs.offer(new int[]{leaving, freeChairs.poll()}); // otherwise, take chair and take note of leaving\\n        }\\n\\n        return freeChairs.peek();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359887,
                "title": "java-minheap-o-nlogn",
                "content": "**Idea:** Use PriorityQueue to keep track of occupied seats, and free seats :)\\n\\n```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        //minQ\\n        PriorityQueue<Integer> free = new PriorityQueue<>();\\n        PriorityQueue<Integer[]> occupied = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        \\n        int n=times.length;\\n        Integer[][] tms = new Integer[n][4];\\n        for(int i=0; i<n; i++){\\n            free.add(i);\\n            tms[i]=new Integer[]{times[i][0],times[i][1],i,0};                                   \\n        }\\n        Arrays.sort(tms,(a,b)->a[0]-b[0]);\\n\\n        \\n        for(int i=0; i<n;i++){\\n            //among occupied I look if one whose time has come to leave needs to free the seat\\n            while(!occupied.isEmpty() && occupied.peek()[1]<=tms[i][0]){\\n                Integer[] arr = occupied.poll();\\n                //to free seats add seat he was sitting on\\n                //remove person from the tabe and add his seat into free pq\\n                free.add(arr[3]);\\n            }\\n            int seat = free.poll();\\n            if(tms[i][2]==targetFriend) return seat;\\n            tms[i][3]=seat;\\n            occupied.add(tms[i]);            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        //minQ\\n        PriorityQueue<Integer> free = new PriorityQueue<>();\\n        PriorityQueue<Integer[]> occupied = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        \\n        int n=times.length;\\n        Integer[][] tms = new Integer[n][4];\\n        for(int i=0; i<n; i++){\\n            free.add(i);\\n            tms[i]=new Integer[]{times[i][0],times[i][1],i,0};                                   \\n        }\\n        Arrays.sort(tms,(a,b)->a[0]-b[0]);\\n\\n        \\n        for(int i=0; i<n;i++){\\n            //among occupied I look if one whose time has come to leave needs to free the seat\\n            while(!occupied.isEmpty() && occupied.peek()[1]<=tms[i][0]){\\n                Integer[] arr = occupied.poll();\\n                //to free seats add seat he was sitting on\\n                //remove person from the tabe and add his seat into free pq\\n                free.add(arr[3]);\\n            }\\n            int seat = free.poll();\\n            if(tms[i][2]==targetFriend) return seat;\\n            tms[i][3]=seat;\\n            occupied.add(tms[i]);            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359885,
                "title": "c-detailed-explanation-sorting-priority-queue",
                "content": "The idea is to process each event in order. \\nSort ```times``` on the basis of\\n1. Time in increasing order\\n2. If the time of two events are the same, the event of someone leaving must come before the event someone arriving. This is to make sure that the person arriving notices that the chair is empty.\\n\\nMaintain a Priority Queue of available chairs. \\n\\nInitially, let the Priority Queue consist of as many chairs as there are guests , ie, ```[0, times.size()]```. Even if all the guests arrived at the same time, they won\\'t need more than that many chairs.\\n\\n1. When a person arrives, the smallest available chair is assigned to the incoming person, and removed from the Priority Queue.\\n1. When a person leaves, the chair that the person was sitting on is inserted into the Priority Queue.\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, pair<int, int>> p1, pair<int, pair<int, int>> p2) {\\n        if (p1.first != p2.first)\\n            return p1.first < p2.first;\\n        return p1.second.second < p2.second.second;\\n    }\\n    \\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n\\t\\n\\t\\t// storing all the events as {time, {index, arriving/leaving}}\\n        vector<pair<int, pair<int, int>>> sortedTimes;\\n        int index = 0;\\n        for (auto v : times) {\\n            sortedTimes.push_back({v[0], {index, 1}});\\n            sortedTimes.push_back({v[1], {index, 0}});\\n            ++index;\\n        }\\n        sort(sortedTimes.begin(), sortedTimes.end(), cmp);\\n\\t\\t\\n\\t\\t// storing chairs assigned to people\\n        vector<int> chairs(times.size());\\n        priority_queue<int> pq;\\n\\t\\t\\n\\t\\t// pushing negatives of the value to maintain Min Heap (default is Max Heap)\\n        for (int i = 0; i < times.size() + 1; ++i)\\n            pq.push(-i);\\n\\t\\t\\t\\n\\t\\t// processing events in order\\n        for (int i = 0; i < sortedTimes.size(); ++i) {\\n\\t\\t\\n\\t\\t\\t// if person is arriving\\n            if (sortedTimes[i].second.second == 1) {\\n                int chair = -pq.top();\\n                pq.pop();\\n                chairs[sortedTimes[i].second.first] = chair;\\n                if (sortedTimes[i].second.first == targetFriend)\\n                    return chair;\\n            } \\n\\t\\t\\t\\n\\t\\t\\t// if person is leaving\\n\\t\\t\\telse {\\n                int chair = chairs[sortedTimes[i].second.first];\\n                pq.push(-chair);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```times```\n```[0, times.size()]```\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, pair<int, int>> p1, pair<int, pair<int, int>> p2) {\\n        if (p1.first != p2.first)\\n            return p1.first < p2.first;\\n        return p1.second.second < p2.second.second;\\n    }\\n    \\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n\\t\\n\\t\\t// storing all the events as {time, {index, arriving/leaving}}\\n        vector<pair<int, pair<int, int>>> sortedTimes;\\n        int index = 0;\\n        for (auto v : times) {\\n            sortedTimes.push_back({v[0], {index, 1}});\\n            sortedTimes.push_back({v[1], {index, 0}});\\n            ++index;\\n        }\\n        sort(sortedTimes.begin(), sortedTimes.end(), cmp);\\n\\t\\t\\n\\t\\t// storing chairs assigned to people\\n        vector<int> chairs(times.size());\\n        priority_queue<int> pq;\\n\\t\\t\\n\\t\\t// pushing negatives of the value to maintain Min Heap (default is Max Heap)\\n        for (int i = 0; i < times.size() + 1; ++i)\\n            pq.push(-i);\\n\\t\\t\\t\\n\\t\\t// processing events in order\\n        for (int i = 0; i < sortedTimes.size(); ++i) {\\n\\t\\t\\n\\t\\t\\t// if person is arriving\\n            if (sortedTimes[i].second.second == 1) {\\n                int chair = -pq.top();\\n                pq.pop();\\n                chairs[sortedTimes[i].second.first] = chair;\\n                if (sortedTimes[i].second.first == targetFriend)\\n                    return chair;\\n            } \\n\\t\\t\\t\\n\\t\\t\\t// if person is leaving\\n\\t\\t\\telse {\\n                int chair = chairs[sortedTimes[i].second.first];\\n                pq.push(-chair);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359863,
                "title": "easy-using-priorityqueue-java",
                "content": "```\\n\\n    public static int smallestChair(int[][] times, int targetFriend) {\\n        HashMap<Long, int[]> map = new HashMap<>();\\n        for (int i = 0; i < times.length; i++) \\n\\t\\t\\tmap.put((long) times[i][0], new int[]{times[i][1], i});\\n        PriorityQueue<int[]> occupiedSeat = new PriorityQueue<>(Comparator.comparingInt(t -> t[0]));\\n        PriorityQueue<Integer> availableSeat = new PriorityQueue<>();\\n        for (int i = 0; i < 10000; i++) availableSeat.add(i);\\n        long time = 0;\\n        while (map.size() != 0) {\\n            time++;\\n            if (!map.containsKey(time)) {\\n\\t\\t\\t\\t// Release Seat that are not used at \"time\" \\n                releaseSeats(occupiedSeat, availableSeat, time);\\n                continue;\\n            }\\n            int[] a = map.get(time);\\n            int leavingTime = a[0];\\n            int curFriend = a[1];\\n            map.remove(time);\\n            releaseSeats(occupiedSeat, availableSeat, time);\\n\\t\\t\\t// return current available seat\\n            if (curFriend == targetFriend) return availableSeat.peek(); \\n            occupiedSeat.add(new int[]{leavingTime, availableSeat.poll()});\\n        }\\n        return -1;\\n    }\\n\\n    private static void releaseSeats(PriorityQueue<int[]> occupiedSeat, PriorityQueue<Integer> availableSeat, long time) {\\n        if (!occupiedSeat.isEmpty()) {\\n            int[] peek = occupiedSeat.peek();\\n            while (!occupiedSeat.isEmpty() && peek[0] == time) {\\n                peek = occupiedSeat.poll();\\n\\t\\t\\t\\t// re-fill the vacant seat\\n                availableSeat.add(peek[1]);\\n                peek = occupiedSeat.peek();\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n    public static int smallestChair(int[][] times, int targetFriend) {\\n        HashMap<Long, int[]> map = new HashMap<>();\\n        for (int i = 0; i < times.length; i++) \\n\\t\\t\\tmap.put((long) times[i][0], new int[]{times[i][1], i});\\n        PriorityQueue<int[]> occupiedSeat = new PriorityQueue<>(Comparator.comparingInt(t -> t[0]));\\n        PriorityQueue<Integer> availableSeat = new PriorityQueue<>();\\n        for (int i = 0; i < 10000; i++) availableSeat.add(i);\\n        long time = 0;\\n        while (map.size() != 0) {\\n            time++;\\n            if (!map.containsKey(time)) {\\n\\t\\t\\t\\t// Release Seat that are not used at \"time\" \\n                releaseSeats(occupiedSeat, availableSeat, time);\\n                continue;\\n            }\\n            int[] a = map.get(time);\\n            int leavingTime = a[0];\\n            int curFriend = a[1];\\n            map.remove(time);\\n            releaseSeats(occupiedSeat, availableSeat, time);\\n\\t\\t\\t// return current available seat\\n            if (curFriend == targetFriend) return availableSeat.peek(); \\n            occupiedSeat.add(new int[]{leavingTime, availableSeat.poll()});\\n        }\\n        return -1;\\n    }\\n\\n    private static void releaseSeats(PriorityQueue<int[]> occupiedSeat, PriorityQueue<Integer> availableSeat, long time) {\\n        if (!occupiedSeat.isEmpty()) {\\n            int[] peek = occupiedSeat.peek();\\n            while (!occupiedSeat.isEmpty() && peek[0] == time) {\\n                peek = occupiedSeat.poll();\\n\\t\\t\\t\\t// re-fill the vacant seat\\n                availableSeat.add(peek[1]);\\n                peek = occupiedSeat.peek();\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359828,
                "title": "priorityqueue-and-pair-class-using-comparator",
                "content": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int n = times.length;\\n        PriorityQueue<Pair> pq= new PriorityQueue<>(new Comp());\\n        for(int i=0;i<n;i++){\\n            pq.add(new Pair(i,times[i]));\\n        }\\n        int ans[] = new int[n];\\n        int chair[] = new int[100001];\\n        while(!pq.isEmpty()){\\n            Pair p = pq.poll();\\n            int index = p.key;\\n            int start = p.arr[0];\\n            int end  = p.arr[1];\\n            for(int i=0;i<=100000;i++){\\n                if(start>=chair[i]){\\n                    chair[i] = end;\\n                    ans[index]=i;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans[targetFriend];   \\n    }\\n    class Comp implements Comparator<Pair>{\\n        public int compare(Pair p,Pair q){\\n            if(p.arr[0]<q.arr[0])\\n                return -1;\\n            else if(p.arr[0]>q.arr[0])\\n                return 1;\\n            else \\n                return 0;\\n        }\\n    }\\n    class Pair{\\n        int key;\\n        int arr[];\\n        Pair(int k,int a[])\\n        {\\n            key = k;\\n            arr = a;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int n = times.length;\\n        PriorityQueue<Pair> pq= new PriorityQueue<>(new Comp());\\n        for(int i=0;i<n;i++){\\n            pq.add(new Pair(i,times[i]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1359804,
                "title": "2-min-heaps-map-explained-c-intuitive",
                "content": "The question is similar to [https://leetcode.com/problems/process-tasks-using-servers](http://) , So similarly we use 2 min heaps ( busy, avail). \\n\\nWe need max of 10^4 seats as no. of freinds <= 10^4, therefore we initialize our avail heap with 10^4 seats.\\nWe tranfer the seat from avail to busy if its get occupied and again tranfer it busy minheap.\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>a, vector<int>b){\\n        \\n        if(a[0]<b[0]){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    \\n    int smallestChair(vector<vector<int>>& times, int tf) {\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>> ,greater<pair<int,int>>>avail, busy;\\n        \\n        int n = times.size();\\n        for(int i=0;i<10000;i++){\\n            \\n            avail.push({0,i});\\n        }\\n        \\n        int start = times[tf][0];\\n        \\n        sort(times.begin(),times.end(),comp);\\n        \\n        unordered_map<int,int>mp;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int en = times[i][0];\\n            int lf = times[i][1];\\n            \\n            while(busy.size() and (busy.top().first<=en || avail.empty())){\\n                \\n                auto it = busy.top();\\n                busy.pop();\\n                \\n                if(it.first<=en){\\n                    \\n                    avail.push({0,it.second});\\n                }\\n                else{\\n                     avail.push({it.first,it.second});\\n                }\\n            }\\n            \\n            auto iit = avail.top();\\n            \\n            avail.pop();\\n            \\n            mp[en] = iit.second;\\n            \\n            busy.push({max(iit.first,en)+lf-en, iit.second});\\n        }\\n        \\n        return mp[start];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>a, vector<int>b){\\n        \\n        if(a[0]<b[0]){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    \\n    int smallestChair(vector<vector<int>>& times, int tf) {\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>> ,greater<pair<int,int>>>avail, busy;\\n        \\n        int n = times.size();\\n        for(int i=0;i<10000;i++){\\n            \\n            avail.push({0,i});\\n        }\\n        \\n        int start = times[tf][0];\\n        \\n        sort(times.begin(),times.end(),comp);\\n        \\n        unordered_map<int,int>mp;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int en = times[i][0];\\n            int lf = times[i][1];\\n            \\n            while(busy.size() and (busy.top().first<=en || avail.empty())){\\n                \\n                auto it = busy.top();\\n                busy.pop();\\n                \\n                if(it.first<=en){\\n                    \\n                    avail.push({0,it.second});\\n                }\\n                else{\\n                     avail.push({it.first,it.second});\\n                }\\n            }\\n            \\n            auto iit = avail.top();\\n            \\n            avail.pop();\\n            \\n            mp[en] = iit.second;\\n            \\n            busy.push({max(iit.first,en)+lf-en, iit.second});\\n        }\\n        \\n        return mp[start];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359801,
                "title": "java-solution-hashing",
                "content": "```\\nimport java.util.*;\\n\\n//import com.sun.org.apache.xml.internal.security.keys.content.RetrievalMethod;\\n\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        \\n    \\tint i,max=0,n=times.length;\\n    \\tMap<Integer,Integer> friend=new HashMap<>(),ret=new HashMap<>();\\n    \\tfor(i=0;i<n;i++)\\n    \\t{\\n    \\t\\tmax=Math.max(max, times[i][0]);\\n    \\t\\tfriend.put(times[i][0], i);\\n    \\t\\tret.put(times[i][0], times[i][1]);\\n    \\t}    \\t\\n    \\tMap<Integer,List<Integer>> map=new HashMap<Integer, List<Integer>>();\\n    \\tPriorityQueue<Integer> pq=new PriorityQueue<>();\\n    \\tint chair=0;\\n    \\tfor(i=1;i<=max;i++)\\n    \\t{\\n    \\t\\tif(map.containsKey(i))\\n    \\t\\t{\\n    \\t\\t\\tfor(Integer ele : map.get(i))\\n    \\t\\t\\t\\tpq.add(ele);\\n    \\t\\t\\tmap.remove(i);\\n    \\t\\t}\\n    \\t\\tif(!friend.containsKey(i))\\n    \\t\\t\\tcontinue;\\n    \\t\\tif(targetFriend==friend.get(i))\\n    \\t\\t{\\n    \\t\\t\\tif(pq.isEmpty())\\n    \\t\\t\\t\\treturn chair;\\n    \\t\\t\\treturn pq.peek();\\n    \\t\\t}\\n    \\t\\tList<Integer> list;\\n    \\t\\tlist=map.getOrDefault(ret.get(i), new ArrayList<>());\\n    \\t\\tif(pq.isEmpty())\\n    \\t\\t\\tlist.add(chair);\\n    \\t\\telse \\n\\t\\t\\t\\tlist.add(pq.poll());\\n    \\t\\tmap.put(ret.get(i), list);\\n    \\t\\tchair++;\\n    \\t}\\n    \\treturn 0;\\n    }\\n}\\n```\\n\\nAny Questions???",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\n//import com.sun.org.apache.xml.internal.security.keys.content.RetrievalMethod;\\n\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        \\n    \\tint i,max=0,n=times.length;\\n    \\tMap<Integer,Integer> friend=new HashMap<>(),ret=new HashMap<>();\\n    \\tfor(i=0;i<n;i++)\\n    \\t{\\n    \\t\\tmax=Math.max(max, times[i][0]);\\n    \\t\\tfriend.put(times[i][0], i);\\n    \\t\\tret.put(times[i][0], times[i][1]);\\n    \\t}    \\t\\n    \\tMap<Integer,List<Integer>> map=new HashMap<Integer, List<Integer>>();\\n    \\tPriorityQueue<Integer> pq=new PriorityQueue<>();\\n    \\tint chair=0;\\n    \\tfor(i=1;i<=max;i++)\\n    \\t{\\n    \\t\\tif(map.containsKey(i))\\n    \\t\\t{\\n    \\t\\t\\tfor(Integer ele : map.get(i))\\n    \\t\\t\\t\\tpq.add(ele);\\n    \\t\\t\\tmap.remove(i);\\n    \\t\\t}\\n    \\t\\tif(!friend.containsKey(i))\\n    \\t\\t\\tcontinue;\\n    \\t\\tif(targetFriend==friend.get(i))\\n    \\t\\t{\\n    \\t\\t\\tif(pq.isEmpty())\\n    \\t\\t\\t\\treturn chair;\\n    \\t\\t\\treturn pq.peek();\\n    \\t\\t}\\n    \\t\\tList<Integer> list;\\n    \\t\\tlist=map.getOrDefault(ret.get(i), new ArrayList<>());\\n    \\t\\tif(pq.isEmpty())\\n    \\t\\t\\tlist.add(chair);\\n    \\t\\telse \\n\\t\\t\\t\\tlist.add(pq.poll());\\n    \\t\\tmap.put(ret.get(i), list);\\n    \\t\\tchair++;\\n    \\t}\\n    \\treturn 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359789,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        unordered_map<int, int> umap;\\n        unordered_map<int, vector<int>> used;\\n        int high = 0, n = times.size();\\n        for (int i = 0; i < n; i++) {\\n            umap[times[i][0]] = i;\\n            high = max(high, times[i][1]);\\n        }\\n        priority_queue<int, vector<int>, greater<int>> available;\\n        \\n        for (int i = 0; i <= high; i++) {\\n            available.push(i);\\n        }\\n        \\n        for (int t = 0; t <= high; t++) {\\n            if (used.count(t)) {\\n                for (int i :used[t]) {\\n                    available.push(i);\\n                }\\n            }\\n            \\n            if (umap.count(t) && umap[t] == targetFriend) {\\n                return available.top();\\n            }\\n            if (umap.count(t)) {\\n                int end = times[umap[t]][1];\\n                used[end].push_back(available.top());\\n                available.pop();\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        unordered_map<int, int> umap;\\n        unordered_map<int, vector<int>> used;\\n        int high = 0, n = times.size();\\n        for (int i = 0; i < n; i++) {\\n            umap[times[i][0]] = i;\\n            high = max(high, times[i][1]);\\n        }\\n        priority_queue<int, vector<int>, greater<int>> available;\\n        \\n        for (int i = 0; i <= high; i++) {\\n            available.push(i);\\n        }\\n        \\n        for (int t = 0; t <= high; t++) {\\n            if (used.count(t)) {\\n                for (int i :used[t]) {\\n                    available.push(i);\\n                }\\n            }\\n            \\n            if (umap.count(t) && umap[t] == targetFriend) {\\n                return available.top();\\n            }\\n            if (umap.count(t)) {\\n                int end = times[umap[t]][1];\\n                used[end].push_back(available.top());\\n                available.pop();\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359770,
                "title": "simple-java-solution-with-priority-queues",
                "content": "\\nIntuition: \\n1. Sort the times on arrival time.\\n1. store your Person Of Interest (poi) : targetFriend\\n1. Use one heap to store the possible free chairs, keep it sorted, smallest on top!. \\n1. Keep another heap called used, to keep track of used chairs. This pq keeps track if which chair is busy till what time (until the person occupying this chair leaves).\\n1. Keep a counter that starts from 0 and goes till last person leaves. Remember to pop the second queue when its time for a person to free a chair. \\n1. Keep the the for loop going until the POI arrives and you assign a chair to him/her.\\n\\nHappy coding!\\n\\nclass Solution {\\n\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int poi=times[targetFriend][0];\\n\\t\\t// Sort times on arrival time.\\n        Arrays.sort(times, (a, b)-> (a[0]-b[0]));\\n\\t\\t// This queue keeps all free chairs\\n        PriorityQueue<Integer> free=new PriorityQueue<>();\\n\\t\\t// This queue keeps all occupied chairs, until the person leaves.\\n        PriorityQueue<int[]> used = new PriorityQueue<>((a, b) -> (a[1]-b[1]));\\n        for(int i=0;i<100010;i++){ // fill up free queue with available chairs\\n            free.offer(i);\\n        }\\n        int counter=0;\\n        int ans=0;\\n        int i=0;\\n        while(counter<=times[times.length-1][1] && i< times.length){\\n            while(!used.isEmpty() && used.peek()[1]<=counter){ // first recover all unused chairs\\n                int[] top=used.poll();\\n                free.offer(top[0]);\\n            }\\n            int chair=free.poll();\\n            if(times[i][0]==poi){\\n                return chair;\\n            }\\n            used.offer(new int[]{chair, times[i][1]});\\n            if(i<times.length-1)\\n                counter=times[i+1][0];\\n            else\\n                counter++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int poi=times[targetFriend][0];\\n\\t\\t// Sort times on arrival time.\\n        Arrays.sort(times, (a, b)-> (a[0]-b[0]));\\n\\t\\t// This queue keeps all free chairs\\n        PriorityQueue<Integer> free=new PriorityQueue<>();\\n\\t\\t// This queue keeps all occupied chairs, until the person leaves.\\n        PriorityQueue<int[]> used = new PriorityQueue<>((a, b) -> (a[1]-b[1]));\\n        for(int i=0;i<100010;i++){ // fill up free queue with available chairs\\n            free.offer(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1359764,
                "title": "easy-to-read-min-heap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int t) {\\n        int arrival = times[t][0];\\n        sort(times.begin(), times.end());\\n        set<int> avilableSeats;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int newSeat = 0;\\n        int result;\\n        for(int i=0; i<times.size(); i++) {\\n            int seat=-1;\\n            while(!pq.empty() && pq.top().first <= times[i][0]) {\\n                seat = pq.top().second;\\n                pq.pop();\\n                avilableSeats.insert(seat);\\n            }\\n            if(avilableSeats.size() > 0) {\\n                seat = *(avilableSeats.begin());\\n                avilableSeats.erase(seat);\\n            }\\n            else {\\n                seat = newSeat++;\\n            }\\n            pq.push({times[i][1], seat});\\n            if(times[i][0] == arrival) {\\n                result = seat;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int t) {\\n        int arrival = times[t][0];\\n        sort(times.begin(), times.end());\\n        set<int> avilableSeats;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int newSeat = 0;\\n        int result;\\n        for(int i=0; i<times.size(); i++) {\\n            int seat=-1;\\n            while(!pq.empty() && pq.top().first <= times[i][0]) {\\n                seat = pq.top().second;\\n                pq.pop();\\n                avilableSeats.insert(seat);\\n            }\\n            if(avilableSeats.size() > 0) {\\n                seat = *(avilableSeats.begin());\\n                avilableSeats.erase(seat);\\n            }\\n            else {\\n                seat = newSeat++;\\n            }\\n            pq.push({times[i][1], seat});\\n            if(times[i][0] == arrival) {\\n                result = seat;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359746,
                "title": "c-1942-the-number-of-the-smallest-unoccupied-chair",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<vector<int>> vals; \\n        for (int i = 0; i < times.size(); ++i) {\\n            vals.push_back({times[i][0], 1, i}); \\n            vals.push_back({times[i][1], 0, i}); \\n        }\\n        sort(vals.begin(), vals.end()); \\n        \\n        int k = 0; \\n        priority_queue<int, vector<int>, greater<>> pq; \\n        unordered_map<int, int> mp; \\n        \\n        for (auto& val : vals) {\\n            int i = val[2], s = 0; \\n            if (val[1]) {\\n                if (pq.size()) {\\n                    s = pq.top(); pq.pop(); \\n                } else \\n                    s = k++; \\n                if (i == targetFriend) return s; \\n                mp[i] = s; \\n            } else \\n                pq.push(mp[i]); \\n        }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<vector<int>> vals; \\n        for (int i = 0; i < times.size(); ++i) {\\n            vals.push_back({times[i][0], 1, i}); \\n            vals.push_back({times[i][1], 0, i}); \\n        }\\n        sort(vals.begin(), vals.end()); \\n        \\n        int k = 0; \\n        priority_queue<int, vector<int>, greater<>> pq; \\n        unordered_map<int, int> mp; \\n        \\n        for (auto& val : vals) {\\n            int i = val[2], s = 0; \\n            if (val[1]) {\\n                if (pq.size()) {\\n                    s = pq.top(); pq.pop(); \\n                } else \\n                    s = k++; \\n                if (i == targetFriend) return s; \\n                mp[i] = s; \\n            } else \\n                pq.push(mp[i]); \\n        }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359693,
                "title": "c-binary-search-o-nlogn-o-n",
                "content": "I first put all students in a set, then find:\\n- The students sitting at chair 0\\n- The students sitting at chair 1\\n- The students sitting at chair 2\\n- ......\\n\\nthen erase them in the set until find the answer student\\n```\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        pair<int,int> t = {times[targetFriend][0],times[targetFriend][1]};\\n        set<pair<int,int>> set;\\n        for(auto x : times)\\n            set.insert({x[0],x[1]});\\n        int chair = 0;\\n        for(auto its : set){\\n            if(its == t) return chair;\\n            pair<int,int> tmp = its;\\n            while(1){\\n                auto it = set.lower_bound({tmp.second,0});\\n                if(it==set.end()) break;\\n                if(*it == t) return chair;\\n                tmp = *it;\\n                set.erase(it);\\n            }\\n            ++chair;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        pair<int,int> t = {times[targetFriend][0],times[targetFriend][1]};\\n        set<pair<int,int>> set;\\n        for(auto x : times)\\n            set.insert({x[0],x[1]});\\n        int chair = 0;\\n        for(auto its : set){\\n            if(its == t) return chair;\\n            pair<int,int> tmp = its;\\n            while(1){\\n                auto it = set.lower_bound({tmp.second,0});\\n                if(it==set.end()) break;\\n                if(*it == t) return chair;\\n                tmp = *it;\\n                set.erase(it);\\n            }\\n            ++chair;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023521,
                "title": "easiest-line-by-line-explanation-of-code",
                "content": "# Intuition :- Since chairs need to be sorted in increasing order of their arrival time, therefore priority_queue can be applied.\\n\\n\\n\\n# Approach :- Each chair can have either of the two states, available or notAvailable.\\n\\nIn order to represent ***available*** chairs only one parameter i.e. chair_index is sufficient.\\n\\nHowever, for ***notAvailable*** chairs, we must mention departure time and chair_index both. Departure time would help us to know when that particular chair would be vacant. \\n\\nI have broken down this code into several steps:-\\n\\n**Step 1.**  ->Declare a dummy variable int t_friend that would contain times.\\ntimes[arrival][departure] - arrival would depend upon targetFriend, and we have initialised departure with 0;\\n\\nint t_friend = times[targetFriend][0];\\n\\n-> Form two priority_queues for ***available*** and ***notAvailable*** respectively.\\nnotAvailable - 2 parameters, therefore pair<int, int> is used. \\ndepartureTime -  first\\nchair_index - second\\n\\npriorirty queue likhne ka tareeka :-\\npriority_queue<int, vector< int >, greater< int >> available;\\npriority_queue<pair<int, int>, vector<pair<int< int>>, greater<pair<int, int>>> notAvailable;\\n\\n**Step 2.** -> Sort times[arrival][leaving] in order of arrival time.\\nsort(times.begin(), times.end());\\n\\n**Step 3.** -> Traverse into times\\n(Shift chairs from ***notAvailable*** to ***available***) if there contains any chair in notAvailable such that it would be freed before the arrival of targetFriend.\\n\\nwhile(!notAvailable.empty() && notAvailable.top().first<= t[0] ){\\n    available.push(notAvailable.top().second); *// pushed that chair_index into available //*\\n    notAvailable.pop();\\n}\\n\\n**Step 4.** -> if targetFriend has arrived then break from the loop\\nif(t[0] == t_friend) break;\\n\\n-> (Shift chairs from ***Available*** to ***notAvailable***)\\nIf available chair is empty that means all chairs are unavailable.\\nif(available.empty()){\\n    notAvailable.push({t[1], notAvailable.size()})\\n}\\n\\nelse push first chair that was to be occupied into notAvailable\\n\\nelse{\\nnotAvailable.push({t[1], available.top()});\\navailable.pop();\\n}\\n\\n**Step 5.** -> Return as per step 4.\\n\\nreturn available.empty() ? notAvailable.size() : available.top();\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\no(n) - for two priority_queues\\n\\n# Code\\n```\\n#include<vector>\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int t_friend = times[targetFriend][0];\\n        int n = times.size();\\n\\n        priority_queue<int, vector<int>, greater<int>> available;\\n        priority_queue<pair<int,int>, vector<pair<int, int>>, greater<pair<int, int>>> notAvailable;\\n\\n        sort(times.begin(), times.end());\\n\\n        for(auto &t : times){\\n            while(!notAvailable.empty() && notAvailable.top().first<= t[0]){\\n                available.push(notAvailable.top().second);\\n                notAvailable.pop();\\n            }\\n\\n            if(t[0] == t_friend) break;\\n\\n            if(available.empty()){\\n                notAvailable.push({t[1], notAvailable.size()});\\n            }\\n\\n            else{\\n                notAvailable.push({t[1], available.top()});\\n                available.pop();\\n            }\\n        }\\n\\n        return available.empty() ? notAvailable.size() : available.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#include<vector>\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int t_friend = times[targetFriend][0];\\n        int n = times.size();\\n\\n        priority_queue<int, vector<int>, greater<int>> available;\\n        priority_queue<pair<int,int>, vector<pair<int, int>>, greater<pair<int, int>>> notAvailable;\\n\\n        sort(times.begin(), times.end());\\n\\n        for(auto &t : times){\\n            while(!notAvailable.empty() && notAvailable.top().first<= t[0]){\\n                available.push(notAvailable.top().second);\\n                notAvailable.pop();\\n            }\\n\\n            if(t[0] == t_friend) break;\\n\\n            if(available.empty()){\\n                notAvailable.push({t[1], notAvailable.size()});\\n            }\\n\\n            else{\\n                notAvailable.push({t[1], available.top()});\\n                available.pop();\\n            }\\n        }\\n\\n        return available.empty() ? notAvailable.size() : available.top();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3964928,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SmallestChair(int[][] times, int targetFriend) {\\n        var list = new List<(int, int, int)>();\\n        var unoccupiedChairPq = new PriorityQueue<int, int>();\\n        var occupiedChairPq = new PriorityQueue<(int, int), int>();\\n\\n        for (int i = 0; i < times.GetLength(0); i++)\\n            list.Add((i, times[i][0], times[i][1]));\\n\\n        list.Sort((a, b) => {\\n            return a.Item2.CompareTo(b.Item2);\\n        });\\n\\n        for (int i = 0; i < list.Count; i++) {\\n            while (occupiedChairPq.Count > 0 && occupiedChairPq.Peek().Item2 <= list[i].Item2) {\\n                var temp = occupiedChairPq.Dequeue();\\n                unoccupiedChairPq.Enqueue(temp.Item1, temp.Item1);\\n            }\\n\\n            var nextChair =  unoccupiedChairPq.Count > 0 ? unoccupiedChairPq.Dequeue() : occupiedChairPq.Count;   \\n\\n            if (list[i].Item1 == targetFriend)\\n                return nextChair;\\n\\n            occupiedChairPq.Enqueue((nextChair, list[i].Item3), list[i].Item3);\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int SmallestChair(int[][] times, int targetFriend) {\\n        var list = new List<(int, int, int)>();\\n        var unoccupiedChairPq = new PriorityQueue<int, int>();\\n        var occupiedChairPq = new PriorityQueue<(int, int), int>();\\n\\n        for (int i = 0; i < times.GetLength(0); i++)\\n            list.Add((i, times[i][0], times[i][1]));\\n\\n        list.Sort((a, b) => {\\n            return a.Item2.CompareTo(b.Item2);\\n        });\\n\\n        for (int i = 0; i < list.Count; i++) {\\n            while (occupiedChairPq.Count > 0 && occupiedChairPq.Peek().Item2 <= list[i].Item2) {\\n                var temp = occupiedChairPq.Dequeue();\\n                unoccupiedChairPq.Enqueue(temp.Item1, temp.Item1);\\n            }\\n\\n            var nextChair =  unoccupiedChairPq.Count > 0 ? unoccupiedChairPq.Dequeue() : occupiedChairPq.Count;   \\n\\n            if (list[i].Item1 == targetFriend)\\n                return nextChair;\\n\\n            occupiedChairPq.Enqueue((nextChair, list[i].Item3), list[i].Item3);\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946486,
                "title": "143ms-100-space-100-speed-two-heap-solution-good-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe given space is 10^4. so this must be a O(n) or O(logn) solution\\n\\nand we need to\\n1. simulate the entering of guests --- guests entering in order of the entrance time, when the guest arriving, find all the guests that have passed leave time and evict them\\n2. simulate the possession of seats ---- when a guest entering, locate the smallest empty seat for him\\n\\nlikely we need to loop through all the guests, so both step 1 and step 2 would happen n times respectively. so each operation can only take O(logN)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. guests entering in order of the entrance time --- sort the times array based on arriving time, then loop ---> O(NlogN)\\n2. when the guest arriving, find all the guests that have passed leave time and evict them \\nHeap should come to the mind ----\\nthis heap should be min heap based on the leaving time.\\nwhenever a guest is entering, pop all the elements in the heap that is smaller than the incoming guest arrival time, then push the guest into the heap\\n\\nhowever, we still need to locate the smallest seat for the guest\\n\\nya, it is another min heap ----- we preload all seat that can possibly be seated --- 0 to the size of the guests\\n\\nthen whenever a guest arrives, he takes the top seat in the heap\\n\\nwhen he being evicted, return his seat to the heap\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N * logN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n//11:14\\n\\nimport (\\n        \"container/heap\"\\n        \"fmt\"\\n)\\n\\n// An IntHeap is a min-heap of ints.\\ntype IntHeap [][]int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i][1] < h[j][1] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n    *h = append(*h, x.([]int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n    old := *h\\n    n := len(old)\\n    x := old[n-1]\\n    *h = old[0 : n-1]\\n    return x\\n}\\n\\ntype IHeap []int\\n\\nfunc (h IHeap) Len() int           { return len(h) }\\nfunc (h IHeap) Less(i, j int) bool { return h[i] < h[j] }\\nfunc (h IHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IHeap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *IHeap) Pop() interface{} {\\n    old := *h\\n    n := len(old)\\n    x := old[n-1]\\n    *h = old[0 : n-1]\\n    return x\\n}\\n\\nfunc smallestChair(times [][]int, targetFriend int) int {\\n    if len(times) == 0 {\\n        return 0\\n    }\\n\\n    h := &IntHeap{}\\n    seat := &IHeap{}\\n    \\n    heap.Init(h)\\n    heap.Init(seat)\\n    tf := fmt.Sprintf(\"%d|%d\", times[targetFriend][0], times[targetFriend][1])\\n\\n    for i, _ := range times {\\n        heap.Push(seat, i)\\n    }\\n\\n    sort.Slice(times, func(i, j int) bool {\\n        return times[i][0] < times[j][0]\\n    })\\n\\n    for _, t := range times {\\n//looks like a O(n^2) coz of two for loop but since we can only \\n//pop n items through out the process, the actual complexity is O(N)\\n        for len(*h) > 0 && (*h)[0][1] <= t[0] {\\n            x := heap.Pop(h).([]int)\\n            heap.Push(seat, x[2])\\n        }\\n        if fmt.Sprintf(\"%d|%d\", t[0], t[1]) != tf {\\n            heap.Push(h, append(t, heap.Pop(seat).(int)))\\n        } else {\\n            break\\n        }\\n    }\\n\\n    return heap.Pop(seat).(int)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n//11:14\\n\\nimport (\\n        \"container/heap\"\\n        \"fmt\"\\n)\\n\\n// An IntHeap is a min-heap of ints.\\ntype IntHeap [][]int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i][1] < h[j][1] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n    *h = append(*h, x.([]int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n    old := *h\\n    n := len(old)\\n    x := old[n-1]\\n    *h = old[0 : n-1]\\n    return x\\n}\\n\\ntype IHeap []int\\n\\nfunc (h IHeap) Len() int           { return len(h) }\\nfunc (h IHeap) Less(i, j int) bool { return h[i] < h[j] }\\nfunc (h IHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IHeap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *IHeap) Pop() interface{} {\\n    old := *h\\n    n := len(old)\\n    x := old[n-1]\\n    *h = old[0 : n-1]\\n    return x\\n}\\n\\nfunc smallestChair(times [][]int, targetFriend int) int {\\n    if len(times) == 0 {\\n        return 0\\n    }\\n\\n    h := &IntHeap{}\\n    seat := &IHeap{}\\n    \\n    heap.Init(h)\\n    heap.Init(seat)\\n    tf := fmt.Sprintf(\"%d|%d\", times[targetFriend][0], times[targetFriend][1])\\n\\n    for i, _ := range times {\\n        heap.Push(seat, i)\\n    }\\n\\n    sort.Slice(times, func(i, j int) bool {\\n        return times[i][0] < times[j][0]\\n    })\\n\\n    for _, t := range times {\\n//looks like a O(n^2) coz of two for loop but since we can only \\n//pop n items through out the process, the actual complexity is O(N)\\n        for len(*h) > 0 && (*h)[0][1] <= t[0] {\\n            x := heap.Pop(h).([]int)\\n            heap.Push(seat, x[2])\\n        }\\n        if fmt.Sprintf(\"%d|%d\", t[0], t[1]) != tf {\\n            heap.Push(h, append(t, heap.Pop(seat).(int)))\\n        } else {\\n            break\\n        }\\n    }\\n\\n    return heap.Pop(seat).(int)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3896047,
                "title": "c-set-map-easy-to-understand",
                "content": "\\n\\n# Approach\\n**We are taking set as to find out the smallest unoccupied chair available at the ith guest after sorting guest in ascending order of arrival time.\\nAt ith iteration for times array whenever we encounter with guest we give him smallest chair possible and delete it from set;\\nAt the start of every iteration we make the chairs free which were occupied by the guest whose departure time is less than equal to ith guest and insert back those chair values to set**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n          int arrival = times[targetFriend][0];\\n          int n = times.size();\\n          sort(times.begin() , times.end());\\n          if(arrival == times[0][0])return 0;\\n          set<int> st;\\n          for(int i = 0 ; i < n ; i++)st.insert(i);\\n          map<int,vector<int>> mp;\\n          for(int i = 0 ; i < n ; i++){\\n                 while(mp.size() > 0 && mp.begin()->first <= times[i][0]){\\n                     int key = mp.begin()->first;\\n                     for(auto key2 : mp[key])\\n                         st.insert(key2);\\n                     mp.erase(key);\\n                 }\\n                 if(times[i][0] == arrival){\\n                     return *(st.begin());\\n                 }\\n                 int token = *(st.begin());\\n                 st.erase(token);\\n                 mp[times[i][1]].push_back(token);\\n          }\\n          return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n          int arrival = times[targetFriend][0];\\n          int n = times.size();\\n          sort(times.begin() , times.end());\\n          if(arrival == times[0][0])return 0;\\n          set<int> st;\\n          for(int i = 0 ; i < n ; i++)st.insert(i);\\n          map<int,vector<int>> mp;\\n          for(int i = 0 ; i < n ; i++){\\n                 while(mp.size() > 0 && mp.begin()->first <= times[i][0]){\\n                     int key = mp.begin()->first;\\n                     for(auto key2 : mp[key])\\n                         st.insert(key2);\\n                     mp.erase(key);\\n                 }\\n                 if(times[i][0] == arrival){\\n                     return *(st.begin());\\n                 }\\n                 int token = *(st.begin());\\n                 st.erase(token);\\n                 mp[times[i][1]].push_back(token);\\n          }\\n          return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835371,
                "title": "the-number-of-the-smallest-unoccupied-chair-min-heaps-heavily-commented",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        import heapq as hq\\n        a=[]\\n        for i in range(len(times)):a.append([i,times[i][0],times[i][1]])\\n        a.sort(key=lambda x:[x[1],x[2]])\\n        \"\"\"Instead of infinite by the logic at worst case each \\n        of friend can have a chair if all attending at same time \\n        every one get seperate chair so we can keep can have \\n        atmost len(times) chairs for safer side \\n        i took len(times)*2 chairs\"\"\"\\n        availablechairs=[]\\n        \"\"\"assigned chairs in this [[EndTime,chairnumber]] type of fashion\\n        in assigned heap/List\"\"\"\\n        assigned=[] \\n        hq.heapify(availablechairs)\\n        hq.heapify(assigned)\\n        \"\"\"make heap of available chairs so avalable chairs will \\n        be put inside this\"\"\"\\n        for i in range(len(a)*2+1):hq.heappush(availablechairs,i)\\n        for i in range(len(a)):\\n            \"\"\"firstly chq whether any chair will be till the arriving \\n            time of current frnd if so take out all the chairs for it \\n            as we already sort time array according to arrival time \\n            of friends is so then put those chairs inside \\n            availablechairs heap\"\"\" \\n            while len(assigned) and assigned[0][0]<=a[i][1]:\\n                x=hq.heappop(assigned)\\n                hq.heappush(availablechairs,x[1])\\n            \"\"\"after taking out all available chairs i tried to \\n            assigned smaller number chairs to the currently arrived friend\"\"\"\\n            x=hq.heappop(availablechairs)\\n            hq.heappush(assigned,[a[i][2],x])\\n            \"\"\"if i got the target frnd i just \\n            returned the chair is assigned to him.\"\"\"\\n            if(a[i][0]==targetFriend):\\n                return(x)\\n        \\n        \\n        ***\"\"\"SECOND APPREOACH\"\"\"**\\n        # import heapq as hq\\n        # a=[]\\n        # for i in range(len(times)):a.append([i,times[i][0],times[i][1]])\\n        # a.sort(key=lambda x:[x[1],x[2]])\\n        # # print(a)\\n        # availablechairs=[]\\n        # assigned=[] ## [[EndTime,chairnumber]]\\n        # hq.heapify(availablechairs)\\n        # hq.heapify(assigned)\\n        # for i in range(len(a)*2+1):hq.heappush(availablechairs,i)\\n        # for i in range(len(a)):\\n        #     f=False\\n        #     for j in range(len(assigned)):\\n        #         if assigned[j][1]<=a[i][1]:\\n        #             assigned[j][1]=a[i][2]\\n        #             f=True\\n        #             if (a[i][0]==targetFriend):\\n        #                 return assigned[j][0]\\n        #             break\\n        #     if f:\\n        #         f=False\\n        #         continue\\n        #     else:\\n        #         x=hq.heappop(availablechairs)\\n        #         hq.heappush(assigned,[x,a[i][2]])\\n        #         if(a[i][0]==targetFriend):\\n        #             return x\\n```*",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        import heapq as hq\\n        a=[]\\n        for i in range(len(times)):a.append([i,times[i][0],times[i][1]])\\n        a.sort(key=lambda x:[x[1],x[2]])\\n        \"\"\"Instead of infinite by the logic at worst case each \\n        of friend can have a chair if all attending at same time \\n        every one get seperate chair so we can keep can have \\n        atmost len(times) chairs for safer side \\n        i took len(times)*2 chairs\"\"\"\\n        availablechairs=[]\\n        \"\"\"assigned chairs in this [[EndTime,chairnumber]] type of fashion\\n        in assigned heap/List\"\"\"\\n        assigned=[] \\n        hq.heapify(availablechairs)\\n        hq.heapify(assigned)\\n        \"\"\"make heap of available chairs so avalable chairs will \\n        be put inside this\"\"\"\\n        for i in range(len(a)*2+1):hq.heappush(availablechairs,i)\\n        for i in range(len(a)):\\n            \"\"\"firstly chq whether any chair will be till the arriving \\n            time of current frnd if so take out all the chairs for it \\n            as we already sort time array according to arrival time \\n            of friends is so then put those chairs inside \\n            availablechairs heap\"\"\" \\n            while len(assigned) and assigned[0][0]<=a[i][1]:\\n                x=hq.heappop(assigned)\\n                hq.heappush(availablechairs,x[1])\\n            \"\"\"after taking out all available chairs i tried to \\n            assigned smaller number chairs to the currently arrived friend\"\"\"\\n            x=hq.heappop(availablechairs)\\n            hq.heappush(assigned,[a[i][2],x])\\n            \"\"\"if i got the target frnd i just \\n            returned the chair is assigned to him.\"\"\"\\n            if(a[i][0]==targetFriend):\\n                return(x)\\n        \\n        \\n        ***\"\"\"SECOND APPREOACH\"\"\"**\\n        # import heapq as hq\\n        # a=[]\\n        # for i in range(len(times)):a.append([i,times[i][0],times[i][1]])\\n        # a.sort(key=lambda x:[x[1],x[2]])\\n        # # print(a)\\n        # availablechairs=[]\\n        # assigned=[] ## [[EndTime,chairnumber]]\\n        # hq.heapify(availablechairs)\\n        # hq.heapify(assigned)\\n        # for i in range(len(a)*2+1):hq.heappush(availablechairs,i)\\n        # for i in range(len(a)):\\n        #     f=False\\n        #     for j in range(len(assigned)):\\n        #         if assigned[j][1]<=a[i][1]:\\n        #             assigned[j][1]=a[i][2]\\n        #             f=True\\n        #             if (a[i][0]==targetFriend):\\n        #                 return assigned[j][0]\\n        #             break\\n        #     if f:\\n        #         f=False\\n        #         continue\\n        #     else:\\n        #         x=hq.heappop(availablechairs)\\n        #         hq.heappush(assigned,[x,a[i][2]])\\n        #         if(a[i][0]==targetFriend):\\n        #             return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795092,
                "title": "c-solution-with-explanation-o-nlogn",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo the set here is used to store all the available seats.Since we have n people.So the max number of seats that could be occupied is also from 0 to n-1. so we have inserted them in the set.\\n\\nThen a map mp is maintained to store all the {start,end} as key and the person associated as the value. So since its a ordered map. we dont need to sort .It will get sorted according to the time.\\n\\nThen the map check is used to store the endTime as key and all the chairs that will get free at that time as value. so a vector is used as a value.\\n\\nTraversing the map mp, we can first remove all the elements from check that needs to be removed . I mean they have left the seat. SO we will check which chairs are freed by the start time of current mp.\\nSo we can add those chairs to set (since they are now available to be used by other people). And the check map is also updated.\\n\\nAfter this , for the current person we will check which chair will be assigned to it. basically allot them the first element of set(which is the smallest available chair).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        set<int> s;\\n        for(int i=0;i<times.size();i++)\\n            s.insert(i);\\n\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<times.size();i++)\\n            mp[{times[i][0],times[i][1]}]=i;\\n\\n        map<int,vector<int>> check;\\n        \\n        for(auto &it1:mp)\\n        {\\n            for(auto &it2:check)\\n            {\\n                if(it2.first <= it1.first.first)\\n                {\\n                    vector<int> v;\\n                    v=it2.second;\\n                    for(auto it:v)\\n                        s.insert(it);\\n                    check.erase(check.find(it2.first));    \\n                }\\n            }\\n\\n            check[it1.first.second].push_back(*s.begin());\\n\\n            if(it1.second == targetFriend)\\n                return *s.begin();\\n\\n            s.erase(s.begin());   \\n        }  \\n        return -1;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        set<int> s;\\n        for(int i=0;i<times.size();i++)\\n            s.insert(i);\\n\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<times.size();i++)\\n            mp[{times[i][0],times[i][1]}]=i;\\n\\n        map<int,vector<int>> check;\\n        \\n        for(auto &it1:mp)\\n        {\\n            for(auto &it2:check)\\n            {\\n                if(it2.first <= it1.first.first)\\n                {\\n                    vector<int> v;\\n                    v=it2.second;\\n                    for(auto it:v)\\n                        s.insert(it);\\n                    check.erase(check.find(it2.first));    \\n                }\\n            }\\n\\n            check[it1.first.second].push_back(*s.begin());\\n\\n            if(it1.second == targetFriend)\\n                return *s.begin();\\n\\n            s.erase(s.begin());   \\n        }  \\n        return -1;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721764,
                "title": "python3-pushing-friends-around-doubleheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to keep track of the smallest chair available and keep track which friend has which chair and when he leaves.\\n\\nIn my head, this screams for thwo heaps and a simultion over time. Therefore, we first sort the friends in the order of their arrival, so we can simulate over time. Here we also need to keep track of their original indices, as we need to know when target friend arrives.\\n\\nThen we go through the arrival times. At each arrival time, we push out all friends that are leaving before this time from the occupied chairs heap. Everytime, we pushed out a friend, we add the free chair back into a minheap keeping track of the smallest numbered chair.\\n\\nAfter we have done that, we assign the smallest chair to the new friend and push his leaving time and chair number into the occupied chairs heap. Before doing that, we can check whether this friend is the target friend. In this case, we can return the minimum chair.\\n\\nKeep in mind: Pushing friends out is not a good thing!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo heaps, with occupied and free chairs\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * logN) as we need to sort the friends with their arrival time\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) for chairs or leaving friends (if we ignore sorting)\\n# Code\\n```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n\\n        # sort the friends by their arrival time (and keep the index)\\n        friends = sorted([(arrival, leave, idx) for idx, (arrival, leave) in enumerate(times)], key=lambda x: x[0])\\n        \\n        # keep track of the minimum free chair\\n        free_chair = 0\\n\\n        # make a heap for the leave times and their occupied chair\\n        occupied = []\\n        chairs = [ele for ele in range(len(friends))]\\n        for arrival, leaving, odx in friends:\\n\\n            # get all the occupied chairs back into the available chairs\\n            while occupied and occupied[0][0] <= arrival:\\n\\n                # push out the leaving friend\\n                _, chair = heapq.heappop(occupied)\\n\\n                # push back the occupied chair\\n                heapq.heappush(chairs, chair)\\n            \\n            # check whether we reached our target\\n            if odx == targetFriend: return chairs[0]\\n\\n            # push the friend into the group of chairs\\n            heapq.heappush(occupied, (leaving, heapq.heappop(chairs)))\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n\\n        # sort the friends by their arrival time (and keep the index)\\n        friends = sorted([(arrival, leave, idx) for idx, (arrival, leave) in enumerate(times)], key=lambda x: x[0])\\n        \\n        # keep track of the minimum free chair\\n        free_chair = 0\\n\\n        # make a heap for the leave times and their occupied chair\\n        occupied = []\\n        chairs = [ele for ele in range(len(friends))]\\n        for arrival, leaving, odx in friends:\\n\\n            # get all the occupied chairs back into the available chairs\\n            while occupied and occupied[0][0] <= arrival:\\n\\n                # push out the leaving friend\\n                _, chair = heapq.heappop(occupied)\\n\\n                # push back the occupied chair\\n                heapq.heappush(chairs, chair)\\n            \\n            # check whether we reached our target\\n            if odx == targetFriend: return chairs[0]\\n\\n            # push the friend into the group of chairs\\n            heapq.heappush(occupied, (leaving, heapq.heappop(chairs)))\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663613,
                "title": "fenwick-tree-binary-search-to-find-mex",
                "content": "```\\nclass FenwickTree:\\n    def __init__(self, x):\\n        self.bit = x\\n        for i in range(len(x)):\\n            j = i | (i + 1)\\n            if j < len(x):\\n                x[j] += x[i]\\n\\n    def update(self, idx, x):\\n        while idx < len(self.bit):\\n            self.bit[idx] += x\\n            idx |= idx + 1\\n\\n    def query(self, end):\\n        x = 0\\n        while end:\\n            x += self.bit[end - 1]\\n            end &= end - 1\\n        return x\\n\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        n = len(times)\\n        pos = []\\n        for i in range(n):\\n            pos.append((times[i][0], 1, i))\\n            pos.append((times[i][1], -1, i))\\n        pos.sort()\\n        used = FenwickTree([0] * (n + 1))\\n        seat = {}\\n        for t, inc, friend in pos:\\n            if inc == 1:\\n                beg = 0\\n                end = n\\n                chair = end\\n                while beg <= end:\\n                    mid = (beg + end) // 2\\n                    if used.query(mid + 1) < mid + 1:\\n                        chair = mid\\n                        end = mid - 1\\n                    else:\\n                        beg = mid + 1\\n                used.update(chair, 1)\\n                seat[friend] = chair\\n            else:\\n                used.update(seat[friend], -1)\\n        return seat[targetFriend]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FenwickTree:\\n    def __init__(self, x):\\n        self.bit = x\\n        for i in range(len(x)):\\n            j = i | (i + 1)\\n            if j < len(x):\\n                x[j] += x[i]\\n\\n    def update(self, idx, x):\\n        while idx < len(self.bit):\\n            self.bit[idx] += x\\n            idx |= idx + 1\\n\\n    def query(self, end):\\n        x = 0\\n        while end:\\n            x += self.bit[end - 1]\\n            end &= end - 1\\n        return x\\n\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        n = len(times)\\n        pos = []\\n        for i in range(n):\\n            pos.append((times[i][0], 1, i))\\n            pos.append((times[i][1], -1, i))\\n        pos.sort()\\n        used = FenwickTree([0] * (n + 1))\\n        seat = {}\\n        for t, inc, friend in pos:\\n            if inc == 1:\\n                beg = 0\\n                end = n\\n                chair = end\\n                while beg <= end:\\n                    mid = (beg + end) // 2\\n                    if used.query(mid + 1) < mid + 1:\\n                        chair = mid\\n                        end = mid - 1\\n                    else:\\n                        beg = mid + 1\\n                used.update(chair, 1)\\n                seat[friend] = chair\\n            else:\\n                used.update(seat[friend], -1)\\n        return seat[targetFriend]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434264,
                "title": "c-code-using-two-min-heaps-easy-approach",
                "content": "# Intuition\\nUse two min heaps.\\n\\n# Approach\\n- Store the arrivalTime of targetFriend, since all the the arrival times are distinct this can be used to identify the targetFriend in sorted array.\\n- Store all the available seats(one for each friend) in minHeap as available.\\n- Sort the times array based on arrival time.\\n- Maintain another minHeap to store leavingTime and occupiedSeat.\\nloop through sorted array\\n- remove all the friends from the heap whose leavingTime is less than or equal to current arraival time and add the occupied seats back to available heap.\\n- if the current start is equal to targetStart return the min available seat , else add the current leaving time and min available seat to heap.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int target = times[targetFriend][0];\\n        \\n        sort(times.begin(),times.end());\\n        int n = times.size();\\n        \\n        //minpq for available chair numbers\\n        priority_queue<int,vector<int>, greater<int> > pq_chair;\\n        \\n        for(int i = 0; i < n; i++)\\n            pq_chair.push(i);\\n        \\n        //minpq for departure time\\n        priority_queue<pair<int,int> ,vector<pair<int,int>>, greater<pair<int,int>> > pq_leaving;\\n        \\n        for(auto v : times){\\n            int arrival = v[0], dep = v[1];\\n            while(!pq_leaving.empty() && pq_leaving.top().first <= arrival){\\n                pair<int,int> p = pq_leaving.top();\\n                pq_leaving.pop();\\n                pq_chair.push(p.second);\\n            }\\n            int chair = pq_chair.top();\\n            pq_chair.pop();\\n            pq_leaving.push({dep,chair});\\n            if(arrival == target)\\n                return chair;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int target = times[targetFriend][0];\\n        \\n        sort(times.begin(),times.end());\\n        int n = times.size();\\n        \\n        //minpq for available chair numbers\\n        priority_queue<int,vector<int>, greater<int> > pq_chair;\\n        \\n        for(int i = 0; i < n; i++)\\n            pq_chair.push(i);\\n        \\n        //minpq for departure time\\n        priority_queue<pair<int,int> ,vector<pair<int,int>>, greater<pair<int,int>> > pq_leaving;\\n        \\n        for(auto v : times){\\n            int arrival = v[0], dep = v[1];\\n            while(!pq_leaving.empty() && pq_leaving.top().first <= arrival){\\n                pair<int,int> p = pq_leaving.top();\\n                pq_leaving.pop();\\n                pq_chair.push(p.second);\\n            }\\n            int chair = pq_chair.top();\\n            pq_chair.pop();\\n            pq_leaving.push({dep,chair});\\n            if(arrival == target)\\n                return chair;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391806,
                "title": "simple-queue-solution",
                "content": "First thing that came to mind when reading the description was that I needed some kind of queue.  \\n\\n# Approach\\nI neeed to separate the \"arrivals\" and \"leavings\" into their own items in the queue and add `time` and friend index (which I call `id`)\\n\\nLoop through the queue and break when friend index === targetFriend, you don\\'t need to keep processing the queue after that because you\\'ve already got your answer\\n\\n# Complexity\\n`Array.prototype.sort` is `O(n log n)` so that would be the most complex of my code, the rest is either `O(n)` (reduce, for-loop, indexOf) or `O(1)` (push).\\n\\nThere are definitely improvements I can do to make this code faster and also take up less memory but I like the legibility of it.\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} times\\n * @param {number} targetFriend\\n * @return {number}\\n */\\nconst smallestChair = function (times, targetFriend) {\\n  const chairs = [];\\n  const ARRIVE = \"arrive\";\\n  const LEAVE = \"leave\";\\n\\n  const queue = times\\n    .reduce((arr, t, i) => {\\n      arr.push({ id: i, time: t[0], action: ARRIVE });\\n      arr.push({ id: i, time: t[1], action: LEAVE });\\n      return arr;\\n    }, [])\\n    .sort((a, b) => {\\n      // if time is the same, put leave in front of arrive\\n      if (a.time === b.time) {\\n        if (a.action === LEAVE) return -1;\\n        else return 1;\\n      }\\n      return a.time - b.time;\\n    });\\n\\n  let friend;\\n  for (let i = 0; i < queue.length; i++) {\\n    friend = queue[i];\\n    if (friend.action === ARRIVE) {\\n      const index = findChair(chairs);\\n      chairs[index] = friend.id;\\n    } else {\\n      const index = chairs.indexOf(friend.id);\\n      chairs[index] = undefined;\\n    }\\n    if (friend.id === targetFriend) {\\n      break;\\n    }\\n  }\\n\\n  return chairs.indexOf(friend.id);\\n};\\n\\nfunction findChair(chairs) {\\n  if (!chairs.length) return 0;\\n  const nextIndex = chairs.indexOf(undefined);\\n  if (nextIndex < 0) {\\n    return chairs.length;\\n  } else {\\n    return nextIndex;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} times\\n * @param {number} targetFriend\\n * @return {number}\\n */\\nconst smallestChair = function (times, targetFriend) {\\n  const chairs = [];\\n  const ARRIVE = \"arrive\";\\n  const LEAVE = \"leave\";\\n\\n  const queue = times\\n    .reduce((arr, t, i) => {\\n      arr.push({ id: i, time: t[0], action: ARRIVE });\\n      arr.push({ id: i, time: t[1], action: LEAVE });\\n      return arr;\\n    }, [])\\n    .sort((a, b) => {\\n      // if time is the same, put leave in front of arrive\\n      if (a.time === b.time) {\\n        if (a.action === LEAVE) return -1;\\n        else return 1;\\n      }\\n      return a.time - b.time;\\n    });\\n\\n  let friend;\\n  for (let i = 0; i < queue.length; i++) {\\n    friend = queue[i];\\n    if (friend.action === ARRIVE) {\\n      const index = findChair(chairs);\\n      chairs[index] = friend.id;\\n    } else {\\n      const index = chairs.indexOf(friend.id);\\n      chairs[index] = undefined;\\n    }\\n    if (friend.id === targetFriend) {\\n      break;\\n    }\\n  }\\n\\n  return chairs.indexOf(friend.id);\\n};\\n\\nfunction findChair(chairs) {\\n  if (!chairs.length) return 0;\\n  const nextIndex = chairs.indexOf(undefined);\\n  if (nextIndex < 0) {\\n    return chairs.length;\\n  } else {\\n    return nextIndex;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302139,
                "title": "python-2-heaps",
                "content": "The idea here is to create a heap for anything behind us and a heap for anything infront of us, the rest will be handled by a pointer. When someone arrives we first check if anyone needs to leave at this time so we can free up chairs. If anyones leave time is less than or equal to our current arrival time we can pop the leave time and chair and put the chair in our behind us heap. \\n\\nWe will than check if we have anything in our behind us heap and if we do we will pop that value and assign our friend that seat. If we have nothing behind us we add our friend to the position of our pointer and increment it by 1 to point at the next maximum seat.\\n\\nAt the end after assigning our friend the seat we can push the leave time and chair number onto the leave heap so it may be freed up in the future.\\n\\nIf we ever assign our target friend we can return his chair\\n\\n```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        \\n        #add the index to our list so we can sort\\n        for i in range(len(times)):\\n            times[i].append(i)\\n            \\n        times.sort(key = lambda x:(x[0], x[1]))\\n        \\n        \\n        heapLeave = []\\n        heapOpen = []\\n        count = 0\\n        \\n        i = 0\\n        #trick to save on space is to only store rearrivals in heapOpen since they will always be less than or equal to our count so if we\\n        #have anything in heapOpen we can pop that first, than if we have nothing in heapOpen we can use the counter which means all the chairs behind us\\n        #are filled and we must start using new chairs\\n        while i <= len(times):\\n            \\n            arr,leav,idx = times[i]\\n            \\n            while heapLeave and heapLeave[0][0] <= arr:\\n                #time leave, his chair\\n                l,c = heappop(heapLeave)\\n                #we only need his chair\\n                heappush(heapOpen, c)\\n            \\n            if heapOpen:\\n                #old chair being reused\\n                chair = heappop(heapOpen)\\n            else:\\n                #new chair\\n                chair = count\\n                count +=1\\n            #break early we found our friend\\n            if idx == targetFriend:\\n                return chair\\n            \\n            #someone sat down, we must add their leave time\\n            heappush(heapLeave, (leav, chair))\\n            \\n            i+=1\\n        \\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "The idea here is to create a heap for anything behind us and a heap for anything infront of us, the rest will be handled by a pointer. When someone arrives we first check if anyone needs to leave at this time so we can free up chairs. If anyones leave time is less than or equal to our current arrival time we can pop the leave time and chair and put the chair in our behind us heap. \\n\\nWe will than check if we have anything in our behind us heap and if we do we will pop that value and assign our friend that seat. If we have nothing behind us we add our friend to the position of our pointer and increment it by 1 to point at the next maximum seat.\\n\\nAt the end after assigning our friend the seat we can push the leave time and chair number onto the leave heap so it may be freed up in the future.\\n\\nIf we ever assign our target friend we can return his chair\\n\\n```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        \\n        #add the index to our list so we can sort\\n        for i in range(len(times)):\\n            times[i].append(i)\\n            \\n        times.sort(key = lambda x:(x[0], x[1]))\\n        \\n        \\n        heapLeave = []\\n        heapOpen = []\\n        count = 0\\n        \\n        i = 0\\n        #trick to save on space is to only store rearrivals in heapOpen since they will always be less than or equal to our count so if we\\n        #have anything in heapOpen we can pop that first, than if we have nothing in heapOpen we can use the counter which means all the chairs behind us\\n        #are filled and we must start using new chairs\\n        while i <= len(times):\\n            \\n            arr,leav,idx = times[i]\\n            \\n            while heapLeave and heapLeave[0][0] <= arr:\\n                #time leave, his chair\\n                l,c = heappop(heapLeave)\\n                #we only need his chair\\n                heappush(heapOpen, c)\\n            \\n            if heapOpen:\\n                #old chair being reused\\n                chair = heappop(heapOpen)\\n            else:\\n                #new chair\\n                chair = count\\n                count +=1\\n            #break early we found our friend\\n            if idx == targetFriend:\\n                return chair\\n            \\n            #someone sat down, we must add their leave time\\n            heappush(heapLeave, (leav, chair))\\n            \\n            i+=1\\n        \\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 3285869,
                "title": "c-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    enum Act{\\n        OUT = 0,\\n        IN = 1,\\n    };\\n\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        const int n = times.size();\\n        set<int> st;\\n        vector<tuple<int, Act, int>> v;    \\n        vector<int> seats(n, -1);    \\n        for(int i = 0; i<n; i++) {\\n            st.insert(i);\\n            v.emplace_back(times[i][0], IN, i);\\n            v.emplace_back(times[i][1], OUT, i);\\n        }\\n        sort(begin(v), end(v));\\n        for(auto [t, act, i] : v){\\n            if(act == IN){\\n                int seat = *st.begin();\\n                seats[i] = seat;\\n                if(targetFriend == i) return seat;\\n                st.erase(seat);\\n            }\\n            else{\\n                st.insert(seats[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    enum Act{\\n        OUT = 0,\\n        IN = 1,\\n    };\\n\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        const int n = times.size();\\n        set<int> st;\\n        vector<tuple<int, Act, int>> v;    \\n        vector<int> seats(n, -1);    \\n        for(int i = 0; i<n; i++) {\\n            st.insert(i);\\n            v.emplace_back(times[i][0], IN, i);\\n            v.emplace_back(times[i][1], OUT, i);\\n        }\\n        sort(begin(v), end(v));\\n        for(auto [t, act, i] : v){\\n            if(act == IN){\\n                int seat = *st.begin();\\n                seats[i] = seat;\\n                if(targetFriend == i) return seat;\\n                st.erase(seat);\\n            }\\n            else{\\n                st.insert(seats[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282329,
                "title": "python-sorting-heap-map-solution",
                "content": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        time_arr = []\\n        arrive, leave = 1, -1\\n        for idx, (arrive_time, leave_time) in enumerate(times):\\n            time_arr.append((arrive_time, arrive, idx))\\n            time_arr.append((leave_time, leave, idx))\\n        time_arr.sort()\\n\\n        chair_min_heap = [chair for chair in range(len(times))]\\n        heapq.heapify(chair_min_heap)\\n        friend_to_chair = {}\\n\\n        for time, flag, idx in time_arr:\\n            if idx == targetFriend:\\n                min_chair = heapq.heappop(chair_min_heap)\\n                return min_chair\\n            if flag == arrive:\\n                min_chair = heapq.heappop(chair_min_heap)\\n                friend_to_chair[idx] = min_chair\\n            else:\\n                occupied_chair = friend_to_chair[idx]\\n                heapq.heappush(chair_min_heap, occupied_chair)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        time_arr = []\\n        arrive, leave = 1, -1\\n        for idx, (arrive_time, leave_time) in enumerate(times):\\n            time_arr.append((arrive_time, arrive, idx))\\n            time_arr.append((leave_time, leave, idx))\\n        time_arr.sort()\\n\\n        chair_min_heap = [chair for chair in range(len(times))]\\n        heapq.heapify(chair_min_heap)\\n        friend_to_chair = {}\\n\\n        for time, flag, idx in time_arr:\\n            if idx == targetFriend:\\n                min_chair = heapq.heappop(chair_min_heap)\\n                return min_chair\\n            if flag == arrive:\\n                min_chair = heapq.heappop(chair_min_heap)\\n                friend_to_chair[idx] = min_chair\\n            else:\\n                occupied_chair = friend_to_chair[idx]\\n                heapq.heappush(chair_min_heap, occupied_chair)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162670,
                "title": "java-sweep-line-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int n = times.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return a[1] - b[1];\\n            } else {\\n                return a[0] - b[0];\\n            }\\n        });\\n        for (int i = 0; i < n; i++) {\\n            int[] time = times[i];\\n            pq.offer(new int[]{time[0], 1, i});\\n            pq.offer(new int[]{time[1], -1, i});\\n        }\\n\\n        int count = 0;\\n        PriorityQueue<Integer> ava = new PriorityQueue<>();\\n        int[] seat = new int[n];\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            if (cur[1] == 1) {\\n                if (!ava.isEmpty()) {\\n                    seat[cur[2]] = ava.poll();\\n                } else {\\n                    seat[cur[2]] = count;\\n                }\\n                count++;\\n            } else {\\n                ava.offer(seat[cur[2]]);\\n                count--;\\n            }\\n            if (cur[2] == targetFriend) return seat[cur[2]];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Line Sweep",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int n = times.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return a[1] - b[1];\\n            } else {\\n                return a[0] - b[0];\\n            }\\n        });\\n        for (int i = 0; i < n; i++) {\\n            int[] time = times[i];\\n            pq.offer(new int[]{time[0], 1, i});\\n            pq.offer(new int[]{time[1], -1, i});\\n        }\\n\\n        int count = 0;\\n        PriorityQueue<Integer> ava = new PriorityQueue<>();\\n        int[] seat = new int[n];\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            if (cur[1] == 1) {\\n                if (!ava.isEmpty()) {\\n                    seat[cur[2]] = ava.poll();\\n                } else {\\n                    seat[cur[2]] = count;\\n                }\\n                count++;\\n            } else {\\n                ava.offer(seat[cur[2]]);\\n                count--;\\n            }\\n            if (cur[2] == targetFriend) return seat[cur[2]];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085926,
                "title": "java-solution-priorityqueue-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        // PriorityQueue + Simulation\\n        int targetTime = times[targetFriend][0];\\n        Arrays.sort(times, (a, b) -> a[0] - b[0]);\\n        PriorityQueue<Integer> leftSeats = new PriorityQueue<>();\\n        for (int i=0; i<times.length; i++) leftSeats.offer(i);\\n\\n        PriorityQueue<int[]> stayFriends = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        for (int[] time : times) {\\n            while (!stayFriends.isEmpty() && stayFriends.peek()[1] <= time[0]) {\\n                leftSeats.offer(stayFriends.poll()[2]);\\n            }\\n            if (time[0] == targetTime) return leftSeats.peek();\\n            stayFriends.offer(new int[]{time[0], time[1], leftSeats.poll()});\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        // PriorityQueue + Simulation\\n        int targetTime = times[targetFriend][0];\\n        Arrays.sort(times, (a, b) -> a[0] - b[0]);\\n        PriorityQueue<Integer> leftSeats = new PriorityQueue<>();\\n        for (int i=0; i<times.length; i++) leftSeats.offer(i);\\n\\n        PriorityQueue<int[]> stayFriends = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        for (int[] time : times) {\\n            while (!stayFriends.isEmpty() && stayFriends.peek()[1] <= time[0]) {\\n                leftSeats.offer(stayFriends.poll()[2]);\\n            }\\n            if (time[0] == targetTime) return leftSeats.peek();\\n            stayFriends.offer(new int[]{time[0], time[1], leftSeats.poll()});\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019951,
                "title": "python-greedy-o-nlogn",
                "content": "# Code\\n```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], target: int) -> int:\\n        n = len(times)\\n        h = [i for i in range(n)]\\n        events = []\\n        L, R = 1, 0\\n        for i, (s, e) in enumerate(times):\\n            events.append((s,L,i))\\n            events.append((e,R,i))\\n        events.sort()\\n        d = defaultdict(lambda: -1)\\n        for t, typ, i in events:\\n            if typ == L:\\n                j = heappop(h)\\n                d[i] = j\\n                if target == i: return j\\n            else:\\n                heappush(h, d[i])\\n             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], target: int) -> int:\\n        n = len(times)\\n        h = [i for i in range(n)]\\n        events = []\\n        L, R = 1, 0\\n        for i, (s, e) in enumerate(times):\\n            events.append((s,L,i))\\n            events.append((e,R,i))\\n        events.sort()\\n        d = defaultdict(lambda: -1)\\n        for t, typ, i in events:\\n            if typ == L:\\n                j = heappop(h)\\n                d[i] = j\\n                if target == i: return j\\n            else:\\n                heappush(h, d[i])\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977107,
                "title": "java-priority-queue-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        PriorityQueue<int[]> pQ1 = \\n        new PriorityQueue<int[]>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return a[1] - b[1];\\n            }\\n            return a[0] - b[0];\\n        });\\n        PriorityQueue<int[]> pQ2 = \\n        new PriorityQueue<int[]>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return a[1] - b[1];\\n            }\\n            return a[0] - b[0];\\n        });\\n        PriorityQueue<Integer> pQ3 = new PriorityQueue<Integer>();\\n        for (int i = 0; i < times.length; i++) {\\n            pQ1.offer(new int[]{times[i][0], times[i][1], i});\\n        }\\n        int next = 0;\\n        while (!pQ1.isEmpty()) {\\n            int[] tuple = pQ1.poll();\\n            int seat = next;\\n            while (!pQ2.isEmpty() && pQ2.peek()[0] <= tuple[0]) {\\n                int[] pair = pQ2.poll();\\n                pQ3.offer(pair[1]);\\n            }\\n            if (!pQ3.isEmpty()) {\\n                seat = pQ3.poll();\\n            } else {\\n                next++;\\n            }\\n            if (tuple[2] == targetFriend) {\\n                return seat;\\n            }\\n            pQ2.offer(new int[]{tuple[1], seat});\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        PriorityQueue<int[]> pQ1 = \\n        new PriorityQueue<int[]>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return a[1] - b[1];\\n            }\\n            return a[0] - b[0];\\n        });\\n        PriorityQueue<int[]> pQ2 = \\n        new PriorityQueue<int[]>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return a[1] - b[1];\\n            }\\n            return a[0] - b[0];\\n        });\\n        PriorityQueue<Integer> pQ3 = new PriorityQueue<Integer>();\\n        for (int i = 0; i < times.length; i++) {\\n            pQ1.offer(new int[]{times[i][0], times[i][1], i});\\n        }\\n        int next = 0;\\n        while (!pQ1.isEmpty()) {\\n            int[] tuple = pQ1.poll();\\n            int seat = next;\\n            while (!pQ2.isEmpty() && pQ2.peek()[0] <= tuple[0]) {\\n                int[] pair = pQ2.poll();\\n                pQ3.offer(pair[1]);\\n            }\\n            if (!pQ3.isEmpty()) {\\n                seat = pQ3.poll();\\n            } else {\\n                next++;\\n            }\\n            if (tuple[2] == targetFriend) {\\n                return seat;\\n            }\\n            pQ2.offer(new int[]{tuple[1], seat});\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957044,
                "title": "java-oop-double-min-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    class Data {\\n\\n        int startTime;\\n        int endTime;\\n        int index;\\n\\n        Data(int s, int e, int i) {\\n            startTime = s;\\n            endTime = e;\\n            index = i;\\n        }\\n\\n        public String toString() {\\n            return \"{ s = \"+startTime+\", e = \"+endTime+\", i = \"+index+\"}\";\\n        }\\n\\n    }\\n\\n    class ReleaseTime {\\n        \\n        int releaseTime;\\n        int chair;\\n\\n        ReleaseTime(int r, int c) {\\n            releaseTime = r;\\n            chair = c;\\n        }\\n\\n    }\\n\\n    Data[] data;\\n\\n    int nextChair = 0;\\n    \\n    PriorityQueue<Integer> chairPool = new PriorityQueue<>();\\n\\n    // minHeap which has releaseTime as index and stores chair to be released at that time\\n    PriorityQueue<ReleaseTime> minHeap = new PriorityQueue<>(new Comparator<ReleaseTime>(){\\n        public int compare(ReleaseTime t1, ReleaseTime t2) {\\n            return Integer.compare(t1.releaseTime, t2.releaseTime);\\n        }\\n    });\\n\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        \\ninit(times);\\n        \\n        // sort data with start time, end time\\n        sort();\\n        int ans = -1;\\n\\n        for(Data d : data) {\\n\\n            // for each item poll from minHeap until release time is smaller than current start time\\n            while(!minHeap.isEmpty() && minHeap.peek().releaseTime <= d.startTime) {\\n                ReleaseTime rt = minHeap.poll();\\n\\n                // add each such candidate chair to another minHeap\\n                chairPool.add(rt.chair);\\n            }\\n\\n            // if chairPool empty then we need a new chair, add that entry into releaseTime minHeap\\n            if(chairPool.isEmpty()) {\\n\\n                // this is for extracting the answer\\n                if(d.index == targetFriend) {\\n                    ans = nextChair;\\n                    break;\\n                }\\n                minHeap.add(new ReleaseTime(d.endTime, nextChair++));\\n            }\\n\\n            // choose smallest index chair from chairPool minHeap and add that entry to releaseTime minHeap\\n            else {\\n\\n                // this is for extracting the answer\\n                if(d.index == targetFriend) {\\n                    ans = chairPool.poll();\\n                    break;\\n                }\\n                minHeap.add(new ReleaseTime(d.endTime, chairPool.poll()));\\n            }\\n        }\\n        return ans;\\n\\n    }\\n\\n    private void init(int[][] times) {\\n        data = new Data[times.length];\\n        for(int i = 0; i < times.length; i++) {\\n            data[i] = new Data(times[i][0], times[i][1], i);\\n        }\\n    }\\n\\n    private void sort() {\\n        Arrays.sort(data, new Comparator<Data>(){\\n            public int compare(Data d1, Data d2) {\\n                if(d1.startTime > d2.startTime)\\n                    return 1;\\n                else if (d1.startTime < d2.startTime)\\n                    return -1;\\n                else\\n                    return Integer.compare(d1.endTime, d2.endTime);\\n\\n            }\\n        });\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Data {\\n\\n        int startTime;\\n        int endTime;\\n        int index;\\n\\n        Data(int s, int e, int i) {\\n            startTime = s;\\n            endTime = e;\\n            index = i;\\n        }\\n\\n        public String toString() {\\n            return \"{ s = \"+startTime+\", e = \"+endTime+\", i = \"+index+\"}\";\\n        }\\n\\n    }\\n\\n    class ReleaseTime {\\n        \\n        int releaseTime;\\n        int chair;\\n\\n        ReleaseTime(int r, int c) {\\n            releaseTime = r;\\n            chair = c;\\n        }\\n\\n    }\\n\\n    Data[] data;\\n\\n    int nextChair = 0;\\n    \\n    PriorityQueue<Integer> chairPool = new PriorityQueue<>();\\n\\n    // minHeap which has releaseTime as index and stores chair to be released at that time\\n    PriorityQueue<ReleaseTime> minHeap = new PriorityQueue<>(new Comparator<ReleaseTime>(){\\n        public int compare(ReleaseTime t1, ReleaseTime t2) {\\n            return Integer.compare(t1.releaseTime, t2.releaseTime);\\n        }\\n    });\\n\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        \\ninit(times);\\n        \\n        // sort data with start time, end time\\n        sort();\\n        int ans = -1;\\n\\n        for(Data d : data) {\\n\\n            // for each item poll from minHeap until release time is smaller than current start time\\n            while(!minHeap.isEmpty() && minHeap.peek().releaseTime <= d.startTime) {\\n                ReleaseTime rt = minHeap.poll();\\n\\n                // add each such candidate chair to another minHeap\\n                chairPool.add(rt.chair);\\n            }\\n\\n            // if chairPool empty then we need a new chair, add that entry into releaseTime minHeap\\n            if(chairPool.isEmpty()) {\\n\\n                // this is for extracting the answer\\n                if(d.index == targetFriend) {\\n                    ans = nextChair;\\n                    break;\\n                }\\n                minHeap.add(new ReleaseTime(d.endTime, nextChair++));\\n            }\\n\\n            // choose smallest index chair from chairPool minHeap and add that entry to releaseTime minHeap\\n            else {\\n\\n                // this is for extracting the answer\\n                if(d.index == targetFriend) {\\n                    ans = chairPool.poll();\\n                    break;\\n                }\\n                minHeap.add(new ReleaseTime(d.endTime, chairPool.poll()));\\n            }\\n        }\\n        return ans;\\n\\n    }\\n\\n    private void init(int[][] times) {\\n        data = new Data[times.length];\\n        for(int i = 0; i < times.length; i++) {\\n            data[i] = new Data(times[i][0], times[i][1], i);\\n        }\\n    }\\n\\n    private void sort() {\\n        Arrays.sort(data, new Comparator<Data>(){\\n            public int compare(Data d1, Data d2) {\\n                if(d1.startTime > d2.startTime)\\n                    return 1;\\n                else if (d1.startTime < d2.startTime)\\n                    return -1;\\n                else\\n                    return Integer.compare(d1.endTime, d2.endTime);\\n\\n            }\\n        });\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928611,
                "title": "python-simple-heap-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestChair(self, times, targetFriend):\\n        result = []\\n\\n        for i, (a,b) in enumerate(times):\\n            result.append([a,1,i])\\n            result.append([b,0,i])\\n\\n        result.sort()\\n\\n        available, dict1 = list(range(len(times))), defaultdict(int)\\n        heapq.heapify(result)\\n\\n        for i,j,k in result:\\n            if j:\\n                if k == targetFriend:\\n                    return heappop(available)\\n\\n                dict1[k] = heappop(available)\\n            else:\\n                heappush(available,dict1.pop(k))\\n                \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times, targetFriend):\\n        result = []\\n\\n        for i, (a,b) in enumerate(times):\\n            result.append([a,1,i])\\n            result.append([b,0,i])\\n\\n        result.sort()\\n\\n        available, dict1 = list(range(len(times))), defaultdict(int)\\n        heapq.heapify(result)\\n\\n        for i,j,k in result:\\n            if j:\\n                if k == targetFriend:\\n                    return heappop(available)\\n\\n                dict1[k] = heappop(available)\\n            else:\\n                heappush(available,dict1.pop(k))\\n                \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866406,
                "title": "simple-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} times\\n * @param {number} targetFriend\\n * @return {number}\\n */\\n\\nvar smallestChair = function(times, targetFriend) {\\n\\n    let chairs = Array(times.length).fill(-1);\\n    let timesSorted = [...times].sort( (a, b) => a[0] - b[0]);\\n    \\n    for(let i=0;i<timesSorted.length;i++){\\n        for(let j=0;j<chairs.length;j++){\\n            if(\\n                chairs[j] <= timesSorted[i][0]\\n            ){\\n                chairs[j] = timesSorted[i][1];\\n                if(\\n                    timesSorted[i].toString() === times[targetFriend].toString()\\n                ){\\n                    return(j)\\n                }\\n                break;\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} times\\n * @param {number} targetFriend\\n * @return {number}\\n */\\n\\nvar smallestChair = function(times, targetFriend) {\\n\\n    let chairs = Array(times.length).fill(-1);\\n    let timesSorted = [...times].sort( (a, b) => a[0] - b[0]);\\n    \\n    for(let i=0;i<timesSorted.length;i++){\\n        for(let j=0;j<chairs.length;j++){\\n            if(\\n                chairs[j] <= timesSorted[i][0]\\n            ){\\n                chairs[j] = timesSorted[i][1];\\n                if(\\n                    timesSorted[i].toString() === times[targetFriend].toString()\\n                ){\\n                    return(j)\\n                }\\n                break;\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2863718,
                "title": "java-bruteforce-solution",
                "content": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int targetFriendArrTime = times[targetFriend][0];\\n        Arrays.sort(times, (a,b)->a[0]-b[0]);\\n        int n = times.length;\\n        int[] arr = new int[n];\\n        int ind = 0;\\n        int arrTime;\\n        while(times[ind][0]!=targetFriendArrTime) {\\n            arrTime = times[ind][0];\\n            for(int i=0;i<n;i++) {\\n                if(arrTime>=arr[i]) {\\n                    arr[i] = times[ind][1];\\n                    break;\\n                }\\n            }\\n            ind++;\\n        }\\n        arrTime = times[ind][0];\\n        for(int i=0;i<n;i++) {\\n            if(arrTime>=arr[i]) {\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int targetFriendArrTime = times[targetFriend][0];\\n        Arrays.sort(times, (a,b)->a[0]-b[0]);\\n        int n = times.length;\\n        int[] arr = new int[n];\\n        int ind = 0;\\n        int arrTime;\\n        while(times[ind][0]!=targetFriendArrTime) {\\n            arrTime = times[ind][0];\\n            for(int i=0;i<n;i++) {\\n                if(arrTime>=arr[i]) {\\n                    arr[i] = times[ind][1];\\n                    break;\\n                }\\n            }\\n            ind++;\\n        }\\n        arrTime = times[ind][0];\\n        for(int i=0;i<n;i++) {\\n            if(arrTime>=arr[i]) {\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829625,
                "title": "c-clean-code-two-min-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<int> ids(times.size());\\n        iota(ids.begin(), ids.end(), 0);\\n        sort(ids.begin(), ids.end(), [&](int i, int j) {return times[i][0] < times[j][0];}); // get the index of sorted times\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> leaveTime; // minHeap: {leave time, chair idx}\\n        priority_queue<int, vector<int>, greater<int>> availableChair; // minHeap: index of available chair\\n        int chair = 0, res = 0;\\n        for (auto id : ids) {\\n            int arrive = times[id][0], leave = times[id][1];\\n            while (!leaveTime.empty() && leaveTime.top().first <= arrive) {\\n                availableChair.push(leaveTime.top().second);\\n                leaveTime.pop();\\n            }\\n            if (availableChair.empty()) {\\n                leaveTime.push({leave, chair});\\n                res = chair++;\\n            }\\n            else {\\n                leaveTime.push({leave, availableChair.top()});\\n                res = availableChair.top();\\n                availableChair.pop();\\n            }\\n            if (id == targetFriend) break;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<int> ids(times.size());\\n        iota(ids.begin(), ids.end(), 0);\\n        sort(ids.begin(), ids.end(), [&](int i, int j) {return times[i][0] < times[j][0];}); // get the index of sorted times\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> leaveTime; // minHeap: {leave time, chair idx}\\n        priority_queue<int, vector<int>, greater<int>> availableChair; // minHeap: index of available chair\\n        int chair = 0, res = 0;\\n        for (auto id : ids) {\\n            int arrive = times[id][0], leave = times[id][1];\\n            while (!leaveTime.empty() && leaveTime.top().first <= arrive) {\\n                availableChair.push(leaveTime.top().second);\\n                leaveTime.pop();\\n            }\\n            if (availableChair.empty()) {\\n                leaveTime.push({leave, chair});\\n                res = chair++;\\n            }\\n            else {\\n                leaveTime.push({leave, availableChair.top()});\\n                res = availableChair.top();\\n                availableChair.pop();\\n            }\\n            if (id == targetFriend) break;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776103,
                "title": "c-pbds-ordered-set-o-n-logn",
                "content": "Here i have used a special data structure availale in C++ for storing the available seats, The data structure is just like a regular set but with some more functionalities and optimisations\\nIf you need explanation, please comment \\nTime Complexity : O(NLogN)\\nSpace Complexity : O(N)\\n```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<vector<int>>mp;\\n        int n=times.size(),frnd=0;\\n        for(auto&it:times){\\n            mp.push_back({it[0],frnd,1});\\n            mp.push_back({it[1],frnd,0});\\n            frnd++;\\n        }\\n        \\n        sort(mp.begin(),mp.end(),[&](vector<int>&a,vector<int>&b){\\n           if(a[0]==b[0]){\\n               return a[2]<b[2];\\n           } \\n            return a[0]<b[0];\\n        });\\n        \\n        tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>pbds;\\n        for(int i=0;i<n;i++){\\n            pbds.insert(i);\\n        }\\n        \\n        unordered_map<int,int>friend_seat;\\n\\n        for(auto&it:mp){\\n            if(it[2]==1){\\n                int first_avail=*pbds.lower_bound(0);\\n                int friend_id=it[1];\\n                if(friend_id==targetFriend){\\n                    return first_avail;\\n                }\\n                pbds.erase(first_avail);\\n                friend_seat[friend_id]=first_avail;\\n            }\\n            else if(it[2]==0){\\n                int friend_id=it[1];\\n                int seat=friend_seat[friend_id];\\n                pbds.insert(seat);\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        vector<vector<int>>mp;\\n        int n=times.size(),frnd=0;\\n        for(auto&it:times){\\n            mp.push_back({it[0],frnd,1});\\n            mp.push_back({it[1],frnd,0});\\n            frnd++;\\n        }\\n        \\n        sort(mp.begin(),mp.end(),[&](vector<int>&a,vector<int>&b){\\n           if(a[0]==b[0]){\\n               return a[2]<b[2];\\n           } \\n            return a[0]<b[0];\\n        });\\n        \\n        tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>pbds;\\n        for(int i=0;i<n;i++){\\n            pbds.insert(i);\\n        }\\n        \\n        unordered_map<int,int>friend_seat;\\n\\n        for(auto&it:mp){\\n            if(it[2]==1){\\n                int first_avail=*pbds.lower_bound(0);\\n                int friend_id=it[1];\\n                if(friend_id==targetFriend){\\n                    return first_avail;\\n                }\\n                pbds.erase(first_avail);\\n                friend_seat[friend_id]=first_avail;\\n            }\\n            else if(it[2]==0){\\n                int friend_id=it[1];\\n                int seat=friend_seat[friend_id];\\n                pbds.insert(seat);\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2759725,
                "title": "simply-priority-q",
                "content": "straight forward simulation.\\n - create a list of events where each event is (friendid, time, eventtype : arrival/departure)\\n-  sort this list with time as primary key and eventtype secondary (make sure that departure is before arrival).\\n-  create a heap(priotiry q) of availiable chairs  0 : len(times) (we definitely dont need more than len(times) chairs and in the worst case we will actually need len(times) chairs, so trying to optimize this number is obsolete IMO) \\n-  create a map friend -> chair\\n\\nnow simply iterate on the events and simulate.\\n- on arrival take a free chair from heap and assign it to the friend (add to map)\\n- on departure return th assigned cahir to the heap\\n\\nthats it.\\n\\n\\n```\\nclass Solution(object):\\n    def smallestChair(self, times, targetFriend):\\n        \"\"\"\\n        :type times: List[List[int]]\\n        :type targetFriend: int\\n        :rtype: int\\n        \"\"\"\\n        events = []\\n        for gid, arrleavetimes in enumerate(times):\\n            events.append((gid, arrleavetimes[0], 1))\\n            events.append((gid, arrleavetimes[1], 0))\\n        events.sort(key = lambda x: (x[1], x[2]))\\n        friendsToChairMap = {}\\n        \\n        chairsHeap = range(len(times))\\n        heapq.heapify(chairsHeap)\\n        \\n        for (gid, t, typee) in events:\\n            if typee == 1:\\n                chair = heapq.heappop(chairsHeap)\\n                friendsToChairMap[gid] = chair\\n                if gid == targetFriend:\\n                    break\\n            else:\\n                chair = friendsToChairMap[gid]\\n                heapq.heappush(chairsHeap, chair)\\n        \\n        return friendsToChairMap[targetFriend]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def smallestChair(self, times, targetFriend):\\n        \"\"\"\\n        :type times: List[List[int]]\\n        :type targetFriend: int\\n        :rtype: int\\n        \"\"\"\\n        events = []\\n        for gid, arrleavetimes in enumerate(times):\\n            events.append((gid, arrleavetimes[0], 1))\\n            events.append((gid, arrleavetimes[1], 0))\\n        events.sort(key = lambda x: (x[1], x[2]))\\n        friendsToChairMap = {}\\n        \\n        chairsHeap = range(len(times))\\n        heapq.heapify(chairsHeap)\\n        \\n        for (gid, t, typee) in events:\\n            if typee == 1:\\n                chair = heapq.heappop(chairsHeap)\\n                friendsToChairMap[gid] = chair\\n                if gid == targetFriend:\\n                    break\\n            else:\\n                chair = friendsToChairMap[gid]\\n                heapq.heappush(chairsHeap, chair)\\n        \\n        return friendsToChairMap[targetFriend]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747173,
                "title": "c-solution-using-2-queues",
                "content": "```\\nclass Solution {\\npublic:  \\n    class cmp{\\n      public: \\n      bool  operator()(vector<int>a,vector<int>b){\\n          return  a[1] > b[1];\\n      }\\n    };\\n     class cmp2{\\n      public: \\n      bool  operator()(vector<int>a,vector<int>b){\\n          return a[2] >  b[2];\\n      }\\n    };\\n    int smallestChair(vector<vector<int>>& times, int target) {\\n    \\n        priority_queue<vector<int>,vector<vector<int>>, cmp>come; \\n        map<int,int>chair; \\n        priority_queue<int, vector<int>, greater<int>>free;\\n        priority_queue<vector<int>,vector<vector<int>>, cmp2>go;  \\n        \\n        for(int i=0;i<=times.size();i++){\\n            free.push(i);  \\n        }\\n        \\n        \\n        for(int i=0;i<times.size();i++){\\n            vector<int>temp; \\n            temp.push_back(i);  \\n            temp.push_back(times[i][0]); \\n            temp.push_back(times[i][1]); \\n            come.push(temp);\\n        }\\n        \\n        \\n        while(!come.empty()){\\n           \\n            while(!go.empty() && go.top()[2] <= come.top()[1]){\\n                vector<int>temp=go.top(); \\n                go.pop(); \\n                free.push(temp[0]); \\n            }\\n            \\n            vector<int>curr=come.top(); \\n            come.pop(); \\n            chair[curr[0]]=free.top(); \\n            free.pop(); \\n            vector<int>temp2; \\n            temp2.push_back(chair[curr[0]]);  \\n            temp2.push_back(curr[1]);  \\n            temp2.push_back(curr[2]);  \\n            go.push(temp2); \\n        }\\n        \\n        return  chair[target]; \\n    }\\n    \\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:  \\n    class cmp{\\n      public: \\n      bool  operator()(vector<int>a,vector<int>b){\\n          return  a[1] > b[1];\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2722587,
                "title": "c-two-minheap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& t, int target) {\\n        for(int i = 0; i < t.size(); i++) t[i].push_back(i);\\n        sort(begin(t), end(t));\\n\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        priority_queue<int, vector<int>, greater<int>> free_chair;\\n        int max_v = 0;\\n        for(auto & e : t) {\\n            while(!pq.empty() && e[0] >= pq.top()[0]) {\\n                free_chair.push(pq.top()[1]);\\n                pq.pop();\\n            }\\n\\n            int cur = 0;\\n            if(!free_chair.empty()) {\\n                cur = free_chair.top();\\n                free_chair.pop();\\n            } else {\\n                cur = max_v++;\\n            }\\n\\n            if(e[2] == target) return cur;\\n            pq.push({e[1], cur});\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& t, int target) {\\n        for(int i = 0; i < t.size(); i++) t[i].push_back(i);\\n        sort(begin(t), end(t));\\n\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        priority_queue<int, vector<int>, greater<int>> free_chair;\\n        int max_v = 0;\\n        for(auto & e : t) {\\n            while(!pq.empty() && e[0] >= pq.top()[0]) {\\n                free_chair.push(pq.top()[1]);\\n                pq.pop();\\n            }\\n\\n            int cur = 0;\\n            if(!free_chair.empty()) {\\n                cur = free_chair.top();\\n                free_chair.pop();\\n            } else {\\n                cur = max_v++;\\n            }\\n\\n            if(e[2] == target) return cur;\\n            pq.push({e[1], cur});\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717987,
                "title": "priority-queue",
                "content": "```\\nint smallestChair(vector<vector<int>>& t, int f) \\n{\\n\\tvector<pair<int,int>> tt;\\n\\tfor(int i{1}; const auto & p : t) tt.push_back({p[0],i}), tt.push_back({p[1],-i}), ++i;\\n\\tsort(begin(tt), end(tt));\\n\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\tfor(int i{}; i<size(tt); ++i) pq.push(i);\\n\\tfor(int v[100001]{}; const auto & [i,j] : tt)\\n\\t\\tif(j>0)\\n\\t\\t{\\n\\t\\t\\tv[j]=pq.top(), pq.pop();\\n\\t\\t\\tif(j==f+1) return v[j];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tpq.push(v[-j]);\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint smallestChair(vector<vector<int>>& t, int f) \\n{\\n\\tvector<pair<int,int>> tt;\\n\\tfor(int i{1}; const auto & p : t) tt.push_back({p[0],i}), tt.push_back({p[1],-i}), ++i;\\n\\tsort(begin(tt), end(tt));\\n\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\tfor(int i{}; i<size(tt); ++i) pq.push(i);\\n\\tfor(int v[100001]{}; const auto & [i,j] : tt)\\n\\t\\tif(j>0)\\n\\t\\t{\\n\\t\\t\\tv[j]=pq.top(), pq.pop();\\n\\t\\t\\tif(j==f+1) return v[j];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tpq.push(v[-j]);\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2710199,
                "title": "just-answer-one-question-when-i-arrived-which-chair-is-unoccupied-sit-at-first-unoccupied-seat",
                "content": "Sort by the arrival time. Then from the second friend on, find a chair unoccupied, how?\\n\\nWhen nth friend arrived, for every chair whose leaving time less then his arrival time are empty,  choose the first one, assgin the nth value to the unoccupied one, mark nth as empty.\\n\\n```\\n\\tint imComming(int[][] times, boolean[] lefted, int commingIdx, int end) {\\n\\t\\tint firstMet = -1;\\n\\t\\tfor (int i = 0; i < commingIdx; i++) { // find the ones came earlier than me and had left before I came.\\n\\t\\t\\tif (lefted[i] || times[i][1] <= times[commingIdx][0]) {\\n\\t\\t\\t\\tif (firstMet == -1) {\\n\\t\\t\\t\\t\\tfirstMet = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlefted[i] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (firstMet != -1) {\\n\\t\\t\\ttimes[firstMet] = times[commingIdx];\\n\\t\\t\\tlefted[firstMet] = false;\\n\\t\\t\\tlefted[commingIdx] = true;\\n\\t\\t}\\n\\t\\treturn firstMet;\\n\\t}\\n\\n\\n\\tpublic int smallestChair(int[][] times, int targetFriend) {\\n\\t\\tint[] t = times[targetFriend];\\n\\t\\tArrays.sort(times, (a, b) -> a[0] - b[0]);\\n\\t\\tint p = Arrays.binarySearch(times, t, (a, b) -> a[0] - b[0]);\\n\\n\\t\\tboolean[] lefted = new boolean[p + 1];\\n\\t\\t// when I\\'m comming is there any empty chairs?\\n\\t\\tint v = -1;\\n\\t\\tfor (int i = 1; i <= p; i++) {\\n\\t\\t\\tv = imComming(times, lefted, i, p);\\n\\t\\t}\\n\\t\\treturn v == -1 ? p : v;\\n\\t}\\n```\\nThe time complexity is O(n!), it is the worst case.",
                "solutionTags": [],
                "code": "```\\n\\tint imComming(int[][] times, boolean[] lefted, int commingIdx, int end) {\\n\\t\\tint firstMet = -1;\\n\\t\\tfor (int i = 0; i < commingIdx; i++) { // find the ones came earlier than me and had left before I came.\\n\\t\\t\\tif (lefted[i] || times[i][1] <= times[commingIdx][0]) {\\n\\t\\t\\t\\tif (firstMet == -1) {\\n\\t\\t\\t\\t\\tfirstMet = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlefted[i] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (firstMet != -1) {\\n\\t\\t\\ttimes[firstMet] = times[commingIdx];\\n\\t\\t\\tlefted[firstMet] = false;\\n\\t\\t\\tlefted[commingIdx] = true;\\n\\t\\t}\\n\\t\\treturn firstMet;\\n\\t}\\n\\n\\n\\tpublic int smallestChair(int[][] times, int targetFriend) {\\n\\t\\tint[] t = times[targetFriend];\\n\\t\\tArrays.sort(times, (a, b) -> a[0] - b[0]);\\n\\t\\tint p = Arrays.binarySearch(times, t, (a, b) -> a[0] - b[0]);\\n\\n\\t\\tboolean[] lefted = new boolean[p + 1];\\n\\t\\t// when I\\'m comming is there any empty chairs?\\n\\t\\tint v = -1;\\n\\t\\tfor (int i = 1; i <= p; i++) {\\n\\t\\t\\tv = imComming(times, lefted, i, p);\\n\\t\\t}\\n\\t\\treturn v == -1 ? p : v;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2662736,
                "title": "easy-solution-t-c-o-n-logn-explained",
                "content": "**PLS UPVOTE IF you like the SOLUTION:)**\\n**IDEA:-**\\n* We use priority queue to solve this problem.\\n* First we store the friends as values where arrival time behaves as key as it is unique mentioned in the question in an unordered map.\\n* Then we sort the array according to arrival time.\\n* THEN we maintain two priority queue.\\n* One is used to store the number of chairs in MIN HEAP fashion.\\n* Other we use while we traverse through the times(Also MIN HEAP according to the delay time).\\n* When we see an  element of times we compare its arrival time with the leaving time of top element of priority queue if its less than or equal to we pop the top element and to make its chair available we push its value to curr to mark that chair is available. \\n* We push times.at(i).at(0) , friend no(from unordered map),chair no (from top of curr).\\n\\n**T.C:-** O(N log N)                 **S.C:-** O(N)\\n\\n```\\nclass cmp{  \\npublic:\\n    bool operator()(tuple<int,int,int> &t1,tuple<int,int,int> &t2){\\n        return get<0>(t1)>get<0>(t2);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        unordered_map<int,int>um;\\n        for(auto i{0};i<times.size();++i){\\n            um[times.at(i).at(0)]=i;\\n        }\\n        \\n        sort(times.begin(),times.end());\\n        \\n        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,cmp>pq;\\n        int siz=times.size()-1;\\n        priority_queue<int>curr;\\n        for(int i{0};i<=siz;++i){\\n            curr.push(-i);\\n        }\\n        \\n        for(auto i{0};i<times.size();++i){\\n            if(pq.empty()){\\n                pq.push(make_tuple(times.at(i).at(1),um[times.at(i).at(0)],curr.top()));\\n                \\n                curr.pop();\\n                \\n                if(get<1>(pq.top())==targetFriend){\\n                    return -get<2>(pq.top());\\n                }\\n                continue;    \\n            }\\n            \\n            while(!pq.empty() && (get<0>(pq.top()))<=times.at(i).at(0)){\\n                int chair=-get<2>(pq.top());\\n                if(get<1>(pq.top())==targetFriend){\\n                    return chair;\\n                }\\n                curr.push(-chair);\\n                pq.pop();\\n                \\n            }\\n            pq.push(make_tuple(times.at(i).at(1),um[times.at(i).at(0)],curr.top()));\\n\\n            if(get<1>(pq.top())==targetFriend){\\n                return -get<2>(pq.top());\\n            }\\n            curr.pop();\\n            \\n        }\\n        while(!pq.empty()){\\n            if(get<1>(pq.top())==targetFriend){\\n                return -get<2>(pq.top());\\n            }\\n            pq.pop();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass cmp{  \\npublic:\\n    bool operator()(tuple<int,int,int> &t1,tuple<int,int,int> &t2){\\n        return get<0>(t1)>get<0>(t2);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        unordered_map<int,int>um;\\n        for(auto i{0};i<times.size();++i){\\n            um[times.at(i).at(0)]=i;\\n        }\\n        \\n        sort(times.begin(),times.end());\\n        \\n        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,cmp>pq;\\n        int siz=times.size()-1;\\n        priority_queue<int>curr;\\n        for(int i{0};i<=siz;++i){\\n            curr.push(-i);\\n        }\\n        \\n        for(auto i{0};i<times.size();++i){\\n            if(pq.empty()){\\n                pq.push(make_tuple(times.at(i).at(1),um[times.at(i).at(0)],curr.top()));\\n                \\n                curr.pop();\\n                \\n                if(get<1>(pq.top())==targetFriend){\\n                    return -get<2>(pq.top());\\n                }\\n                continue;    \\n            }\\n            \\n            while(!pq.empty() && (get<0>(pq.top()))<=times.at(i).at(0)){\\n                int chair=-get<2>(pq.top());\\n                if(get<1>(pq.top())==targetFriend){\\n                    return chair;\\n                }\\n                curr.push(-chair);\\n                pq.pop();\\n                \\n            }\\n            pq.push(make_tuple(times.at(i).at(1),um[times.at(i).at(0)],curr.top()));\\n\\n            if(get<1>(pq.top())==targetFriend){\\n                return -get<2>(pq.top());\\n            }\\n            curr.pop();\\n            \\n        }\\n        while(!pq.empty()){\\n            if(get<1>(pq.top())==targetFriend){\\n                return -get<2>(pq.top());\\n            }\\n            pq.pop();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594819,
                "title": "javascript-hashmap-and-min-heap-explanation",
                "content": "The general idea of this approach is to sort all the arrive and leave times separately and iterate over them. We will allocate chairs and make them available again based on the type of event happening at that time (arriving or leaving).\\n\\nWe need to recognize a few things before starting the problem:\\n- Arrival times are all unique\\n- Need to keep track of the lowest number chair at all times\\n- The problem says there are infinitely many chairs, however at most n number of people will be sitting so there are n chairs at most\\n\\n\\n**Step 1: Decide on data structures**\\n- Store target Arrival time since all arrival times are unique and we are given a target index.\\n- We need access to the closest chair at all times. Since chairs are numbered 0 to n-1, a min Heap would be best to keep optimal access to this value\\n- Arrival times mean we need to allocate a chair for a person. That chair will then become available at the paired leaving time. We can use a hashmap to map the arrival time to the leaving time and another hashmap to store chairs to become available at that leaving time\\n\\t- ```timesMap[arrivalTime[i]]: leavingTime[i] --> chairsMap[leavingTime[i]]: [chair0, chair1, chair2, ...]```\\n- An array named \"events\" that we will later sort and will tell us whether to allocate a chair or make it available again\\n\\n**Step 2: Iterate over input array**\\n- Add index to min heap, that will be the earliest chair available\\n- Add the arrival event and leaving event.\\n\\t- Events labeled with 1 will be arrival events, -1 will be leaving events\\n\\t- Arrival --> ```events[i] = [arrivalTime, 1]```\\n\\t- Leave --> ```events[i] = [leaveTime, -1]```\\n- Map each arrival time to its paired leave time\\n- Map each unique leave time to an array that will hold chair numbers\\n\\n**Step 3: Sort events**\\n- Sort the events array in ascending order based first on the time, second on the type of event\\n- If there is an arrival and leave at the same time then we want the leave to happen first so the chairs become available for the arriving person\\n\\n**Step 4: Iterate over events**\\nWe now have a sorted array of times, each labeled with the type of event (arriving or leaving). Each elemetn in the events array is in the format ```events[i] = [time, typeOfEvent]```\\n- Case 1: We\\'ve hit our target time and its labeled \"1\" so its the arrival event of our target person. Return the lowest value chair.\\n- Case 2: Arrival event. Pop the chair value off our heap and find the leave time that it becomes available again by follow the hashmap.\\n- Case 3: Leave event: Make all chairs stored at that time available again by popping all the values and adding it back to the min Heap\\n\\t- If a leave time is equal to the target time, it doesnt matter since we also sorted leave events to happend before arrival events at the same time.\\n\\n*Complexity Analysis*\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(n)\\n```\\nvar smallestChair = function(times, targetFriend) {\\n  const targetArrival = times[targetFriend][0];\\n  const heap = new MinPriorityQueue();\\n  const events = [];\\n  const timesMap = {};\\n  const leaveTimesAndChairs = {};\\n  \\n  for (let i = 0; i < times.length; i++) {\\n    let [arrive, leave] = times[i];\\n    heap.enqueue(i);\\n    events.push([arrive, 1]);\\n    events.push([leave, -1]);\\n    timesMap[arrive] = leave;\\n    leaveTimesAndChairs[leave] = [];\\n  }\\n  \\n  events.sort((a,b) => {\\n    if (a[0] === b[0]) return a[1] - b[1];\\n    return a[0] - b[0];\\n  });\\n\\n  for (let e of events) {\\n    if (e[0] === targetArrival && e[1] === 1) {\\n      return heap.dequeue().element;\\n    } else if (e[1] === 1) {\\n      let leaveTime = timesMap[e[0]];\\n      leaveTimesAndChairs[leaveTime].push(heap.dequeue().element);\\n    } else {\\n\\t  // this is only an O(n) operation since it only pops previously inputted values, which are at most n\\n      while (leaveTimesAndChairs[e[0]].length) heap.enqueue(leaveTimesAndChairs[e[0]].pop());\\n    }\\n  }\\n};\\n  ```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```timesMap[arrivalTime[i]]: leavingTime[i] --> chairsMap[leavingTime[i]]: [chair0, chair1, chair2, ...]```\n```events[i] = [arrivalTime, 1]```\n```events[i] = [leaveTime, -1]```\n```events[i] = [time, typeOfEvent]```\n```\\nvar smallestChair = function(times, targetFriend) {\\n  const targetArrival = times[targetFriend][0];\\n  const heap = new MinPriorityQueue();\\n  const events = [];\\n  const timesMap = {};\\n  const leaveTimesAndChairs = {};\\n  \\n  for (let i = 0; i < times.length; i++) {\\n    let [arrive, leave] = times[i];\\n    heap.enqueue(i);\\n    events.push([arrive, 1]);\\n    events.push([leave, -1]);\\n    timesMap[arrive] = leave;\\n    leaveTimesAndChairs[leave] = [];\\n  }\\n  \\n  events.sort((a,b) => {\\n    if (a[0] === b[0]) return a[1] - b[1];\\n    return a[0] - b[0];\\n  });\\n\\n  for (let e of events) {\\n    if (e[0] === targetArrival && e[1] === 1) {\\n      return heap.dequeue().element;\\n    } else if (e[1] === 1) {\\n      let leaveTime = timesMap[e[0]];\\n      leaveTimesAndChairs[leaveTime].push(heap.dequeue().element);\\n    } else {\\n\\t  // this is only an O(n) operation since it only pops previously inputted values, which are at most n\\n      while (leaveTimesAndChairs[e[0]].length) heap.enqueue(leaveTimesAndChairs[e[0]].pop());\\n    }\\n  }\\n};\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2593775,
                "title": "c-two-min-heaps",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n\\t\\t\\tpriority_queue<int,vector<int>,greater<int>> pq;\\n\\t\\t\\tpriority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pqf;\\n\\t\\t\\tint res=times[targetFriend][0];\\n\\n\\t\\t\\tsort(times.begin(),times.end());\\n\\t\\t\\tfor(int i=0;i<times.size();i++) pq.push(i);\\n\\n\\t\\t\\tfor(int i=0;i<times.size();i++) {\\n\\t\\t\\t\\tint arr=times[i][0];\\n\\t\\t\\t\\tint dep=times[i][1];\\n\\t\\t\\t\\twhile(pqf.size()&&pqf.top()[0]<=arr) {\\n\\t\\t\\t\\t\\tpq.push(pqf.top()[1]);\\n\\t\\t\\t\\t\\tpqf.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpqf.push({dep,pq.top()});\\n\\t\\t\\t\\tif(arr==res) return pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n\\t\\t\\tpriority_queue<int,vector<int>,greater<int>> pq;\\n\\t\\t\\tpriority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pqf;\\n\\t\\t\\tint res=times[targetFriend][0];\\n\\n\\t\\t\\tsort(times.begin(),times.end());\\n\\t\\t\\tfor(int i=0;i<times.size();i++) pq.push(i);\\n\\n\\t\\t\\tfor(int i=0;i<times.size();i++) {\\n\\t\\t\\t\\tint arr=times[i][0];\\n\\t\\t\\t\\tint dep=times[i][1];\\n\\t\\t\\t\\twhile(pqf.size()&&pqf.top()[0]<=arr) {\\n\\t\\t\\t\\t\\tpq.push(pqf.top()[1]);\\n\\t\\t\\t\\t\\tpqf.pop();\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2572501,
                "title": "c-solution-min-heap",
                "content": "heap sort sorting data index\\nsorting key set as data[0] \\nwhen we pop or push node to different heap\\nwe should update sorting key\\n```\\nint cmp(const void*a,const void*b){\\n    return (*(int**)a)[0]-(*(int**)b)[0];\\n}\\nvoid heapdown(int **chair,int *heap,int heapsize){\\n    int curr = 1;\\n    int child = curr*2;\\n    while(child<=heapsize){\\n        if(child+1<=heapsize && chair[heap[child+1]][0]<chair[heap[child]][0])\\n            child++;\\n        if(chair[heap[curr]][0]<chair[heap[child]][0])\\n            break;\\n        int tmp = heap[child];\\n        heap[child] = heap[curr];\\n        heap[curr] = tmp;\\n        \\n        curr = child;\\n        child*=2;\\n    }\\n}\\nvoid heapup(int **chair,int *heap,int heapidx,int val){\\n    int curr = heapidx;\\n    int father = curr/2;\\n    while(father>=1){\\n        if(chair[heap[father]][0]<=chair[val][0])\\n            break;\\n        heap[curr] = heap[father];\\n        curr = father;\\n        father/=2;\\n    }\\n    heap[curr] = val;\\n}\\nint smallestChair(int** times, int timesSize, int* timesColSize, int targetFriend){\\n    int ans = 0;\\n    int **chair = malloc(timesSize*sizeof(int*));\\n    int **qdata = malloc(timesSize*sizeof(int*));\\n    int *valid = malloc((timesSize+1)*sizeof(int));\\n    int *invalid  = malloc((timesSize+1)*sizeof(int));\\n    int valididx = timesSize;\\n    int invalididx = 0;\\n    for(int i=0;i<timesSize;i++){\\n        qdata[i] = malloc(3*sizeof(int));\\n        qdata[i][0] = times[i][0];\\n        qdata[i][1] = times[i][1];\\n        qdata[i][2] = i;\\n        chair[i] = malloc(3*sizeof(int));\\n        chair[i][0] = i;\\n        chair[i][1] = i;\\n        chair[i][2] = 0;\\n        valid[i+1] = i;\\n    }\\n    qsort(qdata,timesSize,sizeof(qdata[0]),cmp);\\n    for(int i=0;i<timesSize;i++){\\n        //invalid->valid\\n        while(invalididx>0 && chair[invalid[1]][0]<=qdata[i][0]){\\n            int target = invalid[1];\\n            chair[target][0] = chair[target][1];\\n            heapup(chair,valid,++valididx,target);\\n            invalid[1] = invalid[invalididx--];\\n            heapdown(chair,invalid,invalididx);    \\n        }\\n        //valid->invalid\\n        if(targetFriend==qdata[i][2])\\n            return chair[valid[1]][1];\\n        int target = valid[1];\\n        chair[target][0] = chair[target][2] = qdata[i][1];\\n        heapup(chair,invalid,++invalididx,target);\\n        valid[1] = valid[valididx--];\\n        heapdown(chair,valid,valididx);\\n    }\\n    return ans;//no use\\n}\\n```\\nusing same template\\nhttps://leetcode.com/problems/meeting-rooms-iii/discuss/2549669/C-solution-2-min-heap",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp(const void*a,const void*b){\\n    return (*(int**)a)[0]-(*(int**)b)[0];\\n}\\nvoid heapdown(int **chair,int *heap,int heapsize){\\n    int curr = 1;\\n    int child = curr*2;\\n    while(child<=heapsize){\\n        if(child+1<=heapsize && chair[heap[child+1]][0]<chair[heap[child]][0])\\n            child++;\\n        if(chair[heap[curr]][0]<chair[heap[child]][0])\\n            break;\\n        int tmp = heap[child];\\n        heap[child] = heap[curr];\\n        heap[curr] = tmp;\\n        \\n        curr = child;\\n        child*=2;\\n    }\\n}\\nvoid heapup(int **chair,int *heap,int heapidx,int val){\\n    int curr = heapidx;\\n    int father = curr/2;\\n    while(father>=1){\\n        if(chair[heap[father]][0]<=chair[val][0])\\n            break;\\n        heap[curr] = heap[father];\\n        curr = father;\\n        father/=2;\\n    }\\n    heap[curr] = val;\\n}\\nint smallestChair(int** times, int timesSize, int* timesColSize, int targetFriend){\\n    int ans = 0;\\n    int **chair = malloc(timesSize*sizeof(int*));\\n    int **qdata = malloc(timesSize*sizeof(int*));\\n    int *valid = malloc((timesSize+1)*sizeof(int));\\n    int *invalid  = malloc((timesSize+1)*sizeof(int));\\n    int valididx = timesSize;\\n    int invalididx = 0;\\n    for(int i=0;i<timesSize;i++){\\n        qdata[i] = malloc(3*sizeof(int));\\n        qdata[i][0] = times[i][0];\\n        qdata[i][1] = times[i][1];\\n        qdata[i][2] = i;\\n        chair[i] = malloc(3*sizeof(int));\\n        chair[i][0] = i;\\n        chair[i][1] = i;\\n        chair[i][2] = 0;\\n        valid[i+1] = i;\\n    }\\n    qsort(qdata,timesSize,sizeof(qdata[0]),cmp);\\n    for(int i=0;i<timesSize;i++){\\n        //invalid->valid\\n        while(invalididx>0 && chair[invalid[1]][0]<=qdata[i][0]){\\n            int target = invalid[1];\\n            chair[target][0] = chair[target][1];\\n            heapup(chair,valid,++valididx,target);\\n            invalid[1] = invalid[invalididx--];\\n            heapdown(chair,invalid,invalididx);    \\n        }\\n        //valid->invalid\\n        if(targetFriend==qdata[i][2])\\n            return chair[valid[1]][1];\\n        int target = valid[1];\\n        chair[target][0] = chair[target][2] = qdata[i][1];\\n        heapup(chair,invalid,++invalididx,target);\\n        valid[1] = valid[valididx--];\\n        heapdown(chair,valid,valididx);\\n    }\\n    return ans;//no use\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539809,
                "title": "tried-solving-with-a-new-idea-using-single-min-heap-getting-runtime-error",
                "content": "The idea here is to create a vector of moments where a moments is of the format : {time instant, type of moment{1- for departure, 0 - for arrival}, person index }\\neg. if 5th person arrives at 6 and leaves at 10,  the moment corresponding to person\\'s arrival will be {6,0,5} and the moment corresponding to person\\'s departure will be {10,1,5}\\n\\nsorted the moments array with custom comparator {if two moments have same time instant, the one with type = departure will be placed before the other}\\n\\nOnce moments array is sorted, just traverse it and assign chairs using a priority queue\\nfor type = arrival => take the top of prioity queue\\nfor type = departure => push the assigned chair to prioity queue\\n\\nApproach seems to be correct but getting a runtime error :(\\ntest case: \\n```\\n[[3,100000],[37,100000],[34,100000],[16,100000],[28,100000],[19,100000],[14,100000],[29,100000],[5,100000],[9,100000],[25,100000],[18,100000],[31,100000],[17,100000],[12,100000],[36,100000],[30,100000],[13,100000],[27,100000],[10,100000],[21,100000],[38,100000],[11,100000],[46,100000],[2,100000],[33,100000],[20,100000],[8,100000],[35,100000],[43,100000],[23,100000],[22,100000],[15,100000],[44,100000],[45,100000],[7,100000],[24,100000],[42,100000],[6,100000],[1,100000],[26,100000],[39,100000],[32,100000],[40,100000],[41,100000],[4,100000]]\\n23\\n```\\n\\n\\nHelp would be appreciated!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a, vector<int> &b)\\n    {\\n        if(a[0]==b[0])\\n        {\\n            if(a[1]==1) return true;\\n            if(b[1]==1) return false;\\n            return true;\\n        }\\n        return (a[0]<b[0]);\\n    }\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        vector<int> chairs(n,-1);\\n        vector<vector<int>> moments;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(int i =0;i<n;i++)   pq.push(i);\\n        for(int i=0;i<n;i++)\\n        {\\n            moments.push_back({times[i][0],0,i});\\n            moments.push_back({times[i][1],1,i});\\n        }\\n        sort(moments.begin(),moments.end(),comp);\\n        for(int i=0;i<2*n;i++)\\n        {\\n            int type = moments[i][1];\\n            int time_instant = moments[i][0];\\n            int person =  moments[i][2];\\n            if(type==0)\\n            {\\n                int top = pq.top();\\n                pq.pop();\\n                chairs[person] = top;\\n                \\n                //cout<<time_instant<<\": PERSON \"<<person <<\" is assigned chair \"<<top<<endl;\\n                if(person==targetFriend)\\n                    return top;\\n            }\\n            else\\n            {\\n                //cout<<time_instant<<\": PERSON \"<<person <<\" leaves chair \"<<chairs[person]<<endl;\\n                pq.push(chairs[person]);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n[[3,100000],[37,100000],[34,100000],[16,100000],[28,100000],[19,100000],[14,100000],[29,100000],[5,100000],[9,100000],[25,100000],[18,100000],[31,100000],[17,100000],[12,100000],[36,100000],[30,100000],[13,100000],[27,100000],[10,100000],[21,100000],[38,100000],[11,100000],[46,100000],[2,100000],[33,100000],[20,100000],[8,100000],[35,100000],[43,100000],[23,100000],[22,100000],[15,100000],[44,100000],[45,100000],[7,100000],[24,100000],[42,100000],[6,100000],[1,100000],[26,100000],[39,100000],[32,100000],[40,100000],[41,100000],[4,100000]]\\n23\\n```\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a, vector<int> &b)\\n    {\\n        if(a[0]==b[0])\\n        {\\n            if(a[1]==1) return true;\\n            if(b[1]==1) return false;\\n            return true;\\n        }\\n        return (a[0]<b[0]);\\n    }\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        vector<int> chairs(n,-1);\\n        vector<vector<int>> moments;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(int i =0;i<n;i++)   pq.push(i);\\n        for(int i=0;i<n;i++)\\n        {\\n            moments.push_back({times[i][0],0,i});\\n            moments.push_back({times[i][1],1,i});\\n        }\\n        sort(moments.begin(),moments.end(),comp);\\n        for(int i=0;i<2*n;i++)\\n        {\\n            int type = moments[i][1];\\n            int time_instant = moments[i][0];\\n            int person =  moments[i][2];\\n            if(type==0)\\n            {\\n                int top = pq.top();\\n                pq.pop();\\n                chairs[person] = top;\\n                \\n                //cout<<time_instant<<\": PERSON \"<<person <<\" is assigned chair \"<<top<<endl;\\n                if(person==targetFriend)\\n                    return top;\\n            }\\n            else\\n            {\\n                //cout<<time_instant<<\": PERSON \"<<person <<\" leaves chair \"<<chairs[person]<<endl;\\n                pq.push(chairs[person]);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2507894,
                "title": "80-tc-and-67-sc-easy-python-solution",
                "content": "```\\ndef smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n\\theap, l = [], SortedList()\\n\\tm = 0\\n\\tfor i in range(len(times)):\\n\\t\\ttimes[i].append(i)\\n\\ttimes.sort()\\n\\tfor i in range(len(times)):\\n\\t\\twhile(heap):\\n\\t\\t\\tend, chair = heappop(heap)\\n\\t\\t\\tif(end > times[i][0]):\\n\\t\\t\\t\\theappush(heap, (end, chair))\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tl.add(chair)\\n\\t\\tif(times[i][2] == targetFriend):\\n\\t\\t\\tif(not l):\\n\\t\\t\\t\\treturn m\\n\\t\\t\\treturn l.pop(0)\\n\\t\\tif(not l):\\n\\t\\t\\theappush(heap, (times[i][1], m))\\n\\t\\t\\tm += 1\\n\\t\\telse:\\n\\t\\t\\theappush(heap, (times[i][1], l.pop(0)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n\\theap, l = [], SortedList()\\n\\tm = 0\\n\\tfor i in range(len(times)):\\n\\t\\ttimes[i].append(i)\\n\\ttimes.sort()\\n\\tfor i in range(len(times)):\\n\\t\\twhile(heap):\\n\\t\\t\\tend, chair = heappop(heap)\\n\\t\\t\\tif(end > times[i][0]):\\n\\t\\t\\t\\theappush(heap, (end, chair))\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tl.add(chair)\\n\\t\\tif(times[i][2] == targetFriend):\\n\\t\\t\\tif(not l):\\n\\t\\t\\t\\treturn m\\n\\t\\t\\treturn l.pop(0)\\n\\t\\tif(not l):\\n\\t\\t\\theappush(heap, (times[i][1], m))\\n\\t\\t\\tm += 1\\n\\t\\telse:\\n\\t\\t\\theappush(heap, (times[i][1], l.pop(0)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2502527,
                "title": "c-not-elegant-but-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        vector<vector<int>> enter_t(n), exit_t(n);\\n\\t\\t/* Split the entry and exit times */\\n        for (int i = 0; i < n; i++) {\\n            enter_t[i].push_back(times[i][0]);\\n            enter_t[i].push_back(i);\\n            exit_t[i].push_back(times[i][1]);\\n            exit_t[i].push_back(i);\\n        }\\n\\t\\t\\n\\t\\t/*Sort the entry and exit times */\\n        std::sort(enter_t.begin(), enter_t.end(), [](const vector<int> &a,\\n                                          const vector<int> &b){\\n            return a[0] < b[0];\\n        });\\n        std::sort(exit_t.begin(), exit_t.end(), [](const vector<int> &a,\\n                                          const vector<int> &b){\\n            return a[0] < b[0];\\n        });\\n        \\n        int i = 1, j = 0, chair = 0;\\n\\t\\t\\n\\t\\t/* if the first person who enters is our targetFried, return the answer*/\\n        if (enter_t[0][1] == targetFriend) \\n            return 0;\\n        \\n\\t\\t/* Populate Min Priority queue with chairs */\\n        std::priority_queue<int, vector<int>, std::greater<int>> pq;\\n        for (int i = 1; i < n+1; i++) pq.push(i);\\n        \\n\\t\\t/* Using unordered_map to store person and lowest assigned chair */\\n        unordered_map<int, int> user_chair;\\n        user_chair[enter_t[0][1]] = 0;\\n        \\n        while (i < n && j < n) {\\n            if (enter_t[i][0] < exit_t[j][0]) {\\n    \\t\\t    /* When next person enters the room, he gets assigned lowest chair from priority Queue*/\\n                chair = pq.top(); pq.pop();\\n                user_chair[enter_t[i][1]] = chair;\\n                if (enter_t[i][1] == targetFriend)\\n                    break;\\n                i++;\\n            } else if (enter_t[i][0] >= exit_t[j][0]) {\\n\\t\\t\\t   /* When person exits, his chair is moved back to Min priority Queue */\\n                chair = user_chair[exit_t[j][1]];\\n                pq.push(chair);\\n                j++;\\n            }\\n        }\\n        return chair;\\n    }\\n};\\n```\\n\\n/* \\n * NOTE:- On second thought, I could have only used std::map to solve the above problem, but above was my first attempt trying to solve the problem using simulation.\\n*/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        vector<vector<int>> enter_t(n), exit_t(n);\\n\\t\\t/* Split the entry and exit times */\\n        for (int i = 0; i < n; i++) {\\n            enter_t[i].push_back(times[i][0]);\\n            enter_t[i].push_back(i);\\n            exit_t[i].push_back(times[i][1]);\\n            exit_t[i].push_back(i);\\n        }\\n\\t\\t\\n\\t\\t/*Sort the entry and exit times */\\n        std::sort(enter_t.begin(), enter_t.end(), [](const vector<int> &a,\\n                                          const vector<int> &b){\\n            return a[0] < b[0];\\n        });\\n        std::sort(exit_t.begin(), exit_t.end(), [](const vector<int> &a,\\n                                          const vector<int> &b){\\n            return a[0] < b[0];\\n        });\\n        \\n        int i = 1, j = 0, chair = 0;\\n\\t\\t\\n\\t\\t/* if the first person who enters is our targetFried, return the answer*/\\n        if (enter_t[0][1] == targetFriend) \\n            return 0;\\n        \\n\\t\\t/* Populate Min Priority queue with chairs */\\n        std::priority_queue<int, vector<int>, std::greater<int>> pq;\\n        for (int i = 1; i < n+1; i++) pq.push(i);\\n        \\n\\t\\t/* Using unordered_map to store person and lowest assigned chair */\\n        unordered_map<int, int> user_chair;\\n        user_chair[enter_t[0][1]] = 0;\\n        \\n        while (i < n && j < n) {\\n            if (enter_t[i][0] < exit_t[j][0]) {\\n    \\t\\t    /* When next person enters the room, he gets assigned lowest chair from priority Queue*/\\n                chair = pq.top(); pq.pop();\\n                user_chair[enter_t[i][1]] = chair;\\n                if (enter_t[i][1] == targetFriend)\\n                    break;\\n                i++;\\n            } else if (enter_t[i][0] >= exit_t[j][0]) {\\n\\t\\t\\t   /* When person exits, his chair is moved back to Min priority Queue */\\n                chair = user_chair[exit_t[j][1]];\\n                pq.push(chair);\\n                j++;\\n            }\\n        }\\n        return chair;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480526,
                "title": "efficient-java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n  public int smallestChair(int[][] times, int targetFriend) {\\n\\n    int targetTime = times[targetFriend][0];\\n    \\n    Arrays.sort(times, (a,b) -> a[0] - b[0]);\\n    PriorityQueue<Integer> availableChairs = new PriorityQueue<>();\\n\\t\\n\\t//All charis from index 0 to length of times are available\\n    for(int i=0; i<times.length; i++)\\n      availableChairs.offer(i);\\n    \\n\\t//array in PriorityQueue holds smallest idx of available chair and departure time\\n\\t//prioritize the items of the queue based on departure time\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n    \\n    int res = 0;\\n    for(int i=0; i<times.length && times[i][0] <= targetTime; i++){\\n      \\n      while(!pq.isEmpty() && pq.peek()[1] <= times[i][0]){\\n        int[] item = pq.poll();\\n        availableChairs.offer(item[0]); //make this chair available\\n      }\\n      \\n\\t   //get the smallest idx chair that is available\\n\\t   //assign it to the current item and poll it from the availableChairs PriorityQueue so that its not available \\n      int smallestIdxChair = availableChairs.poll();\\n      pq.offer(new int[]{smallestIdxChair, times[i][1]});\\n      res = smallestIdxChair;\\n    }\\n    \\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int smallestChair(int[][] times, int targetFriend) {\\n\\n    int targetTime = times[targetFriend][0];\\n    \\n    Arrays.sort(times, (a,b) -> a[0] - b[0]);\\n    PriorityQueue<Integer> availableChairs = new PriorityQueue<>();\\n\\t\\n\\t//All charis from index 0 to length of times are available\\n    for(int i=0; i<times.length; i++)\\n      availableChairs.offer(i);\\n    \\n\\t//array in PriorityQueue holds smallest idx of available chair and departure time\\n\\t//prioritize the items of the queue based on departure time\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n    \\n    int res = 0;\\n    for(int i=0; i<times.length && times[i][0] <= targetTime; i++){\\n      \\n      while(!pq.isEmpty() && pq.peek()[1] <= times[i][0]){\\n        int[] item = pq.poll();\\n        availableChairs.offer(item[0]); //make this chair available\\n      }\\n      \\n\\t   //get the smallest idx chair that is available\\n\\t   //assign it to the current item and poll it from the availableChairs PriorityQueue so that its not available \\n      int smallestIdxChair = availableChairs.poll();\\n      pq.offer(new int[]{smallestIdxChair, times[i][1]});\\n      res = smallestIdxChair;\\n    }\\n    \\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450898,
                "title": "c-sortedset",
                "content": "We can process *events* (friend enters, friend leave sorted by times) one after one, while tracking `free` seats:  \\n\\n```\\npublic class Solution {\\n        \\n    private static IEnumerable<(int time, int direction, int index)> Sequence(int[][] times) {\\n        for (int i = 0; i < times.Length; ++i) {\\n            yield return (time : times[i][0], direction : +1, index : i);\\n            \\n            yield return (time : times[i][1], direction : -1, index : i);\\n        }\\n    }\\n    \\n    public int SmallestChair(int[][] times, int targetFriend) {\\n        var seq = Sequence(times)\\n            .OrderBy(item => item.time)\\n            .ThenBy(item => item.direction);\\n        \\n        SortedSet<int> free = new(Enumerable.Range(0, times.Length));\\n        \\n        Dictionary<int, int> seats = new();\\n        \\n        foreach (var item in seq) \\n            if (item.direction == 1) {\\n                int at = free.Min;\\n                \\n                seats.Add(item.index, at);\\n                \\n                free.Remove(at);\\n                \\n                if (targetFriend == item.index) \\n                    return at;\\n            }\\n            else \\n                free.Add(seats[item.index]);\\n        \\n        return free.Min;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n        \\n    private static IEnumerable<(int time, int direction, int index)> Sequence(int[][] times) {\\n        for (int i = 0; i < times.Length; ++i) {\\n            yield return (time : times[i][0], direction : +1, index : i);\\n            \\n            yield return (time : times[i][1], direction : -1, index : i);\\n        }\\n    }\\n    \\n    public int SmallestChair(int[][] times, int targetFriend) {\\n        var seq = Sequence(times)\\n            .OrderBy(item => item.time)\\n            .ThenBy(item => item.direction);\\n        \\n        SortedSet<int> free = new(Enumerable.Range(0, times.Length));\\n        \\n        Dictionary<int, int> seats = new();\\n        \\n        foreach (var item in seq) \\n            if (item.direction == 1) {\\n                int at = free.Min;\\n                \\n                seats.Add(item.index, at);\\n                \\n                free.Remove(at);\\n                \\n                if (targetFriend == item.index) \\n                    return at;\\n            }\\n            else \\n                free.Add(seats[item.index]);\\n        \\n        return free.Min;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429357,
                "title": "heap-solution-pyhton",
                "content": "```\\nheap=[]\\n        req=times[targetFriend]\\n        times.sort()\\n        heapq.heapify(heap)\\n        chairno=0\\n        for i in range(len(times)):\\n            if heap and heap[0][0]<=times[i][0]:\\n                chairpops=[]\\n                while heap and heap[0][0]<=times[i][0]:\\n                    chairpops.append(heapq.heappop(heap))\\n                    \\n                chairpops.sort(key=lambda x:x[1],reverse=True)\\n                z=chairpops.pop()\\n                for x in chairpops:\\n                    heapq.heappush(heap,x)\\n                heapq.heappush(heap,(times[i][1],z[1]))\\n                if times[i]==req:\\n                    return z[1]\\n            else:\\n                if times[i]==req:\\n                    return chairno\\n                else:\\n                    heapq.heappush(heap,(times[i][1],chairno))\\n                    chairno+=1\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nheap=[]\\n        req=times[targetFriend]\\n        times.sort()\\n        heapq.heapify(heap)\\n        chairno=0\\n        for i in range(len(times)):\\n            if heap and heap[0][0]<=times[i][0]:\\n                chairpops=[]\\n                while heap and heap[0][0]<=times[i][0]:\\n                    chairpops.append(heapq.heappop(heap))\\n                    \\n                chairpops.sort(key=lambda x:x[1],reverse=True)\\n                z=chairpops.pop()\\n                for x in chairpops:\\n                    heapq.heappush(heap,x)\\n                heapq.heappush(heap,(times[i][1],z[1]))\\n                if times[i]==req:\\n                    return z[1]\\n            else:\\n                if times[i]==req:\\n                    return chairno\\n                else:\\n                    heapq.heappush(heap,(times[i][1],chairno))\\n                    chairno+=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2408507,
                "title": "c-priority-queue-2-minheaps",
                "content": "we use 2 priority queues (minheaps) one stores the lowest number of chair available and the other one stores a pair {time till chair occupied, chair occupied} , before every occupation we pre empt the chairs which should have been vacated before current time and then allocate chair.\\n\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        for(int i=0; i<times.size(); i++) times[i].push_back(i);\\n        sort(times.begin(),times.end());\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> pq;\\n        priority_queue<int,vector<int>,greater<>> chairs;\\n        for(int i=0; i<2e4; i++) chairs.push(i);\\n        for(int i=0; i<times.size(); i++) {\\n            while(!pq.empty() and pq.top().first <= times[i][0]) {\\n                auto p = pq.top(); pq.pop();\\n                chairs.push(p.second);\\n            }\\n            if(times[i][2]==targetFriend) return chairs.top();\\n            pq.push({times[i][1],chairs.top()});\\n            chairs.pop();\\n        }\\n        return chairs.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        for(int i=0; i<times.size(); i++) times[i].push_back(i);\\n        sort(times.begin(),times.end());\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> pq;\\n        priority_queue<int,vector<int>,greater<>> chairs;\\n        for(int i=0; i<2e4; i++) chairs.push(i);\\n        for(int i=0; i<times.size(); i++) {\\n            while(!pq.empty() and pq.top().first <= times[i][0]) {\\n                auto p = pq.top(); pq.pop();\\n                chairs.push(p.second);\\n            }\\n            if(times[i][2]==targetFriend) return chairs.top();\\n            pq.push({times[i][1],chairs.top()});\\n            chairs.pop();\\n        }\\n        return chairs.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348250,
                "title": "python-only-2-heap-trees",
                "content": "After sort the times list first (according to the arrival time), then just need to maintain 2 heap trees; \\n(tree1) One for available chairs till the i th person (with chair id);\\n(tree2) One for occupied chairs (occupied end time, chair id) ;\\nWhen a new person i coming, add the ith chair to tree1;\\nThen check tree 2, move all the chairs in tree2 which occupied end time <= i th person arrival time to tree1;\\nAfter maintain tree 2, the top node of tree1 is the i th person should sit.\\n\\nimport heapq\\nclass Solution(object):\\n    def smallestChair(self, times, targetFriend):\\n        \\n        targetTime = times[targetFriend][0]\\n        times.sort(key = lambda x: x[0])\\n        \\n        nLen = len(times)\\n        \\n        chairs = []\\n        occ = []\\n        \\n        heapq.heapify(chairs)\\n        heapq.heapify(occ)\\n        \\n        for i in range(nLen):\\n    \\n            heapq.heappush(chairs, i)\\n            \\n            while(len(occ) > 0 and occ[0][0] <= times[i][0]):   \\n                heapq.heappush(chairs, heapq.heappop(occ)[1])\\n            \\n            tmp = heapq.heappop(chairs)\\n            heapq.heappush(occ, [times[i][1], tmp])\\n            \\n            if(times[i][0] == targetTime):\\n                return tmp\\n            \\n",
                "solutionTags": [],
                "code": "After sort the times list first (according to the arrival time), then just need to maintain 2 heap trees; \\n(tree1) One for available chairs till the i th person (with chair id);\\n(tree2) One for occupied chairs (occupied end time, chair id) ;\\nWhen a new person i coming, add the ith chair to tree1;\\nThen check tree 2, move all the chairs in tree2 which occupied end time <= i th person arrival time to tree1;\\nAfter maintain tree 2, the top node of tree1 is the i th person should sit.\\n\\nimport heapq\\nclass Solution(object):\\n    def smallestChair(self, times, targetFriend):\\n        \\n        targetTime = times[targetFriend][0]\\n        times.sort(key = lambda x: x[0])\\n        \\n        nLen = len(times)\\n        \\n        chairs = []\\n        occ = []\\n        \\n        heapq.heapify(chairs)\\n        heapq.heapify(occ)\\n        \\n        for i in range(nLen):\\n    \\n            heapq.heappush(chairs, i)\\n            \\n            while(len(occ) > 0 and occ[0][0] <= times[i][0]):   \\n                heapq.heappush(chairs, heapq.heappop(occ)[1])\\n            \\n            tmp = heapq.heappop(chairs)\\n            heapq.heappush(occ, [times[i][1], tmp])\\n            \\n            if(times[i][0] == targetTime):\\n                return tmp\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2319961,
                "title": "a-clean-solution",
                "content": "Eliminate everyone who will take chair 0, then chair 1, 2 ... and so on, until we find the target.\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int target) {\\n        map<int,pair<int,int>> intervals;\\n        for (int i = 0; i < times.size(); ++i) {\\n            intervals[times[i][0]] = {times[i][1], i};\\n        }\\n        int seat = 0;\\n        while (intervals.size()) {\\n            auto it = intervals.begin();\\n            while (it != intervals.end()) {\\n                auto [end, i] = it->second;\\n                if (i == target) return seat;\\n                intervals.erase(it);\\n                it = intervals.lower_bound(end);\\n            }\\n            ++seat;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int target) {\\n        map<int,pair<int,int>> intervals;\\n        for (int i = 0; i < times.size(); ++i) {\\n            intervals[times[i][0]] = {times[i][1], i};\\n        }\\n        int seat = 0;\\n        while (intervals.size()) {\\n            auto it = intervals.begin();\\n            while (it != intervals.end()) {\\n                auto [end, i] = it->second;\\n                if (i == target) return seat;\\n                intervals.erase(it);\\n                it = intervals.lower_bound(end);\\n            }\\n            ++seat;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288971,
                "title": "c-sorting-priority-queue-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n=times.size();\\n        vector<pair<int, int> > start;\\n        vector<pair<int, int> > end;\\n        map<int, int> m;\\n        priority_queue<int, vector<int>, greater<int> > pq;\\n        for(int i=0;i<n;i++) {\\n             start.push_back(make_pair(times[i][0], i));\\n             end.push_back(make_pair(times[i][1], i));\\n        }\\n        sort(start.begin(), start.end());\\n        sort(end.begin(), end.end());\\n        \\n        int curr=0;\\n        int i=0, j=0;\\n        \\n        while(i<n) {\\n            int startx=start[i].first;\\n            int endx=end[j].first;\\n            if(startx<endx) {\\n                if(!pq.empty()) {\\n                    m[start[i].second]=pq.top();\\n                    pq.pop();\\n                } else {\\n                    m[start[i].second]=curr;\\n                    curr++; \\n                }\\n                if(start[i].second==targetFriend)\\n                    return m[start[i].second];\\n                i++;\\n            } else {\\n                int pos=m[end[j].second];\\n                m[end[j].second]=-1;\\n                pq.push(pos);\\n                j++;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n=times.size();\\n        vector<pair<int, int> > start;\\n        vector<pair<int, int> > end;\\n        map<int, int> m;\\n        priority_queue<int, vector<int>, greater<int> > pq;\\n        for(int i=0;i<n;i++) {\\n             start.push_back(make_pair(times[i][0], i));\\n             end.push_back(make_pair(times[i][1], i));\\n        }\\n        sort(start.begin(), start.end());\\n        sort(end.begin(), end.end());\\n        \\n        int curr=0;\\n        int i=0, j=0;\\n        \\n        while(i<n) {\\n            int startx=start[i].first;\\n            int endx=end[j].first;\\n            if(startx<endx) {\\n                if(!pq.empty()) {\\n                    m[start[i].second]=pq.top();\\n                    pq.pop();\\n                } else {\\n                    m[start[i].second]=curr;\\n                    curr++; \\n                }\\n                if(start[i].second==targetFriend)\\n                    return m[start[i].second];\\n                i++;\\n            } else {\\n                int pos=m[end[j].second];\\n                m[end[j].second]=-1;\\n                pq.push(pos);\\n                j++;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269194,
                "title": "c-two-priority-queue-one-for-storing-available-seats-the-other-for-leaving-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        priority_queue<pair<int, int>> Q; //\\n        for (int i = 0; i < times.size(); i++){\\n            times[i].push_back (i); \\n        }\\n        sort (times.begin(), times.end()); \\n        \\n        int cnt = 0; \\n        // cnt is the next available seat \\n        priority_queue<int, vector<int>, greater<int>> available; \\n        for (int i = 0; i < times.size(); i++){\\n            int seat = -1; \\n            if (Q.empty()){\\n                seat = cnt++; \\n                // when will it expire; \\n                Q.push (make_pair (-times[i][1],  seat)); \\n            }\\n            else {\\n                // there is one that is possibly leaving; \\n                while (!Q.empty() && -Q.top().first <= times[i][0]){\\n                    // find all seats that are available; \\n                    available.push (Q.top().second); \\n                    Q.pop(); \\n                }\\n                if (available.empty()){\\n                    seat = cnt++; \\n                }\\n                else {\\n                    seat = available.top(); \\n                    available.pop();\\n                }\\n                Q.push (make_pair (-times[i][1], seat)); \\n                    \\n            }                \\n            if (times[i].back() == targetFriend) return seat; \\n        }\\n        return -1; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        priority_queue<pair<int, int>> Q; //\\n        for (int i = 0; i < times.size(); i++){\\n            times[i].push_back (i); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2246571,
                "title": "rust-solution",
                "content": "```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\nuse std::collections::HashMap;\\n\\nstruct Event {\\n    arrival: bool,\\n    index: usize,\\n    time: i32,\\n}\\n\\nimpl Event {\\n    fn new(arrival: bool, index: usize, time: i32) -> Event {\\n        Event{arrival: arrival, index: index, time: time}\\n    }\\n}\\n\\nimpl Solution {\\n    // Events with smaller time are ordered smaller. \\n    // In case of equalities, events that are not arrivals are smaller.\\n    fn compare(a: &Event, b: &Event) -> Ordering {\\n        let res = a.time.cmp(&b.time);\\n        if res == Ordering::Equal {\\n            if a.arrival == false && b.arrival == true {\\n                return Ordering::Less;\\n            }\\n            if a.arrival == true && b.arrival == false {\\n                return Ordering::Greater;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    pub fn smallest_chair(times: Vec<Vec<i32>>, target_friend: i32) -> i32 {\\n        let mut pq = BinaryHeap::<i32>::new();\\n        let mut map = HashMap::<usize, i32>::new();\\n        let mut highest = 0;\\n        let mut chair: i32 = 0;\\n        \\n        let mut events: Vec<Event> = times\\n        .iter()\\n        .enumerate()\\n        .flat_map(|e| [Event::new(true, e.0, e.1[0]), Event::new(false, e.0, e.1[1])])\\n        .collect();\\n\\n        events.sort_by(|a, b| Solution::compare(&a, &b));                \\n\\n        for e in events {\\n            if e.arrival {\\n                if pq.is_empty() {\\n                    chair = highest;\\n                    highest += 1;\\n                } else {\\n                    chair = -pq.pop().unwrap();\\n                }                \\n                if e.index == target_friend as usize {\\n                    return chair;\\n                }\\n                map.insert(e.index, chair);\\n            } else {\\n                pq.push(-map.get(&e.index).unwrap());\\n            }\\n        }\\n        chair\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\nuse std::collections::HashMap;\\n\\nstruct Event {\\n    arrival: bool,\\n    index: usize,\\n    time: i32,\\n}\\n\\nimpl Event {\\n    fn new(arrival: bool, index: usize, time: i32) -> Event {\\n        Event{arrival: arrival, index: index, time: time}\\n    }\\n}\\n\\nimpl Solution {\\n    // Events with smaller time are ordered smaller. \\n    // In case of equalities, events that are not arrivals are smaller.\\n    fn compare(a: &Event, b: &Event) -> Ordering {\\n        let res = a.time.cmp(&b.time);\\n        if res == Ordering::Equal {\\n            if a.arrival == false && b.arrival == true {\\n                return Ordering::Less;\\n            }\\n            if a.arrival == true && b.arrival == false {\\n                return Ordering::Greater;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    pub fn smallest_chair(times: Vec<Vec<i32>>, target_friend: i32) -> i32 {\\n        let mut pq = BinaryHeap::<i32>::new();\\n        let mut map = HashMap::<usize, i32>::new();\\n        let mut highest = 0;\\n        let mut chair: i32 = 0;\\n        \\n        let mut events: Vec<Event> = times\\n        .iter()\\n        .enumerate()\\n        .flat_map(|e| [Event::new(true, e.0, e.1[0]), Event::new(false, e.0, e.1[1])])\\n        .collect();\\n\\n        events.sort_by(|a, b| Solution::compare(&a, &b));                \\n\\n        for e in events {\\n            if e.arrival {\\n                if pq.is_empty() {\\n                    chair = highest;\\n                    highest += 1;\\n                } else {\\n                    chair = -pq.pop().unwrap();\\n                }                \\n                if e.index == target_friend as usize {\\n                    return chair;\\n                }\\n                map.insert(e.index, chair);\\n            } else {\\n                pq.push(-map.get(&e.index).unwrap());\\n            }\\n        }\\n        chair\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226812,
                "title": "2-priorityqueue-java-solution",
                "content": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int friendArrivalTime = times[targetFriend][0];\\n        Arrays.sort(times,(a,b)->a[0]-b[0]);\\n        // Maximum chairs required is the length of the times array. Incase there is no overlapping.\\n        PriorityQueue<Integer> chairAvailable = new PriorityQueue<>();\\n        for(int i=0;i<times.length;i++)\\n            chairAvailable.offer(i); // List of all the chairs that is available.\\n        PriorityQueue<int[]> haveVisited = new PriorityQueue<>((a,b)->a[1]-b[1]); // Sorted by the time they leave. Ascending Order.\\n        // It is clearly specified that all the arrival times are uinque. \\n        int index = 0;\\n        int result = 0;\\n        while(index<times.length && times[index][0]<=friendArrivalTime){\\n            while(!haveVisited.isEmpty() && haveVisited.peek()[1]<=times[index][0])\\n            {\\n                int[] remove = haveVisited.poll();\\n                chairAvailable.offer(remove[2]);\\n            }\\n            int smallestChairAvailable = chairAvailable.poll();\\n            haveVisited.offer(new int[]{times[index][0],times[index][1],smallestChairAvailable});\\n            index++;\\n            result = smallestChairAvailable;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int friendArrivalTime = times[targetFriend][0];\\n        Arrays.sort(times,(a,b)->a[0]-b[0]);\\n        // Maximum chairs required is the length of the times array. Incase there is no overlapping.\\n        PriorityQueue<Integer> chairAvailable = new PriorityQueue<>();\\n        for(int i=0;i<times.length;i++)\\n            chairAvailable.offer(i); // List of all the chairs that is available.\\n        PriorityQueue<int[]> haveVisited = new PriorityQueue<>((a,b)->a[1]-b[1]); // Sorted by the time they leave. Ascending Order.\\n        // It is clearly specified that all the arrival times are uinque. \\n        int index = 0;\\n        int result = 0;\\n        while(index<times.length && times[index][0]<=friendArrivalTime){\\n            while(!haveVisited.isEmpty() && haveVisited.peek()[1]<=times[index][0])\\n            {\\n                int[] remove = haveVisited.poll();\\n                chairAvailable.offer(remove[2]);\\n            }\\n            int smallestChairAvailable = chairAvailable.poll();\\n            haveVisited.offer(new int[]{times[index][0],times[index][1],smallestChairAvailable});\\n            index++;\\n            result = smallestChairAvailable;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221320,
                "title": "python-solution-with-detailed-explanation",
                "content": "```python\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        \\'\\'\\'\\n        when people left, return the chair to ava_seat[]\\n        when people arr, check if there is any returned chair, if so, take the smallest one\\n        if not, the seat index he will take will be the current total people - 1 in the party\\n        \\'\\'\\'\\n        total_people = 0\\n        arr_heap, lev_heap, ava_seat = [], [], []\\n        d = {}  # map people index to seat index\\n        for i, (arr, lev) in enumerate(times):\\n            heapq.heappush(arr_heap, [arr, i])\\n            heapq.heappush(lev_heap, [lev, i])\\n        \\n        while arr_heap:\\n            arr, cur_i = heapq.heappop(arr_heap)  # arr_time or cur time, cur people index\\n            total_people += 1\\n            \\n            while lev_heap[0][0] <= arr:  # people left before cur time\\n                lev, i = heapq.heappop(lev_heap)\\n                heapq.heappush(ava_seat, d[i])  # return the seat to the ava_seat\\n                total_people -= 1\\n            else:\\n                # check if there is an return seat, if so, take it\\n                if ava_seat:\\n                    take_seat_i = heapq.heappop(ava_seat)\\n                    d[cur_i] = take_seat_i\\n                else:\\n                    # seat_i will be the total people - 1  \\n                    d[cur_i] = total_people - 1\\n                \\n                if cur_i == targetFriend:\\n                    return d[cur_i]\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        \\'\\'\\'\\n        when people left, return the chair to ava_seat[]\\n        when people arr, check if there is any returned chair, if so, take the smallest one\\n        if not, the seat index he will take will be the current total people - 1 in the party\\n        \\'\\'\\'\\n        total_people = 0\\n        arr_heap, lev_heap, ava_seat = [], [], []\\n        d = {}  # map people index to seat index\\n        for i, (arr, lev) in enumerate(times):\\n            heapq.heappush(arr_heap, [arr, i])\\n            heapq.heappush(lev_heap, [lev, i])\\n        \\n        while arr_heap:\\n            arr, cur_i = heapq.heappop(arr_heap)  # arr_time or cur time, cur people index\\n            total_people += 1\\n            \\n            while lev_heap[0][0] <= arr:  # people left before cur time\\n                lev, i = heapq.heappop(lev_heap)\\n                heapq.heappush(ava_seat, d[i])  # return the seat to the ava_seat\\n                total_people -= 1\\n            else:\\n                # check if there is an return seat, if so, take it\\n                if ava_seat:\\n                    take_seat_i = heapq.heappop(ava_seat)\\n                    d[cur_i] = take_seat_i\\n                else:\\n                    # seat_i will be the total people - 1  \\n                    d[cur_i] = total_people - 1\\n                \\n                if cur_i == targetFriend:\\n                    return d[cur_i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193021,
                "title": "javascript-two-heaps-w-explanation",
                "content": "**Solution: Two Heaps & Sorting**\\n\\n1. Add an index `i `to each `times[i]` -> `[i, arrival, leaving]`\\n\\n2. Sort times by arrival time in asc order. This is so we can process each friend by arrival time.\\n\\n3. Maintain two heaps for each `[chair index, available time]`:\\n  available: chairs that are available, order based on chair index in asc order.\\n  notAvailable: chairs that are not available, order based on available time in asc order.\\n\\n4. Process each `times[i]`\\n  a. First, move chairs that have become available from the `notAvailable` heap to the `available` heap.\\n  b. If we have an available chair to re-use, use it. Otherwise, we can use a new chair.\\n  c. Add the updated/new chair and next available time to the `notAvailable` heap.\\n\\nTime Complexity: `O(n log(n))` 242ms\\nSpace Complexity: `O(n)` 61.2MB\\n```\\nvar smallestChair = function(times, targetFriend) {\\n  // [index, arrival, leaving]\\n  times = times\\n    .map((time, index) => [index, time[0], time[1]])\\n    .sort((a, b) => a[1] - b[1]);\\n  \\n  // [chair index, available time]\\n  let available = new PriorityQueue((a, b) => a[0] - b[0]);\\n  let notAvailable = new PriorityQueue((a, b) => a[1] - b[1]);\\n  let newChairNum = 0;\\n  for (let [i, arrival, leaving] of times) {\\n    while (!notAvailable.isEmpty() && notAvailable.top()[1] <= arrival) {\\n      available.add(notAvailable.remove());\\n    }\\n    let chairNum;\\n    if (!available.isEmpty()) chairNum = available.remove()[0]; // there is an available chair we can re-use\\n    else chairNum = newChairNum++; // use a new chair\\n    if (i === targetFriend) return chairNum;\\n    notAvailable.add([chairNum, leaving]);\\n  }\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar smallestChair = function(times, targetFriend) {\\n  // [index, arrival, leaving]\\n  times = times\\n    .map((time, index) => [index, time[0], time[1]])\\n    .sort((a, b) => a[1] - b[1]);\\n  \\n  // [chair index, available time]\\n  let available = new PriorityQueue((a, b) => a[0] - b[0]);\\n  let notAvailable = new PriorityQueue((a, b) => a[1] - b[1]);\\n  let newChairNum = 0;\\n  for (let [i, arrival, leaving] of times) {\\n    while (!notAvailable.isEmpty() && notAvailable.top()[1] <= arrival) {\\n      available.add(notAvailable.remove());\\n    }\\n    let chairNum;\\n    if (!available.isEmpty()) chairNum = available.remove()[0]; // there is an available chair we can re-use\\n    else chairNum = newChairNum++; // use a new chair\\n    if (i === targetFriend) return chairNum;\\n    notAvailable.add([chairNum, leaving]);\\n  }\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182412,
                "title": "java-easy-and-fast-solution-with-priority-queue",
                "content": "class Solution {\\n\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        PriorityQueue<Node2> busyChair = new PriorityQueue<>();\\n        PriorityQueue<Integer> emptyChair = new PriorityQueue<>();\\n        \\n        int n = times.length;\\n        \\n        Node[] arrDepNodeArray = new Node[n];\\n        for(int i = 0; i < n; i++){\\n            int[] time = times[i];\\n            int arr = time[0];\\n            int dep = time[1];\\n            \\n            Node arrDepNode = new Node(arr, dep);\\n            arrDepNodeArray[i] = arrDepNode;\\n            if(i == targetFriend){\\n                arrDepNode.target = true;\\n            }\\n        }\\n        \\n        Arrays.sort(arrDepNodeArray);\\n        int chairNo = 1;\\n        for(Node nodeIter : arrDepNodeArray){\\n            int arr = nodeIter.arrival;\\n            int dep = nodeIter.departure;\\n            int chair = -1;\\n            boolean target = nodeIter.target;\\n            if(busyChair.size() == 0){\\n                chair = 0;\\n                busyChair.add(new Node2(dep, chair));\\n            }else{\\n                while(busyChair.size() > 0 && busyChair.peek().departure <= arr){\\n                    Node2 removeNode = busyChair.poll();\\n                    emptyChair.add(removeNode.chair);\\n                }\\n                if(emptyChair.size() > 0){\\n                    chair = emptyChair.poll();   \\n                }else{\\n                    chair = chairNo;\\n                    chairNo++;\\n                }\\n                busyChair.add(new Node2(dep, chair));\\n            }\\n            \\n            if(target){\\n                return chair;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n\\nclass Node implements Comparable<Node>{\\n\\n    int arrival;\\n    int departure;\\n    boolean target = false;\\n    \\n    public Node(int arrival, int departure){\\n        this.arrival = arrival;\\n        this.departure = departure;\\n    }\\n    \\n    public int compareTo(Node o){\\n        return this.arrival - o.arrival;\\n    }\\n}\\n\\nclass Node2 implements Comparable<Node2>{\\n\\n    int departure;\\n    int chair;\\n    \\n    \\n    public Node2(int departure, int chair){\\n        this.chair = chair;\\n        this.departure = departure;\\n    }\\n    \\n    public int compareTo(Node2 o){\\n        return this.departure - o.departure;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        PriorityQueue<Node2> busyChair = new PriorityQueue<>();\\n        PriorityQueue<Integer> emptyChair = new PriorityQueue<>();\\n        \\n        int n = times.length;\\n        \\n        Node[] arrDepNodeArray = new Node[n];\\n        for(int i = 0; i < n; i++){\\n            int[] time = times[i];\\n            int arr = time[0];\\n            int dep = time[1];\\n            \\n            Node arrDepNode = new Node(arr, dep);\\n            arrDepNodeArray[i] = arrDepNode;\\n            if(i == targetFriend){\\n                arrDepNode.target = true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2179909,
                "title": "two-heap-map-java",
                "content": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        //arrival & leaving time\\n        //toh jab uska arrival time hojayga they leave delete hojayga uska chair\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        //available min chair\\n        for(int i=0;i<times.length;i++)pq.add(i);\\n        \\n        PriorityQueue<int[]>time=new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        \\n        for(int i=0;i<times.length;i++)\\n          time.add(new int[]{times[i][0],times[i][1],i});\\n        \\n        \\n        Map<Integer,List<Integer>>map=new HashMap<>();\\n        //ending -> chair\\n        \\n        int[]tmp=time.remove();\\n        for(int i=1;i<=100000;i++){\\n            if(map.size() > 0 && map.containsKey(i))\\n            {\\n                List<Integer>chair=map.get(i);\\n                \\n                for(int val:chair)\\n                    pq.add(val);\\n                map.remove(i);\\n            }\\n            \\n            \\n            if(tmp[0]==i){\\n                int chair=pq.remove();\\n                \\n                if(tmp[2]==targetFriend)return chair;\\n                \\n                if(!map.containsKey(tmp[1])){\\n                map.put(tmp[1],new ArrayList<>(Arrays.asList(chair)));\\n                }else\\n                    map.get(tmp[1]).add(chair);\\n                \\n                tmp=time.remove();\\n            }\\n            \\n        }\\n        return 0;\\n        \\n    }\\n}``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        //arrival & leaving time\\n        //toh jab uska arrival time hojayga they leave delete hojayga uska chair\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        //available min chair\\n        for(int i=0;i<times.length;i++)pq.add(i);\\n        \\n        PriorityQueue<int[]>time=new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        \\n        for(int i=0;i<times.length;i++)\\n          time.add(new int[]{times[i][0],times[i][1],i});\\n        \\n        \\n        Map<Integer,List<Integer>>map=new HashMap<>();\\n        //ending -> chair\\n        \\n        int[]tmp=time.remove();\\n        for(int i=1;i<=100000;i++){\\n            if(map.size() > 0 && map.containsKey(i))\\n            {\\n                List<Integer>chair=map.get(i);\\n                \\n                for(int val:chair)\\n                    pq.add(val);\\n                map.remove(i);\\n            }\\n            \\n            \\n            if(tmp[0]==i){\\n                int chair=pq.remove();\\n                \\n                if(tmp[2]==targetFriend)return chair;\\n                \\n                if(!map.containsKey(tmp[1])){\\n                map.put(tmp[1],new ArrayList<>(Arrays.asList(chair)));\\n                }else\\n                    map.get(tmp[1]).add(chair);\\n                \\n                tmp=time.remove();\\n            }\\n            \\n        }\\n        return 0;\\n        \\n    }\\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157803,
                "title": "java-heap-easy-understanding",
                "content": "A simple optimization that makes a big difference is that instead of adding all seats to the priority queue we only add the seats which are vaccated during intermediate times. Else we mainitan a \"smallest\" counter and increment\\nthe value. We choose the smallest seat from the heap if its not empty else we use the \"smallest\" value.\\n\\n```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int targetFriendTime = times[targetFriend][0];\\n        int smallest = 0;\\n        PriorityQueue<Person> occupiedSeats = new PriorityQueue<>((x, y) -> x.leaveTime - y.leaveTime);\\n        PriorityQueue<Integer> availableSeats = new PriorityQueue<>();\\n        Arrays.sort(times, (x, y) -> x[0] - y[0]);\\n\\n        for (int[] curr : times) {\\n            while (!occupiedSeats.isEmpty() && occupiedSeats.peek().leaveTime <= curr[0]) {\\n                int seat = occupiedSeats.poll().seat;\\n                availableSeats.add(seat);\\n            }\\n            if (curr[0] == targetFriendTime)\\n                return !availableSeats.isEmpty() ? availableSeats.peek() : smallest++;\\n\\n            occupiedSeats.add(new Person(!availableSeats.isEmpty() ? availableSeats.poll() : smallest++, curr[1]));\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\nclass Person {\\n    int seat;\\n    int leaveTime;\\n    \\n    Person(int seat, int leaveTime) {\\n        this.seat = seat;\\n        this.leaveTime = leaveTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int targetFriendTime = times[targetFriend][0];\\n        int smallest = 0;\\n        PriorityQueue<Person> occupiedSeats = new PriorityQueue<>((x, y) -> x.leaveTime - y.leaveTime);\\n        PriorityQueue<Integer> availableSeats = new PriorityQueue<>();\\n        Arrays.sort(times, (x, y) -> x[0] - y[0]);\\n\\n        for (int[] curr : times) {\\n            while (!occupiedSeats.isEmpty() && occupiedSeats.peek().leaveTime <= curr[0]) {\\n                int seat = occupiedSeats.poll().seat;\\n                availableSeats.add(seat);\\n            }\\n            if (curr[0] == targetFriendTime)\\n                return !availableSeats.isEmpty() ? availableSeats.peek() : smallest++;\\n\\n            occupiedSeats.add(new Person(!availableSeats.isEmpty() ? availableSeats.poll() : smallest++, curr[1]));\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\nclass Person {\\n    int seat;\\n    int leaveTime;\\n    \\n    Person(int seat, int leaveTime) {\\n        this.seat = seat;\\n        this.leaveTime = leaveTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155466,
                "title": "c-simple-approach-priority-queue-with-explanation",
                "content": "Straightforward solution... Order friends by arrival time an then keep track in `chairs` array if chair is free (is null or `leaving` is smaller than `arrival`). \\n```\\npublic class Solution\\n{\\n    public int SmallestChair(int[][] times, int targetFriend)\\n    {\\n        IEnumerable<Friend> friends = times\\n            .Select((time, index) => new Friend(Arrival: time[0], Leaving: time[1], IsTarget: index == targetFriend))\\n            .OrderBy(friend => friend.Arrival);\\n\\n        Friend?[] chairs = new Friend?[times.Length];\\n        foreach (Friend friend in friends)\\n        {\\n            for (int chairNumber = 0; chairNumber < chairs.Length; chairNumber++)\\n            {\\n                if (chairs[chairNumber]?.Leaving > friend.Arrival) continue;\\n\\n                if (friend.IsTarget) return chairNumber;\\n                chairs[chairNumber] = friend;\\n                break;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private readonly record struct Friend(int Arrival, int Leaving, bool IsTarget);\\n}\\n```\\n\\nUsing 3 priority queues, maybe this can be achived with smaller number of queues. Concept is simple:\\n- `arrivals` cotnains `friends` order by `arrival` time\\n- `occupiedChairs` contains time of `leaving` and `chair` index, it is order by `leaving`\\n- `emptyChairs` are chairs which were `occupiedChairs` but `friend` already left\\n\\nWhen new `friend` arrives first I free `occupiedChairs` by checking who already left. Then I check if there is any `emptyChair`, if not we \"add\" new. But if there is `emptyChair` I can `Dequeue` and this queue will contain chair with lowest index. New friend takes seat so I add new entry to `occupiedChairs`. \\n\\n```\\npublic class Solution\\n{\\n    public int SmallestChair(int[][] times, int targetFriend)\\n    {\\n        IEnumerable<Friend> friends = times.Select((time, index) => new Friend(time[0], time[1], index == targetFriend));\\n\\n        PriorityQueue<Friend, int> arrivals = new(friends.Select(friend => (friend, friend.Arrival)));\\n        PriorityQueue<(int Leaving, int Chair), int> occupiedChairs = new();\\n        PriorityQueue<int, int> emptyChairs = new();\\n\\n        while (true)\\n        {\\n            (int arrival, int leaving, bool isTarget) = arrivals.Dequeue();\\n            while (occupiedChairs.Count > 0 && occupiedChairs.Peek().Leaving <= arrival)\\n            {\\n                int freedChair = occupiedChairs.Dequeue().Chair;\\n                emptyChairs.Enqueue(freedChair, freedChair);\\n            }\\n\\n            int chair = emptyChairs.Count == 0 ? occupiedChairs.Count : emptyChairs.Dequeue();\\n            if (isTarget) return chair;\\n\\n            occupiedChairs.Enqueue((leaving, chair), leaving);\\n        }\\n    }\\n\\n    private readonly record struct Friend(int Arrival, int Leaving, bool IsTarget);\\n}\\n```\\n\\nI don\\'t like `while (true)` but I don\\'t have idea how to improve it.",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int SmallestChair(int[][] times, int targetFriend)\\n    {\\n        IEnumerable<Friend> friends = times\\n            .Select((time, index) => new Friend(Arrival: time[0], Leaving: time[1], IsTarget: index == targetFriend))\\n            .OrderBy(friend => friend.Arrival);\\n\\n        Friend?[] chairs = new Friend?[times.Length];\\n        foreach (Friend friend in friends)\\n        {\\n            for (int chairNumber = 0; chairNumber < chairs.Length; chairNumber++)\\n            {\\n                if (chairs[chairNumber]?.Leaving > friend.Arrival) continue;\\n\\n                if (friend.IsTarget) return chairNumber;\\n                chairs[chairNumber] = friend;\\n                break;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private readonly record struct Friend(int Arrival, int Leaving, bool IsTarget);\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int SmallestChair(int[][] times, int targetFriend)\\n    {\\n        IEnumerable<Friend> friends = times.Select((time, index) => new Friend(time[0], time[1], index == targetFriend));\\n\\n        PriorityQueue<Friend, int> arrivals = new(friends.Select(friend => (friend, friend.Arrival)));\\n        PriorityQueue<(int Leaving, int Chair), int> occupiedChairs = new();\\n        PriorityQueue<int, int> emptyChairs = new();\\n\\n        while (true)\\n        {\\n            (int arrival, int leaving, bool isTarget) = arrivals.Dequeue();\\n            while (occupiedChairs.Count > 0 && occupiedChairs.Peek().Leaving <= arrival)\\n            {\\n                int freedChair = occupiedChairs.Dequeue().Chair;\\n                emptyChairs.Enqueue(freedChair, freedChair);\\n            }\\n\\n            int chair = emptyChairs.Count == 0 ? occupiedChairs.Count : emptyChairs.Dequeue();\\n            if (isTarget) return chair;\\n\\n            occupiedChairs.Enqueue((leaving, chair), leaving);\\n        }\\n    }\\n\\n    private readonly record struct Friend(int Arrival, int Leaving, bool IsTarget);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098210,
                "title": "c-easy-to-understand-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int target) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int n=times.size();\\n        vector<vector<int>> arr(n,vector<int>(3,0));\\n        \\n        for(int i=0;i<times.size();i++)\\n        {\\n            arr[i][0]=times[i][0];\\n            arr[i][1]=times[i][1];\\n            arr[i][2]=i;\\n        }\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        int chair=0;\\n        \\n        for(int i=0;i<times.size();i++)\\n        {\\n           vector<int> temp=arr[i];\\n            int start=temp[0];\\n            int end=temp[1];\\n            int idx=temp[2];\\n            int mnn=INT_MAX;\\n            vector<pair<int,int>> x;\\n            while(!pq.empty() && pq.top().first<=start)\\n            {\\n                mnn=min(mnn,pq.top().second);\\n                x.push_back(make_pair(pq.top().first,pq.top().second));\\n                pq.pop();\\n            }\\n            if(x.size()>0)\\n            {\\n                for(auto [e,c]:x)\\n                {\\n                    if(c!=mnn)\\n                    {\\n                        pq.push(make_pair(e,c));\\n                    }\\n                }\\n            }\\n            \\n            if(mnn==INT_MAX)\\n            {\\n                if(idx==target) return chair;\\n                \\n                pq.push(make_pair(end,chair));\\n                chair++;\\n            }\\n            else\\n            {\\n                if(idx==target) return mnn;\\n                \\n                pq.push(make_pair(end,mnn));\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int target) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int n=times.size();\\n        vector<vector<int>> arr(n,vector<int>(3,0));\\n        \\n        for(int i=0;i<times.size();i++)\\n        {\\n            arr[i][0]=times[i][0];\\n            arr[i][1]=times[i][1];\\n            arr[i][2]=i;\\n        }\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        int chair=0;\\n        \\n        for(int i=0;i<times.size();i++)\\n        {\\n           vector<int> temp=arr[i];\\n            int start=temp[0];\\n            int end=temp[1];\\n            int idx=temp[2];\\n            int mnn=INT_MAX;\\n            vector<pair<int,int>> x;\\n            while(!pq.empty() && pq.top().first<=start)\\n            {\\n                mnn=min(mnn,pq.top().second);\\n                x.push_back(make_pair(pq.top().first,pq.top().second));\\n                pq.pop();\\n            }\\n            if(x.size()>0)\\n            {\\n                for(auto [e,c]:x)\\n                {\\n                    if(c!=mnn)\\n                    {\\n                        pq.push(make_pair(e,c));\\n                    }\\n                }\\n            }\\n            \\n            if(mnn==INT_MAX)\\n            {\\n                if(idx==target) return chair;\\n                \\n                pq.push(make_pair(end,chair));\\n                chair++;\\n            }\\n            else\\n            {\\n                if(idx==target) return mnn;\\n                \\n                pq.push(make_pair(end,mnn));\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086319,
                "title": "java-simple-understandable-solution",
                "content": "```\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n    public static int nextAvailableSeat;\\n\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        nextAvailableSeat = -1;\\n        int[][] list = new int[times.length][3];\\n        for (int i = 0; i < times.length; i++) {\\n            list[i][0] = times[i][0];\\n            list[i][1] = times[i][1];\\n            list[i][2] = i;\\n        }\\n        Arrays.sort(list, Comparator.comparingInt(a -> a[0]));\\n        PriorityQueue<Integer> chairFree = new PriorityQueue<>();\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\\n        int i = 0;\\n        int time;\\n        while (i < list.length) {\\n            time = list[i][0];\\n            // remove the seats for those who needs to exit.\\n            while (!queue.isEmpty() && queue.peek()[1] <= time) {\\n                int[] exit = queue.poll();\\n                chairFree.add(exit[3]);\\n            }\\n            int chair = getNextChair(chairFree);\\n            if (isTargetFriend(targetFriend, list[i])) {\\n                return chair;\\n            }\\n            queue.add(new int[]{list[i][0], list[i][1], list[i][2], chair});\\n            i++;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean isTargetFriend(int targetFriend, int[] list) {\\n        return list[2] == targetFriend;\\n    }\\n\\n    private int getNextChair(PriorityQueue<Integer> chairFree) {\\n        if (!chairFree.isEmpty()) {\\n            return chairFree.poll();\\n        }\\n        nextAvailableSeat++;\\n        return nextAvailableSeat;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n    public static int nextAvailableSeat;\\n\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        nextAvailableSeat = -1;\\n        int[][] list = new int[times.length][3];\\n        for (int i = 0; i < times.length; i++) {\\n            list[i][0] = times[i][0];\\n            list[i][1] = times[i][1];\\n            list[i][2] = i;\\n        }\\n        Arrays.sort(list, Comparator.comparingInt(a -> a[0]));\\n        PriorityQueue<Integer> chairFree = new PriorityQueue<>();\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\\n        int i = 0;\\n        int time;\\n        while (i < list.length) {\\n            time = list[i][0];\\n            // remove the seats for those who needs to exit.\\n            while (!queue.isEmpty() && queue.peek()[1] <= time) {\\n                int[] exit = queue.poll();\\n                chairFree.add(exit[3]);\\n            }\\n            int chair = getNextChair(chairFree);\\n            if (isTargetFriend(targetFriend, list[i])) {\\n                return chair;\\n            }\\n            queue.add(new int[]{list[i][0], list[i][1], list[i][2], chair});\\n            i++;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean isTargetFriend(int targetFriend, int[] list) {\\n        return list[2] == targetFriend;\\n    }\\n\\n    private int getNextChair(PriorityQueue<Integer> chairFree) {\\n        if (!chairFree.isEmpty()) {\\n            return chairFree.poll();\\n        }\\n        nextAvailableSeat++;\\n        return nextAvailableSeat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059309,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>>pq;\\n        priority_queue<int,vector<int>,greater<int>> temp_str;\\n        map<int,vector<int>> um;\\n        int left = 0, chair_cnt = 0, mn = INT_MAX, mx = INT_MIN;\\n        while(left < times.size())\\n        {\\n            pq.push({times[left][0],{times[left][1],left}});\\n            mn = min(times[left][0],mn);\\n            mx = max(times[left][1],mx);\\n            left++;\\n        }\\n        int idx = mn;\\n        while(!pq.empty() && idx <= mx)\\n        {\\n            pair<int,pair<int,int>> tmp = pq.top();\\n            if(um.count(idx))\\n            {\\n                for(int i = 0; i < um[idx].size(); i++)\\n                {\\n                    temp_str.push(um[idx][i]);\\n                }\\n                um.erase(idx);\\n            }\\n            if(tmp.first != idx)\\n            {\\n                idx++;\\n                continue;\\n            }\\n            pq.pop();\\n            if(!temp_str.empty())\\n            {\\n                int chair = temp_str.top();\\n                temp_str.pop();\\n                um[tmp.second.first].push_back(chair);\\n                if(tmp.second.second == targetFriend)\\n                    return chair;\\n            }\\n            else\\n            {\\n                um[tmp.second.first].push_back(chair_cnt);\\n                if(tmp.second.second == targetFriend)\\n                    return chair_cnt;\\n                chair_cnt++;\\n            }\\n        }\\n        return chair_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>>pq;\\n        priority_queue<int,vector<int>,greater<int>> temp_str;\\n        map<int,vector<int>> um;\\n        int left = 0, chair_cnt = 0, mn = INT_MAX, mx = INT_MIN;\\n        while(left < times.size())\\n        {\\n            pq.push({times[left][0],{times[left][1],left}});\\n            mn = min(times[left][0],mn);\\n            mx = max(times[left][1],mx);\\n            left++;\\n        }\\n        int idx = mn;\\n        while(!pq.empty() && idx <= mx)\\n        {\\n            pair<int,pair<int,int>> tmp = pq.top();\\n            if(um.count(idx))\\n            {\\n                for(int i = 0; i < um[idx].size(); i++)\\n                {\\n                    temp_str.push(um[idx][i]);\\n                }\\n                um.erase(idx);\\n            }\\n            if(tmp.first != idx)\\n            {\\n                idx++;\\n                continue;\\n            }\\n            pq.pop();\\n            if(!temp_str.empty())\\n            {\\n                int chair = temp_str.top();\\n                temp_str.pop();\\n                um[tmp.second.first].push_back(chair);\\n                if(tmp.second.second == targetFriend)\\n                    return chair;\\n            }\\n            else\\n            {\\n                um[tmp.second.first].push_back(chair_cnt);\\n                if(tmp.second.second == targetFriend)\\n                    return chair_cnt;\\n                chair_cnt++;\\n            }\\n        }\\n        return chair_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004394,
                "title": "java-easy-to-understand-solution-2-priority-queues",
                "content": "```import java.util.*; \\n\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        \\n        targetFriend = times[targetFriend][0];\\n        \\n        // Sorting the times array based on Arrival times\\n        Arrays.sort(times, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Integer.compare(o1[0], o2[0]);\\n            }\\n        });\\n        \\n        // We will keep this sorted on the leaving times\\n        // Poll will give the smallest leaving time\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>() {\\n            @Override\\n            public int compare(Pair o1, Pair o2) {\\n                return Integer.compare(o1.leavingTime, o2.leavingTime);\\n            }\\n        });\\n        \\n        PriorityQueue<Integer> availableChairs = new PriorityQueue<>();\\n        availableChairs.add(0);\\n        \\n        for(int[] time : times){\\n            \\n            Pair curr = new Pair(time);\\n            \\n            int currChairOccupied = Integer.MAX_VALUE;\\n            \\n            // Remove all available seats that are eligible post the arrival of curr\\n            // Any leaving times <= curr.arrivalTime get removed and their chairs are\\n            // added to set of available chairs. \\n            while(!pq.isEmpty() && pq.peek().leavingTime <= curr.arrivalTime){\\n                Pair removedFriend = pq.poll();\\n                availableChairs.add(removedFriend.chairNumber);\\n            }\\n            \\n            // If there any chairs available, get the smallest one \\n            if(availableChairs.size() > 0){\\n                currChairOccupied = availableChairs.poll();\\n            } else { // If no chairs are available, then everything from 0 to pq.size() - 1 is taken.\\n                currChairOccupied = pq.size();\\n            }        \\n            \\n            if(curr.arrivalTime == targetFriend){\\n                return currChairOccupied;\\n            }   \\n            \\n            curr.chairNumber = currChairOccupied; \\n            pq.add(curr);\\n        }\\n        \\n        return 0;\\n        \\n    }\\n}\\n\\nclass Pair { \\n\\n    int arrivalTime; \\n    int leavingTime;\\n    int chairNumber; \\n    \\n    Pair(int[] time){\\n        arrivalTime = time[0];\\n        leavingTime = time[1];\\n    }\\n    \\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        \\n        targetFriend = times[targetFriend][0];\\n        \\n        // Sorting the times array based on Arrival times\\n        Arrays.sort(times, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Integer.compare(o1[0], o2[0]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1982792,
                "title": "simple-solution-without-using-priority-queue",
                "content": "The basic idea is to sort the array according to arrival time of the persons and for targetFriend just find the smallest unoccupied chair by using another occ array. Rest Explaination is in comments.\\n```\\nclass Solution {\\n    //Pair class for sort the times according to arrival time\\n    class Pair implements Comparable<Pair>{\\n        int arr;\\n        int dep;\\n        int ind;\\n        Pair(int arr,int dep,int ind){\\n            this.arr = arr;\\n            this.dep = dep;\\n            this.ind = ind;\\n        }\\n        public int compareTo(Pair o){\\n            return this.arr-o.arr;\\n        }\\n    }\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        Pair[] arr = new Pair[times.length];//new array of pair class\\n        for(int i=0;i<arr.length;i++){\\n            Pair p = new Pair(times[i][0],times[i][1],i);\\n            arr[i] = p;\\n        }\\n        Arrays.sort(arr);//sort it according to arrival time \\n        int[] occ = new int[times.length];//occ array which shows the occupied chairs and contains the leaving time of a person i.e unoccupied time of a chair\\n        Arrays.fill(occ,-1);\\n        //traverse the pair class array\\n        for(int i=0;i<arr.length;i++){\\n            Pair p = arr[i];\\n            if(targetFriend == p.ind){//if target friend is found then return the smallest unoccupied chair\\n                return occupied(occ,p);\\n            }\\n            occupied(occ,p);//else fill the occ array as discussed above\\n        }\\n        return 0;//targetFriend is always in between 0 to n-1\\n    }\\n    public int occupied(int[] occ,Pair p){\\n        for(int i=0;i<occ.length;i++){//traverse the occ array \\n            if(occ[i]!=-1){ //if occ is already filled with some value then we have to check the arrival time of the friend if arrival time is greater or equal to the unoccupied time of chair it means this chair is now available and also this is the smallest possible chair so just return i else continue\\n                if(occ[i]<=p.arr){\\n                    occ[i] = p.dep;\\n                    return i;\\n                }\\n            }else{\\n                occ[i] = p.dep;//if occ is not already filled then fill it with departure time of person and return index\\n                return i;\\n            }\\n        }\\n        return -1;//as maximum of n chairs are occupied\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //Pair class for sort the times according to arrival time\\n    class Pair implements Comparable<Pair>{\\n        int arr;\\n        int dep;\\n        int ind;\\n        Pair(int arr,int dep,int ind){\\n            this.arr = arr;\\n            this.dep = dep;\\n            this.ind = ind;\\n        }\\n        public int compareTo(Pair o){\\n            return this.arr-o.arr;\\n        }\\n    }\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        Pair[] arr = new Pair[times.length];//new array of pair class\\n        for(int i=0;i<arr.length;i++){\\n            Pair p = new Pair(times[i][0],times[i][1],i);\\n            arr[i] = p;\\n        }\\n        Arrays.sort(arr);//sort it according to arrival time \\n        int[] occ = new int[times.length];//occ array which shows the occupied chairs and contains the leaving time of a person i.e unoccupied time of a chair\\n        Arrays.fill(occ,-1);\\n        //traverse the pair class array\\n        for(int i=0;i<arr.length;i++){\\n            Pair p = arr[i];\\n            if(targetFriend == p.ind){//if target friend is found then return the smallest unoccupied chair\\n                return occupied(occ,p);\\n            }\\n            occupied(occ,p);//else fill the occ array as discussed above\\n        }\\n        return 0;//targetFriend is always in between 0 to n-1\\n    }\\n    public int occupied(int[] occ,Pair p){\\n        for(int i=0;i<occ.length;i++){//traverse the occ array \\n            if(occ[i]!=-1){ //if occ is already filled with some value then we have to check the arrival time of the friend if arrival time is greater or equal to the unoccupied time of chair it means this chair is now available and also this is the smallest possible chair so just return i else continue\\n                if(occ[i]<=p.arr){\\n                    occ[i] = p.dep;\\n                    return i;\\n                }\\n            }else{\\n                occ[i] = p.dep;//if occ is not already filled then fill it with departure time of person and return index\\n                return i;\\n            }\\n        }\\n        return -1;//as maximum of n chairs are occupied\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975376,
                "title": "two-priority-queues",
                "content": "Two priority queues, \\n* one for *arrival*,\\n* the other for *unoccupied* chairs.\\n\\n```\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n\\tpriority_queue<int, vector<int>, greater<int>> unoccupied;\\n\\tpriority_queue<\\n\\t\\tpair<int, int>, \\n\\t\\tvector<pair<int, int>>,\\n\\t\\tgreater<pair<int, int>>\\n\\t> occupiedUntil;\\n\\t\\n\\tint largestChair = 0;\\n\\tint smallestChair = 0;\\n\\tint n = times.size();\\n\\tvector<vector<int>> fri(n);\\n\\t\\n\\t// bind the time with id\\n\\tfor (int i = 0; i < n; ++i)\\n\\t\\tfri[i] = {times[i][0], times[i][1], i};\\n\\t\\n\\t// sort by arriving time.\\n\\tsort(fri.begin(), fri.end());\\n\\n\\t// for each arrived student,\\n\\tfor (int i = 0; i < n; ++i)\\n\\t{\\n\\t\\t// if there are any occupied chair that has been unoccpied at the time student i arrive,\\n\\t\\t// put the chair number into unoccupied.\\n\\t\\twhile (occupiedUntil.size() && occupiedUntil.top().first <= fri[i][0])\\n\\t\\t{\\n\\t\\t\\tunoccupied.push(occupiedUntil.top().second);\\n\\t\\t\\toccupiedUntil.pop();\\n\\t\\t}\\n\\t\\t\\n\\t\\t// if there are any chair in unoccupied, allocate it to student i.\\n\\t\\tif (unoccupied.size())\\n\\t\\t{\\n\\t\\t\\tsmallestChair = unoccupied.top();\\n\\t\\t\\tunoccupied.pop();\\n\\t\\t}\\n\\t\\t// if there are no chair in unoccupied, meaning all the chair has been occupied, we acquire one more chare for student i. \\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tsmallestChair = largestChair ++;\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\tif (fri[i][2] == targetFriend)\\n\\t\\t\\treturn smallestChair;\\n\\t\\telse\\n\\t\\t\\toccupiedUntil.push({fri[i][1], smallestChair});\\n\\t}\\n\\t\\n\\treturn -1;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n\\tpriority_queue<int, vector<int>, greater<int>> unoccupied;\\n\\tpriority_queue<\\n\\t\\tpair<int, int>, \\n\\t\\tvector<pair<int, int>>,\\n\\t\\tgreater<pair<int, int>>\\n\\t> occupiedUntil;\\n\\t\\n\\tint largestChair = 0;\\n\\tint smallestChair = 0;\\n\\tint n = times.size();\\n\\tvector<vector<int>> fri(n);\\n\\t\\n\\t// bind the time with id\\n\\tfor (int i = 0; i < n; ++i)\\n\\t\\tfri[i] = {times[i][0], times[i][1], i};\\n\\t\\n\\t// sort by arriving time.\\n\\tsort(fri.begin(), fri.end());\\n\\n\\t// for each arrived student,\\n\\tfor (int i = 0; i < n; ++i)\\n\\t{\\n\\t\\t// if there are any occupied chair that has been unoccpied at the time student i arrive,\\n\\t\\t// put the chair number into unoccupied.\\n\\t\\twhile (occupiedUntil.size() && occupiedUntil.top().first <= fri[i][0])\\n\\t\\t{\\n\\t\\t\\tunoccupied.push(occupiedUntil.top().second);\\n\\t\\t\\toccupiedUntil.pop();\\n\\t\\t}\\n\\t\\t\\n\\t\\t// if there are any chair in unoccupied, allocate it to student i.\\n\\t\\tif (unoccupied.size())\\n\\t\\t{\\n\\t\\t\\tsmallestChair = unoccupied.top();\\n\\t\\t\\tunoccupied.pop();\\n\\t\\t}\\n\\t\\t// if there are no chair in unoccupied, meaning all the chair has been occupied, we acquire one more chare for student i. \\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tsmallestChair = largestChair ++;\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\tif (fri[i][2] == targetFriend)\\n\\t\\t\\treturn smallestChair;\\n\\t\\telse\\n\\t\\t\\toccupiedUntil.push({fri[i][1], smallestChair});\\n\\t}\\n\\t\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1972976,
                "title": "c-priority-queue-set-easy-to-understand",
                "content": "```\\nclass Solution {\\n    struct timeContraints {\\n        int arrivals;\\n        int leaving;\\n        int id;\\n    };\\n    \\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        timeContraints arr[n];\\n        \\n        for(int i=0;i<n;i++) {\\n            arr[i].arrivals = times[i][0]; \\n            arr[i].leaving = times[i][1];\\n            arr[i].id = i;\\n        }\\n        \\n        sort(arr, arr + n, comparator);\\n        \\n        set<int> unoccupied;\\n        int ans;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        \\n        for(int i=0;i<n;i++)\\n            unoccupied.insert(i);\\n        \\n        for(int i=0;i<n;i++) {\\n            while(!pq.empty() && pq.top().first <= arr[i].arrivals) {\\n                unoccupied.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            \\n            int pos = *(unoccupied.begin());\\n            if(targetFriend == arr[i].id) {\\n                ans = pos;\\n                break;\\n            }\\n            \\n            unoccupied.erase(unoccupied.begin());\\n            pq.push({arr[i].leaving, pos});\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    static bool comparator(timeContraints& a, timeContraints& b) {\\n        if(a.arrivals == b.arrivals)\\n            return a.id < b.id;\\n        return a.arrivals < b.arrivals;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    struct timeContraints {\\n        int arrivals;\\n        int leaving;\\n        int id;\\n    };\\n    \\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = times.size();\\n        timeContraints arr[n];\\n        \\n        for(int i=0;i<n;i++) {\\n            arr[i].arrivals = times[i][0]; \\n            arr[i].leaving = times[i][1];\\n            arr[i].id = i;\\n        }\\n        \\n        sort(arr, arr + n, comparator);\\n        \\n        set<int> unoccupied;\\n        int ans;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        \\n        for(int i=0;i<n;i++)\\n            unoccupied.insert(i);\\n        \\n        for(int i=0;i<n;i++) {\\n            while(!pq.empty() && pq.top().first <= arr[i].arrivals) {\\n                unoccupied.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            \\n            int pos = *(unoccupied.begin());\\n            if(targetFriend == arr[i].id) {\\n                ans = pos;\\n                break;\\n            }\\n            \\n            unoccupied.erase(unoccupied.begin());\\n            pq.push({arr[i].leaving, pos});\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    static bool comparator(timeContraints& a, timeContraints& b) {\\n        if(a.arrivals == b.arrivals)\\n            return a.id < b.id;\\n        return a.arrivals < b.arrivals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968038,
                "title": "javascript-solution-two-minheaps",
                "content": "```\\nvar smallestChair = function(times, targetFriend) {\\n    const n = times.length;\\n    \\n    const occupiedSeats = new PriorityQueue((a, b) => a.leavingTime - b.leavingTime);\\n    const freeSeats = new PriorityQueue((a, b) => a.index - b.index);\\n    \\n    freeSeats.enqueue({ index: 0, leavingTime: -1 });\\n    \\n    let nextSeatIdx = 1;\\n    \\n    const friends = [];\\n    \\n    for (let index = 0; index < n; ++index) {\\n        const [arrivalTime, leavingTime] = times[index];\\n        \\n        friends.push({ arrivalTime, leavingTime, index });\\n    }\\n \\n    friends.sort((a, b) => a.arrivalTime - b.arrivalTime || a.leavingTime - b.leavingTime || a.index - b.index);\\n    \\n    let time = 0;\\n    let friendIdx = 0;\\n    \\n    while (friendIdx < n) {\\n        while (occupiedSeats.isEmpty() === false && occupiedSeats.peek().leavingTime === time) {\\n            const top = occupiedSeats.dequeue();\\n            freeSeats.enqueue(top);\\n        }\\n        \\n        while (friends[friendIdx].arrivalTime <= time) {\\n            if (freeSeats.isEmpty() === true) { // We don\\'t have any free seats available\\n                 if (friends[friendIdx].index === targetFriend) {\\n                    return nextSeatIdx;\\n                }\\n                \\n                const nextSeat = { index: nextSeatIdx, leavingTime: friends[friendIdx].leavingTime };\\n                \\n                occupiedSeats.enqueue(nextSeat);\\n                \\n                nextSeatIdx += 1;\\n                friendIdx += 1;\\n            }\\n            else {\\n                const freeSeat = freeSeats.dequeue();\\n                \\n                if (friends[friendIdx].index === targetFriend) {\\n                    return freeSeat.index;\\n                }\\n                \\n                freeSeat.leavingTime = friends[friendIdx].leavingTime;\\n                \\n                occupiedSeats.enqueue(freeSeat);\\n                \\n                friendIdx += 1;\\n            }\\n        }\\n        \\n        ++time;\\n    }\\n    \\n    return;\\n};\\n\\n\\nclass PriorityQueue {\\n    constructor(compare) {\\n      this.compare = compare; // compare function\\n      this.heap = [];\\n    }\\n\\t\\t\\n    size() {\\n      return this.heap.length; \\n    }\\n    \\n    isEmpty() {\\n      return this.size() === 0;\\n    }\\n    \\n    peek() {\\n      return this.heap[0];\\n    }\\n    \\n    getParentIndex(index) {\\n      return Math.floor((index - 1) / 2);\\n    }\\n    \\n    getLeftIndex(index) {\\n      return (index * 2) + 1;\\n    }\\n    \\n    getRightIndex(index) {\\n      return (index * 2) + 2;\\n    }\\n    \\n    swap(i, j) {\\n      const tmp = this.heap[i];\\n      this.heap[i] = this.heap[j];\\n      this.heap[j] = tmp;\\n    }\\n    \\n    enqueue(val) {\\n      this.heap.push(val);\\n      this.swim(this.heap.length - 1);\\n    }\\n    \\n    swim(index) {\\n      let parentIdx = this.getParentIndex(index);\\n        \\n      while (index > 0  && this.compare(this.heap[parentIdx], this.heap[index]) > 0) {\\n        this.swap(parentIdx, index);\\n        \\n        index = parentIdx;\\n        parentIdx = this.getParentIndex(index);\\n      }\\n        \\n      return;\\n    }\\n    \\n    dequeue() {\\n      const top = this.heap[0];\\n      this.swap(0, this.size() - 1);\\n      this.heap.pop();\\n      this.sink(0); \\n      \\n      return top;\\n    }\\n    \\n    sink(index) {\\n      let minIdx = index;\\n        \\n      const size = this.size();\\n      const leftIdx = this.getLeftIndex(minIdx);\\n      const rightIdx = this.getRightIndex(minIdx);\\n        \\n      if (leftIdx < size && this.compare(this.heap[minIdx], this.heap[leftIdx]) > 0) {\\n        minIdx = leftIdx;\\n      } \\n      \\n      if (rightIdx < size && this.compare(this.heap[minIdx], this.heap[rightIdx]) > 0) {\\n        minIdx = rightIdx;\\n      }\\n      \\n      if (index != minIdx) {\\n        this.swap(index, minIdx);\\n        this.sink(minIdx);\\n      }\\n      \\n      return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar smallestChair = function(times, targetFriend) {\\n    const n = times.length;\\n    \\n    const occupiedSeats = new PriorityQueue((a, b) => a.leavingTime - b.leavingTime);\\n    const freeSeats = new PriorityQueue((a, b) => a.index - b.index);\\n    \\n    freeSeats.enqueue({ index: 0, leavingTime: -1 });\\n    \\n    let nextSeatIdx = 1;\\n    \\n    const friends = [];\\n    \\n    for (let index = 0; index < n; ++index) {\\n        const [arrivalTime, leavingTime] = times[index];\\n        \\n        friends.push({ arrivalTime, leavingTime, index });\\n    }\\n \\n    friends.sort((a, b) => a.arrivalTime - b.arrivalTime || a.leavingTime - b.leavingTime || a.index - b.index);\\n    \\n    let time = 0;\\n    let friendIdx = 0;\\n    \\n    while (friendIdx < n) {\\n        while (occupiedSeats.isEmpty() === false && occupiedSeats.peek().leavingTime === time) {\\n            const top = occupiedSeats.dequeue();\\n            freeSeats.enqueue(top);\\n        }\\n        \\n        while (friends[friendIdx].arrivalTime <= time) {\\n            if (freeSeats.isEmpty() === true) { // We don\\'t have any free seats available\\n                 if (friends[friendIdx].index === targetFriend) {\\n                    return nextSeatIdx;\\n                }\\n                \\n                const nextSeat = { index: nextSeatIdx, leavingTime: friends[friendIdx].leavingTime };\\n                \\n                occupiedSeats.enqueue(nextSeat);\\n                \\n                nextSeatIdx += 1;\\n                friendIdx += 1;\\n            }\\n            else {\\n                const freeSeat = freeSeats.dequeue();\\n                \\n                if (friends[friendIdx].index === targetFriend) {\\n                    return freeSeat.index;\\n                }\\n                \\n                freeSeat.leavingTime = friends[friendIdx].leavingTime;\\n                \\n                occupiedSeats.enqueue(freeSeat);\\n                \\n                friendIdx += 1;\\n            }\\n        }\\n        \\n        ++time;\\n    }\\n    \\n    return;\\n};\\n\\n\\nclass PriorityQueue {\\n    constructor(compare) {\\n      this.compare = compare; // compare function\\n      this.heap = [];\\n    }\\n\\t\\t\\n    size() {\\n      return this.heap.length; \\n    }\\n    \\n    isEmpty() {\\n      return this.size() === 0;\\n    }\\n    \\n    peek() {\\n      return this.heap[0];\\n    }\\n    \\n    getParentIndex(index) {\\n      return Math.floor((index - 1) / 2);\\n    }\\n    \\n    getLeftIndex(index) {\\n      return (index * 2) + 1;\\n    }\\n    \\n    getRightIndex(index) {\\n      return (index * 2) + 2;\\n    }\\n    \\n    swap(i, j) {\\n      const tmp = this.heap[i];\\n      this.heap[i] = this.heap[j];\\n      this.heap[j] = tmp;\\n    }\\n    \\n    enqueue(val) {\\n      this.heap.push(val);\\n      this.swim(this.heap.length - 1);\\n    }\\n    \\n    swim(index) {\\n      let parentIdx = this.getParentIndex(index);\\n        \\n      while (index > 0  && this.compare(this.heap[parentIdx], this.heap[index]) > 0) {\\n        this.swap(parentIdx, index);\\n        \\n        index = parentIdx;\\n        parentIdx = this.getParentIndex(index);\\n      }\\n        \\n      return;\\n    }\\n    \\n    dequeue() {\\n      const top = this.heap[0];\\n      this.swap(0, this.size() - 1);\\n      this.heap.pop();\\n      this.sink(0); \\n      \\n      return top;\\n    }\\n    \\n    sink(index) {\\n      let minIdx = index;\\n        \\n      const size = this.size();\\n      const leftIdx = this.getLeftIndex(minIdx);\\n      const rightIdx = this.getRightIndex(minIdx);\\n        \\n      if (leftIdx < size && this.compare(this.heap[minIdx], this.heap[leftIdx]) > 0) {\\n        minIdx = leftIdx;\\n      } \\n      \\n      if (rightIdx < size && this.compare(this.heap[minIdx], this.heap[rightIdx]) > 0) {\\n        minIdx = rightIdx;\\n      }\\n      \\n      if (index != minIdx) {\\n        this.swap(index, minIdx);\\n        this.sink(minIdx);\\n      }\\n      \\n      return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963692,
                "title": "o-nlogn-using-two-priority-queues",
                "content": "```\\nclass Solution {\\npublic:\\n    struct nextFreeSeatCmp {\\n        bool operator()(int &left, int &right){\\n            return left >= right;\\n        }  \\n    };\\n    struct leavingFriendCmp {\\n        bool operator()(const vector<int> &left, const vector<int> &right){\\n            return left[1] >= right[1];\\n        }  \\n    };\\n    static bool sortTimesByArrivalCmp(const vector<int> &left, const vector<int> &right){\\n        return left[0] < right[0];\\n    }\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        \\n        int n = times.size();        \\n        \\n        for(int i=0;i<n;i++){\\n            times[i].push_back(i);\\n        }\\n        \\n        sort(times.begin(), times.end(), sortTimesByArrivalCmp);\\n        \\n        \\n        priority_queue<int, vector<int>, nextFreeSeatCmp> seats;        \\n        \\n        \\n        seats.push(0);\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, leavingFriendCmp> currentFriends;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int arrival = times[i][0];\\n            int leaving = times[i][1];\\n            int friendNumber = times[i][2];                        \\n            \\n            while(!currentFriends.empty()) {\\n                vector<int> top = currentFriends.top();                                \\n                \\n                if(top[1] <= arrival) {                    \\n                    currentFriends.pop();\\n                    seats.push(top[3]);\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            times[i].push_back(seats.top());\\n            \\n            if(friendNumber == targetFriend) return times[i][3];\\n                        \\n            seats.pop();\\n            \\n            if(seats.size() == 0){\\n                seats.push(times[i][3] + 1);\\n            }\\n            \\n            currentFriends.push(times[i]);\\n            \\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct nextFreeSeatCmp {\\n        bool operator()(int &left, int &right){\\n            return left >= right;\\n        }  \\n    };\\n    struct leavingFriendCmp {\\n        bool operator()(const vector<int> &left, const vector<int> &right){\\n            return left[1] >= right[1];\\n        }  \\n    };\\n    static bool sortTimesByArrivalCmp(const vector<int> &left, const vector<int> &right){\\n        return left[0] < right[0];\\n    }\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        \\n        int n = times.size();        \\n        \\n        for(int i=0;i<n;i++){\\n            times[i].push_back(i);\\n        }\\n        \\n        sort(times.begin(), times.end(), sortTimesByArrivalCmp);\\n        \\n        \\n        priority_queue<int, vector<int>, nextFreeSeatCmp> seats;        \\n        \\n        \\n        seats.push(0);\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, leavingFriendCmp> currentFriends;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int arrival = times[i][0];\\n            int leaving = times[i][1];\\n            int friendNumber = times[i][2];                        \\n            \\n            while(!currentFriends.empty()) {\\n                vector<int> top = currentFriends.top();                                \\n                \\n                if(top[1] <= arrival) {                    \\n                    currentFriends.pop();\\n                    seats.push(top[3]);\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            times[i].push_back(seats.top());\\n            \\n            if(friendNumber == targetFriend) return times[i][3];\\n                        \\n            seats.pop();\\n            \\n            if(seats.size() == 0){\\n                seats.push(times[i][3] + 1);\\n            }\\n            \\n            currentFriends.push(times[i]);\\n            \\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960697,
                "title": "simple-solution-in-java-99-faster-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        \\n        Pair[] friendTimes = new Pair[times.length];\\n        for(int i=0; i<times.length; i++){\\n            friendTimes[i] = new Pair(times[i][0], times[i][1], i);\\n        }\\n        Arrays.sort(friendTimes, (a, b) -> a.arrival == b.arrival ? Integer.compare(a.depart, b.depart) : Integer.compare(a.arrival, b.arrival));\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); // {departure, seat}\\n        PriorityQueue<Integer> seatsAvailable = new PriorityQueue<>();\\n        \\n        int maxSeatAvailable = 0;\\n        for(int i=0; i<friendTimes.length; i++){\\n            // Makes the seats available of the departed candidates\\n            while(!pq.isEmpty() && pq.peek()[0] <= friendTimes[i].arrival){\\n               seatsAvailable.offer(pq.poll()[1]);\\n            }\\n            \\n            // Assign the seat to the current guest\\n            if(friendTimes[i].index == targetFriend){\\n                if(seatsAvailable.isEmpty()) return maxSeatAvailable;\\n                else return seatsAvailable.poll();\\n            }\\n            \\n            if(seatsAvailable.isEmpty()){\\n                pq.offer(new int[]{friendTimes[i].depart, maxSeatAvailable});\\n                maxSeatAvailable++;\\n            }else pq.offer(new int[]{friendTimes[i].depart, seatsAvailable.poll()});\\n        }\\n        \\n        return maxSeatAvailable;\\n    }\\n    \\n    private class Pair{\\n        public int arrival;\\n        public int depart;\\n        public int index;\\n        \\n        public Pair(int arrival, int depart, int index){\\n            this.arrival = arrival;\\n            this.depart = depart;\\n            this.index = index;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        \\n        Pair[] friendTimes = new Pair[times.length];\\n        for(int i=0; i<times.length; i++){\\n            friendTimes[i] = new Pair(times[i][0], times[i][1], i);\\n        }\\n        Arrays.sort(friendTimes, (a, b) -> a.arrival == b.arrival ? Integer.compare(a.depart, b.depart) : Integer.compare(a.arrival, b.arrival));\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); // {departure, seat}\\n        PriorityQueue<Integer> seatsAvailable = new PriorityQueue<>();\\n        \\n        int maxSeatAvailable = 0;\\n        for(int i=0; i<friendTimes.length; i++){\\n            // Makes the seats available of the departed candidates\\n            while(!pq.isEmpty() && pq.peek()[0] <= friendTimes[i].arrival){\\n               seatsAvailable.offer(pq.poll()[1]);\\n            }\\n            \\n            // Assign the seat to the current guest\\n            if(friendTimes[i].index == targetFriend){\\n                if(seatsAvailable.isEmpty()) return maxSeatAvailable;\\n                else return seatsAvailable.poll();\\n            }\\n            \\n            if(seatsAvailable.isEmpty()){\\n                pq.offer(new int[]{friendTimes[i].depart, maxSeatAvailable});\\n                maxSeatAvailable++;\\n            }else pq.offer(new int[]{friendTimes[i].depart, seatsAvailable.poll()});\\n        }\\n        \\n        return maxSeatAvailable;\\n    }\\n    \\n    private class Pair{\\n        public int arrival;\\n        public int depart;\\n        public int index;\\n        \\n        public Pair(int arrival, int depart, int index){\\n            this.arrival = arrival;\\n            this.depart = depart;\\n            this.index = index;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944344,
                "title": "c-only-one-set-42-lines-85-beat",
                "content": "```\\nstruct Info {\\n    int index, arrival, leaving, chair;\\n    Info() {}\\n    Info(int a, int b, int c, int d) : index(a), arrival(b), leaving(c), chair(d) {}\\n    bool operator < (const Info& o) const {\\n        if (arrival == o.arrival) return leaving < o.leaving;\\n        return arrival < o.arrival;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = (int)times.size();\\n        \\n        // Structure\\n        vector<Info> infoList(n);\\n        for (int i = 0; i < n; i++) infoList[i] = Info(i, times[i][0], times[i][1], -1);\\n\\n        // Sort - O(nlgn)\\n        sort(infoList.begin(), infoList.end());\\n        \\n        // O(nlgn)\\n        set<Info> st;\\n        for (Info i : infoList) st.insert(i);\\n        \\n        // O(nlgn)\\n        vector<int> chairNumber(n);\\n        int chair = 0;\\n        while (!st.empty()) {\\n            auto it = st.begin();\\n            while (it != st.end()) {\\n                Info info = *it;\\n                chairNumber[info.index] = chair;\\n                st.erase(it);\\n                it = st.lower_bound(Info(-1, info.leaving, -1, -1));\\n            }\\n            chair++;\\n        }\\n        printf(\"minimumChairRequired = %d\\\\n\", chair);\\n        return chairNumber[targetFriend];\\n    }\\n};\\n```\\n\\nPlease upvote if you like this solution.",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nstruct Info {\\n    int index, arrival, leaving, chair;\\n    Info() {}\\n    Info(int a, int b, int c, int d) : index(a), arrival(b), leaving(c), chair(d) {}\\n    bool operator < (const Info& o) const {\\n        if (arrival == o.arrival) return leaving < o.leaving;\\n        return arrival < o.arrival;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        int n = (int)times.size();\\n        \\n        // Structure\\n        vector<Info> infoList(n);\\n        for (int i = 0; i < n; i++) infoList[i] = Info(i, times[i][0], times[i][1], -1);\\n\\n        // Sort - O(nlgn)\\n        sort(infoList.begin(), infoList.end());\\n        \\n        // O(nlgn)\\n        set<Info> st;\\n        for (Info i : infoList) st.insert(i);\\n        \\n        // O(nlgn)\\n        vector<int> chairNumber(n);\\n        int chair = 0;\\n        while (!st.empty()) {\\n            auto it = st.begin();\\n            while (it != st.end()) {\\n                Info info = *it;\\n                chairNumber[info.index] = chair;\\n                st.erase(it);\\n                it = st.lower_bound(Info(-1, info.leaving, -1, -1));\\n            }\\n            chair++;\\n        }\\n        printf(\"minimumChairRequired = %d\\\\n\", chair);\\n        return chairNumber[targetFriend];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941425,
                "title": "java-create-a-timeline-with-comments",
                "content": "We can simplify the question by creating a timeline and sort based on time **and leave & arrival** (leave comes first as specified in the question)\\n\\nIdea is offer 0 as the first seat in the priorityqueue, then we can guarantee that when the heap (priorityqueue) is empty, we can offer the next higher number as the seat. It works because when it is empty, the last seat we offer is always the highest seat thus far. Any seat we reclaimed will be strictly lower than that.\\n\\n**81% Speed**\\n```Java\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        PriorityQueue<Integer> minheap = new PriorityQueue<>();\\n        minheap.offer(0); // Offer the first seat \\n        Person[] all = new Person[times.length * 2];\\n        for (int i = 0; i < times.length; i++){ // create a timeline\\n            all[2 * i] = new Person(i, times[i][0], false, true);\\n            all[2 * i + 1] = new Person(i, times[i][1], true, false);\\n        }\\n        Arrays.sort(all, (a, b) -> { // sort by time first, then by leave & arrival status\\n            int i = a.leave? -1 : 1;\\n            int j = b.leave? -1 : 1;\\n            return a.time == b.time? i - j : a.time - b.time;\\n        });\\n\\n        int[] seat = new int[times.length];\\n        for (int i = 0; true; i++){ // loop until we find the answer \\n            if (all[i].arrive){\\n                if (targetFriend == all[i].idx){\\n                    return minheap.peek(); // found answer\\n                }\\n                seat[all[i].idx] = minheap.poll(); // assign seat\\n                if (minheap.isEmpty()){\\n                    minheap.offer(seat[all[i].idx] + 1); // if empty, offer the next seat\\n                }\\n            }else{\\n                minheap.offer(seat[all[i].idx]); // reclaim seat\\n            }\\n        }\\n    }\\n\\n    private class Person {\\n        boolean leave;\\n        boolean arrive;\\n        int time;\\n        int idx;\\n        Person (int idx, int time, boolean leave, boolean arrive){\\n            this.time = time;\\n            this.leave = leave;\\n            this.arrive = arrive;\\n            this.idx = idx;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        PriorityQueue<Integer> minheap = new PriorityQueue<>();\\n        minheap.offer(0); // Offer the first seat \\n        Person[] all = new Person[times.length * 2];\\n        for (int i = 0; i < times.length; i++){ // create a timeline\\n            all[2 * i] = new Person(i, times[i][0], false, true);\\n            all[2 * i + 1] = new Person(i, times[i][1], true, false);\\n        }\\n        Arrays.sort(all, (a, b) -> { // sort by time first, then by leave & arrival status\\n            int i = a.leave? -1 : 1;\\n            int j = b.leave? -1 : 1;\\n            return a.time == b.time? i - j : a.time - b.time;\\n        });\\n\\n        int[] seat = new int[times.length];\\n        for (int i = 0; true; i++){ // loop until we find the answer \\n            if (all[i].arrive){\\n                if (targetFriend == all[i].idx){\\n                    return minheap.peek(); // found answer\\n                }\\n                seat[all[i].idx] = minheap.poll(); // assign seat\\n                if (minheap.isEmpty()){\\n                    minheap.offer(seat[all[i].idx] + 1); // if empty, offer the next seat\\n                }\\n            }else{\\n                minheap.offer(seat[all[i].idx]); // reclaim seat\\n            }\\n        }\\n    }\\n\\n    private class Person {\\n        boolean leave;\\n        boolean arrive;\\n        int time;\\n        int idx;\\n        Person (int idx, int time, boolean leave, boolean arrive){\\n            this.time = time;\\n            this.leave = leave;\\n            this.arrive = arrive;\\n            this.idx = idx;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938370,
                "title": "simple-c-solution-easy-to-understand-beats-100-priority-queue-hashing",
                "content": "In question we are asked to allot the smallest possible chair available to the friend at the moment he/she arrives..!! Basically there are two possibilities\\n1.) When nth friend arrives, all n-1 friends are still there there chairs from 0 to n-1 are occupied and nth friend will get nth chair.\\n2.) When nth friend arrives, some friend from 0 to n-1 have left the party leaving their chairs unoccupied and now we have to allot the smallest of these chairs to nth friend.\\n\\nWe will use priority queue to return the smallest available chair and use hashing to store the chair occupied by ith friend.\\n```\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        priority_queue<int,vector<int>,greater<int>> pq;// min priority queue\\n        vector<pair<int,int>> v;\\n        unordered_map<int,int> map;\\n        int arrivaltime;\\n        for(int i=0;i<times.size();i++)\\n        {\\n           if(i==targetFriend)\\n           {\\n               arrivaltime=times[i][0]; \\n           }\\n            v.push_back({times[i][0],i+1}); // storing ith and -ith position to distinguish \\n            v.push_back({times[i][1],-i-1});// b/w arriving and leaving time of ith friend\\n        }\\n        \\n        sort(v.begin(),v.end()); // creating a timeline\\n        \\n        int curr=0;  \\n        int i=0;\\n        while(v[i].first<=arrivaltime) // we only need to find the chair alloted to    \\n        {                              // targetFriend \\n            if(v[i].second>0) // v[i].first is arriving time\\n            {\\n                if(pq.empty()) // 1st possibility when 0 to n-1 chairs are occupied.\\n                {\\n                    map[v[i].second]=curr;\\n                    curr++;\\n                }\\n                else // 2nd possibility \\n                {\\n                    map[v[i].second]=pq.top();\\n                    pq.pop();\\n                }\\n            }\\n            else // v[i].first is leaving time\\n            {\\n                pq.push(map[abs(v[i].second)]); // adding the unoccupied chair to priority queue\\n            }\\n            i++;\\n        }\\nreturn map[targetFriend+1]; \\n    } \\n\\t\\n\\n\\tIf you like the explanation and code,please leave a upvote..!! \\n\\tPeace.",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "In question we are asked to allot the smallest possible chair available to the friend at the moment he/she arrives..!! Basically there are two possibilities\\n1.) When nth friend arrives, all n-1 friends are still there there chairs from 0 to n-1 are occupied and nth friend will get nth chair.\\n2.) When nth friend arrives, some friend from 0 to n-1 have left the party leaving their chairs unoccupied and now we have to allot the smallest of these chairs to nth friend.\\n\\nWe will use priority queue to return the smallest available chair and use hashing to store the chair occupied by ith friend.\\n```\\nint smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        priority_queue<int,vector<int>,greater<int>> pq;// min priority queue\\n        vector<pair<int,int>> v;\\n        unordered_map<int,int> map;\\n        int arrivaltime;\\n        for(int i=0;i<times.size();i++)\\n        {\\n           if(i==targetFriend)\\n           {\\n               arrivaltime=times[i][0]; \\n           }\\n            v.push_back({times[i][0],i+1}); // storing ith and -ith position to distinguish \\n            v.push_back({times[i][1],-i-1});// b/w arriving and leaving time of ith friend\\n        }\\n        \\n        sort(v.begin(),v.end()); // creating a timeline\\n        \\n        int curr=0;  \\n        int i=0;\\n        while(v[i].first<=arrivaltime) // we only need to find the chair alloted to    \\n        {                              // targetFriend \\n            if(v[i].second>0) // v[i].first is arriving time\\n            {\\n                if(pq.empty()) // 1st possibility when 0 to n-1 chairs are occupied.\\n                {\\n                    map[v[i].second]=curr;\\n                    curr++;\\n                }\\n                else // 2nd possibility \\n                {\\n                    map[v[i].second]=pq.top();\\n                    pq.pop();\\n                }\\n            }\\n            else // v[i].first is leaving time\\n            {\\n                pq.push(map[abs(v[i].second)]); // adding the unoccupied chair to priority queue\\n            }\\n            i++;\\n        }\\nreturn map[targetFriend+1]; \\n    } \\n\\t\\n\\n\\tIf you like the explanation and code,please leave a upvote..!! \\n\\tPeace.",
                "codeTag": "Unknown"
            },
            {
                "id": 1931314,
                "title": "python-faster-than-99-07",
                "content": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        start = defaultdict(int)\\n        for idx, (startTime, endTime) in enumerate(times):\\n            start[startTime] = idx\\n        heap = []\\n        chairs = []\\n        newChairIdx = 0\\n        startTimes = sorted(list(start.keys()))\\n        \\n        for startTime in startTimes:\\n            # Freeing up chairs that are beyond their ending time\\n            while heap and heap[0][0] <= startTime:\\n                heapq.heappush(chairs, heapq.heappop(heap)[1])\\n            \\n            # Who am I assigning to?\\n            person = start[startTime]\\n            \\n            # Are there any available chairs at the moment?\\n            # If not, I will need to create a new one\\n            if len(chairs) != 0:\\n                assigned_chair = heapq.heappop(chairs)\\n            else:\\n                assigned_chair = newChairIdx\\n                newChairIdx += 1\\n            \\n            # Add [ending time, person] to heap\\n            heapq.heappush(heap, [times[person][1], assigned_chair])\\n            \\n            if person == targetFriend:\\n                return assigned_chair\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        start = defaultdict(int)\\n        for idx, (startTime, endTime) in enumerate(times):\\n            start[startTime] = idx\\n        heap = []\\n        chairs = []\\n        newChairIdx = 0\\n        startTimes = sorted(list(start.keys()))\\n        \\n        for startTime in startTimes:\\n            # Freeing up chairs that are beyond their ending time\\n            while heap and heap[0][0] <= startTime:\\n                heapq.heappush(chairs, heapq.heappop(heap)[1])\\n            \\n            # Who am I assigning to?\\n            person = start[startTime]\\n            \\n            # Are there any available chairs at the moment?\\n            # If not, I will need to create a new one\\n            if len(chairs) != 0:\\n                assigned_chair = heapq.heappop(chairs)\\n            else:\\n                assigned_chair = newChairIdx\\n                newChairIdx += 1\\n            \\n            # Add [ending time, person] to heap\\n            heapq.heappush(heap, [times[person][1], assigned_chair])\\n            \\n            if person == targetFriend:\\n                return assigned_chair\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929019,
                "title": "beats-100-percent-cpp-solution-priority-queue-hashing",
                "content": "class Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n    int n =times.size();\\n        vector<pair<int,int>>v;\\n        unordered_map<int,int>m;\\n         priority_queue<int, vector<int>, greater<int> > p;\\n        for(int i =0;i<times.size();i++){\\n            v.push_back({times[i][0],i+1});\\n            v.push_back({times[i][1],-i-1});\\n        }\\n        sort(v.begin(),v.end());\\n      \\n        int curr =1;\\n        \\n        m[v[0].second]=1;\\n        for(int i =1;i<v.size();i++){\\n          \\n                if(v[i].second<0){\\n            \\n                 \\n                    p.push(m[abs(v[i].second)]);\\n                    \\n                   \\n                }\\n                else{\\n                    if(p.size()==0){\\n                  \\n                    curr++;\\n                    m[v[i].second]=curr;\\n                    }\\n                    else{\\n                    \\n                        m[v[i].second]=p.top();\\n                        p.pop();\\n                    }\\n              \\n                }\\n            \\n        }\\n \\n       return m[targetFriend+1]-1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n    int n =times.size();\\n        vector<pair<int,int>>v;\\n        unordered_map<int,int>m;\\n         priority_queue<int, vector<int>, greater<int> > p;\\n        for(int i =0;i<times.size();i++){\\n            v.push_back({times[i][0],i+1}",
                "codeTag": "Java"
            },
            {
                "id": 1925545,
                "title": "c-priority-queue",
                "content": "```\\nclass node{\\npublic:\\n    int i,t,id;  // i = status(arriving or leaving),t=time,in = index \\n    node(int x,int y,int z){\\n       i=x,t=y,id=z;\\n    }\\n};\\nclass compare{\\npublic:\\n    int operator()(node &v1,node &v2){   \\n        if(v1.t==v2.t){\\n            return v1.i<v2.i;  // if time is same, \\n                              //then leaving instant will be given priority\\n        }\\n        else return v1.t>v2.t;  // less time will be given priority\\n    }\\n};\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& nums, int targetFriend) {\\n        priority_queue<node,vector<node>,compare> q;  // keeps the track of events going to happen\\n        priority_queue<int,vector<int>,greater<int>> seat; //keeps the track of smallest seat availble\\n        vector<int> mp(10001,-1);  // store the seat given to ith person\\n        vector<int> taken(10001,0); // keeps the track of seats in queue\\n        set<int> vis;  // keeps the track of non-available seats\\n        seat.push(0); taken[0] = 1;\\n        for(int i = 0; i<nums.size();++i){\\n            q.push(node(0,nums[i][0],i));  \\n            q.push(node(1,nums[i][1],i));\\n        }\\n        while(!q.empty()){\\n            node temp = q.top(); q.pop();\\n            if(temp.i){  // if somebody is leaving\\n                int st = mp[temp.id];\\n                seat.push(st); vis.erase(st);\\n            }\\n            else{ // if somebody is entering\\n                int k = seat.top(); seat.pop();\\n                if(vis.find(k+1)==vis.end() && taken[k+1]==0){  \\n                    seat.push(k+1);taken[k+1]=1; // push the next seat into queue\\n                }\\n                mp[temp.id] = k; vis.insert(k);\\n                if(temp.id==targetFriend) return k;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass node{\\npublic:\\n    int i,t,id;  // i = status(arriving or leaving),t=time,in = index \\n    node(int x,int y,int z){\\n       i=x,t=y,id=z;\\n    }\\n};\\nclass compare{\\npublic:\\n    int operator()(node &v1,node &v2){   \\n        if(v1.t==v2.t){\\n            return v1.i<v2.i;  // if time is same, \\n                              //then leaving instant will be given priority\\n        }\\n        else return v1.t>v2.t;  // less time will be given priority\\n    }\\n};\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& nums, int targetFriend) {\\n        priority_queue<node,vector<node>,compare> q;  // keeps the track of events going to happen\\n        priority_queue<int,vector<int>,greater<int>> seat; //keeps the track of smallest seat availble\\n        vector<int> mp(10001,-1);  // store the seat given to ith person\\n        vector<int> taken(10001,0); // keeps the track of seats in queue\\n        set<int> vis;  // keeps the track of non-available seats\\n        seat.push(0); taken[0] = 1;\\n        for(int i = 0; i<nums.size();++i){\\n            q.push(node(0,nums[i][0],i));  \\n            q.push(node(1,nums[i][1],i));\\n        }\\n        while(!q.empty()){\\n            node temp = q.top(); q.pop();\\n            if(temp.i){  // if somebody is leaving\\n                int st = mp[temp.id];\\n                seat.push(st); vis.erase(st);\\n            }\\n            else{ // if somebody is entering\\n                int k = seat.top(); seat.pop();\\n                if(vis.find(k+1)==vis.end() && taken[k+1]==0){  \\n                    seat.push(k+1);taken[k+1]=1; // push the next seat into queue\\n                }\\n                mp[temp.id] = k; vis.insert(k);\\n                if(temp.id==targetFriend) return k;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919190,
                "title": "c-easy-to-understand-priority-queue-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static comp(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[0]==b[0])\\n        {\\n            return a[2]<b[2];    \\n        }\\n        return a[0]<b[0];\\n    }\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        for(int i=0;i<times.size();i++)\\n        {\\n            times[i].push_back(i);\\n        }\\n        sort(times.begin(),times.end(),comp);\\n        set<int> unoccupied;\\n        int n=times.size();\\n        int ans;\\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<n;i++)\\n        unoccupied.insert(i);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!pq.empty()&&pq.top().first<=times[i][0])\\n            {\\n                unoccupied.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            int position=*(unoccupied.begin());\\n            if(targetFriend==times[i][2])\\n            {\\n                ans=position;\\n                break;\\n            }\\n            unoccupied.erase(unoccupied.begin());\\n            pq.push({times[i][1],position});\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static comp(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[0]==b[0])\\n        {\\n            return a[2]<b[2];    \\n        }\\n        return a[0]<b[0];\\n    }\\n    int smallestChair(vector<vector<int>>& times, int targetFriend) {\\n        for(int i=0;i<times.size();i++)\\n        {\\n            times[i].push_back(i);\\n        }\\n        sort(times.begin(),times.end(),comp);\\n        set<int> unoccupied;\\n        int n=times.size();\\n        int ans;\\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<n;i++)\\n        unoccupied.insert(i);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!pq.empty()&&pq.top().first<=times[i][0])\\n            {\\n                unoccupied.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            int position=*(unoccupied.begin());\\n            if(targetFriend==times[i][2])\\n            {\\n                ans=position;\\n                break;\\n            }\\n            unoccupied.erase(unoccupied.begin());\\n            pq.push({times[i][1],position});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901489,
                "title": "scala",
                "content": "```\\nimport scala.collection.immutable.{SortedMap, SortedSet}\\nimport scala.util.chaining.scalaUtilChainingOps\\n\\nobject Solution {\\n  def smallestChair(times: Array[Array[Int]], targetFriend: Int): Int = {\\n    /**\\n     * @param i a friend who is arriving\\n     * @return a function that, for each (j, _), returns true iff friend j departs no later than i arrives\\n     */\\n    def isDeparting(i: Int): ((Int, Int)) => Boolean = { case (j, _) => times(j)(1) <= times(i)(0) }\\n\\n    times\\n      .indices\\n      .sortBy(i => times(i)(0))\\n      .takeWhile(_ != targetFriend)\\n      .foldLeft(SortedMap[Int, Int]()(Ordering.by((i: Int) => (times(i)(1), i))), SortedSet[Int]()) {\\n        case ((friendToChair, openChairs), i) => friendToChair\\n          .dropWhile(isDeparting(i))\\n          .pipe(_ -> (openChairs ++ friendToChair.takeWhile(isDeparting(i)).valuesIterator))\\n          .pipe {\\n            case (friendToChair, openChairs) => openChairs.headOption match {\\n              case Some(chair) => (friendToChair + (i -> chair), openChairs.tail)\\n              case _ => (friendToChair + (i -> friendToChair.size), openChairs)\\n            }\\n          }\\n      }\\n      .pipe {\\n        case (friendToChair, openChairs) =>\\n          (openChairs ++ friendToChair.takeWhile(isDeparting(targetFriend)).valuesIterator)\\n            .headOption\\n            .getOrElse(friendToChair.size)\\n      }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Simulation"
                ],
                "code": "```\\nimport scala.collection.immutable.{SortedMap, SortedSet}\\nimport scala.util.chaining.scalaUtilChainingOps\\n\\nobject Solution {\\n  def smallestChair(times: Array[Array[Int]], targetFriend: Int): Int = {\\n    /**\\n     * @param i a friend who is arriving\\n     * @return a function that, for each (j, _), returns true iff friend j departs no later than i arrives\\n     */\\n    def isDeparting(i: Int): ((Int, Int)) => Boolean = { case (j, _) => times(j)(1) <= times(i)(0) }\\n\\n    times\\n      .indices\\n      .sortBy(i => times(i)(0))\\n      .takeWhile(_ != targetFriend)\\n      .foldLeft(SortedMap[Int, Int]()(Ordering.by((i: Int) => (times(i)(1), i))), SortedSet[Int]()) {\\n        case ((friendToChair, openChairs), i) => friendToChair\\n          .dropWhile(isDeparting(i))\\n          .pipe(_ -> (openChairs ++ friendToChair.takeWhile(isDeparting(i)).valuesIterator))\\n          .pipe {\\n            case (friendToChair, openChairs) => openChairs.headOption match {\\n              case Some(chair) => (friendToChair + (i -> chair), openChairs.tail)\\n              case _ => (friendToChair + (i -> friendToChair.size), openChairs)\\n            }\\n          }\\n      }\\n      .pipe {\\n        case (friendToChair, openChairs) =>\\n          (openChairs ++ friendToChair.takeWhile(isDeparting(targetFriend)).valuesIterator)\\n            .headOption\\n            .getOrElse(friendToChair.size)\\n      }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1892464,
                "title": "c-priority-queue-set-explained-in-comments",
                "content": "```\\nconst int INF=1e9;\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int target) {\\n        int i=0;\\n        for(auto &v:times){\\n            v.push_back(i);\\n            i++;\\n        }\\n        int start=times[target][2];\\n        sort(times.begin(),times.end(),[](const vector<int> &a,const vector<int>&b){\\n            if(a[0]==b[0]){\\n                return a[2]<b[2];\\n            } \\n            return a[0]<b[0];\\n        });\\n        int n=times.size();\\n        //to store information for pair (ending time,index no. of chair occupied)\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        set<int> free; // set of available seat no.\\n        int ans;\\n        for(int i=0;i<n;i++)free.insert(i); // all seats are free initially. Max n seats are required\\n        for(int i=0;i<n;i++){\\n            while(!pq.empty() && pq.top().first<=times[i][0]){\\n                free.insert(pq.top().second);\\n                pq.pop();   // leaving time is already over for this \\n            }\\n            int pos=*(free.begin()); //occupy smallest free\\n            if(times[i][2]==start){\\n                ans=pos; // if we get target, store pos of seat in ans\\n            }\\n            free.erase(free.begin()); //occupy smallest set // remove from free\\n            pq.push(make_pair(times[i][1],pos)); // put in occupied information\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int target) {\\n        int i=0;\\n        for(auto &v:times){\\n            v.push_back(i);\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1855817,
                "title": "line-sweep-java",
                "content": "```\\n        public int smallestChair(int[][] times, int targetFriend) {\\n\\n        int[][] arr = new int[times.length*2][3];\\n        int a = 0;\\n        for (int i = 0; i < times.length; i++) {\\n            arr[a++] = new int[] {times[i][0],1, i};  // 1 arriving\\n            arr[a++] = new int[] {times[i][1],0, i}; // 0 leaving\\n        }\\n        Arrays.sort(arr, (o1, o2) -> {\\n            if (o1[0] == o2[0]) {\\n                if (o1[1] == 0) {\\n                    return -1;\\n                } else return 1;\\n            }\\n            return o1[0] - o2[0];\\n        });\\n\\n        PriorityQueue<Integer> chairs = new PriorityQueue<>();\\n        for (int i = 0; i < times.length; i++) {\\n            chairs.add(i);\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i][1] == 1) {\\n                int chair = chairs.poll();\\n                if (arr[i][2] == targetFriend) {\\n                    return chair;\\n                }\\n                map.put(arr[i][2], chair);\\n            } else {\\n                Integer chair = map.get(arr[i][2]);\\n                map.remove(arr[i][2]);\\n                chairs.add(chair);\\n            }\\n        }\\n        return -1;\\n\\n    }",
                "solutionTags": [],
                "code": "```\\n        public int smallestChair(int[][] times, int targetFriend) {\\n\\n        int[][] arr = new int[times.length*2][3];\\n        int a = 0;\\n        for (int i = 0; i < times.length; i++) {\\n            arr[a++] = new int[] {times[i][0],1, i};  // 1 arriving\\n            arr[a++] = new int[] {times[i][1],0, i}; // 0 leaving\\n        }\\n        Arrays.sort(arr, (o1, o2) -> {\\n            if (o1[0] == o2[0]) {\\n                if (o1[1] == 0) {\\n                    return -1;\\n                } else return 1;\\n            }\\n            return o1[0] - o2[0];\\n        });\\n\\n        PriorityQueue<Integer> chairs = new PriorityQueue<>();\\n        for (int i = 0; i < times.length; i++) {\\n            chairs.add(i);\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i][1] == 1) {\\n                int chair = chairs.poll();\\n                if (arr[i][2] == targetFriend) {\\n                    return chair;\\n                }\\n                map.put(arr[i][2], chair);\\n            } else {\\n                Integer chair = map.get(arr[i][2]);\\n                map.remove(arr[i][2]);\\n                chairs.add(chair);\\n            }\\n        }\\n        return -1;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1854824,
                "title": "java-simple-solution-using-priorityqueue-hashmap",
                "content": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        PriorityQueue<int[]> friends = new PriorityQueue<>((a,b) -> a[0] - b[0]);\\n        \\n        HashMap<Integer, List<Integer>> leaving_chair = new HashMap<>();\\n        \\n        int index = 0;\\n        \\n        for(int[] time: times){\\n            friends.offer(new int[]{time[0], time[1], index++});\\n            \\n            leaving_chair.putIfAbsent(time[1], new ArrayList<>());\\n        }\\n        \\n        PriorityQueue<Integer> chairs = new PriorityQueue<>();\\n        \\n        int newChair = 0;\\n        \\n        int time = friends.peek()[0];\\n        \\n        while(!friends.isEmpty()){\\n            if(leaving_chair.containsKey(time)){\\n                for(int i: leaving_chair.get(time))\\n                    chairs.offer(i);\\n            }\\n            if(friends.peek()[0] == time){\\n                int friend = friends.peek()[2];\\n                int arrival = friends.peek()[0];\\n                int leaving = friends.poll()[1];\\n\\n                int chair = 0;\\n\\n                if(!chairs.isEmpty())\\n                    chair = chairs.poll();\\n                else\\n                    chair = newChair++;\\n\\n                leaving_chair.get(leaving).add(chair);\\n\\n                if(friend == targetFriend)\\n                    return chair;\\n            }\\n            time++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        PriorityQueue<int[]> friends = new PriorityQueue<>((a,b) -> a[0] - b[0]);\\n        \\n        HashMap<Integer, List<Integer>> leaving_chair = new HashMap<>();\\n        \\n        int index = 0;\\n        \\n        for(int[] time: times){\\n            friends.offer(new int[]{time[0], time[1], index++});\\n            \\n            leaving_chair.putIfAbsent(time[1], new ArrayList<>());\\n        }\\n        \\n        PriorityQueue<Integer> chairs = new PriorityQueue<>();\\n        \\n        int newChair = 0;\\n        \\n        int time = friends.peek()[0];\\n        \\n        while(!friends.isEmpty()){\\n            if(leaving_chair.containsKey(time)){\\n                for(int i: leaving_chair.get(time))\\n                    chairs.offer(i);\\n            }\\n            if(friends.peek()[0] == time){\\n                int friend = friends.peek()[2];\\n                int arrival = friends.peek()[0];\\n                int leaving = friends.poll()[1];\\n\\n                int chair = 0;\\n\\n                if(!chairs.isEmpty())\\n                    chair = chairs.poll();\\n                else\\n                    chair = newChair++;\\n\\n                leaving_chair.get(leaving).add(chair);\\n\\n                if(friend == targetFriend)\\n                    return chair;\\n            }\\n            time++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850696,
                "title": "easy-undersatnding",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int t)\\n    {\\n        int n = times.size();\\n        priority_queue< pair<int,int> , vector<pair<int,int>> , greater<pair<int,int>> > pq;\\n        priority_queue<int ,vector<int>, greater<int>>q;\\n        \\n        int tar = times[t][0];\\n        sort(times.begin(),times.end());\\n        \\n\\n        int cnt = 0; \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int arrival = times[i][0];\\n            int dep = times[i][1];\\n            \\n            while(!pq.empty() && pq.top().first<=arrival)\\n            {\\n                auto chair = pq.top().second;\\n                q.push(chair);\\n                pq.pop();\\n            }\\n            \\n            \\n            if(arrival == tar)\\n            {\\n                if(!q.empty())return q.top();\\n                return cnt;\\n            }\\n            \\n            else\\n            {\\n              int kk;\\n              if(q.empty())\\n                {\\n                   kk=cnt;\\n                   cnt++;\\n                }\\n                else\\n                {\\n                  kk = q.top();q.pop();\\n                }\\n             pq.push({dep,kk}); \\n            }\\n           \\n         \\n          \\n        }\\n        \\n        return pq.size()-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestChair(vector<vector<int>>& times, int t)\\n    {\\n        int n = times.size();\\n        priority_queue< pair<int,int> , vector<pair<int,int>> , greater<pair<int,int>> > pq;\\n        priority_queue<int ,vector<int>, greater<int>>q;\\n        \\n        int tar = times[t][0];\\n        sort(times.begin(),times.end());\\n        \\n\\n        int cnt = 0; \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int arrival = times[i][0];\\n            int dep = times[i][1];\\n            \\n            while(!pq.empty() && pq.top().first<=arrival)\\n            {\\n                auto chair = pq.top().second;\\n                q.push(chair);\\n                pq.pop();\\n            }\\n            \\n            \\n            if(arrival == tar)\\n            {\\n                if(!q.empty())return q.top();\\n                return cnt;\\n            }\\n            \\n            else\\n            {\\n              int kk;\\n              if(q.empty())\\n                {\\n                   kk=cnt;\\n                   cnt++;\\n                }\\n                else\\n                {\\n                  kk = q.top();q.pop();\\n                }\\n             pq.push({dep,kk}); \\n            }\\n           \\n         \\n          \\n        }\\n        \\n        return pq.size()-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842362,
                "title": "welcome-to-python-is-easy",
                "content": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], t: int) -> int:\\n        sor=sorted(times)\\n        que=deque([])\\n        poped=deque([i for i in range(10**4)])\\n        for i,j in sor:\\n            while que and que[0][0]<=i:\\n                bisect.insort(poped,que.popleft()[2])\\n            x=poped.popleft()\\n            bisect.insort(que,[j,i,x])\\n            if [i,j]==times[t]:\\n                return x\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], t: int) -> int:\\n        sor=sorted(times)\\n        que=deque([])\\n        poped=deque([i for i in range(10**4)])\\n        for i,j in sor:\\n            while que and que[0][0]<=i:\\n                bisect.insort(poped,que.popleft()[2])\\n            x=poped.popleft()\\n            bisect.insort(que,[j,i,x])\\n            if [i,j]==times[t]:\\n                return x\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829129,
                "title": "python-heapq",
                "content": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        available, heap = [],[]\\n        t = sorted([(a,b,i) for i,(a,b) in enumerate(times)])\\n        for start,end,ind in t:\\n            while heap and start >= heap[0][0]:\\n                heappush(available,heappop(heap)[1])\\n            if ind == targetFriend:\\n                return available[0] if available else len(heap)\\n            if available:\\n                heappush(heap,(end,heappop(available)))\\n            else:\\n                heappush(heap,(end,len(heap)))\\n  ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        available, heap = [],[]\\n        t = sorted([(a,b,i) for i,(a,b) in enumerate(times)])\\n        for start,end,ind in t:\\n            while heap and start >= heap[0][0]:\\n                heappush(available,heappop(heap)[1])\\n            if ind == targetFriend:\\n                return available[0] if available else len(heap)\\n            if available:\\n                heappush(heap,(end,heappop(available)))\\n            else:\\n                heappush(heap,(end,len(heap)))\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1827399,
                "title": "python-solution",
                "content": "```\\nfrom queue import PriorityQueue\\nfrom functools import cmp_to_key\\n\\ndef compare(e1, e2):\\n    if e1[1] == e2[1]:\\n        return e1[2] - e2[2]\\n    return e1[1] - e2[1]\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        events = []\\n        for idx, time in enumerate(times):\\n            # 1 as arrival, 0 as leaving in event[2]\\n            events.append((idx, time[0], 1))\\n            events.append((idx, time[1], 0))\\n        events.sort(key = cmp_to_key(compare))  #O(nlogn)\\n        \\n        seat_dict = {}\\n        heap = PriorityQueue() # to keep the chairs that are freed from left friends\\n        heap.put(0)\\n        \\n\\t\\t# O(nlogn) n for event, logn for heap operation\\n        for event in events:\\n            friend_id = event[0]\\n            action = event[2]\\n            if action == 1:\\n                seat = heap.get()\\n                if heap.empty():\\n                    heap.put(seat + 1)\\n                seat_dict[friend_id] = seat\\n                \\n                if friend_id == targetFriend:\\n                    return seat\\n            if action == 0:\\n                heap.put(seat_dict[friend_id])\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nfrom queue import PriorityQueue\\nfrom functools import cmp_to_key\\n\\ndef compare(e1, e2):\\n    if e1[1] == e2[1]:\\n        return e1[2] - e2[2]\\n    return e1[1] - e2[1]\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        events = []\\n        for idx, time in enumerate(times):\\n            # 1 as arrival, 0 as leaving in event[2]\\n            events.append((idx, time[0], 1))\\n            events.append((idx, time[1], 0))\\n        events.sort(key = cmp_to_key(compare))  #O(nlogn)\\n        \\n        seat_dict = {}\\n        heap = PriorityQueue() # to keep the chairs that are freed from left friends\\n        heap.put(0)\\n        \\n\\t\\t# O(nlogn) n for event, logn for heap operation\\n        for event in events:\\n            friend_id = event[0]\\n            action = event[2]\\n            if action == 1:\\n                seat = heap.get()\\n                if heap.empty():\\n                    heap.put(seat + 1)\\n                seat_dict[friend_id] = seat\\n                \\n                if friend_id == targetFriend:\\n                    return seat\\n            if action == 0:\\n                heap.put(seat_dict[friend_id])\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807435,
                "title": "python-simple-and-easy-single-priority-queue-code",
                "content": "```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        q = PriorityQueue()\\n        for i, (start, end) in enumerate(times):\\n            q.put((start, 1, i))\\n            q.put((end, 0, i))\\n        \\n        chair = [0] * len(times)\\n        picked_chairs = {}\\n        \\n        while not q.empty():\\n            _, which, i = q.get()\\n            if i == targetFriend:\\n                return chair.index(0)\\n            elif which == 1:\\n                picked_chairs[i] = chair.index(0)\\n                chair[picked_chairs[i]] = 1\\n            else:\\n                chair[picked_chairs[i]] = 0\\n        \\n        return -1",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        q = PriorityQueue()\\n        for i, (start, end) in enumerate(times):\\n            q.put((start, 1, i))\\n            q.put((end, 0, i))\\n        \\n        chair = [0] * len(times)\\n        picked_chairs = {}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1939935,
                "content": [
                    {
                        "username": "Dominator_123",
                        "content": "Seems to be a bit towards hard side not medium."
                    },
                    {
                        "username": "zayne-siew",
                        "content": "## Question\\n\\nFor this problem, the constraints state that\\n\\n> Each $$arrival_{i}$$ time is distinct.\\n\\nAs a follow-up question, how should we modify the code to handle cases where this constraint is relaxed (i.e., when $$arrival_{i}$$ is no longer distinct)? This introduces cases $$arrival_{i} \\\\le arrival_{j} ,\\\\ leaving_{i} \\\\le leaving_{j} ,\\\\ i \\\\ne j$$ where simple sorting does not necessarily work.\\n\\n\\n## Sample test-case\\n\\nInput: `times = [[1,5],[1,5],[1,5]], targetFriend = 1`\\nOutput: `0`\\nExplanation: Since all three friends arrive at the exact same time, the smallest chair that the target friend can sit on is the smallest chair available, which is `0`.\\n\\n## Intuition\\n\\nI\\'ve not tried to implement this follow-up question yet, but some methods that I can think of include:\\n\\n- Giving top-most priority to `targetFriend` (and therefore processing it first)\\n- Excluding all $$arrival_{i} \\\\ge arrival_{targetFriend} ,\\\\ i \\\\ne targetFriend$$ from `times` before processing\\n\\nNot sure which one is the most efficient, what do you guys think?"
                    }
                ]
            },
            {
                "id": 1772289,
                "content": [
                    {
                        "username": "Dominator_123",
                        "content": "Seems to be a bit towards hard side not medium."
                    },
                    {
                        "username": "zayne-siew",
                        "content": "## Question\\n\\nFor this problem, the constraints state that\\n\\n> Each $$arrival_{i}$$ time is distinct.\\n\\nAs a follow-up question, how should we modify the code to handle cases where this constraint is relaxed (i.e., when $$arrival_{i}$$ is no longer distinct)? This introduces cases $$arrival_{i} \\\\le arrival_{j} ,\\\\ leaving_{i} \\\\le leaving_{j} ,\\\\ i \\\\ne j$$ where simple sorting does not necessarily work.\\n\\n\\n## Sample test-case\\n\\nInput: `times = [[1,5],[1,5],[1,5]], targetFriend = 1`\\nOutput: `0`\\nExplanation: Since all three friends arrive at the exact same time, the smallest chair that the target friend can sit on is the smallest chair available, which is `0`.\\n\\n## Intuition\\n\\nI\\'ve not tried to implement this follow-up question yet, but some methods that I can think of include:\\n\\n- Giving top-most priority to `targetFriend` (and therefore processing it first)\\n- Excluding all $$arrival_{i} \\\\ge arrival_{targetFriend} ,\\\\ i \\\\ne targetFriend$$ from `times` before processing\\n\\nNot sure which one is the most efficient, what do you guys think?"
                    }
                ]
            }
        ]
    }
]